! ###################################################################
! Copyright (c) 2013-2019, Marc De Graef Research Group/Carnegie Mellon University
! All rights reserved.
!
! Redistribution and use in source and binary forms, with or without modification, are 
! permitted provided that the following conditions are met:
!
!     - Redistributions of source code must retain the above copyright notice, this list 
!        of conditions and the following disclaimer.
!     - Redistributions in binary form must reproduce the above copyright notice, this 
!        list of conditions and the following disclaimer in the documentation and/or 
!        other materials provided with the distribution.
!     - Neither the names of Marc De Graef, Carnegie Mellon University nor the names 
!        of its contributors may be used to endorse or promote products derived from 
!        this software without specific prior written permission.
!
! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
! ###################################################################
!--------------------------------------------------------------------------
! EMsoft:EBSDmod.f90
!--------------------------------------------------------------------------
!
! MODULE: EBSDmod
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief EMEBSD helper routines
!
!> @date  06/24/14  MDG 1.0 original, lifted from EMEBSD.f90 to simplify code
!> @date  09/01/15  MDG 1.1 modified EBSDMasterDIType definition to accommodate multiple Lambert maps
!> @date  09/15/15  SS  1.2 added accum_z to EBSDLargeAccumDIType
!--------------------------------------------------------------------------
module EBSDDImod


use local
use typedefs
use stringconstants

IMPLICIT NONE

type EBSDAngleDIType
        real(kind=sgl),allocatable      :: quatang(:,:)
end type EBSDAngleDIType

type EBSDLargeAccumDIType
        integer(kind=irg),allocatable   :: accum_e(:,:,:),accum_z(:,:,:,:)
        real(kind=sgl),allocatable      :: accum_e_detector(:,:,:)
end type EBSDLargeAccumDIType

type EBSDMasterDIType
        real(kind=sgl),allocatable      :: mLPNH(:,:,:) , mLPSH(:,:,:)
        real(kind=sgl),allocatable      :: rgx(:,:), rgy(:,:), rgz(:,:)          ! auxiliary detector arrays needed for interpolation
end type EBSDMasterDIType
        
type EBSDDIdataType
  integer(kind=irg)             :: FZcnt
  integer(kind=irg)             :: Nexp
  integer(kind=irg)             :: pgnum
  real(kind=sgl),allocatable    :: ADP(:)
  real(kind=sgl),allocatable    :: AverageOrientations(:,:)
  real(kind=sgl),allocatable    :: CI(:)
  real(kind=sgl),allocatable    :: EulerAngles(:,:)
  real(kind=sgl),allocatable    :: Fit(:)
  real(kind=sgl),allocatable    :: IQ(:)
  real(kind=sgl),allocatable    :: KAM(:,:)
  real(kind=sgl),allocatable    :: OSM(:,:)
  integer(kind=irg),allocatable :: Phase(:)
  real(kind=sgl),allocatable    :: Phi1(:)
  real(kind=sgl),allocatable    :: Phi(:)
  real(kind=sgl),allocatable    :: Phi2(:)
  integer(kind=irg),allocatable :: SEMsignal(:)
  real(kind=sgl),allocatable    :: TopDotProductList(:,:)
  integer(kind=irg),allocatable :: TopMatchIndices(:,:)
  integer(kind=irg),allocatable :: Valid(:)
  real(kind=sgl),allocatable    :: XPosition(:)
  real(kind=sgl),allocatable    :: YPosition(:)
  real(kind=sgl),allocatable    :: RefinedEulerAngles(:,:)
  real(kind=sgl),allocatable    :: RefinedDotProducts(:)
end type EBSDDIdataType


contains

!--------------------------------------------------------------------------
!
! FUNCTION: getExpEBSDpatterns
!
!> @author Marc De Graef
!
!> @brief Read an array of nx x ny x np experimental EBSD patterns from an HDF5 input file
!
!> @detail For now, the only HDF5 input file format is the one generated by the TSL software;
!> this will be updated at a later time to include potential other vendor formats.
!
!> @param enl EBSD cluster name list structure
!
!> @date 12/28/15 MDG 1.0 original
!--------------------------------------------------------------------------
recursive function getExpEBSDpatterns(enl) result(rdata)
!DEC$ ATTRIBUTES DLLEXPORT :: getExpEBSDpatterns

use local
use typedefs
use NameListTypedefs
use HDF5
use HDFsupport

type(EBSDclusterNameListType),INTENT(INOUT)     :: enl
real(kind=dbl),allocatable                      :: rdata(:,:,:)

character(len=1), allocatable                   :: cdata(:,:,:)
integer(kind=irg)                               :: hdferr, i, j, k
integer(HSIZE_T)                                :: rdims(3)
character(fnlen)                                :: datafile, groupname, dataset

type(HDFobjectStackType),pointer                :: HDF_head

! Initialize FORTRAN interface.
!
nullify(HDF_head)

! Open the HDF5 file  in readonly mode
datafile = trim(EMsoft_getEMdatapathname())//trim(enl%inputfilename)
datafile = EMsoft_toNativePath(datafile)

hdferr =  HDF_openFile(datafile, HDF_head, .TRUE.)

! open the correct group (only the Scan group should be entered in the namelist file)
groupname = trim(enl%groupname)//'/EBSD/Data'
hdferr = HDF_openGroup(groupname, HDF_head)

! open the correct dataset and read the data
dataset = trim(enl%datasetname)
call HDF_readDatasetCharArray3D(dataset, rdims, HDF_head, hdferr, cdata)

call HDF_pop(HDF_head)

! get the number of image columns and rows in the EBSD data set
groupname = trim(enl%groupname)//'/EBSD/Header'
hdferr = HDF_openGroup(groupname, HDF_head)

! open the correct dataset and read the data
dataset = SC_nColumns
call HDF_readDatasetInteger(dataset, HDF_head, hdferr, enl%NScanColumns)

dataset = SC_nRows
call HDF_readDatasetInteger(dataset, HDF_head, hdferr, enl%NScanRows)

! close the datafile
call HDF_pop(HDF_head,.TRUE.)

! convert to double precision intensities between 0 and 1
allocate(rdata(1:rdims(1),1:rdims(2),1:rdims(3)))
do k=1,rdims(3)
  do j=1,rdims(2)
    do i=1,rdims(1)
      rdata(i,j,k) = dble(ichar(cdata(i,j,k)))
    end do
  end do
end do
rdata = rdata/maxval(rdata)

deallocate(cdata)

end function getExpEBSDpatterns

!--------------------------------------------------------------------------
!
! SUBROUTINE: EBSDprepExpPatterns
!
!> @author Marc De Graef
!
!> @brief Read an array of nx x ny x np experimental EBSD patterns from an HDF5 input file
!
!> @param rdata experimental EBSD patterns; will be modified on output
!> @param dims dimensions of rdata array
!> @param w hi-pass filter mask semi-edge length (mask is square)
!> @param applymask OPTIONAL apply circular mask
!> @param normalize OPTIONAL normalize each pattern to unit total intensity
!
!> @date 12/28/15 MDG 1.0 original
!> @date 01/05/15 MDG 1.1 added w parameter to set size of hi-pass filter window
!--------------------------------------------------------------------------
recursive subroutine EBSDprepExpPatterns(enl,rdata,dims,w,applymask,normalize) 
!DEC$ ATTRIBUTES DLLEXPORT :: EBSDprepExpPatterns

use local
use typedefs
use NameListTypedefs
use HDF5
use HDFsupport
use FFTW3mod
use io

type(EBSDclusterNameListType),INTENT(IN):: enl
integer(kind=irg),INTENT(IN)            :: dims(3)
integer(kind=irg),INTENT(IN)            :: w
real(kind=dbl),INTENT(INOUT)            :: rdata(dims(1),dims(2),dims(3))
logical,INTENT(IN),OPTIONAL             :: applymask
logical,INTENT(IN),OPTIONAL             :: normalize

complex(kind=dbl)                       :: hpmask(dims(1),dims(2)) 
real(kind=dbl)                          :: cmask(dims(1),dims(2)), pat(dims(1),dims(2)), r2, shx, shy, r
integer(kind=irg)                       :: i, j, k
complex(kind=dbl)                       :: cone = cmplx(1.D0,0.D0), czero = cmplx(0.D0,0.D0), cimag = cmplx(0.D0,1.D0)

! fftw variables
type(C_PTR)                             :: planf, planb
complex(C_DOUBLE_COMPLEX)               :: inp(dims(1),dims(2)), outp(dims(1),dims(2))

! first of all, we compute the high-pass filtering mask (will become variable size in future)
! we simply create a square array of complex zeroes centered on the origin
hpmask = cone
hpmask(1:w,1:w) = czero
hpmask(dims(1)-w:dims(1),1:w) = czero
hpmask(1:w,dims(2)-w:dims(2)) = czero
hpmask(dims(1)-w:dims(1),dims(2)-w:dims(2)) = czero

call Message('EBSDprepExpPatterns: performing hi-pass FFT filtering')

! then we set up the fftw plans for forward and reverse transforms
planf = fftw_plan_dft_2d(dims(2),dims(1),inp,outp, FFTW_FORWARD, FFTW_ESTIMATE)
planb = fftw_plan_dft_2d(dims(2),dims(1),inp,outp, FFTW_BACKWARD, FFTW_ESTIMATE)

! and we apply the hi-pass mask to each pattern
do i=1,dims(3)
  do j=1,dims(1)
   do k=1,dims(1)
    inp(j,k) = cmplx(rdata(j,k,i),0.D0)    
   end do
  end do
  call fftw_execute_dft(planf, inp, outp)
  inp = outp * hpmask
  call fftw_execute_dft(planb, inp, outp) 
  rdata(1:dims(1),1:dims(2),i) = real(outp)
end do

call fftw_destroy_plan(planf)
call fftw_destroy_plan(planb)
call fftw_cleanup()

! do we need to bin the patterns down ?
if (enl%binfactor.ne.1) then
  call Message('EBSDprepExpPatterns: binning patterns (to be implemented)')
end if

! do we need to apply a circular mask to these patterns ?
if (PRESENT(applymask)) then
  if (applymask) then
    call Message('EBSDprepExpPatterns: applying circular mask')
! initialize the circular mask first
    cmask = 0.D0
    r2 = ( dble(minval( (/ dims(1), dims(2) /) ))* 0.5D0 )**2
    shx = dble(dims(1))*0.5D0
    shy = dble(dims(2))*0.5D0
    do i=1,dims(1)
      do j=1,dims(2)
        r = (dble(i)-shx)**2 + (dble(j)-shy)**2
        if (r.le.r2) cmask(i,j) = 1.D0
      end do
    end do
! then apply it to all the patterns
    do k=1,dims(3)
      pat = rdata(1:dims(1),1:dims(2),k) * cmask
      rdata(1:dims(1),1:dims(2),k) = pat
    end do
  end if
end if

! do we need to normalize all the patterns ?
if (PRESENT(normalize)) then
  if (normalize) then
    call Message('EBSDprepExpPatterns: normalizing patterns')
    do k=1,dims(3)
      pat = rdata(1:dims(1),1:dims(2),k)
      r = dsqrt(sum(pat*pat))
      pat = pat / r
      rdata(1:dims(1),1:dims(2),k) = pat
    end do
  end if
end if

end subroutine EBSDprepExpPatterns


!--------------------------------------------------------------------------
!
! SUBROUTINE:EBSDIndexingreadMCfile
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief read angles from an angle file
!
!> @param enl EBSD name list structure
!> @param acc energy structure
!
!> @date 06/24/14  MDG 1.0 original
!> @date 11/18/14  MDG 1.1 removed enl%MCnthreads from file read
!> @date 04/02/15  MDG 2.0 changed program input & output to HDF format
!> @date 04/29/15  MDG 2.1 add optional parameter efile
!> @date 09/15/15  SS  2.2 added accum_z reading
!> @date 01/26/16  SS  2.3 adjusted for EBSDIndexing 
!> @date 10/11/16  MDG 2.4 conversion to new HDF5 file organization
!--------------------------------------------------------------------------
recursive subroutine EBSDIndexingreadMCfile(enl,acc,efile,verbose,NoHDFInterfaceOpen)
!DEC$ ATTRIBUTES DLLEXPORT :: EBSDIndexingreadMCfile

use local
use typedefs
use NameListTypedefs
use files
use io
use EBSDmod
use HDF5
use HDFsupport
use error

IMPLICIT NONE

type(EBSDIndexingNameListType),INTENT(INOUT)    :: enl
type(EBSDLargeAccumDIType),pointer              :: acc
character(fnlen),INTENT(IN),OPTIONAL            :: efile
logical,INTENT(IN),OPTIONAL                     :: verbose
logical,INTENT(IN),OPTIONAL                     :: NoHDFInterfaceOpen

type(MCCLNameListType)                          :: mcnl
type(EBSDMCdataType)                            :: EBSDMCdata
integer(kind=irg)                               :: istat, hdferr, nx, sz3(3), sz4(4)
logical                                         :: stat, HDFopen
character(fnlen)                                :: energyfile 

! is the efile parameter present? If so, use it as the filename, otherwise use the enl%energyfile parameter
if (PRESENT(efile)) then
  energyfile = efile
else
  energyfile = trim(EMsoft_getEMdatapathname())//trim(enl%energyfile)
end if
energyfile = EMsoft_toNativePath(energyfile)

HDFopen = .TRUE.
if (present(NoHDFInterfaceOpen)) then
  if (NoHDFInterfaceOpen.eqv..FALSE.) HDFopen = .FALSE.
end if 

allocate(acc)

if (HDFopen.eqv..TRUE.) call h5open_EMsoft(hdferr)
call readEBSDMonteCarloFile(enl%energyfile, mcnl, hdferr, EBSDMCdata, getAccumz=.TRUE., getAccume=.TRUE.)
if (HDFopen.eqv..TRUE.) call h5close_EMsoft(hdferr)

! copy all the necessary variables from the mcnl namelist group
enl%MCxtalname = trim(mcnl%xtalname)
enl%MCmode = mcnl%MCmode
!if (enl%MCmode .ne. 'full') call FatalError('EBSDIndexingreadMCfile','File not in full mode. Please input correct HDF5 file')

enl%nsx = (mcnl%numsx - 1)/2
enl%nsy = enl%nsx

enl%EkeV = mcnl%EkeV
enl%Ehistmin = mcnl%Ehistmin

enl%Ebinsize = mcnl%Ebinsize
enl%depthmax = mcnl%depthmax
enl%depthstep = mcnl%depthstep
enl%MCsig = mcnl%sig
enl%MComega = mcnl%omega
enl%totnum_el = EBSDMCdata%totnum_el
enl%multiplier = EBSDMCdata%multiplier

! it is not clear whether or not these are really ever used ...  
! a grep of all the source code shows that they are not used at all
! dataset = SC_ProgramName
!   call HDF_readDatasetStringArray(dataset, nlines, HDF_head, hdferr, stringarray)
!   enl%MCprogname = trim(stringarray(1))
!   deallocate(stringarray)

! dataset = SC_Version
!   call HDF_readDatasetStringArray(dataset, nlines, HDF_head, hdferr, stringarray)
!   enl%MCscversion = trim(stringarray(1))
!   deallocate(stringarray)

enl%numEbins = EBSDMCdata%numEbins
enl%numzbins = EBSDMCdata%numzbins
enl%num_el = sum(EBSDMCdata%accum_e)
sz3 = shape(EBSDMCdata%accum_e)
nx = (sz3(2)-1)/2
allocate(acc%accum_e(1:sz3(1),-nx:nx,-nx:nx))
acc%accum_e = EBSDMCdata%accum_e
deallocate(EBSDMCdata%accum_e)
  
sz4 = shape(EBSDMCdata%accum_z)
allocate(acc%accum_z(1:sz4(1),1:sz4(2),1:sz4(3),1:sz4(4)))
acc%accum_z = EBSDMCdata%accum_z
deallocate(EBSDMCdata%accum_z)

if (present(verbose)) call Message(' -> completed reading Monte Carlo data from '//trim(enl%energyfile), frm = "(A)")

end subroutine EBSDIndexingreadMCfile

!--------------------------------------------------------------------------
!
! SUBROUTINE:EBSDIndexingreadMasterfile
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief read EBSD master pattern from file
!
!> @param enl EBSD name list structure
!> @param 
!
!> @date 06/24/14  MDG 1.0 original
!> @date 04/02/15  MDG 2.0 changed program input & output to HDF format
!> @date 09/01/15  MDG 3.0 changed Lambert maps to Northern + Southern maps; lots of changes...
!> @date 09/03/15  MDG 3.1 removed support for old file format (too difficult to maintain after above changes)
!> @date 01/26/16  SS  3.2 adjusted for EBSDIndexing 
!--------------------------------------------------------------------------
recursive subroutine EBSDIndexingreadMasterfile(enl, master, mfile, verbose, NoHDFInterfaceOpen)
!DEC$ ATTRIBUTES DLLEXPORT :: EBSDIndexingreadMasterfile

use local
use typedefs
use NameListTypedefs
use files
use io
use error
use HDF5
use HDFsupport


IMPLICIT NONE

type(EBSDIndexingNameListType),INTENT(INOUT)    :: enl
type(EBSDMasterDIType),pointer                  :: master
character(fnlen),INTENT(IN),OPTIONAL            :: mfile
logical,INTENT(IN),OPTIONAL                     :: verbose
logical,OPTIONAL,INTENT(IN)                     :: NoHDFInterfaceOpen

real(kind=sgl),allocatable                      :: mLPNH(:,:,:) 
real(kind=sgl),allocatable                      :: mLPSH(:,:,:) 
real(kind=sgl),allocatable                      :: EkeVs(:) 
integer(kind=irg),allocatable                   :: atomtype(:)

real(kind=sgl),allocatable                      :: srtmp(:,:,:,:)
integer(kind=irg)                               :: istat

logical                                         :: stat, readonly, HDFopen 
integer(kind=irg)                               :: hdferr, nlines
integer(HSIZE_T)                                :: dims(1), dims4(4)
character(fnlen)                                :: groupname, dataset, masterfile
character(fnlen),allocatable                    :: stringarray(:)

type(HDFobjectStackType),pointer                :: HDF_head

HDFopen = .TRUE.
if (present(NoHDFInterfaceOpen)) then
  if (NoHDFInterfaceOpen.eqv..FALSE.) HDFopen = .FALSE.
end if 

! open the fortran HDF interface
if (HDFopen.eqv..TRUE.) call h5open_EMsoft(hdferr)

nullify(HDF_head, HDF_head)

! is the mfile parameter present? If so, use it as the filename, otherwise use the enl%masterfile parameter
if (PRESENT(mfile)) then
  masterfile = mfile
else
  masterfile = trim(EMsoft_getEMdatapathname())//trim(enl%masterfile)
end if
masterfile = EMsoft_toNativePath(masterfile)

! is this a proper HDF5 file ?
call h5fis_hdf5_f(trim(masterfile), stat, hdferr)

if (stat) then 
! open the master file 
  readonly = .TRUE.
  hdferr =  HDF_openFile(masterfile, HDF_head, readonly)

! open the namelist group
groupname = SC_NMLparameters
  hdferr = HDF_openGroup(groupname, HDF_head)

groupname = SC_EBSDMasterNameList
  hdferr = HDF_openGroup(groupname, HDF_head)

! read all the necessary variables from the namelist group
dataset = SC_energyfile
  call HDF_readDatasetStringArray(dataset, nlines, HDF_head, hdferr, stringarray)
  enl%Masterenergyfile = trim(stringarray(1))
  deallocate(stringarray)

dataset = SC_npx
  call HDF_readDatasetInteger(dataset, HDF_head, hdferr, enl%npx)
  enl%npy = enl%npx

  call HDF_pop(HDF_head)
  call HDF_pop(HDF_head)

groupname = SC_EMData
  hdferr = HDF_openGroup(groupname, HDF_head)

groupname = SC_EBSDmaster
  hdferr = HDF_openGroup(groupname, HDF_head)

dataset = SC_numEbins
  call HDF_readDatasetInteger(dataset, HDF_head, hdferr, enl%nE)
! make sure that MC and Master results are compatible
  if ((enl%numEbins.ne.enl%nE).and.(.not.PRESENT(mfile))) then
    call Message('Energy histogram and Lambert stack have different energy dimension; aborting program', frm = "(A)")
    call HDF_pop(HDF_head,.TRUE.)
    stop
  end if

dataset = SC_numset
  call HDF_readDatasetInteger(dataset, HDF_head, hdferr, enl%numset)

! dataset = 'squhex'
! call HDF_readDatasetStringArray(dataset, nlines, HDF_head, hdferr, stringarray)
! enl%sqorhe = trim(stringarray(1))
! deallocate(stringarray)

dataset = SC_mLPNH
  call HDF_readDatasetFloatArray4D(dataset, dims4, HDF_head, hdferr, srtmp)
  allocate(master%mLPNH(-enl%npx:enl%npx,-enl%npy:enl%npy,enl%nE),stat=istat)
  master%mLPNH = sum(srtmp,4)
  deallocate(srtmp)

dataset = SC_mLPSH
  call HDF_readDatasetFloatArray4D(dataset, dims4, HDF_head, hdferr, srtmp)
  allocate(master%mLPSH(-enl%npx:enl%npx,-enl%npy:enl%npy,enl%nE),stat=istat)
  master%mLPSH = sum(srtmp,4)
  deallocate(srtmp)

dataset = SC_xtalname
  call HDF_readDatasetStringArray(dataset, nlines, HDF_head, hdferr, stringarray)
  enl%Masterxtalname = trim(stringarray(1))
  deallocate(stringarray)

  call HDF_pop(HDF_head)
  call HDF_pop(HDF_head)

groupname = SC_EMheader
  hdferr = HDF_openGroup(groupname, HDF_head)

groupname = SC_EBSDmaster
  hdferr = HDF_openGroup(groupname, HDF_head)

dataset = SC_ProgramName
  call HDF_readDatasetStringArray(dataset, nlines, HDF_head, hdferr, stringarray)
  enl%Masterprogname = trim(stringarray(1))
  deallocate(stringarray)
  
dataset = SC_Version
  call HDF_readDatasetStringArray(dataset, nlines, HDF_head, hdferr, stringarray)
  enl%Masterscversion = trim(stringarray(1))
  deallocate(stringarray)
  
  call HDF_pop(HDF_head,.TRUE.)

! close the fortran HDF interface
if (HDFopen.eqv..TRUE.)  call h5close_EMsoft(hdferr)

else
  masterfile = 'File '//trim(masterfile)//' is not an HDF5 file'
  call FatalError('EBSDIndexingreadMasterfile',masterfile)
end if
!====================================

if (present(verbose)) call Message(' -> completed reading dynamical scattering data from &
'//trim(enl%masterfile), frm = "(A)")

end subroutine EBSDIndexingreadMasterfile

!--------------------------------------------------------------------------
!
! SUBROUTINE:EBSDIndexingGenerateDetector
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief generate the detector arrays
!
!> @param enl EBSD name list structure
!
!> @date 06/24/14  MDG 1.0 original
!> @date 07/01/15   SS  1.1 added omega as the second tilt angle
!> @date 07/07/15   SS  1.2 correction to the omega tilt parameter; old version in the comments
!> @date 01/26/16   SS  1.3 adjusted for EBSDIndexing
!> @date 06/12/16  MDG  1.4 added correction for effetive detector pixel size w.r.t. equal area mapping
!--------------------------------------------------------------------------
recursive subroutine EBSDIndexingGenerateDetector(enl, acc, master, verbose)
!DEC$ ATTRIBUTES DLLEXPORT :: EBSDIndexingGenerateDetector

use local
use typedefs
use NameListTypedefs
use files
use constants
use io
use Lambert

IMPLICIT NONE

type(EBSDIndexingNameListType),INTENT(INOUT)    :: enl
type(EBSDLargeAccumDIType),pointer              :: acc
type(EBSDMasterDIType),pointer                  :: master
logical,INTENT(IN),OPTIONAL                     :: verbose

real(kind=sgl),allocatable                      :: scin_x(:), scin_y(:)                 ! scintillator coordinate ararays [microns]
real(kind=sgl),parameter                        :: dtor = 0.0174533  ! convert from degrees to radians
real(kind=sgl)                                  :: alp, ca, sa, cw, sw
real(kind=sgl)                                  :: L2, Ls, Lc     ! distances
real(kind=sgl),allocatable                      :: z(:,:)           
integer(kind=irg)                               :: nix, niy, binx, biny , i, j, Emin, Emax, istat, k, ipx, ipy, nixp, niyp      ! various parameters
real(kind=sgl)                                  :: dc(3), scl, pcvec(3), alpha, theta, gam, dp           ! direction cosine array
real(kind=sgl)                                  :: sx, dx, dxm, dy, dym, rhos, x, bindx         ! various parameters
real(kind=sgl)                                  :: ixy(2)


!====================================
! ------ generate the detector arrays
!====================================
! This needs to be done only once for a given detector geometry
allocate(scin_x(enl%numsx),scin_y(enl%numsy),stat=istat)
! if (istat.ne.0) then ...
scin_x = - ( enl%xpc - ( 1.0 - enl%numsx ) * 0.5 - (/ (i-1, i=1,enl%numsx) /) ) * enl%delta
scin_y = ( enl%ypc - ( 1.0 - enl%numsy ) * 0.5 - (/ (i-1, i=1,enl%numsy) /) ) * enl%delta

! auxiliary angle to rotate between reference frames
alp = 0.5 * cPi - (enl%MCsig - enl%thetac) * dtor
ca = cos(alp)
sa = sin(alp)

cw = cos(enl%omega * dtor)
sw = sin(enl%omega * dtor)

! we will need to incorporate a series of possible distortions 
! here as well, as described in Gert nolze's paper; for now we 
! just leave this place holder comment instead

! compute auxilliary interpolation arrays
! if (istat.ne.0) then ...

L2 = enl%L * enl%L
do j=1,enl%numsx
  sx = L2 + scin_x(j) * scin_x(j)
  Ls = -sw * scin_x(j) + enl%L*cw
  Lc = cw * scin_x(j) + enl%L*sw
  do i=1,enl%numsy
   rhos = 1.0/sqrt(sx + scin_y(i)**2)
   master%rgx(j,i) = (scin_y(i) * ca + sa * Ls) * rhos!Ls * rhos
   master%rgy(j,i) = Lc * rhos!(scin_x(i) * cw + Lc * sw) * rhos
   master%rgz(j,i) = (-sa * scin_y(i) + ca * Ls) * rhos!(-sw * scin_x(i) + Lc * cw) * rhos
  end do
end do
deallocate(scin_x, scin_y)

! normalize the direction cosines.
allocate(z(enl%numsx,enl%numsy))
  z = 1.0/sqrt(master%rgx*master%rgx+master%rgy*master%rgy+master%rgz*master%rgz)
  master%rgx = master%rgx*z
  master%rgy = master%rgy*z
  master%rgz = master%rgz*z
deallocate(z)
!====================================

!====================================
! ------ create the equivalent detector energy array
!====================================
! from the Monte Carlo energy data, we need to extract the relevant
! entries for the detector geometry defined above.  Once that is 
! done, we can get rid of the larger energy array
!
! in the old version, we either computed the background model here, or 
! we would load a background pattern from file.  In this version, we are
! using the background that was computed by the MC program, and has 
! an energy histogram embedded in it, so we need to interpolate this 
! histogram to the pixels of the scintillator.  In other words, we need
! to initialize a new accum_e array for the detector by interpolating
! from the Lambert projection of the MC results.
!

! determine the scale factor for the Lambert interpolation; the square has
! an edge length of 2 x sqrt(pi/2)
  scl = float(enl%nsx) !  / LPs%sPio2  [removed on 09/01/15 by MDG for new Lambert routines]

! get the indices of the minimum and maximum energy
  Emin = nint((enl%energymin - enl%Ehistmin)/enl%Ebinsize) +1
  if (Emin.lt.1)  Emin=1
  if (Emin.gt.enl%numEbins)  Emin=enl%numEbins

  Emax = nint((enl%energymax - enl%Ehistmin)/enl%Ebinsize) +1
  if (Emax.lt.1)  Emax=1
  if (Emax.gt.enl%numEbins)  Emax=enl%numEbins

! get an estimate of the cone opening angle for which the projected area at the pattern
! center is the same as delta**2
  alpha = atan(enl%delta/enl%L/sqrt(sngl(cPi)))

! then get the direction cosines for the pattern center
  ipx = enl%numsx/2+nint(enl%xpc)
  ipy = enl%numsy/2+nint(enl%ypc)
  pcvec = (/ master%rgx(ipx,ipy), master%rgy(ipx,ipy), master%rgz(ipx,ipy) /)
  !pcvec = (/enl%ypc*enl%delta*ca + enl%xpc*enl%delta*sa*sw + enl%L*cw*sa, &
  !         enl%L*sw - enl%xpc*enl%delta*cw,&
  !         enl%L*ca*cw + enl%xpc*enl%delta*ca*sw - enl%ypc*enl%delta*sa/)
  !pcvec = pcvec/NORM2(pcvec)

  do i=1,enl%numsx
    do j=1,enl%numsy
! do the coordinate transformation for this detector pixel
       dc = (/ master%rgx(i,j),master%rgy(i,j),master%rgz(i,j) /)

! make sure the third one is positive; if not, switch all 
       if (dc(3).lt.0.0) dc = -dc

! convert these direction cosines to coordinates in the Rosca-Lambert projection
       call LambertgetInterpolation(dc, scl, enl%nsx, enl%nsy, nix, niy, nixp, niyp, dx, dy, dxm, dym, swap=.TRUE.)

! do the area correction for this detector pixel
       dp = dot_product(pcvec,dc)
       theta = acos(dp)
       if ((i.eq.ipx).and.(j.eq.ipy)) then
          gam = 0.25 
       else
          gam = 2.0 * tan(alpha) * dp / ( tan(theta+alpha) - tan(theta-alpha) ) * 0.25
       end if
! interpolate the intensity 
       do k=Emin,Emax 
          acc%accum_e_detector(k,i,j) = gam * ( acc%accum_e(k,nix,niy) * dxm * dym + &
                                        acc%accum_e(k,nixp,niy) * dx * dym + &
                                        acc%accum_e(k,nix,niyp) * dxm * dy + &
                                        acc%accum_e(k,nixp,niyp) * dx * dy )
       end do
    end do
  end do 


! and finally, get rid of the original accum_e array which is no longer needed
! [we'll do that in the calling program ]
!  deallocate(accum_e)

!====================================
end subroutine EBSDIndexingGenerateDetector

!--------------------------------------------------------------------------
!
! SUBROUTINE:EBSDFastIndexingGenerateDetector
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief generate the detector arrays
!
!> @param enl EBSD name list structure
!
!> @date 06/24/14  MDG  1.0 original
!> @date 07/01/15   SS  1.1 added omega as the second tilt angle
!> @date 07/07/15   SS  1.2 correction to the omega tilt parameter; old version in the comments
!> @date 01/26/16   SS  1.3 adjusted for EBSDIndexing
!> @date 06/12/16  MDG  1.4 added correction for effetive detector pixel size w.r.t. equal area mapping
!> @date 07/06/17  MDG  2.0 split from regular routine for an N-line detector
!--------------------------------------------------------------------------
recursive subroutine EBSDFastIndexingGenerateDetector(enl, acc, master, nlines, verbose)
!DEC$ ATTRIBUTES DLLEXPORT :: EBSDFastIndexingGenerateDetector

use local
use typedefs
use NameListTypedefs
use files
use constants
use io
use Lambert

IMPLICIT NONE

type(EBSDIndexingNameListType),INTENT(INOUT)    :: enl
type(EBSDLargeAccumDIType),pointer              :: acc
type(EBSDMasterDIType),pointer                  :: master
integer(kind=irg),INTENT(IN)                    :: nlines
logical,INTENT(IN),OPTIONAL                     :: verbose

real(kind=sgl),allocatable                      :: scin_x(:), scin_y(:)                 ! scintillator coordinate ararays [microns]
real(kind=sgl),parameter                        :: dtor = 0.0174533  ! convert from degrees to radians
real(kind=sgl)                                  :: alp, ca, sa, cw, sw
real(kind=sgl)                                  :: L2, Ls, Lc     ! distances
real(kind=sgl),allocatable                      :: z(:,:)           
integer(kind=irg)                               :: nix, niy, binx, biny , i, j, Emin, Emax, istat, k, ipx, ipy, ystep, nixp, niyp   ! various parameters
real(kind=sgl)                                  :: dc(3), scl, pcvec(3), alpha, theta, gam, dp ! direction cosine array
real(kind=sgl)                                  :: sx, dx, dxm, dy, dym, rhos, x, bindx         ! various parameters
real(kind=sgl)                                  :: ixy(2)


!====================================
! ------ generate the detector arrays
!====================================
! This needs to be done only once for a given detector geometry
allocate(scin_x(enl%numsx),scin_y(nlines),stat=istat)
! if (istat.ne.0) then ...
! we use nlines horizontal lines on the detector, equidistant from each other;
! the scin_x array remains unchanged from the regular detector definition
scin_x = - ( enl%xpc - ( 1.0 - enl%numsx ) * 0.5 - (/ (i-1, i=1,enl%numsx) /) ) * enl%delta

! this requires a change of the scin_y array definition to a larger vertical step size 
ystep = floor(float(enl%numsy)/float(nlines+1))
scin_y = ( enl%ypc - ( 1.0 - enl%numsy ) * 0.5 - (/ (i*ystep, i=1,nlines) /) ) * enl%delta

! auxiliary angle to rotate between reference frames
alp = 0.5 * cPi - (enl%MCsig - enl%thetac) * dtor
ca = cos(alp)
sa = sin(alp)

cw = cos(enl%omega * dtor)
sw = sin(enl%omega * dtor)

! we will need to incorporate a series of possible distortions 
! here as well, as described in Gert nolze's paper; for now we 
! just leave this place holder comment instead

! compute auxilliary interpolation arrays
! if (istat.ne.0) then ...

L2 = enl%L * enl%L
do j=1,enl%numsx
  sx = L2 + scin_x(j) * scin_x(j)
  Ls = -sw * scin_x(j) + enl%L*cw
  Lc = cw * scin_x(j) + enl%L*sw
  do i=1,nlines
   rhos = 1.0/sqrt(sx + scin_y(i)**2)
   master%rgx(j,i) = (scin_y(i) * ca + sa * Ls) * rhos!Ls * rhos
   master%rgy(j,i) = Lc * rhos!(scin_x(i) * cw + Lc * sw) * rhos
   master%rgz(j,i) = (-sa * scin_y(i) + ca * Ls) * rhos!(-sw * scin_x(i) + Lc * cw) * rhos
  end do
end do
deallocate(scin_x, scin_y)

! normalize the direction cosines.
allocate(z(enl%numsx,nlines))
  z = 1.0/sqrt(master%rgx*master%rgx+master%rgy*master%rgy+master%rgz*master%rgz)
  master%rgx = master%rgx*z
  master%rgy = master%rgy*z
  master%rgz = master%rgz*z
deallocate(z)
!====================================

!====================================
! ------ create the equivalent detector energy array
!====================================
! from the Monte Carlo energy data, we need to extract the relevant
! entries for the detector geometry defined above.  Once that is 
! done, we can get rid of the larger energy array
!
! in the old version, we either computed the background model here, or 
! we would load a background pattern from file.  In this version, we are
! using the background that was computed by the MC program, and has 
! an energy histogram embedded in it, so we need to interpolate this 
! histogram to the pixels of the scintillator.  In other words, we need
! to initialize a new accum_e array for the detector by interpolating
! from the Lambert projection of the MC results.
!

! determine the scale factor for the Lambert interpolation; the square has
! an edge length of 2 x sqrt(pi/2)
  scl = float(enl%nsx) !  / LPs%sPio2  [removed on 09/01/15 by MDG for new Lambert routines]

! get the indices of the minimum and maximum energy
  Emin = nint((enl%energymin - enl%Ehistmin)/enl%Ebinsize) +1
  if (Emin.lt.1)  Emin=1
  if (Emin.gt.enl%numEbins)  Emin=enl%numEbins

  Emax = nint((enl%energymax - enl%Ehistmin)/enl%Ebinsize) +1
  if (Emax.lt.1)  Emax=1
  if (Emax.gt.enl%numEbins)  Emax=enl%numEbins

! get an estimate of the cone opening angle for which the projected area at the pattern
! center is the same as delta**2
  alpha = atan(enl%delta/enl%L/sqrt(sngl(cPi)))

! then get the direction cosines for the pattern center
  ipx = enl%numsx/2+nint(enl%xpc)
  ipy = enl%numsy/2+nint(enl%ypc)
  !pcvec = (/ master%rgx(ipx,ipy), master%rgy(ipx,ipy), master%rgz(ipx,ipy) /)
  pcvec = (/enl%ypc*enl%delta*ca + enl%xpc*enl%delta*sa*sw + enl%L*cw*sa, &
           enl%L*sw - enl%xpc*enl%delta*cw,&
           enl%L*ca*cw + enl%xpc*enl%delta*ca*sw - enl%ypc*enl%delta*sa/)
  pcvec = pcvec/NORM2(pcvec)

  do i=1,enl%numsx
    do j=1,nlines
! do the coordinate transformation for this detector pixel
       dc = (/ master%rgx(i,j),master%rgy(i,j),master%rgz(i,j) /)

! make sure the third one is positive; if not, switch all 
       if (dc(3).lt.0.0) dc = -dc

! convert these direction cosines to coordinates in the Rosca-Lambert projection
       call LambertgetInterpolation(dc, scl, enl%nsx, enl%nsy, nix, niy, nixp, niyp, dx, dy, dxm, dym, swap=.TRUE.)

! do the area correction for this detector pixel
        dp = dot_product(pcvec,dc)
        theta = acos(dp)
        if ((i.eq.ipx).and.(j.eq.ipy)) then
          gam = 0.25 
        else
          gam = 2.0 * tan(alpha) * dp / ( tan(theta+alpha) - tan(theta-alpha) ) * 0.25
        end if
! interpolate the intensity 
        do k=Emin,Emax 
          acc%accum_e_detector(k,i,j) = gam * ( acc%accum_e(k,nix,niy) * dxm * dym + &
                                        acc%accum_e(k,nixp,niy) * dx * dym + &
                                        acc%accum_e(k,nix,niyp) * dxm * dy + &
                                        acc%accum_e(k,nixp,niyp) * dx * dy )
        end do
    end do
  end do 


! and finally, get rid of the original accum_e array which is no longer needed
! [we'll do that in the calling program ]
!  deallocate(accum_e)

!====================================
end subroutine EBSDFastIndexingGenerateDetector

!--------------------------------------------------------------------------
!
! FUNCTION: getEBSDIQ
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief compute the EBSD Image Quality using the second moment of the power spectrum
!
!> @details This is based on Krieger Lassen's pattern sharpness definition: Q = 1 - J / Jres wtot
!> more details page 93 of thesis of Farangis Ram.
!
!> @param dimx x pattern dimension
!> @param dimy y pattern dimension
!> @param pattern input EBSD pattern
!
!> @date 02/07/16 MDG 1.0 original
!--------------------------------------------------------------------------
recursive function getEBSDIQ(dimx, dimy, pattern, init) result(Q)
!DEC$ ATTRIBUTES DLLEXPORT :: getEBSDIQ

use local
use typedefs
use FFTW3mod

IMPLICIT NONE

integer(kind=irg),INTENT(IN)            :: dimx
integer(kind=irg),INTENT(IN)            :: dimy
real(kind=sgl),INTENT(IN)               :: pattern(dimx,dimy)
logical,INTENT(IN),OPTIONAL             :: init
real(kind=dbl)                          :: Q

real(kind=dbl),allocatable,SAVE         :: ksqarray(:,:)
real(kind=dbl),SAVE                     :: Jres
type(C_PTR),SAVE                        :: planf

real(kind=dbl)                          :: J, wtot
complex(C_DOUBLE_COMPLEX),pointer       :: inp(:,:)
complex(C_DOUBLE_COMPLEX),pointer       :: outp(:,:)
type(C_PTR)                             :: p, o
real(kind=dbl)                          :: w(dimx,dimy), linex(dimx), liney(dimy)
integer(kind=irg)                       :: i

p = fftw_alloc_complex(int(dimx*dimy,C_SIZE_T))
call c_f_pointer(p, inp, [dimx,dimy])

o = fftw_alloc_complex(int(dimx*dimy,C_SIZE_T))
call c_f_pointer(o, outp, [dimx,dimy])

if (present(init)) then
  if (init.eqv..TRUE.) then 
    allocate(ksqarray(dimx,dimy))

    inp = cmplx(0.D0,0D0)
    outp = cmplx(0.D0,0.D0)

! set up the fftw plan for the forward transform
    planf = fftw_plan_dft_2d(dimy,dimx,inp,outp, FFTW_FORWARD,FFTW_ESTIMATE)

! generate the parameter/array needed by the getEBSDIQ function
    ksqarray = 0.D0
    Jres = 0.D0

    linex = (/ (dble(i),i=0,dimx-1) /) 
    linex(dimx/2+1:dimx) = linex(dimx/2+1:dimx) - dble(dimx)
    linex = linex**2
    liney = (/ (dble(i),i=0,dimy-1) /) 
    liney(dimy/2+1:dimy) = liney(dimy/2+1:dimy) - dble(dimy)
    liney = liney**2
    
    do i=1,dimx
        ksqarray(i,1:dimy) = linex(i) + liney(1:dimy)
    end do
    Jres = sum(ksqarray) / dble(dimx) / dble(dimy)
  end if
else
  inp = cmplx(0.D0,0D0)
  inp = pattern
  outp = cmplx(0.D0,0.D0)

! compute the Fourier transform
  call fftw_execute_dft(planf, inp, outp)

  w = sqrt(real(outp)**2 + aimag(outp)**2)

! sum over the arrays
  J = sum(w*ksqarray)
  wtot = sum(w)

! and return the quality parametere
  Q = 1.0 - J/Jres/wtot
end if

call fftw_free(p)
call fftw_free(o)
call fftw_cleanup()

end function getEBSDIQ

!--------------------------------------------------------------------------
!
! FUNCTION: init_getEBSDIQ
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief initialize variables for the EBSD Image Quality using the second moment of the power spectrum
!
!> @details This is based on Krieger Lassen's pattern sharpness definition: Q = 1 - J / Jres wtot
!> more details page 93 of thesis of Farangis Ram.
!
!> @param dimx x pattern dimension
!> @param dimy y pattern dimension
!> @param pattern input EBSD pattern
!
!> @date 01/10/18 MDG 1.0 original, based on getEBSDIQ routine, but only init part
!--------------------------------------------------------------------------
recursive subroutine init_getEBSDIQ(dimx, dimy, pattern, ksqarray, Jres, planf) 
!DEC$ ATTRIBUTES DLLEXPORT :: init_getEBSDIQ

use local
use typedefs
use FFTW3mod

IMPLICIT NONE

integer(kind=irg),INTENT(IN)            :: dimx
integer(kind=irg),INTENT(IN)            :: dimy
real(kind=sgl),INTENT(IN)               :: pattern(dimx,dimy)
real(kind=dbl),INTENT(OUT)              :: ksqarray(dimx,dimy)
real(kind=dbl),INTENT(OUT)              :: Jres
type(C_PTR),INTENT(OUT)                 :: planf

complex(C_DOUBLE_COMPLEX),pointer       :: inp(:,:)
complex(C_DOUBLE_COMPLEX),pointer       :: outp(:,:)
type(C_PTR)                             :: p, o
real(kind=dbl)                          :: linex(dimx), liney(dimy)
integer(kind=irg)                       :: i

p = fftw_alloc_complex(int(dimx*dimy,C_SIZE_T))
call c_f_pointer(p, inp, [dimx,dimy])

o = fftw_alloc_complex(int(dimx*dimy,C_SIZE_T))
call c_f_pointer(o, outp, [dimx,dimy])

inp = cmplx(0.D0,0D0)
outp = cmplx(0.D0,0.D0)

! set up the fftw plan for the forward transform
planf = fftw_plan_dft_2d(dimy,dimx,inp,outp, FFTW_FORWARD,FFTW_ESTIMATE)

! generate the parameter/array needed by the getEBSDIQ function
ksqarray = 0.D0
Jres = 0.D0

linex = (/ (dble(i),i=0,dimx-1) /) 
linex(dimx/2+1:dimx) = linex(dimx/2+1:dimx) - dble(dimx)
linex = linex**2
liney = (/ (dble(i),i=0,dimy-1) /) 
liney(dimy/2+1:dimy) = liney(dimy/2+1:dimy) - dble(dimy)
liney = liney**2

do i=1,dimx
    ksqarray(i,1:dimy) = linex(i) + liney(1:dimy)
end do
Jres = sum(ksqarray) / dble(dimx) / dble(dimy)

call fftw_free(p)
call fftw_free(o)
call fftw_cleanup()

end subroutine init_getEBSDIQ

!--------------------------------------------------------------------------
!
! FUNCTION: computeEBSDIQ
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief compute the EBSD Image Quality using the second moment of the power spectrum
!
!> @details This is based on Krieger Lassen's pattern sharpness definition: Q = 1 - J / Jres wtot
!> more details page 93 of thesis of Farangis Ram.
!
!> @param dimx x pattern dimension
!> @param dimy y pattern dimension
!> @param pattern input EBSD pattern
!
!> @date 02/07/16 MDG 1.0 original
!--------------------------------------------------------------------------
recursive function computeEBSDIQ(dimx, dimy, pattern, ksqarray, Jres, planf) result(Q)
!DEC$ ATTRIBUTES DLLEXPORT :: computeEBSDIQ

use local
use typedefs
use FFTW3mod

IMPLICIT NONE

integer(kind=irg),INTENT(IN)            :: dimx
integer(kind=irg),INTENT(IN)            :: dimy
real(kind=sgl),INTENT(IN)               :: pattern(dimx,dimy)
real(kind=dbl),INTENT(IN)               :: ksqarray(dimx,dimy)
real(kind=dbl),INTENT(IN)               :: Jres
type(C_PTR),INTENT(IN)                  :: planf
real(kind=dbl)                          :: Q


real(kind=dbl)                          :: J, wtot
complex(C_DOUBLE_COMPLEX),pointer       :: inp(:,:)
complex(C_DOUBLE_COMPLEX),pointer       :: outp(:,:)
type(C_PTR)                             :: p, o
real(kind=dbl)                          :: w(dimx,dimy), linex(dimx), liney(dimy)
integer(kind=irg)                       :: i

p = fftw_alloc_complex(int(dimx*dimy,C_SIZE_T))
call c_f_pointer(p, inp, [dimx,dimy])

o = fftw_alloc_complex(int(dimx*dimy,C_SIZE_T))
call c_f_pointer(o, outp, [dimx,dimy])

inp = pattern
outp = cmplx(0.D0,0.D0)

! compute the Fourier transform
call fftw_execute_dft(planf, inp, outp)

w = sqrt(real(outp)**2 + aimag(outp)**2)

! sum over the arrays
J = sum(w*ksqarray)
wtot = sum(w)

! and return the quality parametere
Q = 1.0 - J/Jres/wtot

call fftw_free(p)
call fftw_free(o)
call fftw_cleanup()

end function computeEBSDIQ

!--------------------------------------------------------------------------
!
! SUBROUTINE: get_EBSDDI_memory_pattern
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief determine which large arrays to hold in memory, if any
!
!> @param ebsdnl EBSD namelist
!> @param holdexpt logical
!> @param holddict logical
!
!> @date 03/15/16 MDG 1.0 original
!--------------------------------------------------------------------------
recursive subroutine get_EBSDDI_memory_pattern(ebsdnl, holdexpt, holddict)
!DEC$ ATTRIBUTES DLLEXPORT :: get_EBSDDI_memory_pattern

use local
use typedefs
use NameListTypedefs
use HDF5
use h5im
use h5lt
use HDFsupport


IMPLICIT NONE

type(EBSDIndexingNameListType),INTENT(INOUT)        :: ebsdnl
logical,INTENT(OUT)                                 :: holdexpt
logical,INTENT(OUT)                                 :: holddict

integer(kind=irg)                                   :: available_memory


! these will be returned to the calling program
holdexpt = .FALSE.
holddict = .FALSE.

! get the available memory in bytes
!available_memory = ebsdnl%sysmem * 1024 * 1024 * 1024

! open each of the HDF5 files for expt and dict patterns and find out
! the array sizes





end subroutine get_EBSDDI_memory_pattern



!--------------------------------------------------------------------------
!
! SUBROUTINE: CalcEBSDPatternSingleApprox
!
!> @author Saransh Singh/Marc De Graef, Carnegie Mellon University
!
!> @brief compute an approximate single EBSD pattern, used in many programs
!
!> @param ebsdnl EBSD namelist
!> @param holdexpt logical
!> @param holddict logical
!
!> @date 03/17/16 MDG 1.0 original
!--------------------------------------------------------------------------
recursive subroutine CalcEBSDPatternSingleApprox(ipar,qu,acc_array,mLPNH,mLPSH,rgx,rgy,rgz,binned,mask,prefactor)
!DEC$ ATTRIBUTES DLLEXPORT :: CalcEBSDPatternSingleApprox

use local
use typedefs
use NameListTypedefs
use NameListHDFwriters
use symmetry
use crystal
use constants
use io
use files
use diffraction
use Lambert
use quaternions
use rotations

IMPLICIT NONE

integer(kind=irg),INTENT(IN)                    :: ipar(7)
real(kind=sgl),INTENT(IN)                       :: qu(4) 
real(kind=dbl),INTENT(IN)                       :: prefactor
integer(kind=irg),INTENT(IN)                    :: acc_array(ipar(2),ipar(3))
real(kind=sgl),INTENT(IN)                       :: mLPNH(-ipar(4):ipar(4),-ipar(5):ipar(5))
real(kind=sgl),INTENT(IN)                       :: mLPSH(-ipar(4):ipar(4),-ipar(5):ipar(5))
real(kind=sgl),INTENT(IN)                       :: rgx(ipar(2),ipar(3))
real(kind=sgl),INTENT(IN)                       :: rgy(ipar(2),ipar(3))
real(kind=sgl),INTENT(IN)                       :: rgz(ipar(2),ipar(3))
real(kind=sgl),INTENT(OUT)                      :: binned(ipar(2)/ipar(1),ipar(3)/ipar(1))
real(kind=sgl),INTENT(IN)                       :: mask(ipar(2)/ipar(1),ipar(3)/ipar(1))

real(kind=sgl),allocatable                      :: EBSDpattern(:,:)
real(kind=sgl),allocatable                      :: wf(:)
real(kind=sgl)                                  :: dc(3),ixy(2),scl,bindx
real(kind=sgl)                                  :: dx,dy,dxm,dym
integer(kind=irg)                               :: ii,jj,kk,istat
integer(kind=irg)                               :: nix,niy,nixp,niyp

! ipar(1) = ebsdnl%binning
! ipar(2) = ebsdnl%numsx
! ipar(3) = ebsdnl%numsy
! ipar(4) = ebsdnl%npx
! ipar(5) = ebsdnl%npy
! ipar(6) = ebsdnl%numEbins
! ipar(7) = ebsdnl%nE


bindx = 1.0/float(ipar(1))**2

allocate(EBSDpattern(ipar(2),ipar(3)),stat=istat)

binned = 0.0
EBSDpattern = 0.0

scl = float(ipar(4)) 

do ii = 1,ipar(2)
    do jj = 1,ipar(3)

        dc = sngl(quat_Lp(qu(1:4),  (/ rgx(ii,jj),rgy(ii,jj),rgz(ii,jj) /) ))

        dc = dc/sqrt(sum(dc**2))

! convert these direction cosines to coordinates in the Rosca-Lambert projection
        call LambertgetInterpolation(dc, scl, ipar(4), ipar(5), nix, niy, nixp, niyp, dx, dy, dxm, dym)

! interpolate the intensity
        if (dc(3) .ge. 0.0) then
                EBSDpattern(ii,jj) = EBSDpattern(ii,jj) + acc_array(ii,jj) * ( mLPNH(nix,niy) * dxm * dym + &
                                               mLPNH(nixp,niy) * dx * dym + mLPNH(nix,niyp) * dxm * dy + &
                                               mLPNH(nixp,niyp) * dx * dy )
        else
                EBSDpattern(ii,jj) = EBSDpattern(ii,jj) + acc_array(ii,jj) * ( mLPSH(nix,niy) * dxm * dym + &
                                               mLPSH(nixp,niy) * dx * dym + mLPSH(nix,niyp) * dxm * dy + &
                                               mLPSH(nixp,niyp) * dx * dy )

        end if
    end do
end do

EBSDpattern = prefactor * EBSDpattern

if (ipar(1) .ne. 1) then
    do ii=1,ipar(2),ipar(1)
        do jj=1,ipar(3),ipar(1)
            binned(ii/ipar(1)+1,jj/ipar(1)+1) = &
            sum(EBSDpattern(ii:ii+ipar(1)-1,jj:jj+ipar(1)-1))
        end do
    end do
! and divide by binning^2

    binned = binned * bindx
else
    binned = EBSDpattern
end if

binned = binned * mask

end subroutine CalcEBSDPatternSingleApprox

!--------------------------------------------------------------------------
!
! SUBROUTINE: readEBSDDotProductFile
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief read a Dot Product File from Dictionary Indexing into the correct namelist and data structure
!
!> @param dpfile filename of the EBSD dot product file
!> @param ebsdnl EBSDIndexingNamelist
!> @param hdferr error code
!
!> @date 03/12/18 MDG 1.0 started new routine
!--------------------------------------------------------------------------
recursive subroutine readEBSDDotProductFile(dpfile, ebsdnl, hdferr, EBSDDIdata, getADP, getAverageOrientations, getCI, &
                                            getEulerAngles, getFit, getIQ, getKAM, getOSM, getPhase, getPhi1, &
                                            getPhi, getPhi2, getSEMsignal, getTopDotProductList, getTopMatchIndices, & 
                                            getValid, getXPosition, getYPosition, getRefinedDotProducts, getRefinedEulerAngles)
!DEC$ ATTRIBUTES DLLEXPORT :: readEBSDDotProductFile

use local
use typedefs
use NameListTypedefs
use error
use HDF5
use HDFsupport
use io
use ISO_C_BINDING

IMPLICIT NONE

character(fnlen),INTENT(IN)                         :: dpfile
type(EBSDIndexingNameListType),INTENT(INOUT)        :: ebsdnl
integer(kind=irg),INTENT(OUT)                       :: hdferr
type(EBSDDIdataType),INTENT(INOUT)                  :: EBSDDIdata
logical,INTENT(IN),OPTIONAL                         :: getADP
logical,INTENT(IN),OPTIONAL                         :: getAverageOrientations
logical,INTENT(IN),OPTIONAL                         :: getCI
logical,INTENT(IN),OPTIONAL                         :: getEulerAngles
logical,INTENT(IN),OPTIONAL                         :: getFit
logical,INTENT(IN),OPTIONAL                         :: getIQ
logical,INTENT(IN),OPTIONAL                         :: getKAM
logical,INTENT(IN),OPTIONAL                         :: getOSM
logical,INTENT(IN),OPTIONAL                         :: getPhase
logical,INTENT(IN),OPTIONAL                         :: getPhi1
logical,INTENT(IN),OPTIONAL                         :: getPhi
logical,INTENT(IN),OPTIONAL                         :: getPhi2
logical,INTENT(IN),OPTIONAL                         :: getSEMsignal
logical,INTENT(IN),OPTIONAL                         :: getTopDotProductList
logical,INTENT(IN),OPTIONAL                         :: getTopMatchIndices
logical,INTENT(IN),OPTIONAL                         :: getValid
logical,INTENT(IN),OPTIONAL                         :: getXPosition
logical,INTENT(IN),OPTIONAL                         :: getYPosition
logical,INTENT(IN),OPTIONAL                         :: getRefinedDotProducts
logical,INTENT(IN),OPTIONAL                         :: getRefinedEulerAngles

character(fnlen)                                    :: infile, groupname, dataset
logical                                             :: stat, readonly, g_exists
type(HDFobjectStackType),pointer                    :: HDF_head
integer(kind=irg)                                   :: ii, nlines
integer(kind=irg),allocatable                       :: iarray(:)
real(kind=sgl),allocatable                          :: farray(:)
integer(HSIZE_T)                                    :: dims(1), dims2(2), dims3(3), offset3(3) 
character(fnlen, KIND=c_char),allocatable,TARGET    :: stringarray(:)

! we assume that the calling program has opened the HDF interface

infile = trim(EMsoft_getEMdatapathname())//trim(dpfile)
infile = EMsoft_toNativePath(infile)

! is this a proper HDF5 file ?
call h5fis_hdf5_f(trim(infile), stat, hdferr)

!===================================================================================
!===============read dot product file===============================================
!===================================================================================

if (stat.eqv..FALSE.) then ! the file exists, so let's open it an first make sure it is an EBSD dot product file
   call FatalError('readEBSDDotProductFile','This is not a proper HDF5 file')
end if 
   
! open the dot product file 
nullify(HDF_head)
readonly = .TRUE.
hdferr =  HDF_openFile(infile, HDF_head, readonly)

! make sure this is an EBSD dot product file
groupname = SC_NMLfiles
    hdferr = HDF_openGroup(groupname, HDF_head)
dataset = 'EBSDDictionaryIndexingNML'
call H5Lexists_f(HDF_head%objectID,trim(dataset),g_exists, hdferr)
if (g_exists.eqv..FALSE.) then
    call FatalError('readEBSDDotProductFile','this is not an EBSD dot product file')
end if
call HDF_pop(HDF_head)

!====================================
! read all NMLparameters group datasets
!====================================
groupname = SC_NMLparameters
    hdferr = HDF_openGroup(groupname, HDF_head)
groupname = SC_EBSDIndexingNameListType
    hdferr = HDF_openGroup(groupname, HDF_head)

! we'll read these roughly in the order that the HDFView program displays them...
dataset = SC_HDFstrings
    call HDF_readDatasetStringArray(dataset, nlines, HDF_head, hdferr, stringarray)
    do ii=1,10
      ebsdnl%HDFstrings(ii) = trim(stringarray(ii))
    end do
    deallocate(stringarray)

dataset = SC_L
    call HDF_readDatasetFloat(dataset, HDF_head, hdferr, ebsdnl%L)

dataset = SC_ncubochoric  
! There is an issue with the capitalization on this variable; needs to be resolved 
! [MDG 10/18/17]  We test to see if Ncubochoric exists; if it does not then we check
! for ncubochoric ...
call H5Lexists_f(HDF_head%objectID,trim(dataset),g_exists, hdferr)
if (g_exists) then
    call HDF_readDatasetInteger(dataset, HDF_head, hdferr, ebsdnl%ncubochoric)
else
    dataset = 'ncubochoric'
    call HDF_readDatasetInteger(dataset, HDF_head, hdferr, ebsdnl%ncubochoric)
end if

dataset = SC_ROI
call H5Lexists_f(HDF_head%objectID,trim(dataset),g_exists, hdferr)
if (g_exists) then
    call HDF_readDatasetIntegerArray1D(dataset, dims, HDF_head, hdferr, iarray)
    ebsdnl%ROI(1:4) = iarray(1:4)
else
    ebsdnl%ROI = (/ 0, 0, 0, 0 /)
end if


dataset = SC_angfile
    call HDF_readDatasetStringArray(dataset, nlines, HDF_head, hdferr, stringarray)
    ebsdnl%angfile = trim(stringarray(1))
    deallocate(stringarray)

dataset = SC_anglefile
    call HDF_readDatasetStringArray(dataset, nlines, HDF_head, hdferr, stringarray)
    ebsdnl%anglefile = trim(stringarray(1))
    deallocate(stringarray)

dataset = SC_axisangle
    call HDF_readDatasetFloatArray1D(dataset, dims, HDF_head, hdferr, farray)
    ebsdnl%axisangle(1:4) = farray(1:4)

dataset = SC_beamcurrent
    call HDF_readDatasetDouble(dataset, HDF_head, hdferr, ebsdnl%beamcurrent)

dataset = SC_binning
    call HDF_readDatasetInteger(dataset, HDF_head, hdferr, ebsdnl%binning)

dataset = SC_ctffile
    call HDF_readDatasetStringArray(dataset, nlines, HDF_head, hdferr, stringarray)
    ebsdnl%ctffile = trim(stringarray(1))
    deallocate(stringarray)

dataset = SC_datafile
    call HDF_readDatasetStringArray(dataset, nlines, HDF_head, hdferr, stringarray)
    ebsdnl%datafile = trim(stringarray(1))
    deallocate(stringarray)

dataset = SC_delta
    call HDF_readDatasetFloat(dataset, HDF_head, hdferr, ebsdnl%delta)

dataset = SC_devid
    call HDF_readDatasetInteger(dataset, HDF_head, hdferr, ebsdnl%devid)

dataset = SC_dwelltime
    call HDF_readDatasetDouble(dataset, HDF_head, hdferr, ebsdnl%dwelltime)

dataset = SC_energyaverage
    call HDF_readDatasetInteger(dataset, HDF_head, hdferr, ebsdnl%energyaverage)

dataset = SC_energyfile
    call HDF_readDatasetStringArray(dataset, nlines, HDF_head, hdferr, stringarray)
    ebsdnl%energyfile = trim(stringarray(1))
    deallocate(stringarray)

dataset = SC_energymax
    call HDF_readDatasetFloat(dataset, HDF_head, hdferr, ebsdnl%energymax)

dataset = SC_energymin
    call HDF_readDatasetFloat(dataset, HDF_head, hdferr, ebsdnl%energymin)

dataset = SC_eulerfile
    call HDF_readDatasetStringArray(dataset, nlines, HDF_head, hdferr, stringarray)
    ebsdnl%eulerfile = trim(stringarray(1))
    deallocate(stringarray)

dataset = SC_exptfile
    call HDF_readDatasetStringArray(dataset, nlines, HDF_head, hdferr, stringarray)
    ebsdnl%exptfile = trim(stringarray(1))
    deallocate(stringarray)

dataset = SC_gammavalue
    call HDF_readDatasetFloat(dataset, HDF_head, hdferr, ebsdnl%gammavalue)

dataset = SC_hipassw
    call HDF_readDatasetDouble(dataset, HDF_head, hdferr, ebsdnl%hipassw)

dataset = SC_inputtype
    call HDF_readDatasetStringArray(dataset, nlines, HDF_head, hdferr, stringarray)
    ebsdnl%inputtype = trim(stringarray(1))
    deallocate(stringarray)

dataset = SC_ipfht
    call HDF_readDatasetInteger(dataset, HDF_head, hdferr, ebsdnl%ipf_ht)

dataset = SC_ipfwd
    call HDF_readDatasetInteger(dataset, HDF_head, hdferr, ebsdnl%ipf_wd)

dataset = SC_maskfile
    call HDF_readDatasetStringArray(dataset, nlines, HDF_head, hdferr, stringarray)
    ebsdnl%maskfile = trim(stringarray(1))
    deallocate(stringarray)

dataset = SC_maskpattern
    call HDF_readDatasetStringArray(dataset, nlines, HDF_head, hdferr, stringarray)
    ebsdnl%maskpattern = trim(stringarray(1))
    deallocate(stringarray)

dataset = SC_maskradius
    call HDF_readDatasetInteger(dataset, HDF_head, hdferr, ebsdnl%maskradius)

dataset = SC_masterfile
    call HDF_readDatasetStringArray(dataset, nlines, HDF_head, hdferr, stringarray)
    ebsdnl%masterfile = trim(stringarray(1))
    deallocate(stringarray)

dataset = SC_nnav
    call HDF_readDatasetInteger(dataset, HDF_head, hdferr, ebsdnl%nnav)

dataset = SC_nnk
    call HDF_readDatasetInteger(dataset, HDF_head, hdferr, ebsdnl%nnk)

dataset = SC_nosm
    call HDF_readDatasetInteger(dataset, HDF_head, hdferr, ebsdnl%nosm)

dataset = SC_nregions
    call HDF_readDatasetInteger(dataset, HDF_head, hdferr, ebsdnl%nregions)

dataset = SC_nthreads
    call HDF_readDatasetInteger(dataset, HDF_head, hdferr, ebsdnl%nthreads)

dataset = SC_numdictsingle
    call HDF_readDatasetInteger(dataset, HDF_head, hdferr, ebsdnl%numdictsingle)

dataset = SC_numexptsingle
    call HDF_readDatasetInteger(dataset, HDF_head, hdferr, ebsdnl%numexptsingle)

dataset = SC_numsx
    call HDF_readDatasetInteger(dataset, HDF_head, hdferr, ebsdnl%numsx)

dataset = SC_numsy
    call HDF_readDatasetInteger(dataset, HDF_head, hdferr, ebsdnl%numsy)

dataset = SC_omega
    call HDF_readDatasetFloat(dataset, HDF_head, hdferr, ebsdnl%omega)

dataset = SC_platid
    call HDF_readDatasetInteger(dataset, HDF_head, hdferr, ebsdnl%platid)

dataset = SC_scalingmode
    call HDF_readDatasetStringArray(dataset, nlines, HDF_head, hdferr, stringarray)
    ebsdnl%scalingmode = trim(stringarray(1))
    deallocate(stringarray)

dataset = SC_spatialaverage
    call HDF_readDatasetStringArray(dataset, nlines, HDF_head, hdferr, stringarray)
    ebsdnl%spatialaverage = trim(stringarray(1))
    deallocate(stringarray)

dataset = SC_thetac
    call HDF_readDatasetFloat(dataset, HDF_head, hdferr, ebsdnl%thetac)

dataset = SC_tmpfile
    call HDF_readDatasetStringArray(dataset, nlines, HDF_head, hdferr, stringarray)
    ebsdnl%tmpfile = trim(stringarray(1))
    deallocate(stringarray)
    
dataset = SC_xpc
    call HDF_readDatasetFloat(dataset, HDF_head, hdferr, ebsdnl%xpc)

dataset = SC_ypc
    call HDF_readDatasetFloat(dataset, HDF_head, hdferr, ebsdnl%ypc)

! and close the NMLparameters group
    call HDF_pop(HDF_head)
    call HDF_pop(HDF_head)
!====================================
!====================================

! open the Scan 1/EBSD/Data group; dictionary indexing files only have one "scan" in them...
groupname = 'Scan 1'
    hdferr = HDF_openGroup(groupname, HDF_head)
groupname = SC_EBSD
    hdferr = HDF_openGroup(groupname, HDF_head)
groupname = SC_Data
    hdferr = HDF_openGroup(groupname, HDF_head)

! integers
dataset = SC_FZcnt
    call HDF_readDatasetInteger(dataset, HDF_head, hdferr, EBSDDIdata%FZcnt)

dataset = SC_NumExptPatterns
    call HDF_readDatasetInteger(dataset, HDF_head, hdferr, EBSDDIdata%Nexp)

dataset = SC_PointGroupNumber
    call HDF_readDatasetInteger(dataset, HDF_head, hdferr, EBSDDIdata%pgnum)

! various optional arrays
if (present(getADP)) then
  if (getADP.eqv..TRUE.) then
!   dataset = SC_ADP
!   call HDF_readDatasetFloatArray1D(dataset, dims, HDF_head, hdferr, EBSDDIdata%ADP)
    call Message('ADP','reading the ADP variable is not yet implemented')
  end if 
end if

if (present(getAverageOrientations)) then
  if (getAverageOrientations.eqv..TRUE.) then
    dataset = SC_AverageOrientations
    call HDF_readDatasetFloatArray2D(dataset, dims2, HDF_head, hdferr, EBSDDIdata%AverageOrientations)
  end if 
end if

if (present(getCI)) then
  if (getCI.eqv..TRUE.) then
    dataset = SC_CI
    call HDF_readDatasetFloatArray1D(dataset, dims, HDF_head, hdferr, EBSDDIdata%CI)
  end if 
end if

if (present(getEulerAngles)) then
  if (getEulerAngles.eqv..TRUE.) then
    dataset = SC_EulerAngles
    call HDF_readDatasetFloatArray2D(dataset, dims2, HDF_head, hdferr, EBSDDIdata%EulerAngles)
  end if 
end if

if (present(getFit)) then
  if (getFit.eqv..TRUE.) then
    dataset = SC_Fit
    call HDF_readDatasetFloatArray1D(dataset, dims, HDF_head, hdferr, EBSDDIdata%Fit)
  end if 
end if

if (present(getIQ)) then
  if (getIQ.eqv..TRUE.) then
    dataset = SC_IQ
    call HDF_readDatasetFloatArray1D(dataset, dims, HDF_head, hdferr, EBSDDIdata%IQ)
  end if 
end if

if (present(getKAM)) then
  if (getKAM.eqv..TRUE.) then
    dataset = SC_KAM
    call HDF_readDatasetFloatArray2D(dataset, dims2, HDF_head, hdferr, EBSDDIdata%KAM)
  end if 
end if

if (present(getOSM)) then
  if (getOSM.eqv..TRUE.) then
    dataset = SC_OSM
    call HDF_readDatasetFloatArray2D(dataset, dims2, HDF_head, hdferr, EBSDDIdata%OSM)
  end if 
end if

if (present(getPhase)) then   ! this is a 1-byte integer, to be implemented 
  if (getPhase.eqv..TRUE.) then
!   dataset = SC_Phase
!   call HDF_readDatasetIntegerArray1D(dataset, dims, HDF_head, hdferr, EBSDDIdata%Phase)
    call Message('Phase','reading the Phase variable is not yet implemented')
  end if 
end if

if (present(getPhi)) then
  if (getPhi.eqv..TRUE.) then
    dataset = SC_Phi
    call HDF_readDatasetFloatArray1D(dataset, dims, HDF_head, hdferr, EBSDDIdata%Phi)
  end if 
end if

if (present(getPhi1)) then
  if (getPhi1.eqv..TRUE.) then
    dataset = SC_Phi1
    call HDF_readDatasetFloatArray1D(dataset, dims, HDF_head, hdferr, EBSDDIdata%Phi1)
  end if 
end if

if (present(getPhi2)) then
  if (getPhi2.eqv..TRUE.) then
    dataset = SC_Phi2
    call HDF_readDatasetFloatArray1D(dataset, dims, HDF_head, hdferr, EBSDDIdata%Phi2)
  end if 
end if

if (present(getSEMsignal)) then
  if (getSEMsignal.eqv..TRUE.) then
    dataset = SC_SEMsignal
    call HDF_readDatasetIntegerArray1D(dataset, dims, HDF_head, hdferr, EBSDDIdata%SEMsignal)
  end if 
end if

if (present(getTopDotProductList)) then
  if (getTopDotProductList.eqv..TRUE.) then
    dataset = SC_TopDotProductList
    call HDF_readDatasetFloatArray2D(dataset, dims2, HDF_head, hdferr, EBSDDIdata%TopDotProductList)
  end if 
end if

if (present(getTopMatchIndices)) then
  if (getTopMatchIndices.eqv..TRUE.) then
    dataset = SC_TopMatchIndices
    call HDF_readDatasetIntegerArray2D(dataset, dims2, HDF_head, hdferr, EBSDDIdata%TopMatchIndices)
  end if 
end if

if (present(getValid)) then
  if (getValid.eqv..TRUE.) then
!   dataset = SC_Valid
!   call HDF_readDatasetIntegerArray1D(dataset, dims, HDF_head, hdferr, EBSDDIdata%Valid)
    call Message('Valid','reading the Valid variable is not yet implemented')
  end if 
end if

if (present(getXPosition)) then
  if (getXPosition.eqv..TRUE.) then
    dataset = SC_XPosition
    call HDF_readDatasetFloatArray1D(dataset, dims, HDF_head, hdferr, EBSDDIdata%XPosition)
  end if 
end if

if (present(getYPosition)) then
  if (getYPosition.eqv..TRUE.) then
    dataset = SC_YPosition
    call HDF_readDatasetFloatArray1D(dataset, dims, HDF_head, hdferr, EBSDDIdata%YPosition)
  end if 
end if

if (present(getRefinedDotProducts)) then
  if (getRefinedDotProducts.eqv..TRUE.) then
    dataset = SC_RefinedDotProducts
    call H5Lexists_f(HDF_head%objectID,trim(dataset),g_exists, hdferr)
    if (g_exists) then 
      call HDF_readDatasetFloatArray1D(dataset, dims, HDF_head, hdferr, EBSDDIdata%RefinedDotProducts)
    else
      call Message('readEBSDDotProductFile','There is no RefinedDotProducts data set in this file')
    end if
  end if 
end if

if (present(getRefinedEulerAngles)) then
  if (getRefinedEulerAngles.eqv..TRUE.) then
    dataset = SC_RefinedEulerAngles
    call H5Lexists_f(HDF_head%objectID,trim(dataset),g_exists, hdferr)
    if (g_exists) then 
      call HDF_readDatasetFloatArray2D(dataset, dims2, HDF_head, hdferr, EBSDDIdata%RefinedEulerAngles)
    else
      call Message('readEBSDDotProductFile','There is no RefinedEulerAngles data set in this file')
    end if
  end if 
end if

call HDF_pop(HDF_head)

groupname = SC_Header
    hdferr = HDF_openGroup(groupname, HDF_head)

dataset = SC_StepX
    call HDF_readDatasetFloat(dataset, HDF_head, hdferr, ebsdnl%StepX)
    
dataset = SC_StepY
    call HDF_readDatasetFloat(dataset, HDF_head, hdferr, ebsdnl%StepY)

! if (present()) then
!   if (get.eqv..TRUE.) then

!   end if 
! end if

! and close the HDF5 dot product file
call HDF_pop(HDF_head,.TRUE.)
    
end subroutine readEBSDDotProductFile

!--------------------------------------------------------------------------
!
! SUBROUTINE: EBSDgetAverageOrientations
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief Use the top near-matches list to compute the averaged orientations
!
!> @param ipar array of integers
!> @param Eulers array of dictionary Euler angle triplets
!> @param tmi top match index array
!> @param dplist dot product list
!> @param 
!> @param avEuler (returned) resulting averaged orientations array
!> @param disorient (optional) array of disorientation angles for top matches
!
!> @date 07/06/16 MDG 1.0 original
!> @date 09/06/16 MDG 1.1 correction of issue where the acos() function returned NAN
!--------------------------------------------------------------------------
recursive subroutine EBSDgetAverageOrientations(ipar, Eulers, tmi, dplist, avEuler, disorient)
!DEC$ ATTRIBUTES DLLEXPORT :: EBSDgetAverageOrientations

use dictmod
use rotations
use quaternions
use constants

IMPLICIT NONE

! ipar(1) = pgnum
! ipar(2) = FZcnt
! ipar(3) = Nexp
! ipar(4) = nnk
! ipar(5) = indi (=Ne*ceiling(float(totnumexpt)/float(Ne)))
! ipar(6) = nmuse

integer(kind=irg),INTENT(IN)            :: ipar(6)
real(kind=sgl),INTENT(IN)               :: Eulers(3,ipar(2))
integer(kind=irg),INTENT(IN)            :: tmi(ipar(4),ipar(5))
real(kind=irg),INTENT(IN)               :: dplist(ipar(4),ipar(5))
real(kind=sgl),INTENT(OUT)              :: avEuler(3,ipar(3))
real(kind=sgl),INTENT(OUT),OPTIONAL     :: disorient(ipar(3),ipar(6))

type(dicttype),pointer                  :: dict
integer(kind=irg)                       :: Nexp, nnm, nnk, Pmdims, i, j, k, ipat, pgnum, FZcnt, indi, nmuse
real(kind=sgl)                          :: ax(4), accum(3), q1(4), q2(4), qus(4), a, oldmo, p(4), qsmall(4), theta, vec(3)

real(kind=sgl),allocatable              :: logq(:,:), w(:)
integer(kind=irg),allocatable           :: EulerIDs(:)
logical                                 :: store

pgnum = ipar(1)
FZcnt = ipar(2)
Nexp = ipar(3)
nnk = ipar(4)
indi = ipar(5)
nmuse = ipar(6)

store = .FALSE.
if (PRESENT(disorient)) store = .TRUE.

!===================================
! set up the symmetry quaternions for this rotational symmetry
! allocate the dict structure
allocate(dict)
dict%Num_of_init = 3
dict%Num_of_iterations = 30
dict%pgnum = pgnum
! initialize the symmetry matrices
call DI_Init(dict,'nil') 
Pmdims = dict%Nqsym
!write (*,*) 'number of symmetry operators : ',Pmdims
!do i=1,Pmdims
!    write (*,*) dict%Pm(1:4,i)
!end do

!===================================
! ok, so now we have all the necessary data
! next, we convert all the dictionary Euler angles into axis-angle triplets 
! but with half the angle so that they become the logarithm of the corresponding 
! quaternions (we omit the scalar part which is always zero)
allocate(logq(3,FZcnt))
do i=1,FZcnt
  ax = eu2ax(Eulers(1:3,i))
  logq(1:3,i) = ax(1:3) * ax(4) * 0.5
end do

! next, loop over all the experimental points, determine the weight factors
! and perform the averaging over those symmetrically equivalent orientations
! that have the smallest possible misorientation with respect to the best match.
allocate(EulerIDs(nmuse),w(nmuse))

do i=1,Nexp
! get the Euler angle IDs in the short list
  EulerIDs(1:nmuse) = tmi(1:nmuse,i)

! get the weight factors and normalize them to sum to 1
  w(1:nmuse) = dplist(1:nmuse,i)
  w = w - w(nmuse)
  w = w/sum(w)

! for each orientation in the list, determine the symmetrycally equivalent one
! that has the smallest misorientation with respect to the first entry on the list
! and add its weighted logarithm to the accum sum
  q1 = eu2qu(Eulers(1:3,EulerIDs(1)))
  accum = logq(1:3,EulerIDs(1)) * w(1)
  do j=2,nmuse!  -1   ! -1 because the last one has weight factor 0
    q2 = eu2qu(Eulers(1:3,EulerIDs(j)))
    oldmo = 10.0
! determine the orientation with the smallest misorientation w.r.t. q1 and store it in qsmall
    do k=1,Pmdims
      qus = quat_mult(dict%Pm(1:4,k),dble(q2))
      if (qus(1).lt.0.0) qus=-qus
      p = quat_mult(q1,conjg(qus))
      if (p(1).lt.0.0) p=-p
      if (p(1).gt.1.0) p(1)=1.0
      a = 2.0*acos(p(1))
      if (a.lt.oldmo) then
        oldmo = a
        qsmall = qus
      end if
      p = quat_mult(qus,conjg(q1))
      if (p(1).lt.0.0) p=-p
      if (p(1).gt.1.0) p(1)=1.0
      a = 2.0*acos(p(1))
      if (a.lt.oldmo) then
        oldmo = a
        qsmall = qus
      end if
    end do
    if (store.eqv..TRUE.) disorient(i,j) = oldmo
! take the logarithm of qsmall and add it with the appropriate weight factor to accum
    ax = qu2ax(qsmall)
    accum(1:3) = accum(1:3) + ax(1:3) * ax(4) * 0.5 * w(j)
  end do
  
! accum is now the logarithm of the desired orientation quaternion, so we need to convert
! this back to an Euler angle triplet
  theta = sqrt(sum(accum**2))
  theta = mod(theta, 2.0*sngl(cPi))
  if (theta.ne.0.0) then
    vec = accum/theta
  else 
    vec = (/ 0.0, 0.0, 1.0 /)
  end if
  ax(1:3) = vec(1:3)
  ax(4) = theta  * 2.0
  avEuler(1:3,i) = ax2eu(ax)
end do

! and put this array back in degrees
avEuler = avEuler *180.0/sngl(cPi)

end subroutine EBSDgetAverageOrientations

!--------------------------------------------------------------------------
!
! SUBROUTINE: EBSDgetOrientationSimilarityMap
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief compute the OSM (Orientation Similarity Map) given a set of near matches
!
!> @param idims dimensions of TopMatchIndices (tmi) array
!> @param tmi Top Match Indices array
!> @param nm number of matches to use for OSM
!> @param ipf_wd width of the ROI
!> @param ipf_ht height of the ROI
!> @param osm (returned) Orientation Similarity Map (1D array)
!
!> @date 07/28/16 MDG 1.0 original
!--------------------------------------------------------------------------
recursive subroutine EBSDgetOrientationSimilarityMap(idims, tmi, nm, ipf_wd, ipf_ht, osm)
!DEC$ ATTRIBUTES DLLEXPORT :: EBSDgetOrientationSimilarityMap

use math
use io

IMPLICIT NONE

integer(kind=irg),INTENT(IN)     :: idims(2)
integer(kind=irg),INTENT(IN)     :: tmi(idims(1),idims(2))
integer(kind=irg),INTENT(IN)     :: nm
integer(kind=irg),INTENT(IN)     :: ipf_wd
integer(kind=irg),INTENT(IN)     :: ipf_ht
real(kind=sgl),INTENT(OUT)       :: osm(ipf_wd,ipf_ht)

real(kind=sgl),allocatable       :: localosm(:)
integer(kind=irg),allocatable    :: lstore(:,:), pstore(:,:), cp(:), lp(:)
integer(kind=irg)                :: ii, jj, iii , dp, lnm, io_int(2), totnumexpt

osm = 0.0
totnumexpt = ipf_wd * ipf_ht

! make sure that the requested number of near-matches is smaller than/equal to the available number
if (nm.gt.idims(1)) then
  io_int(1) = nm
  io_int(2) = idims(1)
  call WriteValue('Requested number of near matches is too large: ',io_int,2,"(I4,' > ',I4)")
  call Message(' --> Resetting requested number to maximum available')
  lnm = idims(1)
else
  lnm = nm
end if

allocate(lstore(lnm, ipf_wd), pstore(lnm, ipf_wd), cp(lnm), lp(lnm), localosm(ipf_wd*ipf_ht))

localosm = 0.0
lstore = 0
pstore = 0
cp = 0
lp = 0

! we'll do this computation on the 1D array, in the same way 
! as the ADP (Average Dot Product) map in the EBSDDI.f90 program
do iii = 1,totnumexpt
    ii = mod(iii,ipf_wd)
    if (ii.eq.0) ii = ipf_wd
    jj = iii/ipf_wd+1
! do we need to copy pstore into lstore ?
    if ((ii.eq.1).and.(jj.gt.1)) lstore = pstore
! determine to which osm entries we need to add the similarity count
    if (ii.eq.1) then
      cp(1:lnm) = tmi(1:lnm, iii)
      pstore(1:lnm,ii) = cp(1:lnm)
    else
      lp = cp
      cp(1:lnm) = tmi(1:lnm, iii)
      pstore(1:lnm,ii) = cp(1:lnm)
      dp = vectormatch(lnm, cp, lp)
      localosm(iii-1) = localosm(iii-1) + dp
      localosm(iii) = localosm(iii) + dp
    end if
    if (jj.gt.1) then
      dp = vectormatch(lnm,lstore(1:lnm,ii),cp)
      localosm(iii-ipf_wd+1) = localosm(iii-ipf_wd+1) + dp
      localosm(iii) = localosm(iii) + dp
    end if
end do

! correct the osm values depending on inside, edge, or corner pixels
! divide by 4
localosm = localosm*0.25

! correct the straight segments  THIS NEEDS TO BE VERIFIED !!!!!
localosm(2:ipf_wd-1) = localosm(2:ipf_wd-1) * 4.0/3.0
localosm(totnumexpt-ipf_wd+2:totnumexpt-1) = localosm(totnumexpt-ipf_wd+2:totnumexpt-1) * 4.0/3.0
do jj=1,ipf_ht-2
  localosm(ipf_wd*jj+1) = localosm(ipf_wd*jj+1) * 4.0/3.0
end do
do jj=2,ipf_ht-1
  localosm(ipf_wd*jj) = localosm(ipf_wd*jj) * 4.0/3.0
end do

! and the corners
localosm(1) = localosm(1) * 4.0
localosm(ipf_wd) = localosm(ipf_wd) * 2.0
localosm(totnumexpt) = localosm(totnumexpt) * 2.0
localosm(totnumexpt-ipf_wd+1) = localosm(totnumexpt-ipf_wd+1) * 4.0/3.0

! and we deallocate the auxiliary variables 
deallocate(lstore,pstore,lp,cp)

do ii=1,ipf_wd
  do jj=1,ipf_ht
    osm(ii,jj) = localosm(ipf_wd*(jj-1)+ii)
  end do
end do

end subroutine EBSDgetOrientationSimilarityMap

!--------------------------------------------------------------------------
!
! SUBROUTINE: EBSDgetIndexingSuccessMap
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief compute the ISM (Indexing Success Map) given a set of near matches
!
!> @param idims dimensions of TopMatchIndices (tmi) array
!> @param tmi Top Match Indices array
!> @param eq Euler angles array
!> @param ebsdnl namelist
!> @param ism (returned) Indexing Success Rate Map 
!
!> @date 06/27/18 MDG 1.0 original
!--------------------------------------------------------------------------
recursive subroutine EBSDgetIndexingSuccessMap(ipar, tmi, ea, ebsdnl, ism)
!DEC$ ATTRIBUTES DLLEXPORT :: EBSDgetIndexingSuccessMap

use NameListTypedefs
use omp_lib
use io
use dictmod
use constants

IMPLICIT NONE

integer(kind=irg),INTENT(IN)                :: ipar(10)
integer(kind=irg),INTENT(IN)                :: tmi(ipar(1),ipar(2))
real(kind=sgl),INTENT(INOUT)                :: ea(3,ipar(4))
type(EBSDIndexingNameListType),INTENT(IN)   :: ebsdnl
real(kind=sgl),INTENT(OUT)                  :: ism(ipar(7)*ipar(8))

integer(kind=irg)                           :: io_int(2), lnism, i, j
real(kind=sgl),allocatable                  :: angles(:)
real(kind=sgl)                              :: angle
type(dicttype),pointer                      :: dict

ism = 0.0

! make sure that the requested number of near-matches is smaller than/equal to the available number
if (ebsdnl%nism.gt.ebsdnl%nnk-1) then
  io_int(1) = ebsdnl%nism
  io_int(2) = ebsdnl%nnk-1
  call WriteValue('Requested number of near matches is too large: ',io_int,2,"(I4,' > ',I4)")
  call Message(' --> Resetting requested number to maximum available')
  lnism = ebsdnl%nnk-1
else
  lnism = ebsdnl%nism
end if

! set up the correct symmetry variables 
nullify(dict)
allocate(dict)
dict%Num_of_init = 1
dict%Num_of_iterations = 2
dict%pgnum = ipar(6)
call DI_Init(dict,'nil') 

! next we go through the entire list of points in tmi and compute the misorientation angle
! for the best match with respect to the next nism matches

! this should be done in parallel ... 
call OMP_SET_NUM_THREADS(ebsdnl%nthreads)
!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(i,j,angles,angle)
allocate(angles(lnism))
!$OMP DO SCHEDULE(DYNAMIC)
do i=1,ipar(3)
  do j=2,lnism+1
    call getDisorientationAngle(ea(1:3,tmi(1,i)), ea(1:3,tmi(j,i)), dict, angle)
    angles(j-1) = angle
  end do
  ism(i) = minval(angles)
end do
!$OMP END DO
deallocate(angles)
!$OMP END PARALLEL

ism = ism * 180.0/sngl(cPi)

! that's it.

end subroutine EBSDgetIndexingSuccessMap

!--------------------------------------------------------------------------
!
! SUBROUTINE: EBSDgetKAMMap
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief compute the KAM (Kernel Average Misorientation Map) given a set of orientations
!
!> @param numeu dimensions of TopMathcIndices (tmi) array
!> @param eulers 1D array of Euler angles 
!> @param ipf_wd width of the ROI
!> @param ipf_ht height of the ROI
!> @param dict dict structure
!> @param Pmdims number of symmetry operators
!> @param kam (returned) Kernel Average Misorientation Map (2D array, radians)
!
!> @date 07/30/16 MDG 1.0 original
!--------------------------------------------------------------------------
recursive subroutine EBSDgetKAMMap(numeu, eulers, ipf_wd, ipf_ht, dict, kam)
!DEC$ ATTRIBUTES DLLEXPORT :: EBSDgetKAMMap

use math
use io
use dictmod

IMPLICIT NONE

integer(kind=irg),INTENT(IN)     :: numeu
real(kind=sgl),INTENT(IN)        :: eulers(3,numeu)
integer(kind=irg),INTENT(IN)     :: ipf_wd
integer(kind=irg),INTENT(IN)     :: ipf_ht
!type(dicttype),INTENT(INOUT),pointer:: dict
type(dicttype),INTENT(INOUT):: dict
real(kind=sgl),INTENT(OUT)       :: kam(ipf_wd,ipf_ht)

real(kind=sgl),allocatable       :: localkam(:)
real(kind=sgl),allocatable       :: lstore(:,:), pstore(:,:)
real(kind=sgl)                   :: cp(3), lp(3)
integer(kind=irg)                :: ii, jj, iii 
real(kind=sgl)                   :: dp

kam = 0.0

allocate(lstore(3,ipf_wd), pstore(3,ipf_wd), localkam(numeu))

localkam = 0.0
lstore = 0
pstore = 0
cp = 0
lp = 0

! we'll do this computation on the 1D array, in the same way 
! as the ADP (Average Dot Product) map in the EBSDDI.f90 program
do iii = 1,numeu
    ii = mod(iii,ipf_wd)
    if (ii.eq.0) ii = ipf_wd
    jj = iii/ipf_wd+1
! do we need to copy pstore into lstore ?
    if ((ii.eq.1).and.(jj.gt.1)) lstore = pstore
! determine to which kam entries we need to add the next disorientation value
    if (ii.eq.1) then
      cp = eulers(1:3,iii)
      pstore(1:3,ii) = cp
    else
      lp = cp
      cp = eulers(1:3,iii)
      pstore(1:3,ii) = cp
      call getDisorientationAngle(lp, cp, dict, dp)
      localkam(iii-1) = localkam(iii-1) + dp
      localkam(iii) = localkam(iii) + dp
    end if
    if (jj.gt.1) then
      call getDisorientationAngle(lstore(1:3,ii), cp, dict, dp)
      localkam(iii-ipf_wd+1) = localkam(iii-ipf_wd+1) + dp
      localkam(iii) = localkam(iii) + dp
    end if
end do

! correct the kam values depending on inside, edge, or corner pixels
! divide by 4
localkam = localkam*0.25

! correct the straight segments  
localkam(2:ipf_wd-1) = localkam(2:ipf_wd-1) * 4.0/3.0
localkam(numeu-ipf_wd+2:numeu-1) = localkam(numeu-ipf_wd+2:numeu-1) * 4.0/3.0
do jj=1,ipf_ht-2
  localkam(ipf_wd*jj+1) = localkam(ipf_wd*jj+1) * 4.0/3.0
end do
do jj=2,ipf_ht-1
  localkam(ipf_wd*jj) = localkam(ipf_wd*jj) * 4.0/3.0
end do

! and the corners
localkam(1) = localkam(1) * 4.0
localkam(ipf_wd) = localkam(ipf_wd) * 2.0
localkam(numeu) = localkam(numeu) * 2.0
localkam(numeu-ipf_wd+1) = localkam(numeu-ipf_wd+1) * 4.0/3.0

! and we deallocate the auxiliary variables 
deallocate(lstore,pstore)

do ii=1,ipf_wd
  do jj=1,ipf_ht
    kam(ii,jj) = localkam(ipf_wd*(jj-1)+ii)
  end do
end do

end subroutine EBSDgetKAMMap

end module EBSDDImod
