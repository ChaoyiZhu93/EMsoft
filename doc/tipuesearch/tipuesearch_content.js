var tipuesearch = {"pages":[{"text":"Fortran Program Hi, my name is mdg. This is a project which I wrote. This file will provide the documents. I'm\nwriting the body of the text here. It contains an overall description of the\nproject. It might explain how to go about installing/compiling it. It might\nprovide a change-log for the code. [[linalg]] Maybe it will talk about the\nhistory and/or motivation for this software. Note You can include any notes (or bugs, warnings, or todos) like so. Bug You can have multi-paragraph versions of these too! That means you can\ninclude ordered lists unordered lists images etc. Isn't that cool? Bug Hey I'm doing it again... This ones ends mid... ...paragraph. You can have as many paragraphs as you like here and can use headlines, links,\nimages, etc. Basically, you can use anything in Markdown and Markdown-Extra.\nFurthermore, you can insert LaTeX into your documentation. So, for example,\nyou can provide inline math using like  y = x&#94;2  or math on its own line\nlike  x = \\sqrt{y}  or  e = mc&#94;2.  You can even use LaTeX environments!\nSo you can get numbered equations like this:\n\\begin{equation}\n  PV = nRT\n\\end{equation}\nSo let your imagination run wild. As you can tell, I'm more or less just\nfilling in space now. This will be the last sentence. Developer Info Marc De Graef Research Group/Carnegie Mellon University Professor of Materials Science and Engineering, CMU","tags":"","loc":"index.html","title":" Fortran Program "},{"text":"Modules apb Source Code apb.f90 Source Code ! ################################################################### ! Copyright (c) 2013-2014, Marc De Graef/Carnegie Mellon University ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without modification, are ! permitted provided that the following conditions are met: ! !     - Redistributions of source code must retain the above copyright notice, this list !        of conditions and the following disclaimer. !     - Redistributions in binary form must reproduce the above copyright notice, this !        list of conditions and the following disclaimer in the documentation and/or !        other materials provided with the distribution. !     - Neither the names of Marc De Graef, Carnegie Mellon University nor the names !        of its contributors may be used to endorse or promote products derived from !        this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE ! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ################################################################### !-------------------------------------------------------------------------- ! EMsoft:apb.f90 !-------------------------------------------------------------------------- ! ! MODULE: inclusion ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief Provides routines to deal with cylindrical APBs ! !> @date   02/10/14 MDG 1.0 original !-------------------------------------------------------------------------- module apb use local use typedefs contains !-------------------------------------------------------------------------- ! ! SUBROUTINE: read_apb_data ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief  read apb parameters from file ! !> @param defects defect structure !> @param cell unit cell pointer !> @param foil foil structure !> @param DF_L column edge length !> @param DF_npix number of x-pixels !> @param DF_npiy number of y-pixels !> @param dinfo logical to trigger verbose output ! !> @date   02/10/14 MDG 1.0 new code !> @date   06/10/14 MDG 2.0 removed all global variables; added defect, foil arguments !-------------------------------------------------------------------------- recursive subroutine read_apb_data ( defects , cell , DF_L , DF_npix , DF_npiy , dinfo ) !DEC$ ATTRIBUTES DLLEXPORT :: read_apb_data use io use files use crystal IMPLICIT NONE type ( defecttype ), INTENT ( INOUT ) :: defects type ( unitcell ), pointer :: cell integer ( kind = irg ), INTENT ( IN ) :: dinfo , DF_npix , DF_npiy real ( kind = sgl ), INTENT ( IN ) :: DF_L integer ( kind = irg ) :: i , io_int ( 1 ) real ( kind = sgl ) :: Vx , Vy , Vz , Vrad , w , tmp ( 3 ), tmp2 ( 3 ), Rx , Ry , Rz ! open the apbdata file call Message ( 'Opening ' // trim ( defects % apbname ), frm = \"(A)\" ) open ( unit = dataunit , file = trim ( EMsoft_toNativePath ( defects % apbname )), form = 'formatted' ) read ( dataunit , * ) defects % numapb ! PGC unit=dataunit -> dataunit allocate ( defects % apbs ( defects % numapb )) if ( dinfo . eq . 1 ) then io_int ( 1 ) = defects % numapb call WriteValue ( ' Number of APBs ' , io_int , 1 , \"(I)\" ) end if ! read each subsequent line do i = 1 , defects % numapb read ( dataunit , * ) Vx , Vy , Vz , Vrad , w , Rx , Ry , Rz ! PGC unit=dataunit -> dataunit defects % apbs ( i )% xpos = Vx * 0.5 * float ( DF_npix ) * DF_L defects % apbs ( i )% ypos = Vy * 0.5 * float ( DF_npiy ) * DF_L defects % apbs ( i )% zpos = Vz * foil % z0 ! vertical fractional location in interval [-1,1] defects % apbs ( i )% radius = Vrad ! radius in nanometers defects % apbs ( i )% w = w tmp = ( / Rx , Ry , Rz / ) call TransSpace ( cell , tmp , tmp2 , 'd' , 'c' ) defects % apbs ( i )% Rdisp = tmp2 tmp = quat_Lp ( conjg ( foil % a_fc ), dble (( / defects % apbs ( i )% xpos , defects % apbs ( i )% ypos , defects % apbs ( i )% zpos / )) ) defects % apbs ( i )% xpos = tmp ( 1 ) defects % apbs ( i )% ypos = tmp ( 2 ) defects % apbs ( i )% zpos = tmp ( 3 ) end do ! close datafile close ( unit = dataunit , status = 'keep' ) end subroutine read_apb_data end module apb","tags":"","loc":"sourcefile/apb.f90.html","title":"apb.f90 – Fortran Program"},{"text":"References\n  * \" The BOBYQA algorithm for bound constrained optimization without\n    derivatives \". History\n  * M.J.D. Powell (January 5th, 2009) -- There are no restrictions on or charges \n    for the use of the software. I hope that the time and effort I have spent on \n     developing the package will be helpful to much research and to many applications.\n  * Jacob Williams, July 2015 : refactoring of the code into modern Fortran. Modules bobyqa_module Source Code bobyqa.f90 Source Code !***************************************************************************************** !> !  BOBYQA: **B**ound **O**ptimization **BY** **Q**uadratic **A**pproximation ! !  The purpose of BOBYQA is to seek the least value of a function F of several !  variables, when derivatives are not available. The constraints are the lower !  and upper bounds on every variable, which can be set to huge values for !  unconstrained variables. ! !  The algorithm is intended to change the variables to values that are close !  to a local minimum of F. The user, however, should assume responsibility for !  finding out if the calculations are satisfactory, by considering carefully !  the values of F that occur. ! !# References !  * \"[The BOBYQA algorithm for bound constrained optimization without !    derivatives](http://www.damtp.cam.ac.uk/user/na/NA_papers/NA2009_06.pdf)\". ! !# History !  * M.J.D. Powell (January 5th, 2009) -- There are no restrictions on or charges !    for the use of the software. I hope that the time and effort I have spent on !     developing the package will be helpful to much research and to many applications. !  * Jacob Williams, July 2015 : refactoring of the code into modern Fortran. module bobyqa_module use local use , INTRINSIC :: ISO_C_BINDING !    private ! @date 12/12/15 SS 1.1 changed input parameters to the function interfce abstract interface recursive subroutine func ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , accum_e , & mLPNH , mLPSH , n , x , f , nstep , stepsize , verbose ) !! calfun interface use local use , INTRINSIC :: ISO_C_BINDING implicit none integer ( irg ), intent ( in ) :: nipar integer ( irg ), intent ( in ) :: nfpar integer ( irg ), intent ( in ) :: ninit integer ( irg ), intent ( in ) :: nstep integer ( c_size_t ), intent ( in ) :: ipar ( nipar ) real ( sgl ), intent ( inout ) :: fpar ( nfpar ) real ( sgl ), intent ( in ) :: stepsize ( nstep ) real ( sgl ), intent ( in ) :: initmeanval ( ninit ) real ( c_float ), intent ( in ) :: expt1 ( ipar ( 2 ) * ipar ( 3 ) / ipar ( 12 ) ** 2 ) real ( sgl ), intent ( in ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( sgl ), intent ( in ) :: mLPNH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) real ( sgl ), intent ( in ) :: mLPSH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) integer ( irg ), intent ( in ) :: n real ( dbl ), dimension (:), intent ( in ) :: x real ( dbl ), intent ( out ) :: f logical , intent ( in ), optional :: verbose end subroutine func end interface !    public :: bobyqa contains !***************************************************************************************** !***************************************************************************************** !> !  This subroutine seeks the least value of a function of many variables, !  by applying a trust region method that forms quadratic models by !  interpolation. There is usually some freedom in the interpolation !  conditions, which is taken up by minimizing the Frobenius norm of !  the change to the second derivative of the model, beginning with the !  zero matrix. The values of the variables are constrained by upper and !  lower bounds. ! !  In addition to providing CALFUN, an initial vector of variables and !  the lower and upper bounds, the user has to set the values of the parameters !  ```RHOBEG```, ```RHOEND``` and ```NPT```. After scaling the individual variables !  if necessary, so that the magnitudes of their expected changes are similar, !  ```RHOBEG``` is the initial steplength for changes to the variables, a reasonable choice !  being the mesh size of a coarse grid search. Further, ```RHOEND``` should be suitable for !  a search on a very fine grid. Typically, the software calculates a vector !  of variables that is within distance ```10*RHOEND``` of a local minimum. Another !  consideration is that every trial vector of variables is forced to satisfy !  the lower and upper bounds, but there has to be room to make a search in all !  directions. Therefore an error return occurs if the difference between the !  bounds on any variable is less than ```2*RHOBEG```. The parameter ```NPT``` specifies !  the number of interpolation conditions on each quadratic model, the value !  ```NPT=2*N+1``` being recommended for a start, where ```N``` is the number of !  variables. It is often worthwhile to try other choices too, but much larger values !  tend to be inefficient, because the amount of routine work of each iteration is !  of magnitude ```NPT**2```, and because the achievement of adequate accuracy in some !  matrix calculations becomes more difficult. Some excellent numerical results !  have been found in the case ```NPT=N+6``` even with more than 100 variables. ! @date 12/12/15 SS 1.1 changed input parameters to the function interfce recursive subroutine bobyqa ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , n , npt , x , xl ,& xu , rhobeg , rhoend , iprint , maxfun , calfun , accum_e , mLPNH , mLPSH ,& nstep , stepsize , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: bobyqa use , INTRINSIC :: ISO_C_BINDING implicit none integer ( 8 ), intent ( in ) :: ipar ( nipar ) real ( sgl ), intent ( inout ) :: fpar ( nfpar ) real ( sgl ), intent ( in ) :: initmeanval ( ninit ) real ( sgl ), intent ( in ) :: stepsize ( nstep ) integer ( irg ), intent ( in ) :: ninit integer ( irg ), intent ( in ) :: nipar integer ( irg ), intent ( in ) :: nfpar integer ( irg ), intent ( in ) :: nstep real ( c_float ), intent ( in ) :: expt1 ( ipar ( 2 ) * ipar ( 3 ) / ipar ( 12 ) ** 2 ) real ( sgl ), intent ( in ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( sgl ), intent ( in ) :: mLPNH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) real ( sgl ), intent ( in ) :: mLPSH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) logical , intent ( in ), optional :: verbose integer , intent ( in ) :: n !! number of variables (must be at least two) integer , intent ( in ) :: npt !! number of interpolation conditions. Its value must be in !! the interval [N+2,(N+1)(N+2)/2]. Choices that exceed 2*N+1 are not !! recommended. real ( dbl ), dimension (:), intent ( inout ) :: x !! Initial values of the variables must be set in X(1),X(2),...,X(N). They !! will be changed to the values that give the least calculated F. real ( dbl ), dimension (:), intent ( in ) :: xl !! lower bounds on x. The construction of quadratic models !! requires XL(I) to be strictly less than XU(I) for each I. Further, !! the contribution to a model from changes to the I-th variable is !! damaged severely by rounding errors if XU(I)-XL(I) is too small. real ( dbl ), dimension (:), intent ( in ) :: xu !! upper bounds on x. The construction of quadratic models !! requires XL(I) to be strictly less than XU(I) for each I. Further, !! the contribution to a model from changes to the I-th variable is !! damaged severely by rounding errors if XU(I)-XL(I) is too small. real ( dbl ), intent ( in ) :: rhobeg !! RHOBEG must be set to the initial value of a trust region radius. !! It must be positive, and typically should be about one tenth of the greatest !! expected change to a variable.  An error return occurs if any of !! the differences XU(I)-XL(I), I=1,...,N, is less than 2*RHOBEG. real ( dbl ), intent ( in ) :: rhoend !! RHOEND must be set to the final value of a trust !! region radius. It must be positive with RHOEND no greater than !! RHOBEG. Typically, RHOEND should indicate the !! accuracy that is required in the final values of the variables. integer , intent ( in ) :: iprint !! IPRINT should be set to 0, 1, 2 or 3, which controls the !! amount of printing. Specifically, there is no output if IPRINT=0 and !! there is output only at the return if IPRINT=1. Otherwise, each new !! value of RHO is printed, with the best vector of variables so far and !! the corresponding value of the objective function. Further, each new !! value of F with its variables are output if IPRINT=3. integer , intent ( in ) :: maxfun !! an upper bound on the number of calls of CALFUN. procedure ( func ) :: calfun !! SUBROUTINE CALFUN (N,X,F) has to be provided by the user. It must set !! F to the value of the objective function for the current values of the !! variables X(1),X(2),...,X(N), which are generated automatically in a !! way that satisfies the bounds given in XL and XU. integer :: ibmat , id , ifv , igo , ihq , ipq , isl , isu , ivl , iw , ixa ,& ixb , ixn , ixo , ixp , izmat , j , jsl , jsu , ndim , np real ( dbl ), dimension (:), allocatable :: w real ( dbl ) :: temp real ( dbl ), parameter :: zero = 0.0_dbl ! The array W will be used for working space. allocate ( w (( NPT + 5 ) * ( NPT + N ) + 3 * N * ( N + 5 ) / 2 ) ) ! !     Return if the value of NPT is unacceptable. ! np = n + 1 if ( npt < n + 2 . or . npt > (( n + 2 ) * np ) / 2 ) then write ( * , '(/4X,A)' ) & 'Return from BOBYQA because NPT is not in the required interval' return end if ! !     Partition the working space array, so that different parts of it can !     be treated separately during the calculation of BOBYQB. The partition !     requires the first (NPT+2)*(NPT+N)+3*N*(N+5)/2 elements of W plus the !     space that is taken by the last array in the argument list of BOBYQB. ! ndim = npt + n ixb = 1 ixp = ixb + n ifv = ixp + n * npt ixo = ifv + npt igo = ixo + n ihq = igo + n ipq = ihq + ( n * np ) / 2 ibmat = ipq + npt izmat = ibmat + ndim * n isl = izmat + npt * ( npt - np ) isu = isl + n ixn = isu + n ixa = ixn + n id = ixa + n ivl = id + n iw = ivl + ndim ! !     Return if there is insufficient space between the bounds. Modify the !     initial X if necessary in order to avoid conflicts between the bounds !     and the construction of the first quadratic model. The lower and upper !     bounds on moves from the updated X are set now, in the ISL and ISU !     partitions of W, in order to provide useful and exact information about !     components of X that become within distance RHOBEG from their bounds. ! do j = 1 , n temp = xu ( j ) - xl ( j ) if ( temp < rhobeg + rhobeg ) then write ( * , '(/4X,A)' ) & 'Return from BOBYQA because one of the differences ' // & 'XU(I)-XL(I) is less than 2*RHOBEG.' return end if jsl = isl + j - 1 jsu = jsl + n w ( jsl ) = xl ( j ) - x ( j ) w ( jsu ) = xu ( j ) - x ( j ) if ( w ( jsl ) >=- rhobeg ) then if ( w ( jsl ) >= zero ) then x ( j ) = xl ( j ) w ( jsl ) = zero w ( jsu ) = temp else x ( j ) = xl ( j ) + rhobeg w ( jsl ) = - rhobeg w ( jsu ) = max ( xu ( j ) - x ( j ), rhobeg ) end if else if ( w ( jsu ) <= rhobeg ) then if ( w ( jsu ) <= zero ) then x ( j ) = xu ( j ) w ( jsl ) = - temp w ( jsu ) = zero else x ( j ) = xu ( j ) - rhobeg w ( jsl ) = min ( xl ( j ) - x ( j ), - rhobeg ) w ( jsu ) = rhobeg end if end if end do ! !     Make the call of BOBYQB. ! if ( present ( verbose )) then call bobyqb ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , n , npt , x , xl , xu , rhobeg , rhoend , iprint ,& maxfun , w ( ixb ), w ( ixp ), w ( ifv ), w ( ixo ), w ( igo ), w ( ihq ), w ( ipq ), w ( ibmat ), w ( izmat ), ndim , w ( isl ), & w ( isu ), w ( ixn ), w ( ixa ), w ( id ), w ( ivl ), w ( iw ), calfun , accum_e , mLPNH , mLPSH , nstep , & stepsize , verbose ) else call bobyqb ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , n , npt , x , xl , xu , rhobeg , rhoend , iprint ,& maxfun , w ( ixb ), w ( ixp ), w ( ifv ), w ( ixo ), w ( igo ), w ( ihq ), w ( ipq ), w ( ibmat ), w ( izmat ), ndim , w ( isl ), & w ( isu ), w ( ixn ), w ( ixa ), w ( id ), w ( ivl ), w ( iw ), calfun , accum_e , mLPNH , mLPSH , nstep , & stepsize ) end if deallocate ( w ) end subroutine bobyqa ! @date 12/12/15 SS 1.1 changed input parameters to the function interfce recursive subroutine bobyqb ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , n , npt , x , xl , xu ,& rhobeg , rhoend , iprint ,& maxfun , xbase , xpt , fval , xopt , gopt , hq , pq , bmat , zmat , ndim , sl , su , xnew , xalt , & d , vlag , w , calfun , accum_e , mLPNH , mLPSH , nstep , stepsize , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: bobyqb implicit real ( dbl ) ( a - h , o - z ) integer ( 8 ), intent ( in ) :: ipar ( nipar ) real ( sgl ), intent ( inout ) :: fpar ( nfpar ) real ( sgl ), intent ( in ) :: initmeanval ( ninit ) integer ( irg ), intent ( in ) :: ninit integer ( irg ), intent ( in ) :: nipar integer ( irg ), intent ( in ) :: nfpar integer ( irg ), intent ( in ) :: nstep real ( sgl ), intent ( in ) :: stepsize ( nstep ) real ( c_float ), intent ( in ) :: expt1 ( ipar ( 2 ) * ipar ( 3 ) / ipar ( 12 ) ** 2 ) real ( sgl ), intent ( in ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( sgl ), intent ( in ) :: mLPNH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) real ( sgl ), intent ( in ) :: mLPSH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) logical , intent ( in ), optional :: verbose dimension x ( * ), xl ( * ), xu ( * ), xbase ( * ), xpt ( npt , * ), fval ( * ), xopt ( * ), & gopt ( * ), hq ( * ), pq ( * ), bmat ( ndim , * ), zmat ( npt , * ), sl ( * ), su ( * ), & xnew ( * ), xalt ( * ), d ( * ), vlag ( * ), w ( * ) procedure ( func ) :: calfun ! !     The arguments N, NPT, X, XL, XU, RHOBEG, RHOEND, IPRINT and MAXFUN !       are identical to the corresponding arguments in SUBROUTINE BOBYQA. !     XBASE holds a shift of origin that should reduce the contributions !       from rounding errors to values of the model and Lagrange functions. !     XPT is a two-dimensional array that holds the coordinates of the !       interpolation points relative to XBASE. !     FVAL holds the values of F at the interpolation points. !     XOPT is set to the displacement from XBASE of the trust region centre. !     GOPT holds the gradient of the quadratic model at XBASE+XOPT. !     HQ holds the explicit second derivatives of the quadratic model. !     PQ contains the parameters of the implicit second derivatives of the !       quadratic model. !     BMAT holds the last N columns of H. !     ZMAT holds the factorization of the leading NPT by NPT submatrix of H, !       this factorization being ZMAT times ZMAT&#94;T, which provides both the !       correct rank and positive semi-definiteness. !     NDIM is the first dimension of BMAT and has the value NPT+N. !     SL and SU hold the differences XL-XBASE and XU-XBASE, respectively. !       All the components of every XOPT are going to satisfy the bounds !       SL(I) .LEQ. XOPT(I) .LEQ. SU(I), with appropriate equalities when !       XOPT is on a constraint boundary. !     XNEW is chosen by SUBROUTINE TRSBOX or ALTMOV. Usually XBASE+XNEW is the !       vector of variables for the next call of CALFUN. XNEW also satisfies !       the SL and SU constraints in the way that has just been mentioned. !     XALT is an alternative to XNEW, chosen by ALTMOV, that may replace XNEW !       in order to increase the denominator in the updating of UPDATE. !     D is reserved for a trial step from XOPT, which is usually XNEW-XOPT. !     VLAG contains the values of the Lagrange functions at a new point X. !       They are part of a product that requires VLAG to be of length NDIM. !     W is a one-dimensional array that is used for working space. Its length !       must be at least 3*NDIM = 3*(NPT+N). ! !     Set some constants. ! half = 0.5_dbl one = 1.0_dbl ten = 1 0.0_dbl tenth = 0.1_dbl two = 2.0_dbl zero = 0.0_dbl np = n + 1 nptm = npt - np nh = ( n * np ) / 2 ! !     The call of PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ, !     BMAT and ZMAT for the first iteration, with the corresponding values of !     of NF and KOPT, which are the number of calls of CALFUN so far and the !     index of the interpolation point at the trust region centre. Then the !     initial XOPT is set too. The branch to label 720 occurs if MAXFUN is !     less than NPT. GOPT will be updated if KOPT is different from KBASE. ! if ( present ( verbose )) then call prelim ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , n , npt , x , xl , xu , rhobeg ,& iprint , maxfun , xbase , xpt , fval , gopt , hq , pq , bmat , zmat , ndim , sl , su , nf , kopt , calfun , accum_e , & mLPNH , mLPSH , nstep , stepsize , verbose ) else call prelim ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , n , npt , x , xl , xu , rhobeg ,& iprint , maxfun , xbase , xpt , fval , gopt , hq , pq , bmat , zmat , ndim , sl , su , nf , kopt , calfun , accum_e , & mLPNH , mLPSH , nstep , stepsize ) end if xoptsq = zero do i = 1 , n xopt ( i ) = xpt ( kopt , i ) xoptsq = xoptsq + xopt ( i ) ** 2 end do fsave = fval ( 1 ) if ( nf < npt ) then if ( iprint > 0 ) write ( * , '(/4X,A)' ) & 'Return from BOBYQA because CALFUN has been called MAXFUN times.' go to 720 end if kbase = 1 ! !     Complete the settings that are required for the iterative procedure. ! rho = rhobeg delta = rho nresc = nf ntrits = 0 diffa = zero diffb = zero itest = 0 nfsav = nf ! !     Update GOPT if necessary before the first iteration and after each !     call of RESCUE that makes a call of CALFUN. ! 20 if ( kopt /= kbase ) then ih = 0 do j = 1 , n do i = 1 , j ih = ih + 1 if ( i < j ) gopt ( j ) = gopt ( j ) + hq ( ih ) * xopt ( i ) gopt ( i ) = gopt ( i ) + hq ( ih ) * xopt ( j ) end do end do if ( nf > npt ) then do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * xopt ( j ) end do temp = pq ( k ) * temp do i = 1 , n gopt ( i ) = gopt ( i ) + temp * xpt ( k , i ) end do end do end if end if ! !     Generate the next point in the trust region that provides a small value !     of the quadratic model subject to the constraints on the variables. !     The integer NTRITS is set to the number \"trust region\" iterations that !     have occurred since the last \"alternative\" iteration. If the length !     of XNEW-XOPT is less than HALF*RHO, however, then there is a branch to !     label 650 or 680 with NTRITS=-1, instead of calculating F at XNEW. ! 60 call trsbox ( n , npt , xpt , xopt , gopt , hq , pq , sl , su , delta , xnew , d , w , w ( np ), & & w ( np + n ), w ( np + 2 * n ), w ( np + 3 * n ), dsq , crvmin ) dnorm = min ( delta , sqrt ( dsq )) if ( dnorm < half * rho ) then ntrits = - 1 distsq = ( ten * rho ) ** 2 if ( nf <= nfsav + 2 ) go to 650 ! !     The following choice between labels 650 and 680 depends on whether or !     not our work with the current RHO seems to be complete. Either RHO is !     decreased or termination occurs if the errors in the quadratic model at !     the last three interpolation points compare favourably with predictions !     of likely improvements to the model within distance HALF*RHO of XOPT. ! errbig = max ( diffa , diffb , diffc ) frhosq = 0.125_dbl * rho * rho if ( crvmin > zero . and . errbig > frhosq * crvmin ) go to 650 bdtol = errbig / rho do j = 1 , n bdtest = bdtol if ( xnew ( j ) == sl ( j )) bdtest = w ( j ) if ( xnew ( j ) == su ( j )) bdtest = - w ( j ) if ( bdtest < bdtol ) then curv = hq (( j + j * j ) / 2 ) do k = 1 , npt curv = curv + pq ( k ) * xpt ( k , j ) ** 2 end do bdtest = bdtest + half * curv * rho if ( bdtest < bdtol ) go to 650 end if end do go to 680 end if ntrits = ntrits + 1 ! !     Severe cancellation is likely to occur if XOPT is too far from XBASE. !     If the following test holds, then XBASE is shifted so that XOPT becomes !     zero. The appropriate changes are made to BMAT and to the second !     derivatives of the current model, beginning with the changes to BMAT !     that do not depend on ZMAT. VLAG is used temporarily for working space. ! 90 if ( dsq <= 1.0e-3_dbl * xoptsq ) then fracsq = 0.25_dbl * xoptsq sumpq = zero do k = 1 , npt sumpq = sumpq + pq ( k ) sum = - half * xoptsq do i = 1 , n sum = sum + xpt ( k , i ) * xopt ( i ) end do w ( npt + k ) = sum temp = fracsq - half * sum do i = 1 , n w ( i ) = bmat ( k , i ) vlag ( i ) = sum * xpt ( k , i ) + temp * xopt ( i ) ip = npt + i do j = 1 , i bmat ( ip , j ) = bmat ( ip , j ) + w ( i ) * vlag ( j ) + vlag ( i ) * w ( j ) end do end do end do ! !     Then the revisions of BMAT that depend on ZMAT are calculated. ! do jj = 1 , nptm sumz = zero sumw = zero do k = 1 , npt sumz = sumz + zmat ( k , jj ) vlag ( k ) = w ( npt + k ) * zmat ( k , jj ) sumw = sumw + vlag ( k ) end do do j = 1 , n sum = ( fracsq * sumz - half * sumw ) * xopt ( j ) do k = 1 , npt sum = sum + vlag ( k ) * xpt ( k , j ) end do w ( j ) = sum do k = 1 , npt bmat ( k , j ) = bmat ( k , j ) + sum * zmat ( k , jj ) end do end do do i = 1 , n ip = i + npt temp = w ( i ) do j = 1 , i bmat ( ip , j ) = bmat ( ip , j ) + temp * w ( j ) end do end do end do ! !     The following instructions complete the shift, including the changes !     to the second derivative parameters of the quadratic model. ! ih = 0 do j = 1 , n w ( j ) = - half * sumpq * xopt ( j ) do k = 1 , npt w ( j ) = w ( j ) + pq ( k ) * xpt ( k , j ) xpt ( k , j ) = xpt ( k , j ) - xopt ( j ) end do do i = 1 , j ih = ih + 1 hq ( ih ) = hq ( ih ) + w ( i ) * xopt ( j ) + xopt ( i ) * w ( j ) bmat ( npt + i , j ) = bmat ( npt + j , i ) end do end do do i = 1 , n xbase ( i ) = xbase ( i ) + xopt ( i ) xnew ( i ) = xnew ( i ) - xopt ( i ) sl ( i ) = sl ( i ) - xopt ( i ) su ( i ) = su ( i ) - xopt ( i ) xopt ( i ) = zero end do xoptsq = zero end if if ( ntrits == 0 ) go to 210 go to 230 ! !     XBASE is also moved to XOPT by a call of RESCUE. This calculation is !     more expensive than the previous shift, because new matrices BMAT and !     ZMAT are generated from scratch, which may include the replacement of !     interpolation points whose positions seem to be causing near linear !     dependence in the interpolation conditions. Therefore RESCUE is called !     only if rounding errors have reduced by at least a factor of two the !     denominator of the formula for updating the H matrix. It provides a !     useful safeguard, but is not invoked in most applications of BOBYQA. ! 190 nfsav = nf kbase = kopt if ( present ( verbose )) then call rescue ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , n , npt , xl , xu , iprint , maxfun , xbase ,& xpt , fval , xopt , gopt , hq , pq , bmat , zmat , ndim , sl , su , nf , delta , kopt , vlag , w , w ( n + np ), w ( ndim + np ), & calfun , accum_e , mLPNH , mLPSH , nstep , stepsize , verbose ) else call rescue ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , n , npt , xl , xu , iprint , maxfun , xbase ,& xpt , fval , xopt , gopt , hq , pq , bmat , zmat , ndim , sl , su , nf , delta , kopt , vlag , w , w ( n + np ), w ( ndim + np ), & calfun , accum_e , mLPNH , mLPSH , nstep , stepsize ) end if ! !     XOPT is updated now in case the branch below to label 720 is taken. !     Any updating of GOPT occurs after the branch below to label 20, which !     leads to a trust region iteration as does the branch to label 60. ! xoptsq = zero if ( kopt /= kbase ) then do i = 1 , n xopt ( i ) = xpt ( kopt , i ) xoptsq = xoptsq + xopt ( i ) ** 2 end do end if if ( nf < 0 ) then nf = maxfun if ( iprint > 0 ) write ( * , '(/4X,A)' ) & 'Return from BOBYQA because CALFUN has been called MAXFUN times.' go to 720 end if nresc = nf if ( nfsav < nf ) then nfsav = nf go to 20 end if if ( ntrits > 0 ) go to 60 ! !     Pick two alternative vectors of variables, relative to XBASE, that !     are suitable as new positions of the KNEW-th interpolation point. !     Firstly, XNEW is set to the point on a line through XOPT and another !     interpolation point that minimizes the predicted value of the next !     denominator, subject to ||XNEW - XOPT|| .LEQ. ADELT and to the SL !     and SU bounds. Secondly, XALT is set to the best feasible point on !     a constrained version of the Cauchy step of the KNEW-th Lagrange !     function, the corresponding value of the square of this function !     being returned in CAUCHY. The choice between these alternatives is !     going to be made when the denominator is calculated. ! 210 call altmov ( n , npt , xpt , xopt , bmat , zmat , ndim , sl , su , kopt , knew , adelt , & & xnew , xalt , alpha , cauchy , w , w ( np ), w ( ndim + 1 )) do i = 1 , n d ( i ) = xnew ( i ) - xopt ( i ) end do ! !     Calculate VLAG and BETA for the current choice of D. The scalar !     product of D with XPT(K,.) is going to be held in W(NPT+K) for !     use when VQUAD is calculated. ! 230 do k = 1 , npt suma = zero sumb = zero sum = zero do j = 1 , n suma = suma + xpt ( k , j ) * d ( j ) sumb = sumb + xpt ( k , j ) * xopt ( j ) sum = sum + bmat ( k , j ) * d ( j ) end do w ( k ) = suma * ( half * suma + sumb ) vlag ( k ) = sum w ( npt + k ) = suma end do beta = zero do jj = 1 , nptm sum = zero do k = 1 , npt sum = sum + zmat ( k , jj ) * w ( k ) end do beta = beta - sum * sum do k = 1 , npt vlag ( k ) = vlag ( k ) + sum * zmat ( k , jj ) end do end do dsq = zero bsum = zero dx = zero do j = 1 , n dsq = dsq + d ( j ) ** 2 sum = zero do k = 1 , npt sum = sum + w ( k ) * bmat ( k , j ) end do bsum = bsum + sum * d ( j ) jp = npt + j do i = 1 , n sum = sum + bmat ( jp , i ) * d ( i ) end do vlag ( jp ) = sum bsum = bsum + sum * d ( j ) dx = dx + d ( j ) * xopt ( j ) end do beta = dx * dx + dsq * ( xoptsq + dx + dx + half * dsq ) + beta - bsum vlag ( kopt ) = vlag ( kopt ) + one ! !     If NTRITS is zero, the denominator may be increased by replacing !     the step D of ALTMOV by a Cauchy step. Then RESCUE may be called if !     rounding errors have damaged the chosen denominator. ! if ( ntrits == 0 ) then denom = vlag ( knew ) ** 2 + alpha * beta if ( denom < cauchy . and . cauchy > zero ) then do i = 1 , n xnew ( i ) = xalt ( i ) d ( i ) = xnew ( i ) - xopt ( i ) end do cauchy = zero go to 230 end if if ( denom <= half * vlag ( knew ) ** 2 ) then if ( nf > nresc ) go to 190 if ( iprint > 0 ) write ( * , '(/5X,A)' ) & 'Return from BOBYQA because of much cancellation in a denominator.' go to 720 end if ! !     Alternatively, if NTRITS is positive, then set KNEW to the index of !     the next interpolation point to be deleted to make room for a trust !     region step. Again RESCUE may be called if rounding errors have damaged !     the chosen denominator, which is the reason for attempting to select !     KNEW before calculating the next value of the objective function. ! else delsq = delta * delta scaden = zero biglsq = zero knew = 0 do k = 1 , npt if ( k == kopt ) cycle hdiag = zero do jj = 1 , nptm hdiag = hdiag + zmat ( k , jj ) ** 2 end do den = beta * hdiag + vlag ( k ) ** 2 distsq = zero do j = 1 , n distsq = distsq + ( xpt ( k , j ) - xopt ( j )) ** 2 end do temp = max ( one , ( distsq / delsq ) ** 2 ) if ( temp * den > scaden ) then scaden = temp * den knew = k denom = den end if biglsq = max ( biglsq , temp * vlag ( k ) ** 2 ) end do if ( scaden <= half * biglsq ) then if ( nf > nresc ) go to 190 if ( iprint > 0 ) write ( * , '(/5X,A)' ) & 'Return from BOBYQA because of much cancellation in a denominator.' go to 720 end if end if ! !     Put the variables for the next calculation of the objective function !       in XNEW, with any adjustments for the bounds. ! ! !     Calculate the value of the objective function at XBASE+XNEW, unless !       the limit on the number of calculations of F has been reached. ! 360 do i = 1 , n x ( i ) = min ( max ( xl ( i ), xbase ( i ) + xnew ( i )), xu ( i )) if ( xnew ( i ) == sl ( i )) x ( i ) = xl ( i ) if ( xnew ( i ) == su ( i )) x ( i ) = xu ( i ) end do if ( nf >= maxfun ) then if ( iprint > 0 ) write ( * , '(/4X,A)' ) & 'Return from BOBYQA because CALFUN has been called MAXFUN times.' go to 720 end if nf = nf + 1 !======================================================================================= !============changed function call depending on how many call have been made============ !======================================================================================= if ( present ( verbose )) then call calfun ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , accum_e , mLPNH , mLPSH , & n , x ( 1 : n ), f , nstep , stepsize , verbose = verbose ) else call calfun ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , accum_e , mLPNH , mLPSH , & n , x ( 1 : n ), f , nstep , stepsize ) end if if ( iprint == 3 ) then print 400 , nf , f , ( x ( i ), i = 1 , n ) 400 format ( / 4 x , 'Function number' , i6 , '    F =' , 1 pd18 . 10 ,& '   The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if if ( ntrits ==- 1 ) then fsave = f go to 720 end if ! !     Use the quadratic model to predict the change in F due to the step D, !       and set DIFF to the error of this prediction. ! fopt = fval ( kopt ) vquad = zero ih = 0 do j = 1 , n vquad = vquad + d ( j ) * gopt ( j ) do i = 1 , j ih = ih + 1 temp = d ( i ) * d ( j ) if ( i == j ) temp = half * temp vquad = vquad + hq ( ih ) * temp end do end do do k = 1 , npt vquad = vquad + half * pq ( k ) * w ( npt + k ) ** 2 end do diff = f - fopt - vquad diffc = diffb diffb = diffa diffa = abs ( diff ) if ( dnorm > rho ) nfsav = nf ! !     Pick the next value of DELTA after a trust region step. ! if ( ntrits > 0 ) then if ( vquad >= zero ) then if ( iprint > 0 ) print 430 430 format ( / 4 x , 'Return from BOBYQA because a trust' ,& ' region step has failed to reduce Q.' ) go to 720 end if ratio = ( f - fopt ) / vquad if ( ratio <= tenth ) then delta = min ( half * delta , dnorm ) else if ( ratio <= 0.7_dbl ) then delta = max ( half * delta , dnorm ) else delta = max ( half * delta , dnorm + dnorm ) end if if ( delta <= 1.5_dbl * rho ) delta = rho ! !     Recalculate KNEW and DENOM if the new F is less than FOPT. ! if ( f < fopt ) then ksav = knew densav = denom delsq = delta * delta scaden = zero biglsq = zero knew = 0 do k = 1 , npt hdiag = zero do jj = 1 , nptm hdiag = hdiag + zmat ( k , jj ) ** 2 end do den = beta * hdiag + vlag ( k ) ** 2 distsq = zero do j = 1 , n distsq = distsq + ( xpt ( k , j ) - xnew ( j )) ** 2 end do temp = max ( one , ( distsq / delsq ) ** 2 ) if ( temp * den > scaden ) then scaden = temp * den knew = k denom = den end if biglsq = max ( biglsq , temp * vlag ( k ) ** 2 ) end do if ( scaden <= half * biglsq ) then knew = ksav denom = densav end if end if end if ! !     Update BMAT and ZMAT, so that the KNEW-th interpolation point can be !     moved. Also update the second derivative terms of the model. ! call update ( n , npt , bmat , zmat , ndim , vlag , beta , denom , knew , w ) ih = 0 pqold = pq ( knew ) pq ( knew ) = zero do i = 1 , n temp = pqold * xpt ( knew , i ) do j = 1 , i ih = ih + 1 hq ( ih ) = hq ( ih ) + temp * xpt ( knew , j ) end do end do do jj = 1 , nptm temp = diff * zmat ( knew , jj ) do k = 1 , npt pq ( k ) = pq ( k ) + temp * zmat ( k , jj ) end do end do ! !     Include the new interpolation point, and make the changes to GOPT at !     the old XOPT that are caused by the updating of the quadratic model. ! fval ( knew ) = f do i = 1 , n xpt ( knew , i ) = xnew ( i ) w ( i ) = bmat ( knew , i ) end do do k = 1 , npt suma = zero do jj = 1 , nptm suma = suma + zmat ( knew , jj ) * zmat ( k , jj ) end do sumb = zero do j = 1 , n sumb = sumb + xpt ( k , j ) * xopt ( j ) end do temp = suma * sumb do i = 1 , n w ( i ) = w ( i ) + temp * xpt ( k , i ) end do end do do i = 1 , n gopt ( i ) = gopt ( i ) + diff * w ( i ) end do ! !     Update XOPT, GOPT and KOPT if the new calculated F is less than FOPT. ! if ( f < fopt ) then kopt = knew xoptsq = zero ih = 0 do j = 1 , n xopt ( j ) = xnew ( j ) xoptsq = xoptsq + xopt ( j ) ** 2 do i = 1 , j ih = ih + 1 if ( i < j ) gopt ( j ) = gopt ( j ) + hq ( ih ) * d ( i ) gopt ( i ) = gopt ( i ) + hq ( ih ) * d ( j ) end do end do do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * d ( j ) end do temp = pq ( k ) * temp do i = 1 , n gopt ( i ) = gopt ( i ) + temp * xpt ( k , i ) end do end do end if ! !     Calculate the parameters of the least Frobenius norm interpolant to !     the current data, the gradient of this interpolant at XOPT being put !     into VLAG(NPT+I), I=1,2,...,N. ! if ( ntrits > 0 ) then do k = 1 , npt vlag ( k ) = fval ( k ) - fval ( kopt ) w ( k ) = zero end do do j = 1 , nptm sum = zero do k = 1 , npt sum = sum + zmat ( k , j ) * vlag ( k ) end do do k = 1 , npt w ( k ) = w ( k ) + sum * zmat ( k , j ) end do end do do k = 1 , npt sum = zero do j = 1 , n sum = sum + xpt ( k , j ) * xopt ( j ) end do w ( k + npt ) = w ( k ) w ( k ) = sum * w ( k ) end do gqsq = zero gisq = zero do i = 1 , n sum = zero do k = 1 , npt sum = sum + bmat ( k , i ) * vlag ( k ) + xpt ( k , i ) * w ( k ) end do if ( xopt ( i ) == sl ( i )) then gqsq = gqsq + min ( zero , gopt ( i )) ** 2 gisq = gisq + min ( zero , sum ) ** 2 else if ( xopt ( i ) == su ( i )) then gqsq = gqsq + max ( zero , gopt ( i )) ** 2 gisq = gisq + max ( zero , sum ) ** 2 else gqsq = gqsq + gopt ( i ) ** 2 gisq = gisq + sum * sum end if vlag ( npt + i ) = sum end do ! !     Test whether to replace the new quadratic model by the least Frobenius !     norm interpolant, making the replacement if the test is satisfied. ! itest = itest + 1 if ( gqsq < ten * gisq ) itest = 0 if ( itest >= 3 ) then do i = 1 , max ( npt , nh ) if ( i <= n ) gopt ( i ) = vlag ( npt + i ) if ( i <= npt ) pq ( i ) = w ( npt + i ) if ( i <= nh ) hq ( i ) = zero itest = 0 end do end if end if ! !     If a trust region step has provided a sufficient decrease in F, then !     branch for another trust region calculation. The case NTRITS=0 occurs !     when the new interpolation point was reached by an alternative step. ! if ( ntrits == 0 ) go to 60 if ( f <= fopt + tenth * vquad ) go to 60 ! !     Alternatively, find out if the interpolation points are close enough !       to the best point so far. ! distsq = max (( two * delta ) ** 2 , ( ten * rho ) ** 2 ) 650 knew = 0 do k = 1 , npt sum = zero do j = 1 , n sum = sum + ( xpt ( k , j ) - xopt ( j )) ** 2 end do if ( sum > distsq ) then knew = k distsq = sum end if end do ! !     If KNEW is positive, then ALTMOV finds alternative new positions for !     the KNEW-th interpolation point within distance ADELT of XOPT. It is !     reached via label 90. Otherwise, there is a branch to label 60 for !     another trust region iteration, unless the calculations with the !     current RHO are complete. ! if ( knew > 0 ) then dist = sqrt ( distsq ) if ( ntrits ==- 1 ) then delta = min ( tenth * delta , half * dist ) if ( delta <= 1.5_dbl * rho ) delta = rho end if ntrits = 0 adelt = max ( min ( tenth * dist , delta ), rho ) dsq = adelt * adelt go to 90 end if if ( ntrits ==- 1 ) go to 680 if ( ratio > zero ) go to 60 if ( max ( delta , dnorm ) > rho ) go to 60 ! !     The calculations with the current value of RHO are complete. Pick the !       next values of RHO and DELTA. ! 680 if ( rho > rhoend ) then delta = half * rho ratio = rho / rhoend if ( ratio <= 1 6.0_dbl ) then rho = rhoend else if ( ratio <= 25 0.0_dbl ) then rho = sqrt ( ratio ) * rhoend else rho = tenth * rho end if delta = max ( delta , rho ) if ( iprint >= 2 ) then if ( iprint >= 3 ) print 690 690 format ( 5 x ) print 700 , rho , nf 700 format ( / 4 x , 'New RHO =' , 1 pd11 . 4 , 5 x , 'Number of' ,& ' function values =' , i6 ) print 710 , fval ( kopt ), ( xbase ( i ) + xopt ( i ), i = 1 , n ) 710 format ( 4 x , 'Least value of F =' , 1 pd23 . 15 , 9 x ,& 'The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if ntrits = 0 nfsav = nf go to 60 end if ! !     Return from the calculation, after another Newton-Raphson step, if !       it is too short to have been tried before. ! if ( ntrits ==- 1 ) go to 360 720 if ( fval ( kopt ) <= fsave ) then do i = 1 , n x ( i ) = min ( max ( xl ( i ), xbase ( i ) + xopt ( i )), xu ( i )) if ( xopt ( i ) == sl ( i )) x ( i ) = xl ( i ) if ( xopt ( i ) == su ( i )) x ( i ) = xu ( i ) end do f = fval ( kopt ) end if if ( iprint >= 1 ) then print 740 , nf 740 format ( / 4 x , 'At the return from BOBYQA' , 5 x ,& 'Number of function values =' , i6 ) print 710 , f , ( x ( i ), i = 1 , n ) end if return end subroutine bobyqb recursive subroutine altmov ( n , npt , xpt , xopt , bmat , zmat , ndim , sl , su , kopt , knew , adelt , & & xnew , xalt , alpha , cauchy , glag , hcol , w ) !DEC$ ATTRIBUTES DLLEXPORT :: altmov implicit real ( dbl ) ( a - h , o - z ) dimension xpt ( npt , * ), xopt ( * ), bmat ( ndim , * ), zmat ( npt , * ), sl ( * ), su ( * ), & & xnew ( * ), xalt ( * ), glag ( * ), hcol ( * ), w ( * ) ! !     The arguments N, NPT, XPT, XOPT, BMAT, ZMAT, NDIM, SL and SU all have !       the same meanings as the corresponding arguments of BOBYQB. !     KOPT is the index of the optimal interpolation point. !     KNEW is the index of the interpolation point that is going to be moved. !     ADELT is the current trust region bound. !     XNEW will be set to a suitable new position for the interpolation point !       XPT(KNEW,.). Specifically, it satisfies the SL, SU and trust region !       bounds and it should provide a large denominator in the next call of !       UPDATE. The step XNEW-XOPT from XOPT is restricted to moves along the !       straight lines through XOPT and another interpolation point. !     XALT also provides a large value of the modulus of the KNEW-th Lagrange !       function subject to the constraints that have been mentioned, its main !       difference from XNEW being that XALT-XOPT is a constrained version of !       the Cauchy step within the trust region. An exception is that XALT is !       not calculated if all components of GLAG (see below) are zero. !     ALPHA will be set to the KNEW-th diagonal element of the H matrix. !     CAUCHY will be set to the square of the KNEW-th Lagrange function at !       the step XALT-XOPT from XOPT for the vector XALT that is returned, !       except that CAUCHY is set to zero if XALT is not calculated. !     GLAG is a working space vector of length N for the gradient of the !       KNEW-th Lagrange function at XOPT. !     HCOL is a working space vector of length NPT for the second derivative !       coefficients of the KNEW-th Lagrange function. !     W is a working space vector of length 2N that is going to hold the !       constrained Cauchy step from XOPT of the Lagrange function, followed !       by the downhill version of XALT when the uphill step is calculated. ! !     Set the first NPT components of W to the leading elements of the !     KNEW-th column of the H matrix. ! half = 0.5_dbl one = 1.0_dbl zero = 0.0_dbl const = one + sqrt ( 2.0_dbl ) do k = 1 , npt hcol ( k ) = zero end do do j = 1 , npt - n - 1 temp = zmat ( knew , j ) do k = 1 , npt hcol ( k ) = hcol ( k ) + temp * zmat ( k , j ) end do end do alpha = hcol ( knew ) ha = half * alpha ! !     Calculate the gradient of the KNEW-th Lagrange function at XOPT. ! do i = 1 , n glag ( i ) = bmat ( knew , i ) end do do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * xopt ( j ) end do temp = hcol ( k ) * temp do i = 1 , n glag ( i ) = glag ( i ) + temp * xpt ( k , i ) end do end do ! !     Search for a large denominator along the straight lines through XOPT !     and another interpolation point. SLBD and SUBD will be lower and upper !     bounds on the step along each of these lines in turn. PREDSQ will be !     set to the square of the predicted denominator for each line. PRESAV !     will be set to the largest admissible value of PREDSQ that occurs. ! presav = zero do k = 1 , npt if ( k == kopt ) cycle dderiv = zero distsq = zero do i = 1 , n temp = xpt ( k , i ) - xopt ( i ) dderiv = dderiv + glag ( i ) * temp distsq = distsq + temp * temp end do subd = adelt / sqrt ( distsq ) slbd = - subd ilbd = 0 iubd = 0 sumin = min ( one , subd ) ! !     Revise SLBD and SUBD if necessary because of the bounds in SL and SU. ! do i = 1 , n temp = xpt ( k , i ) - xopt ( i ) if ( temp > zero ) then if ( slbd * temp < sl ( i ) - xopt ( i )) then slbd = ( sl ( i ) - xopt ( i )) / temp ilbd = - i end if if ( subd * temp > su ( i ) - xopt ( i )) then subd = max ( sumin , ( su ( i ) - xopt ( i )) / temp ) iubd = i end if else if ( temp < zero ) then if ( slbd * temp > su ( i ) - xopt ( i )) then slbd = ( su ( i ) - xopt ( i )) / temp ilbd = i end if if ( subd * temp < sl ( i ) - xopt ( i )) then subd = max ( sumin , ( sl ( i ) - xopt ( i )) / temp ) iubd = - i end if end if end do ! !     Seek a large modulus of the KNEW-th Lagrange function when the index !     of the other interpolation point on the line through XOPT is KNEW. ! if ( k == knew ) then diff = dderiv - one step = slbd vlag = slbd * ( dderiv - slbd * diff ) isbd = ilbd temp = subd * ( dderiv - subd * diff ) if ( abs ( temp ) > abs ( vlag )) then step = subd vlag = temp isbd = iubd end if tempd = half * dderiv tempa = tempd - diff * slbd tempb = tempd - diff * subd if ( tempa * tempb < zero ) then temp = tempd * tempd / diff if ( abs ( temp ) > abs ( vlag )) then step = tempd / diff vlag = temp isbd = 0 end if end if ! !     Search along each of the other lines through XOPT and another point. ! else step = slbd vlag = slbd * ( one - slbd ) isbd = ilbd temp = subd * ( one - subd ) if ( abs ( temp ) > abs ( vlag )) then step = subd vlag = temp isbd = iubd end if if ( subd > half ) then if ( abs ( vlag ) < 0.25_dbl ) then step = half vlag = 0.25_dbl isbd = 0 end if end if vlag = vlag * dderiv end if ! !     Calculate PREDSQ for the current line search and maintain PRESAV. ! temp = step * ( one - step ) * distsq predsq = vlag * vlag * ( vlag * vlag + ha * temp * temp ) if ( predsq > presav ) then presav = predsq ksav = k stpsav = step ibdsav = isbd end if end do ! !     Construct XNEW in a way that satisfies the bound constraints exactly. ! do i = 1 , n temp = xopt ( i ) + stpsav * ( xpt ( ksav , i ) - xopt ( i )) xnew ( i ) = max ( sl ( i ), min ( su ( i ), temp )) end do if ( ibdsav < 0 ) xnew ( - ibdsav ) = sl ( - ibdsav ) if ( ibdsav > 0 ) xnew ( ibdsav ) = su ( ibdsav ) ! !     Prepare for the iterative method that assembles the constrained Cauchy !     step in W. The sum of squares of the fixed components of W is formed in !     WFIXSQ, and the free components of W are set to BIGSTP. ! bigstp = adelt + adelt iflag = 0 100 wfixsq = zero ggfree = zero do i = 1 , n w ( i ) = zero tempa = min ( xopt ( i ) - sl ( i ), glag ( i )) tempb = max ( xopt ( i ) - su ( i ), glag ( i )) if ( tempa > zero . or . tempb < zero ) then w ( i ) = bigstp ggfree = ggfree + glag ( i ) ** 2 end if end do if ( ggfree == zero ) then cauchy = zero return end if ! !     Investigate whether more components of W can be fixed. ! 120 temp = adelt * adelt - wfixsq if ( temp > zero ) then wsqsav = wfixsq step = sqrt ( temp / ggfree ) ggfree = zero do i = 1 , n if ( w ( i ) == bigstp ) then temp = xopt ( i ) - step * glag ( i ) if ( temp <= sl ( i )) then w ( i ) = sl ( i ) - xopt ( i ) wfixsq = wfixsq + w ( i ) ** 2 else if ( temp >= su ( i )) then w ( i ) = su ( i ) - xopt ( i ) wfixsq = wfixsq + w ( i ) ** 2 else ggfree = ggfree + glag ( i ) ** 2 end if end if end do if ( wfixsq > wsqsav . and . ggfree > zero ) go to 120 end if ! !     Set the remaining free components of W and all components of XALT, !     except that W may be scaled later. ! gw = zero do i = 1 , n if ( w ( i ) == bigstp ) then w ( i ) = - step * glag ( i ) xalt ( i ) = max ( sl ( i ), min ( su ( i ), xopt ( i ) + w ( i ))) else if ( w ( i ) == zero ) then xalt ( i ) = xopt ( i ) else if ( glag ( i ) > zero ) then xalt ( i ) = sl ( i ) else xalt ( i ) = su ( i ) end if gw = gw + glag ( i ) * w ( i ) end do ! !     Set CURV to the curvature of the KNEW-th Lagrange function along W. !     Scale W by a factor less than one if that can reduce the modulus of !     the Lagrange function at XOPT+W. Set CAUCHY to the final value of !     the square of this function. ! curv = zero do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * w ( j ) end do curv = curv + hcol ( k ) * temp * temp end do if ( iflag == 1 ) curv = - curv if ( curv >- gw . and . curv <- const * gw ) then scale = - gw / curv do i = 1 , n temp = xopt ( i ) + scale * w ( i ) xalt ( i ) = max ( sl ( i ), min ( su ( i ), temp )) end do cauchy = ( half * gw * scale ) ** 2 else cauchy = ( gw + half * curv ) ** 2 end if ! !     If IFLAG is zero, then XALT is calculated as before after reversing !     the sign of GLAG. Thus two XALT vectors become available. The one that !     is chosen is the one that gives the larger value of CAUCHY. ! if ( iflag == 0 ) then do i = 1 , n glag ( i ) = - glag ( i ) w ( n + i ) = xalt ( i ) end do csave = cauchy iflag = 1 go to 100 end if if ( csave > cauchy ) then do i = 1 , n xalt ( i ) = w ( n + i ) end do cauchy = csave end if end subroutine altmov ! @date 12/12/15 SS 1.1 changed input parameters to the subroutine recursive subroutine prelim ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , n , npt , x , xl , xu , rhobeg ,& iprint , maxfun , xbase , xpt , fval , gopt , hq , pq , bmat , zmat , ndim , sl , su , nf , kopt , calfun , accum_e , mLPNH , mLPSH ,& nstep , stepsize , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: prelim implicit real ( dbl ) ( a - h , o - z ) integer ( 8 ), intent ( in ) :: ipar ( nipar ) real ( sgl ), intent ( inout ) :: fpar ( nfpar ) real ( sgl ), intent ( in ) :: initmeanval ( ninit ) integer ( irg ), intent ( in ) :: ninit integer ( irg ), intent ( in ) :: nipar integer ( irg ), intent ( in ) :: nfpar integer ( irg ), intent ( in ) :: nstep real ( sgl ), intent ( in ) :: stepsize ( nstep ) real ( c_float ), intent ( in ) :: expt1 ( ipar ( 2 ) * ipar ( 3 ) / ipar ( 12 ) ** 2 ) real ( sgl ), intent ( in ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( sgl ), intent ( in ) :: mLPNH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) real ( sgl ), intent ( in ) :: mLPSH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) logical , intent ( in ), optional :: verbose dimension x ( * ), xl ( * ), xu ( * ), xbase ( * ), xpt ( npt , * ), fval ( * ), gopt ( * ), hq & & ( * ), pq ( * ), bmat ( ndim , * ), zmat ( npt , * ), sl ( * ), su ( * ) procedure ( func ) :: calfun ! !     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the !       same as the corresponding arguments in SUBROUTINE BOBYQA. !     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU !       are the same as the corresponding arguments in BOBYQB, the elements !       of SL and SU being set in BOBYQA. !     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but !       it is set by PRELIM to the gradient of the quadratic model at XBASE. !       If XOPT is nonzero, BOBYQB will change it to its usual value later. !     NF is maintaned as the number of calls of CALFUN so far. !     KOPT will be such that the least calculated value of F so far is at !       the point XPT(KOPT,.)+XBASE in the space of the variables. ! !     SUBROUTINE PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ, !     BMAT and ZMAT for the first iteration, and it maintains the values of !     NF and KOPT. The vector X is also changed by PRELIM. ! !     Set some constants. ! half = 0.5_dbl one = 1.0_dbl two = 2.0_dbl zero = 0.0_dbl rhosq = rhobeg * rhobeg recip = one / rhosq np = n + 1 ! !     Set XBASE to the initial vector of variables, and set the initial !     elements of XPT, BMAT, HQ, PQ and ZMAT to zero. ! do j = 1 , n xbase ( j ) = x ( j ) do k = 1 , npt xpt ( k , j ) = zero end do do i = 1 , ndim bmat ( i , j ) = zero end do end do do ih = 1 , ( n * np ) / 2 hq ( ih ) = zero end do do k = 1 , npt pq ( k ) = zero do j = 1 , npt - np zmat ( k , j ) = zero end do end do ! !     Begin the initialization procedure. NF becomes one more than the number !     of function values so far. The coordinates of the displacement of the !     next initial interpolation point from XBASE are set in XPT(NF+1,.). ! nf = 0 50 nfm = nf nfx = nf - n nf = nf + 1 if ( nfm <= 2 * n ) then if ( nfm >= 1 . and . nfm <= n ) then stepa = rhobeg if ( su ( nfm ) == zero ) stepa = - stepa xpt ( nf , nfm ) = stepa else if ( nfm > n ) then stepa = xpt ( nf - n , nfx ) stepb = - rhobeg if ( sl ( nfx ) == zero ) stepb = min ( two * rhobeg , su ( nfx )) if ( su ( nfx ) == zero ) stepb = max ( - two * rhobeg , sl ( nfx )) xpt ( nf , nfx ) = stepb end if else itemp = ( nfm - np ) / n jpt = nfm - itemp * n - n ipt = jpt + itemp if ( ipt > n ) then itemp = jpt jpt = ipt - n ipt = itemp end if xpt ( nf , ipt ) = xpt ( ipt + 1 , ipt ) xpt ( nf , jpt ) = xpt ( jpt + 1 , jpt ) end if ! !     Calculate the next value of F. The least function value so far and !     its index are required. ! do j = 1 , n x ( j ) = min ( max ( xl ( j ), xbase ( j ) + xpt ( nf , j )), xu ( j )) if ( xpt ( nf , j ) == sl ( j )) x ( j ) = xl ( j ) if ( xpt ( nf , j ) == su ( j )) x ( j ) = xu ( j ) end do !======================================================================================= !============changed function call depending on how many call have been made============ !======================================================================================= if ( present ( verbose )) then call calfun ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , accum_e , mLPNH , mLPSH , & n , x ( 1 : n ), f , nstep , stepsize , verbose = verbose ) else call calfun ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , accum_e , mLPNH , mLPSH , & n , x ( 1 : n ), f , nstep , stepsize ) end if if ( iprint == 3 ) then print 70 , nf , f , ( x ( i ), i = 1 , n ) 70 format ( / 4 x , 'Function number' , i6 , '    F =' , 1 pd18 . 10 ,& '    The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if fval ( nf ) = f if ( nf == 1 ) then fbeg = f kopt = 1 else if ( f < fval ( kopt )) then kopt = nf end if ! !     Set the nonzero initial elements of BMAT and the quadratic model in the !     cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions !     of the NF-th and (NF-N)-th interpolation points may be switched, in !     order that the function value at the first of them contributes to the !     off-diagonal second derivative terms of the initial quadratic model. ! if ( nf <= 2 * n + 1 ) then if ( nf >= 2 . and . nf <= n + 1 ) then gopt ( nfm ) = ( f - fbeg ) / stepa if ( npt < nf + n ) then bmat ( 1 , nfm ) = - one / stepa bmat ( nf , nfm ) = one / stepa bmat ( npt + nfm , nfm ) = - half * rhosq end if else if ( nf >= n + 2 ) then ih = ( nfx * ( nfx + 1 )) / 2 temp = ( f - fbeg ) / stepb diff = stepb - stepa hq ( ih ) = two * ( temp - gopt ( nfx )) / diff gopt ( nfx ) = ( gopt ( nfx ) * stepb - temp * stepa ) / diff if ( stepa * stepb < zero ) then if ( f < fval ( nf - n )) then fval ( nf ) = fval ( nf - n ) fval ( nf - n ) = f if ( kopt == nf ) kopt = nf - n xpt ( nf - n , nfx ) = stepb xpt ( nf , nfx ) = stepa end if end if bmat ( 1 , nfx ) = - ( stepa + stepb ) / ( stepa * stepb ) bmat ( nf , nfx ) = - half / xpt ( nf - n , nfx ) bmat ( nf - n , nfx ) = - bmat ( 1 , nfx ) - bmat ( nf , nfx ) zmat ( 1 , nfx ) = sqrt ( two ) / ( stepa * stepb ) zmat ( nf , nfx ) = sqrt ( half ) / rhosq zmat ( nf - n , nfx ) = - zmat ( 1 , nfx ) - zmat ( nf , nfx ) end if ! !     Set the off-diagonal second derivatives of the Lagrange functions and !     the initial quadratic model. ! else ih = ( ipt * ( ipt - 1 )) / 2 + jpt zmat ( 1 , nfx ) = recip zmat ( nf , nfx ) = recip zmat ( ipt + 1 , nfx ) = - recip zmat ( jpt + 1 , nfx ) = - recip temp = xpt ( nf , ipt ) * xpt ( nf , jpt ) hq ( ih ) = ( fbeg - fval ( ipt + 1 ) - fval ( jpt + 1 ) + f ) / temp end if if ( nf < npt . and . nf < maxfun ) go to 50 end subroutine prelim ! @date 12/12/15 SS 1.1 changed input parameters to subroutine call recursive subroutine rescue ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , n , npt , xl , xu , iprint ,& maxfun , xbase , xpt , fval , xopt , gopt , hq , pq , bmat , zmat , ndim , sl , su , nf , delta , kopt , vlag ,& ptsaux , ptsid , w , calfun , accum_e , mLPNH , mLPSH , nstep , stepsize , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: rescue implicit real ( dbl ) ( a - h , o - z ) integer ( 8 ), intent ( in ) :: ipar ( nipar ) real ( sgl ), intent ( inout ) :: fpar ( nfpar ) real ( sgl ), intent ( in ) :: initmeanval ( ninit ) integer ( irg ), intent ( in ) :: ninit integer ( irg ), intent ( in ) :: nipar integer ( irg ), intent ( in ) :: nfpar integer ( irg ), intent ( in ) :: nstep real ( sgl ), intent ( in ) :: stepsize ( nstep ) real ( c_float ), intent ( in ) :: expt1 ( ipar ( 2 ) * ipar ( 3 ) / ipar ( 12 ) ** 2 ) real ( sgl ), intent ( in ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( sgl ), intent ( in ) :: mLPNH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) real ( sgl ), intent ( in ) :: mLPSH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) logical , intent ( in ), optional :: verbose dimension xl ( * ), xu ( * ), xbase ( * ), xpt ( npt , * ), fval ( * ), xopt ( * ), gopt ( * ), & & hq ( * ), pq ( * ), bmat ( ndim , * ), zmat ( npt , * ), sl ( * ), su ( * ), vlag ( * ), ptsaux & & ( 2 , * ), ptsid ( * ), w ( * ) procedure ( func ) :: calfun ! !     The arguments N, NPT, XL, XU, IPRINT, MAXFUN, XBASE, XPT, FVAL, XOPT, !       GOPT, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU have the same meanings as !       the corresponding arguments of BOBYQB on the entry to RESCUE. !     NF is maintained as the number of calls of CALFUN so far, except that !       NF is set to -1 if the value of MAXFUN prevents further progress. !     KOPT is maintained so that FVAL(KOPT) is the least calculated function !       value. Its correct value must be given on entry. It is updated if a !       new least function value is found, but the corresponding changes to !       XOPT and GOPT have to be made later by the calling program. !     DELTA is the current trust region radius. !     VLAG is a working space vector that will be used for the values of the !       provisional Lagrange functions at each of the interpolation points. !       They are part of a product that requires VLAG to be of length NDIM. !     PTSAUX is also a working space array. For J=1,2,...,N, PTSAUX(1,J) and !       PTSAUX(2,J) specify the two positions of provisional interpolation !       points when a nonzero step is taken along e_J (the J-th coordinate !       direction) through XBASE+XOPT, as specified below. Usually these !       steps have length DELTA, but other lengths are chosen if necessary !       in order to satisfy the given bounds on the variables. !     PTSID is also a working space array. It has NPT components that denote !       provisional new positions of the original interpolation points, in !       case changes are needed to restore the linear independence of the !       interpolation conditions. The K-th point is a candidate for change !       if and only if PTSID(K) is nonzero. In this case let p and q be the !       integer parts of PTSID(K) and (PTSID(K)-p) multiplied by N+1. If p !       and q are both positive, the step from XBASE+XOPT to the new K-th !       interpolation point is PTSAUX(1,p)*e_p + PTSAUX(1,q)*e_q. Otherwise !       the step is PTSAUX(1,p)*e_p or PTSAUX(2,q)*e_q in the cases q=0 or !       p=0, respectively. !     The first NDIM+NPT elements of the array W are used for working space. !     The final elements of BMAT and ZMAT are set in a well-conditioned way !       to the values that are appropriate for the new interpolation points. !     The elements of GOPT, HQ and PQ are also revised to the values that are !       appropriate to the final quadratic model. ! !     Set some constants. ! half = 0.5_dbl one = 1.0_dbl zero = 0.0_dbl np = n + 1 sfrac = half / real ( np , dbl ) nptm = npt - np ! !     Shift the interpolation points so that XOPT becomes the origin, and set !     the elements of ZMAT to zero. The value of SUMPQ is required in the !     updating of HQ below. The squares of the distances from XOPT to the !     other interpolation points are set at the end of W. Increments of WINC !     may be added later to these squares to balance the consideration of !     the choice of point that is going to become current. ! sumpq = zero winc = zero do k = 1 , npt distsq = zero do j = 1 , n xpt ( k , j ) = xpt ( k , j ) - xopt ( j ) distsq = distsq + xpt ( k , j ) ** 2 end do sumpq = sumpq + pq ( k ) w ( ndim + k ) = distsq winc = max ( winc , distsq ) do j = 1 , nptm zmat ( k , j ) = zero end do end do ! !     Update HQ so that HQ and PQ define the second derivatives of the model !     after XBASE has been shifted to the trust region centre. ! ih = 0 do j = 1 , n w ( j ) = half * sumpq * xopt ( j ) do k = 1 , npt w ( j ) = w ( j ) + pq ( k ) * xpt ( k , j ) end do do i = 1 , j ih = ih + 1 hq ( ih ) = hq ( ih ) + w ( i ) * xopt ( j ) + w ( j ) * xopt ( i ) end do end do ! !     Shift XBASE, SL, SU and XOPT. Set the elements of BMAT to zero, and !     also set the elements of PTSAUX. ! do j = 1 , n xbase ( j ) = xbase ( j ) + xopt ( j ) sl ( j ) = sl ( j ) - xopt ( j ) su ( j ) = su ( j ) - xopt ( j ) xopt ( j ) = zero ptsaux ( 1 , j ) = min ( delta , su ( j )) ptsaux ( 2 , j ) = max ( - delta , sl ( j )) if ( ptsaux ( 1 , j ) + ptsaux ( 2 , j ) < zero ) then temp = ptsaux ( 1 , j ) ptsaux ( 1 , j ) = ptsaux ( 2 , j ) ptsaux ( 2 , j ) = temp end if if ( abs ( ptsaux ( 2 , j )) < half * abs ( ptsaux ( 1 , j ))) then ptsaux ( 2 , j ) = half * ptsaux ( 1 , j ) end if do i = 1 , ndim bmat ( i , j ) = zero end do end do fbase = fval ( kopt ) ! !     Set the identifiers of the artificial interpolation points that are !     along a coordinate direction from XOPT, and set the corresponding !     nonzero elements of BMAT and ZMAT. ! ptsid ( 1 ) = sfrac do j = 1 , n jp = j + 1 jpn = jp + n ptsid ( jp ) = real ( j , dbl ) + sfrac if ( jpn <= npt ) then ptsid ( jpn ) = real ( j , dbl ) / real ( np , dbl ) + sfrac temp = one / ( ptsaux ( 1 , j ) - ptsaux ( 2 , j )) bmat ( jp , j ) = - temp + one / ptsaux ( 1 , j ) bmat ( jpn , j ) = temp + one / ptsaux ( 2 , j ) bmat ( 1 , j ) = - bmat ( jp , j ) - bmat ( jpn , j ) zmat ( 1 , j ) = sqrt ( 2.0_dbl ) / abs ( ptsaux ( 1 , j ) * ptsaux ( 2 , j )) zmat ( jp , j ) = zmat ( 1 , j ) * ptsaux ( 2 , j ) * temp zmat ( jpn , j ) = - zmat ( 1 , j ) * ptsaux ( 1 , j ) * temp else bmat ( 1 , j ) = - one / ptsaux ( 1 , j ) bmat ( jp , j ) = one / ptsaux ( 1 , j ) bmat ( j + npt , j ) = - half * ptsaux ( 1 , j ) ** 2 end if end do ! !     Set any remaining identifiers with their nonzero elements of ZMAT. ! if ( npt >= n + np ) then do k = 2 * np , npt iw = ( real ( k - np , dbl ) - half ) / real ( n , dbl ) ip = k - np - iw * n iq = ip + iw if ( iq > n ) iq = iq - n ptsid ( k ) = real ( ip , dbl ) + real ( iq , dbl ) / real ( np , dbl ) + sfrac temp = one / ( ptsaux ( 1 , ip ) * ptsaux ( 1 , iq )) zmat ( 1 , k - np ) = temp zmat ( ip + 1 , k - np ) = - temp zmat ( iq + 1 , k - np ) = - temp zmat ( k , k - np ) = temp end do end if nrem = npt kold = 1 knew = kopt ! !     Reorder the provisional points in the way that exchanges PTSID(KOLD) !     with PTSID(KNEW). ! 80 do j = 1 , n temp = bmat ( kold , j ) bmat ( kold , j ) = bmat ( knew , j ) bmat ( knew , j ) = temp end do do j = 1 , nptm temp = zmat ( kold , j ) zmat ( kold , j ) = zmat ( knew , j ) zmat ( knew , j ) = temp end do ptsid ( kold ) = ptsid ( knew ) ptsid ( knew ) = zero w ( ndim + knew ) = zero nrem = nrem - 1 if ( knew /= kopt ) then temp = vlag ( kold ) vlag ( kold ) = vlag ( knew ) vlag ( knew ) = temp ! !     Update the BMAT and ZMAT matrices so that the status of the KNEW-th !     interpolation point can be changed from provisional to original. The !     subroutine returns if all the original points are reinstated. !     The nonnegative values of W(NDIM+K) are required in the search below. ! call update ( n , npt , bmat , zmat , ndim , vlag , beta , denom , knew , w ) if ( nrem == 0 ) return do k = 1 , npt w ( ndim + k ) = abs ( w ( ndim + k )) end do end if ! !     Pick the index KNEW of an original interpolation point that has not !     yet replaced one of the provisional interpolation points, giving !     attention to the closeness to XOPT and to previous tries with KNEW. ! 120 dsqmin = zero do k = 1 , npt if ( w ( ndim + k ) > zero ) then if ( dsqmin == zero . or . w ( ndim + k ) < dsqmin ) then knew = k dsqmin = w ( ndim + k ) end if end if end do if ( dsqmin == zero ) go to 260 ! !     Form the W-vector of the chosen original interpolation point. ! do j = 1 , n w ( npt + j ) = xpt ( knew , j ) end do do k = 1 , npt sum = zero if ( k == kopt ) then continue else if ( ptsid ( k ) == zero ) then do j = 1 , n sum = sum + w ( npt + j ) * xpt ( k , j ) end do else ip = ptsid ( k ) if ( ip > 0 ) sum = w ( npt + ip ) * ptsaux ( 1 , ip ) iq = real ( np , dbl ) * ptsid ( k ) - real ( ip * np , dbl ) if ( iq > 0 ) then iw = 1 if ( ip == 0 ) iw = 2 sum = sum + w ( npt + iq ) * ptsaux ( iw , iq ) end if end if w ( k ) = half * sum * sum end do ! !     Calculate VLAG and BETA for the required updating of the H matrix if !     XPT(KNEW,.) is reinstated in the set of interpolation points. ! do k = 1 , npt sum = zero do j = 1 , n sum = sum + bmat ( k , j ) * w ( npt + j ) end do vlag ( k ) = sum end do beta = zero do j = 1 , nptm sum = zero do k = 1 , npt sum = sum + zmat ( k , j ) * w ( k ) end do beta = beta - sum * sum do k = 1 , npt vlag ( k ) = vlag ( k ) + sum * zmat ( k , j ) end do end do bsum = zero distsq = zero do j = 1 , n sum = zero do k = 1 , npt sum = sum + bmat ( k , j ) * w ( k ) end do jp = j + npt bsum = bsum + sum * w ( jp ) do ip = npt + 1 , ndim sum = sum + bmat ( ip , j ) * w ( ip ) end do bsum = bsum + sum * w ( jp ) vlag ( jp ) = sum distsq = distsq + xpt ( knew , j ) ** 2 end do beta = half * distsq * distsq + beta - bsum vlag ( kopt ) = vlag ( kopt ) + one ! !     KOLD is set to the index of the provisional interpolation point that is !     going to be deleted to make way for the KNEW-th original interpolation !     point. The choice of KOLD is governed by the avoidance of a small value !     of the denominator in the updating calculation of UPDATE. ! denom = zero vlmxsq = zero do k = 1 , npt if ( ptsid ( k ) /= zero ) then hdiag = zero do j = 1 , nptm hdiag = hdiag + zmat ( k , j ) ** 2 end do den = beta * hdiag + vlag ( k ) ** 2 if ( den > denom ) then kold = k denom = den end if end if vlmxsq = max ( vlmxsq , vlag ( k ) ** 2 ) end do if ( denom <= 1.0e-2_dbl * vlmxsq ) then w ( ndim + knew ) = - w ( ndim + knew ) - winc go to 120 end if go to 80 ! !     When label 260 is reached, all the final positions of the interpolation !     points have been chosen although any changes have not been included yet !     in XPT. Also the final BMAT and ZMAT matrices are complete, but, apart !     from the shift of XBASE, the updating of the quadratic model remains to !     be done. The following cycle through the new interpolation points begins !     by putting the new point in XPT(KPT,.) and by setting PQ(KPT) to zero, !     except that a RETURN occurs if MAXFUN prohibits another value of F. ! 260 do kpt = 1 , npt if ( ptsid ( kpt ) == zero ) cycle if ( nf >= maxfun ) then nf = - 1 return end if ih = 0 do j = 1 , n w ( j ) = xpt ( kpt , j ) xpt ( kpt , j ) = zero temp = pq ( kpt ) * w ( j ) do i = 1 , j ih = ih + 1 hq ( ih ) = hq ( ih ) + temp * w ( i ) end do end do pq ( kpt ) = zero ip = ptsid ( kpt ) iq = real ( np , dbl ) * ptsid ( kpt ) - real ( ip * np , dbl ) if ( ip > 0 ) then xp = ptsaux ( 1 , ip ) xpt ( kpt , ip ) = xp end if if ( iq > 0 ) then xq = ptsaux ( 1 , iq ) if ( ip == 0 ) xq = ptsaux ( 2 , iq ) xpt ( kpt , iq ) = xq end if ! !     Set VQUAD to the value of the current model at the new point. ! vquad = fbase if ( ip > 0 ) then ihp = ( ip + ip * ip ) / 2 vquad = vquad + xp * ( gopt ( ip ) + half * xp * hq ( ihp )) end if if ( iq > 0 ) then ihq = ( iq + iq * iq ) / 2 vquad = vquad + xq * ( gopt ( iq ) + half * xq * hq ( ihq )) if ( ip > 0 ) then iw = max ( ihp , ihq ) - abs ( ip - iq ) vquad = vquad + xp * xq * hq ( iw ) end if end if do k = 1 , npt temp = zero if ( ip > 0 ) temp = temp + xp * xpt ( k , ip ) if ( iq > 0 ) temp = temp + xq * xpt ( k , iq ) vquad = vquad + half * pq ( k ) * temp * temp end do ! !     Calculate F at the new interpolation point, and set DIFF to the factor !     that is going to multiply the KPT-th Lagrange function when the model !     is updated to provide interpolation to the new function value. ! do i = 1 , n w ( i ) = min ( max ( xl ( i ), xbase ( i ) + xpt ( kpt , i )), xu ( i )) if ( xpt ( kpt , i ) == sl ( i )) w ( i ) = xl ( i ) if ( xpt ( kpt , i ) == su ( i )) w ( i ) = xu ( i ) end do nf = nf + 1 !======================================================================================= !============changed function call depending on how many call have been made============ !======================================================================================= if ( present ( verbose )) then call calfun ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , accum_e , mLPNH , mLPSH , & n , w ( 1 : n ), f , nstep , stepsize , verbose = verbose ) else call calfun ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , accum_e , mLPNH , mLPSH , & n , w ( 1 : n ), f , nstep , stepsize ) end if if ( iprint == 3 ) then print 300 , nf , f , ( w ( i ), i = 1 , n ) 300 format ( / 4 x , 'Function number' , i6 , '    F =' , 1 pd18 . 10 ,& '    The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if fval ( kpt ) = f if ( f < fval ( kopt )) kopt = kpt diff = f - vquad ! !     Update the quadratic model. The RETURN from the subroutine occurs when !     all the new interpolation points are included in the model. ! do i = 1 , n gopt ( i ) = gopt ( i ) + diff * bmat ( kpt , i ) end do do k = 1 , npt sum = zero do j = 1 , nptm sum = sum + zmat ( k , j ) * zmat ( kpt , j ) end do temp = diff * sum if ( ptsid ( k ) == zero ) then pq ( k ) = pq ( k ) + temp else ip = ptsid ( k ) iq = real ( np , dbl ) * ptsid ( k ) - real ( ip * np , dbl ) ihq = ( iq * iq + iq ) / 2 if ( ip == 0 ) then hq ( ihq ) = hq ( ihq ) + temp * ptsaux ( 2 , iq ) ** 2 else ihp = ( ip * ip + ip ) / 2 hq ( ihp ) = hq ( ihp ) + temp * ptsaux ( 1 , ip ) ** 2 if ( iq > 0 ) then hq ( ihq ) = hq ( ihq ) + temp * ptsaux ( 1 , iq ) ** 2 iw = max ( ihp , ihq ) - abs ( iq - ip ) hq ( iw ) = hq ( iw ) + temp * ptsaux ( 1 , ip ) * ptsaux ( 1 , iq ) end if end if end if end do ptsid ( kpt ) = zero end do end subroutine rescue recursive subroutine trsbox ( n , npt , xpt , xopt , gopt , hq , pq , sl , su , delta , xnew , d , gnew , & & xbdi , s , hs , hred , dsq , crvmin ) !DEC$ ATTRIBUTES DLLEXPORT :: trsbox implicit real ( dbl ) ( a - h , o - z ) dimension xpt ( npt , * ), xopt ( * ), gopt ( * ), hq ( * ), pq ( * ), sl ( * ), su ( * ), xnew & & ( * ), d ( * ), gnew ( * ), xbdi ( * ), s ( * ), hs ( * ), hred ( * ) ! !     The arguments N, NPT, XPT, XOPT, GOPT, HQ, PQ, SL and SU have the same !       meanings as the corresponding arguments of BOBYQB. !     DELTA is the trust region radius for the present calculation, which !       seeks a small value of the quadratic model within distance DELTA of !       XOPT subject to the bounds on the variables. !     XNEW will be set to a new vector of variables that is approximately !       the one that minimizes the quadratic model within the trust region !       subject to the SL and SU constraints on the variables. It satisfies !       as equations the bounds that become active during the calculation. !     D is the calculated trial step from XOPT, generated iteratively from an !       initial value of zero. Thus XNEW is XOPT+D after the final iteration. !     GNEW holds the gradient of the quadratic model at XOPT+D. It is updated !       when D is updated. !     XBDI is a working space vector. For I=1,2,...,N, the element XBDI(I) is !       set to -1.0, 0.0, or 1.0, the value being nonzero if and only if the !       I-th variable has become fixed at a bound, the bound being SL(I) or !       SU(I) in the case XBDI(I)=-1.0 or XBDI(I)=1.0, respectively. This !       information is accumulated during the construction of XNEW. !     The arrays S, HS and HRED are also used for working space. They hold the !       current search direction, and the changes in the gradient of Q along S !       and the reduced D, respectively, where the reduced D is the same as D, !       except that the components of the fixed variables are zero. !     DSQ will be set to the square of the length of XNEW-XOPT. !     CRVMIN is set to zero if D reaches the trust region boundary. Otherwise !       it is set to the least curvature of H that occurs in the conjugate !       gradient searches that are not restricted by any constraints. The !       value CRVMIN=-1.0D0 is set, however, if all of these searches are !       constrained. ! !     A version of the truncated conjugate gradient is applied. If a line !     search is restricted by a constraint, then the procedure is restarted, !     the values of the variables that are at their bounds being fixed. If !     the trust region boundary is reached, then further changes may be made !     to D, each one being in the two dimensional space that is spanned !     by the current D and the gradient of Q at XOPT+D, staying on the trust !     region boundary. Termination occurs when the reduction in Q seems to !     be close to the greatest reduction that can be achieved. ! !     Set some constants. ! half = 0.5_dbl one = 1.0_dbl onemin = - 1.0_dbl zero = 0.0_dbl ! !     The sign of GOPT(I) gives the sign of the change to the I-th variable !     that will reduce Q from its value at XOPT. Thus XBDI(I) shows whether !     or not to fix the I-th variable at one of its bounds initially, with !     NACT being set to the number of fixed variables. D and GNEW are also !     set for the first iteration. DELSQ is the upper bound on the sum of !     squares of the free variables. QRED is the reduction in Q so far. ! iterc = 0 nact = 0 sqstp = zero do i = 1 , n xbdi ( i ) = zero if ( xopt ( i ) <= sl ( i )) then if ( gopt ( i ) >= zero ) xbdi ( i ) = onemin else if ( xopt ( i ) >= su ( i )) then if ( gopt ( i ) <= zero ) xbdi ( i ) = one end if if ( xbdi ( i ) /= zero ) nact = nact + 1 d ( i ) = zero gnew ( i ) = gopt ( i ) end do delsq = delta * delta qred = zero crvmin = onemin ! !     Set the next search direction of the conjugate gradient method. It is !     the steepest descent direction initially and when the iterations are !     restarted because a variable has just been fixed by a bound, and of !     course the components of the fixed variables are zero. ITERMAX is an !     upper bound on the indices of the conjugate gradient iterations. ! 20 beta = zero 30 stepsq = zero do i = 1 , n if ( xbdi ( i ) /= zero ) then s ( i ) = zero else if ( beta == zero ) then s ( i ) = - gnew ( i ) else s ( i ) = beta * s ( i ) - gnew ( i ) end if stepsq = stepsq + s ( i ) ** 2 end do if ( stepsq == zero ) go to 190 if ( beta == zero ) then gredsq = stepsq itermax = iterc + n - nact end if if ( gredsq * delsq <= 1.0e-4_dbl * qred * qred ) go to 190 ! !     Multiply the search direction by the second derivative matrix of Q and !     calculate some scalars for the choice of steplength. Then set BLEN to !     the length of the the step to the trust region boundary and STPLEN to !     the steplength, ignoring the simple bounds. ! go to 210 50 resid = delsq ds = zero shs = zero do i = 1 , n if ( xbdi ( i ) == zero ) then resid = resid - d ( i ) ** 2 ds = ds + s ( i ) * d ( i ) shs = shs + s ( i ) * hs ( i ) end if end do if ( resid <= zero ) go to 90 temp = sqrt ( stepsq * resid + ds * ds ) if ( ds < zero ) then blen = ( temp - ds ) / stepsq else blen = resid / ( temp + ds ) end if stplen = blen if ( shs > zero ) then stplen = min ( blen , gredsq / shs ) end if ! ! !     Reduce STPLEN if necessary in order to preserve the simple bounds, !     letting IACT be the index of the new constrained variable. ! iact = 0 do i = 1 , n if ( s ( i ) /= zero ) then xsum = xopt ( i ) + d ( i ) if ( s ( i ) > zero ) then temp = ( su ( i ) - xsum ) / s ( i ) else temp = ( sl ( i ) - xsum ) / s ( i ) end if if ( temp < stplen ) then stplen = temp iact = i end if end if end do ! !     Update CRVMIN, GNEW and D. Set SDEC to the decrease that occurs in Q. ! sdec = zero if ( stplen > zero ) then iterc = iterc + 1 temp = shs / stepsq if ( iact == 0 . and . temp > zero ) then crvmin = min ( crvmin , temp ) if ( crvmin == onemin ) crvmin = temp end if ggsav = gredsq gredsq = zero do i = 1 , n gnew ( i ) = gnew ( i ) + stplen * hs ( i ) if ( xbdi ( i ) == zero ) gredsq = gredsq + gnew ( i ) ** 2 d ( i ) = d ( i ) + stplen * s ( i ) end do sdec = max ( stplen * ( ggsav - half * stplen * shs ), zero ) qred = qred + sdec end if ! !     Restart the conjugate gradient method if it has hit a new bound. ! if ( iact > 0 ) then nact = nact + 1 xbdi ( iact ) = one if ( s ( iact ) < zero ) xbdi ( iact ) = onemin delsq = delsq - d ( iact ) ** 2 if ( delsq <= zero ) go to 90 go to 20 end if ! !     If STPLEN is less than BLEN, then either apply another conjugate !     gradient iteration or RETURN. ! if ( stplen < blen ) then if ( iterc == itermax ) go to 190 if ( sdec <= 0.01_dbl * qred ) go to 190 beta = gredsq / ggsav go to 30 end if 90 crvmin = zero ! !     Prepare for the alternative iteration by calculating some scalars and !     by multiplying the reduced D by the second derivative matrix of Q. ! 100 if ( nact >= n - 1 ) go to 190 dredsq = zero dredg = zero gredsq = zero do i = 1 , n if ( xbdi ( i ) == zero ) then dredsq = dredsq + d ( i ) ** 2 dredg = dredg + d ( i ) * gnew ( i ) gredsq = gredsq + gnew ( i ) ** 2 s ( i ) = d ( i ) else s ( i ) = zero end if end do itcsav = iterc go to 210 ! !     Let the search direction S be a linear combination of the reduced D !     and the reduced G that is orthogonal to the reduced D. ! 120 iterc = iterc + 1 temp = gredsq * dredsq - dredg * dredg if ( temp <= 1.0e-4_dbl * qred * qred ) go to 190 temp = sqrt ( temp ) do i = 1 , n if ( xbdi ( i ) == zero ) then s ( i ) = ( dredg * d ( i ) - dredsq * gnew ( i )) / temp else s ( i ) = zero end if end do sredg = - temp ! !     By considering the simple bounds on the variables, calculate an upper !     bound on the tangent of half the angle of the alternative iteration, !     namely ANGBD, except that, if already a free variable has reached a !     bound, there is a branch back to label 100 after fixing that variable. ! angbd = one iact = 0 do i = 1 , n if ( xbdi ( i ) == zero ) then tempa = xopt ( i ) + d ( i ) - sl ( i ) tempb = su ( i ) - xopt ( i ) - d ( i ) if ( tempa <= zero ) then nact = nact + 1 xbdi ( i ) = onemin go to 100 else if ( tempb <= zero ) then nact = nact + 1 xbdi ( i ) = one go to 100 end if ratio = one ssq = d ( i ) ** 2 + s ( i ) ** 2 temp = ssq - ( xopt ( i ) - sl ( i )) ** 2 if ( temp > zero ) then temp = sqrt ( temp ) - s ( i ) if ( angbd * temp > tempa ) then angbd = tempa / temp iact = i xsav = onemin end if end if temp = ssq - ( su ( i ) - xopt ( i )) ** 2 if ( temp > zero ) then temp = sqrt ( temp ) + s ( i ) if ( angbd * temp > tempb ) then angbd = tempb / temp iact = i xsav = one end if end if end if end do ! !     Calculate HHD and some curvatures for the alternative iteration. ! go to 210 150 shs = zero dhs = zero dhd = zero do i = 1 , n if ( xbdi ( i ) == zero ) then shs = shs + s ( i ) * hs ( i ) dhs = dhs + d ( i ) * hs ( i ) dhd = dhd + d ( i ) * hred ( i ) end if end do ! !     Seek the greatest reduction in Q for a range of equally spaced values !     of ANGT in [0,ANGBD], where ANGT is the tangent of half the angle of !     the alternative iteration. ! redmax = zero isav = 0 redsav = zero iu = 1 7.0_dbl * angbd + 3.1_dbl do i = 1 , iu angt = angbd * real ( i , dbl ) / real ( iu , dbl ) sth = ( angt + angt ) / ( one + angt * angt ) temp = shs + angt * ( angt * dhd - dhs - dhs ) rednew = sth * ( angt * dredg - sredg - half * sth * temp ) if ( rednew > redmax ) then redmax = rednew isav = i rdprev = redsav else if ( i == isav + 1 ) then rdnext = rednew end if redsav = rednew end do ! !     Return if the reduction is zero. Otherwise, set the sine and cosine !     of the angle of the alternative iteration, and calculate SDEC. ! if ( isav == 0 ) go to 190 if ( isav < iu ) then temp = ( rdnext - rdprev ) / ( redmax + redmax - rdprev - rdnext ) angt = angbd * ( real ( isav , dbl ) + half * temp ) / real ( iu , dbl ) end if cth = ( one - angt * angt ) / ( one + angt * angt ) sth = ( angt + angt ) / ( one + angt * angt ) temp = shs + angt * ( angt * dhd - dhs - dhs ) sdec = sth * ( angt * dredg - sredg - half * sth * temp ) if ( sdec <= zero ) go to 190 ! !     Update GNEW, D and HRED. If the angle of the alternative iteration !     is restricted by a bound on a free variable, that variable is fixed !     at the bound. ! dredg = zero gredsq = zero do i = 1 , n gnew ( i ) = gnew ( i ) + ( cth - one ) * hred ( i ) + sth * hs ( i ) if ( xbdi ( i ) == zero ) then d ( i ) = cth * d ( i ) + sth * s ( i ) dredg = dredg + d ( i ) * gnew ( i ) gredsq = gredsq + gnew ( i ) ** 2 end if hred ( i ) = cth * hred ( i ) + sth * hs ( i ) end do qred = qred + sdec if ( iact > 0 . and . isav == iu ) then nact = nact + 1 xbdi ( iact ) = xsav go to 100 end if ! !     If SDEC is sufficiently small, then RETURN after setting XNEW to !     XOPT+D, giving careful attention to the bounds. ! if ( sdec > 0.01_dbl * qred ) go to 120 190 dsq = zero do i = 1 , n xnew ( i ) = max ( min ( xopt ( i ) + d ( i ), su ( i )), sl ( i )) if ( xbdi ( i ) == onemin ) xnew ( i ) = sl ( i ) if ( xbdi ( i ) == one ) xnew ( i ) = su ( i ) d ( i ) = xnew ( i ) - xopt ( i ) dsq = dsq + d ( i ) ** 2 end do return ! !     The following instructions multiply the current S-vector by the second !     derivative matrix of the quadratic model, putting the product in HS. !     They are reached from three different parts of the software above and !     they can be regarded as an external subroutine. ! 210 ih = 0 do j = 1 , n hs ( j ) = zero do i = 1 , j ih = ih + 1 if ( i < j ) hs ( j ) = hs ( j ) + hq ( ih ) * s ( i ) hs ( i ) = hs ( i ) + hq ( ih ) * s ( j ) end do end do do k = 1 , npt if ( pq ( k ) /= zero ) then temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * s ( j ) end do temp = temp * pq ( k ) do i = 1 , n hs ( i ) = hs ( i ) + temp * xpt ( k , i ) end do end if end do if ( crvmin /= zero ) go to 50 if ( iterc > itcsav ) go to 150 do i = 1 , n hred ( i ) = hs ( i ) end do go to 120 end subroutine trsbox recursive subroutine update ( n , npt , bmat , zmat , ndim , vlag , beta , denom , knew , w ) !DEC$ ATTRIBUTES DLLEXPORT :: update implicit real ( dbl ) ( a - h , o - z ) dimension bmat ( ndim , * ), zmat ( npt , * ), vlag ( * ), w ( * ) ! !     The arrays BMAT and ZMAT are updated, as required by the new position !     of the interpolation point that has the index KNEW. The vector VLAG has !     N+NPT components, set on entry to the first NPT and last N components !     of the product Hw in equation (4.11) of the Powell (2006) paper on !     NEWUOA. Further, BETA is set on entry to the value of the parameter !     with that name, and DENOM is set to the denominator of the updating !     formula. Elements of ZMAT may be treated as zero if their moduli are !     at most ZTEST. The first NDIM elements of W are used for working space. ! !     Set some constants. ! one = 1.0_dbl zero = 0.0_dbl nptm = npt - n - 1 ztest = zero do k = 1 , npt do j = 1 , nptm ztest = max ( ztest , abs ( zmat ( k , j ))) end do end do ztest = 1.0e-20_dbl * ztest ! !     Apply the rotations that put zeros in the KNEW-th row of ZMAT. ! jl = 1 do j = 2 , nptm if ( abs ( zmat ( knew , j )) > ztest ) then temp = sqrt ( zmat ( knew , 1 ) ** 2 + zmat ( knew , j ) ** 2 ) tempa = zmat ( knew , 1 ) / temp tempb = zmat ( knew , j ) / temp do i = 1 , npt temp = tempa * zmat ( i , 1 ) + tempb * zmat ( i , j ) zmat ( i , j ) = tempa * zmat ( i , j ) - tempb * zmat ( i , 1 ) zmat ( i , 1 ) = temp end do end if zmat ( knew , j ) = zero end do ! !     Put the first NPT components of the KNEW-th column of HLAG into W, !     and calculate the parameters of the updating formula. ! do i = 1 , npt w ( i ) = zmat ( knew , 1 ) * zmat ( i , 1 ) end do alpha = w ( knew ) tau = vlag ( knew ) vlag ( knew ) = vlag ( knew ) - one ! !     Complete the updating of ZMAT. ! temp = sqrt ( denom ) tempb = zmat ( knew , 1 ) / temp tempa = tau / temp do i = 1 , npt zmat ( i , 1 ) = tempa * zmat ( i , 1 ) - tempb * vlag ( i ) end do ! !     Finally, update the matrix BMAT. ! do j = 1 , n jp = npt + j w ( jp ) = bmat ( knew , j ) tempa = ( alpha * vlag ( jp ) - tau * w ( jp )) / denom tempb = ( - beta * w ( jp ) - tau * vlag ( jp )) / denom do i = 1 , jp bmat ( i , j ) = bmat ( i , j ) + tempa * vlag ( i ) + tempb * w ( i ) if ( i > npt ) bmat ( jp , i - npt ) = bmat ( i , j ) end do end do end subroutine update !***************************************************************************************** end module bobyqa_module !*****************************************************************************************","tags":"","loc":"sourcefile/bobyqa.f90.html","title":"bobyqa.f90 – Fortran Program"},{"text":"References\n  * \" The BOBYQA algorithm for bound constrained optimization without\n    derivatives \". History\n  * M.J.D. Powell (January 5th, 2009) -- There are no restrictions on or charges \n    for the use of the software. I hope that the time and effort I have spent on \n     developing the package will be helpful to much research and to many applications.\n  * Jacob Williams, July 2015 : refactoring of the code into modern Fortran. Modules bobyqa_refinement Source Code bobyqa_refinement.f90 Source Code !***************************************************************************************** !> !  BOBYQA: **B**ound **O**ptimization **BY** **Q**uadratic **A**pproximation ! !  The purpose of BOBYQA is to seek the least value of a function F of several !  variables, when derivatives are not available. The constraints are the lower !  and upper bounds on every variable, which can be set to huge values for !  unconstrained variables. ! !  The algorithm is intended to change the variables to values that are close !  to a local minimum of F. The user, however, should assume responsibility for !  finding out if the calculations are satisfactory, by considering carefully !  the values of F that occur. ! !# References !  * \"[The BOBYQA algorithm for bound constrained optimization without !    derivatives](http://www.damtp.cam.ac.uk/user/na/NA_papers/NA2009_06.pdf)\". ! !# History !  * M.J.D. Powell (January 5th, 2009) -- There are no restrictions on or charges !    for the use of the software. I hope that the time and effort I have spent on !     developing the package will be helpful to much research and to many applications. !  * Jacob Williams, July 2015 : refactoring of the code into modern Fortran. module bobyqa_refinement use local use , INTRINSIC :: ISO_C_BINDING !    private ! @date 12/12/15 SS 1.1 changed input parameters to the function interfce abstract interface recursive subroutine func2 ( ipar , initmeanval , expt , accum , & mLPNH , mLPSH , n , x , f , mask , prefactor , rgx , rgy , rgz , & stepsize , verbose ) !! calfun interface use local use , INTRINSIC :: ISO_C_BINDING implicit none integer ( c_size_t ), INTENT ( IN ) :: ipar ( 9 ) real ( sgl ), INTENT ( IN ) :: stepsize ( 3 ) real ( sgl ), INTENT ( IN ) :: initmeanval ( 3 ) real ( c_float ), INTENT ( IN ) :: expt ( ipar ( 2 ) * ipar ( 3 ) / ipar ( 1 ) ** 2 ) real ( kind = sgl ), INTENT ( IN ) :: accum ( ipar ( 6 ), ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: mLPNH ( - ipar ( 4 ): ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), ipar ( 7 )) real ( kind = sgl ), INTENT ( IN ) :: mLPSH ( - ipar ( 4 ): ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), ipar ( 7 )) real ( kind = sgl ), INTENT ( IN ) :: rgx ( ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: rgy ( ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: rgz ( ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: mask ( ipar ( 2 ) / ipar ( 1 ), ipar ( 3 ) / ipar ( 1 )) real ( kind = dbl ), INTENT ( IN ) :: prefactor integer ( irg ), intent ( in ) :: n real ( dbl ), dimension (:), intent ( in ) :: x real ( dbl ), intent ( out ) :: f logical , intent ( in ), optional :: verbose end subroutine func2 end interface !    public :: bobyqa contains !***************************************************************************************** !***************************************************************************************** !> !  This subroutine seeks the least value of a function of many variables, !  by applying a trust region method that forms quadratic models by !  interpolation. There is usually some freedom in the interpolation !  conditions, which is taken up by minimizing the Frobenius norm of !  the change to the second derivative of the model, beginning with the !  zero matrix. The values of the variables are constrained by upper and !  lower bounds. ! !  In addition to providing CALFUN, an initial vector of variables and !  the lower and upper bounds, the user has to set the values of the parameters !  ```RHOBEG```, ```RHOEND``` and ```NPT```. After scaling the individual variables !  if necessary, so that the magnitudes of their expected changes are similar, !  ```RHOBEG``` is the initial steplength for changes to the variables, a reasonable choice !  being the mesh size of a coarse grid search. Further, ```RHOEND``` should be suitable for !  a search on a very fine grid. Typically, the software calculates a vector !  of variables that is within distance ```10*RHOEND``` of a local minimum. Another !  consideration is that every trial vector of variables is forced to satisfy !  the lower and upper bounds, but there has to be room to make a search in all !  directions. Therefore an error return occurs if the difference between the !  bounds on any variable is less than ```2*RHOBEG```. The parameter ```NPT``` specifies !  the number of interpolation conditions on each quadratic model, the value !  ```NPT=2*N+1``` being recommended for a start, where ```N``` is the number of !  variables. It is often worthwhile to try other choices too, but much larger values !  tend to be inefficient, because the amount of routine work of each iteration is !  of magnitude ```NPT**2```, and because the achievement of adequate accuracy in some !  matrix calculations becomes more difficult. Some excellent numerical results !  have been found in the case ```NPT=N+6``` even with more than 100 variables. ! @date 12/12/15 SS 1.1 changed input parameters to the function interfce recursive subroutine bobyqa ( ipar , initmeanval , expt , n , npt , x , xl ,& xu , rhobeg , rhoend , iprint , maxfun , calfun , accum , mLPNH , mLPSH ,& mask , prefactor , rgx , rgy , rgz , stepsize , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: bobyqa use , INTRINSIC :: ISO_C_BINDING implicit none integer ( c_size_t ), intent ( in ) :: ipar ( 9 ) real ( sgl ), intent ( in ) :: initmeanval ( 3 ) real ( sgl ), intent ( in ) :: stepsize ( 3 ) real ( kind = sgl ), intent ( in ) :: expt ( ipar ( 2 ) * ipar ( 3 ) / ipar ( 1 ) ** 2 ) real ( kind = sgl ), INTENT ( IN ) :: accum ( ipar ( 6 ), ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: mLPNH ( - ipar ( 4 ): ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), ipar ( 7 )) real ( kind = sgl ), INTENT ( IN ) :: mLPSH ( - ipar ( 4 ): ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), ipar ( 7 )) real ( kind = sgl ), INTENT ( IN ) :: rgx ( ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: rgy ( ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: rgz ( ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: mask ( ipar ( 2 ) / ipar ( 1 ), ipar ( 3 ) / ipar ( 1 )) real ( kind = dbl ) :: prefactor logical , intent ( in ), optional :: verbose integer , intent ( in ) :: n !! number of variables (must be at least two) integer , intent ( in ) :: npt !! number of interpolation conditions. Its value must be in !! the interval [N+2,(N+1)(N+2)/2]. Choices that exceed 2*N+1 are not !! recommended. real ( dbl ), dimension (:), intent ( inout ) :: x !! Initial values of the variables must be set in X(1),X(2),...,X(N). They !! will be changed to the values that give the least calculated F. real ( dbl ), dimension (:), intent ( in ) :: xl !! lower bounds on x. The construction of quadratic models !! requires XL(I) to be strictly less than XU(I) for each I. Further, !! the contribution to a model from changes to the I-th variable is !! damaged severely by rounding errors if XU(I)-XL(I) is too small. real ( dbl ), dimension (:), intent ( in ) :: xu !! upper bounds on x. The construction of quadratic models !! requires XL(I) to be strictly less than XU(I) for each I. Further, !! the contribution to a model from changes to the I-th variable is !! damaged severely by rounding errors if XU(I)-XL(I) is too small. real ( dbl ), intent ( in ) :: rhobeg !! RHOBEG must be set to the initial value of a trust region radius. !! It must be positive, and typically should be about one tenth of the greatest !! expected change to a variable.  An error return occurs if any of !! the differences XU(I)-XL(I), I=1,...,N, is less than 2*RHOBEG. real ( dbl ), intent ( in ) :: rhoend !! RHOEND must be set to the final value of a trust !! region radius. It must be positive with RHOEND no greater than !! RHOBEG. Typically, RHOEND should indicate the !! accuracy that is required in the final values of the variables. integer , intent ( in ) :: iprint !! IPRINT should be set to 0, 1, 2 or 3, which controls the !! amount of printing. Specifically, there is no output if IPRINT=0 and !! there is output only at the return if IPRINT=1. Otherwise, each new !! value of RHO is printed, with the best vector of variables so far and !! the corresponding value of the objective function. Further, each new !! value of F with its variables are output if IPRINT=3. integer , intent ( in ) :: maxfun !! an upper bound on the number of calls of CALFUN. procedure ( func2 ) :: calfun !! SUBROUTINE CALFUN has to be provided by the user. It must set !! F to the value of the objective function for the current values of the !! variables X(1),X(2),...,X(N), which are generated automatically in a !! way that satisfies the bounds given in XL and XU. integer :: ibmat , id , ifv , igo , ihq , ipq , isl , isu , ivl , iw , ixa ,& ixb , ixn , ixo , ixp , izmat , j , jsl , jsu , ndim , np real ( dbl ), dimension (:), allocatable :: w real ( dbl ) :: temp real ( dbl ), parameter :: zero = 0.0_dbl ! The array W will be used for working space. allocate ( w (( NPT + 5 ) * ( NPT + N ) + 3 * N * ( N + 5 ) / 2 ) ) ! !     Return if the value of NPT is unacceptable. ! np = n + 1 if ( npt < n + 2 . or . npt > (( n + 2 ) * np ) / 2 ) then write ( * , '(/4X,A)' ) & 'Return from BOBYQA because NPT is not in the required interval' return end if ! !     Partition the working space array, so that different parts of it can !     be treated separately during the calculation of BOBYQB. The partition !     requires the first (NPT+2)*(NPT+N)+3*N*(N+5)/2 elements of W plus the !     space that is taken by the last array in the argument list of BOBYQB. ! ndim = npt + n ixb = 1 ixp = ixb + n ifv = ixp + n * npt ixo = ifv + npt igo = ixo + n ihq = igo + n ipq = ihq + ( n * np ) / 2 ibmat = ipq + npt izmat = ibmat + ndim * n isl = izmat + npt * ( npt - np ) isu = isl + n ixn = isu + n ixa = ixn + n id = ixa + n ivl = id + n iw = ivl + ndim ! !     Return if there is insufficient space between the bounds. Modify the !     initial X if necessary in order to avoid conflicts between the bounds !     and the construction of the first quadratic model. The lower and upper !     bounds on moves from the updated X are set now, in the ISL and ISU !     partitions of W, in order to provide useful and exact information about !     components of X that become within distance RHOBEG from their bounds. ! do j = 1 , n temp = xu ( j ) - xl ( j ) if ( temp < rhobeg + rhobeg ) then write ( * , '(/4X,A)' ) & 'Return from BOBYQA because one of the differences ' // & 'XU(I)-XL(I) is less than 2*RHOBEG.' return end if jsl = isl + j - 1 jsu = jsl + n w ( jsl ) = xl ( j ) - x ( j ) w ( jsu ) = xu ( j ) - x ( j ) if ( w ( jsl ) >=- rhobeg ) then if ( w ( jsl ) >= zero ) then x ( j ) = xl ( j ) w ( jsl ) = zero w ( jsu ) = temp else x ( j ) = xl ( j ) + rhobeg w ( jsl ) = - rhobeg w ( jsu ) = max ( xu ( j ) - x ( j ), rhobeg ) end if else if ( w ( jsu ) <= rhobeg ) then if ( w ( jsu ) <= zero ) then x ( j ) = xu ( j ) w ( jsl ) = - temp w ( jsu ) = zero else x ( j ) = xu ( j ) - rhobeg w ( jsl ) = min ( xl ( j ) - x ( j ), - rhobeg ) w ( jsu ) = rhobeg end if end if end do ! !     Make the call of BOBYQB. ! if ( present ( verbose )) then call bobyqb ( ipar , initmeanval , expt , n , npt , x , xl , xu , rhobeg , rhoend , iprint ,& maxfun , w ( ixb ), w ( ixp ), w ( ifv ), w ( ixo ), w ( igo ), w ( ihq ), w ( ipq ), w ( ibmat ), w ( izmat ), ndim , w ( isl ), & w ( isu ), w ( ixn ), w ( ixa ), w ( id ), w ( ivl ), w ( iw ), calfun , accum , mLPNH , mLPSH , mask , prefactor , & rgx , rgy , rgz , stepsize , verbose ) else call bobyqb ( ipar , initmeanval , expt , n , npt , x , xl , xu , rhobeg , rhoend , iprint ,& maxfun , w ( ixb ), w ( ixp ), w ( ifv ), w ( ixo ), w ( igo ), w ( ihq ), w ( ipq ), w ( ibmat ), w ( izmat ), ndim , w ( isl ), & w ( isu ), w ( ixn ), w ( ixa ), w ( id ), w ( ivl ), w ( iw ), calfun , accum , mLPNH , mLPSH , mask , prefactor , & rgx , rgy , rgz , stepsize ) end if deallocate ( w ) end subroutine bobyqa ! @date 12/12/15 SS 1.1 changed input parameters to the function interfce recursive subroutine bobyqb ( ipar , initmeanval , expt1 , n , npt , x , xl , xu ,& rhobeg , rhoend , iprint , maxfun , xbase , xpt , fval , xopt , gopt , hq ,& pq , bmat , zmat , ndim , sl , su , xnew , xalt , d , vlag , w , calfun , accum ,& mLPNH , mLPSH , mask , prefactor , rgx , rgy , rgz , stepsize , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: bobyqb implicit real ( dbl ) ( a - h , o - z ) integer ( c_size_t ), intent ( in ) :: ipar ( 9 ) real ( sgl ), intent ( in ) :: initmeanval ( 3 ) real ( sgl ), intent ( in ) :: stepsize ( 3 ) real ( sgl ), intent ( in ) :: expt1 ( ipar ( 2 ) * ipar ( 3 ) / ipar ( 1 ) ** 2 ) real ( kind = sgl ), INTENT ( IN ) :: accum ( ipar ( 6 ), ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: mLPNH ( - ipar ( 4 ): ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), ipar ( 7 )) real ( kind = sgl ), INTENT ( IN ) :: mLPSH ( - ipar ( 4 ): ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), ipar ( 7 )) real ( kind = sgl ), INTENT ( IN ) :: rgx ( ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: rgy ( ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: rgz ( ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: mask ( ipar ( 2 ) / ipar ( 1 ), ipar ( 3 ) / ipar ( 1 )) real ( kind = dbl ) :: prefactor logical , intent ( in ), optional :: verbose dimension x ( * ), xl ( * ), xu ( * ), xbase ( * ), xpt ( npt , * ), fval ( * ), xopt ( * ), & gopt ( * ), hq ( * ), pq ( * ), bmat ( ndim , * ), zmat ( npt , * ), sl ( * ), su ( * ), & xnew ( * ), xalt ( * ), d ( * ), vlag ( * ), w ( * ) procedure ( func2 ) :: calfun ! !     The arguments N, NPT, X, XL, XU, RHOBEG, RHOEND, IPRINT and MAXFUN !       are identical to the corresponding arguments in SUBROUTINE BOBYQA. !     XBASE holds a shift of origin that should reduce the contributions !       from rounding errors to values of the model and Lagrange functions. !     XPT is a two-dimensional array that holds the coordinates of the !       interpolation points relative to XBASE. !     FVAL holds the values of F at the interpolation points. !     XOPT is set to the displacement from XBASE of the trust region centre. !     GOPT holds the gradient of the quadratic model at XBASE+XOPT. !     HQ holds the explicit second derivatives of the quadratic model. !     PQ contains the parameters of the implicit second derivatives of the !       quadratic model. !     BMAT holds the last N columns of H. !     ZMAT holds the factorization of the leading NPT by NPT submatrix of H, !       this factorization being ZMAT times ZMAT&#94;T, which provides both the !       correct rank and positive semi-definiteness. !     NDIM is the first dimension of BMAT and has the value NPT+N. !     SL and SU hold the differences XL-XBASE and XU-XBASE, respectively. !       All the components of every XOPT are going to satisfy the bounds !       SL(I) .LEQ. XOPT(I) .LEQ. SU(I), with appropriate equalities when !       XOPT is on a constraint boundary. !     XNEW is chosen by SUBROUTINE TRSBOX or ALTMOV. Usually XBASE+XNEW is the !       vector of variables for the next call of CALFUN. XNEW also satisfies !       the SL and SU constraints in the way that has just been mentioned. !     XALT is an alternative to XNEW, chosen by ALTMOV, that may replace XNEW !       in order to increase the denominator in the updating of UPDATE. !     D is reserved for a trial step from XOPT, which is usually XNEW-XOPT. !     VLAG contains the values of the Lagrange functions at a new point X. !       They are part of a product that requires VLAG to be of length NDIM. !     W is a one-dimensional array that is used for working space. Its length !       must be at least 3*NDIM = 3*(NPT+N). ! !     Set some constants. ! half = 0.5_dbl one = 1.0_dbl ten = 1 0.0_dbl tenth = 0.1_dbl two = 2.0_dbl zero = 0.0_dbl np = n + 1 nptm = npt - np nh = ( n * np ) / 2 ! !     The call of PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ, !     BMAT and ZMAT for the first iteration, with the corresponding values of !     of NF and KOPT, which are the number of calls of CALFUN so far and the !     index of the interpolation point at the trust region centre. Then the !     initial XOPT is set too. The branch to label 720 occurs if MAXFUN is !     less than NPT. GOPT will be updated if KOPT is different from KBASE. ! if ( present ( verbose )) then call prelim ( ipar , initmeanval , expt1 , n , npt , x , xl , xu , rhobeg ,& iprint , maxfun , xbase , xpt , fval , gopt , hq , pq , bmat , zmat , ndim , sl , su , nf , kopt , calfun , accum , & mLPNH , mLPSH , mask , prefactor , rgx , rgy , rgz , stepsize , verbose ) else call prelim ( ipar , initmeanval , expt1 , n , npt , x , xl , xu , rhobeg ,& iprint , maxfun , xbase , xpt , fval , gopt , hq , pq , bmat , zmat , ndim , sl , su , nf , kopt , calfun , accum , & mLPNH , mLPSH , mask , prefactor , rgx , rgy , rgz , stepsize ) end if xoptsq = zero do i = 1 , n xopt ( i ) = xpt ( kopt , i ) xoptsq = xoptsq + xopt ( i ) ** 2 end do fsave = fval ( 1 ) if ( nf < npt ) then if ( iprint > 0 ) write ( * , '(/4X,A)' ) & 'Return from BOBYQA because CALFUN has been called MAXFUN times.' go to 720 end if kbase = 1 ! !     Complete the settings that are required for the iterative procedure. ! rho = rhobeg delta = rho nresc = nf ntrits = 0 diffa = zero diffb = zero itest = 0 nfsav = nf ! !     Update GOPT if necessary before the first iteration and after each !     call of RESCUE that makes a call of CALFUN. ! 20 if ( kopt /= kbase ) then ih = 0 do j = 1 , n do i = 1 , j ih = ih + 1 if ( i < j ) gopt ( j ) = gopt ( j ) + hq ( ih ) * xopt ( i ) gopt ( i ) = gopt ( i ) + hq ( ih ) * xopt ( j ) end do end do if ( nf > npt ) then do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * xopt ( j ) end do temp = pq ( k ) * temp do i = 1 , n gopt ( i ) = gopt ( i ) + temp * xpt ( k , i ) end do end do end if end if ! !     Generate the next point in the trust region that provides a small value !     of the quadratic model subject to the constraints on the variables. !     The integer NTRITS is set to the number \"trust region\" iterations that !     have occurred since the last \"alternative\" iteration. If the length !     of XNEW-XOPT is less than HALF*RHO, however, then there is a branch to !     label 650 or 680 with NTRITS=-1, instead of calculating F at XNEW. ! 60 call trsbox ( n , npt , xpt , xopt , gopt , hq , pq , sl , su , delta , xnew , d , w , w ( np ), & & w ( np + n ), w ( np + 2 * n ), w ( np + 3 * n ), dsq , crvmin ) dnorm = min ( delta , sqrt ( dsq )) if ( dnorm < half * rho ) then ntrits = - 1 distsq = ( ten * rho ) ** 2 if ( nf <= nfsav + 2 ) go to 650 ! !     The following choice between labels 650 and 680 depends on whether or !     not our work with the current RHO seems to be complete. Either RHO is !     decreased or termination occurs if the errors in the quadratic model at !     the last three interpolation points compare favourably with predictions !     of likely improvements to the model within distance HALF*RHO of XOPT. ! errbig = max ( diffa , diffb , diffc ) frhosq = 0.125_dbl * rho * rho if ( crvmin > zero . and . errbig > frhosq * crvmin ) go to 650 bdtol = errbig / rho do j = 1 , n bdtest = bdtol if ( xnew ( j ) == sl ( j )) bdtest = w ( j ) if ( xnew ( j ) == su ( j )) bdtest = - w ( j ) if ( bdtest < bdtol ) then curv = hq (( j + j * j ) / 2 ) do k = 1 , npt curv = curv + pq ( k ) * xpt ( k , j ) ** 2 end do bdtest = bdtest + half * curv * rho if ( bdtest < bdtol ) go to 650 end if end do go to 680 end if ntrits = ntrits + 1 ! !     Severe cancellation is likely to occur if XOPT is too far from XBASE. !     If the following test holds, then XBASE is shifted so that XOPT becomes !     zero. The appropriate changes are made to BMAT and to the second !     derivatives of the current model, beginning with the changes to BMAT !     that do not depend on ZMAT. VLAG is used temporarily for working space. ! 90 if ( dsq <= 1.0e-3_dbl * xoptsq ) then fracsq = 0.25_dbl * xoptsq sumpq = zero do k = 1 , npt sumpq = sumpq + pq ( k ) sum = - half * xoptsq do i = 1 , n sum = sum + xpt ( k , i ) * xopt ( i ) end do w ( npt + k ) = sum temp = fracsq - half * sum do i = 1 , n w ( i ) = bmat ( k , i ) vlag ( i ) = sum * xpt ( k , i ) + temp * xopt ( i ) ip = npt + i do j = 1 , i bmat ( ip , j ) = bmat ( ip , j ) + w ( i ) * vlag ( j ) + vlag ( i ) * w ( j ) end do end do end do ! !     Then the revisions of BMAT that depend on ZMAT are calculated. ! do jj = 1 , nptm sumz = zero sumw = zero do k = 1 , npt sumz = sumz + zmat ( k , jj ) vlag ( k ) = w ( npt + k ) * zmat ( k , jj ) sumw = sumw + vlag ( k ) end do do j = 1 , n sum = ( fracsq * sumz - half * sumw ) * xopt ( j ) do k = 1 , npt sum = sum + vlag ( k ) * xpt ( k , j ) end do w ( j ) = sum do k = 1 , npt bmat ( k , j ) = bmat ( k , j ) + sum * zmat ( k , jj ) end do end do do i = 1 , n ip = i + npt temp = w ( i ) do j = 1 , i bmat ( ip , j ) = bmat ( ip , j ) + temp * w ( j ) end do end do end do ! !     The following instructions complete the shift, including the changes !     to the second derivative parameters of the quadratic model. ! ih = 0 do j = 1 , n w ( j ) = - half * sumpq * xopt ( j ) do k = 1 , npt w ( j ) = w ( j ) + pq ( k ) * xpt ( k , j ) xpt ( k , j ) = xpt ( k , j ) - xopt ( j ) end do do i = 1 , j ih = ih + 1 hq ( ih ) = hq ( ih ) + w ( i ) * xopt ( j ) + xopt ( i ) * w ( j ) bmat ( npt + i , j ) = bmat ( npt + j , i ) end do end do do i = 1 , n xbase ( i ) = xbase ( i ) + xopt ( i ) xnew ( i ) = xnew ( i ) - xopt ( i ) sl ( i ) = sl ( i ) - xopt ( i ) su ( i ) = su ( i ) - xopt ( i ) xopt ( i ) = zero end do xoptsq = zero end if if ( ntrits == 0 ) go to 210 go to 230 ! !     XBASE is also moved to XOPT by a call of RESCUE. This calculation is !     more expensive than the previous shift, because new matrices BMAT and !     ZMAT are generated from scratch, which may include the replacement of !     interpolation points whose positions seem to be causing near linear !     dependence in the interpolation conditions. Therefore RESCUE is called !     only if rounding errors have reduced by at least a factor of two the !     denominator of the formula for updating the H matrix. It provides a !     useful safeguard, but is not invoked in most applications of BOBYQA. ! 190 nfsav = nf kbase = kopt if ( present ( verbose )) then call rescue ( ipar , initmeanval , expt1 , n , npt , xl , xu , iprint , maxfun , xbase ,& xpt , fval , xopt , gopt , hq , pq , bmat , zmat , ndim , sl , su , nf , delta , kopt , vlag , w , w ( n + np ), w ( ndim + np ), & calfun , accum , mLPNH , mLPSH , mask , prefactor , rgx , rgy , rgz , stepsize , verbose ) else call rescue ( ipar , initmeanval , expt1 , n , npt , xl , xu , iprint , maxfun , xbase ,& xpt , fval , xopt , gopt , hq , pq , bmat , zmat , ndim , sl , su , nf , delta , kopt , vlag , w , w ( n + np ), w ( ndim + np ), & calfun , accum , mLPNH , mLPSH , mask , prefactor , rgx , rgy , rgz , stepsize ) end if ! !     XOPT is updated now in case the branch below to label 720 is taken. !     Any updating of GOPT occurs after the branch below to label 20, which !     leads to a trust region iteration as does the branch to label 60. ! xoptsq = zero if ( kopt /= kbase ) then do i = 1 , n xopt ( i ) = xpt ( kopt , i ) xoptsq = xoptsq + xopt ( i ) ** 2 end do end if if ( nf < 0 ) then nf = maxfun if ( iprint > 0 ) write ( * , '(/4X,A)' ) & 'Return from BOBYQA because CALFUN has been called MAXFUN times.' go to 720 end if nresc = nf if ( nfsav < nf ) then nfsav = nf go to 20 end if if ( ntrits > 0 ) go to 60 ! !     Pick two alternative vectors of variables, relative to XBASE, that !     are suitable as new positions of the KNEW-th interpolation point. !     Firstly, XNEW is set to the point on a line through XOPT and another !     interpolation point that minimizes the predicted value of the next !     denominator, subject to ||XNEW - XOPT|| .LEQ. ADELT and to the SL !     and SU bounds. Secondly, XALT is set to the best feasible point on !     a constrained version of the Cauchy step of the KNEW-th Lagrange !     function, the corresponding value of the square of this function !     being returned in CAUCHY. The choice between these alternatives is !     going to be made when the denominator is calculated. ! 210 call altmov ( n , npt , xpt , xopt , bmat , zmat , ndim , sl , su , kopt , knew , adelt , & & xnew , xalt , alpha , cauchy , w , w ( np ), w ( ndim + 1 )) do i = 1 , n d ( i ) = xnew ( i ) - xopt ( i ) end do ! !     Calculate VLAG and BETA for the current choice of D. The scalar !     product of D with XPT(K,.) is going to be held in W(NPT+K) for !     use when VQUAD is calculated. ! 230 do k = 1 , npt suma = zero sumb = zero sum = zero do j = 1 , n suma = suma + xpt ( k , j ) * d ( j ) sumb = sumb + xpt ( k , j ) * xopt ( j ) sum = sum + bmat ( k , j ) * d ( j ) end do w ( k ) = suma * ( half * suma + sumb ) vlag ( k ) = sum w ( npt + k ) = suma end do beta = zero do jj = 1 , nptm sum = zero do k = 1 , npt sum = sum + zmat ( k , jj ) * w ( k ) end do beta = beta - sum * sum do k = 1 , npt vlag ( k ) = vlag ( k ) + sum * zmat ( k , jj ) end do end do dsq = zero bsum = zero dx = zero do j = 1 , n dsq = dsq + d ( j ) ** 2 sum = zero do k = 1 , npt sum = sum + w ( k ) * bmat ( k , j ) end do bsum = bsum + sum * d ( j ) jp = npt + j do i = 1 , n sum = sum + bmat ( jp , i ) * d ( i ) end do vlag ( jp ) = sum bsum = bsum + sum * d ( j ) dx = dx + d ( j ) * xopt ( j ) end do beta = dx * dx + dsq * ( xoptsq + dx + dx + half * dsq ) + beta - bsum vlag ( kopt ) = vlag ( kopt ) + one ! !     If NTRITS is zero, the denominator may be increased by replacing !     the step D of ALTMOV by a Cauchy step. Then RESCUE may be called if !     rounding errors have damaged the chosen denominator. ! if ( ntrits == 0 ) then denom = vlag ( knew ) ** 2 + alpha * beta if ( denom < cauchy . and . cauchy > zero ) then do i = 1 , n xnew ( i ) = xalt ( i ) d ( i ) = xnew ( i ) - xopt ( i ) end do cauchy = zero go to 230 end if if ( denom <= half * vlag ( knew ) ** 2 ) then if ( nf > nresc ) go to 190 if ( iprint > 0 ) write ( * , '(/5X,A)' ) & 'Return from BOBYQA because of much cancellation in a denominator.' go to 720 end if ! !     Alternatively, if NTRITS is positive, then set KNEW to the index of !     the next interpolation point to be deleted to make room for a trust !     region step. Again RESCUE may be called if rounding errors have damaged !     the chosen denominator, which is the reason for attempting to select !     KNEW before calculating the next value of the objective function. ! else delsq = delta * delta scaden = zero biglsq = zero knew = 0 do k = 1 , npt if ( k == kopt ) cycle hdiag = zero do jj = 1 , nptm hdiag = hdiag + zmat ( k , jj ) ** 2 end do den = beta * hdiag + vlag ( k ) ** 2 distsq = zero do j = 1 , n distsq = distsq + ( xpt ( k , j ) - xopt ( j )) ** 2 end do temp = max ( one , ( distsq / delsq ) ** 2 ) if ( temp * den > scaden ) then scaden = temp * den knew = k denom = den end if biglsq = max ( biglsq , temp * vlag ( k ) ** 2 ) end do if ( scaden <= half * biglsq ) then if ( nf > nresc ) go to 190 if ( iprint > 0 ) write ( * , '(/5X,A)' ) & 'Return from BOBYQA because of much cancellation in a denominator.' go to 720 end if end if ! !     Put the variables for the next calculation of the objective function !       in XNEW, with any adjustments for the bounds. ! ! !     Calculate the value of the objective function at XBASE+XNEW, unless !       the limit on the number of calculations of F has been reached. ! 360 do i = 1 , n x ( i ) = min ( max ( xl ( i ), xbase ( i ) + xnew ( i )), xu ( i )) if ( xnew ( i ) == sl ( i )) x ( i ) = xl ( i ) if ( xnew ( i ) == su ( i )) x ( i ) = xu ( i ) end do if ( nf >= maxfun ) then if ( iprint > 0 ) write ( * , '(/4X,A)' ) & 'Return from BOBYQA because CALFUN has been called MAXFUN times.' go to 720 end if nf = nf + 1 !======================================================================================= !============changed function call depending on how many call have been made============ !======================================================================================= if ( present ( verbose )) then call calfun ( ipar , initmeanval , expt1 , accum , mLPNH , mLPSH , & n , x ( 1 : n ), f , mask , prefactor , rgx , rgy , rgz , stepsize , verbose = verbose ) else call calfun ( ipar , initmeanval , expt1 , accum , mLPNH , mLPSH , & n , x ( 1 : n ), f , mask , prefactor , rgx , rgy , rgz , stepsize ) end if if ( iprint == 3 ) then print 400 , nf , f , ( x ( i ), i = 1 , n ) 400 format ( / 4 x , 'Function number' , i6 , '    F =' , 1 pd18 . 10 ,& '   The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if if ( ntrits ==- 1 ) then fsave = f go to 720 end if ! !     Use the quadratic model to predict the change in F due to the step D, !       and set DIFF to the error of this prediction. ! fopt = fval ( kopt ) vquad = zero ih = 0 do j = 1 , n vquad = vquad + d ( j ) * gopt ( j ) do i = 1 , j ih = ih + 1 temp = d ( i ) * d ( j ) if ( i == j ) temp = half * temp vquad = vquad + hq ( ih ) * temp end do end do do k = 1 , npt vquad = vquad + half * pq ( k ) * w ( npt + k ) ** 2 end do diff = f - fopt - vquad diffc = diffb diffb = diffa diffa = abs ( diff ) if ( dnorm > rho ) nfsav = nf ! !     Pick the next value of DELTA after a trust region step. ! if ( ntrits > 0 ) then if ( vquad >= zero ) then if ( iprint > 0 ) print 430 430 format ( / 4 x , 'Return from BOBYQA because a trust' ,& ' region step has failed to reduce Q.' ) go to 720 end if ratio = ( f - fopt ) / vquad if ( ratio <= tenth ) then delta = min ( half * delta , dnorm ) else if ( ratio <= 0.7_dbl ) then delta = max ( half * delta , dnorm ) else delta = max ( half * delta , dnorm + dnorm ) end if if ( delta <= 1.5_dbl * rho ) delta = rho ! !     Recalculate KNEW and DENOM if the new F is less than FOPT. ! if ( f < fopt ) then ksav = knew densav = denom delsq = delta * delta scaden = zero biglsq = zero knew = 0 do k = 1 , npt hdiag = zero do jj = 1 , nptm hdiag = hdiag + zmat ( k , jj ) ** 2 end do den = beta * hdiag + vlag ( k ) ** 2 distsq = zero do j = 1 , n distsq = distsq + ( xpt ( k , j ) - xnew ( j )) ** 2 end do temp = max ( one , ( distsq / delsq ) ** 2 ) if ( temp * den > scaden ) then scaden = temp * den knew = k denom = den end if biglsq = max ( biglsq , temp * vlag ( k ) ** 2 ) end do if ( scaden <= half * biglsq ) then knew = ksav denom = densav end if end if end if ! !     Update BMAT and ZMAT, so that the KNEW-th interpolation point can be !     moved. Also update the second derivative terms of the model. ! call update ( n , npt , bmat , zmat , ndim , vlag , beta , denom , knew , w ) ih = 0 pqold = pq ( knew ) pq ( knew ) = zero do i = 1 , n temp = pqold * xpt ( knew , i ) do j = 1 , i ih = ih + 1 hq ( ih ) = hq ( ih ) + temp * xpt ( knew , j ) end do end do do jj = 1 , nptm temp = diff * zmat ( knew , jj ) do k = 1 , npt pq ( k ) = pq ( k ) + temp * zmat ( k , jj ) end do end do ! !     Include the new interpolation point, and make the changes to GOPT at !     the old XOPT that are caused by the updating of the quadratic model. ! fval ( knew ) = f do i = 1 , n xpt ( knew , i ) = xnew ( i ) w ( i ) = bmat ( knew , i ) end do do k = 1 , npt suma = zero do jj = 1 , nptm suma = suma + zmat ( knew , jj ) * zmat ( k , jj ) end do sumb = zero do j = 1 , n sumb = sumb + xpt ( k , j ) * xopt ( j ) end do temp = suma * sumb do i = 1 , n w ( i ) = w ( i ) + temp * xpt ( k , i ) end do end do do i = 1 , n gopt ( i ) = gopt ( i ) + diff * w ( i ) end do ! !     Update XOPT, GOPT and KOPT if the new calculated F is less than FOPT. ! if ( f < fopt ) then kopt = knew xoptsq = zero ih = 0 do j = 1 , n xopt ( j ) = xnew ( j ) xoptsq = xoptsq + xopt ( j ) ** 2 do i = 1 , j ih = ih + 1 if ( i < j ) gopt ( j ) = gopt ( j ) + hq ( ih ) * d ( i ) gopt ( i ) = gopt ( i ) + hq ( ih ) * d ( j ) end do end do do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * d ( j ) end do temp = pq ( k ) * temp do i = 1 , n gopt ( i ) = gopt ( i ) + temp * xpt ( k , i ) end do end do end if ! !     Calculate the parameters of the least Frobenius norm interpolant to !     the current data, the gradient of this interpolant at XOPT being put !     into VLAG(NPT+I), I=1,2,...,N. ! if ( ntrits > 0 ) then do k = 1 , npt vlag ( k ) = fval ( k ) - fval ( kopt ) w ( k ) = zero end do do j = 1 , nptm sum = zero do k = 1 , npt sum = sum + zmat ( k , j ) * vlag ( k ) end do do k = 1 , npt w ( k ) = w ( k ) + sum * zmat ( k , j ) end do end do do k = 1 , npt sum = zero do j = 1 , n sum = sum + xpt ( k , j ) * xopt ( j ) end do w ( k + npt ) = w ( k ) w ( k ) = sum * w ( k ) end do gqsq = zero gisq = zero do i = 1 , n sum = zero do k = 1 , npt sum = sum + bmat ( k , i ) * vlag ( k ) + xpt ( k , i ) * w ( k ) end do if ( xopt ( i ) == sl ( i )) then gqsq = gqsq + min ( zero , gopt ( i )) ** 2 gisq = gisq + min ( zero , sum ) ** 2 else if ( xopt ( i ) == su ( i )) then gqsq = gqsq + max ( zero , gopt ( i )) ** 2 gisq = gisq + max ( zero , sum ) ** 2 else gqsq = gqsq + gopt ( i ) ** 2 gisq = gisq + sum * sum end if vlag ( npt + i ) = sum end do ! !     Test whether to replace the new quadratic model by the least Frobenius !     norm interpolant, making the replacement if the test is satisfied. ! itest = itest + 1 if ( gqsq < ten * gisq ) itest = 0 if ( itest >= 3 ) then do i = 1 , max ( npt , nh ) if ( i <= n ) gopt ( i ) = vlag ( npt + i ) if ( i <= npt ) pq ( i ) = w ( npt + i ) if ( i <= nh ) hq ( i ) = zero itest = 0 end do end if end if ! !     If a trust region step has provided a sufficient decrease in F, then !     branch for another trust region calculation. The case NTRITS=0 occurs !     when the new interpolation point was reached by an alternative step. ! if ( ntrits == 0 ) go to 60 if ( f <= fopt + tenth * vquad ) go to 60 ! !     Alternatively, find out if the interpolation points are close enough !       to the best point so far. ! distsq = max (( two * delta ) ** 2 , ( ten * rho ) ** 2 ) 650 knew = 0 do k = 1 , npt sum = zero do j = 1 , n sum = sum + ( xpt ( k , j ) - xopt ( j )) ** 2 end do if ( sum > distsq ) then knew = k distsq = sum end if end do ! !     If KNEW is positive, then ALTMOV finds alternative new positions for !     the KNEW-th interpolation point within distance ADELT of XOPT. It is !     reached via label 90. Otherwise, there is a branch to label 60 for !     another trust region iteration, unless the calculations with the !     current RHO are complete. ! if ( knew > 0 ) then dist = sqrt ( distsq ) if ( ntrits ==- 1 ) then delta = min ( tenth * delta , half * dist ) if ( delta <= 1.5_dbl * rho ) delta = rho end if ntrits = 0 adelt = max ( min ( tenth * dist , delta ), rho ) dsq = adelt * adelt go to 90 end if if ( ntrits ==- 1 ) go to 680 if ( ratio > zero ) go to 60 if ( max ( delta , dnorm ) > rho ) go to 60 ! !     The calculations with the current value of RHO are complete. Pick the !       next values of RHO and DELTA. ! 680 if ( rho > rhoend ) then delta = half * rho ratio = rho / rhoend if ( ratio <= 1 6.0_dbl ) then rho = rhoend else if ( ratio <= 25 0.0_dbl ) then rho = sqrt ( ratio ) * rhoend else rho = tenth * rho end if delta = max ( delta , rho ) if ( iprint >= 2 ) then if ( iprint >= 3 ) print 690 690 format ( 5 x ) print 700 , rho , nf 700 format ( / 4 x , 'New RHO =' , 1 pd11 . 4 , 5 x , 'Number of' ,& ' function values =' , i6 ) print 710 , fval ( kopt ), ( xbase ( i ) + xopt ( i ), i = 1 , n ) 710 format ( 4 x , 'Least value of F =' , 1 pd23 . 15 , 9 x ,& 'The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if ntrits = 0 nfsav = nf go to 60 end if ! !     Return from the calculation, after another Newton-Raphson step, if !       it is too short to have been tried before. ! if ( ntrits ==- 1 ) go to 360 720 if ( fval ( kopt ) <= fsave ) then do i = 1 , n x ( i ) = min ( max ( xl ( i ), xbase ( i ) + xopt ( i )), xu ( i )) if ( xopt ( i ) == sl ( i )) x ( i ) = xl ( i ) if ( xopt ( i ) == su ( i )) x ( i ) = xu ( i ) end do f = fval ( kopt ) end if if ( iprint >= 1 ) then print 740 , nf 740 format ( / 4 x , 'At the return from BOBYQA' , 5 x ,& 'Number of function values =' , i6 ) print 710 , f , ( x ( i ), i = 1 , n ) end if return end subroutine bobyqb recursive subroutine altmov ( n , npt , xpt , xopt , bmat , zmat , ndim , sl , su , kopt , knew , adelt , & & xnew , xalt , alpha , cauchy , glag , hcol , w ) !DEC$ ATTRIBUTES DLLEXPORT :: altmov implicit real ( dbl ) ( a - h , o - z ) dimension xpt ( npt , * ), xopt ( * ), bmat ( ndim , * ), zmat ( npt , * ), sl ( * ), su ( * ), & & xnew ( * ), xalt ( * ), glag ( * ), hcol ( * ), w ( * ) ! !     The arguments N, NPT, XPT, XOPT, BMAT, ZMAT, NDIM, SL and SU all have !       the same meanings as the corresponding arguments of BOBYQB. !     KOPT is the index of the optimal interpolation point. !     KNEW is the index of the interpolation point that is going to be moved. !     ADELT is the current trust region bound. !     XNEW will be set to a suitable new position for the interpolation point !       XPT(KNEW,.). Specifically, it satisfies the SL, SU and trust region !       bounds and it should provide a large denominator in the next call of !       UPDATE. The step XNEW-XOPT from XOPT is restricted to moves along the !       straight lines through XOPT and another interpolation point. !     XALT also provides a large value of the modulus of the KNEW-th Lagrange !       function subject to the constraints that have been mentioned, its main !       difference from XNEW being that XALT-XOPT is a constrained version of !       the Cauchy step within the trust region. An exception is that XALT is !       not calculated if all components of GLAG (see below) are zero. !     ALPHA will be set to the KNEW-th diagonal element of the H matrix. !     CAUCHY will be set to the square of the KNEW-th Lagrange function at !       the step XALT-XOPT from XOPT for the vector XALT that is returned, !       except that CAUCHY is set to zero if XALT is not calculated. !     GLAG is a working space vector of length N for the gradient of the !       KNEW-th Lagrange function at XOPT. !     HCOL is a working space vector of length NPT for the second derivative !       coefficients of the KNEW-th Lagrange function. !     W is a working space vector of length 2N that is going to hold the !       constrained Cauchy step from XOPT of the Lagrange function, followed !       by the downhill version of XALT when the uphill step is calculated. ! !     Set the first NPT components of W to the leading elements of the !     KNEW-th column of the H matrix. ! half = 0.5_dbl one = 1.0_dbl zero = 0.0_dbl const = one + sqrt ( 2.0_dbl ) do k = 1 , npt hcol ( k ) = zero end do do j = 1 , npt - n - 1 temp = zmat ( knew , j ) do k = 1 , npt hcol ( k ) = hcol ( k ) + temp * zmat ( k , j ) end do end do alpha = hcol ( knew ) ha = half * alpha ! !     Calculate the gradient of the KNEW-th Lagrange function at XOPT. ! do i = 1 , n glag ( i ) = bmat ( knew , i ) end do do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * xopt ( j ) end do temp = hcol ( k ) * temp do i = 1 , n glag ( i ) = glag ( i ) + temp * xpt ( k , i ) end do end do ! !     Search for a large denominator along the straight lines through XOPT !     and another interpolation point. SLBD and SUBD will be lower and upper !     bounds on the step along each of these lines in turn. PREDSQ will be !     set to the square of the predicted denominator for each line. PRESAV !     will be set to the largest admissible value of PREDSQ that occurs. ! presav = zero do k = 1 , npt if ( k == kopt ) cycle dderiv = zero distsq = zero do i = 1 , n temp = xpt ( k , i ) - xopt ( i ) dderiv = dderiv + glag ( i ) * temp distsq = distsq + temp * temp end do subd = adelt / sqrt ( distsq ) slbd = - subd ilbd = 0 iubd = 0 sumin = min ( one , subd ) ! !     Revise SLBD and SUBD if necessary because of the bounds in SL and SU. ! do i = 1 , n temp = xpt ( k , i ) - xopt ( i ) if ( temp > zero ) then if ( slbd * temp < sl ( i ) - xopt ( i )) then slbd = ( sl ( i ) - xopt ( i )) / temp ilbd = - i end if if ( subd * temp > su ( i ) - xopt ( i )) then subd = max ( sumin , ( su ( i ) - xopt ( i )) / temp ) iubd = i end if else if ( temp < zero ) then if ( slbd * temp > su ( i ) - xopt ( i )) then slbd = ( su ( i ) - xopt ( i )) / temp ilbd = i end if if ( subd * temp < sl ( i ) - xopt ( i )) then subd = max ( sumin , ( sl ( i ) - xopt ( i )) / temp ) iubd = - i end if end if end do ! !     Seek a large modulus of the KNEW-th Lagrange function when the index !     of the other interpolation point on the line through XOPT is KNEW. ! if ( k == knew ) then diff = dderiv - one step = slbd vlag = slbd * ( dderiv - slbd * diff ) isbd = ilbd temp = subd * ( dderiv - subd * diff ) if ( abs ( temp ) > abs ( vlag )) then step = subd vlag = temp isbd = iubd end if tempd = half * dderiv tempa = tempd - diff * slbd tempb = tempd - diff * subd if ( tempa * tempb < zero ) then temp = tempd * tempd / diff if ( abs ( temp ) > abs ( vlag )) then step = tempd / diff vlag = temp isbd = 0 end if end if ! !     Search along each of the other lines through XOPT and another point. ! else step = slbd vlag = slbd * ( one - slbd ) isbd = ilbd temp = subd * ( one - subd ) if ( abs ( temp ) > abs ( vlag )) then step = subd vlag = temp isbd = iubd end if if ( subd > half ) then if ( abs ( vlag ) < 0.25_dbl ) then step = half vlag = 0.25_dbl isbd = 0 end if end if vlag = vlag * dderiv end if ! !     Calculate PREDSQ for the current line search and maintain PRESAV. ! temp = step * ( one - step ) * distsq predsq = vlag * vlag * ( vlag * vlag + ha * temp * temp ) if ( predsq > presav ) then presav = predsq ksav = k stpsav = step ibdsav = isbd end if end do ! !     Construct XNEW in a way that satisfies the bound constraints exactly. ! do i = 1 , n temp = xopt ( i ) + stpsav * ( xpt ( ksav , i ) - xopt ( i )) xnew ( i ) = max ( sl ( i ), min ( su ( i ), temp )) end do if ( ibdsav < 0 ) xnew ( - ibdsav ) = sl ( - ibdsav ) if ( ibdsav > 0 ) xnew ( ibdsav ) = su ( ibdsav ) ! !     Prepare for the iterative method that assembles the constrained Cauchy !     step in W. The sum of squares of the fixed components of W is formed in !     WFIXSQ, and the free components of W are set to BIGSTP. ! bigstp = adelt + adelt iflag = 0 100 wfixsq = zero ggfree = zero do i = 1 , n w ( i ) = zero tempa = min ( xopt ( i ) - sl ( i ), glag ( i )) tempb = max ( xopt ( i ) - su ( i ), glag ( i )) if ( tempa > zero . or . tempb < zero ) then w ( i ) = bigstp ggfree = ggfree + glag ( i ) ** 2 end if end do if ( ggfree == zero ) then cauchy = zero return end if ! !     Investigate whether more components of W can be fixed. ! 120 temp = adelt * adelt - wfixsq if ( temp > zero ) then wsqsav = wfixsq step = sqrt ( temp / ggfree ) ggfree = zero do i = 1 , n if ( w ( i ) == bigstp ) then temp = xopt ( i ) - step * glag ( i ) if ( temp <= sl ( i )) then w ( i ) = sl ( i ) - xopt ( i ) wfixsq = wfixsq + w ( i ) ** 2 else if ( temp >= su ( i )) then w ( i ) = su ( i ) - xopt ( i ) wfixsq = wfixsq + w ( i ) ** 2 else ggfree = ggfree + glag ( i ) ** 2 end if end if end do if ( wfixsq > wsqsav . and . ggfree > zero ) go to 120 end if ! !     Set the remaining free components of W and all components of XALT, !     except that W may be scaled later. ! gw = zero do i = 1 , n if ( w ( i ) == bigstp ) then w ( i ) = - step * glag ( i ) xalt ( i ) = max ( sl ( i ), min ( su ( i ), xopt ( i ) + w ( i ))) else if ( w ( i ) == zero ) then xalt ( i ) = xopt ( i ) else if ( glag ( i ) > zero ) then xalt ( i ) = sl ( i ) else xalt ( i ) = su ( i ) end if gw = gw + glag ( i ) * w ( i ) end do ! !     Set CURV to the curvature of the KNEW-th Lagrange function along W. !     Scale W by a factor less than one if that can reduce the modulus of !     the Lagrange function at XOPT+W. Set CAUCHY to the final value of !     the square of this function. ! curv = zero do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * w ( j ) end do curv = curv + hcol ( k ) * temp * temp end do if ( iflag == 1 ) curv = - curv if ( curv >- gw . and . curv <- const * gw ) then scale = - gw / curv do i = 1 , n temp = xopt ( i ) + scale * w ( i ) xalt ( i ) = max ( sl ( i ), min ( su ( i ), temp )) end do cauchy = ( half * gw * scale ) ** 2 else cauchy = ( gw + half * curv ) ** 2 end if ! !     If IFLAG is zero, then XALT is calculated as before after reversing !     the sign of GLAG. Thus two XALT vectors become available. The one that !     is chosen is the one that gives the larger value of CAUCHY. ! if ( iflag == 0 ) then do i = 1 , n glag ( i ) = - glag ( i ) w ( n + i ) = xalt ( i ) end do csave = cauchy iflag = 1 go to 100 end if if ( csave > cauchy ) then do i = 1 , n xalt ( i ) = w ( n + i ) end do cauchy = csave end if end subroutine altmov ! @date 12/12/15 SS 1.1 changed input parameters to the subroutine recursive subroutine prelim ( ipar , initmeanval , expt1 , n , npt , x , xl , xu , rhobeg ,& iprint , maxfun , xbase , xpt , fval , gopt , hq , pq , bmat , zmat , ndim , sl , su , nf , kopt , calfun , accum , mLPNH , mLPSH ,& mask , prefactor , rgx , rgy , rgz , stepsize , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: prelim implicit real ( dbl ) ( a - h , o - z ) integer ( 8 ), intent ( in ) :: ipar ( 9 ) real ( sgl ), intent ( in ) :: initmeanval ( 3 ) real ( sgl ), intent ( in ) :: stepsize ( 3 ) real ( sgl ), intent ( in ) :: expt1 ( ipar ( 2 ) * ipar ( 3 ) / ipar ( 1 ) ** 2 ) real ( kind = sgl ), INTENT ( IN ) :: accum ( ipar ( 6 ), ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: mLPNH ( - ipar ( 4 ): ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), ipar ( 7 )) real ( kind = sgl ), INTENT ( IN ) :: mLPSH ( - ipar ( 4 ): ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), ipar ( 7 )) real ( kind = sgl ), INTENT ( IN ) :: rgx ( ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: rgy ( ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: rgz ( ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: mask ( ipar ( 2 ) / ipar ( 1 ), ipar ( 3 ) / ipar ( 1 )) real ( kind = dbl ) :: prefactor logical , intent ( in ), optional :: verbose dimension x ( * ), xl ( * ), xu ( * ), xbase ( * ), xpt ( npt , * ), fval ( * ), gopt ( * ), hq & & ( * ), pq ( * ), bmat ( ndim , * ), zmat ( npt , * ), sl ( * ), su ( * ) procedure ( func2 ) :: calfun ! !     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the !       same as the corresponding arguments in SUBROUTINE BOBYQA. !     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU !       are the same as the corresponding arguments in BOBYQB, the elements !       of SL and SU being set in BOBYQA. !     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but !       it is set by PRELIM to the gradient of the quadratic model at XBASE. !       If XOPT is nonzero, BOBYQB will change it to its usual value later. !     NF is maintaned as the number of calls of CALFUN so far. !     KOPT will be such that the least calculated value of F so far is at !       the point XPT(KOPT,.)+XBASE in the space of the variables. ! !     SUBROUTINE PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ, !     BMAT and ZMAT for the first iteration, and it maintains the values of !     NF and KOPT. The vector X is also changed by PRELIM. ! !     Set some constants. ! half = 0.5_dbl one = 1.0_dbl two = 2.0_dbl zero = 0.0_dbl rhosq = rhobeg * rhobeg recip = one / rhosq np = n + 1 ! !     Set XBASE to the initial vector of variables, and set the initial !     elements of XPT, BMAT, HQ, PQ and ZMAT to zero. ! do j = 1 , n xbase ( j ) = x ( j ) do k = 1 , npt xpt ( k , j ) = zero end do do i = 1 , ndim bmat ( i , j ) = zero end do end do do ih = 1 , ( n * np ) / 2 hq ( ih ) = zero end do do k = 1 , npt pq ( k ) = zero do j = 1 , npt - np zmat ( k , j ) = zero end do end do ! !     Begin the initialization procedure. NF becomes one more than the number !     of function values so far. The coordinates of the displacement of the !     next initial interpolation point from XBASE are set in XPT(NF+1,.). ! nf = 0 50 nfm = nf nfx = nf - n nf = nf + 1 if ( nfm <= 2 * n ) then if ( nfm >= 1 . and . nfm <= n ) then stepa = rhobeg if ( su ( nfm ) == zero ) stepa = - stepa xpt ( nf , nfm ) = stepa else if ( nfm > n ) then stepa = xpt ( nf - n , nfx ) stepb = - rhobeg if ( sl ( nfx ) == zero ) stepb = min ( two * rhobeg , su ( nfx )) if ( su ( nfx ) == zero ) stepb = max ( - two * rhobeg , sl ( nfx )) xpt ( nf , nfx ) = stepb end if else itemp = ( nfm - np ) / n jpt = nfm - itemp * n - n ipt = jpt + itemp if ( ipt > n ) then itemp = jpt jpt = ipt - n ipt = itemp end if xpt ( nf , ipt ) = xpt ( ipt + 1 , ipt ) xpt ( nf , jpt ) = xpt ( jpt + 1 , jpt ) end if ! !     Calculate the next value of F. The least function value so far and !     its index are required. ! do j = 1 , n x ( j ) = min ( max ( xl ( j ), xbase ( j ) + xpt ( nf , j )), xu ( j )) if ( xpt ( nf , j ) == sl ( j )) x ( j ) = xl ( j ) if ( xpt ( nf , j ) == su ( j )) x ( j ) = xu ( j ) end do !======================================================================================= !============changed function call depending on how many call have been made============ !======================================================================================= if ( present ( verbose )) then call calfun ( ipar , initmeanval , expt1 , accum , mLPNH , mLPSH , & n , x ( 1 : n ), f , mask , prefactor , rgx , rgy , rgz , stepsize , verbose = verbose ) else call calfun ( ipar , initmeanval , expt1 , accum , mLPNH , mLPSH , & n , x ( 1 : n ), f , mask , prefactor , rgx , rgy , rgz , stepsize ) end if if ( iprint == 3 ) then print 70 , nf , f , ( x ( i ), i = 1 , n ) 70 format ( / 4 x , 'Function number' , i6 , '    F =' , 1 pd18 . 10 ,& '    The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if fval ( nf ) = f if ( nf == 1 ) then fbeg = f kopt = 1 else if ( f < fval ( kopt )) then kopt = nf end if ! !     Set the nonzero initial elements of BMAT and the quadratic model in the !     cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions !     of the NF-th and (NF-N)-th interpolation points may be switched, in !     order that the function value at the first of them contributes to the !     off-diagonal second derivative terms of the initial quadratic model. ! if ( nf <= 2 * n + 1 ) then if ( nf >= 2 . and . nf <= n + 1 ) then gopt ( nfm ) = ( f - fbeg ) / stepa if ( npt < nf + n ) then bmat ( 1 , nfm ) = - one / stepa bmat ( nf , nfm ) = one / stepa bmat ( npt + nfm , nfm ) = - half * rhosq end if else if ( nf >= n + 2 ) then ih = ( nfx * ( nfx + 1 )) / 2 temp = ( f - fbeg ) / stepb diff = stepb - stepa hq ( ih ) = two * ( temp - gopt ( nfx )) / diff gopt ( nfx ) = ( gopt ( nfx ) * stepb - temp * stepa ) / diff if ( stepa * stepb < zero ) then if ( f < fval ( nf - n )) then fval ( nf ) = fval ( nf - n ) fval ( nf - n ) = f if ( kopt == nf ) kopt = nf - n xpt ( nf - n , nfx ) = stepb xpt ( nf , nfx ) = stepa end if end if bmat ( 1 , nfx ) = - ( stepa + stepb ) / ( stepa * stepb ) bmat ( nf , nfx ) = - half / xpt ( nf - n , nfx ) bmat ( nf - n , nfx ) = - bmat ( 1 , nfx ) - bmat ( nf , nfx ) zmat ( 1 , nfx ) = sqrt ( two ) / ( stepa * stepb ) zmat ( nf , nfx ) = sqrt ( half ) / rhosq zmat ( nf - n , nfx ) = - zmat ( 1 , nfx ) - zmat ( nf , nfx ) end if ! !     Set the off-diagonal second derivatives of the Lagrange functions and !     the initial quadratic model. ! else ih = ( ipt * ( ipt - 1 )) / 2 + jpt zmat ( 1 , nfx ) = recip zmat ( nf , nfx ) = recip zmat ( ipt + 1 , nfx ) = - recip zmat ( jpt + 1 , nfx ) = - recip temp = xpt ( nf , ipt ) * xpt ( nf , jpt ) hq ( ih ) = ( fbeg - fval ( ipt + 1 ) - fval ( jpt + 1 ) + f ) / temp end if if ( nf < npt . and . nf < maxfun ) go to 50 end subroutine prelim ! @date 12/12/15 SS 1.1 changed input parameters to subroutine call recursive subroutine rescue ( ipar , initmeanval , expt1 , n , npt , xl , xu , iprint ,& maxfun , xbase , xpt , fval , xopt , gopt , hq , pq , bmat , zmat , ndim , sl , su , nf , delta , kopt , vlag ,& ptsaux , ptsid , w , calfun , accum , mLPNH , mLPSH , mask , prefactor , rgx , rgy , rgz , stepsize , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: rescue implicit real ( dbl ) ( a - h , o - z ) integer ( 8 ), intent ( in ) :: ipar ( 9 ) real ( sgl ), intent ( in ) :: initmeanval ( 3 ) real ( sgl ), intent ( in ) :: stepsize ( 3 ) real ( sgl ), intent ( in ) :: expt1 ( ipar ( 2 ) * ipar ( 3 ) / ipar ( 1 ) ** 2 ) real ( kind = sgl ), INTENT ( IN ) :: accum ( ipar ( 6 ), ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: mLPNH ( - ipar ( 4 ): ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), ipar ( 7 )) real ( kind = sgl ), INTENT ( IN ) :: mLPSH ( - ipar ( 4 ): ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), ipar ( 7 )) real ( kind = sgl ), INTENT ( IN ) :: rgx ( ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: rgy ( ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: rgz ( ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: mask ( ipar ( 2 ) / ipar ( 1 ), ipar ( 3 ) / ipar ( 1 )) real ( kind = dbl ) :: prefactor logical , intent ( in ), optional :: verbose dimension xl ( * ), xu ( * ), xbase ( * ), xpt ( npt , * ), fval ( * ), xopt ( * ), gopt ( * ), & & hq ( * ), pq ( * ), bmat ( ndim , * ), zmat ( npt , * ), sl ( * ), su ( * ), vlag ( * ), ptsaux & & ( 2 , * ), ptsid ( * ), w ( * ) procedure ( func2 ) :: calfun ! !     The arguments N, NPT, XL, XU, IPRINT, MAXFUN, XBASE, XPT, FVAL, XOPT, !       GOPT, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU have the same meanings as !       the corresponding arguments of BOBYQB on the entry to RESCUE. !     NF is maintained as the number of calls of CALFUN so far, except that !       NF is set to -1 if the value of MAXFUN prevents further progress. !     KOPT is maintained so that FVAL(KOPT) is the least calculated function !       value. Its correct value must be given on entry. It is updated if a !       new least function value is found, but the corresponding changes to !       XOPT and GOPT have to be made later by the calling program. !     DELTA is the current trust region radius. !     VLAG is a working space vector that will be used for the values of the !       provisional Lagrange functions at each of the interpolation points. !       They are part of a product that requires VLAG to be of length NDIM. !     PTSAUX is also a working space array. For J=1,2,...,N, PTSAUX(1,J) and !       PTSAUX(2,J) specify the two positions of provisional interpolation !       points when a nonzero step is taken along e_J (the J-th coordinate !       direction) through XBASE+XOPT, as specified below. Usually these !       steps have length DELTA, but other lengths are chosen if necessary !       in order to satisfy the given bounds on the variables. !     PTSID is also a working space array. It has NPT components that denote !       provisional new positions of the original interpolation points, in !       case changes are needed to restore the linear independence of the !       interpolation conditions. The K-th point is a candidate for change !       if and only if PTSID(K) is nonzero. In this case let p and q be the !       integer parts of PTSID(K) and (PTSID(K)-p) multiplied by N+1. If p !       and q are both positive, the step from XBASE+XOPT to the new K-th !       interpolation point is PTSAUX(1,p)*e_p + PTSAUX(1,q)*e_q. Otherwise !       the step is PTSAUX(1,p)*e_p or PTSAUX(2,q)*e_q in the cases q=0 or !       p=0, respectively. !     The first NDIM+NPT elements of the array W are used for working space. !     The final elements of BMAT and ZMAT are set in a well-conditioned way !       to the values that are appropriate for the new interpolation points. !     The elements of GOPT, HQ and PQ are also revised to the values that are !       appropriate to the final quadratic model. ! !     Set some constants. ! half = 0.5_dbl one = 1.0_dbl zero = 0.0_dbl np = n + 1 sfrac = half / real ( np , dbl ) nptm = npt - np ! !     Shift the interpolation points so that XOPT becomes the origin, and set !     the elements of ZMAT to zero. The value of SUMPQ is required in the !     updating of HQ below. The squares of the distances from XOPT to the !     other interpolation points are set at the end of W. Increments of WINC !     may be added later to these squares to balance the consideration of !     the choice of point that is going to become current. ! sumpq = zero winc = zero do k = 1 , npt distsq = zero do j = 1 , n xpt ( k , j ) = xpt ( k , j ) - xopt ( j ) distsq = distsq + xpt ( k , j ) ** 2 end do sumpq = sumpq + pq ( k ) w ( ndim + k ) = distsq winc = max ( winc , distsq ) do j = 1 , nptm zmat ( k , j ) = zero end do end do ! !     Update HQ so that HQ and PQ define the second derivatives of the model !     after XBASE has been shifted to the trust region centre. ! ih = 0 do j = 1 , n w ( j ) = half * sumpq * xopt ( j ) do k = 1 , npt w ( j ) = w ( j ) + pq ( k ) * xpt ( k , j ) end do do i = 1 , j ih = ih + 1 hq ( ih ) = hq ( ih ) + w ( i ) * xopt ( j ) + w ( j ) * xopt ( i ) end do end do ! !     Shift XBASE, SL, SU and XOPT. Set the elements of BMAT to zero, and !     also set the elements of PTSAUX. ! do j = 1 , n xbase ( j ) = xbase ( j ) + xopt ( j ) sl ( j ) = sl ( j ) - xopt ( j ) su ( j ) = su ( j ) - xopt ( j ) xopt ( j ) = zero ptsaux ( 1 , j ) = min ( delta , su ( j )) ptsaux ( 2 , j ) = max ( - delta , sl ( j )) if ( ptsaux ( 1 , j ) + ptsaux ( 2 , j ) < zero ) then temp = ptsaux ( 1 , j ) ptsaux ( 1 , j ) = ptsaux ( 2 , j ) ptsaux ( 2 , j ) = temp end if if ( abs ( ptsaux ( 2 , j )) < half * abs ( ptsaux ( 1 , j ))) then ptsaux ( 2 , j ) = half * ptsaux ( 1 , j ) end if do i = 1 , ndim bmat ( i , j ) = zero end do end do fbase = fval ( kopt ) ! !     Set the identifiers of the artificial interpolation points that are !     along a coordinate direction from XOPT, and set the corresponding !     nonzero elements of BMAT and ZMAT. ! ptsid ( 1 ) = sfrac do j = 1 , n jp = j + 1 jpn = jp + n ptsid ( jp ) = real ( j , dbl ) + sfrac if ( jpn <= npt ) then ptsid ( jpn ) = real ( j , dbl ) / real ( np , dbl ) + sfrac temp = one / ( ptsaux ( 1 , j ) - ptsaux ( 2 , j )) bmat ( jp , j ) = - temp + one / ptsaux ( 1 , j ) bmat ( jpn , j ) = temp + one / ptsaux ( 2 , j ) bmat ( 1 , j ) = - bmat ( jp , j ) - bmat ( jpn , j ) zmat ( 1 , j ) = sqrt ( 2.0_dbl ) / abs ( ptsaux ( 1 , j ) * ptsaux ( 2 , j )) zmat ( jp , j ) = zmat ( 1 , j ) * ptsaux ( 2 , j ) * temp zmat ( jpn , j ) = - zmat ( 1 , j ) * ptsaux ( 1 , j ) * temp else bmat ( 1 , j ) = - one / ptsaux ( 1 , j ) bmat ( jp , j ) = one / ptsaux ( 1 , j ) bmat ( j + npt , j ) = - half * ptsaux ( 1 , j ) ** 2 end if end do ! !     Set any remaining identifiers with their nonzero elements of ZMAT. ! if ( npt >= n + np ) then do k = 2 * np , npt iw = ( real ( k - np , dbl ) - half ) / real ( n , dbl ) ip = k - np - iw * n iq = ip + iw if ( iq > n ) iq = iq - n ptsid ( k ) = real ( ip , dbl ) + real ( iq , dbl ) / real ( np , dbl ) + sfrac temp = one / ( ptsaux ( 1 , ip ) * ptsaux ( 1 , iq )) zmat ( 1 , k - np ) = temp zmat ( ip + 1 , k - np ) = - temp zmat ( iq + 1 , k - np ) = - temp zmat ( k , k - np ) = temp end do end if nrem = npt kold = 1 knew = kopt ! !     Reorder the provisional points in the way that exchanges PTSID(KOLD) !     with PTSID(KNEW). ! 80 do j = 1 , n temp = bmat ( kold , j ) bmat ( kold , j ) = bmat ( knew , j ) bmat ( knew , j ) = temp end do do j = 1 , nptm temp = zmat ( kold , j ) zmat ( kold , j ) = zmat ( knew , j ) zmat ( knew , j ) = temp end do ptsid ( kold ) = ptsid ( knew ) ptsid ( knew ) = zero w ( ndim + knew ) = zero nrem = nrem - 1 if ( knew /= kopt ) then temp = vlag ( kold ) vlag ( kold ) = vlag ( knew ) vlag ( knew ) = temp ! !     Update the BMAT and ZMAT matrices so that the status of the KNEW-th !     interpolation point can be changed from provisional to original. The !     subroutine returns if all the original points are reinstated. !     The nonnegative values of W(NDIM+K) are required in the search below. ! call update ( n , npt , bmat , zmat , ndim , vlag , beta , denom , knew , w ) if ( nrem == 0 ) return do k = 1 , npt w ( ndim + k ) = abs ( w ( ndim + k )) end do end if ! !     Pick the index KNEW of an original interpolation point that has not !     yet replaced one of the provisional interpolation points, giving !     attention to the closeness to XOPT and to previous tries with KNEW. ! 120 dsqmin = zero do k = 1 , npt if ( w ( ndim + k ) > zero ) then if ( dsqmin == zero . or . w ( ndim + k ) < dsqmin ) then knew = k dsqmin = w ( ndim + k ) end if end if end do if ( dsqmin == zero ) go to 260 ! !     Form the W-vector of the chosen original interpolation point. ! do j = 1 , n w ( npt + j ) = xpt ( knew , j ) end do do k = 1 , npt sum = zero if ( k == kopt ) then continue else if ( ptsid ( k ) == zero ) then do j = 1 , n sum = sum + w ( npt + j ) * xpt ( k , j ) end do else ip = ptsid ( k ) if ( ip > 0 ) sum = w ( npt + ip ) * ptsaux ( 1 , ip ) iq = real ( np , dbl ) * ptsid ( k ) - real ( ip * np , dbl ) if ( iq > 0 ) then iw = 1 if ( ip == 0 ) iw = 2 sum = sum + w ( npt + iq ) * ptsaux ( iw , iq ) end if end if w ( k ) = half * sum * sum end do ! !     Calculate VLAG and BETA for the required updating of the H matrix if !     XPT(KNEW,.) is reinstated in the set of interpolation points. ! do k = 1 , npt sum = zero do j = 1 , n sum = sum + bmat ( k , j ) * w ( npt + j ) end do vlag ( k ) = sum end do beta = zero do j = 1 , nptm sum = zero do k = 1 , npt sum = sum + zmat ( k , j ) * w ( k ) end do beta = beta - sum * sum do k = 1 , npt vlag ( k ) = vlag ( k ) + sum * zmat ( k , j ) end do end do bsum = zero distsq = zero do j = 1 , n sum = zero do k = 1 , npt sum = sum + bmat ( k , j ) * w ( k ) end do jp = j + npt bsum = bsum + sum * w ( jp ) do ip = npt + 1 , ndim sum = sum + bmat ( ip , j ) * w ( ip ) end do bsum = bsum + sum * w ( jp ) vlag ( jp ) = sum distsq = distsq + xpt ( knew , j ) ** 2 end do beta = half * distsq * distsq + beta - bsum vlag ( kopt ) = vlag ( kopt ) + one ! !     KOLD is set to the index of the provisional interpolation point that is !     going to be deleted to make way for the KNEW-th original interpolation !     point. The choice of KOLD is governed by the avoidance of a small value !     of the denominator in the updating calculation of UPDATE. ! denom = zero vlmxsq = zero do k = 1 , npt if ( ptsid ( k ) /= zero ) then hdiag = zero do j = 1 , nptm hdiag = hdiag + zmat ( k , j ) ** 2 end do den = beta * hdiag + vlag ( k ) ** 2 if ( den > denom ) then kold = k denom = den end if end if vlmxsq = max ( vlmxsq , vlag ( k ) ** 2 ) end do if ( denom <= 1.0e-2_dbl * vlmxsq ) then w ( ndim + knew ) = - w ( ndim + knew ) - winc go to 120 end if go to 80 ! !     When label 260 is reached, all the final positions of the interpolation !     points have been chosen although any changes have not been included yet !     in XPT. Also the final BMAT and ZMAT matrices are complete, but, apart !     from the shift of XBASE, the updating of the quadratic model remains to !     be done. The following cycle through the new interpolation points begins !     by putting the new point in XPT(KPT,.) and by setting PQ(KPT) to zero, !     except that a RETURN occurs if MAXFUN prohibits another value of F. ! 260 do kpt = 1 , npt if ( ptsid ( kpt ) == zero ) cycle if ( nf >= maxfun ) then nf = - 1 return end if ih = 0 do j = 1 , n w ( j ) = xpt ( kpt , j ) xpt ( kpt , j ) = zero temp = pq ( kpt ) * w ( j ) do i = 1 , j ih = ih + 1 hq ( ih ) = hq ( ih ) + temp * w ( i ) end do end do pq ( kpt ) = zero ip = ptsid ( kpt ) iq = real ( np , dbl ) * ptsid ( kpt ) - real ( ip * np , dbl ) if ( ip > 0 ) then xp = ptsaux ( 1 , ip ) xpt ( kpt , ip ) = xp end if if ( iq > 0 ) then xq = ptsaux ( 1 , iq ) if ( ip == 0 ) xq = ptsaux ( 2 , iq ) xpt ( kpt , iq ) = xq end if ! !     Set VQUAD to the value of the current model at the new point. ! vquad = fbase if ( ip > 0 ) then ihp = ( ip + ip * ip ) / 2 vquad = vquad + xp * ( gopt ( ip ) + half * xp * hq ( ihp )) end if if ( iq > 0 ) then ihq = ( iq + iq * iq ) / 2 vquad = vquad + xq * ( gopt ( iq ) + half * xq * hq ( ihq )) if ( ip > 0 ) then iw = max ( ihp , ihq ) - abs ( ip - iq ) vquad = vquad + xp * xq * hq ( iw ) end if end if do k = 1 , npt temp = zero if ( ip > 0 ) temp = temp + xp * xpt ( k , ip ) if ( iq > 0 ) temp = temp + xq * xpt ( k , iq ) vquad = vquad + half * pq ( k ) * temp * temp end do ! !     Calculate F at the new interpolation point, and set DIFF to the factor !     that is going to multiply the KPT-th Lagrange function when the model !     is updated to provide interpolation to the new function value. ! do i = 1 , n w ( i ) = min ( max ( xl ( i ), xbase ( i ) + xpt ( kpt , i )), xu ( i )) if ( xpt ( kpt , i ) == sl ( i )) w ( i ) = xl ( i ) if ( xpt ( kpt , i ) == su ( i )) w ( i ) = xu ( i ) end do nf = nf + 1 !======================================================================================= !============changed function call depending on how many call have been made============ !======================================================================================= if ( present ( verbose )) then call calfun ( ipar , initmeanval , expt1 , accum , mLPNH , mLPSH , & n , w ( 1 : n ), f , mask , prefactor , rgx , rgy , rgz , stepsize , verbose = verbose ) else call calfun ( ipar , initmeanval , expt1 , accum , mLPNH , mLPSH , & n , w ( 1 : n ), f , mask , prefactor , rgx , rgy , rgz , stepsize ) end if if ( iprint == 3 ) then print 300 , nf , f , ( w ( i ), i = 1 , n ) 300 format ( / 4 x , 'Function number' , i6 , '    F =' , 1 pd18 . 10 ,& '    The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if fval ( kpt ) = f if ( f < fval ( kopt )) kopt = kpt diff = f - vquad ! !     Update the quadratic model. The RETURN from the subroutine occurs when !     all the new interpolation points are included in the model. ! do i = 1 , n gopt ( i ) = gopt ( i ) + diff * bmat ( kpt , i ) end do do k = 1 , npt sum = zero do j = 1 , nptm sum = sum + zmat ( k , j ) * zmat ( kpt , j ) end do temp = diff * sum if ( ptsid ( k ) == zero ) then pq ( k ) = pq ( k ) + temp else ip = ptsid ( k ) iq = real ( np , dbl ) * ptsid ( k ) - real ( ip * np , dbl ) ihq = ( iq * iq + iq ) / 2 if ( ip == 0 ) then hq ( ihq ) = hq ( ihq ) + temp * ptsaux ( 2 , iq ) ** 2 else ihp = ( ip * ip + ip ) / 2 hq ( ihp ) = hq ( ihp ) + temp * ptsaux ( 1 , ip ) ** 2 if ( iq > 0 ) then hq ( ihq ) = hq ( ihq ) + temp * ptsaux ( 1 , iq ) ** 2 iw = max ( ihp , ihq ) - abs ( iq - ip ) hq ( iw ) = hq ( iw ) + temp * ptsaux ( 1 , ip ) * ptsaux ( 1 , iq ) end if end if end if end do ptsid ( kpt ) = zero end do end subroutine rescue recursive subroutine trsbox ( n , npt , xpt , xopt , gopt , hq , pq , sl , su , delta , xnew , d , gnew , & & xbdi , s , hs , hred , dsq , crvmin ) !DEC$ ATTRIBUTES DLLEXPORT :: trsbox implicit real ( dbl ) ( a - h , o - z ) dimension xpt ( npt , * ), xopt ( * ), gopt ( * ), hq ( * ), pq ( * ), sl ( * ), su ( * ), xnew & & ( * ), d ( * ), gnew ( * ), xbdi ( * ), s ( * ), hs ( * ), hred ( * ) ! !     The arguments N, NPT, XPT, XOPT, GOPT, HQ, PQ, SL and SU have the same !       meanings as the corresponding arguments of BOBYQB. !     DELTA is the trust region radius for the present calculation, which !       seeks a small value of the quadratic model within distance DELTA of !       XOPT subject to the bounds on the variables. !     XNEW will be set to a new vector of variables that is approximately !       the one that minimizes the quadratic model within the trust region !       subject to the SL and SU constraints on the variables. It satisfies !       as equations the bounds that become active during the calculation. !     D is the calculated trial step from XOPT, generated iteratively from an !       initial value of zero. Thus XNEW is XOPT+D after the final iteration. !     GNEW holds the gradient of the quadratic model at XOPT+D. It is updated !       when D is updated. !     XBDI is a working space vector. For I=1,2,...,N, the element XBDI(I) is !       set to -1.0, 0.0, or 1.0, the value being nonzero if and only if the !       I-th variable has become fixed at a bound, the bound being SL(I) or !       SU(I) in the case XBDI(I)=-1.0 or XBDI(I)=1.0, respectively. This !       information is accumulated during the construction of XNEW. !     The arrays S, HS and HRED are also used for working space. They hold the !       current search direction, and the changes in the gradient of Q along S !       and the reduced D, respectively, where the reduced D is the same as D, !       except that the components of the fixed variables are zero. !     DSQ will be set to the square of the length of XNEW-XOPT. !     CRVMIN is set to zero if D reaches the trust region boundary. Otherwise !       it is set to the least curvature of H that occurs in the conjugate !       gradient searches that are not restricted by any constraints. The !       value CRVMIN=-1.0D0 is set, however, if all of these searches are !       constrained. ! !     A version of the truncated conjugate gradient is applied. If a line !     search is restricted by a constraint, then the procedure is restarted, !     the values of the variables that are at their bounds being fixed. If !     the trust region boundary is reached, then further changes may be made !     to D, each one being in the two dimensional space that is spanned !     by the current D and the gradient of Q at XOPT+D, staying on the trust !     region boundary. Termination occurs when the reduction in Q seems to !     be close to the greatest reduction that can be achieved. ! !     Set some constants. ! half = 0.5_dbl one = 1.0_dbl onemin = - 1.0_dbl zero = 0.0_dbl ! !     The sign of GOPT(I) gives the sign of the change to the I-th variable !     that will reduce Q from its value at XOPT. Thus XBDI(I) shows whether !     or not to fix the I-th variable at one of its bounds initially, with !     NACT being set to the number of fixed variables. D and GNEW are also !     set for the first iteration. DELSQ is the upper bound on the sum of !     squares of the free variables. QRED is the reduction in Q so far. ! iterc = 0 nact = 0 sqstp = zero do i = 1 , n xbdi ( i ) = zero if ( xopt ( i ) <= sl ( i )) then if ( gopt ( i ) >= zero ) xbdi ( i ) = onemin else if ( xopt ( i ) >= su ( i )) then if ( gopt ( i ) <= zero ) xbdi ( i ) = one end if if ( xbdi ( i ) /= zero ) nact = nact + 1 d ( i ) = zero gnew ( i ) = gopt ( i ) end do delsq = delta * delta qred = zero crvmin = onemin ! !     Set the next search direction of the conjugate gradient method. It is !     the steepest descent direction initially and when the iterations are !     restarted because a variable has just been fixed by a bound, and of !     course the components of the fixed variables are zero. ITERMAX is an !     upper bound on the indices of the conjugate gradient iterations. ! 20 beta = zero 30 stepsq = zero do i = 1 , n if ( xbdi ( i ) /= zero ) then s ( i ) = zero else if ( beta == zero ) then s ( i ) = - gnew ( i ) else s ( i ) = beta * s ( i ) - gnew ( i ) end if stepsq = stepsq + s ( i ) ** 2 end do if ( stepsq == zero ) go to 190 if ( beta == zero ) then gredsq = stepsq itermax = iterc + n - nact end if if ( gredsq * delsq <= 1.0e-4_dbl * qred * qred ) go to 190 ! !     Multiply the search direction by the second derivative matrix of Q and !     calculate some scalars for the choice of steplength. Then set BLEN to !     the length of the the step to the trust region boundary and STPLEN to !     the steplength, ignoring the simple bounds. ! go to 210 50 resid = delsq ds = zero shs = zero do i = 1 , n if ( xbdi ( i ) == zero ) then resid = resid - d ( i ) ** 2 ds = ds + s ( i ) * d ( i ) shs = shs + s ( i ) * hs ( i ) end if end do if ( resid <= zero ) go to 90 temp = sqrt ( stepsq * resid + ds * ds ) if ( ds < zero ) then blen = ( temp - ds ) / stepsq else blen = resid / ( temp + ds ) end if stplen = blen if ( shs > zero ) then stplen = min ( blen , gredsq / shs ) end if ! ! !     Reduce STPLEN if necessary in order to preserve the simple bounds, !     letting IACT be the index of the new constrained variable. ! iact = 0 do i = 1 , n if ( s ( i ) /= zero ) then xsum = xopt ( i ) + d ( i ) if ( s ( i ) > zero ) then temp = ( su ( i ) - xsum ) / s ( i ) else temp = ( sl ( i ) - xsum ) / s ( i ) end if if ( temp < stplen ) then stplen = temp iact = i end if end if end do ! !     Update CRVMIN, GNEW and D. Set SDEC to the decrease that occurs in Q. ! sdec = zero if ( stplen > zero ) then iterc = iterc + 1 temp = shs / stepsq if ( iact == 0 . and . temp > zero ) then crvmin = min ( crvmin , temp ) if ( crvmin == onemin ) crvmin = temp end if ggsav = gredsq gredsq = zero do i = 1 , n gnew ( i ) = gnew ( i ) + stplen * hs ( i ) if ( xbdi ( i ) == zero ) gredsq = gredsq + gnew ( i ) ** 2 d ( i ) = d ( i ) + stplen * s ( i ) end do sdec = max ( stplen * ( ggsav - half * stplen * shs ), zero ) qred = qred + sdec end if ! !     Restart the conjugate gradient method if it has hit a new bound. ! if ( iact > 0 ) then nact = nact + 1 xbdi ( iact ) = one if ( s ( iact ) < zero ) xbdi ( iact ) = onemin delsq = delsq - d ( iact ) ** 2 if ( delsq <= zero ) go to 90 go to 20 end if ! !     If STPLEN is less than BLEN, then either apply another conjugate !     gradient iteration or RETURN. ! if ( stplen < blen ) then if ( iterc == itermax ) go to 190 if ( sdec <= 0.01_dbl * qred ) go to 190 beta = gredsq / ggsav go to 30 end if 90 crvmin = zero ! !     Prepare for the alternative iteration by calculating some scalars and !     by multiplying the reduced D by the second derivative matrix of Q. ! 100 if ( nact >= n - 1 ) go to 190 dredsq = zero dredg = zero gredsq = zero do i = 1 , n if ( xbdi ( i ) == zero ) then dredsq = dredsq + d ( i ) ** 2 dredg = dredg + d ( i ) * gnew ( i ) gredsq = gredsq + gnew ( i ) ** 2 s ( i ) = d ( i ) else s ( i ) = zero end if end do itcsav = iterc go to 210 ! !     Let the search direction S be a linear combination of the reduced D !     and the reduced G that is orthogonal to the reduced D. ! 120 iterc = iterc + 1 temp = gredsq * dredsq - dredg * dredg if ( temp <= 1.0e-4_dbl * qred * qred ) go to 190 temp = sqrt ( temp ) do i = 1 , n if ( xbdi ( i ) == zero ) then s ( i ) = ( dredg * d ( i ) - dredsq * gnew ( i )) / temp else s ( i ) = zero end if end do sredg = - temp ! !     By considering the simple bounds on the variables, calculate an upper !     bound on the tangent of half the angle of the alternative iteration, !     namely ANGBD, except that, if already a free variable has reached a !     bound, there is a branch back to label 100 after fixing that variable. ! angbd = one iact = 0 do i = 1 , n if ( xbdi ( i ) == zero ) then tempa = xopt ( i ) + d ( i ) - sl ( i ) tempb = su ( i ) - xopt ( i ) - d ( i ) if ( tempa <= zero ) then nact = nact + 1 xbdi ( i ) = onemin go to 100 else if ( tempb <= zero ) then nact = nact + 1 xbdi ( i ) = one go to 100 end if ratio = one ssq = d ( i ) ** 2 + s ( i ) ** 2 temp = ssq - ( xopt ( i ) - sl ( i )) ** 2 if ( temp > zero ) then temp = sqrt ( temp ) - s ( i ) if ( angbd * temp > tempa ) then angbd = tempa / temp iact = i xsav = onemin end if end if temp = ssq - ( su ( i ) - xopt ( i )) ** 2 if ( temp > zero ) then temp = sqrt ( temp ) + s ( i ) if ( angbd * temp > tempb ) then angbd = tempb / temp iact = i xsav = one end if end if end if end do ! !     Calculate HHD and some curvatures for the alternative iteration. ! go to 210 150 shs = zero dhs = zero dhd = zero do i = 1 , n if ( xbdi ( i ) == zero ) then shs = shs + s ( i ) * hs ( i ) dhs = dhs + d ( i ) * hs ( i ) dhd = dhd + d ( i ) * hred ( i ) end if end do ! !     Seek the greatest reduction in Q for a range of equally spaced values !     of ANGT in [0,ANGBD], where ANGT is the tangent of half the angle of !     the alternative iteration. ! redmax = zero isav = 0 redsav = zero iu = 1 7.0_dbl * angbd + 3.1_dbl do i = 1 , iu angt = angbd * real ( i , dbl ) / real ( iu , dbl ) sth = ( angt + angt ) / ( one + angt * angt ) temp = shs + angt * ( angt * dhd - dhs - dhs ) rednew = sth * ( angt * dredg - sredg - half * sth * temp ) if ( rednew > redmax ) then redmax = rednew isav = i rdprev = redsav else if ( i == isav + 1 ) then rdnext = rednew end if redsav = rednew end do ! !     Return if the reduction is zero. Otherwise, set the sine and cosine !     of the angle of the alternative iteration, and calculate SDEC. ! if ( isav == 0 ) go to 190 if ( isav < iu ) then temp = ( rdnext - rdprev ) / ( redmax + redmax - rdprev - rdnext ) angt = angbd * ( real ( isav , dbl ) + half * temp ) / real ( iu , dbl ) end if cth = ( one - angt * angt ) / ( one + angt * angt ) sth = ( angt + angt ) / ( one + angt * angt ) temp = shs + angt * ( angt * dhd - dhs - dhs ) sdec = sth * ( angt * dredg - sredg - half * sth * temp ) if ( sdec <= zero ) go to 190 ! !     Update GNEW, D and HRED. If the angle of the alternative iteration !     is restricted by a bound on a free variable, that variable is fixed !     at the bound. ! dredg = zero gredsq = zero do i = 1 , n gnew ( i ) = gnew ( i ) + ( cth - one ) * hred ( i ) + sth * hs ( i ) if ( xbdi ( i ) == zero ) then d ( i ) = cth * d ( i ) + sth * s ( i ) dredg = dredg + d ( i ) * gnew ( i ) gredsq = gredsq + gnew ( i ) ** 2 end if hred ( i ) = cth * hred ( i ) + sth * hs ( i ) end do qred = qred + sdec if ( iact > 0 . and . isav == iu ) then nact = nact + 1 xbdi ( iact ) = xsav go to 100 end if ! !     If SDEC is sufficiently small, then RETURN after setting XNEW to !     XOPT+D, giving careful attention to the bounds. ! if ( sdec > 0.01_dbl * qred ) go to 120 190 dsq = zero do i = 1 , n xnew ( i ) = max ( min ( xopt ( i ) + d ( i ), su ( i )), sl ( i )) if ( xbdi ( i ) == onemin ) xnew ( i ) = sl ( i ) if ( xbdi ( i ) == one ) xnew ( i ) = su ( i ) d ( i ) = xnew ( i ) - xopt ( i ) dsq = dsq + d ( i ) ** 2 end do return ! !     The following instructions multiply the current S-vector by the second !     derivative matrix of the quadratic model, putting the product in HS. !     They are reached from three different parts of the software above and !     they can be regarded as an external subroutine. ! 210 ih = 0 do j = 1 , n hs ( j ) = zero do i = 1 , j ih = ih + 1 if ( i < j ) hs ( j ) = hs ( j ) + hq ( ih ) * s ( i ) hs ( i ) = hs ( i ) + hq ( ih ) * s ( j ) end do end do do k = 1 , npt if ( pq ( k ) /= zero ) then temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * s ( j ) end do temp = temp * pq ( k ) do i = 1 , n hs ( i ) = hs ( i ) + temp * xpt ( k , i ) end do end if end do if ( crvmin /= zero ) go to 50 if ( iterc > itcsav ) go to 150 do i = 1 , n hred ( i ) = hs ( i ) end do go to 120 end subroutine trsbox recursive subroutine update ( n , npt , bmat , zmat , ndim , vlag , beta , denom , knew , w ) !DEC$ ATTRIBUTES DLLEXPORT :: update implicit real ( dbl ) ( a - h , o - z ) dimension bmat ( ndim , * ), zmat ( npt , * ), vlag ( * ), w ( * ) ! !     The arrays BMAT and ZMAT are updated, as required by the new position !     of the interpolation point that has the index KNEW. The vector VLAG has !     N+NPT components, set on entry to the first NPT and last N components !     of the product Hw in equation (4.11) of the Powell (2006) paper on !     NEWUOA. Further, BETA is set on entry to the value of the parameter !     with that name, and DENOM is set to the denominator of the updating !     formula. Elements of ZMAT may be treated as zero if their moduli are !     at most ZTEST. The first NDIM elements of W are used for working space. ! !     Set some constants. ! one = 1.0_dbl zero = 0.0_dbl nptm = npt - n - 1 ztest = zero do k = 1 , npt do j = 1 , nptm ztest = max ( ztest , abs ( zmat ( k , j ))) end do end do ztest = 1.0e-20_dbl * ztest ! !     Apply the rotations that put zeros in the KNEW-th row of ZMAT. ! jl = 1 do j = 2 , nptm if ( abs ( zmat ( knew , j )) > ztest ) then temp = sqrt ( zmat ( knew , 1 ) ** 2 + zmat ( knew , j ) ** 2 ) tempa = zmat ( knew , 1 ) / temp tempb = zmat ( knew , j ) / temp do i = 1 , npt temp = tempa * zmat ( i , 1 ) + tempb * zmat ( i , j ) zmat ( i , j ) = tempa * zmat ( i , j ) - tempb * zmat ( i , 1 ) zmat ( i , 1 ) = temp end do end if zmat ( knew , j ) = zero end do ! !     Put the first NPT components of the KNEW-th column of HLAG into W, !     and calculate the parameters of the updating formula. ! do i = 1 , npt w ( i ) = zmat ( knew , 1 ) * zmat ( i , 1 ) end do alpha = w ( knew ) tau = vlag ( knew ) vlag ( knew ) = vlag ( knew ) - one ! !     Complete the updating of ZMAT. ! temp = sqrt ( denom ) tempb = zmat ( knew , 1 ) / temp tempa = tau / temp do i = 1 , npt zmat ( i , 1 ) = tempa * zmat ( i , 1 ) - tempb * vlag ( i ) end do ! !     Finally, update the matrix BMAT. ! do j = 1 , n jp = npt + j w ( jp ) = bmat ( knew , j ) tempa = ( alpha * vlag ( jp ) - tau * w ( jp )) / denom tempb = ( - beta * w ( jp ) - tau * vlag ( jp )) / denom do i = 1 , jp bmat ( i , j ) = bmat ( i , j ) + tempa * vlag ( i ) + tempb * w ( i ) if ( i > npt ) bmat ( jp , i - npt ) = bmat ( i , j ) end do end do end subroutine update !***************************************************************************************** end module bobyqa_refinement !*****************************************************************************************","tags":"","loc":"sourcefile/bobyqa_refinement.f90.html","title":"bobyqa_refinement.f90 – Fortran Program"},{"text":"Files Dependent On This One sourcefile~~clsupport.f90~~AfferentGraph sourcefile~clsupport.f90 CLsupport.f90 sourcefile~emdymod.f90 EMdymod.f90 sourcefile~clsupport.f90->sourcefile~emdymod.f90 sourcefile~indexingmod.f90 Indexingmod.f90 sourcefile~clsupport.f90->sourcefile~indexingmod.f90 sourcefile~simulated_annealing.f90 simulated_annealing.f90 sourcefile~emdymod.f90->sourcefile~simulated_annealing.f90 sourcefile~indexingmod.f90->sourcefile~emdymod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules CLsupport Source Code CLsupport.f90 Source Code ! ################################################################### ! Copyright (c) 2013-2016, Marc De Graef Research Group/Carnegie Mellon University ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without modification, are ! permitted provided that the following conditions are met: ! !     - Redistributions of source code must retain the above copyright notice, this list !        of conditions and the following disclaimer. !     - Redistributions in binary form must reproduce the above copyright notice, this !        list of conditions and the following disclaimer in the documentation and/or !        other materials provided with the distribution. !     - Neither the names of Marc De Graef, Carnegie Mellon University nor the names !        of its contributors may be used to endorse or promote products derived from !        this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE ! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ################################################################### module CLsupport use local use clfortran IMPLICIT NONE contains !-------------------------------------------------------------------------- ! ! SUBROUTINE:CLquery_platform_info ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief display information about an OpenCL device (based on (clfortran's query_platforms_devices.f90) ! !> @param platform_id id number of platform ! !> @date 02/18/16 MDG 1.0 modification of clfortran's original routine !> @date 05/21/16 MDG 1.1 split CPU and GPU device information into separate blocks !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- ! original Copyright information (clfortran's query_platforms_devices.f90) ! ----------------------------------------------------------------------------- ! ! Copyright (C) 2013-2014 Company for Advanced Supercomputing Solutions LTD ! Bosmat 2a St. ! Shoham ! Israel 60850 ! http://www.cass-hpc.com ! ! Author: Mordechai Butrashvily <support@cass-hpc.com> ! ! ----------------------------------------------------------------------------- ! ! This program is free software: you can redistribute it and/or modify ! it under the terms of the GNU Lesser General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! This program is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU Lesser General Public License for more details. ! ! You should have received a copy of the GNU Lesser General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! ! ----------------------------------------------------------------------------- recursive subroutine CLquery_platform_info ( platform_id ) !DEC$ ATTRIBUTES DLLEXPORT :: CLquery_platform_info use ISO_C_BINDING IMPLICIT NONE ! Input variable. integer ( c_intptr_t ), INTENT ( IN ) :: platform_id ! Helper variables to work with OpenCL API. integer ( c_int32_t ) :: err integer ( c_size_t ) :: zero_size = 0 integer ( c_size_t ) :: temp_size ! For quering devices. integer ( c_int64_t ) :: device_type integer ( c_int32_t ) :: num_devices integer ( c_int ) :: i integer ( c_intptr_t ), allocatable , target :: device_ids (:) ! String arrays for holding platform details. character , allocatable , target :: platform_profile (:) character , allocatable , target :: platform_version (:) character , allocatable , target :: platform_name (:) character , allocatable , target :: platform_vendor (:) character , allocatable , target :: platform_extensions (:) ! String array for holding device name. character , allocatable , target :: device_name (:) ! Maximum compute units for device. integer ( c_size_t ), target :: device_mwgs , device_mwis ( 3 ) integer ( c_int32_t ), target :: device_cu integer ( c_int64_t ), target :: device_gms , device_mmas ! Profile. err = clGetPlatformInfo ( platform_id , CL_PLATFORM_PROFILE , zero_size , C_NULL_PTR , temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetPlatformInfo' , err ) allocate ( platform_profile ( temp_size )) err = clGetPlatformInfo ( platform_id , CL_PLATFORM_PROFILE , temp_size , C_LOC ( platform_profile ), temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetPlatformInfo' , err ) print * , 'Profile: ' , platform_profile deallocate ( platform_profile ) ! Version. err = clGetPlatformInfo ( platform_id , CL_PLATFORM_VERSION , zero_size , C_NULL_PTR , temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetPlatformInfo' , err ) allocate ( platform_version ( temp_size )) err = clGetPlatformInfo ( platform_id , CL_PLATFORM_VERSION , temp_size , C_LOC ( platform_version ), temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetPlatformInfo' , err ) print * , 'Version: ' , platform_version deallocate ( platform_version ) ! Name. err = clGetPlatformInfo ( platform_id , CL_PLATFORM_NAME , zero_size , C_NULL_PTR , temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetPlatformInfo' , err ) allocate ( platform_name ( temp_size )) err = clGetPlatformInfo ( platform_id , CL_PLATFORM_NAME , temp_size , C_LOC ( platform_name ), temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetPlatformInfo' , err ) print * , 'Name: ' , platform_name deallocate ( platform_name ) ! Vendor. err = clGetPlatformInfo ( platform_id , CL_PLATFORM_VENDOR , zero_size , C_NULL_PTR , temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetPlatformInfo' , err ) allocate ( platform_vendor ( temp_size )) err = clGetPlatformInfo ( platform_id , CL_PLATFORM_VENDOR , temp_size , C_LOC ( platform_vendor ), temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetPlatformInfo' , err ) print * , 'Vendor: ' , platform_vendor deallocate ( platform_vendor ) ! Extensions. err = clGetPlatformInfo ( platform_id , CL_PLATFORM_EXTENSIONS , zero_size , C_NULL_PTR , temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetPlatformInfo' , err ) allocate ( platform_extensions ( temp_size )) err = clGetPlatformInfo ( platform_id , CL_PLATFORM_EXTENSIONS , temp_size , C_LOC ( platform_extensions ), temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetPlatformInfo' , err ) print * , 'Extensions: ' , platform_extensions deallocate ( platform_extensions ) ! ! Print device information for this platform. ! ! Get device count. print * ! device_type = CL_DEVICE_TYPE_CPU err = clGetDeviceIDs ( platform_id , CL_DEVICE_TYPE_CPU , 0 , C_NULL_PTR , num_devices ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceIDs' , err ,. TRUE .) if ( err /= CL_SUCCESS . or . num_devices < 1 ) then print * , 'No CPU devices found on this platform' else print * print '(A, I2)' , 'Num CPU Devices: ' , num_devices ! Allocate an array to hold device handles. allocate ( device_ids ( num_devices )) ! Get device IDs. err = clGetDeviceIDs ( platform_id , CL_DEVICE_TYPE_CPU , num_devices , C_LOC ( device_ids ), num_devices ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceIDs' , err ) if ( err /= CL_SUCCESS ) then print * , 'Error quering CPU devices: ' , err return end if ! Loop over devices and print information. do i = 1 , num_devices ! Maximum compute units. temp_size = 8 err = clGetDeviceInfo ( device_ids ( i ), CL_DEVICE_MAX_COMPUTE_UNITS , temp_size , C_LOC ( device_cu ), temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceInfo' , err ) temp_size = 8 err = clGetDeviceInfo ( device_ids ( i ), CL_DEVICE_GLOBAL_MEM_SIZE , temp_size , C_LOC ( device_gms ), temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceInfo' , err ) device_gms = device_gms / 1024 / 1024 / 1024 ! temp_size = 8 ! err = clGetDeviceInfo(device_ids(i), CL_DEVICE_MAX_MEM_ALLOC_SIZE, temp_size, C_LOC(device_gms), temp_size) !write (*,*) 'mmas : ', device_mmas ! CL_DEVICE_MAX_WORK_GROUP_SIZE temp_size = 8 err = clGetDeviceInfo ( device_ids ( i ), CL_DEVICE_MAX_WORK_GROUP_SIZE , temp_size , C_LOC ( device_mwgs ), temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceInfo' , err ) ! CL_DEVICE_MAX_WORK_ITEM_SIZES temp_size = 8 * 3 err = clGetDeviceInfo ( device_ids ( i ), CL_DEVICE_MAX_WORK_ITEM_SIZES , temp_size , C_LOC ( device_mwis ), temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceInfo' , err ) ! Name. temp_size = 4 err = clGetDeviceInfo ( device_ids ( i ), CL_DEVICE_NAME , zero_size , C_NULL_PTR , temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceInfo' , err ) allocate ( device_name ( temp_size )) err = clGetDeviceInfo ( device_ids ( i ), CL_DEVICE_NAME , temp_size , C_LOC ( device_name ), temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceInfo' , err ) ! Print brief device details. Since this routine can be used by the user to determine GPU device IDs, ! we subtract 1 from the device ID to make sure that the CPU gets number 0... write ( * , '(A,I2,A,I4,A,I4,A,I4,A,I4,A,I4,A,I3,A,$)' ) ' Device (#' , i , ', CU/MWGS/MWIS/GMS: ' , device_cu , '/' , device_mwgs , '/' ,& device_mwis ( 1 ), ',' , device_mwis ( 2 ), ',' , device_mwis ( 3 ), '/' , device_gms , ') - ' print * , device_name deallocate ( device_name ) end do end if ! Get device count. !device_type = CL_DEVICE_TYPE_ALL print * err = clGetDeviceIDs ( platform_id , CL_DEVICE_TYPE_GPU , 0 , C_NULL_PTR , num_devices ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceIDs' , err ,. TRUE .) if ( err /= CL_SUCCESS . or . num_devices < 1 ) then print * , 'No GPU devices found on this platform ' else print * print '(A, I2)' , 'Num GPU Devices: ' , num_devices ! Allocate an array to hold device handles. if ( allocated ( device_ids )) deallocate ( device_ids ) allocate ( device_ids ( num_devices )) ! Get device IDs. err = clGetDeviceIDs ( platform_id , CL_DEVICE_TYPE_GPU , num_devices , C_LOC ( device_ids ), num_devices ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceIDs' , err ) if ( err /= CL_SUCCESS ) then print * , 'Error quering devices: ' , err return end if ! Loop over devices and print information. do i = 1 , num_devices ! Maximum compute units. temp_size = 8 err = clGetDeviceInfo ( device_ids ( i ), CL_DEVICE_MAX_COMPUTE_UNITS , temp_size , C_LOC ( device_cu ), temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceInfo' , err ) temp_size = 8 err = clGetDeviceInfo ( device_ids ( i ), CL_DEVICE_GLOBAL_MEM_SIZE , temp_size , C_LOC ( device_gms ), temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceInfo' , err ) device_gms = device_gms / 1024 / 1024 / 1024 ! temp_size = 8 ! err = clGetDeviceInfo(device_ids(i), CL_DEVICE_MAX_MEM_ALLOC_SIZE, temp_size, C_LOC(device_gms), temp_size) !write (*,*) 'mmas : ', device_mmas ! CL_DEVICE_MAX_WORK_GROUP_SIZE temp_size = 8 err = clGetDeviceInfo ( device_ids ( i ), CL_DEVICE_MAX_WORK_GROUP_SIZE , temp_size , C_LOC ( device_mwgs ), temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceInfo' , err ) ! CL_DEVICE_MAX_WORK_ITEM_SIZES temp_size = 8 * 3 err = clGetDeviceInfo ( device_ids ( i ), CL_DEVICE_MAX_WORK_ITEM_SIZES , temp_size , C_LOC ( device_mwis ), temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceInfo' , err ) ! Name. temp_size = 4 err = clGetDeviceInfo ( device_ids ( i ), CL_DEVICE_NAME , zero_size , C_NULL_PTR , temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceInfo' , err ) allocate ( device_name ( temp_size )) err = clGetDeviceInfo ( device_ids ( i ), CL_DEVICE_NAME , temp_size , C_LOC ( device_name ), temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceInfo' , err ) ! Print brief device details. Since this routine can be used by the user to determine GPU device IDs, ! we subtract 1 from the device ID to make sure that the CPU gets number 0... write ( * , '(A,I2,A,I4,A,I4,A,I4,A,I4,A,I4,A,I3,A,$)' ) ' Device (#' , i , ', CU/MWGS/MWIS/GMS: ' , device_cu , '/' , device_mwgs , '/' ,& device_mwis ( 1 ), ',' , device_mwis ( 2 ), ',' , device_mwis ( 3 ), '/' , device_gms , ') - ' print * , device_name deallocate ( device_name ) end do end if print * , ' ' write ( * , * ) '[CU = Compute Units; MWGS = Maximum Work Group Size; MWIS = Maximum Work Item Sizes (3D); ' // & 'GMS = Global Memory Size (Gb)]' end subroutine CLquery_platform_info !-------------------------------------------------------------------------- ! ! SUBROUTINE:CLread_source_file ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read an OpenCL source file and return the source properly formatted ! !> @param sourcefile filename for the OpenCL source code !> @param source c_str containing the source, NULL-terminated !> @param slength source string length ! !> @date 02/18/16  MDG 1.0 original !> @date 01/15/17  MDG 1.1 added functionality for second opencl folder for developers... !-------------------------------------------------------------------------- recursive subroutine CLread_source_file ( sourcefile , csource , slength ) !DEC$ ATTRIBUTES DLLEXPORT :: CLread_source_file use local use error use ISO_C_BINDING IMPLICIT NONE integer , parameter :: source_length = 50000 character ( fnlen ), INTENT ( IN ) :: sourcefile character ( len = source_length , KIND = c_char ), INTENT ( OUT ) :: csource integer ( c_size_t ), INTENT ( OUT ) :: slength character ( len = source_length ), target :: source character ( fnlen ) :: fname , clpath , clpath2 , tcf integer ( kind = irg ) :: irec , ierr , ipos , i , j logical :: develop , fexist ! find the cl file in the main opencl folder or the private folder if the Develop mode equals Yes... clpath = trim ( EMsoft_getOpenCLpathname ()) ! then, determine whether or not the user is working in develop mode by checking for the ! Develop keyword in the EMsoftconfig.json file... Regular users will only have a single ! opencl folder, but developers have two, so we need to make sure we check both ! locations.  The second location is the private folder... develop = EMsoft_getEMdevelop () clpath2 = '' if ( develop . eqv .. TRUE .) then ipos = index ( clpath , 'Public' ) do i = 1 , ipos - 1 clpath2 ( i : i ) = clpath ( i : i ) end do tcf = 'Private/opencl/' do i = ipos , ipos + 15 j = i - ipos + 1 clpath2 ( i : i ) = tcf ( j : j ) end do end if fname = trim ( clpath ) // trim ( sourcefile ) fname = EMsoft_toNativePath ( fname ) inquire ( file = trim ( fname ), exist = fexist ) if (. not . fexist ) then if ( develop . eqv .. TRUE .) then fname = trim ( clpath2 ) // trim ( sourcefile ) fname = EMsoft_toNativePath ( fname ) inquire ( file = trim ( fname ), exist = fexist ) if (. not . fexist ) then call FatalError ( 'CLread_source_file' , 'opencl source file ' // trim ( sourcefile ) // ' not found in either opencl folder.' & // trim ( fname )) end if else call FatalError ( 'CLread_source_file' , 'opencl source  file ' // trim ( fname ) // ' not found' ) end if end if ! read the source file from the opencl folder open ( unit = dataunit , file = trim ( fname ), access = 'direct' , status = 'old' , & action = 'read' , iostat = ierr , recl = 1 ) if ( ierr /= 0 ) call FatalError ( \"CLread_source_file: \" , 'Cannot open file ' // fname ) source = '' irec = 1 do read ( unit = dataunit , rec = irec , iostat = ierr ) source ( irec : irec ) if ( ierr /= 0 ) exit if ( irec == source_length ) call FatalError ( \"CLread_source_file: \" , 'Error: CL source file is too big' ) irec = irec + 1 end do close ( unit = dataunit ) csource = trim ( source ) csource ( irec : irec ) = C_NULL_CHAR slength = irec end subroutine CLread_source_file !-------------------------------------------------------------------------- ! ! SUBROUTINE:CLinit_PDCCQ ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief initalize a CL platform, device, context, and command queue ! !> @param ! !> @date 02/23/16  MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine CLinit_PDCCQ ( platform , nump , selnump , device , numd , selnumd , devinfo , context , command_queue ) !DEC$ ATTRIBUTES DLLEXPORT :: CLinit_PDCCQ use ISO_C_BINDING use error use io IMPLICIT NONE integer ( c_intptr_t ), allocatable , target :: platform (:) integer ( kind = irg ), INTENT ( OUT ) :: nump integer ( kind = irg ), INTENT ( IN ) :: selnump integer ( c_intptr_t ), allocatable , target :: device (:) integer ( kind = irg ), INTENT ( OUT ) :: numd integer ( kind = irg ), INTENT ( IN ) :: selnumd character ( fnlen ), INTENT ( OUT ) :: devinfo integer ( c_intptr_t ), target :: context integer ( c_intptr_t ), target :: command_queue integer ( c_int32_t ) :: ierr integer ( c_size_t ) :: cnuminfo character ( fnlen ), target :: info integer ( c_intptr_t ), target :: ctx_props ( 3 ) integer ( c_int64_t ) :: cmd_queue_props ! get the platform ID ierr = clGetPlatformIDs ( 0 , C_NULL_PTR , nump ) call CLerror_check ( 'CLinit_PDCCQ:clGetPlatformIDs' , ierr ) allocate ( platform ( nump )) ierr = clGetPlatformIDs ( nump , C_LOC ( platform ), nump ) call CLerror_check ( 'CLinit_PDCCQ:clGetPlatformIDs' , ierr ) if ( selnump . gt . nump ) then call FatalError ( \"CLinit_PDCCQ\" , \"non-existing platform id requested\" ) end if ! get the device ID ierr = clGetDeviceIDs ( platform ( selnump ), CL_DEVICE_TYPE_GPU , 0 , C_NULL_PTR , numd ) call CLerror_check ( 'CLinit_PDCCQ:clGetDeviceIDs' , ierr ) allocate ( device ( numd )) ierr = clGetDeviceIDs ( platform ( selnump ), CL_DEVICE_TYPE_GPU , numd , C_LOC ( device ), numd ) call CLerror_check ( 'CLinit_PDCCQ:clGetDeviceIDs' , ierr ) if ( selnumd . gt . numd ) then call FatalError ( \"CLinit_PDCCQ\" , \"non-existing device id requested\" ) end if ! get the device name and return it as devinfo ierr = clGetDeviceInfo ( device ( selnumd ), CL_DEVICE_NAME , sizeof ( info ), C_LOC ( info ), cnuminfo ) call CLerror_check ( 'CLinit_PDCCQ:clGetDeviceInfo' , ierr ) if ( cnuminfo . gt . fnlen ) then call WriteValue ( \"CLinit_PDCCQ\" , \"device info string truncated to 132 characters\" ) devinfo = trim ( info ( 1 : 132 )) else devinfo = trim ( info ( 1 : cnuminfo )) end if ! create the context and the command queue ctx_props ( 1 ) = CL_CONTEXT_PLATFORM ctx_props ( 2 ) = platform ( selnump ) ctx_props ( 3 ) = 0 context = clCreateContext ( C_LOC ( ctx_props ), numd , C_LOC ( device ), C_NULL_FUNPTR , C_NULL_PTR , ierr ) call CLerror_check ( 'CLinit_PDCCQ:clCreateContext' , ierr ) cmd_queue_props = 0 command_queue = clCreateCommandQueue ( context , device ( selnumd ), cmd_queue_props , ierr ) call CLerror_check ( 'CLinit_PDCCQ:clCreateCommandQueue' , ierr ) end subroutine CLinit_PDCCQ !-------------------------------------------------------------------------- ! ! SUBROUTINE:CLerror_check ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief checks whether or not there was a CL 1.2 error and returns the error message. ! !> @param ierr error number (0 is no error) ! !> @date 06/06/16  MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine CLerror_check ( routine , ierr , nonfatal ) !DEC$ ATTRIBUTES DLLEXPORT :: CLerror_check use ISO_C_BINDING use error use io IMPLICIT NONE character ( * ), INTENT ( IN ) :: routine integer ( kind = c_int32_t ), INTENT ( IN ) :: ierr logical , INTENT ( IN ), OPTIONAL :: nonfatal character ( fnlen ) :: estr integer ( kind = irg ) :: iout ( 1 ) if ( ierr . ne . 0 ) then select case ( ierr ) case ( - 1 ) estr = 'Error: CL_DEVICE_NOT_FOUND' !                       = -1 case ( - 2 ) estr = 'Error: CL_DEVICE_NOT_AVAILABLE' !                   = -2 case ( - 3 ) estr = 'Error: CL_COMPILER_NOT_AVAILABLE' !                 = -3 case ( - 4 ) estr = 'Error: CL_MEM_OBJECT_ALLOCATION_FAILURE' !          = -4 case ( - 5 ) estr = 'Error: CL_OUT_OF_RESOURCES' !                       = -5 case ( - 6 ) estr = 'Error: CL_OUT_OF_HOST_MEMORY' !                     = -6 case ( - 7 ) estr = 'Error: CL_PROFILING_INFO_NOT_AVAILABLE' !           = -7 case ( - 8 ) estr = 'Error: CL_MEM_COPY_OVERLAP' !                       = -8 case ( - 9 ) estr = 'Error: CL_IMAGE_FORMAT_MISMATCH' !                  = -9 case ( - 10 ) estr = 'Error: CL_IMAGE_FORMAT_NOT_SUPPORTED' !             = -10 case ( - 11 ) estr = 'Error: CL_BUILD_PROGRAM_FAILURE' !                  = -11 case ( - 12 ) estr = 'Error: CL_MAP_FAILURE' !                            = -12 case ( - 13 ) estr = 'Error: CL_MISALIGNED_SUB_BUFFER_OFFSET' !           = -13 case ( - 14 ) estr = 'Error: CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST' ! 14 case ( - 15 ) estr = 'Error: CL_COMPILE_PROGRAM_FAILURE' !                = -15 case ( - 16 ) estr = 'Error: CL_LINKER_NOT_AVAILABLE' !                   = -16 case ( - 17 ) estr = 'Error: CL_LINK_PROGRAM_FAILURE' !                   = -17 case ( - 18 ) estr = 'Error: CL_DEVICE_PARTITION_FAILED' !                = -18 case ( - 19 ) estr = 'Error: CL_KERNEL_ARG_INFO_NOT_AVAILABLE' !          = -19 case ( - 30 ) estr = 'Error: CL_INVALID_VALUE' !                          = -30 case ( - 31 ) estr = 'Error: CL_INVALID_DEVICE_TYPE' !                    = -31 case ( - 32 ) estr = 'Error: CL_INVALID_PLATFORM' !                       = -32 case ( - 33 ) estr = 'Error: CL_INVALID_DEVICE' !                         = -33 case ( - 34 ) estr = 'Error: CL_INVALID_CONTEXT' !                        = -34 case ( - 35 ) estr = 'Error: CL_INVALID_QUEUE_PROPERTIES' !               = -35 case ( - 36 ) estr = 'Error: CL_INVALID_COMMAND_QUEUE' !                  = -36 case ( - 37 ) estr = 'Error: CL_INVALID_HOST_PTR' !                       = -37 case ( - 38 ) estr = 'Error: CL_INVALID_MEM_OBJECT' !                     = -38 case ( - 39 ) estr = 'Error: CL_INVALID_IMAGE_FORMAT_DESCRIPTOR' !        = -39 case ( - 40 ) estr = 'Error: CL_INVALID_IMAGE_SIZE' !                     = -40 case ( - 41 ) estr = 'Error: CL_INVALID_SAMPLER' !                        = -41 case ( - 42 ) estr = 'Error: CL_INVALID_BINARY' !                         = -42 case ( - 43 ) estr = 'Error: CL_INVALID_BUILD_OPTION' !                   = -43 case ( - 44 ) estr = 'Error: CL_INVALID_PROGRAM' !                        = -44 case ( - 45 ) estr = 'Error: CL_INVALID_PROGRAM_EXECUTABLE' !             = -45 case ( - 46 ) estr = 'Error: CL_INVALID_KERNEL_NAME' !                    = -46 case ( - 47 ) estr = 'Error: CL_INVALID_KERNEL_DEFINITION' !              = -47 case ( - 48 ) estr = 'Error: CL_INVALID_KERNEL' !                         = -48 case ( - 49 ) estr = 'Error: CL_INVALID_ARG_INDEX' !                      = -49 case ( - 50 ) estr = 'Error: CL_INVALID_ARG_VALUE' !                      = -50 case ( - 51 ) estr = 'Error: CL_INVALID_ARG_SIZE' !                       = -51 case ( - 52 ) estr = 'Error: CL_INVALID_KERNEL_ARGS' !                    = -52 case ( - 53 ) estr = 'Error: CL_INVALID_WORK_DIMENSION' !                 = -53 case ( - 54 ) estr = 'Error: CL_INVALID_WORK_GROUP_SIZE' !                = -54 case ( - 55 ) estr = 'Error: CL_INVALID_WORK_ITEM_SIZE' !                 = -55 case ( - 56 ) estr = 'Error: CL_INVALID_GLOBAL_OFFSET' !                  = -56 case ( - 57 ) estr = 'Error: CL_INVALID_EVENT_WAIT_LIST' !                = -57 case ( - 58 ) estr = 'Error: CL_INVALID_EVENT' !                          = -58 case ( - 59 ) estr = 'Error: CL_INVALID_OPERATION' !                      = -59 case ( - 60 ) estr = 'Error: CL_INVALID_GL_OBJECT' !                      = -60 case ( - 61 ) estr = 'Error: CL_INVALID_BUFFER_SIZE' !                    = -61 case ( - 62 ) estr = 'Error: CL_INVALID_MIP_LEVEL' !                      = -62 case ( - 63 ) estr = 'Error: CL_INVALID_GLOBAL_WORK_SIZE' !               = -63 case ( - 64 ) estr = 'Error: CL_INVALID_PROPERTY' !                       = -64 case ( - 65 ) estr = 'Error: CL_INVALID_IMAGE_DESCRIPTOR' !               = -65 case ( - 66 ) estr = 'Error: CL_INVALID_COMPILER_OPTIONS' !               = -66 case ( - 67 ) estr = 'Error: CL_INVALID_LINKER_OPTIONS' !                 = -67 case ( - 68 ) estr = 'Error: CL_INVALID_DEVICE_PARTITION_COUNT' !         = -68 case default estr = 'Error: Unknown CL error code' iout ( 1 ) = ierr call WriteValue ( 'Unknown CL error code : ' , iout , 1 ) end select if ( present ( nonfatal )) then if ( nonfatal . eqv .. TRUE .) then print * , ' Non-fatal error: ' // trim ( estr ) end if else call FatalError ( trim ( routine ), trim ( estr )) end if end if end subroutine CLerror_check end module CLsupport","tags":"","loc":"sourcefile/clsupport.f90.html","title":"CLsupport.f90 – Fortran Program"},{"text":"Files Dependent On This One sourcefile~~constants.f90~~AfferentGraph sourcefile~constants.f90 constants.f90 sourcefile~dispfield.f90 dispfield.f90 sourcefile~constants.f90->sourcefile~dispfield.f90 sourcefile~so3.f90 so3.f90 sourcefile~constants.f90->sourcefile~so3.f90 sourcefile~povray.f90 povray.f90 sourcefile~constants.f90->sourcefile~povray.f90 sourcefile~initializers.f90 initializers.f90 sourcefile~constants.f90->sourcefile~initializers.f90 sourcefile~pfinversion.f90 PFInversion.f90 sourcefile~constants.f90->sourcefile~pfinversion.f90 sourcefile~emdymod.f90 EMdymod.f90 sourcefile~constants.f90->sourcefile~emdymod.f90 sourcefile~filters.f90 filters.f90 sourcefile~constants.f90->sourcefile~filters.f90 sourcefile~eccimod.f90 ECCImod.f90 sourcefile~constants.f90->sourcefile~eccimod.f90 sourcefile~defectmodule.f90 defectmodule.f90 sourcefile~constants.f90->sourcefile~defectmodule.f90 sourcefile~namelisthandlers.f90 NameListHandlers.f90 sourcefile~constants.f90->sourcefile~namelisthandlers.f90 sourcefile~pedmod.f90 PEDmod.f90 sourcefile~constants.f90->sourcefile~pedmod.f90 sourcefile~dictmod.f90 dictmod.f90 sourcefile~constants.f90->sourcefile~dictmod.f90 sourcefile~muellercalculus.f90 MuellerCalculus.f90 sourcefile~constants.f90->sourcefile~muellercalculus.f90 sourcefile~so3.f90->sourcefile~dictmod.f90 sourcefile~initializers.f90->sourcefile~emdymod.f90 sourcefile~simulated_annealing.f90 simulated_annealing.f90 sourcefile~emdymod.f90->sourcefile~simulated_annealing.f90 sourcefile~filters.f90->sourcefile~emdymod.f90 sourcefile~defectmodule.f90->sourcefile~dispfield.f90 sourcefile~jsonsupport.f90 JSONsupport.f90 sourcefile~namelisthandlers.f90->sourcefile~jsonsupport.f90 sourcefile~dictmod.f90->sourcefile~pfinversion.f90 sourcefile~jsonsupport.f90->sourcefile~defectmodule.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules constants Source Code constants.f90 Source Code ! ################################################################### ! Copyright (c) 2014, Marc De Graef/Carnegie Mellon University ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without modification, are ! permitted provided that the following conditions are met: ! !     - Redistributions of source code must retain the above copyright notice, this list !        of conditions and the following disclaimer. !     - Redistributions in binary form must reproduce the above copyright notice, this !        list of conditions and the following disclaimer in the documentation and/or !        other materials provided with the distribution. !     - Neither the names of Marc De Graef, Carnegie Mellon University nor the names !        of its contributors may be used to endorse or promote products derived from !        this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE ! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ################################################################### !-------------------------------------------------------------------------- ! EMsoft:constants.f90 !-------------------------------------------------------------------------- ! ! MODULE: constants ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief !> Definition of constants and constant arrays used by other routines ! !> @details !> physical and mathematical constants used by various programs; periodic !>  table information; atomic weights; ! !> @date 1/5/99   MDG 1.0 original !> @date 5/18/01  MDG 2.0 f90 !> @date 11/27/01 MDG 2.1 added kind support !> @date 03/19/13 MDG 3.0 added atomic weights !> @date 01/10/14 MDG 4.0 new version !> @date 04/29/14 MDG 4.1 constants updated from NIST physical constants tables !> @date 07/06/14 MDG 4.2 added omegamax to Lambert constant type !> @date 08/11/14 MDG 4.3 added infty for handling of +Infinity in rotations module !> @date 08/11/14 MDG 4.4 added epsijk option to package !> @date 09/30/14 MDG 4.5 added some additional comments about epsijk !> @date 10/02/14 MDG 4.6 removed omegamax again, since we now have properly dealt with 180 degree rotations !> @date 03/11/15 MDG 4.7 added some additional comments about epsijk !> @date 04/02/17 MDG 4.8 modified definition of fundamental zones types and orders to accomodate two-phase disorientations !-------------------------------------------------------------------------- module constants use local IMPLICIT NONE ! **************************************************** ! **************************************************** ! **************************************************** ! used to change the sign of the permutation symbol from Adam Morawiec's book to ! the convention used for the EMsoft package.  If you want to use Adam's convention, ! both of these parameters should be set to +1; -1 will change the sign everywhere ! for all representations that involve the unit vector.  The quaternion product is ! also redefined to include the epsijk parameter.  Doing so guarantees that the ! quat_Lp operator ALWAYS returns an active result, regardless of the choice of epsijk; ! quat_LPstar ALWAYS returns a passive result. ! Uncomment these for an alternative way of doing things !real(kind=sgl), parameter :: epsijk = -1.0 !real(kind=dbl), parameter :: epsijkd = -1.D0 ! uncomment these for the Morawiec version. real ( kind = sgl ), parameter :: epsijk = 1.0 real ( kind = dbl ), parameter :: epsijkd = 1.D0 !DEC$ ATTRIBUTES DLLEXPORT :: epsijk !DEC$ ATTRIBUTES DLLEXPORT :: epsijkd ! In the first case, epsijk=-1, the rotation 120@[111] will result in ! an axis angle pair of [111], 2pi/3.  In the second case, the axis-angle ! pair will be -[111], 2pi/3.  In all cases, the rotations are interpreted ! in the passive sense.  The case epsijk=+1 corresponds to the mathematically ! consistent case, using the standard definition for the quaternion product; in ! the other case, epsijk=-1, one must redefine the quaternion product in order ! to produce consistent results.  This takes a lengthy explanation ... see the ! rotations tutorial paper for an in-depth explanation.  These changes propagate ! to a number of files, notably quaternions.f90, and everywhere else that quaternions ! and rotations in general are used. ! **************************************************** ! **************************************************** ! **************************************************** ! the rotations.f90 routines need to have access to the value +Infinity ! which is defined here (using the LaTeX name infty) !INTEGER,private :: inf !REAL,public :: infty !EQUIVALENCE (inf,infty) ! stores two variable at the same address !DATA inf/z'7f800000'/ !Hex for +Infinity !INTEGER(kind=8),private :: infd !REAL(kind=dbl),public :: inftyd !EQUIVALENCE (infd,inftyd) ! stores two variable at the same address !DATA infd/z'7FF0000000000000'/ !Hex for +Infinity ! solution to Intel fortran compiler not liking the above definitions for infty and inftyd REAL ( kind = sgl ), public :: infty = HUGE ( 0.0_sgl ) REAL ( kind = dbl ), public :: inftyd = HUGE ( 0.0_dbl ) !DEC$ ATTRIBUTES DLLEXPORT :: infty !DEC$ ATTRIBUTES DLLEXPORT :: inftyd ! various physical constants !> cPi\t\t= pi [dimensionless] !> cLight\t= velocity of light [m/s] !> cPlanck\t= Planck''s constant [Js] !> cBoltzmann\t= Boltmann constant [J/K] !> cPermea\t= permeability of vacuum [dimensionless] !> cPermit\t= permittivity of vacuum [F/m] !> cCharge\t= electron charge [C] !> cRestmass\t= electron rest mass [kg] !> cMoment\t= electron magnetic moment [J/T] !> cJ2eV\t= Joules per eV !> cAvogadro\t= Avogadro's constant [mol&#94;-1] real ( kind = dbl ), parameter :: cPi = 3.141592653589793238D0 , cLight = 29979245 8.D0 , & cPlanck = 6.62606957D-34 , cBoltzmann = 1.3806488D-23 , & cPermea = 1.2566370614D-6 , cPermit = 8.854187817D-12 , & cCharge = 1.602176565D-19 , cRestmass = 9.10938291D-31 , & cMoment = 9.28476430D-24 , cJ2eV = 1.602176565D-19 , & cAvogadro = 6.02214129D23 !DEC$ ATTRIBUTES DLLEXPORT :: cPi !DEC$ ATTRIBUTES DLLEXPORT :: cPlanck !DEC$ ATTRIBUTES DLLEXPORT :: cPermea !DEC$ ATTRIBUTES DLLEXPORT :: cCharge !DEC$ ATTRIBUTES DLLEXPORT :: cMoment !DEC$ ATTRIBUTES DLLEXPORT :: cAvogadro !DEC$ ATTRIBUTES DLLEXPORT :: cLight !DEC$ ATTRIBUTES DLLEXPORT :: cBoltzmann !DEC$ ATTRIBUTES DLLEXPORT :: cPermit !DEC$ ATTRIBUTES DLLEXPORT :: cRestmass !DEC$ ATTRIBUTES DLLEXPORT :: cJ2eV !> element symbols (we'll do 1-98 for all parameter lists) character ( 2 ), parameter :: ATOM_sym ( 98 ) = ( / ' H' , 'He' , 'Li' , 'Be' , ' B' , ' C' , ' N' , ' O' , ' F' , 'Ne' , & 'Na' , 'Mg' , 'Al' , 'Si' , ' P' , ' S' , 'Cl' , 'Ar' , ' K' , 'Ca' , & 'Sc' , 'Ti' , ' V' , 'Cr' , 'Mn' , 'Fe' , 'Co' , 'Ni' , 'Cu' , 'Zn' , & 'Ga' , 'Ge' , 'As' , 'Se' , 'Br' , 'Kr' , 'Rb' , 'Sr' , ' Y' , 'Zr' , & 'Nb' , 'Mo' , 'Tc' , 'Ru' , 'Rh' , 'Pd' , 'Ag' , 'Cd' , 'In' , 'Sn' , & 'Sb' , 'Te' , ' I' , 'Xe' , 'Cs' , 'Ba' , 'La' , 'Ce' , 'Pr' , 'Nd' , & 'Pm' , 'Sm' , 'Eu' , 'Gd' , 'Tb' , 'Dy' , 'Ho' , 'Er' , 'Tm' , 'Yb' , & 'Lu' , 'Hf' , 'Ta' , ' W' , 'Re' , 'Os' , 'Ir' , 'Pt' , 'Au' , 'Hg' , & 'Tl' , 'Pb' , 'Bi' , 'Po' , 'At' , 'Rn' , 'Fr' , 'Ra' , 'Ac' , 'Th' , & 'Pa' , ' U' , 'Np' , 'Pu' , 'Am' , 'Cm' , 'Bk' , 'Cf' / ) !DEC$ ATTRIBUTES DLLEXPORT :: ATOM_sym !> Shannon-Prewitt ionic radii in nanometer real ( kind = sgl ), parameter :: ATOM_SPradii ( 98 ) = ( / 0.010 , 0.010 , 0.680 , 0.300 , 0.160 , 0.150 , 0.148 , 0.146 , 0.133 , 0.500 , & 0.098 , 0.065 , 0.450 , 0.380 , 0.340 , 0.190 , 0.181 , 0.500 , 0.133 , 0.940 , & 0.068 , 0.060 , 0.740 , 0.690 , 0.670 , 0.640 , 0.630 , 0.620 , 0.720 , 0.740 , & 0.113 , 0.073 , 0.580 , 0.202 , 0.196 , 0.500 , 0.148 , 0.110 , 0.880 , 0.770 , & 0.067 , 0.068 , 0.500 , 0.500 , 0.500 , 0.860 , 0.126 , 0.970 , 0.132 , 0.930 , & 0.076 , 0.222 , 0.219 , 0.500 , 0.167 , 0.129 , 0.104 , 0.111 , 0.500 , 0.108 , & 0.050 , 0.104 , 0.500 , 0.970 , 0.500 , 0.990 , 0.500 , 0.960 , 0.500 , 0.940 , & 0.050 , 0.050 , 0.680 , 0.600 , 0.520 , 0.500 , 0.500 , 0.500 , 0.137 , 0.112 , & 0.140 , 0.132 , 0.740 , 0.230 , 0.227 , 0.500 , 0.175 , 0.137 , 0.111 , 0.990 , & 0.090 , 0.083 , 0.500 , 0.108 , 0.500 , 0.500 , 0.500 , 0.500 / ) !DEC$ ATTRIBUTES DLLEXPORT :: ATOM_SPradii !> atomic (metallic) radii in nanometer (0.100 if not known/applicable) real ( kind = sgl ), parameter :: ATOM_MTradii ( 98 ) = ( / 0.100 , 0.100 , 0.156 , 0.112 , 0.100 , 0.100 , 0.100 , 0.100 , 0.100 , 0.100 , & 0.191 , 0.160 , 0.142 , 0.100 , 0.100 , 0.100 , 0.100 , 0.100 , 0.238 , 0.196 , & 0.160 , 0.146 , 0.135 , 0.128 , 0.136 , 0.127 , 0.125 , 0.124 , 0.128 , 0.137 , & 0.135 , 0.139 , 0.125 , 0.116 , 0.100 , 0.100 , 0.253 , 0.215 , 0.181 , 0.160 , & 0.147 , 0.140 , 0.135 , 0.133 , 0.134 , 0.137 , 0.144 , 0.152 , 0.167 , 0.158 , & 0.161 , 0.143 , 0.100 , 0.100 , 0.270 , 0.224 , 0.187 , 0.182 , 0.182 , 0.181 , & 0.100 , 0.100 , 0.204 , 0.178 , 0.177 , 0.175 , 0.176 , 0.173 , 0.174 , 0.193 , & 0.173 , 0.158 , 0.147 , 0.141 , 0.137 , 0.135 , 0.135 , 0.138 , 0.144 , 0.155 , & 0.171 , 0.174 , 0.182 , 0.168 , 0.100 , 0.100 , 0.100 , 0.100 , 0.100 , 0.180 , & 0.163 , 0.154 , 0.150 , 0.164 , 0.100 , 0.100 , 0.100 , 0.100 / ) !DEC$ ATTRIBUTES DLLEXPORT :: ATOM_MTradii !> atom colors for PostScript drawings character ( 3 ), parameter :: ATOM_color ( 98 ) = ( / 'blu' , 'grn' , 'blu' , 'blu' , 'red' , 'bro' , 'blu' , 'red' , 'grn' , 'grn' , & 'blu' , 'pnk' , 'grn' , 'red' , 'pnk' , 'cyn' , 'blu' , 'blu' , 'grn' , 'grn' , & 'blu' , 'blu' , 'grn' , 'red' , 'pnk' , 'cyn' , 'blu' , 'blu' , 'grn' , 'grn' , & 'blu' , 'blu' , 'grn' , 'red' , 'pnk' , 'cyn' , 'blu' , 'blu' , 'grn' , 'grn' , & 'blu' , 'blu' , 'grn' , 'red' , 'pnk' , 'cyn' , 'blu' , 'blu' , 'grn' , 'grn' , & 'blu' , 'blu' , 'grn' , 'red' , 'pnk' , 'cyn' , 'blu' , 'blu' , 'grn' , 'grn' , & 'blu' , 'blu' , 'grn' , 'red' , 'pnk' , 'cyn' , 'blu' , 'blu' , 'grn' , 'grn' , & 'blu' , 'blu' , 'grn' , 'red' , 'pnk' , 'cyn' , 'blu' , 'blu' , 'grn' , 'grn' , & 'blu' , 'blu' , 'grn' , 'red' , 'pnk' , 'cyn' , 'blu' , 'blu' , 'grn' , 'grn' , & 'blu' , 'blu' , 'grn' , 'red' , 'pnk' , 'cyn' , 'blu' , 'grn' / ) !DEC$ ATTRIBUTES DLLEXPORT :: ATOM_color !> atomic weights for things like density computations (from NIST elemental data base) real ( kind = sgl ), parameter :: ATOM_weights ( 98 ) = ( / 1.00794 , 4.002602 , 6.941 , 9.012182 , 1 0.811 , & 1 2.0107 , 1 4.0067 , 1 5.9994 , 1 8.9984032 , 2 0.1797 , & 2 2.98976928 , 2 4.3050 , 2 6.9815386 , 2 8.0855 , 3 0.973762 , & 3 2.065 , 3 5.453 , 3 9.948 , 3 9.0983 , 4 0.078 , & 4 4.955912 , 4 7.867 , 5 0.9415 , 5 1.9961 , 5 4.938045 , & 5 5.845 , 5 8.933195 , 5 8.6934 , 6 3.546 , 6 5.38 , & 6 9.723 , 7 2.64 , 7 4.92160 , 7 8.96 , 7 9.904 , & 8 3.798 , 8 5.4678 , 8 7.62 , 8 8.90585 , 9 1.224 , & 9 2.90638 , 9 5.96 , 9 8.9062 , 10 1.07 , 10 2.90550 , & 10 6.42 , 10 7.8682 , 11 2.411 , 11 4.818 , 11 8.710 , & 12 1.760 , 12 7.60 , 12 6.90447 , 13 1.293 , 13 2.9054519 , & 13 7.327 , 13 8.90547 , 14 0.116 , 14 0.90765 , 14 4.242 , & 14 5.0 , 15 0.36 , 15 1.964 , 15 7.25 , 15 8.92535 , & 16 2.500 , 16 4.93032 , 16 7.259 , 16 8.93421 , 17 3.054 , & 17 4.9668 , 17 8.49 , 18 0.94788 , 18 3.84 , 18 6.207 , & 19 0.23 , 19 2.217 , 19 5.084 , 19 6.966569 , 20 0.59 , & 20 4.3833 , 20 7.2 , 20 8.98040 , 20 9.0 , 21 0.0 , & 22 2.0 , 22 3.0 , 22 6.0 , 22 7.0 , 23 2.03806 , & 23 1.03588 , 23 8.02891 , 23 7.0 , 24 4.0 , 24 3.0 , & 24 7.0 , 25 1.0 , 25 2.0 / ) !DEC$ ATTRIBUTES DLLEXPORT :: ATOM_weights ! these are a bunch of constants used for Lambert and related projections; they are all in double precision type LambertParametersType real ( kind = dbl ) :: Pi = 3.141592653589793D0 !  pi real ( kind = dbl ) :: iPi = 0.318309886183791D0 !  1/pi real ( kind = dbl ) :: sPi = 1.772453850905516D0 !  sqrt(pi) real ( kind = dbl ) :: sPio2 = 1.253314137315500D0 !  sqrt(pi/2) real ( kind = dbl ) :: sPi2 = 0.886226925452758D0 !  sqrt(pi)/2 real ( kind = dbl ) :: srt = 0.86602540378D0 !  sqrt(3)/2 real ( kind = dbl ) :: isrt = 0.57735026919D0 !  1/sqrt(3) real ( kind = dbl ) :: alpha = 1.346773687088598D0 !  sqrt(pi)/3&#94;(1/4) real ( kind = dbl ) :: rtt = 1.732050807568877D0 !  sqrt(3) real ( kind = dbl ) :: prea = 0.525037567904332D0 !  3&#94;(1/4)/sqrt(2pi) real ( kind = dbl ) :: preb = 1.050075135808664D0 !  3&#94;(1/4)sqrt(2/pi) real ( kind = dbl ) :: prec = 0.906899682117109D0 !  pi/2sqrt(3) real ( kind = dbl ) :: pred = 2.094395102393195D0 !  2pi/3 real ( kind = dbl ) :: pree = 0.759835685651593D0 !  3&#94;(-1/4) real ( kind = dbl ) :: pref = 1.381976597885342D0 !  sqrt(6/pi) real ( kind = dbl ) :: preg = 1.5551203015562141D0 ! 2sqrt(pi)/3&#94;(3/4) ! the following constants are used for the cube to quaternion hemisphere mapping real ( kind = dbl ) :: a = 1.925749019958253D0 ! pi&#94;(5/6)/6&#94;(1/6) real ( kind = dbl ) :: ap = 2.145029397111025D0 ! pi&#94;(2/3) real ( kind = dbl ) :: sc = 0.897772786961286D0 ! a/ap real ( kind = dbl ) :: beta = 0.962874509979126D0 ! pi&#94;(5/6)/6&#94;(1/6)/2 real ( kind = dbl ) :: R1 = 1.330670039491469D0 ! (3pi/4)&#94;(1/3) real ( kind = dbl ) :: r2 = 1.414213562373095D0 ! sqrt(2) real ( kind = dbl ) :: r22 = 0.707106781186547D0 ! 1/sqrt(2) real ( kind = dbl ) :: pi12 = 0.261799387799149D0 ! pi/12 real ( kind = dbl ) :: pi8 = 0.392699081698724D0 ! pi/8 real ( kind = dbl ) :: prek = 1.643456402972504D0 ! R1 2&#94;(1/4)/beta real ( kind = dbl ) :: r24 = 4.898979485566356D0 ! sqrt(24) !       real(kind=dbl)          :: tfit(16) = (/1.0000000000018852D0, -0.5000000002194847D0, & !                                            -0.024999992127593126D0, - 0.003928701544781374D0, & !                                            -0.0008152701535450438D0, - 0.0002009500426119712D0, & !                                            -0.00002397986776071756D0, - 0.00008202868926605841D0, & !                                            +0.00012448715042090092D0, - 0.0001749114214822577D0, & !                                            +0.0001703481934140054D0, - 0.00012062065004116828D0, & !                                            +0.000059719705868660826D0, - 0.00001980756723965647D0, & !                                            +0.000003953714684212874D0, - 0.00000036555001439719544D0 /) ! a more accurate fit, up to order 40  [MDG, 03/28/16] real ( kind = dbl ) :: tfit ( 21 ) = ( / 0.9999999999999968D0 , - 0.49999999999986866D0 , & - 0.025000000000632055D0 , - 0.003928571496460683D0 , & - 0.0008164666077062752D0 , - 0.00019411896443261646D0 , & - 0.00004985822229871769D0 , - 0.000014164962366386031D0 , & - 1.9000248160936107D-6 , - 5.72184549898506D-6 , & 7.772149920658778D-6 , - 0.00001053483452909705D0 , & 9.528014229335313D-6 , - 5.660288876265125D-6 , & 1.2844901692764126D-6 , 1.1255185726258763D-6 , & - 1.3834391419956455D-6 , 7.513691751164847D-7 , & - 2.401996891720091D-7 , 4.386887017466388D-8 , & - 3.5917775353564864D-9 / ) real ( kind = dbl ) :: BP ( 6 ) = ( / 0.D0 , 1.D0 , 0.577350269189626D0 , 0.414213562373095D0 , 0.D0 , & 0.267949192431123D0 / ) ! used for Fundamental Zone determination in so3 module end type LambertParametersType type ( LambertParametersType ) :: LPs !DEC$ ATTRIBUTES DLLEXPORT :: LPs ! The following two arrays are used to determine the FZtype (FZtarray) and primary rotation axis order (FZoarray) ! for each of the 32 crystallographic point group symmetries (in the order of the International Tables) ! !                                       '    1','   -1','    2','    m','  2/m','  222', & !                                       '  mm2','  mmm','    4','   -4','  4/m','  422', & !                                       '  4mm',' -42m','4/mmm','    3','   -3','   32', & !                                       '   3m','  -3m','    6','   -6','  6/m','  622', & !                                       '  6mm',' -6m2','6/mmm','   23','   m3','  432', & !                                       ' -43m',' m-3m'/ ! ! 1 (C1), -1 (Ci), [triclinic] ! 2 (C2), m (Cs), 2/m (C2h), [monoclinic] ! 222 (D2), mm2 (C2v), mmm (D2h), [orthorhombic] ! 4 (C4), -4 (S4), 4/m (C4h), 422 (D4), 4mm (C4v), -42m (D2d), 4/mmm (D4h), [tetragonal] ! 3 (C3), -3 (C3i), 32 (D3), 3m (C3v), -3m (D3d), [trigonal] ! 6 (C6), -6 (C3h), 6/m (C6h), 622 (D6), 6mm (C6v), -6m2 (D3h), 6/mmm (D6h), [hexagonal] ! 23 (T), m3 (Th), 432 (O), -43m (Td), m-3m (Oh) [cubic] ! ! FZtype ! 0        no symmetry at all ! 1        cyclic symmetry ! 2        dihedral symmetry ! 3        tetrahedral symmetry ! 4        octahedral symmetry ! ! these parameters are used in the so3 module ! integer ( kind = irg ), parameter :: FZtarray ( 32 ) = ( / 0 , 0 , 1 , 1 , 1 , 2 , 2 , 2 , 1 , 1 , 1 , 2 , 2 , 2 , 2 , 1 , 1 , 2 , 2 , 2 , 1 , 1 , 1 , 2 , 2 , 2 , 2 , 3 , 3 , 4 , 3 , 4 / ) !DEC$ ATTRIBUTES DLLEXPORT :: FZtarray integer ( kind = irg ), parameter :: FZoarray ( 32 ) = ( / 0 , 0 , 2 , 2 , 2 , 2 , 2 , 2 , 4 , 4 , 4 , 4 , 4 , 4 , 4 , 3 , 3 , 3 , 3 , 3 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 0 , 0 , 0 , 0 , 0 / ) !DEC$ ATTRIBUTES DLLEXPORT :: FZoarray real ( kind = sgl ) :: Butterfly9x9 ( 81 ) = ( /- 1 0.0 , - 1 5.0 , - 2 2.0 , - 2 2.0 , - 2 2.0 , - 2 2.0 , - 2 2.0 , - 1 5.0 , - 1 0.0 , & - 1.0 , - 6.0 , - 1 3.0 , - 2 2.0 , - 2 2.0 , - 2 2.0 , - 1 3.0 , - 6.0 , - 1.0 , & 3.0 , 6.0 , 4.0 , - 3.0 , - 2 2.0 , - 3.0 , 4.0 , 6.0 , 3.0 , & 3.0 , 1 1.0 , 1 9.0 , 2 8.0 , 4 2.0 , 2 8.0 , 1 9.0 , 1 1.0 , 3.0 , & 3.0 , 1 1.0 , 2 7.0 , 4 2.0 , 4 2.0 , 4 2.0 , 2 7.0 , 1 1.0 , 3.0 , & 3.0 , 1 1.0 , 1 9.0 , 2 8.0 , 4 2.0 , 2 8.0 , 1 9.0 , 1 1.0 , 3.0 , & 3.0 , 6.0 , 4.0 , - 3.0 , - 2 2.0 , - 3.0 , 4.0 , 6.0 , 3.0 , & - 1.0 , - 6.0 , - 1 3.0 , - 2 2.0 , - 2 2.0 , - 2 2.0 , - 1 3.0 , - 6.0 , - 1.0 , & - 1 0.0 , - 1 5.0 , - 2 2.0 , - 2 2.0 , - 2 2.0 , - 2 2.0 , - 2 2.0 , - 1 5.0 , - 1 0.0 / ) !DEC$ ATTRIBUTES DLLEXPORT :: Butterfly9x9 end module","tags":"","loc":"sourcefile/constants.f90.html","title":"constants.f90 – Fortran Program"},{"text":"This File Depends On sourcefile~~defectmodule.f90~~EfferentGraph sourcefile~defectmodule.f90 defectmodule.f90 sourcefile~jsonsupport.f90 JSONsupport.f90 sourcefile~jsonsupport.f90->sourcefile~defectmodule.f90 sourcefile~constants.f90 constants.f90 sourcefile~constants.f90->sourcefile~defectmodule.f90 sourcefile~namelisthandlers.f90 NameListHandlers.f90 sourcefile~constants.f90->sourcefile~namelisthandlers.f90 sourcefile~namelisthandlers.f90->sourcefile~jsonsupport.f90 sourcefile~namelisttypedefs.f90 NameListTypedefs.f90 sourcefile~namelisttypedefs.f90->sourcefile~jsonsupport.f90 sourcefile~namelisttypedefs.f90->sourcefile~namelisthandlers.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files Dependent On This One sourcefile~~defectmodule.f90~~AfferentGraph sourcefile~defectmodule.f90 defectmodule.f90 sourcefile~dispfield.f90 dispfield.f90 sourcefile~defectmodule.f90->sourcefile~dispfield.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules defectmodule Source Code defectmodule.f90 Source Code ! ################################################################### ! Copyright (c) 2013-2015, Marc De Graef/Carnegie Mellon University ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without modification, are ! permitted provided that the following conditions are met: ! !     - Redistributions of source code must retain the above copyright notice, this list !        of conditions and the following disclaimer. !     - Redistributions in binary form must reproduce the above copyright notice, this !        list of conditions and the following disclaimer in the documentation and/or !        other materials provided with the distribution. !     - Neither the names of Marc De Graef, Carnegie Mellon University nor the names !        of its contributors may be used to endorse or promote products derived from !        this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE ! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ################################################################### !-------------------------------------------------------------------------- ! EMsoft:defectmodule.f90 !-------------------------------------------------------------------------- ! ! MODULE: defectmodule ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief Provides a routine to compute the displacement vector for an array of defects. ! !> @date 04/29/11 MDG 1.0 original !> @date 06/04/13 MDG 2.0 rewrite + quaternions instead of rotations !> @date 11/13/13 MDG 2.1 fixed error with coordinate transformations (after very long bug search!) !> @date 11/17/15 MDG 3.0 start of complete rewrite; this mod will now include a routine to read all defect info from a json file !> @date 11/23/15 MDG 3.1 inserted all defect mods into this file instead of separate files !> @date 12/08/15 MDG 3.2 added artificial distortion to inclusion field to mimic ellipsoidal shape (needs Eshelby for correct field) !> @date 12/11/15 MDG 3.3 gave up on previous item and implemented full isotropic Eshelby ellipsoidal inclusion !-------------------------------------------------------------------------- module defectmodule use local use quaternions use typedefs contains !-------------------------------------------------------------------------- ! ! SUBROUTINE: InitializeDefects ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read defect information, and generate all data that can be precomputed for each defect ! !> @date  11/22/15 MDG 1.0 original !> @date  11/24/15 MDG 1.1 added Ydislocations, stacking faults, inclusions and voids !-------------------------------------------------------------------------- recursive subroutine InitializeDefects ( cell , defects , jsonname , npix , npiy , L , gf , error_cnt , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: InitializeDefects use local use typedefs use io use JSONsupport IMPLICIT NONE type ( unitcell ), pointer :: cell type ( defecttype ), INTENT ( INOUT ) :: defects character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( IN ) :: npix integer ( kind = irg ), INTENT ( IN ) :: npiy real ( kind = sgl ), INTENT ( IN ) :: L real ( kind = sgl ), INTENT ( IN ) :: gf ( 3 ) integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt logical , INTENT ( IN ), OPTIONAL :: verbose integer ( kind = irg ) :: v , i , io_int ( 1 ) error_cnt = 0 v = 0 if ( PRESENT ( verbose )) then if ( verbose ) then v = 1 end if end if defects % numdisl = 0 defects % numYdisl = 0 defects % numsf = 0 defects % numvoids = 0 defects % numinc = 0 defects % numEinc = 0 ! first of all, we need to read all the defect data from the jsonname file, including the foil data call JSONreadDefectFile ( cell , jsonname , defects , error_cnt , verbose ) call Message ( 'The following defects were initialized : ' ) io_int ( 1 ) = defects % numdisl call WriteValue ( '  Number of dislocations       : ' , io_int , 1 ) io_int ( 1 ) = defects % numYdisl call WriteValue ( '  Number of Yoffe dislocations : ' , io_int , 1 ) io_int ( 1 ) = defects % numsf call WriteValue ( '  Number of stacking faults    : ' , io_int , 1 ) io_int ( 1 ) = defects % numinc call WriteValue ( '  Number of inclusions         : ' , io_int , 1 ) io_int ( 1 ) = defects % numEinc call WriteValue ( '  Number of Eshelby inclusions : ' , io_int , 1 ) io_int ( 1 ) = defects % numvoids call WriteValue ( '  Number of voids              : ' , io_int , 1 ) ! once we have this data, we need to initialize all other defect related parameters, including ! things like displacement field parameters etc... ! we begin with the foil itself call init_foil_data ( cell , defects , npix , npiy , L , v ) ! then we add the defects, starting with all the regular dislocations, if any if ( defects % numdisl . ne . 0 ) call init_dislocation_data ( cell , defects , npix , npiy , gf , L , v ) ! then Ydislocations if ( defects % numYdisl . ne . 0 ) call init_YSH_dislocation_data ( cell , defects , npix , npiy , gf , L , v ) ! stacking faults if ( defects % numsf . ne . 0 ) call init_stacking_fault_data ( cell , defects , L , npix , npiy , gf , v ) ! inclusions if ( defects % numinc . ne . 0 ) call init_inclusion_data ( defects , L , npix , npiy , v ) ! Eshelby inclusions if ( defects % numEinc . ne . 0 ) then do i = 1 , defects % numEinc call InitializeEshelbyInclusion ( cell , defects , i , v , L , npix , npiy ) end do end if ! voids if ( defects % numvoids . ne . 0 ) call init_void_data ( defects , L , npix , npiy , v ) end subroutine InitializeDefects !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- ! here are the init_defect_data subroutines !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- ! ! SUBROUTINE: init_foil_data ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief  initializes the foil geometry data ! !> @param cell unit cell pointer !> @param defects defects structure !> @param npix number of x image pixels !> @param npiy number of y image pixels !> @param L pixel size for column approximation !> @param dinfo flag to print information ! !> @date 11/22/15 MDG 1.0 new routine in Release 3.1; read portion replaced with JSONreadFoilData in JSONsupport !-------------------------------------------------------------------------- recursive subroutine init_foil_data ( cell , defects , npix , npiy , L , dinfo ) !DEC$ ATTRIBUTES DLLEXPORT :: init_foil_data use crystal use io use constants use files use rotations use typedefs IMPLICIT NONE type ( unitcell ), pointer :: cell type ( defecttype ), INTENT ( INOUT ) :: defects integer ( kind = irg ), INTENT ( IN ) :: npix , npiy , dinfo real ( kind = sgl ), INTENT ( IN ) :: L real ( kind = sgl ) :: io_real ( 1 ) real ( kind = dbl ) :: amat ( 3 , 3 ) ! assign these values to the appropriate slots in foil%   [verified 4/23/11] defects % foil % alP = defects % foil % alP * cPi / 18 0.0 ! convert the tilt and rotation angles to radians defects % foil % alS = defects % foil % alS * cPi / 18 0.0 defects % foil % alR = defects % foil % alR * cPi / 18 0.0 defects % foil % npix = npix ! image size (this duplicates some values, but it's easier this way) defects % foil % npiy = npiy ! shape parameters defects % foil % cpx = defects % foil % cpx * float ( npix ) * 0.5 * L ! we'll define the foil shape center w.r.t. to the center of the image in [nm] coordinates defects % foil % cpy = defects % foil % cpy * float ( npiy ) * 0.5 * L ! ! initialize a bunch of foil related quantities, using quaternions for all rotations call initialize_foil_geometry ( cell , defects % foil , dinfo ) ! compute the projected thickness amat = qu2om ( defects % foil % a_fm ) defects % foil % zb = defects % foil % z0 / amat ( 3 , 3 ) if ( dinfo . eq . 1 ) then io_real ( 1 ) = defects % foil % z0 call WriteValue ( 'Nominal foil thickness = ' , io_real , 1 , \"(F8.3)\" ) io_real ( 1 ) = defects % foil % zb call WriteValue ( 'Effective foil thickness = ' , io_real , 1 , \"(F8.3/)\" ) end if end subroutine init_foil_data !-------------------------------------------------------------------------- ! ! SUBROUTINE: init_dislocation_data ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief  init dislocation namelist files ! !> @param cell unit cell pointer !> @param defects defect structure !> @param DF_npix number of x-pixels !> @param DF_npiy number of y-pixels !> @param DF_gf !> @param L !> @param dinfo logical to trigger verbose output ! !> @date 01/05/99 MDG 1.0 original !> @date 05/19/01 MDG 2.0 f90 version !> @date 11/27/01 MDG 2.1 added kind support !> @date 06/04/13 MDG 3.0 rewrite !> @date 06/09/14 MDG 4.0 added cell, DL argument !> @date 11/22/15 MDG 4.1 old routine obsolete with Release 3.1; replaced by JsonreadDefectFile !> @date 11/23/15 MDG 4.2 moved from dislocation.f90 to defectmodule.f90 !-------------------------------------------------------------------------- recursive subroutine init_dislocation_data ( cell , defects , DF_npix , DF_npiy , DF_gf , L , dinfo ) !DEC$ ATTRIBUTES DLLEXPORT :: init_dislocation_data use io use files IMPLICIT NONE type ( defecttype ), INTENT ( INOUT ) :: defects type ( unitcell ), pointer :: cell integer ( kind = irg ), INTENT ( IN ) :: DF_npix , DF_npiy , dinfo real ( kind = sgl ), INTENT ( IN ) :: DF_gf ( 3 ), L integer ( kind = irg ) :: i ! zfrac goes between -0.5 and +0.5, with -0.5 being the top surface and +0.5 the bottom ! this only really matters for dislocations that are parallel to the foil surfaces ! loop over all regular dislocations and initialize their displacement field parameters do i = 1 , defects % numdisl ! +2*defects%numsf   ! we do not deal with partials in stacking faults here ... ! center of dislocation inside the foil is transformed to foil coordinates [nm] with defects%DL(i)%kd=0 (center of foil) [verified 4/23/11] ! the point (0,0) is at the center of the image ... hence the factor of 0.5 defects % DL ( i )% id = defects % DL ( i )% id * 0.5 * float ( DF_npix ) ! * L   scaling (zooming) is done later in the image reference frame... defects % DL ( i )% jd = defects % DL ( i )% jd * 0.5 * float ( DF_npiy ) ! * L defects % DL ( i )% g = DF_gf ! and pre-compute the dislocation displacement field parameters call makedislocation ( cell , defects , i , dinfo , L ) end do end subroutine init_dislocation_data !-------------------------------------------------------------------------- ! ! SUBROUTINE: init_stacking_fault_data ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief  read stacking fault namelist files ! !> @param cell unit cell pointer !> @param defects defect structure !> @param DF_L !> @param DF_npix number of x-pixels !> @param DF_npiy number of y-pixels !> @param DF_gf !> @param dinfo logical to trigger verbose output !> @param ECCI logical optional to indicate ECCI formatting rather than regular TEM ! !> @date    1/5/99  MDG 1.0 original !> @date    5/19/01 MDG 2.0 f90 version !> @date   11/27/01 MDG 2.1 added kind support !> @date   06/04/13 MDG 3.0 rewrite !> @date   12/17/13 MDG 3.1 added ECCI mode !> @date   06/09/14 MDG 4.0 added cell, defects arguments !> @date   06/10/14 MDG 4.1 added foil argument !-------------------------------------------------------------------------- recursive subroutine init_stacking_fault_data ( cell , defects , DF_L , DF_npix , DF_npiy , DF_g , dinfo , ECCI ) !DEC$ ATTRIBUTES DLLEXPORT :: init_stacking_fault_data use io use files IMPLICIT NONE type ( unitcell ), pointer :: cell type ( defecttype ), INTENT ( INOUT ) :: defects integer ( kind = irg ), INTENT ( IN ) :: DF_npix , DF_npiy , dinfo real ( kind = sgl ), INTENT ( IN ) :: DF_g ( 3 ) real ( kind = sgl ), INTENT ( IN ) :: DF_L logical , INTENT ( IN ), OPTIONAL :: ECCI integer ( kind = irg ) :: i real ( kind = sgl ) :: poisson ! read the namelist files for all of the stacking faults do i = 1 , defects % numsf !   SFR = (/ 0.0, 0.0, 0.0 /) poisson = 0.0 ! transform the fault fractional coordinates to nm in the image reference frame defects % SF ( i )% id = defects % SF ( i )% id * 0.5 * float ( DF_npix ) ! * DF_L  (zooming is done later in the image reference frame) defects % SF ( i )% jd = defects % SF ( i )% jd * 0.5 * float ( DF_npiy ) ! * DF_L defects % SF ( i )% poisson = poisson !   if (sum(abs(SFR)).eq.0.0) then defects % SF ( i )% Rdisp = defects % SF ( i )% lpb !   else !     defects%SF(i)%Rdisp = SFR !   end if ! initialize the stacking fault variables and both partial dislocations; this might depend ! on the imaging mode (TEM vs. ECCI); careful here, since the counting of dislocations has ! changed with respect to release 2.0 !!! if ( present ( ECCI )) then call makestackingfaultECCI ( cell , defects , i , DF_L , DF_npix , DF_npiy , DF_g , dinfo ) defects % numYdisl = defects % numYdisl + 2 else call makestackingfault ( cell , defects , i , DF_L , DF_npix , DF_npiy , DF_g , dinfo ) defects % numdisl = defects % numdisl + 2 end if end do end subroutine init_stacking_fault_data !-------------------------------------------------------------------------- ! ! SUBROUTINE: init_YSH_dislocation_data ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief init Yoffe dislocation ! !> @param cell unit cell pointer !> @param defects defects structure !> @param DF_npix number of x-pixels !> @param DF_npiy number of y-pixels !> @param DF_gf !> @param L !> @param dinfo logical to trigger verbose output ! !> @date  1/5/99  MDG 1.0 original !> @date  5/19/01 MDG 2.0 f90 version !> @date 11/27/01 MDG 2.1 added kind support !> @date 03/25/13 MDG 3.0 updated IO !> @date 11/21/13 MDG 3.1 verification !> @date 06/10/14 MDG 4.0 added defects, cell and foil arguments !> @date 11/23/15 MDG 4.1 made foil part of defects !-------------------------------------------------------------------------- recursive subroutine init_YSH_dislocation_data ( cell , defects , DF_npix , DF_npiy , DF_gf , L , dinfo ) !DEC$ ATTRIBUTES DLLEXPORT :: init_YSH_dislocation_data use io use files IMPLICIT NONE type ( unitcell ), pointer :: cell type ( defecttype ), INTENT ( INOUT ) :: defects integer ( kind = irg ), INTENT ( IN ) :: DF_npix , DF_npiy , dinfo real ( kind = sgl ), INTENT ( IN ) :: DF_gf ( 3 ), L integer ( kind = irg ) :: i real ( kind = sgl ) :: id , jd , u ( 3 ), bv ( 3 ), poisson ! these are just the individual dislocations; the ones that belong to ! stacking faults are handled separately do i = 1 , defects % numYdisl ! top-of-the-foil intersection of dislocation line is transformed to foil coordinates [nm] with DL(i)%kd=0 (center of foil) [verified 4/23/11] ! the point (0,0) is at the center of the image ... hence the factor of 0.5 defects % YD ( i )% id = defects % YD ( i )% id * 0.5 * float ( DF_npix ) ! * L   scaling (zooming) is done later in the image reference frame... defects % YD ( i )% jd = defects % YD ( i )% jd * 0.5 * float ( DF_npiy ) ! * L defects % YD ( i )% g = DF_gf ! and pre-compute the dislocation displacement field parameters call makeYSHdislocation ( cell , defects , i , dinfo , L ) end do end subroutine init_YSH_dislocation_data !-------------------------------------------------------------------------- ! ! SUBROUTINE: init_void_data ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief  init void parameters ! !> @param defects defects structure !> @param DF_L column edge length !> @param DF_npix number of x-pixels !> @param DF_npiy number of y-pixels !> @param dinfo logical to trigger verbose output ! !> @date 01/05/99 MDG 1.0 original !> @date 05/19/01 MDG 2.0 f90 version !> @date 11/27/01 MDG 2.1 added kind support !> @date 03/25/13 MDG 3.0 updated IO !> @date 06/09/14 MDG 4.0 added defects argument !> @date 06/10/14 MDG 4.1 added foil argument !> @date 11/23/15 MDG 4.2 removed foil and put it inside defects !-------------------------------------------------------------------------- recursive subroutine init_void_data ( defects , DF_L , DF_npix , DF_npiy , dinfo ) !DEC$ ATTRIBUTES DLLEXPORT :: init_void_data use io use files IMPLICIT NONE type ( defecttype ), INTENT ( INOUT ) :: defects integer ( kind = irg ), INTENT ( IN ) :: dinfo , DF_npix , DF_npiy real ( kind = sgl ), INTENT ( IN ) :: DF_L integer ( kind = irg ) :: i real ( kind = sgl ) :: tmp ( 3 ) ! read each subsequent line do i = 1 , defects % numvoids defects % voids ( i )% xpos = defects % voids ( i )% xpos * 0.5 * float ( DF_npix ) * DF_L defects % voids ( i )% ypos = defects % voids ( i )% ypos * 0.5 * float ( DF_npiy ) * DF_L defects % voids ( i )% zpos = defects % voids ( i )% zpos * defects % foil % z0 ! transform to the foil reference frame tmp = quat_Lp ( conjg ( defects % foil % a_fc ), dble (( / defects % voids ( i )% xpos , defects % voids ( i )% ypos , defects % voids ( i )% zpos / )) ) defects % voids ( i )% xpos = tmp ( 1 ) defects % voids ( i )% ypos = tmp ( 2 ) defects % voids ( i )% zpos = tmp ( 3 ) if ( dinfo . eq . 1 ) write ( * , * ) i , defects % voids ( i )% xpos , defects % voids ( i )% ypos , defects % voids ( i )% zpos , defects % voids ( i )% radius end do end subroutine init_void_data !-------------------------------------------------------------------------- ! ! SUBROUTINE: init_inclusion_data ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief  init inclusion parameters ! !> @param defects defect structure !> @param DF_L column edge length !> @param DF_npix number of x-pixels !> @param DF_npiy number of y-pixels !> @param dinfo logical to trigger verbose output ! !> @date  01/05/99 MDG 1.0 original !> @date  05/19/01 MDG 2.0 f90 version !> @date  11/27/01 MDG 2.1 added kind support !> @date  03/25/13 MDG 3.0 updated IO !> @date  06/09/14 MDG 4.0 added defects argument !> @date  06/10/14 MDG 4.1 added foil argument !> @date  11/23/15 MDG 4.2 made foil part of defects !-------------------------------------------------------------------------- recursive subroutine init_inclusion_data ( defects , DF_L , DF_npix , DF_npiy , dinfo ) !DEC$ ATTRIBUTES DLLEXPORT :: init_inclusion_data use io use files IMPLICIT NONE type ( defecttype ), INTENT ( INOUT ) :: defects integer ( kind = irg ), INTENT ( IN ) :: dinfo , DF_npix , DF_npiy real ( kind = sgl ), INTENT ( IN ) :: DF_L integer ( kind = irg ) :: i real ( kind = sgl ) :: tmp ( 3 ) ! read each subsequent line do i = 1 , defects % numinc defects % inclusions ( i )% xpos = defects % inclusions ( i )% xpos * 0.5 * float ( DF_npix ) * DF_L defects % inclusions ( i )% ypos = defects % inclusions ( i )% ypos * 0.5 * float ( DF_npiy ) * DF_L defects % inclusions ( i )% zpos = defects % inclusions ( i )% zpos * defects % foil % z0 ! vertical fractional location in interval [-1,1] tmp = quat_Lp ( conjg ( defects % foil % a_fc ), dble (( / defects % inclusions ( i )% xpos , defects % inclusions ( i )% ypos , & defects % inclusions ( i )% zpos / )) ) defects % inclusions ( i )% xpos = tmp ( 1 ) defects % inclusions ( i )% ypos = tmp ( 2 ) defects % inclusions ( i )% zpos = tmp ( 3 ) if ( dinfo . eq . 1 ) write ( * , * ) i , defects % inclusions ( i )% xpos , defects % inclusions ( i )% ypos , defects % inclusions ( i )% zpos , & defects % inclusions ( i )% radius , defects % inclusions ( i )% C end do end subroutine init_inclusion_data !-------------------------------------------------------------------------- ! ! SUBROUTINE: init_Einclusion_data ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief  init inclusion parameters ! !> @param cell cell structure pointer !> @param defects defect structure !> @param DF_L column edge length !> @param DF_npix number of x-pixels !> @param DF_npiy number of y-pixels !> @param dinfo logical to trigger verbose output ! !> @date  01/05/99 MDG 1.0 original !> @date  05/19/01 MDG 2.0 f90 version !> @date  11/27/01 MDG 2.1 added kind support !> @date  03/25/13 MDG 3.0 updated IO !> @date  06/09/14 MDG 4.0 added defects argument !> @date  06/10/14 MDG 4.1 added foil argument !> @date  11/23/15 MDG 4.2 made foil part of defects !> @date  12/08/15 MDG 4.3 forked from init_inclusion_data !> @date  12/11/15 MDG 4.4 reworked based on IDL ellipsoid.pro script !-------------------------------------------------------------------------- recursive subroutine init_Einclusion_data ( cell , defects , DF_L , DF_npix , DF_npiy , dinfo ) !DEC$ ATTRIBUTES DLLEXPORT :: init_Einclusion_data use io use files IMPLICIT NONE type ( unitcell ), pointer :: cell type ( defecttype ), INTENT ( INOUT ) :: defects integer ( kind = irg ), INTENT ( IN ) :: dinfo , DF_npix , DF_npiy real ( kind = sgl ), INTENT ( IN ) :: DF_L integer ( kind = irg ) :: i real ( kind = sgl ) :: tmp ( 3 ) ! read each subsequent line do i = 1 , defects % numEinc defects % Einclusions ( i )% xpos = defects % Einclusions ( i )% xyz ( 1 ) * 0.5 * float ( DF_npix ) * DF_L defects % Einclusions ( i )% ypos = defects % Einclusions ( i )% xyz ( 2 ) * 0.5 * float ( DF_npiy ) * DF_L defects % Einclusions ( i )% zpos = defects % Einclusions ( i )% xyz ( 3 ) * defects % foil % z0 ! vertical fractional location in interval [-1,1] tmp = quat_Lp ( conjg ( defects % foil % a_fc ), dble (( / defects % Einclusions ( i )% xpos , defects % Einclusions ( i )% ypos , & defects % Einclusions ( i )% zpos / )) ) defects % Einclusions ( i )% xpos = tmp ( 1 ) defects % Einclusions ( i )% ypos = tmp ( 2 ) defects % Einclusions ( i )% zpos = tmp ( 3 ) ! here we call the initialization routine to compute a series of arrays ! and look-up tables for elliptic integrals call InitializeEshelbyInclusion ( cell , defects , i , dinfo , DF_L , DF_npix , DF_npiy ) if ( dinfo . eq . 1 ) write ( * , * ) i , defects % Einclusions ( i )% xpos , defects % Einclusions ( i )% ypos , defects % Einclusions ( i )% zpos end do end subroutine init_Einclusion_data !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- ! and here are the routines that actually compute all the defect parameters !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- ! ! SUBROUTINE: initialize_foil_geometry ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief  Initializes the foil geometry ! !> @details This new implementation uses quaternions for all rotations. ! !> @param cell unit cell pointer !> @param dinfo ! !> @date  1/ 5/99 MDG 1.0 original !> @date  1/11/10 MDG 2.0 rewrite of beam direction part !> @date  3/28/11 MDG 2.1 code verified !> @date  4/23/11 MDG 2.2 redefined origin to be at center of image !> @date  6/03/13 MDG 3.0 replaced rotation matrices by quaternions throughout !> @date 10/30/13 MDG 3.1 complete debug of quaternion and rotation implementation !> @date 06/09/14 MDG 4.0 added cell and foil as argument !-------------------------------------------------------------------------- recursive subroutine initialize_foil_geometry ( cell , foil , dinfo ) !DEC$ ATTRIBUTES DLLEXPORT :: initialize_foil_geometry use local use typedefs use math use constants use crystal use symmetry use io use rotations IMPLICIT NONE type ( unitcell ), pointer :: cell type ( foiltype ), INTENT ( INOUT ) :: foil integer ( kind = sgl ), INTENT ( IN ) :: dinfo real ( kind = dbl ) :: ey ( 3 ), ex ( 3 ), tt , dx , dy real ( kind = sgl ) :: io_real ( 3 ) real ( kind = dbl ) :: cp , sp , cs , ss , cr , sr , ca , sa , a_fc ( 3 , 3 ) integer ( kind = irg ) :: i , j type ( orientationtyped ) :: ot character ( 10 ) :: pret ! determine the foil-to-microscope transformations [verified on 4/23/11, converted to quaternions on 6/4/13, ! verified 10/30/13, and again on 11/11/13 after some changes elsewhere] if ( foil % alR . eq . 0.D0 ) then ! the double tilt holder transformation a_fm; note quaternions, hence we need the half-angles ! ! a_fm transforms a vector v FROM the microscope reference frame To the foil reference frame ! using the quat_rotate_vector routine. cp = dcos ( foil % alP * 0.5D0 ) sp = dsin ( foil % alP * 0.5D0 ) ca = dcos ( foil % alP ) sa = dsin ( foil % alP ) cs = dcos ( foil % alS * 0.5D0 ) ss = dsin ( foil % alS * 0.5D0 ) foil % a_fm = conjg ( quat_mult ( ( / cs , 0.D0 , ss * ca , ss * sa / ), ( / cp , sp , 0.D0 , 0.D0 / ) ) ) else ! the rotation tilt holder transformation a_fm [verified on 4/23/11, converted to quaternions on 6/4/13, ! and again on 11/11/13 after changes elsewhere] cp = dcos ( foil % alP * 0.5D0 ) sp = dsin ( foil % alP * 0.5D0 ) cr = dcos ( foil % alR * 0.5D0 ) sr = dsin ( foil % alR * 0.5D0 ) ca = dcos ( foil % alP ) sa = dsin ( foil % alP ) foil % a_fm = conjg ( quat_mult ( ( / cr , 0.D0 , - sr * sa , sr * ca / ), ( / cp , sp , 0.D0 , 0.D0 / ) ) ) end if if ( dinfo . eq . 1 ) then pret = 'a_fm: ' ot = init_orientation ( foil % a_fm , 'qu' ) call print_orientation ( ot , 'om' , pret ) end if ! a_mi (image to microscope) apart from a scale factor, these two are identical ! The EM book uses a beta rotation angle between the image and the microscope, ! but that is really not necessary because we already fix the image with respect to ! the microscope by defining q (the horizontal image direction) to point to the ! airlock. [verified 4/23/11, converted to quaternions on 6/4/13] ! So we'll keep this transformation equal to the identity at all times. foil % a_mi = ( / 1.D0 , 0.D0 , 0.D0 , 0.D0 / ) ! identity quaternion if ( dinfo . eq . 1 ) then pret = 'a_mi: ' ot = init_orientation ( foil % a_mi , 'qu' ) call print_orientation ( ot , 'om' , pret ) end if ! This allows us to get the beam direction, since we know the foil normal and tilt angles ! The beam direction is the inverse transform of the microscope e_z-axis to the foil reference frame [verified 11/12/13] foil % B = quat_Lp ( conjg ( foil % a_fm ), ( / 0.D0 , 0.D0 , - 1.D0 / ) ) foil % Bn = foil % B call NormVec ( cell , foil % Bn , 'c' ) if ( dinfo . eq . 1 ) then io_real ( 1 : 3 ) = foil % B ( 1 : 3 ) call WriteValue ( '  Beam direction (foil reference frame) = ' , io_real , 3 , \"('[',F12.5,',',F12.5,',',F12.5,']')\" ) end if ! transform both the foil normal and the q-vector to the crystal cartesian reference frame (eq. 8.8) [verified 4/23/11, ! and again on 11/12/13 afterchanges elsewhere] call TransSpace ( cell , foil % F , foil % Fn , 'd' , 'c' ) call TransSpace ( cell , foil % q , foil % qn , 'r' , 'c' ) call NormVec ( cell , foil % Fn , 'c' ) call NormVec ( cell , foil % qn , 'c' ) ! a_fc (crystal to foil) a_fc ( 3 , 1 : 3 ) = foil % Fn ( 1 : 3 ) a_fc ( 1 , 1 : 3 ) = foil % qn ( 1 : 3 ) call CalcCross ( cell , foil % Fn , foil % qn , ey , 'c' , 'c' , 0 ) call NormVec ( cell , ey , 'c' ) a_fc ( 2 , 1 : 3 ) = ey ( 1 : 3 ) foil % a_fc = om2qu ( a_fc ) if ( dinfo . eq . 1 ) then pret = 'a_fc: ' ot = init_orientation ( foil % a_fc , 'qu' ) call print_orientation ( ot , 'om' , pret ) end if ! a_mc (crystal to microscope) foil % a_mc = quat_mult ( conjg ( foil % a_fm ), foil % a_fc ) if ( dinfo . eq . 1 ) then pret = 'a_mc: ' ot = init_orientation ( foil % a_mc , 'qu' ) call print_orientation ( ot , 'om' , pret ) end if ! a_ic (crystal to image) foil % a_ic = quat_mult ( conjg ( foil % a_mi ) , foil % a_mc ) if ( dinfo . eq . 1 ) then pret = 'a_ic: ' ot = init_orientation ( foil % a_ic , 'qu' ) call print_orientation ( ot , 'om' , pret ) end if ! a_fi (image to foil) foil % a_fi = quat_mult ( foil % a_fc , conjg ( foil % a_ic ) ) if ( dinfo . eq . 1 ) then pret = 'a_fi: ' ot = init_orientation ( foil % a_fi , 'qu' ) call print_orientation ( ot , 'om' , pret ) end if ! express the beam direction in the Bravais reference frame [verified 4/23/11, and again on 11/12/13 ! after changes elsewhere] ex = quat_Lp ( conjg ( foil % a_fc ), dble ( foil % Bn ) ) call TransSpace ( cell , ex , ey , 'c' , 'd' ) call NormVec ( cell , ey , 'c' ) if ( dinfo . eq . 1 ) then io_real ( 1 : 3 ) = ey ( 1 : 3 ) call WriteValue ( '  Beam direction (crystal reference frame) = ' , io_real , 3 , \"('[',F12.5,',',F12.5,',',F12.5,']'/)\" ) end if ! define the foil shape (for now as an elliptic paraboloid z = brx * (x-xc)&#94;2 + bry * (y-yc)&#94;2) if (. not . allocated ( foil % sg )) allocate ( foil % sg ( foil % npix , foil % npiy )) ! if the foil is not bent, then we set this array to zero, otherwise we compute the elliptical paraboloid if (( foil % brx . eq . 0.0 ). and .( foil % bry . eq . 0.0 )) then if ( dinfo . eq . 1 ) then call Message ( ' Initializing a flat foil ' , frm = \"(A)\" ) end if foil % sg = 0.0 else dx = foil % npix * 0.5 dy = foil % npiy * 0.5 do i = 1 , foil % npix tt = foil % brx * ( float ( i ) - dx - foil % cpx ) ** 2 do j = 1 , foil % npiy ! initialize the foil shape function; we assume that the center of the elliptic paraboloid is at location (cpx,cpy) ! presumably, this surface could also be a saddle point if the brx and bry values have opposite sign ... foil % sg ( i , j ) = tt + foil % bry * ( float ( j ) - dy - foil % cpy ) ** 2 + 2.0 * foil % brxy * ( float ( j ) - dy - foil % cpy ) * ( float ( i ) - dx - foil % cpx ) end do end do if ( dinfo . eq . 1 ) then call Message ( ' Initializing a bent foil ' , frm = \"(A)\" ) io_real ( 1 ) = minval ( foil % sg ); io_real ( 2 ) = maxval ( foil % sg ); call WriteValue ( 'Range of local excitation error deviations : ' , io_real , 2 , \"(F10.6,',',F10.6/)\" ) end if end if end subroutine initialize_foil_geometry !-------------------------------------------------------------------------- ! ! SUBROUTINE: makedislocation ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief  Compute the dismat displacement matrix for a given dislocation ! !> @details This subroutine computes the matrix dismat that describes the displacement field !> of a dislocation.  The routine needs the elastic moduli tensor, the transformation !> matrix between the crystal and dislocation reference frames, and the dislocation !> Burgers vector.  The routine computes the arrays dismat and pa, which should be used as follows: !> !> R_k = 2.0*real([ sum_a=1&#94;3 (dismat(k,a)*log(Z_a)) ]), !> !> with Z_a = x_1 + pa(a)*x_2 !> !>  [see CalcR subroutine for more information] !> !> We must also make sure that the x=0 plane of the defect reference frame contains the !> incident beam direction, to avoid getting stacking-fault fringes in the wrong plane... !> Actual stacking faults are added in using a different module (stacking_fault.f90). !> !> @param cell unit cell pointer !> @param defects defect structure !> @param inum !> @param dinfo !> @param DF_L column width ! !> @date   1/ 5/99 MDG 1.0 original !> @date   5/19/01 MDG 2.0 f90 version !> @date  11/27/01 MDG 2.1 added kind support !> @date  06/04/13 MDG 3.0 rewrite !> @date  10/30/13 MDG 3.1 debug of all rotation parts !> @date  06/09/14 MDG 4.0 added cell, defects arguments !> @date  06/10/14 MDG 4.1 added foil as argument !> @date  11/21/15 MDG 4.2 moved foil into defects structure !-------------------------------------------------------------------------- recursive subroutine makedislocation ( cell , defects , inum , dinfo , DF_L ) !DEC$ ATTRIBUTES DLLEXPORT :: makedislocation use math use constants use crystal use math use io use symmetry use rotations IMPLICIT NONE type ( unitcell ), pointer :: cell type ( defecttype ), INTENT ( INOUT ) :: defects integer ( kind = irg ), INTENT ( IN ) :: inum integer ( kind = irg ), INTENT ( IN ) :: dinfo real ( kind = sgl ), INTENT ( IN ) :: DF_L type ( foiltype ) :: foil real ( kind = dbl ) :: zz , zang , zmin real ( kind = sgl ) :: ec ( 6 , 6 ), lec ( 6 , 6 ) real ( kind = dbl ) :: a_dc ( 3 , 3 ), tmp ( 3 ), ex ( 3 ), ey ( 3 ) real ( kind = dbl ) :: Bij ( 3 , 3 ), Hij ( 3 , 3 ) complex ( kind = dbl ) :: a ( 0 : 6 ), b ( 0 : 6 ), c ( 0 : 6 ), d ( 0 : 6 ), e ( 0 : 6 ), ff ( 0 : 6 ), tt ( 5 , 0 : 6 ), s ( 0 : 6 ), roots ( 6 ), & zero , pasq ( 3 ), mat ( 3 , 3 ), aka ( 3 , 3 ), Lia ( 3 , 3 ), Mai ( 3 , 3 ), v ( 3 ), pas integer ( kind = irg ) :: i , j , k , l , imin , ind ( 3 ), jnd ( 3 ) foil = defects % foil ! convert line direction and g-vector to the Cartesian crystal reference frame call TransSpace ( cell , defects % DL ( inum )% u , defects % DL ( inum )% un , 'd' , 'c' ) call TransSpace ( cell , defects % DL ( inum )% g , defects % DL ( inum )% gn , 'r' , 'c' ) ! normalize both vectors call NormVec ( cell , defects % DL ( inum )% un , 'c' ) call NormVec ( cell , defects % DL ( inum )% gn , 'c' ) ! first find the length of the dislocation line inside the foil along the ! dislocation z-axis, which is the line direction; also, compute the intersection ! points of the line with the top and bottom surfaces  (all components in [nm]) zang = CalcAngle ( cell , defects % DL ( inum )% u , dble ( foil % F ), 'd' ) zz = cos ( zang ) if ( abs ( zz ). gt . 0.00001 ) then defects % DL ( inum )% zu = 0.5 * foil % z0 / zz else defects % DL ( inum )% zu = 10000 0.0 ! this is when the dislocation is nearly parallel to the foil end if ! transform the line direction to the foil reference frame tmp = quat_Lp ( foil % a_fc , dble ( defects % DL ( inum )% un ) ) / DF_L if ( dinfo . eq . 1 ) then write ( * , * ) 'transformed line direction ' , tmp , zang , zz end if ! determine the top and bottom intersection coordinates if ( zz . gt . 0.0 ) then ! u points to the top of the foil defects % DL ( inum )% top = ( / defects % DL ( inum )% id + tmp ( 1 ) * defects % DL ( inum )% zu , defects % DL ( inum )% jd + & tmp ( 2 ) * defects % DL ( inum )% zu , 0.5D0 * foil % z0 / ) defects % DL ( inum )% bottom = ( / defects % DL ( inum )% id - tmp ( 1 ) * defects % DL ( inum )% zu , defects % DL ( inum )% jd - & tmp ( 2 ) * defects % DL ( inum )% zu , - 0.5D0 * foil % z0 / ) else ! u points to the bottom of the foil defects % DL ( inum )% top = ( / defects % DL ( inum )% id - tmp ( 1 ) * defects % DL ( inum )% zu , defects % DL ( inum )% jd - & tmp ( 2 ) * defects % DL ( inum )% zu , - 0.5D0 * foil % z0 / ) defects % DL ( inum )% bottom = ( / defects % DL ( inum )% id + tmp ( 1 ) * defects % DL ( inum )% zu , defects % DL ( inum )% jd + & tmp ( 2 ) * defects % DL ( inum )% zu , 0.5D0 * foil % z0 / ) end if if ( dinfo . eq . 1 ) then write ( * , * ) defects % DL ( inum )% id , defects % DL ( inum )% jd write ( * , * ) 'dislocation top intersection at ' , defects % DL ( inum )% top write ( * , * ) 'dislocation bottom intersection at ' , defects % DL ( inum )% bottom end if ! a_dc (crystal to defect)  matrix corrected on 11/29/10 to put defect x-axis in the plane of u and B if ( dinfo . eq . 1 ) then write ( * , * ) 'cartesian quantities' write ( * , * ) 'unit line direction = ' , defects % DL ( inum )% un write ( * , * ) 'unit beam direction = ' , foil % Bn end if ! transform beam direction (currently in foil frame) to cartesian tmp = quat_Lp ( conjg ( foil % a_fc ), dble ( foil % Bn )) !tmp = quat_rotate_vector(conjg(foil%a_fc), (/ 0.0D0, 0.0D0, -1.0D0/) ) call NormVec ( cell , tmp , 'c' ) ! the defect z axis is the line direction and x is in the plane of u and B to avoid the intrinsic discontinuity (cut plane) a_dc ( 3 , 1 : 3 ) = defects % DL ( inum )% un ( 1 : 3 ) call CalcCross ( cell , dble ( defects % DL ( inum )% un ), tmp , ex , 'c' , 'c' , 0 ) call NormVec ( cell , ex , 'c' ) a_dc ( 1 , 1 : 3 ) = ex ( 1 : 3 ) call CalcCross ( cell , dble ( defects % DL ( inum )% un ), ex , ey , 'c' , 'c' , 0 ) call NormVec ( cell , ey , 'c' ) a_dc ( 2 , 1 : 3 ) = ey ( 1 : 3 ) defects % DL ( inum )% a_dc = om2qu ( a_dc ) if ( dinfo . eq . 1 ) then call PrintMatrixd ( 'a_dc' , a_dc ) end if ! a_di (image to defect) defects % DL ( inum )% a_di = quat_mult ( defects % DL ( inum )% a_dc , conjg ( foil % a_ic ) ) defects % DL ( inum )% a_id = conjg ( defects % DL ( inum )% a_di ) if ( dinfo . eq . 1 ) then call print_orientation_d ( init_orientation_d ( defects % DL ( inum )% a_di , 'qu' ), 'om' , 'a_di:     ' ) call print_orientation_d ( init_orientation_d ( defects % DL ( inum )% a_id , 'qu' ), 'om' , 'a_id:     ' ) end if ! finally, get the foil to defect transformation (used in defect module) defects % DL ( inum )% a_df = quat_mult ( defects % DL ( inum )% a_di , conjg ( foil % a_fi ) ) ! Burgers vector (in the defect reference frame !!!) ! first transform Burgers vector to crystal cartesian reference frame call TransSpace ( cell , dble ( defects % DL ( inum )% burg ), tmp , 'd' , 'c' ) ! then convert this to the defect reference frame defects % DL ( inum )% burgd ( 1 : 3 ) = quat_Lp ( defects % DL ( inum )% a_dc , dble ( tmp )) if ( dinfo . eq . 1 ) then write ( * , * ) 'rotated burgers vector  = ' , defects % DL ( inum )% burgd ( 1 : 3 ) end if ! transform the elastic moduli lec = foil % elmo ! transform lec to defect reference frame a_dc = qu2om ( defects % DL ( inum )% a_dc ) call TransFourthRankTensor ( a_dc , lec , ec ) if ( dinfo . eq . 1 ) then write ( * , * ) 'Elasticity tensor in defect reference frame' do i = 1 , 6 write ( * , \"(6(F8.4,2x))\" ) ( ec ( i , j ), j = 1 , 6 ) end do write ( * , * ) '----' end if ! next, create the sextic polynomial zero = cmplx ( 0.0 , 0.0 , dbl ) a = zero ; b = zero ; c = zero ; d = zero ; e = zero ; ff = zero a ( 0 : 2 ) = ( / cmplx ( ec ( 1 , 1 ), 0.0 , dbl ), cmplx ( ec ( 1 , 6 ) * 2.0 , 0.0 , dbl ), cmplx ( ec ( 6 , 6 ), 0.0 , dbl ) / ) b ( 0 : 2 ) = ( / cmplx ( ec ( 6 , 6 ), 0.0 , dbl ), cmplx ( ec ( 2 , 6 ) * 2.0 , 0.0 , dbl ), cmplx ( ec ( 2 , 2 ), 0.0 , dbl ) / ) c ( 0 : 2 ) = ( / cmplx ( ec ( 5 , 5 ), 0.0 , dbl ), cmplx ( ec ( 4 , 5 ) * 2.0 , 0.0 , dbl ), cmplx ( ec ( 4 , 4 ), 0.0 , dbl ) / ) d ( 0 : 2 ) = ( / cmplx ( ec ( 5 , 6 ), 0.0 , dbl ), cmplx ( ec ( 4 , 6 ) + ec ( 2 , 5 ), 0.0 , dbl ), cmplx ( ec ( 2 , 4 ), 0.0 , dbl ) / ) e ( 0 : 2 ) = ( / cmplx ( ec ( 1 , 5 ), 0.0 , dbl ), cmplx ( ec ( 1 , 4 ) + ec ( 5 , 6 ), 0.0 , dbl ), cmplx ( ec ( 4 , 6 ), 0.0 , dbl ) / ) ff ( 0 : 2 ) = ( / cmplx ( ec ( 1 , 6 ), 0.0 , dbl ), cmplx ( ec ( 1 , 2 ) + ec ( 6 , 6 ), 0.0 , dbl ), cmplx ( ec ( 2 , 6 ), 0.0 , dbl ) / ) tt = zero s = zero ! matrix elements do j = 0 , 6 do i = 0 , j tt ( 1 , j ) = tt ( 1 , j ) + a ( j - i ) * b ( i ) tt ( 2 , j ) = tt ( 2 , j ) + d ( j - i ) * e ( i ) tt ( 3 , j ) = tt ( 3 , j ) + a ( j - i ) * d ( i ) tt ( 4 , j ) = tt ( 4 , j ) + b ( j - i ) * e ( i ) tt ( 5 , j ) = tt ( 5 , j ) + c ( j - i ) * ff ( i ) end do end do ! determinant leading to the sextic equation do j = 0 , 6 do i = 0 , j s ( j ) = s ( j ) + tt ( 1 , j - i ) * c ( i ) + 2.0 * tt ( 2 , j - i ) * ff ( i ) - tt ( 3 , j - i ) * d ( i ) - tt ( 4 , j - i ) * e ( i ) - tt ( 5 , j - i ) * ff ( i ) end do end do ! get the complex root pairs call zroots ( s , roots ) ! then, solve the equation for the vector A_k using the roots with positive imaginary part. k = 1 do j = 1 , 6 if ( aimag ( roots ( j )). gt . 0.0 ) then defects % DL ( inum )% pa ( k ) = roots ( j ) k = k + 1 end if end do ! renumber them to avoid the symmetry degeneracy (see page 328 Head et al.) v ( 1 : 3 ) = ec ( 5 , 5 ) + 2.0 * defects % DL ( inum )% pa ( 1 : 3 ) * ec ( 4 , 5 ) + ec ( 4 , 4 ) * defects % DL ( inum )% pa ( 1 : 3 ) ** 2 zmin = 10 0.0 imin = 0 ! where is the smallest value ? do i = 1 , 3 if ( abs ( v ( i )). lt . zmin ) then imin = i zmin = abs ( v ( i )) end if end do ! is the 3rd one the smallest ? if not, then swap with the current 3rd one. if ( imin . ne . 3 ) then pas = defects % DL ( inum )% pa ( imin ) defects % DL ( inum )% pa ( imin ) = defects % DL ( inum )% pa ( 3 ) defects % DL ( inum )% pa ( 3 ) = pas end if pas = defects % DL ( inum )% pa ( 1 ) defects % DL ( inum )% pa ( 1 ) = defects % DL ( inum )% pa ( 2 ) defects % DL ( inum )% pa ( 2 ) = pas ! eliminate really small numbers do i = 1 , 3 if ( abs ( aimag ( defects % DL ( inum )% pa ( i ))). lt . 1.0e-8 ) defects % DL ( inum )% pa ( i ) = cmplx ( real ( defects % DL ( inum )% pa ( i )), 0.0 , dbl ) if ( abs ( real ( defects % DL ( inum )% pa ( i ))). lt . 1.0e-8 ) defects % DL ( inum )% pa ( i ) = cmplx ( 0.0 , aimag ( defects % DL ( inum )% pa ( i )), dbl ) end do if ( dinfo . eq . 1 ) then write ( * , * ) ' sextic roots' do i = 1 , 3 write ( * , * ) defects % DL ( inum )% pa ( i ) end do write ( * , * ) '---' end if !  compute the A_ka vectors (see description on page 328 of Head et al.) pasq = defects % DL ( inum )% pa ** 2 if ( dinfo . eq . 1 ) write ( * , * ) 'Aka vectors' do k = 1 , 3 mat = zero mat ( 1 , 1 ) = ec ( 1 , 1 ) + 2.D0 * defects % DL ( inum )% pa ( k ) * ec ( 1 , 6 ) + ec ( 6 , 6 ) * pasq ( k ) mat ( 2 , 2 ) = ec ( 6 , 6 ) + 2.D0 * defects % DL ( inum )% pa ( k ) * ec ( 2 , 6 ) + ec ( 2 , 2 ) * pasq ( k ) mat ( 3 , 3 ) = ec ( 5 , 5 ) + 2.D0 * defects % DL ( inum )% pa ( k ) * ec ( 4 , 5 ) + ec ( 4 , 4 ) * pasq ( k ) mat ( 2 , 3 ) = ec ( 5 , 6 ) + defects % DL ( inum )% pa ( k ) * ( ec ( 4 , 6 ) + ec ( 2 , 5 )) + ec ( 2 , 4 ) * pasq ( k ) mat ( 1 , 3 ) = ec ( 1 , 5 ) + defects % DL ( inum )% pa ( k ) * ( ec ( 1 , 4 ) + ec ( 5 , 6 )) + ec ( 4 , 6 ) * pasq ( k ) mat ( 1 , 2 ) = ec ( 1 , 6 ) + defects % DL ( inum )% pa ( k ) * ( ec ( 1 , 2 ) + ec ( 6 , 6 )) + ec ( 2 , 6 ) * pasq ( k ) if ( k . eq . 1 ) then aka ( 1 , 1 ) = mat ( 2 , 2 ) * mat ( 3 , 3 ) - mat ( 2 , 3 ) * mat ( 2 , 3 ) aka ( 1 , 2 ) = mat ( 1 , 3 ) * mat ( 2 , 3 ) - mat ( 1 , 2 ) * mat ( 3 , 3 ) aka ( 1 , 3 ) = mat ( 1 , 2 ) * mat ( 2 , 3 ) - mat ( 1 , 3 ) * mat ( 2 , 2 ) end if if ( k . eq . 2 ) then aka ( 2 , 1 ) = mat ( 1 , 3 ) * mat ( 2 , 3 ) - mat ( 1 , 2 ) * mat ( 3 , 3 ) aka ( 2 , 2 ) = mat ( 1 , 1 ) * mat ( 3 , 3 ) - mat ( 1 , 3 ) * mat ( 1 , 3 ) aka ( 2 , 3 ) = mat ( 1 , 3 ) * mat ( 1 , 2 ) - mat ( 1 , 1 ) * mat ( 2 , 3 ) end if if ( k . eq . 3 ) then aka ( 3 , 1 ) = mat ( 1 , 2 ) * mat ( 2 , 3 ) - mat ( 1 , 3 ) * mat ( 2 , 2 ) aka ( 3 , 2 ) = mat ( 1 , 3 ) * mat ( 1 , 2 ) - mat ( 1 , 1 ) * mat ( 2 , 3 ) aka ( 3 , 3 ) = mat ( 1 , 1 ) * mat ( 2 , 2 ) - mat ( 1 , 2 ) * mat ( 1 , 2 ) end if if ( dinfo . eq . 1 ) write ( * , * ) k ,( aka ( k , j ), j = 1 , 3 ) end do aka = transpose ( aka ) ! next, create the L_ialpha matrix ind = ( / 6 , 2 , 4 / ) jnd = ( / 1 , 6 , 5 / ) Lia = zero do i = 1 , 3 do j = 1 , 3 do k = 1 , 3 Lia ( i , j ) = Lia ( i , j ) + ( ec ( ind ( i ), jnd ( k )) + defects % DL ( inum )% pa ( j ) * ec ( ind ( i ), ind ( k ))) * aka ( k , j ) end do end do end do if ( dinfo . eq . 1 ) call PrintMatrixcd ( 'Lia ' , Lia ) ! and invert it call cInvert ( Lia , Mai ) if ( dinfo . eq . 1 ) call PrintMatrixcd ( 'Mai ' , Mai ) ! compute Bij ( real matrix ) Bij = 0.D0 do i = 1 , 3 do j = 1 , 3 do k = 1 , 3 Bij ( i , j ) = Bij ( i , j ) - aimag ( aka ( i , k )) * real ( Mai ( k , j )) - real ( aka ( i , k )) * aimag ( Mai ( k , j )) end do end do end do if ( dinfo . eq . 1 ) call PrintMatrixd ( 'Bij ' , Bij ) ! and invert to get Hij call mInvert ( Bij , Hij ,. FALSE .) if ( dinfo . eq . 1 ) call PrintMatrixd ( 'Hij ' , Hij ) ! compute matrix (this is what actually gets to be used for the ! displacement field); needs to know the Burgers vector. defects % DL ( inum )% dismat = zero do k = 1 , 3 do l = 1 , 3 do i = 1 , 3 do j = 1 , 3 defects % DL ( inum )% dismat ( k , l ) = defects % DL ( inum )% dismat ( k , l ) + defects % DL ( inum )% burgd ( i ) * Hij ( j , i ) * Mai ( l , j ) * aka ( k , l ) end do end do end do end do ! scale by 1/4pi defects % DL ( inum )% dismat = defects % DL ( inum )% dismat * 0.25D0 / cPi if ( dinfo . eq . 1 ) call PrintMatrixcd ( 'dismat' , defects % DL ( inum )% dismat ) ! and return to calling routine end subroutine makedislocation !-------------------------------------------------------------------------- ! ! SUBROUTINE: makestackingfault ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief compute parameters for a stacking fault ! !> @details  This subroutine computes the geometrical parameters for a !> stacking fault.  It computes, among others, the coordinates of the !> centers of the partial dislocations, the intersections of each dislocation !> line with the top and bottom foil surface, and an array that indicates, for !> each image pixel, whether or not the corresponding integration column !> contains this fault; if it does not, the  value in the array is set to !> -10000; if it does, then the value is equal to the point where the fault !> plane intersects with the column, measured from the top surface. !> In short, anything that is needed in the CalcR routine and can be computed !> ahead of time, is computed here.  The routine also calls the makedislocation !> routine to create the partials. ! !> @param cell unit cell pointer !> @param defects defect structure !> @param inum !> @param DF_L column edge length !> @param nx !> @param ny !> @param DF_g !> @param ndl !> @param dinfo trigger for verbose output ! !> @date   11/05/13 MDG 1.0 new attempt to replace faulty original routine !> @date   11/13/13 MDG 1.1 traced error to problem with transformations in defectmodule !> @date   11/13/13 MDG 1.2 changed SF normal transformation for zpos array computation (to be tested) !> @date   06/09/14 MDG 2.0 added defects and cell as arguments !> @date   06/10/14 MDG 2.1 added foil as argument !-------------------------------------------------------------------------- recursive subroutine makestackingfault ( cell , defects , inum , DF_L , nx , ny , DF_g , dinfo ) !DEC$ ATTRIBUTES DLLEXPORT ::  makestackingfault use math use constants use files use rotations use crystal use symmetry use math IMPLICIT NONE type ( defecttype ), INTENT ( INOUT ) :: defects type ( unitcell ), pointer :: cell real ( kind = sgl ), INTENT ( IN ) :: DF_L real ( kind = sgl ), INTENT ( IN ) :: DF_g ( 3 ) integer ( kind = irg ), INTENT ( IN ) :: inum , nx , ny , dinfo real ( kind = sgl ) :: fpn ( 3 ), am ( 4 , 4 ), midpoint ( 3 ), ex ( 3 ), ey ( 3 ),& lptopi ( 3 ), lpboti ( 3 ), tptopi ( 3 ), tpboti ( 3 ), det , A ( 4 ), xx ( 4 ), yy ( 4 ), tmp ( 3 ), & planenormal ( 3 ), rzero ( 3 ), unita ( 3 ) integer ( kind = irg ) :: i , j , info , ipiv , minx , maxx , miny , maxy , ndl ndl = defects % numdisl ! we begin by computing the geometry in the foil reference frame, which is the cartesian frame ! for zero sample tilt;  sample tilts are applied once we known the partial dislocation geometry call TransSpace ( cell , defects % SF ( inum )% plane , tmp , 'r' , 'c' ) call NormVec ( cell , tmp , 'c' ) planenormal = tmp call CalcCross ( cell , planenormal , ( / 0.0 , 0.0 , 1.0 / ), unita , 'c' , 'c' , 0 ) call NormVec ( cell , unita , 'c' ) fpn = planenormal if ( dinfo . eq . 1 ) write ( * , * ) ' unita should have zero third component ' , unita , fpn ! the fault plane goes through the point rzero in the foil center plane rzero = ( / defects % SF ( inum )% id , defects % SF ( inum )% jd , 0.0 / ) ! this leads to the location of the partial dislocation centers defects % SF ( inum )% lpr = rzero + 0.5 * defects % SF ( inum )% sep * unita / DF_L defects % SF ( inum )% tpr = rzero - 0.5 * defects % SF ( inum )% sep * unita / DF_L if ( dinfo . eq . 1 ) write ( * , * ) 'lpr_i = ' , defects % SF ( inum )% lpr ( 1 : 3 ) if ( dinfo . eq . 1 ) write ( * , * ) 'tpr_i = ' , defects % SF ( inum )% tpr ( 1 : 3 ) ! call makedislocation for each of the partials defects % DL ( ndl + 1 )% id = defects % SF ( inum )% lpr ( 1 ) defects % DL ( ndl + 1 )% jd = defects % SF ( inum )% lpr ( 2 ) defects % DL ( ndl + 1 )% u = defects % SF ( inum )% lpu defects % DL ( ndl + 1 )% burg = defects % SF ( inum )% lpb defects % DL ( ndl + 1 )% g = DF_g call makedislocation ( cell , defects , ndl + 1 , dinfo , DF_L ) if ( dinfo . eq . 1 ) write ( * , * ) 'Leading Partial Position ' , defects % DL ( ndl + 1 )% id , defects % DL ( ndl + 1 )% jd defects % DL ( ndl + 2 )% id = defects % SF ( inum )% tpr ( 1 ) defects % DL ( ndl + 2 )% jd = defects % SF ( inum )% tpr ( 2 ) defects % DL ( ndl + 2 )% u = defects % SF ( inum )% tpu defects % DL ( ndl + 2 )% burg = defects % SF ( inum )% tpb defects % DL ( ndl + 2 )% g = DF_g call makedislocation ( cell , defects , ndl + 2 , dinfo , DF_L ) if ( dinfo . eq . 1 ) write ( * , * ) 'Trailing Partial Position ' , defects % DL ( ndl + 2 )% id , defects % DL ( ndl + 2 )% jd ! copy the top and bottom dislocation intersections (computed in make_dislocation) ! into the corresponding variables of the SF record defects % SF ( inum )% lpbot = defects % DL ( ndl + 1 )% bottom defects % SF ( inum )% lptop = defects % DL ( ndl + 1 )% top defects % SF ( inum )% tpbot = defects % DL ( ndl + 2 )% bottom defects % SF ( inum )% tptop = defects % DL ( ndl + 2 )% top ! obviously, these four points need to lie in a single plane; at this point, we check that this is indeed the case ! by computing the volume of the tetrahedron formed by these four points; if the volume is zero, then the ! points are co-planar.  (Use LAPACK's LU-decomposition and compute the product of the diagonal elements of U) am ( 1 : 4 , 1 ) = ( / defects % SF ( inum )% lptop ( 1 : 3 ), 1.0 / ) am ( 1 : 4 , 2 ) = ( / defects % SF ( inum )% lpbot ( 1 : 3 ), 1.0 / ) am ( 1 : 4 , 3 ) = ( / defects % SF ( inum )% tptop ( 1 : 3 ), 1.0 / ) am ( 1 : 4 , 4 ) = ( / defects % SF ( inum )% tpbot ( 1 : 3 ), 1.0 / ) call sgetrf ( 4 , 4 , am , 4 , ipiv , info ) det = abs ( am ( 1 , 1 ) * am ( 2 , 2 ) * am ( 3 , 3 ) * am ( 4 , 4 )) if ( dinfo . eq . 1 ) write ( * , * ) 'determinant (should be zero) = ' , det ! ok, next we need to figure out which image pixels lie on the projection of the stacking fault plane. ! We need to transform the corner points into the image reference frame !!! lptopi = quat_Lp ( defects % foil % a_fi , dble ( defects % SF ( inum )% lptop )) lpboti = quat_Lp ( defects % foil % a_fi , dble ( defects % SF ( inum )% lpbot )) tptopi = quat_Lp ( defects % foil % a_fi , dble ( defects % SF ( inum )% tptop )) tpboti = quat_Lp ( defects % foil % a_fi , dble ( defects % SF ( inum )% tpbot )) if ( dinfo . eq . 1 ) then write ( * , * ) 'SF parameters :' write ( * , * ) lptopi , ' <> ' , lpboti write ( * , * ) tptopi , ' <> ' , tpboti end if ! define the array that will contain the zpos values allocate ( defects % SF ( inum )% zpos ( nx , ny )) defects % SF ( inum )% zpos = - 1000 0.0 ! set all points to be outside the projected SF ! first determine the smaller box minx = nint ( min ( lptopi ( 1 ), lpboti ( 1 ), tptopi ( 1 ), tpboti ( 1 ) )) - 2 maxx = nint ( max ( lptopi ( 1 ), lpboti ( 1 ), tptopi ( 1 ), tpboti ( 1 ) )) + 2 miny = nint ( min ( lptopi ( 2 ), lpboti ( 2 ), tptopi ( 2 ), tpboti ( 2 ) )) - 2 maxy = nint ( max ( lptopi ( 2 ), lpboti ( 2 ), tptopi ( 2 ), tpboti ( 2 ) )) + 2 ! the fault edges may fall outside of the viewing frame (origin at the center !!!) if ( minx . lt .( - nx / 2 + 1 )) minx =- nx / 2 + 1 if ( maxx . gt . nx / 2 ) maxx = nx / 2 if ( miny . lt .( - ny / 2 + 1 )) miny =- ny / 2 + 1 if ( maxy . gt . ny / 2 ) maxy = ny / 2 if ( dinfo . eq . 1 ) write ( * , * ) 'Integer fault box = ' , minx , maxx , miny , maxy ! get the equation of the stacking fault plane in the image reference frame ! first the unit plane normal in image space ! we'll take two vectors: ex = from ltop to ttop; ey = from ltop to lbot ex = tptopi - lptopi ey = lpboti - lptopi call NormVec ( cell , ex , 'c' ) call NormVec ( cell , ey , 'c' ) call CalcCross ( cell , ex , ey , fpn , 'c' , 'c' , 0 ) A ( 1 : 3 ) = fpn ! quat_LPstar( conjg(foil%a_fi), dble(fpn(1:3)) ) midpoint = 0.25 * ( lptopi + lpboti + tptopi + tpboti ) ! quat_LPstar( conjg(foil%a_fi), dble(0.25*(lptopi+lpboti+tptopi+tpboti) )) A ( 4 ) = sum ( A ( 1 : 3 ) * midpoint ) if ( dinfo . eq . 1 ) write ( * , * ) 'fault plane parameters : ' , A , midpoint ! rank the corner points so that the polygon is convex ! call rank_points(tpboti(1:2),lpboti(1:2),lptopi(1:2),tptopi(1:2),xx,yy) xx = ( / lptopi ( 1 ), tptopi ( 1 ), tpboti ( 1 ), lpboti ( 1 ) / ) yy = ( / lptopi ( 2 ), tptopi ( 2 ), tpboti ( 2 ), lpboti ( 2 ) / ) ! for all of the points inside this box: do i = minx , maxx do j = miny , maxy if ( point_inside_polygon ( float ( i ), float ( j ), xx , yy ). gt . 0 ) then ! the point lies inside the projected region, ! so we need the depth of the SF plane at this position, taking into account the ! proper coordinate transformation (depth must be expressed in image reference frame) defects % SF ( inum )% zpos ( i + nx / 2 , j + ny / 2 ) = DF_L * ( A ( 4 ) - A ( 1 ) * float ( i ) - A ( 2 ) * float ( j ) ) / A ( 3 ) end if end do end do if ( dinfo . eq . 1 ) write ( * , * ) 'fault plane pixels determined' ! let's also make sure that the SF displacement vector is translated to the ! cartesian reference frame, so that it can be used directly by the CalcR routine defects % SF ( inum )% lpbc = matmul ( cell % dsm , defects % SF ( inum )% Rdisp ) ! that should do it for the stacking fault...  The rest ! takes place in the CalcR routine. end subroutine makestackingfault !-------------------------------------------------------------------------- ! ! SUBROUTINE: makestackingfaultECCI ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief compute parameters for a stacking fault in ECCI mode ! !> @details  This subroutine computes the geometrical parameters for a !> stacking fault.  It computes, among others, the coordinates of the surface !> intersections of the partial dislocations, and an array that indicates, for !> each image pixel, whether or not the corresponding integration column !> contains this fault; if it does not, the  value in the array is set to !> -10000; if it does, then the value is equal to the point where the fault !> plane intersects with the column, measured from the top surface. !> In short, anything that is needed in the CalcR routine and can be computed !> ahead of time, is computed here.  The routine also calls the makedislocation !> routine to create the partials. ! !> @param cell unit cell pointer !> @param defects defect structure !> @param inum !> @param DF_L column edge length !> @param nx !> @param ny !> @param DF_g !> @param ndl !> @param dinfo trigger for verbose output ! !> @date   11/05/13 MDG 1.0 new attempt to replace faulty original routine !> @date   11/13/13 MDG 1.1 traced error to problem with transformations in defectmodule !> @date   11/13/13 MDG 1.2 changed SF normal transformation for zpos array computation (to be tested) !> @date   12/17/13 MDG 1.3 branch from original routine to deal with different ECCI geometry !> @date   12/18/13 MDG 1.4 debug of stacking fault location array !> @date   06/09/14 MDG 2.0 added cell, SF, YD arguments !> @date   06/10/14 MDG 2.1 added foil argument !-------------------------------------------------------------------------- recursive subroutine makestackingfaultECCI ( cell , defects , inum , DF_L , nx , ny , DF_g , dinfo ) !DEC$ ATTRIBUTES DLLEXPORT :: makestackingfaultECCI use math use constants use files use rotations use crystal use symmetry use math IMPLICIT NONE type ( defecttype ), INTENT ( INOUT ) :: defects type ( unitcell ), pointer :: cell real ( kind = sgl ), INTENT ( IN ) :: DF_L real ( kind = sgl ), INTENT ( IN ) :: DF_g ( 3 ) integer ( kind = irg ), INTENT ( IN ) :: inum , nx , ny , dinfo real ( kind = sgl ) :: fpn ( 3 ), am ( 4 , 4 ), midpoint ( 3 ), ex ( 3 ), ey ( 3 ),& lptopi ( 3 ), lpboti ( 3 ), tptopi ( 3 ), tpboti ( 3 ), det , A ( 4 ), xx ( 4 ), yy ( 4 ), tmp ( 3 ), & planenormal ( 3 ), rzero ( 3 ), unita ( 3 ), lun ( 3 ), tun ( 3 ), zang , zu , zz integer ( kind = irg ) :: i , j , info , ipiv , minx , maxx , miny , maxy , ndl ndl = defects % numYdisl ! we begin by computing the geometry in the foil reference frame, which is the cartesian frame ! for zero sample tilt;  sample tilts are applied once we known the partial dislocation geometry call TransSpace ( cell , defects % SF ( inum )% plane , tmp , 'r' , 'c' ) call NormVec ( cell , tmp , 'c' ) planenormal = tmp call CalcCross ( cell , planenormal , ( / 0.0 , 0.0 , 1.0 / ), unita , 'c' , 'c' , 0 ) call NormVec ( cell , unita , 'c' ) fpn = planenormal if ( dinfo . eq . 1 ) write ( * , * ) ' unita should have zero third component ' , unita , fpn ! the fault plane goes through the point rzero in the foil top surface rzero = ( / defects % SF ( inum )% id , defects % SF ( inum )% jd , sngl ( defects % foil % z0 ) * 0.5 / ) ! this leads to the location of the partial dislocation intersections, and these must ! be Yoffe dislocations !!! defects % SF ( inum )% lpr = rzero + 0.5 * defects % SF ( inum )% sep * unita / DF_L defects % SF ( inum )% tpr = rzero - 0.5 * defects % SF ( inum )% sep * unita / DF_L if ( dinfo . eq . 1 ) write ( * , * ) 'lpr_i = ' , defects % SF ( inum )% lpr ( 1 : 3 ) if ( dinfo . eq . 1 ) write ( * , * ) 'tpr_i = ' , defects % SF ( inum )% tpr ( 1 : 3 ) ! convert line directions to the Cartesian crystal reference frame call TransSpace ( cell , defects % SF ( inum )% lpu , lun , 'd' , 'c' ) call TransSpace ( cell , defects % SF ( inum )% tpu , tun , 'd' , 'c' ) ! normalize both vectors call NormVec ( cell , lun , 'c' ) call NormVec ( cell , tun , 'c' ) ! call makeYSHdislocation for each of the partials [must be done in main program] !  if (.not. allocated(YD)) allocate(defects%YD(3*maxdefects)) defects % YD ( ndl + 1 )% id = defects % SF ( inum )% lpr ( 1 ) defects % YD ( ndl + 1 )% jd = defects % SF ( inum )% lpr ( 2 ) defects % YD ( ndl + 1 )% u ( 1 : 3 ) = dble ( defects % SF ( inum )% lpu ( 1 : 3 )) defects % YD ( ndl + 1 )% burg ( 1 : 3 ) = dble ( defects % SF ( inum )% lpb ( 1 : 3 )) defects % YD ( ndl + 1 )% g = DF_g defects % YD ( ndl + 1 )% sig = defects % SF ( inum )% poisson defects % YD ( ndl + 2 )% id = defects % SF ( inum )% tpr ( 1 ) defects % YD ( ndl + 2 )% jd = defects % SF ( inum )% tpr ( 2 ) defects % YD ( ndl + 2 )% u ( 1 : 3 ) = dble ( defects % SF ( inum )% tpu ( 1 : 3 )) defects % YD ( ndl + 2 )% burg ( 1 : 3 ) = dble ( defects % SF ( inum )% tpb ( 1 : 3 )) defects % YD ( ndl + 2 )% g = DF_g defects % YD ( ndl + 2 )% sig = defects % SF ( inum )% poisson call makeYSHdislocation ( cell , defects , ndl + 1 , dinfo , DF_L ) if ( dinfo . eq . 1 ) write ( * , * ) 'Leading Partial Position ' , defects % YD ( ndl + 1 )% id , defects % YD ( ndl + 1 )% jd call makeYSHdislocation ( cell , defects , ndl + 2 , dinfo , DF_L ) if ( dinfo . eq . 1 ) write ( * , * ) 'Trailing Partial Position ' , defects % YD ( ndl + 2 )% id , defects % YD ( ndl + 2 )% jd ! first find the length of the dislocation line inside the foil along the ! dislocation z-axis, which is the line direction; also, compute the intersection ! points of the line with the top and bottom surfaces  (all components in [nm]) zang = CalcAngle ( cell , defects % YD ( ndl + 1 )% u , defects % foil % F , 'd' ) zz = cos ( zang ) if ( abs ( zz ). gt . 0.00001 ) then zu = abs ( defects % foil % z0 / zz ) else zu = 10000 0.0 ! this is when the dislocation is nearly parallel to the foil end if ! transform the line direction to the foil reference frame tmp = quat_Lp ( conjg ( defects % foil % a_fc ), dble ( lun ) ) / DF_L ! determine the top and bottom intersection coordinates defects % YD ( ndl + 1 )% top = ( / defects % YD ( ndl + 1 )% id , defects % YD ( ndl + 1 )% jd , defects % foil % z0 * 0.5 / ) if ( zz . gt . 0.0 ) then ! u points to the top of the foil defects % YD ( ndl + 1 )% bottom = ( / defects % YD ( ndl + 1 )% id - tmp ( 1 ) * zu , defects % YD ( ndl + 1 )% jd - tmp ( 2 ) * zu , - 0.5D0 * defects % foil % z0 / ) else ! u points to the bottom of the foil defects % YD ( ndl + 1 )% bottom = ( / defects % YD ( ndl + 1 )% id + tmp ( 1 ) * zu , defects % YD ( ndl + 1 )% jd + tmp ( 2 ) * zu , - 0.5D0 * defects % foil % z0 / ) end if ! first find the length of the dislocation line inside the foil along the ! dislocation z-axis, which is the line direction; also, compute the intersection ! points of the line with the top and bottom surfaces  (all components in [nm]) zang = CalcAngle ( cell , defects % YD ( ndl + 2 )% u , defects % foil % F , 'd' ) zz = cos ( zang ) if ( abs ( zz ). gt . 0.00001 ) then zu = abs ( defects % foil % z0 / zz ) else zu = 10000 0.0 ! this is when the dislocation is nearly parallel to the foil end if ! transform the line direction to the foil reference frame tmp = quat_Lp ( conjg ( defects % foil % a_fc ), dble ( tun ) ) / DF_L ! determine the top and bottom intersection coordinates defects % YD ( ndl + 2 )% top = ( / defects % YD ( ndl + 2 )% id , defects % YD ( ndl + 2 )% jd , defects % foil % z0 * 0.5 / ) if ( zz . gt . 0.0 ) then ! u points to the top of the foil defects % YD ( ndl + 2 )% bottom = ( / defects % YD ( ndl + 2 )% id - tmp ( 1 ) * zu , defects % YD ( ndl + 2 )% jd - tmp ( 2 ) * zu , - 0.5D0 * defects % foil % z0 / ) else ! u points to the bottom of the foil defects % YD ( ndl + 2 )% bottom = ( / defects % YD ( ndl + 2 )% id + tmp ( 1 ) * zu , defects % YD ( ndl + 2 )% jd + tmp ( 2 ) * zu , - 0.5D0 * defects % foil % z0 / ) end if ! copy the top and bottom dislocation intersections ! into the corresponding variables of the SF record defects % SF ( inum )% lpbot = defects % YD ( ndl + 1 )% bottom defects % SF ( inum )% lptop = defects % YD ( ndl + 1 )% top defects % SF ( inum )% tpbot = defects % YD ( ndl + 2 )% bottom defects % SF ( inum )% tptop = defects % YD ( ndl + 2 )% top ! obviously, these four points need to lie in a single plane; at this point, we check that this is indeed the case ! by computing the volume of the tetrahedron formed by these four points; if the volume is zero, then the ! points are co-planar.  (Use LAPACK's LU-decomposition and compute the product of the diagonal elements of U) am ( 1 : 4 , 1 ) = ( / defects % SF ( inum )% lptop ( 1 : 3 ), 1.0 / ) am ( 1 : 4 , 2 ) = ( / defects % SF ( inum )% lpbot ( 1 : 3 ), 1.0 / ) am ( 1 : 4 , 3 ) = ( / defects % SF ( inum )% tptop ( 1 : 3 ), 1.0 / ) am ( 1 : 4 , 4 ) = ( / defects % SF ( inum )% tpbot ( 1 : 3 ), 1.0 / ) call sgetrf ( 4 , 4 , am , 4 , ipiv , info ) det = abs ( am ( 1 , 1 ) * am ( 2 , 2 ) * am ( 3 , 3 ) * am ( 4 , 4 )) if ( dinfo . eq . 1 ) write ( * , * ) 'determinant (should be zero) = ' , det ! ok, next we need to figure out which image pixels lie on the projection of the stacking fault plane. ! We need to transform the corner points into the image reference frame !!! lptopi = quat_Lp ( defects % foil % a_fi , dble ( defects % SF ( inum )% lptop )) lpboti = quat_Lp ( defects % foil % a_fi , dble ( defects % SF ( inum )% lpbot )) tptopi = quat_Lp ( defects % foil % a_fi , dble ( defects % SF ( inum )% tptop )) tpboti = quat_Lp ( defects % foil % a_fi , dble ( defects % SF ( inum )% tpbot )) if ( dinfo . eq . 1 ) then write ( * , * ) 'SF parameters :' write ( * , * ) lptopi , ' <> ' , lpboti write ( * , * ) tptopi , ' <> ' , tpboti end if ! define the array that will contain the zpos values allocate ( defects % SF ( inum )% zpos ( nx , ny )) defects % SF ( inum )% zpos = - 1000 0.0 ! set all points to be outside the projected SF ! first determine the smaller box minx = nint ( min ( lptopi ( 1 ), lpboti ( 1 ), tptopi ( 1 ), tpboti ( 1 ) )) - 2 maxx = nint ( max ( lptopi ( 1 ), lpboti ( 1 ), tptopi ( 1 ), tpboti ( 1 ) )) + 2 miny = nint ( min ( lptopi ( 2 ), lpboti ( 2 ), tptopi ( 2 ), tpboti ( 2 ) )) - 2 maxy = nint ( max ( lptopi ( 2 ), lpboti ( 2 ), tptopi ( 2 ), tpboti ( 2 ) )) + 2 ! the fault edges may fall outside of the viewing frame (origin at the center !!!) if ( minx . lt .( - nx / 2 + 1 )) minx =- nx / 2 + 1 if ( maxx . gt . nx / 2 ) maxx = nx / 2 if ( miny . lt .( - ny / 2 + 1 )) miny =- ny / 2 + 1 if ( maxy . gt . ny / 2 ) maxy = ny / 2 if ( dinfo . eq . 1 ) write ( * , * ) 'Integer fault box = ' , minx , maxx , miny , maxy ! get the equation of the stacking fault plane in the image reference frame ! first the unit plane normal in image space ! we'll take two vectors: ex = from ltop to ttop; ey = from ltop to lbot ex = tptopi - lptopi ey = lpboti - lptopi call NormVec ( cell , ex , 'c' ) call NormVec ( cell , ey , 'c' ) call CalcCross ( cell , ex , ey , fpn , 'c' , 'c' , 0 ) A ( 1 : 3 ) = fpn ! quat_LPstar( conjg(foil%a_fi), dble(fpn(1:3)) ) midpoint = 0.25 * ( lptopi + lpboti + tptopi + tpboti ) ! quat_LPstar( conjg(foil%a_fi), dble(0.25*(lptopi+lpboti+tptopi+tpboti) )) A ( 4 ) = sum ( A ( 1 : 3 ) * midpoint ) if ( dinfo . eq . 1 ) write ( * , * ) 'fault plane parameters : ' , A , midpoint ! rank the corner points so that the polygon is convex ! call rank_points(tpboti(1:2),lpboti(1:2),lptopi(1:2),tptopi(1:2),xx,yy) xx = ( / lptopi ( 1 ), tptopi ( 1 ), tpboti ( 1 ), lpboti ( 1 ) / ) yy = ( / lptopi ( 2 ), tptopi ( 2 ), tpboti ( 2 ), lpboti ( 2 ) / ) ! for all of the points inside this box: do i = minx , maxx do j = miny , maxy if ( point_inside_polygon ( float ( i ), float ( j ), xx , yy ). gt . 0 ) then ! the point lies inside the projected region, ! so we need the depth of the SF plane at this position, taking into account the ! proper coordinate transformation (depth must be expressed in image reference frame) defects % SF ( inum )% zpos ( i + nx / 2 , j + ny / 2 ) = ( A ( 4 ) - A ( 1 ) * float ( i ) - A ( 2 ) * float ( j ) ) / A ( 3 ) end if end do end do if ( dinfo . eq . 1 ) write ( * , * ) 'fault plane pixels determined' ! let's also make sure that the SF displacement vector is translated to the ! cartesian reference frame, so that it can be used directly by the CalcR routine defects % SF ( inum )% lpbc = matmul ( cell % dsm , defects % SF ( inum )% Rdisp ) ! that should do it for the stacking fault...  The rest ! takes place in the CalcR routine. end subroutine makestackingfaultECCI !-------------------------------------------------------------------------- ! ! FUNCTION: YSHDisp ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief  compute the displacement field of an inclined dislocation intersecting the foil surface ! !> @details compute the displacement field of an inclined dislocation intersecting the top surface of !> the foil, taking into account surface relaxations for the isotropic elastic case (cubic only) ... !> !> equations are based on the Shaibani&Hazzledine 1981 paper, along with special limits for !> the alpha->0 case, which were derived by MDG using Mathematica. ! !> @paraqm defects defects structure !> @param x dislocation x-coordinate !> @param y dislocation y-coordinate !> @param z dislocation z-coordinate !> @param ii dislocation number ! !> @todo There is a problem with dislocations normal to the foil surface, likely a typographical error !> in the SH paper; this needs to be resolved further, which may require explicit repetition of all !> analytical computations! Mathematica gives an infinite limit for the bx edge case when normal !> to the foil surface. ! !> @date    1/5/99  MDG 1.0 original !> @date    5/19/01 MDG 2.0 f90 version !> @date   11/27/01 MDG 2.1 added kind support !> @date   06/04/13 MDG 3.0 rewrite !> @date   11/21/13 MDG 3.1 verification !> @date   06/09/14 MDG 4.0 added defects as argument !-------------------------------------------------------------------------- recursive function YSHDisp ( defects , x , y , z , ii ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: YSHDisp use constants IMPLICIT NONE type ( defecttype ), INTENT ( INOUT ) :: defects real ( kind = dbl ), INTENT ( IN ) :: x , y , z integer ( kind = irg ), INTENT ( IN ) :: ii real ( kind = dbl ) :: eta , zeta , etap , zetap , r , oms , omts , xx , sgn , om , omp , AA , BB , BBp , th , & k , lam , alA , alB , u , v , w , ms , S , du , dv , dw , qe , me , De , qx , mx , Dx , rr , eps real ( kind = dbl ) :: res ( 3 ) ! initialize the geometrical parameters eta = y * defects % YD ( ii )% ca - z * defects % YD ( ii )% sa zeta = y * defects % YD ( ii )% sa + z * defects % YD ( ii )% ca etap = - y * defects % YD ( ii )% ca - z * defects % YD ( ii )% sa zetap = y * defects % YD ( ii )% sa - z * defects % YD ( ii )% ca r = sqrt ( x ** 2 + y ** 2 + z ** 2 ) oms = 1.D0 - defects % YD ( ii )% sig omts = 1.D0 - 2.D0 * defects % YD ( ii )% sig ! cover the special case of negative x values (based on IDL tests) xx = x sgn = 1.D0 if ( xx . lt . 0.D0 ) then xx = dabs ( x ) sgn = - 1.D0 else sgn = 1.D0 end if ! more parameters om = ( datan2 ( y , xx ) - datan2 ( eta , xx ) + datan2 ( xx * r * defects % YD ( ii )% sa , eta * y + xx ** 2 * defects % YD ( ii )% ca )) omp = ( datan2 ( y , xx ) - datan2 ( etap , xx ) + datan2 ( xx * r * defects % YD ( ii )% sa , etap * y - xx ** 2 * defects % YD ( ii )% ca )) AA = r - z BB = r - zeta BBp = r - zetap th = 2.D0 * oms * ( omp - om ) lam = omts * dlog ( BBp / BB ) alA = dlog ( AA ) alB = dlog ( BB ) u = 0.D0 v = 0.D0 w = 0.D0 eps = 1.0D-6 ! screw component first if ( abs ( defects % YD ( ii )% bs ). gt . eps ) then ms = xx * sin ( 2.D0 * defects % YD ( ii )% alpha ) / r / BB S = defects % YD ( ii )% bs / ( 4.D0 * cPi ) if ( defects % YD ( ii )% alpha . gt . 0.01 ) then du = xx * ms + 2.D0 * eta * defects % YD ( ii )% ca ** 2 / BB + 2.D0 * omts * defects % YD ( ii )% cota * ( - 1.D0 + defects % YD ( ii )% ca + & defects % YD ( ii )% ca * alA - y * defects % YD ( ii )% sa / AA - alB ) - sin ( 2.D0 * defects % YD ( ii )% alpha ) dv = y * ms - 2.D0 * xx * defects % YD ( ii )% ca / BB - defects % YD ( ii )% sa * ( omp - om ) + 2.D0 * omts * defects % YD ( ii )% cota * & ( xx * defects % YD ( ii )% sa / AA - om * defects % YD ( ii )% ca ) dw = z * ms + defects % YD ( ii )% ca * ( omp - om ) - 2.D0 * omts * om * defects % YD ( ii )% ca else du = 2.D0 * y / ( r - z ) dv = - 2.D0 * xx * ( r + z ) / ( xx ** 2 + y ** 2 ) dw = cPi + datan2 ( y , xx ) - datan2 ( - y , xx ) end if u = u + du * S v = v - sgn * dv * S w = w + sgn * dw * S end if ! then the edge component in the y-z plane if ( abs ( defects % YD ( ii )% be ). gt . eps ) then qe = xx * ( 1.D0 / BBp - 1.D0 / BB + 2.D0 * z * defects % YD ( ii )% ca / BB ** 2 ) me = - qe / r - 4.D0 * oms * xx * defects % YD ( ii )% ca ** 2 / r / BB De = defects % YD ( ii )% be / ( 8.D0 * cPi * oms ) if ( defects % YD ( ii )% alpha . gt . 0.01 ) then k = 4.D0 * oms * omts * defects % YD ( ii )% cota ** 2 du = xx * me + lam + 2.D0 * defects % YD ( ii )% ca * ( z + 2.D0 * oms * eta * defects % YD ( ii )% sa ) / BB - 4.D0 * oms * defects % YD ( ii )% sa ** 2 + & k * ( 1.D0 - defects % YD ( ii )% ca - defects % YD ( ii )% ca * alA + y * defects % YD ( ii )% sa / AA + alB ) dv = y * me + qe * defects % YD ( ii )% sa + th * defects % YD ( ii )% ca + k * ( - xx * defects % YD ( ii )% sa / AA + om * defects % YD ( ii )% ca ) dw = z * me + qe * defects % YD ( ii )% ca + th * defects % YD ( ii )% sa - 2.D0 * xx * defects % YD ( ii )% ca * ( 1.D0 / BBp + omts / BB ) + k * om * defects % YD ( ii )% sa !    write (*,*) du,dv,dw else rr = xx ** 2 + y ** 2 du = 2.D0 * z / ( r - z ) + 4.D0 * xx ** 2 * ( defects % YD ( ii )% sig * rr - r ** 2 ) / r / AA ** 2 / ( r + z ) + 2.D0 * omts * oms * (( xx ** 2 + z * ( z - r )) / AA ** 2 + alA ) + & omts * dlog (( r + z ) / AA ) dv = 4.D0 * xx * y * ( rr * defects % YD ( ii )% sig - r ** 2 ) / r / AA ** 2 / ( r + z ) + 2.D0 * xx * y * ( rr + 2.D0 * z * ( r + z )) * oms * omts / rr ** 2 + & 2.D0 * oms * ( cPi + datan2 ( y , xx ) - datan2 ( - y , xx )) dw = 4.D0 * xx * rr * defects % YD ( ii )% sig * ( z - 2.D0 * r * oms ) / r / AA ** 2 / ( r + z ) end if u = u + du * De v = v + sgn * dv * De w = w + sgn * dw * De end if ! and finally the bx edge component if ( abs ( defects % YD ( ii )% bx ). gt . eps ) then qx = etap / BBp - eta / BB - 2.D0 * z * eta * defects % YD ( ii )% ca / BB ** 2 mx = - qx / r + 2.D0 * omts * y * defects % YD ( ii )% ca / r / BB Dx = defects % YD ( ii )% bx / ( 8.D0 * cPi * oms ) if ( defects % YD ( ii )% alpha . gt . 0.01 ) then k = 4.D0 * oms * omts * defects % YD ( ii )% cota ** 2 du = xx * mx + th + k * ( xx * defects % YD ( ii )% ta / AA - om ) dv = y * mx + qx * defects % YD ( ii )% sa - lam * defects % YD ( ii )% ca - 2.D0 * defects % YD ( ii )% ca * & ( z * defects % YD ( ii )% ca + omts * y * defects % YD ( ii )% sa ) / BB + & k * ( - 1.D0 + defects % YD ( ii )% ca - alA + y * defects % YD ( ii )% ta / AA + defects % YD ( ii )% ca * alB ) dw = z * mx + qx * defects % YD ( ii )% ca - lam * defects % YD ( ii )% sa - 2.D0 * etap * defects % YD ( ii )% ca / BBp + & 4.D0 * defects % YD ( ii )% ca * ( oms * y * defects % YD ( ii )% ca - omts * z * defects % YD ( ii )% sa ) / BB + & k * defects % YD ( ii )% ta * ( defects % YD ( ii )% ca - alA + defects % YD ( ii )% ca * alB ) + 4.D0 * oms * defects % YD ( ii )% ca * defects % YD ( ii )% cota else rr = xx ** 2 + y ** 2 du = - 4.D0 * xx * y * ( rr * defects % YD ( ii )% sig - r ** 2 ) / r / AA ** 2 / ( r + z ) - 2.D0 * xx * y * ( rr + 2.D0 * z * ( r + z )) * oms * omts / rr ** 2 + & 2.D0 * oms * ( cPi + datan2 ( y , xx ) - datan2 ( - y , xx )) dv = 2.D0 * z / ( r - z ) - 4.D0 * y ** 2 * ( defects % YD ( ii )% sig * rr - r ** 2 ) / r / AA ** 2 / ( r + z ) + 2.D0 * omts * oms * ( - 1.D0 + ( z * ( r - z ) - y ** 2 ) / AA ** 2 - alA ) - & omts * dlog (( r + z ) / AA ) dw = 0.D0 ! not sure if this limit is correct ... Mathematica gives a directedinfinity value for the limit, which might mean that the ! original YSH expression in the paper is incorrect for the w component ... this needs to be rederived and verified !!! end if u = u + sgn * du * Dx v = v + dv * Dx w = w + dw * Dx end if ! and return the displacement components res = ( / u , v , w / ) end function YSHDisp !-------------------------------------------------------------------------- ! ! FUNCTION: makeYSHdislocation ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief pre-compute geometrical parametersf or the Yoffe&Shaibani&Hazzledine (YSH) !> surface-relaxed dislocation in an elastically isotropic matrix. ! !> @details These parameters are then used in the CalcR routine. !> !> We implemented the YSH expressions instead of Yoffe's !> since the former are more easily handled for numerical computations. !> !> SH have redefined the x-y-z reference frame used by Yoffe to fall along !> the dislocation line itself.  As a result, the Burgers vector must be decomposed !> into a screw component and two edge components, one in the plane of the !> discontinuity, the other normal to that plane (which is by definition the x-axis). !> Check the SH paper for more details. ! !> @param cell unit cell pointer !> @param defects defects structure !> @param i dislocation number !> @param dinfo triggers verbose output !> @param L column edge length ! !> @todo Convert IO to Write_Value calls ! !> @date  1/5/99  MDG 1.0 original !> @date  5/19/01 MDG 2.0 f90 version !> @date 11/27/01 MDG 2.1 added kind support !> @date 06/04/13 MDG 3.0 rewrite+added quaternions !> @date 11/21/13 MDG 3.1 verification + rewrite of output handling !> @date 06/09/14 MDG 4.0 added cell and defects arguments !> @date 06/10/14 MDG 4.1 added foil argument !-------------------------------------------------------------------------- recursive subroutine makeYSHdislocation ( cell , defects , i , dinfo , L ) !DEC$ ATTRIBUTES DLLEXPORT :: makeYSHdislocation use constants use crystal use io use error use rotations IMPLICIT NONE type ( unitcell ), pointer :: cell type ( defecttype ), INTENT ( INOUT ) :: defects integer ( kind = irg ), INTENT ( IN ) :: i integer ( kind = irg ), INTENT ( IN ) :: dinfo real ( kind = sgl ), INTENT ( IN ) :: L real ( kind = dbl ) :: alpha , beta , tu ( 3 ), tx ( 3 ), ty ( 3 ), te ( 3 ), tb ( 3 ), bl , fx ( 3 ), fy ( 3 ), fz ( 3 ), & dx , dy , a_di ( 3 , 3 ), io_real ( 3 ) ! first, determine the alpha angle between the ! negative z-axis, which is really the negative foil normal, and the line direction ! (make sure to reduce the angle to [0,90] interval). ! Each YSH dislocation must have a line direction that points INTO the foil !!! alpha = CalcAngle ( cell , defects % foil % F , dble ( defects % YD ( i )% u ), 'd' ) * 18 0.0 / cPi if ( alpha . ge . 9 0.0 ) then alpha = 18 0.0 - alpha if ( dinfo . eq . 1 ) then io_real ( 1 : 3 ) = defects % foil % F ( 1 : 3 ) call WriteValue ( 'Foil normal = ' , io_real , 3 , \"('[',3F5.1,']')\" ) io_real ( 1 : 3 ) = defects % YD ( i )% u ( 1 : 3 ) call WriteValue ( 'line direction = ' , io_real , 3 , \"('[',3F5.1,']')\" ) io_real ( 1 ) = alpha call WriteValue ( ' --> alpha angle = ' , io_real , 1 , \"(F5.1)\" ) end if alpha = alpha * cPi / 18 0.0 else call FatalError ( 'makeYSHdislocation' , 'YSH dislocations must have line directions pointing into the foil ! ' ) end if ! normalize the line direction call TransSpace ( cell , defects % YD ( i )% u , tu , 'd' , 'c' ) call NormVec ( cell , tu , 'c' ) ! consider the case of alpha=0 separately if ( alpha . gt . 0.0 ) then call TransSpace ( cell , defects % foil % F , ty , 'd' , 'c' ) call NormVec ( cell , ty , 'c' ) !  F call CalcCross ( cell , tu , ty , tx , 'c' , 'c' , 0 ) ! x = u x F call NormVec ( cell , tx , 'c' ) call CalcCross ( cell , tx , tu , te , 'c' , 'c' , 0 ) ! e = x x u call NormVec ( cell , te , 'c' ) call CalcCross ( cell , ty , tx , ty , 'c' , 'c' , 0 ) call NormVec ( cell , ty , 'c' ) else tx = defects % foil % qn call CalcCross ( cell , tx , tu , te , 'c' , 'c' , 0 ) ! e = x x u call NormVec ( cell , te , 'c' ) end if bl = CalcLength ( cell , defects % YD ( i )% burg , 'd' ) if ( dinfo . eq . 1 ) then io_real ( 1 : 3 ) = tx ( 1 : 3 ) call WriteValue ( ' tx = ' , io_real , 3 , \"(3F5.1)\" ) io_real ( 1 : 3 ) = te ( 1 : 3 ) call WriteValue ( ' te = ' , io_real , 3 , \"(3F5.1)\" ) io_real ( 1 : 3 ) = tu ( 1 : 3 ) call WriteValue ( ' tu = ' , io_real , 3 , \"(3F5.1)\" ) io_real ( 1 : 3 ) = ty ( 1 : 3 ) call WriteValue ( ' ty = ' , io_real , 3 , \"(3F5.1)\" ) io_real ( 1 ) = bl call WriteValue ( ' bl = ' , io_real , 1 , \"(F8.3)\" ) end if call TransSpace ( cell , defects % YD ( i )% burg , tb , 'd' , 'c' ) call NormVec ( cell , tb , 'c' ) defects % YD ( i )% bx = bl * CalcDot ( cell , tb , tx , 'c' ) ! edge component normal to cut plane defects % YD ( i )% be = bl * CalcDot ( cell , tb , te , 'c' ) ! edge component in cut plane defects % YD ( i )% bs = bl * CalcDot ( cell , tb , tu , 'c' ) ! screw component if ( dinfo . eq . 1 ) then io_real ( 1 : 3 ) = ( / defects % YD ( i )% bx , defects % YD ( i )% be , defects % YD ( i )% bs / ) call WriteValue ( 'Burgers vector components (bx,be,bs) ' , io_real , 3 , \"(3F12.6)\" ) end if ! verified MDG 7/31/11 ! we will also need to know the quaternion rotation between the dislocation reference frame ! and the foil reference frame, so that we can transform the foil coordinates to defect ! coordinates...  We need the angle beta between the defect x axis (tx) and the foil x axis, ! which is the first column of the foil%a_fc matrix ...   We must make sure that this angle ! is measured in a CCW sense. ! projection of defect x axis onto foil x and y axes call TransSpace ( cell , defects % foil % q , fx , 'd' , 'c' ) call TransSpace ( cell , defects % foil % F , fz , 'd' , 'c' ) call NormVec ( cell , fx , 'c' ) call NormVec ( cell , fz , 'c' ) call CalcCross ( cell , fz , fx , fy , 'c' , 'c' , 0 ) dx = CalcDot ( cell , tx , fx , 'c' ) dy = CalcDot ( cell , tx , fy , 'c' ) ! use the arctan function to get the angle with correct quadrant computation defects % YD ( i )% beta = atan2 ( dy , dx ) !+ cPi*0.5 if ( dinfo . eq . 1 ) then io_real ( 1 ) = dx call WriteValue ( ' dx = ' , io_real , 1 , \"(F8.3)\" ) io_real ( 1 ) = dy call WriteValue ( ' dy = ' , io_real , 1 , \"(F8.3)\" ) io_real ( 1 ) = defects % YD ( i )% beta call WriteValue ( ' beta = ' , io_real , 1 , \"(F8.3)\" ) end if ! convert to a quaternion beta = defects % YD ( i )% beta a_di ( 1 , 1 : 3 ) = ( / cos ( beta ), sin ( beta ), 0.D0 / ) a_di ( 2 , 1 : 3 ) = ( / - sin ( beta ), cos ( beta ), 0.D0 / ) a_di ( 3 , 1 : 3 ) = ( / 0.D0 , 0.D0 , 1.D0 / ) defects % YD ( i )% a_di = om2qu ( a_di ) defects % YD ( i )% a_id = conjg ( defects % YD ( i )% a_di ) if ( dinfo . eq . 1 ) then write ( * , * ) 'beta = ' , beta write ( * , * ) defects % YD ( i )% a_di write ( * , * ) defects % YD ( i )% a_id end if ! finally some geometrical parameters needed for the displacement field computation... defects % YD ( i )% alpha = alpha defects % YD ( i )% ca = cos ( alpha ) defects % YD ( i )% sa = sin ( alpha ) defects % YD ( i )% ta = tan ( alpha ) defects % YD ( i )% cota = 1.0 / defects % YD ( i )% ta ! that's it! the rest is handled in the CalcR routine. end subroutine makeYSHdislocation !-------------------------------------------------------------------------- ! ! FUNCTION: InitializeEshelbyInclusion ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief pre-compute all parameters for an isotropic Eshelby ellipsoidal inclusion ! !> @details These parameters are then used in the CalcR routine. !> !> We implemented the Eshelby expressions based on Mura's 1987 book. ! !> @param cell unit cell pointer !> @param defects defects structure !> @param i dislocation number !> @param dinfo triggers verbose output !> @param L column edge length ! !> @date 12/11/15 MDG 1.0 initial version based on trial IDL script !> @date 12/13/15 MDG 1.1 corrections to some of the auxiliary expressions; sphere limit is now correct !-------------------------------------------------------------------------- recursive subroutine InitializeEshelbyInclusion ( cell , defects , i , dinfo , L , npix , npiy ) !DEC$ ATTRIBUTES DLLEXPORT :: InitalizeEshelbyInclusion use local use constants use typedefs use math IMPLICIT NONE type ( unitcell ), pointer :: cell type ( defecttype ), INTENT ( INOUT ) :: defects integer ( kind = irg ), INTENT ( IN ) :: i integer ( kind = irg ), INTENT ( IN ) :: dinfo real ( kind = sgl ), INTENT ( IN ) :: L integer ( kind = irg ), INTENT ( IN ) :: npix integer ( kind = irg ), INTENT ( IN ) :: npiy integer ( kind = irg ) :: j , k , ll , ii complex ( kind = dbl ) :: t , s , q real ( kind = dbl ) :: rsq , v , w , modt , lambda , II1 , II3 , EF , EE , Delta , dth real ( kind = dbl ) :: r2 ( 3 ), IIinside ( 3 ), IIJinside ( 3 , 3 ), maxr ( 3 ), ES ( 3 , 3 , 3 , 3 ), ESV ( 6 , 6 ) real ( kind = dbl ), allocatable :: z (:) ! set the size of the elliptic integral lookup tables defects % Einclusions ( i )% nLUT = 500 ! copy the defect position defects % Einclusions ( i )% xpos = defects % Einclusions ( i )% xyz ( 1 ) * 0.5 * float ( npix ) defects % Einclusions ( i )% ypos = defects % Einclusions ( i )% xyz ( 2 ) * 0.5 * float ( npiy ) defects % Einclusions ( i )% zpos = defects % Einclusions ( i )% xyz ( 3 ) * defects % foil % z0 ! copy the semi-axis into the individual variables defects % Einclusions ( i )% a1 = defects % Einclusions ( i )% a123 ( 1 ) defects % Einclusions ( i )% a2 = defects % Einclusions ( i )% a123 ( 2 ) defects % Einclusions ( i )% a3 = defects % Einclusions ( i )% a123 ( 3 ) ! rearrange the ellipsoid semi-axes from largest to smallest and initialize the ! corresponding permutation matrix as well as the rotation matrix based on the ! eigenvectors... ! to be implemented ! determine the maximum vector length for the computation of theta(lambda) maxr = ( / 51 2.D0 , 51 2.D0 , 10 0.D0 / ) ! to be corrected ... ! elastic parameters defects % Einclusions ( i )% omnu = 1.D0 - 2.D0 * defects % Einclusions ( i )% nu defects % Einclusions ( i )% pre = 1.D0 / ( 8.D0 * cPi * ( 1.D0 - defects % Einclusions ( i )% nu )) ! volume defects % Einclusions ( i )% V = 4.D0 * cPi * defects % Einclusions ( i )% a1 * defects % Einclusions ( i )% a2 * defects % Einclusions ( i )% a3 / 3.D0 ! and some other derived constants defects % Einclusions ( i )% a12 = defects % Einclusions ( i )% a1 ** 2 defects % Einclusions ( i )% a22 = defects % Einclusions ( i )% a2 ** 2 defects % Einclusions ( i )% a32 = defects % Einclusions ( i )% a3 ** 2 defects % Einclusions ( i )% asq = ( / defects % Einclusions ( i )% a12 , defects % Einclusions ( i )% a22 , defects % Einclusions ( i )% a32 / ) defects % Einclusions ( i )% eta = defects % Einclusions ( i )% a12 + defects % Einclusions ( i )% a22 + defects % Einclusions ( i )% a32 ! used in s variable (to compute lambda) defects % Einclusions ( i )% ss1 = 3.D0 * ( defects % Einclusions ( i )% a12 * defects % Einclusions ( i )% a22 + & defects % Einclusions ( i )% a22 * defects % Einclusions ( i )% a32 + & defects % Einclusions ( i )% a32 * defects % Einclusions ( i )% a12 ) defects % Einclusions ( i )% svec = 3.D0 * ( / defects % Einclusions ( i )% eta - defects % Einclusions ( i )% a12 , & defects % Einclusions ( i )% eta - defects % Einclusions ( i )% a22 , & defects % Einclusions ( i )% eta - defects % Einclusions ( i )% a32 / ) ! used in q variable (to compute lambda) defects % Einclusions ( i )% qs1 = ( defects % Einclusions ( i )% eta - 3.D0 * defects % Einclusions ( i )% a12 ) * & ( defects % Einclusions ( i )% eta - 3.D0 * defects % Einclusions ( i )% a22 ) * & ( defects % Einclusions ( i )% eta - 3.D0 * defects % Einclusions ( i )% a32 ) defects % Einclusions ( i )% qvec1 = 9.D0 * ( / defects % Einclusions ( i )% a12 , defects % Einclusions ( i )% a22 , defects % Einclusions ( i )% a32 / ) defects % Einclusions ( i )% qvec2 = 9.D0 * ( / defects % Einclusions ( i )% a12 ** 2 + 2.D0 * defects % Einclusions ( i )% a22 * defects % Einclusions ( i )% a32 ,& defects % Einclusions ( i )% a22 ** 2 + 2.D0 * defects % Einclusions ( i )% a12 * defects % Einclusions ( i )% a32 ,& defects % Einclusions ( i )% a32 ** 2 + 2.D0 * defects % Einclusions ( i )% a12 * defects % Einclusions ( i )% a22 / ) ! Delta matrix  (we'll symmetrize it) defects % Einclusions ( i )% Deltaij = 0.D0 defects % Einclusions ( i )% Deltaij ( 1 , 2 ) = defects % Einclusions ( i )% a12 - defects % Einclusions ( i )% a22 defects % Einclusions ( i )% Deltaij ( 1 , 3 ) = defects % Einclusions ( i )% a12 - defects % Einclusions ( i )% a32 defects % Einclusions ( i )% Deltaij ( 2 , 3 ) = defects % Einclusions ( i )% a22 - defects % Einclusions ( i )% a32 defects % Einclusions ( i )% Deltaij ( 2 , 1 ) = defects % Einclusions ( i )% Deltaij ( 1 , 2 ) defects % Einclusions ( i )% Deltaij ( 3 , 1 ) = defects % Einclusions ( i )% Deltaij ( 1 , 3 ) defects % Einclusions ( i )% Deltaij ( 3 , 2 ) = defects % Einclusions ( i )% Deltaij ( 2 , 3 ) defects % Einclusions ( i )% Deltaij = dsqrt ( defects % Einclusions ( i )% Deltaij ) ! second argument of Elliptic functions defects % Einclusions ( i )% kEl = defects % Einclusions ( i )% Deltaij ( 1 , 2 ) / defects % Einclusions ( i )% Deltaij ( 1 , 3 ) ! some other prefactors defects % Einclusions ( i )% preI1 = 3.D0 * & defects % Einclusions ( i )% V / defects % Einclusions ( i )% Deltaij ( 1 , 2 ) ** 2 / defects % Einclusions ( i )% Deltaij ( 1 , 3 ) defects % Einclusions ( i )% preI3 = 3.D0 * & defects % Einclusions ( i )% V / defects % Einclusions ( i )% Deltaij ( 2 , 3 ) ** 2 / defects % Einclusions ( i )% Deltaij ( 1 , 3 ) defects % Einclusions ( i )% s3 = dsqrt ( 3.D0 ) defects % Einclusions ( i )% c1 = 2.D0 ** ( 1.D0 / 3.D0 ) defects % Einclusions ( i )% c2 = 6.D0 * 2.D0 ** ( 2.D0 / 3.D0 ) defects % Einclusions ( i )% math = dasin ( dsqrt ( defects % Einclusions ( i )% Deltaij ( 1 , 3 ) ** 2 / defects % Einclusions ( i )% a12 )) ! next we need the largest possible lambda value; we'll have the user pass in the coordinates of the furthest point r2 = maxr ** 2 rsq = sum ( r2 ) s = dcmplx ( ( rsq - defects % Einclusions ( i )% eta ) ** 2 + sum ( defects % Einclusions ( i )% svec * r2 ) - defects % Einclusions ( i )% ss1 , 0.D0 ) q = dcmplx ( - 2.D0 * rsq ** 3 - 3.D0 * defects % Einclusions ( i )% eta * rsq ** 2 + rsq * ( 3.D0 * defects % Einclusions ( i )% eta ** 2 + & sum ( defects % Einclusions ( i )% qvec1 * r2 )) - sum ( defects % Einclusions ( i )% qvec2 * r2 ) - defects % Einclusions ( i )% qs1 , 0.D0 ) t = ( q + sqrt ( q * q - 4.D0 * s * s * s ) ) ** ( 1.D0 / 3.D0 ) v = real ( t ) w = abs ( imag ( t )) modt = v ** 2 + w ** 2 lambda = ( rsq - defects % Einclusions ( i )% eta ) / 3.D0 + & ( v + defects % Einclusions ( i )% s3 * w ) * ( 2.D0 * real ( s ) + defects % Einclusions ( i )% c1 * modt ) / defects % Einclusions ( i )% c2 / modt defects % Einclusions ( i )% mith = dasin ( defects % Einclusions ( i )% Deltaij ( 1 , 3 ) / dsqrt ( defects % Einclusions ( i )% a12 + lambda )) ! pre-compute the look-up tables for the elliptic integrals allocate ( z ( defects % Einclusions ( i )% nLUT )) dth = ( defects % Einclusions ( i )% math - defects % Einclusions ( i )% mith ) / dble ( defects % Einclusions ( i )% nLUT - 1 ) do j = 1 , defects % Einclusions ( i )% nLUT z ( j ) = defects % Einclusions ( i )% mith + dble ( j - 1 ) * dth end do allocate ( defects % Einclusions ( i )% EFLUT ( defects % Einclusions ( i )% nLUT )) allocate ( defects % Einclusions ( i )% EELUT ( defects % Einclusions ( i )% nLUT )) defects % Einclusions ( i )% EFLUT = 0.D0 defects % Einclusions ( i )% EELUT = 0.D0 do j = 1 , defects % Einclusions ( i )% nLUT defects % Einclusions ( i )% EFLUT ( j ) = el1k ( z ( j ), defects % Einclusions ( i )% kEl ) defects % Einclusions ( i )% EELUT ( j ) = el2k ( z ( j ), defects % Einclusions ( i )% kEl ) end do defects % Einclusions ( i )% thpre = dble ( defects % Einclusions ( i )% nLUT - 1 ) / ( defects % Einclusions ( i )% math - defects % Einclusions ( i )% mith ) deallocate ( z ) ! also, when lambda=0 (inside the ellipsoid), we can simplify things a little ! by using precomputed II and IIJ arrays; in that case we use math to compute ! the integrals EF = defects % Einclusions ( i )% EFLUT ( defects % Einclusions ( i )% nLUT ) EE = defects % Einclusions ( i )% EELUT ( defects % Einclusions ( i )% nLUT ) Delta = defects % Einclusions ( i )% a1 * defects % Einclusions ( i )% a2 * defects % Einclusions ( i )% a3 ! first order integrals II1 = defects % Einclusions ( i )% preI1 * ( EF - EE ) II3 = defects % Einclusions ( i )% preI3 * ( defects % Einclusions ( i )% Deltaij ( 1 , 3 ) * defects % Einclusions ( i )% a22 / Delta - EE ) IIinside = ( / II1 , 3.D0 * defects % Einclusions ( i )% V / Delta - II1 - II3 , II3 / ) defects % Einclusions ( i )% IIinside = IIinside ! second order integrals IIJinside = 0.D0 IIJinside ( 1 , 2 ) = - ( defects % Einclusions ( i )% IIinside ( 1 ) - defects % Einclusions ( i )% IIinside ( 2 )) / defects % Einclusions ( i )% Deltaij ( 1 , 2 ) ** 2 IIJinside ( 2 , 1 ) = IIJinside ( 1 , 2 ) IIJinside ( 1 , 3 ) = - ( defects % Einclusions ( i )% IIinside ( 1 ) - defects % Einclusions ( i )% IIinside ( 3 )) / defects % Einclusions ( i )% Deltaij ( 1 , 3 ) ** 2 IIJinside ( 3 , 1 ) = IIJinside ( 1 , 3 ) IIJinside ( 2 , 3 ) = - ( defects % Einclusions ( i )% IIinside ( 2 ) - defects % Einclusions ( i )% IIinside ( 3 )) / defects % Einclusions ( i )% Deltaij ( 2 , 3 ) ** 2 IIJinside ( 3 , 2 ) = IIJinside ( 2 , 3 ) IIJinside ( 1 , 1 ) = defects % Einclusions ( i )% V / defects % Einclusions ( i )% a12 / Delta - ( IIJinside ( 1 , 2 ) + IIJinside ( 1 , 3 )) / 3.D0 IIJinside ( 2 , 2 ) = defects % Einclusions ( i )% V / defects % Einclusions ( i )% a22 / Delta - ( IIJinside ( 2 , 1 ) + IIJinside ( 2 , 3 )) / 3.D0 IIJinside ( 3 , 3 ) = defects % Einclusions ( i )% V / defects % Einclusions ( i )% a32 / Delta - ( IIJinside ( 3 , 1 ) + IIJinside ( 3 , 2 )) / 3.D0 defects % Einclusions ( i )% IIJinside = IIJinside ! and finally the Eshelby S tensor for inside the inclusion (i.e., lambda=0) ES = 0.D0 do ii = 1 , 3 do j = 1 , 3 do k = 1 , 3 do ll = 1 , 3 Es ( ii , j , k , ll ) = kdelta ( ii , j ) * kdelta ( k , ll ) * ( 2.D0 * defects % Einclusions ( i )% nu * IIinside ( ii ) - IIinside ( k ) + & defects % Einclusions ( i )% a123 ( ii ) ** 2 * IIJinside ( k , ii )) + ( kdelta ( ii , k ) * kdelta ( j , ll ) + kdelta ( j , k ) * kdelta ( ii , ll )) * & ( defects % Einclusions ( i )% a123 ( ii ) ** 2 * IIJinside ( ii , j ) - IIinside ( j ) + ( 1.D0 - defects % Einclusions ( i )% nu ) * & ( IIinside ( k ) + IIinside ( ll ))) end do end do end do end do ES = ES / ( 8.0 * cPi * ( 1.D0 - defects % Einclusions ( i )% nu )) defects % Einclusions ( i )% EshelbyS = ES ! convert this tensor to Voigt notation as a 6x6 matrix ESV = 0.D0 ESV ( 1 , 1 ) = ES ( 1 , 1 , 1 , 1 ) ESV ( 2 , 2 ) = ES ( 2 , 2 , 2 , 2 ) ESV ( 3 , 3 ) = ES ( 3 , 3 , 3 , 3 ) ESV ( 4 , 4 ) = ES ( 2 , 3 , 2 , 3 ) ESV ( 5 , 5 ) = ES ( 3 , 1 , 3 , 1 ) ESV ( 6 , 6 ) = ES ( 1 , 2 , 1 , 2 ) ESV ( 1 , 2 ) = ES ( 1 , 1 , 2 , 2 ) ESV ( 1 , 3 ) = ES ( 1 , 1 , 3 , 3 ) ESV ( 2 , 1 ) = ES ( 2 , 2 , 1 , 1 ) ESV ( 3 , 1 ) = ES ( 3 , 3 , 1 , 1 ) ESV ( 3 , 2 ) = ES ( 3 , 3 , 2 , 2 ) ESV ( 2 , 3 ) = ES ( 2 , 2 , 3 , 3 ) defects % Einclusions ( i )% ESV = ESV end subroutine InitializeEshelbyInclusion !-------------------------------------------------------------------------- ! ! FUNCTION: Eshelby_disp ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief compute the actual displacement vector for an isotropic Eshelby ellipsoidal inclusion ! !> We implemented the Eshelby expressions based on Mura's 1987 book. ! !> @param defects defects structure !> @param i Einclusion number !> @param xyz coordinate triplet ! !> @date 12/11/15 MDG 1.0 initial version based on trial IDL script !> @date 12/13/15 MDG 1.1 corrections to some of the auxiliary expressions; sphere limit is now correct !-------------------------------------------------------------------------- recursive function Eshelby_disp ( defects , i , xyz ) result ( u ) !DEC$ ATTRIBUTES DLLEXPORT :: Eshelby_disp ! ! implement the displacement field equations for an isotropic ellipsoidal inclusion ! use local use math IMPLICIT NONE type ( defecttype ), INTENT ( IN ) :: defects integer ( kind = irg ), INTENT ( IN ) :: i real ( kind = dbl ), INTENT ( IN ) :: xyz ( 3 ) real ( kind = dbl ) :: u ( 3 ) integer ( kind = irg ) :: itheta , j , l , k real ( kind = dbl ) :: Treps , r2 ( 3 ), rsq , dd , v , w , modt , lambda , xx , thetaEl , dtheta , sigma , & II1 , II3 , II ( 3 ), IIJ ( 3 , 3 ), phici ( 3 ), psicjli ( 3 , 3 , 3 ), c , t1 , t2 , dt ( 3 ), Delta , EE , EF complex ( kind = dbl ) :: t , s , q Treps = defects % Einclusions ( i )% epsstar ( 1 , 1 ) + defects % Einclusions ( i )% epsstar ( 2 , 2 ) + defects % Einclusions ( i )% epsstar ( 3 , 3 ) r2 = xyz ** 2 rsq = sum ( r2 ) dd = dsqrt ( xyz ( 1 ) ** 2 / defects % Einclusions ( i )% a12 + xyz ( 2 ) ** 2 / defects % Einclusions ( i )% a22 + xyz ( 3 ) ** 2 / defects % Einclusions ( i )% a32 ) !  first we need the lambda value for this point lambda = 0.D0 if ( dd . gt . 1.D0 ) then s = dcmplx ( ( rsq - defects % Einclusions ( i )% eta ) ** 2 + sum ( defects % Einclusions ( i )% svec * r2 ) - defects % Einclusions ( i )% ss1 , 0.D0 ) q = dcmplx ( - 2.D0 * rsq ** 3 - 3.D0 * defects % Einclusions ( i )% eta * rsq ** 2 + rsq * ( 3.D0 * defects % Einclusions ( i )% eta ** 2 + & sum ( defects % Einclusions ( i )% qvec1 * r2 )) - sum ( defects % Einclusions ( i )% qvec2 * r2 ) - defects % Einclusions ( i )% qs1 , 0.D0 ) t = ( q + sqrt ( q * q - 4.D0 * s * s * s ) ) ** ( 1.D0 / 3.D0 ) v = real ( t ) w = abs ( imag ( t )) modt = v ** 2 + w ** 2 lambda = ( rsq - defects % Einclusions ( i )% eta ) / 3.D0 + ( v + defects % Einclusions ( i )% s3 * w ) * & ( 2.D0 * real ( s ) + defects % Einclusions ( i )% c1 * modt ) / defects % Einclusions ( i )% c2 / modt end if ! predefine a couple of parameters dt = ( / defects % Einclusions ( i )% a12 , defects % Einclusions ( i )% a22 , defects % Einclusions ( i )% a32 / ) + lambda Delta = dsqrt ( dt ( 1 ) * dt ( 2 ) * dt ( 3 )) if ( lambda . ne . 0.D0 ) then ! next, we compute the elliptic integrals by interpolating the look-up tables thetaEl = dasin ( dsqrt ( defects % Einclusions ( i )% Deltaij ( 1 , 3 ) ** 2 / dt ( 1 ))) xx = defects % Einclusions ( i )% thpre * ( thetaEl - defects % Einclusions ( i )% mith ) itheta = int ( xx ) + 1 dtheta = xx - int ( xx ) if ( itheta . lt . defects % Einclusions ( i )% nLUT ) then EF = ( 1.D0 - dtheta ) * defects % Einclusions ( i )% EFLUT ( itheta ) + dtheta * defects % Einclusions ( i )% EFLUT ( itheta + 1 ) EE = ( 1.D0 - dtheta ) * defects % Einclusions ( i )% EELUT ( itheta ) + dtheta * defects % Einclusions ( i )% EELUT ( itheta + 1 ) else EF = defects % Einclusions ( i )% EFLUT ( itheta ) EE = defects % Einclusions ( i )% EELUT ( itheta ) end if ! first order integrals II1 = defects % Einclusions ( i )% preI1 * ( EF - EE ) II3 = defects % Einclusions ( i )% preI3 * ( defects % Einclusions ( i )% Deltaij ( 1 , 3 ) * dt ( 2 ) / Delta - EE ) II = ( / II1 , 3.D0 * defects % Einclusions ( i )% V / Delta - II1 - II3 , II3 / ) ! second order integrals IIJ ( 1 , 2 ) = - ( II ( 1 ) - II ( 2 )) / defects % Einclusions ( i )% Deltaij ( 1 , 2 ) ** 2 IIJ ( 2 , 1 ) = IIJ ( 1 , 2 ) IIJ ( 1 , 3 ) = - ( II ( 1 ) - II ( 3 )) / defects % Einclusions ( i )% Deltaij ( 1 , 3 ) ** 2 IIJ ( 3 , 1 ) = IIJ ( 1 , 3 ) IIJ ( 2 , 3 ) = - ( II ( 2 ) - II ( 3 )) / defects % Einclusions ( i )% Deltaij ( 2 , 3 ) ** 2 IIJ ( 3 , 2 ) = IIJ ( 2 , 3 ) IIJ ( 1 , 1 ) = defects % Einclusions ( i )% V / dt ( 1 ) / Delta - ( IIJ ( 1 , 2 ) + IIJ ( 1 , 3 )) / 3.0 IIJ ( 2 , 2 ) = defects % Einclusions ( i )% V / dt ( 2 ) / Delta - ( IIJ ( 2 , 1 ) + IIJ ( 2 , 3 )) / 3.0 IIJ ( 3 , 3 ) = defects % Einclusions ( i )% V / dt ( 3 ) / Delta - ( IIJ ( 3 , 1 ) + IIJ ( 3 , 2 )) / 3.0 else II = defects % Einclusions ( i )% IIinside IIJ = defects % Einclusions ( i )% IIJinside end if ! then we need to evaluate the large number of \"tensor\" components in the phi_{,j} ! and psi_{,jli} arrays, as defined in Muro's 1987 book; we've actually computed the ! derivatives ourselves similar to the computation of eq. (11.40) phici = ( / - xyz ( 1 ) * II ( 1 ), - xyz ( 2 ) * II ( 2 ), - xyz ( 3 ) * II ( 3 ) / ) c = 0.D0 sigma = ( xyz ( 1 ) / dt ( 1 )) ** 2 + ( xyz ( 2 ) / dt ( 2 )) ** 2 + ( xyz ( 3 ) / dt ( 3 )) ** 2 do j = 1 , 3 do l = 1 , 3 do k = 1 , 3 if ( lambda . ne . 0.D0 ) c = 3.D0 * defects % Einclusions ( i )% V * lambda * xyz ( k ) * xyz ( j ) * xyz ( l ) / dt ( k ) / dt ( j ) / dt ( l ) / Delta / sigma t1 = kdelta ( j , l ) * xyz ( k ) * ( II ( k ) - defects % Einclusions ( i )% asq ( j ) * IIJ ( j , k )) t2 = ( kdelta ( k , j ) * xyz ( l ) + kdelta ( k , l ) * xyz ( j )) * ( II ( l ) - defects % Einclusions ( i )% asq ( j ) * IIJ ( j , l )) psicjli ( j , l , k ) = - t1 - t2 + c end do end do end do do k = 1 , 3 ! middle term of Mura eq. (11.30) u ( k ) = - 2.0 * defects % Einclusions ( i )% nu * Treps * phici ( k ) ! last term do l = 1 , 3 u ( k ) = u ( k ) - 4.D0 * ( 1.D0 - defects % Einclusions ( i )% nu ) * defects % Einclusions ( i )% epsstar ( k , l ) * phici ( l ) end do ! first term do j = 1 , 3 do l = 1 , 3 u ( k ) = u ( k ) + defects % Einclusions ( i )% epsstar ( j , l ) * psicjli ( j , l , k ) end do end do end do u = defects % Einclusions ( i )% pre * u end function Eshelby_disp !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- ! and finally, here we compute the total displacements for an integration column !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- ! ! SUBROUTINE: CalcR ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief returns the total displacement vector for each slice in a column ! !> @details Note that the end result MUST be expressed in the cartesian reference frame ! ! !> @param cell unit cell pointer !> @param defects defect structure !> @param i integer x coordinate !> @param j integer y coordinate ! !> @note This entire routine was thoroughly verified after the quaternion conversion ! !> !> General comment for those who wish to add other defects... !> !> the general procedure to implement a defect displacement field is as follows: !> - if the defect has its own reference frame, then transform (xpos,ypos,zpos) to !>   that frame (see the dislocation section below for an example), and then do !>   the computation of the displacement vector and express it in the cartesian frame. !> !> - if the defect uses the foil reference frame (e.g., voids, inclusions), then use tmpf !>  as the current position vector. !> @date  10/20/98 MDG 1.0 original !> @date   5/22/01 MDG 2.0 f90 !> @date  11/27/01 MDG 2.1 added kind support !> @date  03/26/13 MDG 3.0 updated IO !> @date  10/30/13 MDG 3.1 debug of coordinate rotations !> @date  11/13/13 MDG 3.2 finally, the bug has been found! !> @date  06/09/14 MDG 4.0 introduced defects argument and simplified routine !> @date  06/10/14 MDG 4.1 added foil argument !> @date  11/23/15 MDG 4.2 removed foil argument and placed it inside defects !-------------------------------------------------------------------------- recursive subroutine CalcR ( cell , defects , i , j ) !DEC$ ATTRIBUTES DLLEXPORT :: CalcR use local use constants use crystal use rotations IMPLICIT NONE type ( unitcell ), pointer :: cell type ( defecttype ), INTENT ( INOUT ) :: defects integer ( kind = irg ), INTENT ( IN ) :: i , j integer ( kind = irg ) :: k , islice , ii real ( kind = dbl ) :: dis , xpos , ypos , zpos , sumR ( 3 ), thick , tmp ( 3 ), tmp2 ( 3 ), & tmpf ( 3 ), u ( 3 ), zaamp , zaphase , zar , zai , zr ( 3 ), zi ( 3 ), & zt , fx , fy , fz , a_fm ( 3 , 3 ), ar !,& !                                nu,x,y,z,zn,t,pre,r1,r2,r3,th,rn complex ( kind = dbl ) :: za ( 3 ) complex ( kind = sgl ) :: zero logical :: isvoid ! scale the image coordinates with respect to the origin at the center of the image xpos = float ( i - defects % DF_npix / 2 ) * defects % DF_L ypos = float ( j - defects % DF_npiy / 2 ) * defects % DF_L ! determine the starting point of the z-integration for the tilted foil ! this depends on the foil normal components which give the equation ! of the top foil plane as F . r = z0/2, from which we get zt... a_fm = qu2om ( defects % foil % a_fm ) fx = a_fm ( 3 , 1 ) fy = a_fm ( 3 , 2 ) fz = a_fm ( 3 , 3 ) zt = defects % foil % zb * 0.5 - ( fx * xpos + fy * ypos ) / fz ! initialize some other variables thick = defects % foil % zb zero = cmplx ( 0.0 , 0.0 ) ! loop over all slices (this is the main loop) sliceloop : do islice = 1 , defects % DF_nums ! zpos is the position down the column, starting at zt (in image coordinates) zpos = zt - float ( islice ) * defects % DF_slice ! set the displacements to zero sumR = 0.0 ! set the position in the foil reference frame tmpf = quat_Lp ( defects % foil % a_fi , dble ( ( / xpos , ypos , zpos / )) ) !------------ !----VOIDS--- !------------ ! voids are easy to deal with; we simply return -10000 for each point tmpf that lies inside ! one of the voids; the calling routine then knows to use the void scattering matrix. if ( defects % numvoids . ne . 0 ) then ! are we inside a void ? isvoid = . FALSE . voidloop : do ii = 1 , defects % numvoids ! subtract the void position from the current slice position to get the relative position vector tmp = tmpf - ( / defects % voids ( ii )% xpos , defects % voids ( ii )% ypos , defects % voids ( ii )% zpos / ) dis = CalcLength ( cell , tmp , 'c' ) if ( dis . lt . defects % voids ( ii )% radius ) then ! inside void isvoid = . TRUE . exit voidloop end if end do voidloop ! skip the rest of the computation for this slice if we are inside a void if ( isvoid . eqv .. TRUE .) then defects % DF_R ( islice , 1 ) = - 1000 0.0 cycle sliceloop end if end if ! ok, if we get here, then we're not inside a void... !------------------ !----CURVED FOIL--- !------------------ ! first we take the foil shape into account using equations (8.28) and (8.29) sumR = sumR + float ( islice ) * defects % DF_slice * defects % foil % sg ( i , j ) * defects % DF_gstar !----------------- !--DISLOCATIONS-- !----------------- ! let's put a few dislocations in ... (see section 8.4.2) do ii = 1 , defects % numdisl ! compute the difference vector between the current (xpos,ypos,zpos) in the foil reference frame ! and the defect center coordinate tmp2 = tmpf - dble (( / defects % DF_L * defects % DL ( ii )% id , defects % DF_L * defects % DL ( ii )% jd , defects % DL ( ii )% zfrac * defects % foil % z0 / )) ! then convert the difference vector to the defect reference frame for this dislocation (we will only need the x and y coordinates) tmp = quat_Lp ( defects % DL ( ii )% a_df , tmp2 ) ! compute x1 + p_alpha x2  (eq. 8.38) za ( 1 : 3 ) = tmp ( 1 ) + defects % DL ( ii )% pa ( 1 : 3 ) * tmp ( 2 ) ! compute the displacement vector u (eq. 8.38) [this expands the log of a complex number and takes the real part only, ! taking proper care of the branch cut] if ( tmp ( 1 ). gt . 0.0 ) then do k = 1 , 3 zar = real ( za ( k )) zai = aimag ( za ( k )) zaamp = abs ( za ( k )) zaphase = abs ( zai / zar ) zr ( k ) = log ( zaamp ) zi ( k ) = atan ( zaphase ) if ( zar . le . 0.0 ) then if ( zai . lt . 0.0 ) zi ( k ) = - cPi + zi ( k ) if ( zai . eq . 0.0 ) zi ( k ) = cPi if ( zai . gt . 0.0 ) zi ( k ) = cPi - zi ( k ) else if ( zai . lt . 0.0 ) zi ( k ) = - zi ( k ) end if end do else do k = 1 , 3 zar = real ( za ( k )) zai = aimag ( za ( k )) zaamp = abs ( za ( k )) zaphase = abs ( zai / zar ) zr ( k ) = log ( zaamp ) zi ( k ) = atan ( zaphase ) if ( zar . le . 0.0 ) then if ( zai . gt . 0.0 ) zi ( k ) = cPi - zi ( k ) if ( zai . eq . 0.0 ) zi ( k ) = cPi if ( zai . lt . 0.0 ) zi ( k ) = cPi + zi ( k ) else if ( zai . lt . 0.0 ) zi ( k ) = 2.0 * cPi - zi ( k ) if ( zai . eq . 0.0 ) zi ( k ) = 0.0 end if end do end if u = 2.0 * real ( matmul ( defects % DL ( ii )% dismat , cmplx ( zr , zi ))) ! transform displacement vector u to the Cartesian crystal reference frame u = quat_Lp ( conjg ( defects % DL ( ii )% a_dc ), dble ( u ) ) sumR = sumR + u end do !------------------------------------- !--SURFACE INTERSECTING DISLOCATIONS-- !------------------------------------- ! this part is mostly used for ECCI-type image simulations, not for EM or STEM, ! although it could probably be used there as well; we would need to extend it ! to incorporate both top and bottom foil surfaces ! do we have any dislocations with surface relaxations ?  YSH model if ( defects % numYdisl . gt . 0 ) then do ii = 1 , defects % numYdisl ! first, figure out what the coordinates are in the YSH reference frame for this dislocation ... ! translate to the defect origin tmp = tmpf - ( / defects % DF_L * defects % YD ( ii )% id , defects % DF_L * defects % YD ( ii )% jd , defects % foil % z0 * 0.5 / ) ! rotate into the defect reference frame tmp = quat_Lp ( conjg ( defects % YD ( ii )% a_di ), tmp ) ! compute the displacement vector !     u = sngl(YSHDisp(dble(tmp(2)),-dble(tmp(1)),dble(tmp(3)),ii)) u = sngl ( YSHDisp ( defects , dble ( tmp ( 1 )), dble ( tmp ( 2 )), dble ( tmp ( 3 )), ii )) ! and rotate back to the image reference frame u = quat_Lp ( conjg ( defects % YD ( ii )% a_id ), u ) u = quat_Lp ( defects % foil % a_ic , u ) ! that should do it ! sumR = sumR + u end do end if !-------------------- !--STACKING FAULTS-- !-------------------- ! stacking faults (this is easy because we've already done all the work in the stacking_fault module) ! all we need is the z-value at which the stacking fault plane is crossed in this particular image ! column; from that point on, we simply add the leading partial Burgers vector to the total displacement. do ii = 1 , defects % numsf if (( zpos . lt . defects % SF ( ii )% zpos ( i , j )). and .( defects % SF ( ii )% zpos ( i , j ). ne . - 1000 0.0 )) then sumR = sumR + defects % SF ( ii )% lpbc end if end do !-------------------- !--LARGE INCLUSIONS--  currently commented out !-------------------- ! Mader's expression for the displacement field of a large inclusion !   if (0.eq.1.) then !    nu = 0.25 !    ce = 0.005 !    rn = 25.0*DF_L !    x = (float(i-DF_npix/2)-0.5)*DF_L !    y = (float(j-DF_npiy/2)-0.5)*DF_L !    z = float(k)*DF_slice !    zn = 100.5*DF_slice !    t = DF_slice * DF_nums !    pre = (1.0+nu)/(3.0*(1.0-nu))*ce*rn**3 ! !    r1 = sqrt(x**2+y**2+(z-zn)**2) !    r2 = sqrt(x**2+y**2+(z+zn)**2) !    r3 = sqrt(x**2+y**2+(2.0*t-z-zn)**2) ! !    if (((r1.eq.0.0).or.(r2.eq.0.0)).or.(r3.eq.0.0)) then !      return !    else !     dis = (1.0/r1**3+(3.0-4.0*nu)/r2**3-6.0*z*(z+zn)/r2**5+(3.0-4.0*nu)/r3**3-6.0*(t-z)*(2.0*t-z-zn)/r3**5) !     rx = x*dis !     ry = y*dis !     rz = (z-zn)/r1**3-(3.0-4.0*nu)*((z+zn)/r2**3+(2.0*t-z-zn)/r3**3)-6.0*z*(z+zn)**2/r2**5 + & !          2.0*z/r2**3+6.0*(t-z)*(2.0*t-z-zn)**2/r3**5-2.0*(t-z)/r3**3 ! !     sumR = pre*(/ rx, ry, rz /) !     return !    end if !   end if !-------------------- !--SMALL INCLUSIONS-- !-------------------- ! then the coherent precipitates, using the model in section 8.4.1 if ( defects % numinc . gt . 0 ) then do ii = 1 , defects % numinc ! subtract the inclusion position from the current slice position to get the relative position vector tmp = tmpf - ( / defects % inclusions ( ii )% xpos , defects % inclusions ( ii )% ypos , defects % inclusions ( ii )% zpos / ) dis = CalcLength ( cell , tmp , 'c' ) if ( dis . ge . defects % inclusions ( ii )% radius ) then ! outside particle tmp = tmp * ( defects % inclusions ( ii )% radius / dis ) ** 3 end if sumR = sumR + defects % inclusions ( ii )% C * tmp end do end if !--------------------- !--SMALL EINCLUSIONS-- !--------------------- ! then the coherent ellipsoidally distorted precipitates, using Eshelby's model if ( defects % numEinc . gt . 0 ) then do ii = 1 , defects % numEinc ! subtract the inclusion position from the current slice position to get the relative position vector tmp = tmpf - ( / defects % Einclusions ( ii )% xpos , defects % Einclusions ( ii )% ypos , defects % Einclusions ( ii )% zpos / ) ! and also get the position vector for the mirror image inclusion, to make sure we get a traction-free surface... tmp2 = tmpf - ( / defects % Einclusions ( ii )% xpos , defects % Einclusions ( ii )% ypos , - defects % Einclusions ( ii )% zpos / ) u = Eshelby_disp ( defects , ii , tmp ) + Eshelby_disp ( defects , ii , tmp2 ) ! we need to check the reference frame here ! sumR = sumR + u end do end if ! TO BE IMPLEMENTED FOR RICHARD LESAR'S Discrete Dislocation Dynamics ! ! finally any displacement fields defined by the user routine UserDisp ! sumR = sumR + UserDisp() ! TO BE IMPLEMENTED FOR YUNZHI WANG's Dislocation Simulations ! ! finally any displacement fields defined by the user routine UserDisp ! sumR = sumR + UserDisp() defects % DF_R ( islice , 1 : 3 ) = sumR ( 1 : 3 ) end do sliceloop ! main loop over the slices end subroutine CalcR end module defectmodule","tags":"","loc":"sourcefile/defectmodule.f90.html","title":"defectmodule.f90 – Fortran Program"},{"text":"This File Depends On sourcefile~~dictmod.f90~~EfferentGraph sourcefile~dictmod.f90 dictmod.f90 sourcefile~constants.f90 constants.f90 sourcefile~constants.f90->sourcefile~dictmod.f90 sourcefile~so3.f90 so3.f90 sourcefile~constants.f90->sourcefile~so3.f90 sourcefile~so3.f90->sourcefile~dictmod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files Dependent On This One sourcefile~~dictmod.f90~~AfferentGraph sourcefile~dictmod.f90 dictmod.f90 sourcefile~pfinversion.f90 PFInversion.f90 sourcefile~dictmod.f90->sourcefile~pfinversion.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules dictmod Source Code dictmod.f90 Source Code ! ################################################################### ! Copyright (c) 2014-2016, Marc De Graef Research Group/Carnegie Mellon University ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without modification, are ! permitted provided that the following conditions are met: ! !     - Redistributions of source code must retain the above copyright notice, this list !        of conditions and the following disclaimer. !     - Redistributions in binary form must reproduce the above copyright notice, this !        list of conditions and the following disclaimer in the documentation and/or !        other materials provided with the distribution. !     - Neither the names of Marc De Graef, Carnegie Mellon University nor the names !        of its contributors may be used to endorse or promote products derived from !        this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE ! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ################################################################### !-------------------------------------------------------------------------- ! EMsoft:dictmod.f90 !-------------------------------------------------------------------------- ! ! MODULE: dictmod ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief Dictionary indexing routines ! !> @details This module contains all the routines that deal with the dictionary !> indexing approach, both in terms of computing all the dot products (which uses !> OpenCL kernels) and in terms of the subsequent indexing on the symmetrized !> quaternion unit sphere using the modified von Mises-Fisher distribution, or the !> modified mixture of axial Watson distributinos.  All !> the details for this approach can be found in two papers: !> !> \"A dictionary based approach for EBSD indexing\", Yu Hui Chen, Se Un Park, Dennis Wei, !> Greg Newstadt, Michael Jackson, Jeff Simmons, Alfred Hero, and Marc De Graef, !> Microscopy & Microanalysis, under review (2015). !> !> \"Parameter estimation in spherical symmetry groups\", Yu Hui Chen, Dennis Wei, !> Gregory Newstadt, Marc De Graef, Jeff Simmons, and Al Hero, IEEE Signal Processing !> Letters, in print (2015) !> !> Here is an example program showing how the routines can be called: !> !> program t !> !> use local !> use typedefs !> use dictmod !> use quaternions !> use constants !> !> integer(kind=irg)               :: nums, seed !> real(kind=dbl),allocatable      :: samples(:,:) !> type(dicttype)                  :: dict !> real(kind=dbl)                  :: muhat(4), kappahat !> !> ! this is a test of the dictionary indexing portion that deals with the !> ! modified von Mises-Fisher distribution; the results must be the same !> ! as those produced by the original Matlab code... !> !> seed = 432514 !> nums = 1000 !> allocate(samples(4,nums)) !> !> allocate(dict) !> dict%Num_of_init = 3 !> dict%Num_of_iterations = 30 !> dict%pgnum = 32 !> !> ! read a bunch of quaternions from a file... and store them in samples !> !> call DI_Init(dict,'VMF') ! replace 'VMF' by 'WAT' to use the axial Watson distribution !> !> do i=1,10 !>   call DI_EMforDD(samples, dict, nums, seed, muhat, kappahat,'VMF')  ! replace 'VMF' by 'WAT' to use the Watson distribution !> !>   write (*,*) '  ' !>   write (*,*) 'mu    = ',muhat !>   write (*,*) 'kappa = ',kappahat !>   write (*,*) 'equivalent angular precision : ',180.D0*dacos(1.D0-1.D0/kappahat)/cPi !> end do !> !> end program !> ! !> @date 12/31/14 MDG 1.0 original (based on UMich Matlab code and IDL intermediate version) !> @date 01/02/15 MDG 1.1 debug of code; produces same result as Matlab code !> @date 01/04/15 MDG 1.2 trial implementation of model using hyperbolic functions instead of exponential !> @date 01/06/15 MDG 1.3 changed public routine names with DI_ in front !> @date 01/07/15 MDG 1.4 added VMF sampling routines !> @date 01/09/15 MDG 1.5 replaced several computations by numerically more stable versions !> @date 02/05/15 MDG 1.6 added sampling for axial Watson distribution !> @date 02/06/15 MDG 1.7 streamlined sampling code by removing duplications; VMF vs. Watson is now an argument !> @date 02/06/15 MDG 1.8 general rewrite and removal of duplications in indexing routines; some name changes !-------------------------------------------------------------------------- module dictmod IMPLICIT NONE public :: DI_Init , DI_EMforDD , DD_Density , DI_Similarity_Classifier , DI_SampleDD , getDisorientationAngle , & ReduceOrientationtoRFZ private :: DD_Estep , DD_Mstep , DD_getQandL , CardIntersection , randDDMarginal , randUniformSphere , & getDDDensityLBM , VMFMeanDirDensity , WatsonMeanDirDensity , DI_RotateToMu , logCp interface getDisorientationAngle module procedure getDisorientationAngleSingle module procedure getDisorientationAngleDouble end interface contains !-------------------------------------------------------------------------- ! ! FUNCTION: DI_RotateToMu ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief Rotate an array of quaternions to an average direction lmu using the null space approach ! !> @param N number of samples to return !> @param seed random number generator seed value !> @param mu mean direction (unit quaternion) !> @param kappa concentration ! !> @date 02/05/15 MDG 1.0 original !-------------------------------------------------------------------------- recursive function DI_RotateToMu ( N , lmu , y ) result ( ymu ) !DEC$ ATTRIBUTES DLLEXPORT :: DI_RotateToMu use local IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: N real ( kind = dbl ), INTENT ( IN ) :: lmu ( 4 ) real ( kind = dbl ), INTENT ( IN ) :: y ( 4 , N ) real ( kind = dbl ) :: ymu ( 4 , N ) integer ( kind = irg ) :: i ! parameters for the singular value decomposition integer ( kind = irg ) :: nr , LDA , LDU , LDVT , lwork , info real ( kind = dbl ) :: mA ( 4 , 4 ), ss ( 4 ), u ( 4 , 4 ), vt , work ( 20 ) ! Rotate the distribution along the desired mean direction mu ! In Matlab, one uses the null() operator which returns the null space of the argument ! This is then inserted into a 4x4 rotation matrix and multiplied with the quaternions ! from the random sample.  The null space of the input quaternion can be computed with ! singular value decomposition, which is done with the dgesvd Lapack routine. The matrix ! returned as u is the desired rotation matrix, except that the numbers in the first ! column must have their signs reversed. mA = 0.D0 mA ( 1 : 4 , 1 ) = lmu ( 1 : 4 ) nr = 4 LDA = 4 LDVT = 1 LDU = 4 lwork = 20 call DGESVD ( 'A' , 'N' , nr , nr , mA , LDA , ss , u , LDU , vt , LDVT , work , lwork , info ) u ( 1 : 4 , 1 ) = - u ( 1 : 4 , 1 ) ! next, apply this 4x4 rotation matrix to all of the generated quaternions to ! rotate them along the mean direction mu do i = 1 , N ymu ( 1 : 4 , i ) = matmul ( u , y ( 1 : 4 , i )) end do end function DI_RotateToMu !-------------------------------------------------------------------------- ! ! FUNCTION: randUniformSphere ! !> @author Marc De Graef, Carnegie Mellon University / Yu-Hui Chen, U. Michigan ! !> @brief Return a set of random vectors on the sphere S&#94;2 using normal random sampling ! !> @param N number of samples to return !> @param seed random number generator seed value ! !> @date 01/07/15 MDG 1.0 original, based on Yu-Hui's Matlab code, output transposed !-------------------------------------------------------------------------- recursive function randUniformSphere ( N , seed ) result ( ranSphere ) !DEC$ ATTRIBUTES DLLEXPORT :: randUniformSphere use local use math IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: N integer ( kind = irg ), INTENT ( INOUT ) :: seed real ( kind = dbl ) :: ranSphere ( 3 , N ) real ( kind = dbl ) :: nq , NR ( N * 3 ), randNorm ( 3 , N ) integer ( kind = irg ) :: i ranSphere = 0.D0 call R8VEC_normal_01 ( N * 3 , seed , NR ) randNorm = reshape ( NR , ( / 3 , N / ) ) ! and normalize the three-vectors do i = 1 , N nq = dsqrt ( sum ( randNorm ( 1 : 3 , i ) ** 2 )) RanSphere ( 1 : 3 , i ) = randNorm ( 1 : 3 , i ) / nq end do end function randUniformSphere !-------------------------------------------------------------------------- ! ! FUNCTION: DI_SampleDD ! !> @author Marc De Graef, Carnegie Mellon University / Yu-Hui Chen, U. Michigan ! !> @brief Sample a directional distribution (VMF or WAT) on the quaternion unit sphere ! !> @param N number of samples to return !> @param seed random number generator seed value !> @param mu mean direction (unit quaternion) !> @param kappa concentration !> @param Dtype 'VMF' for von-Mises-Fisher  or 'WAT' for axial Watson ! !> @date 01/07/15 MDG 1.0 original, based on Yu-Hui's Matlab code !-------------------------------------------------------------------------- recursive function DI_SampleDD ( N , seed , mu , kappa , Dtype ) result ( sDD ) !DEC$ ATTRIBUTES DLLEXPORT :: DI_SampleDD use local use error IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: N integer ( kind = irg ), INTENT ( INOUT ) :: seed real ( kind = dbl ), INTENT ( IN ) :: mu ( 4 ) real ( kind = dbl ), INTENT ( IN ) :: kappa character ( 3 ), INTENT ( IN ) :: Dtype real ( kind = dbl ) :: sDD ( 4 , N ) real ( kind = dbl ) :: nq , tmpmu ( 4 ), RandSphere ( 3 , N ), t ( N ), RS ( 4 , N ), lmu ( 4 ), y ( 4 , N ) integer ( kind = irg ) :: i ! make sure the input quaternion is normalized nq = dsqrt ( sum ( mu * mu )) if ( nq . eq . 0.D0 ) call FatalError ( 'DI_SampleDD' , 'Input quaternion has zero length' ) lmu = mu / nq ! initialize a bunch of parameters tmpmu = ( / 1.D0 , 0.D0 , 0.D0 , 0.D0 / ) sDD = 0.D0 RS = 0.D0 ! get the t-parameter t = randDDMarginal ( N , kappa , seed , Dtype ) ! and the distribution of random directions on the 2-sphere RandSphere = randUniformSphere ( N , seed ) RS ( 2 : 4 , 1 : N ) = RandSphere ( 1 : 3 , 1 : N ) ! merge these two parameters into the desired random variables y = transpose ( spread ( t , DIM = 2 , NCOPIES = 4 ) * spread ( tmpmu , DIM = 1 , NCOPIES = N ) + & spread ( dsqrt ( 1.D0 - t * t ), DIM = 2 , NCOPIES = 4 ) * transpose ( RS ) ) ! Rotate the distribution along the desired mean direction mu sDD = DI_RotateToMu ( N , lmu , y ) end function DI_SampleDD !-------------------------------------------------------------------------- ! ! FUNCTION: randDDMarginal ! !> @author Marc De Graef, Carnegie Mellon University / Yu-Hui Chen, U. Michigan ! !> @brief rejection sampling for the t parameter for the marginal directional distribution ! !> @details This algorithm samples the parameter t from a marginal distribution f(t), which !> by itself is the VMF or Watson distribution integrated around the mean direction.  These !> expressions were derived by Yu-Hui and verified by MDG [02/05/15] and then implemented; !> there are some typographical errors in the literature, and the versions documented here !> are correct [numerical verification]. ! !> @param N number of samples to return !> @param k concentration !> @param seed random number generator seed value !> @param Dtype 'VMF' or 'WAT' ! !> @date 01/07/15 MDG 1.0 original, based on Yu-Hui's Matlab code !> @date 02/05/15 MDG 1.1 consolidated routines for VMF and WAT distributions !-------------------------------------------------------------------------- recursive function randDDMarginal ( N , k , seed , Dtype ) result ( t ) !DEC$ ATTRIBUTES DLLEXPORT :: randDDMarginal use local use math IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: N real ( kind = dbl ), INTENT ( IN ) :: k integer ( kind = irg ), INTENT ( INOUT ) :: seed character ( 3 ), INTENT ( IN ) :: Dtype real ( kind = dbl ) :: t ( N ) real ( kind = dbl ) :: LBM ( 2 ), h , x , C integer ( kind = irg ) :: i ! Find the left bound and maximum needed for rejection sampling C = 0.D0 LBM = getDDDensityLBM ( k , C , Dtype ) ! apply the rejection sampling algorithm to either VMF or Watson marginal distributions t = 0.D0 do i = 1 , N do x = r8_uniform_01 ( seed ) * ( 1.D0 - LBM ( 1 )) + LBM ( 1 ) if ( Dtype . eq . 'VMF' ) h = VMFMeanDirDensity ( x , k , C ) if ( Dtype . eq . 'WAT' ) h = WatsonMeanDirDensity ( x , k , C ) if ( r8_uniform_01 ( seed ) * LBM ( 2 ). le . h ) EXIT end do t ( i ) = x end do end function randDDMarginal !-------------------------------------------------------------------------- ! ! FUNCTION: getDDDensityLBM ! !> @author Marc De Graef, Carnegie Mellon University / Yu-Hui Chen, U. Michigan ! !> @brief determines the left bound and maximum for rejection sampling ! !> @param k concentration !> @param C constant prefactor of distribution function !> @param Dtype 'VMF' or 'WAT' ! !> @date 01/07/15 MDG 1.0 original, based on Yu-Hui's Matlab code !> @date 02/05/15 MDG 1.1 consolidated routines for VMF and WAT distributions !-------------------------------------------------------------------------- recursive function getDDDensityLBM ( k , C , Dtype ) result ( LBM ) !DEC$ ATTRIBUTES DLLEXPORT :: getDDDensityLBM use local use error IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: k real ( kind = dbl ), INTENT ( INOUT ) :: C character ( 3 ), INTENT ( IN ) :: Dtype real ( kind = dbl ) :: LBM ( 2 ) real ( kind = dbl ), parameter :: min_thresh = 0.00001D0 real ( kind = dbl ) :: s , x , start integer ( kind = irg ) :: f start = - 1.D0 if ( Dtype . eq . 'WAT' ) start = 0.D0 ! first we look for the left bound f = 1 do x = start + dble ( f ) * 0.00001D0 if ( x . eq . 1.D0 ) call FatalError ( 'getDDDensityLBM' , 'reached +1 in leftbound determination' ) if ( Dtype . eq . 'VMF' ) s = VMFMeanDirDensity ( x , k , C ) if ( Dtype . eq . 'WAT' ) s = WatsonMeanDirDensity ( x , k , C ) if ( s . ge . min_thresh ) EXIT f = f + 1 end do ! LBM ( 1 ) = start + dble ( f ) * 0.00001D0 if ( Dtype . eq . 'VMF' ) then ! for the simplified version of the density function, we have an analytical ! expression for where the maximum of the function occurs [convert the BesselI(3/2,x) ! to hyperbolic functions, then to exponential, and ignore the negative exponential ! which will be very small for reasonably sized k and t...] x = ( - 1.D0 + dsqrt ( 1.D0 + 4.D0 * k * k )) / ( 2.D0 * k ) LBM ( 2 ) = VMFMeanDirDensity ( x , k , C ) end if if ( Dtype . eq . 'WAT' ) then ! for the simplified version of the density function, we have an analytical ! expression for where the maximum of the function occurs x = dsqrt (( 2.D0 * k - 1.D0 ) / ( 2.D0 * k )) LBM ( 2 ) = WatsonMeanDirDensity ( x , k , C ) end if end function getDDDensityLBM !-------------------------------------------------------------------------- ! ! FUNCTION: VMFMeanDirDensity ! !> @author Marc De Graef, Carnegie Mellon University / Yu-Hui Chen, U. Michigan ! !> @brief function to be sampled for VMF random sampling; we're using a close approximation ! !> @param x argument value !> @param k concentration !> @param C constant prefactor ! !> @date 01/07/15 MDG 1.0 original, based on Yu-Hui's Matlab code !-------------------------------------------------------------------------- recursive function VMFMeanDirDensity ( x , k , C ) result ( y ) !DEC$ ATTRIBUTES DLLEXPORT :: VMFMeanDirDensity use local use constants use math use error IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: x real ( kind = dbl ), INTENT ( IN ) :: k real ( kind = dbl ), INTENT ( INOUT ) :: C real ( kind = dbl ) :: y if ( dabs ( x ). gt . 1.D0 ) call FatalError ( 'VMFMeanDirDensity' , 'argument must be in [-1,1]' ) ! explicit expression for p=4 (Gamma[3/2]Gamma[1/2] = pi/2) ! and the BesselI(3/2) function reduces to hyperbolic functions ! diverges for k->0, and becomes really small for large k if ( C . eq . 0.D0 ) then C = 2.D0 * k ** ( 2.5D0 ) / dsqrt ( 2.D0 * cPi ) / ( k - 1.D0 ) end if ! this is a close approximation, really good for larger values of k ! and numerically more stable than the original, which has problems for k>600 or so y = C * dexp ( k * ( x - 1.D0 )) * dsqrt ( 1.D0 - x * x ) end function VMFMeanDirDensity !-------------------------------------------------------------------------- ! ! FUNCTION: WatsonMeanDirDensity ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief function to be sampled for Watson random sampling; we're using a close approximation ! !> @param x argument value !> @param k concentration !> @param C constant prefactor ! !> @date 02/05/15 MDG 1.0 original !-------------------------------------------------------------------------- recursive function WatsonMeanDirDensity ( x , k , C ) result ( y ) !DEC$ ATTRIBUTES DLLEXPORT :: WatsonMeanDirDensity use local use constants use math use error IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: x real ( kind = dbl ), INTENT ( IN ) :: k real ( kind = dbl ), INTENT ( INOUT ) :: C real ( kind = dbl ) :: y real ( kind = dbl ), parameter :: CC = 14 4.43253338822560946D0 ! 256/sqrt(pi) if ( dabs ( x ). gt . 1.D0 ) call FatalError ( 'WatsonMeanDirDensity' , 'argument must be in [-1,1]' ) ! approximate expression for p=4 if ( C . eq . 0.D0 ) then C = CC * k ** 4.5D0 / ( 52 5.D0 + 4.D0 * k * ( 4 5.D0 + 8.D0 * k * ( 3.D0 + 4.D0 * k ))) end if ! this is a close approximation, really good for larger values of k ! and numerically more stable than the original, which has problems for k>600 or so y = C * dexp ( k * ( x * x - 1.D0 )) * dsqrt ( 1.D0 - x * x ) end function WatsonMeanDirDensity !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- ! below we have a series of functions/subroutines used to index patterns based ! on the set of 40 or so closest matches in the dictionary; these routines perform ! an averaging on the quaternion unit sphere and return the mean direction and ! the concentration parameter for either the von Mises-Fisher or the axial Watson distribution. !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- ! ! SUBROUTINE: DI_Init ! !> @author Marc De Graef, Carnegie Mellon University / Yu-Hui Chen, U. Michigan ! !> @brief initialize the dictionary indexing parameters (symmetry operators and precomputed Ap lookup table) ! !> @details For all details, see following paper: ! !> @param dict dictionary parameter (must be declared in calling routine) !> @param Dtype  'VMF' or 'WAT' for von Mises-Fisher and Watson distributions, respectively. ! !> @date 12/31/14 MDG 1.0 original !> @date 01/06/15 MDG 1.1 added optional argument full !> @date 02/06/15 MDG 1.2 removed full again after extensive testing; no need to use 2M operators !-------------------------------------------------------------------------- recursive subroutine DI_Init ( dict , Dtype ) !DEC$ ATTRIBUTES DLLEXPORT :: DI_Init use local use typedefs use error use math IMPLICIT NONE type ( dicttype ), INTENT ( INOUT ) :: dict character ( 3 ), INTENT ( IN ) :: Dtype integer ( kind = irg ) :: i real ( kind = dbl ) :: y1 , y2 ! here we need to analyze the rotational symmetry group, and copy the appropriate ! quaternion symmetry operators into the dict%Pm array ! first get the number of the rotational point group that corresponds to the crystal point group dict % prot = PGrot ( dict % pgnum ) ! possible values for dict%prot are: (/1,3,6,9,12,16,18,21,24,28,30/) ! corresponding to the point groups 1, 2, 222, 4, 422, 3, 32, 6, 622, 23, and 432, respectively !------------ ! IMPORTANT NOTE: the original von Mises-Fischer (VMF) approach requires that q and -q are considered to ! be separate quaternions, so the original Matlab code included the negatives of all quaternion symmetry operators ! as well, leading to a cardinality of twice the rotational point group order.  It appears that we do not have to ! do so if we replace the exponential in the VMF by a hyperbolic cosine function, which would account directly ! for the q, -q duplicity... Alternatively, one can use the axial Watson distribution. !------------ ! identity operator is part of all point groups dict % Pm = 0.D0 ! initialize all entries to zero dict % Pm ( 1 : 4 , 1 ) = SYM_Qsymop ( 1 : 4 , 1 ) ! select statement for each individual rotational point group (see typedefs.f90 for SYM_Qsymop definitions) select case ( dict % prot ) case ( 1 ) ! 1 (no additional symmetry elements) dict % Nqsym = 1 dict % Pm ( 1 : 4 , 2 ) = - dict % Pm ( 1 : 4 , 1 ) case ( 3 ) ! 2  (we'll assume that the two-fold axis lies along the e_y-axis) dict % Nqsym = 2 dict % Pm ( 1 : 4 , 2 ) = SYM_Qsymop ( 1 : 4 , 3 ) case ( 6 ) ! 222 dict % Nqsym = 4 do i = 2 , 4 dict % Pm ( 1 : 4 , i ) = SYM_Qsymop ( 1 : 4 , i ) end do case ( 9 ) ! 4 dict % Nqsym = 4 dict % Pm ( 1 : 4 , 2 ) = SYM_Qsymop ( 1 : 4 , 4 ) dict % Pm ( 1 : 4 , 3 ) = SYM_Qsymop ( 1 : 4 , 7 ) dict % Pm ( 1 : 4 , 4 ) = SYM_Qsymop ( 1 : 4 , 10 ) case ( 12 ) ! 422 dict % Nqsym = 8 dict % Pm ( 1 : 4 , 2 ) = SYM_Qsymop ( 1 : 4 , 4 ) dict % Pm ( 1 : 4 , 3 ) = SYM_Qsymop ( 1 : 4 , 7 ) dict % Pm ( 1 : 4 , 4 ) = SYM_Qsymop ( 1 : 4 , 10 ) dict % Pm ( 1 : 4 , 5 ) = SYM_Qsymop ( 1 : 4 , 2 ) dict % Pm ( 1 : 4 , 6 ) = SYM_Qsymop ( 1 : 4 , 3 ) dict % Pm ( 1 : 4 , 7 ) = SYM_Qsymop ( 1 : 4 , 11 ) dict % Pm ( 1 : 4 , 8 ) = SYM_Qsymop ( 1 : 4 , 12 ) case ( 16 ) ! 3 dict % Nqsym = 2 call FatalError ( 'InitDictionaryIndexing' , 'this symmetry has not yet been implemented (pg 3)' ) case ( 18 ) ! 32 (needs special handling) dict % Nqsym = 2 call FatalError ( 'InitDictionaryIndexing' , 'this symmetry has not yet been implemented (pg 32)' ) case ( 21 ) ! 6 dict % Nqsym = 6 do i = 25 , 29 dict % Pm ( 1 : 4 , i - 23 ) = SYM_Qsymop ( 1 : 4 , i ) end do case ( 24 ) ! 622 dict % Nqsym = 12 do i = 25 , 35 dict % Pm ( 1 : 4 , i - 23 ) = SYM_Qsymop ( 1 : 4 , i ) end do case ( 28 ) ! 23 dict % Nqsym = 12 do i = 2 , 4 dict % Pm ( 1 : 4 , i ) = SYM_Qsymop ( 1 : 4 , i ) end do do i = 17 , 24 dict % Pm ( 1 : 4 , 4 + ( i - 16 )) = SYM_Qsymop ( 1 : 4 , i ) end do case ( 30 ) ! 432 dict % Nqsym = 24 do i = 2 , 24 dict % Pm ( 1 : 4 , i ) = SYM_Qsymop ( 1 : 4 , i ) end do case default ! this should never happen ... call FatalError ( 'InitDictionaryIndexing' , 'unknown rotational point group number' ) end select ! von Mises-Fisher mode: ! the next part of the initial Matlab code computes a lookup table for the parameter Ap(u) (Appendix in paper) ! this lookup table is only used when the ratio of the BesselI functions is between 0 and 0.95; for the ! region between 0.95 and 1, we use an analytical approximation (see VMF_Mstep routine). ! ! Watson mode: ! we've used a similar approach to create a lookup table for values of kappa that are smaller than 35, in ! which case we use the standard ratio of Kummer functions:  Kummer[3/2,3,k]/Kummer[1/2,2,k]/k.  For ! larger kappa values, we have an expansion using the large argument behavior of the modified Bessel functions. ! dict % Apnum = 35000 allocate ( dict % xAp ( dict % Apnum ), dict % yAp ( dict % Apnum )) ! define the xAp array dict % xAp = ( / ( 0.001D0 + dble ( i - 1 ) * 0.001D0 , i = 1 , dict % Apnum ) / ) if ( Dtype . eq . 'VMF' ) then ! von Mises-Fisher distribution do i = 1 , dict % Apnum dict % yAp ( i ) = BesselIn ( dict % xAp ( i ), 2 ) / BesselI1 ( dict % xAp ( i )) end do end if if ( Dtype . eq . 'WAT' ) then ! Watson distribution do i = 1 , dict % Apnum y1 = BesselI1 ( dict % xAp ( i ) * 0.5D0 ) y2 = BesselI0 ( dict % xAp ( i ) * 0.5D0 ) dict % yAp ( i ) = y1 / ( y2 - y1 ) / dict % xAp ( i ) end do end if end subroutine DI_Init !-------------------------------------------------------------------------- ! ! SUBROUTINE: DI_EMforDD ! !> @author Yu-Hui Chen, U. Michigan / Marc De Graef, Carnegie Mellon University ! !> @brief Expectation maximization approach to maximum likelihood problem for mu and kappa ! !> @details For all details, see following paper: ! !> @param X list of input quaternions !> @param dict dictionary parameter (must be declared in calling routine) !> @param nums number of input quaternions !> @param seed for normal random number generator !> @param muhat output mean orientation !> @param kappahat output concentration parameter !> @param Dtype 'VMF' or 'WAT' ! !> @date 01/01/15 MDG 1.0 original, based on Chen's Matlab version + simplifications !> @date 01/06/15 MDG 1.1 added optional argument full !> @date 02/06/15 MDG 1.2 removed full again, added Dtype and streamlined code; removed duplications !-------------------------------------------------------------------------- recursive subroutine DI_EMforDD ( X , dict , nums , seed , muhat , kappahat , Dtype ) !DEC$ ATTRIBUTES DLLEXPORT :: DI_EMforDD use local use constants use typedefs use math , only : r8vec_normal_01 , r4_uniform_01 ! array of normal random numbers use quaternions use rotations , only : qu2ro ! we only need to move to Rodrigues-Frank space use so3 , only : IsinsideFZ ! we only need to do a test ... IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: X ( 4 , nums ) type ( dicttype ), INTENT ( INOUT ) :: dict integer ( kind = irg ), INTENT ( IN ) :: nums integer ( kind = irg ), INTENT ( INOUT ) :: seed real ( kind = dbl ), INTENT ( OUT ) :: muhat ( 4 ) real ( kind = dbl ), INTENT ( OUT ) :: kappahat character ( 3 ), INTENT ( IN ) :: Dtype integer ( kind = irg ) :: i , j , N , Pmdims , init , dd integer ( kind = irg ) :: FZtype , FZorder real ( kind = dbl ), allocatable :: Mu_All (:,:), Kappa_All (:), R_All (:,:,:), L_All (:), & R (:,:), Q (:), L (:) real ( kind = dbl ) :: Mu ( 4 ), PmMu ( 4 ), MuKa ( 5 ), Qi , Li , rod ( 4 ), qu ( 4 ), Kappa ! In this routine, we perform the EM algorithm to obtain an estimate for the ! mean direction and concentration parameter of the modified von Mises-Fisher (mVMF) ! distribution that models the statistics of the orientation point cloud. ! array sizes (we use shorthand notations) N = nums Pmdims = dict % Nqsym ! initialize some auxiliary arrays allocate ( Mu_All ( dict % Num_of_init , 4 ), Kappa_All ( dict % Num_of_init ), & R_All ( N , Pmdims , dict % Num_of_init ), L_All ( dict % num_of_init )) Mu_All = 0.D0 Kappa_All = 0.D0 R_All = 0.D0 L_All = 0.D0 ! main loop (EM typically uses a few starting parameter sets to make sure we don't get stuck in a local maximum) do init = 1 , dict % Num_of_init ! create a vector to hold the results allocate ( R ( N , Pmdims )) R = 0.D0 ! generate a normal random vector and normalize it as a starting guess for Mu (i.e., a unit quaternion) call R8VEC_normal_01 ( 4 , seed , Mu ) Mu = Mu / cabs ( Mu ) ! the EMsoft package only considers quaternions with positive first component, ! so we may need to change all the signs if ( Mu ( 1 ). lt . 0.D0 ) Mu = - Mu ! starting value for Kappa Kappa = 3 0.D0 ! define the number of iterations and the Q and L function arrays allocate ( Q ( dict % Num_of_iterations ), L ( dict % Num_of_iterations )) Q = 0.D0 L = 0.D0 ! and here we go with the EM iteration... ! we use quaternion multiplication throughout instead of the matrix version in the Matlab version ! quaternion multiplication has been verified against the 4x4 matrix multiplication of the Matlab code on 01/02/15 iloop : do i = 1 , dict % Num_of_iterations ! E-step R = DD_Estep ( X , dict , Pmdims , N , Mu , Kappa , Dtype ) ! M-step MuKa = DD_Mstep ( X , dict , Pmdims , N , R , Dtype ) ! calculate the Q and Likelihood function values call DD_getQandL ( X , dict , Pmdims , nums , MuKa , R , Qi , Li , Dtype ) L ( i ) = Li Q ( i ) = Qi ! update the containers Mu_All ( init , 1 : 4 ) = MuKa ( 1 : 4 ) Kappa_All ( init ) = MuKa ( 5 ) R_All ( 1 : N , 1 : Pmdims , init ) = R ( 1 : N , 1 : Pmdims ) L_All ( init ) = L ( i ) Mu = MuKa ( 1 : 4 ) Kappa = MuKa ( 5 ) ! and terminate if necessary if ( i . ge . 2 ) then if ( abs ( Q ( i ) - Q ( i - 1 )). lt . 0.01 ) then EXIT iloop end if end if end do iloop deallocate ( R , Q , L ) end do dd = maxloc ( L_All , 1 ) Mu = Mu_all ( dd , 1 : 4 ) kappahat = Kappa_All ( dd ) ! the EMsoft package only considers quaternions with positive first component, ! so we may need to change all the signs if ( Mu ( 1 ). lt . 0.D0 ) Mu = - Mu ! the final step is to make sure that the resulting Mu lies in the same ! fundamental zone that the dictionary elements are located in; since we start ! the EM iterations from a random quaternion, there is no guarantee that the ! result lies in the same fundamental zone. Therefore, we cycle through all the ! equivalent quaternions, and stop as soon as we find one in the Rodrigues ! fundamental zone, which requires routines from the rotations and so3 modules. FZtype = FZtarray ( dict % pgnum ) FZorder = FZoarray ( dict % pgnum ) FZloop : do i = 1 , Pmdims qu = quat_mult ( Mu , dict % Pm ( 1 : 4 , i )) if ( qu ( 1 ). lt . 0.D0 ) qu = - qu rod = qu2ro ( qu ) if ( IsinsideFZ ( rod , FZtype , FZorder )) EXIT FZloop end do FZloop muhat = qu deallocate ( Mu_All , Kappa_All , R_All , L_All ) end subroutine DI_EMforDD !-------------------------------------------------------------------------- ! ! FUNCTION: DD_Estep ! !> @author Marc De Graef, Carnegie Mellon University / Yu-Hui Chen, U. Michigan ! !> @brief computes the E step of the EM process, verified against Matlab code on 01/02/15 ! !> @param X list of input quaternions !> @param dict dictionary type !> @param Pmdims number of quaternion symmetry operators !> @param nums number of samples !> @param Mu current guess for mean quaternion !> @param Kappa input parameter ! !> @date 01/01/15 MDG 1.0 original !> @date 01/06/15 MDG 1.1 added optional argument full !> @date 01/09/15 MDG 1.2 removed optional argument full (incorporated in dicttype) !> @date 02/06/15 MDG 1.3 removed full handling after extensive checking !> @date 02/06/15 MDG 1.4 merged VMF and Watson Esteps into a single routine and renamed !-------------------------------------------------------------------------- recursive function DD_Estep ( X , dict , Pmdims , nums , Mu , Kappa , Dtype ) result ( R ) !DEC$ ATTRIBUTES DLLEXPORT :: DD_Estep use local use typedefs use quaternions IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: X ( 4 , nums ) type ( dicttype ), INTENT ( IN ) :: dict integer ( kind = irg ), INTENT ( IN ) :: Pmdims integer ( kind = irg ), INTENT ( IN ) :: nums real ( kind = dbl ), INTENT ( IN ) :: Mu ( 4 ) real ( kind = dbl ), INTENT ( IN ) :: Kappa character ( 3 ), INTENT ( IN ) :: Dtype real ( kind = dbl ) :: R ( nums , Pmdims ) integer ( kind = irg ) :: j real ( kind = dbl ) :: Rdenom ( nums ), PmMu ( 4 ), C C = logCp ( kappa , Dtype ) do j = 1 , Pmdims PmMu = quat_mult ( Mu , dict % Pm ( 1 : 4 , j )) R ( 1 : nums , j ) = DD_Density ( X , nums , PmMu , Kappa , C , Dtype ) end do ! and determine the normalization factors Rdenom = 1.D0 / sum ( R , 2 ) do j = 1 , Pmdims R ( 1 : nums , j ) = R ( 1 : nums , j ) * Rdenom ( 1 : nums ) end do end function DD_Estep !-------------------------------------------------------------------------- ! ! FUNCTION: DD_Mstep ! !> @author Marc De Graef, Carnegie Mellon University / Yu-Hui Chen, U. Michigan ! !> @brief computes the M step of the EM process ! !> @param X list of input quaternions !> @param dict dictionary type !> @param Pmdims number of quaternion symmetry operators !> @param nums number of samples !> @param R weight factors form the E step !> @param Dtype 'VMF' or 'WAT' ! !> @date 01/01/15 MDG 1.0 original !> @date 01/06/15 MDG 1.1 added optional full parameter !> @date 01/09/15 MDG 1.2 removed optional argument full (incorporated in dicttype) !> @date 01/09/15 MDG 1.3 introduced accurate numerical approximation for kappa determination !> @date 02/06/15 MDG 1.4 removed full handling after extensive checking !> @date 02/06/15 MDG 1.5 merged Msteps for VMF and WAT and renamed !-------------------------------------------------------------------------- recursive function DD_Mstep ( X , dict , Pmdims , nums , R , Dtype ) result ( MuKa ) !DEC$ ATTRIBUTES DLLEXPORT :: DD_Mstep use local use typedefs use quaternions IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: X ( 4 , nums ) type ( dicttype ), INTENT ( IN ) :: dict integer ( kind = irg ), INTENT ( IN ) :: Pmdims integer ( kind = irg ), INTENT ( IN ) :: nums real ( kind = dbl ), INTENT ( IN ) :: R ( nums , Pmdims ) character ( 3 ), INTENT ( IN ) :: Dtype real ( kind = dbl ) :: MuKa ( 5 ) real ( kind = dbl ) :: tmpGamma ( 4 ), nGamma , diff ( dict % Apnum ), qu ( 4 ), y , Tscatt ( 4 , 4 ), tmp ( 4 , 4 ) integer ( kind = irg ) :: minp , i , j ! variables needed for the dsyev Lapack eigenvalue routine CHARACTER :: JOBZ , UPLO INTEGER :: INFO , LDA , LWORK , NN DOUBLE PRECISION :: A ( 4 , 4 ), W ( 4 ), WORK ( 20 ) if ( Dtype . eq . 'VMF' ) then ! this is simplified from the Matlab routine and uses straight summations and ! quaternion multiplication instead of arrays tmpGamma = 0.D0 do j = 1 , Pmdims do i = 1 , nums qu = quat_mult ( X ( 1 : 4 , i ), conjg ( dict % Pm ( 1 : 4 , j ))) tmpGamma = tmpGamma + R ( i , j ) * qu end do end do nGamma = cabs ( tmpGamma ) MuKa ( 1 : 4 ) = tmpGamma / nGamma y = nGamma / dble ( nums ) end if if ( Dtype . eq . 'WAT' ) then ! here, we compute the modified scattering matrix Tscatt and compute its largest eigenvalue ! under the assumption that kappa will always be positive for the types of problems that we ! need to consider; we need to use the outer product, implemented using spread calls Tscatt = 0.D0 do j = 1 , Pmdims do i = 1 , nums qu = quat_mult ( X ( 1 : 4 , i ), conjg ( dict % Pm ( 1 : 4 , j ))) tmp = spread ( qu , dim = 2 , ncopies = 4 ) * spread ( qu , dim = 1 , ncopies = 4 ) Tscatt = Tscatt + R ( i , j ) * tmp end do end do Tscatt = Tscatt / dble ( nums ) JOBZ = 'V' UPLO = 'U' NN = 4 LDA = 4 LWORK = 20 A = Tscatt call DSYEV ( JOBZ , UPLO , NN , A , LDA , W , WORK , LWORK , INFO ) qu ( 1 : 4 ) = A ( 1 : 4 , 4 ) MuKa ( 1 : 4 ) = qu ( 1 : 4 ) y = dot_product ( qu , matmul ( Tscatt , qu )) end if ! find kappa corresponding to this value of gamma (equation 17 in appendix of paper) ! we split this into two regionds: 0<=y<0.94, for which we use the look-up table ! approach, and 0.94<=y<=1, for which we have derived an analytical approximation ! that is pretty accurate in the relevant region of kappa>30. if ( y . ge . 0.94D0 ) then if ( Dtype . eq . 'VMF' ) MuKa ( 5 ) = ( 1 5.D0 - 3.D0 * y + dsqrt ( 1 5.D0 + 9 0.D0 * y + 3 9.D0 * y * y )) / ( 1 6.D0 * ( 1.0D0 - y )) if ( Dtype . eq . 'WAT' ) MuKa ( 5 ) = ( 5.D0 * y - 1 1.D0 - dsqrt ( 3 9.D0 - 1 2.D0 * y + 9.D0 * y ** 2 )) / ( 8.D0 * ( y - 1.D0 )) else diff = dabs ( y - dict % yAp ) minp = minloc ( diff , 1 ) if ( minp . eq . 1 ) minp = 2 MuKa ( 5 ) = dict % xAp ( minp ) end if end function DD_Mstep !-------------------------------------------------------------------------- ! ! SUBROUTINE: DD_getQandL ! !> @author Yu-Hui Chen, U. Michigan / Marc De Graef, Carnegie Mellon University ! !> @brief Computes the Q array and the log-likelihood array ! !> @details For all details, see following paper: ! !> @param X list of input quaternions !> @param dict dictionary parameter (must be declared in calling routine) !> @param Pmdims number of quaternion symmetry operators to consider !> @param number of input quaternions !> @param MuKa  vector with Mu and Kappa !> @param R output from the E step !> @param Q output Q !> @param L output L !> @param Dtype 'VMF' or 'WAT' ! !> @date 01/01/15 MDG 1.0 original, based on Chen's Matlab version + simplifications !> @date 01.06/15 MDG 1.1 added optional full parameter !> @date 01/09/15 MDG 1.2 removed optional argument full (incorporated in dicttype) !> @date 02/06/15 MDG 1.3 removed full handling after extensive checking !> @date 02/06/15 MDG 1.4 merged VMF and WAT routines and renamed !> @date 12/05/16 MDG 1.5 intercepted case when Phi becomes zero for a VERY sharp texture... !-------------------------------------------------------------------------- recursive subroutine DD_getQandL ( X , dict , Pmdims , nums , MuKa , R , Q , L , Dtype ) !DEC$ ATTRIBUTES DLLEXPORT :: DD_getQandL use local use typedefs use quaternions IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: X ( 4 , nums ) type ( dicttype ), INTENT ( INOUT ) :: dict integer ( kind = irg ), INTENT ( IN ) :: Pmdims integer ( kind = irg ), INTENT ( IN ) :: nums real ( kind = dbl ), INTENT ( IN ) :: MuKa ( 5 ) real ( kind = dbl ), INTENT ( IN ) :: R ( nums , Pmdims ) real ( kind = dbl ), INTENT ( INOUT ) :: Q real ( kind = dbl ), INTENT ( INOUT ) :: L character ( 3 ), INTENT ( IN ) :: Dtype real ( kind = dbl ) :: Phi ( nums , Pmdims ), PmMu ( 4 ), qu ( 4 ), C , oldQ , oldL integer ( kind = irg ) :: j real ( kind = dbl ), parameter :: eps = 0.00001D0 oldQ = Q oldL = L C = logCp ( MuKa ( 5 ), Dtype ) if ( Dtype . eq . 'VMF' ) C = dexp ( C ) ! compute the auxiliary Phi array Phi = 0.D0 qu = MuKa ( 1 : 4 ) do j = 1 , Pmdims PmMu = quat_mult ( dict % Pm ( 1 : 4 , j ), qu ) Phi ( 1 : nums , j ) = DD_Density ( X , nums , PmMu , MuKa ( 5 ), C , Dtype ) end do Phi = Phi / dble ( dict % Nqsym ) if ( minval ( Phi ). gt . 0.D0 ) then ! and convert the array into the Q and L parameters. L = sum ( dlog ( sum ( Phi , 2 ))) Q = sum ( R * dlog ( Phi )) else L = oldL Q = oldQ end if ! else, we reuse the old values end subroutine DD_getQandL !-------------------------------------------------------------------------- ! ! FUNCTION: DD_Density ! !> @author Marc De Graef, Carnegie Mellon University / Yu-Hui Chen, U. Michigan ! !> @brief computes the VMF or Watson density function ! !> @details !> original in Matlab by Yu-Hui Chen, U. Michigan !> converted to IDL by MDG, 12/18/14, simplified arguments !> converted to f90 by MDG, 12/31/14, further simplifications !> output validated against Matlab output on 12/31/14 ! !> @param X input quaternion samples !> @param nums number of samples !> @param mu mean direction !> @param kappa concentration !> @param C logCp(kappa) or exp(logCp(kappa) (precomputed in calling routine) !> @param Dtype 'VMF' or 'WAT' ! !> @date 01/01/15 MDG 1.0 original !> @date 01/06/15 MDG 1.1 added C and full parameters !> @date 02/06/15 MDG 1.2 removed full handling !> @date 02/06/15 MDG 1.3 merged 'VMF' and 'WAT' routines and renamed !-------------------------------------------------------------------------- recursive function DD_Density ( X , nums , mu , kappa , C , Dtype ) result ( y ) !DEC$ ATTRIBUTES DLLEXPORT :: DD_Density use local IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: X ( 4 , nums ) integer ( kind = irg ), INTENT ( IN ) :: nums real ( kind = dbl ), INTENT ( IN ) :: mu ( 4 ) real ( kind = dbl ), INTENT ( IN ) :: kappa real ( kind = dbl ), INTENT ( IN ) :: C character ( 3 ), INTENT ( IN ) :: Dtype real ( kind = dbl ) :: y ( nums ) integer ( kind = irg ) :: j if ( Dtype . eq . 'VMF' ) then do j = 1 , nums y ( j ) = dexp ( C + kappa * dot_product ( mu , X ( 1 : 4 , j ))) end do end if if ( Dtype . eq . 'WAT' ) then do j = 1 , nums y ( j ) = dexp ( C + kappa * dot_product ( mu , X ( 1 : 4 , j )) ** 2 ) end do end if end function DD_Density !-------------------------------------------------------------------------- ! ! FUNCTION: logCp ! !> @author Marc De Graef, Carnegie Mellon University / Yu-Hui Chen, U. Michigan ! !> @brief computes the logarithm of Cp for VMF and Watson distributions ! !> @details !> original in Matlab by Yu-Hui Chen, U. Michigan !> converted to IDL by MDG, 12/18/14, simplified arguments !> converted to f90 by MDG, 12/31/14, further simplifications !> output validated against Matlab output on 12/31/14 ! !> @param kappa input parameter !> @param Dtype 'VMF' or 'WAT' ! !> @date 12/31/14 MDG 1.0 original !> @date 01/09/14 MDG 1.1 introduced more accurate numerical approximation for Cp !> @date 01/09/14 MDG 1.2 moved some of the constants in front of the logarithm !> @date 02/06/15 MDG 1.3 merged VMF and WAT routines !-------------------------------------------------------------------------- recursive function logCp ( kappa , Dtype ) result ( lCp ) !DEC$ ATTRIBUTES DLLEXPORT :: logCp use local use constants use math IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: kappa character ( 3 ), INTENT ( IN ) :: Dtype real ( kind = dbl ) :: lCp ! pre-computed constants real ( kind = dbl ), parameter :: C =- 3.675754132818690967D0 ! C = ln(1.D0/(2.D0*cPi)**2) real ( kind = dbl ), parameter :: C2 = 4.1746562059854348688D0 ! C2 = ln(512/sqrt(2)/pi&#94;(3/2)) real ( kind = dbl ), parameter :: C2W = 5.4243952068443172530D0 ! C2 = ln(128*sqrt(pi)) if ( Dtype . eq . 'VMF' ) then ! for arguments larger than kappa=30, we use a simple numerical approximation if ( kappa . gt . 3 0.D0 ) then lCp = kappa ** 4.5D0 / ( - 105 D0 + 8.D0 * kappa * ( - 1 5.D0 + 1 6.D0 * kappa * ( - 3.D0 + 8.D0 * kappa ))) lCp = C2 - kappa + dlog ( lCp ) else lCp = C + dlog ( kappa / BesselI1 ( kappa ) ) end if end if if ( Dtype . eq . 'WAT' ) then ! for arguments larger than kappa=20, we use a simple numerical approximation if ( kappa . gt . 2 0.D0 ) then lCp = kappa ** 4.5D0 / ( 52 5.D0 + 4.D0 * kappa * ( 4 5.D0 + 8.D0 * kappa * ( 3.D0 + 4.D0 * kappa ))) lCp = C2W - kappa + dlog ( lCp ) else lCp = - kappa * 0.5D0 - dlog ( BesselI0 ( kappa * 0.5D0 ) - BesselI1 ( kappa * 0.5D0 ) ) end if end if end function logCp !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- ! the following routines have to do with the neighborhood similarity analysis !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- ! ! SUBROUTINE: DI_similarity_classifier ! !> @author Saransh Singh, Carnegie Mellon University / Yu-Hui Chen, U. Michigan ! !> @brief classify the point as grain interior or anomalous point ! !> @details takes the kNN neighbor information as input and returns the !  whether the point lies in the interior of the grain or lies on the !  grain boundary. Details in pg 11 of the dictionary indexing paper ! !> @param array input array !> @param k number of top matches for each pixel !> @param npx number of pixels in the x direction !> @param npy number of pixels in the y direction ! !> @date 01/05/15 SS 1.0 original !> @date 01/06/15 MDG 1.1 simplified summation loop and renamed routine !-------------------------------------------------------------------------- recursive subroutine DI_Similarity_Classifier ( array , k , npx , npy , returnarr ) !DEC$ ATTRIBUTES DLLEXPORT :: DI_Similarity_Classifier use local IMPLICIT NONE integer ( kind = sgl ), INTENT ( IN ) :: array ( npx , npy , k ) integer ( kind = irg ), INTENT ( IN ) :: k integer ( kind = irg ), INTENT ( IN ) :: npx integer ( kind = irg ), INTENT ( IN ) :: npy real ( kind = sgl ), INTENT ( OUT ) :: returnarr ( npx , npy ) integer ( kind = irg ) :: ii , jj , ki , kj , similarity_measure_sum , res real ( kind = sgl ) :: similarity_measure similarity_measure_sum = 0 similarity_measure = 0.0 returnarr = 0.0 do ii = 2 , npx - 1 do jj = 2 , npy - 1 do ki = - 1 , 1 do kj = - 1 , 1 if (( abs ( ki ) + abs ( kj )). ne . 0 ) then call CardIntersection ( array ( ii + ki , jj + kj , 1 : k ), array ( ii , jj , 1 : k ), k , res ) similarity_measure_sum = similarity_measure_sum + res similarity_measure = float ( similarity_measure_sum ) / float ( 8 * k ) returnarr ( ii , jj ) = similarity_measure similarity_measure = 0.0 similarity_measure_sum = 0 end if end do end do end do end do end subroutine DI_Similarity_Classifier !-------------------------------------------------------------------------- ! ! SUBROUTINE: CardIntersection ! !> @author Saransh Singh, Carnegie Mellon University / Yu-Hui Chen, U. Michigan ! !> @brief calculate the cardinality of the intersection of two sets ! !> @param set1 !> @param set2 !> @param k number of elements in each set ! !> @date 01/05/15 SS 1.0 original !> @date MDG 1.1 changed types to integer !-------------------------------------------------------------------------- recursive subroutine CardIntersection ( set1 , set2 , k , res ) !DEC$ ATTRIBUTES DLLEXPORT :: CardIntersection use local IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: set1 ( k ) integer ( kind = irg ), INTENT ( IN ) :: set2 ( k ) integer ( kind = irg ), INTENT ( IN ) :: k integer ( kind = irg ), INTENT ( OUT ) :: res integer ( kind = irg ) :: ii , jj jj = 1 res = 0 do ii = 1 , k do jj = 1 , k if ( set1 ( ii ) . eq . set2 ( jj )) then res = res + 1 EXIT end if end do end do end subroutine CardIntersection !-------------------------------------------------------------------------- ! ! SUBROUTINE: ReduceDisorientationtoMFZ ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief Reduce a disorientation (Rodrigues) to the Mackenzie Fundamental Zone ! !> @details This requires the symmetry operations of the Rodrigues FZ, which !> includes mirrors and inversion symmetry, i.e., the regular (full) point group !> symmetry of the shape of the RFZ.  We already have those implemented in the !> regular symmetry module, and we assume that those symmetry matrices have been !> initialized and are present in the cell structure.  Then we just call the regular !> CalcStar routine to generate the equivalents and pick the one that is inside !> the MFZ. ! !> @param ro Rodrigues vector !> @param cell cell pointer !> @param FZtype Fundamental Zone type !> @param FZorder Fundamental Zone order !> @param euFZ Euler triplet in fundamental zone (in radians) ! !> @date 07/29/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine ReduceDisorientationtoMFZ ( ro , cell , FZtype , FZorder , roMFZ ) !DEC$ ATTRIBUTES DLLEXPORT :: ReduceDisorientationtoMFZ use local use rotations use quaternions use so3 use typedefs use symmetry IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: ro ( 4 ) type ( unitcell ), pointer , INTENT ( IN ) :: cell integer ( kind = irg ), INTENT ( IN ) :: FZtype integer ( kind = irg ), INTENT ( IN ) :: FZorder real ( kind = dbl ), INTENT ( OUT ) :: roMFZ ( 4 ) real ( kind = dbl ) :: r ( 3 ), rod ( 4 ), mag integer ( kind = irg ) :: i , j , n real ( kind = dbl ) :: stmp ( 48 , 3 ) logical :: inMFZ roMFZ = 0.D0 r ( 1 : 3 ) = ro ( 1 : 3 ) * ro ( 4 ) stmp = 0.0 call CalcStar ( cell , r , n , stmp , 'd' ) MFZloop : do j = 1 , n mag = dsqrt ( sum ( stmp ( j , 1 : 3 ) ** 2 )) rod ( 4 ) = mag rod ( 1 : 3 ) = stmp ( j , 1 : 3 ) / mag inMFZ = IsinsideMFZ ( rod , FZtype , FZorder ) if ( inMFZ ) EXIT MFZloop ! we really should never get to the following line ... if ( j . eq . n ) then write ( * , * ) 'problem ... ' , j , inMFZ write ( * , * ) r , n write ( * , * ) mag , rod write ( * , * ) transpose ( stmp ) stop end if end do MFZloop roMFZ = rod end subroutine ReduceDisorientationtoMFZ !-------------------------------------------------------------------------- ! ! SUBROUTINE: ReduceOrientationtoCubicEFZ ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief Reduce an orientation (Euler angles) to the cubic FZ in Euler space ! !> @param eu Euler triplet (in radians) !> @param dict dict structure !> @param euFZ Euler triplet in Euler fundamental zone (in radians) ! !> @date 07/29/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine ReduceOrientationtoCubicEFZ ( eu , dict , euFZ ) !DEC$ ATTRIBUTES DLLEXPORT :: ReduceOrientationtoCubicEFZ use local use rotations use quaternions use constants use so3 IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: eu ( 3 ) type ( dicttype ), INTENT ( IN ) :: dict real ( kind = dbl ), INTENT ( OUT ) :: euFZ ( 3 ) real ( kind = dbl ) :: Mu ( 4 ), qu ( 4 ), rod ( 4 ), c , s , z integer ( kind = irg ) :: i , j , Pmdims euFZ = 0.D0 Pmdims = dict % Nqsym Mu = eu2qu ( eu ) if ( Mu ( 1 ). lt . 0.D0 ) Mu = - Mu FZloop : do j = 1 , Pmdims qu = quat_mult ( dict % Pm ( 1 : 4 , j ), Mu ) if ( qu ( 1 ). lt . 0.D0 ) qu = - qu euFZ = qu2eu ( qu ) ! apply the cubic Euler FZ boundary conditions c = cos ( euFZ ( 3 )) s = sin ( euFZ ( 3 )) z = acos ( minval ( ( / c / sqrt ( 1 + c * c ), s / sqrt ( 1 + s * s ) / ) )) if (( euFZ ( 2 ). gt . z ). and .( euFZ ( 2 ). lt . cPi / 2 D0 ). and .( euFZ ( 3 ). lt . cPi / 2.D0 )) EXIT FZloop ! we really should never get to the following line ... if ( j . eq . Pmdims ) write ( * , * ) 'problem ... ' , i end do FZloop end subroutine ReduceOrientationtoCubicEFZ !-------------------------------------------------------------------------- ! ! SUBROUTINE: ReduceOrientationtoRFZ ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief Reduce an orientation (Euler angles) to the Rodrigues Fundamental Zone ! !> @param eu Euler triplet (in radians) !> @param dict dict structure !> @param FZtype Fundamental Zone type !> @param FZorder Fundamental Zone order !> @param euFZ Euler triplet in fundamental zone (in radians) !> @param MFZ (optonal) apply MacKenzie cell ! !> @date 07/29/16 MDG 1.0 original !> @date 03/27/17 MDG 1.1 added checking of MacKenzie cell !-------------------------------------------------------------------------- recursive subroutine ReduceOrientationtoRFZ ( eu , dict , FZtype , FZorder , euFZ , MFZ ) !DEC$ ATTRIBUTES DLLEXPORT :: ReduceOrientationtoRFZ use local use rotations use quaternions use so3 use constants IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: eu ( 3 ) type ( dicttype ), INTENT ( IN ) :: dict integer ( kind = irg ), INTENT ( IN ) :: FZtype integer ( kind = irg ), INTENT ( IN ) :: FZorder real ( kind = dbl ), INTENT ( OUT ) :: euFZ ( 3 ) logical , OPTIONAL , INTENT ( IN ) :: MFZ real ( kind = dbl ) :: Mu ( 4 ), qu ( 4 ), rod ( 4 ) integer ( kind = irg ) :: i , j , Pmdims logical :: useMFZ useMFZ = . FALSE . if ( present ( MFZ )) then if ( MFZ . eqv .. TRUE .) then useMFZ = . TRUE . end if endif euFZ = 0.D0 Pmdims = dict % Nqsym Mu = eu2qu ( eu ) if ( Mu ( 1 ). lt . 0.D0 ) Mu = - Mu FZloop : do j = 1 , Pmdims qu = quat_mult ( dict % Pm ( 1 : 4 , j ), Mu ) if ( qu ( 1 ). lt . 0.D0 ) qu = - qu rod = qu2ro ( qu ) if ( abs ( rod ( 4 )) . gt . 1.0D10 ) rod ( 4 ) = inftyd if ( useMFZ . eqv .. TRUE .) then if ( IsinsideMFZ ( rod , FZtype , FZorder )) EXIT FZloop else if ( IsinsideFZ ( rod , FZtype , FZorder )) EXIT FZloop end if ! we really should never get to the following line ... !if (j.eq.Pmdims) write (*,*) 'problem ... ',180.0*eu(1:3)/cPi,eu2ro(eu) end do FZloop euFZ = ro2eu ( rod ) end subroutine ReduceOrientationtoRFZ !-------------------------------------------------------------------------- ! ! SUBROUTINE: getDisorientationAngleDouble ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief Determine the disorientation angle between two orientations (in radians) ! !> @param eu1 first Euler triplet (in radians) !> @param eu2 first Euler triplet (in radians) !> @param dict dict structure !> @param Pmdims number of symmetry operators to consider ! !> @date 07/29/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine getDisorientationAngleDouble ( eu1 , eu2 , dict , disang , ax ) !DEC$ ATTRIBUTES DLLEXPORT :: getDisorientationAngleDouble use local use rotations use quaternions IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: eu1 ( 3 ) real ( kind = dbl ), INTENT ( IN ) :: eu2 ( 3 ) type ( dicttype ), INTENT ( IN ) :: dict real ( kind = dbl ), INTENT ( OUT ) :: disang real ( kind = dbl ), OPTIONAL , INTENT ( OUT ) :: ax ( 3 ) real ( kind = dbl ) :: Mu ( 4 ), qu ( 4 ), Mus ( 4 ), qus ( 4 ), p ( 4 ), ac , a integer ( kind = irg ) :: j , k , Pmdims disang = 0.D0 Pmdims = dict % Nqsym a = sum ( abs ( eu1 - eu2 )) if ( a . ne . 0.D0 ) then Mu = eu2qu ( eu1 ) if ( Mu ( 1 ). lt . 0.D0 ) Mu =- Mu qu = eu2qu ( eu2 ) if ( qu ( 1 ). lt . 0.D0 ) qu =- qu ac = 100 0.D0 do j = 1 , Pmdims ! loop over the symmetric equivalents of Mu Mus = quat_mult ( dict % Pm ( 1 : 4 , j ), Mu ) if ( Mus ( 1 ). lt . 0.D0 ) Mus =- Mus do k = 1 , Pmdims qus = quat_mult ( dict % Pm ( 1 : 4 , k ), qu ) if ( qus ( 1 ). lt . 0.D0 ) qus =- qus p = quat_mult ( Mus , conjg ( qus )) if ( p ( 1 ). lt . 0.D0 ) p =- p a = 2.0 * acos ( p ( 1 )) if ( a . lt . ac ) then ac = a if ( present ( ax )) then ax ( 1 : 3 ) = p ( 2 : 4 ) / NORM2 ( p ( 2 : 4 )) end if end if p = quat_mult ( qus , conjg ( Mus )) if ( p ( 1 ). lt . 0.D0 ) p =- p a = 2.0 * acos ( p ( 1 )) if ( a . lt . ac ) then ac = a if ( present ( ax )) then ax ( 1 : 3 ) = p ( 2 : 4 ) / NORM2 ( p ( 2 : 4 )) end if end if end do end do disang = ac end if end subroutine getDisorientationAngleDouble !-------------------------------------------------------------------------- ! ! SUBROUTINE: getDisorientationAngleSingle ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief Determine the disorientation angle between two orientations (in radians, single precision) ! !> @param eu1 first Euler triplet (in radians) !> @param eu2 first Euler triplet (in radians) !> @param dict dict structure !> @param Pmdims number of symmetry operators to consider ! !> @date 07/29/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine getDisorientationAngleSingle ( eu1 , eu2 , dict , disang , ax ) ! result(disang) !DEC$ ATTRIBUTES DLLEXPORT :: getDisorientationAngleSingle use local use rotations use quaternions IMPLICIT NONE real ( kind = sgl ), INTENT ( IN ) :: eu1 ( 3 ) real ( kind = sgl ), INTENT ( IN ) :: eu2 ( 3 ) type ( dicttype ), INTENT ( INOUT ) :: dict real ( kind = sgl ), INTENT ( OUT ) :: disang real ( kind = dbl ), OPTIONAL , INTENT ( OUT ) :: ax ( 3 ) real ( kind = sgl ) :: Mu ( 4 ), qu ( 4 ), Mus ( 4 ), qus ( 4 ), p ( 4 ), ac , a integer ( kind = irg ) :: j , k , Pmdims disang = 0.0 Pmdims = dict % Nqsym a = sum ( abs ( eu1 - eu2 )) if ( a . ne . 0.0 ) then Mu = eu2qu ( eu1 ) if ( Mu ( 1 ). lt . 0.0 ) Mu =- Mu qu = eu2qu ( eu2 ) if ( qu ( 1 ). lt . 0.0 ) qu =- qu ac = 100 0.0 do j = 1 , Pmdims ! loop over the symmetric equivalents of Mu Mus = quat_mult ( sngl ( dict % Pm ( 1 : 4 , j )), Mu ) if ( Mus ( 1 ). lt . 0.0 ) Mus =- Mus do k = 1 , Pmdims qus = quat_mult ( sngl ( dict % Pm ( 1 : 4 , k )), qu ) if ( qus ( 1 ). lt . 0.0 ) qus =- qus p = quat_mult ( Mus , conjg ( qus )) if ( p ( 1 ). lt . 0.0 ) p =- p a = 2.0 * acos ( p ( 1 )) if ( a . lt . ac ) then ac = a if ( present ( ax )) then ax ( 1 : 3 ) = p ( 2 : 4 ) / NORM2 ( p ( 2 : 4 )) end if end if p = quat_mult ( qus , conjg ( Mus )) if ( p ( 1 ). lt . 0.0 ) p =- p a = 2.0 * acos ( p ( 1 )) if ( a . lt . ac ) then ac = a if ( present ( ax )) then ax ( 1 : 3 ) = p ( 2 : 4 ) / NORM2 ( p ( 2 : 4 )) end if end if end do end do disang = ac end if end subroutine getDisorientationAngleSingle !-------------------------------------------------------------------------- ! ! SUBROUTINE: getDisorientationAngleAxis ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief Determine the disorientation angle and axis between two orientations (in radians) ! !> @param eu1 first Euler triplet (in radians) !> @param eu2 first Euler triplet (in radians) !> @param dict dict structure ! !> @date 02/14/17 SS 1.0 original !-------------------------------------------------------------------------- recursive subroutine getDisorientationAngleAxis ( eu1 , eu2 , dict , disax ) !DEC$ ATTRIBUTES DLLEXPORT :: getDisorientationAngleAxis use local use rotations use quaternions IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: eu1 ( 3 ) real ( kind = dbl ), INTENT ( IN ) :: eu2 ( 3 ) type ( dicttype ), INTENT ( IN ) :: dict real ( kind = dbl ), INTENT ( OUT ) :: disax ( 4 ) real ( kind = dbl ) :: Mu ( 4 ), qu ( 4 ), Mus ( 4 ), qus ( 4 ), p ( 4 ), ac , a , ax ( 3 ) integer ( kind = irg ) :: j , k , Pmdims disax = 0.D0 Pmdims = dict % Nqsym a = sum ( abs ( eu1 - eu2 )) if ( a . ne . 0.D0 ) then Mu = eu2qu ( eu1 ) if ( Mu ( 1 ). lt . 0.D0 ) Mu =- Mu qu = eu2qu ( eu2 ) if ( qu ( 1 ). lt . 0.D0 ) qu =- qu ac = 100 0.D0 do j = 1 , Pmdims ! loop over the symmetric equivalents of Mu Mus = quat_mult ( dict % Pm ( 1 : 4 , j ), Mu ) if ( Mus ( 1 ). lt . 0.D0 ) Mus =- Mus do k = 1 , Pmdims qus = quat_mult ( dict % Pm ( 1 : 4 , k ), qu ) if ( qus ( 1 ). lt . 0.D0 ) qus =- qus p = quat_mult ( Mus , conjg ( qus )) if ( p ( 1 ). lt . 0.D0 ) p =- p a = 2.0 * acos ( p ( 1 )) if ( a . lt . ac ) then ac = a ax ( 1 : 3 ) = p ( 2 : 4 ) / NORM2 ( p ( 2 : 4 )) end if p = quat_mult ( qus , conjg ( Mus )) if ( p ( 1 ). lt . 0.D0 ) p =- p a = 2.0 * acos ( p ( 1 )) if ( a . lt . ac ) then ac = a ax ( 1 : 3 ) = p ( 2 : 4 ) / NORM2 ( p ( 2 : 4 )) end if end do end do disax ( 1 : 3 ) = ax ( 1 : 3 ) disax ( 4 ) = ac end if end subroutine getDisorientationAngleAxis !-------------------------------------------------------------------------- ! ! SUBROUTINE: getDisorientationAngleAxisTwoPhases ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief Determine the disorientation angle and axis between two orientations (in radians) ! !> @param eu1 first Euler triplet (in radians) !> @param eu2 first Euler triplet (in radians) !> @param dict1 dict1 structure !> @param dict2 dict2 structure !> @param disax smallest rotation angle disorientation axis-angle pair ! !> @date 02/14/17 SS 1.0 original !-------------------------------------------------------------------------- recursive subroutine getDisorientationAngleAxisTwoPhases ( eu1 , eu2 , dict1 , dict2 , disax ) !DEC$ ATTRIBUTES DLLEXPORT :: getDisorientationAngleAxisTwoPhases use local use rotations use quaternions IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: eu1 ( 3 ) real ( kind = dbl ), INTENT ( IN ) :: eu2 ( 3 ) type ( dicttype ), INTENT ( IN ) :: dict1 type ( dicttype ), INTENT ( IN ) :: dict2 real ( kind = dbl ), INTENT ( OUT ) :: disax ( 4 ) real ( kind = dbl ) :: Mu ( 4 ), qu ( 4 ), Mus ( 4 ), qus ( 4 ), p ( 4 ), ac , a , ax ( 3 ), axax ( 4 ) integer ( kind = irg ) :: j , k , Pmdims1 , Pmdims2 disax = 0.D0 Pmdims1 = dict1 % Nqsym Pmdims2 = dict2 % Nqsym a = sum ( abs ( eu1 - eu2 )) if ( a . ne . 0.D0 ) then Mu = eu2qu ( eu1 ) if ( Mu ( 1 ). lt . 0.D0 ) Mu =- Mu qu = eu2qu ( eu2 ) if ( qu ( 1 ). lt . 0.D0 ) qu =- qu ac = 100 0.D0 do j = 1 , Pmdims1 ! loop over the symmetric equivalents of Mu Mus = quat_mult ( dict1 % Pm ( 1 : 4 , j ), Mu ) if ( Mus ( 1 ). lt . 0.D0 ) Mus =- Mus do k = 1 , Pmdims2 qus = quat_mult ( dict2 % Pm ( 1 : 4 , k ), qu ) if ( qus ( 1 ). lt . 0.D0 ) qus =- qus p = quat_mult ( Mus , conjg ( qus )) if ( p ( 1 ). lt . 0.D0 ) p =- p a = 2.0 * acos ( p ( 1 )) if ( a . lt . ac ) then ac = a ax ( 1 : 3 ) = p ( 2 : 4 ) / NORM2 ( p ( 2 : 4 )) end if end do end do disax ( 1 : 3 ) = ax ( 1 : 3 ) disax ( 4 ) = ac end if end subroutine getDisorientationAngleAxisTwoPhases end module dictmod","tags":"","loc":"sourcefile/dictmod.f90.html","title":"dictmod.f90 – Fortran Program"},{"text":"This File Depends On sourcefile~~dispfield.f90~~EfferentGraph sourcefile~dispfield.f90 dispfield.f90 sourcefile~pgm.f90 pgm.f90 sourcefile~pgm.f90->sourcefile~dispfield.f90 sourcefile~defectmodule.f90 defectmodule.f90 sourcefile~defectmodule.f90->sourcefile~dispfield.f90 sourcefile~stemmodule.f90 STEMmodule.f90 sourcefile~stemmodule.f90->sourcefile~dispfield.f90 sourcefile~constants.f90 constants.f90 sourcefile~constants.f90->sourcefile~dispfield.f90 sourcefile~constants.f90->sourcefile~defectmodule.f90 sourcefile~namelisthandlers.f90 NameListHandlers.f90 sourcefile~constants.f90->sourcefile~namelisthandlers.f90 sourcefile~timing.f90 timing.f90 sourcefile~timing.f90->sourcefile~dispfield.f90 sourcefile~jsonsupport.f90 JSONsupport.f90 sourcefile~jsonsupport.f90->sourcefile~defectmodule.f90 sourcefile~namelisthandlers.f90->sourcefile~jsonsupport.f90 sourcefile~namelisttypedefs.f90 NameListTypedefs.f90 sourcefile~namelisttypedefs.f90->sourcefile~jsonsupport.f90 sourcefile~namelisttypedefs.f90->sourcefile~namelisthandlers.f90 var pansourcefiledispfieldf90EfferentGraph = svgPanZoom('#sourcefiledispfieldf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Programs dispfield Modules YSHModule Subroutines CalcRLocal Source Code dispfield.f90 Source Code module YSHModule use local IMPLICIT NONE type YDtype real ( kind = sgl ) :: burg ( 3 ), burgd ( 3 ), u ( 3 ), un ( 3 ), g ( 3 ), gn ( 3 ), id , jd , zu , bs , be , bx , beta real ( kind = sgl ) :: alpha , ca , sa , ta , cota , a_dc ( 3 , 3 ), a_id ( 3 , 3 ), a_di ( 3 , 3 ), top ( 3 ), bottom ( 3 ), sig end type YDtype type ( YDtype ), allocatable :: YD (:) !DEC$ ATTRIBUTES DLLEXPORT :: YD contains recursive function YSHDisp ( x , y , z , ii ) !DEC$ ATTRIBUTES DLLEXPORT :: YSHDisp ! ! compute the displacement field of an inclined dislocation intersection the top surface of ! the foil, taking into account surface relaxations for the isotropic elastic case (cubic only) ... ! ! equations are based on the Shaibani&Hazzledine 1981 paper, along with special limits for ! the alpha->0 case, which were derived by MDG using Mathematica. use local use constants IMPLICIT NONE integer ( kind = irg ) :: ii real ( kind = dbl ) :: eta , zeta , etap , zetap , r , oms , omts , xx , sgn , om , omp , AA , BB , BBp , th , & k , lam , alA , alB , u , v , w , ms , S , du , dv , dw , qe , me , De , qx , mx , Dx , rr , eps real ( kind = dbl ) :: x , y , z real ( kind = dbl ) :: YSHDisp ( 3 ) ! initialize the geometrical parameters eta = y * YD ( ii )% ca - z * YD ( ii )% sa zeta = y * YD ( ii )% sa + z * YD ( ii )% ca etap = - y * YD ( ii )% ca - z * YD ( ii )% sa zetap = y * YD ( ii )% sa - z * YD ( ii )% ca r = sqrt ( x ** 2 + y ** 2 + z ** 2 ) oms = 1.D0 - YD ( ii )% sig omts = 1.D0 - 2.D0 * YD ( ii )% sig ! cover the special case of negative x values (based on IDL tests) xx = x if ( xx . lt . 0.D0 ) then x = dabs ( x ) sgn = - 1.D0 else sgn = 1.D0 end if ! more parameters om = ( datan2 ( y , x ) - datan2 ( eta , x ) + datan2 ( x * r * YD ( ii )% sa , eta * y + x ** 2 * YD ( ii )% ca )) omp = ( datan2 ( y , x ) - datan2 ( etap , x ) + datan2 ( x * r * YD ( ii )% sa , etap * y - x ** 2 * YD ( ii )% ca )) AA = r - z BB = r - zeta BBp = r - zetap th = 2.D0 * oms * ( omp - om ) k = 4.D0 * oms * omts * YD ( ii )% cota ** 2 lam = omts * dlog ( BBp / BB ) alA = dlog ( AA ) alB = dlog ( BB ) u = 0.D0 v = 0.D0 w = 0.D0 eps = 1.0D-6 ! screw component first if ( abs ( YD ( ii )% bs ). gt . eps ) then ms = x * sin ( 2.D0 * YD ( ii )% alpha ) / r / BB S = YD ( ii )% bs / ( 4.D0 * cPi ) if ( YD ( ii )% alpha . gt . 0.01 ) then du = x * ms + 2.D0 * eta * YD ( ii )% ca ** 2 / BB + 2.D0 * omts * YD ( ii )% cota * ( - 1.D0 + YD ( ii )% ca + & YD ( ii )% ca * alA - y * YD ( ii )% sa / AA - alB ) - sin ( 2.D0 * YD ( ii )% alpha ) dv = y * ms - 2.D0 * x * YD ( ii )% ca / BB - YD ( ii )% sa * ( omp - om ) + 2.D0 * omts * YD ( ii )% cota * ( x * YD ( ii )% sa / AA - om * YD ( ii )% ca ) dw = z * ms + YD ( ii )% ca * ( omp - om ) - 2.D0 * omts * om * YD ( ii )% ca else du = 2.D0 * y / ( r - z ) dv = 2.D0 * x / ( r - z ) dw = cPi + datan2 ( y , x ) - datan2 ( - y , x ) end if u = u + du * S v = v - sgn * dv * S w = w + sgn * dw * S end if ! then the edge component in the y-z plane if ( abs ( YD ( ii )% be ). gt . eps ) then qe = x * ( 1.D0 / BBp - 1.D0 / BB + 2.D0 * z * YD ( ii )% ca / BB ** 2 ) me = - qe / r - 4.D0 * oms * x * YD ( ii )% ca ** 2 / r / BB De = YD ( ii )% be / ( 8.D0 * cPi * oms ) if ( YD ( ii )% alpha . gt . 0.01 ) then du = x * me + lam + 2.D0 * YD ( ii )% ca * ( z + 2.D0 * oms * eta * YD ( ii )% sa ) / BB - 4.D0 * oms * YD ( ii )% sa ** 2 + k * ( 1.D0 - YD ( ii )% ca - YD ( ii )% ca * alA + & y * YD ( ii )% sa / AA + alB ) dv = y * me + qe * YD ( ii )% sa + th * YD ( ii )% ca + k * ( - x * YD ( ii )% sa / AA + om * YD ( ii )% ca ) dw = z * me + qe * YD ( ii )% ca + th * YD ( ii )% sa - 2.D0 * x * YD ( ii )% ca * ( 1.D0 / BBp + omts / BB ) + k * om * YD ( ii )% sa !    write (*,*) du,dv,dw else rr = x ** 2 + y ** 2 du = 2.D0 * z / ( r - z ) + 4.D0 * x ** 2 * ( YD ( ii )% sig * rr - r ** 2 ) / r / AA ** 2 / ( r + z ) + 2.D0 * omts * oms * (( x ** 2 + z * ( z + r )) / AA ** 2 + alA ) + omts * dlog (( r + z ) / AA ) dv = 4.D0 * x * y * ( rr * YD ( ii )% sig - r ** 2 ) / r / AA ** 2 / ( r + z ) + 2.D0 * x * y * ( rr + 2.D0 * z * ( r + z )) * oms * omts / rr ** 2 + & 2.D0 * oms * ( cPi + datan2 ( y , x ) - datan2 ( - y , x )) dw = 4.D0 * x * rr * YD ( ii )% sig * ( z - 2.D0 * r * oms ) / r / AA ** 2 / ( r + z ) end if u = u + du * De v = v + sgn * dv * De w = w + sgn * dw * De end if ! and finally the bx edge component if ( abs ( YD ( ii )% bx ). gt . eps ) then qx = etap / BBp - eta / BB - 2.D0 * z * eta * YD ( ii )% ca / BB ** 2 mx = - qx / r + 2.D0 * omts * y * YD ( ii )% ca / r / BB Dx = YD ( ii )% bx / ( 8.D0 * cPi * oms ) du = x * mx + th + k * ( x * YD ( ii )% ta / AA - om ) dv = y * mx + qx * YD ( ii )% sa - lam * YD ( ii )% ca - 2.D0 * YD ( ii )% ca * ( z * YD ( ii )% ca + omts * y * YD ( ii )% sa ) / BB + k * ( - 1.D0 + YD ( ii )% ca - alA + y * YD ( ii )% ta / AA + & YD ( ii )% ca * alB ) dw = z * mx + qx * YD ( ii )% ca - lam * YD ( ii )% sa - 2.D0 * etap * YD ( ii )% ca / BBp + 4.D0 * YD ( ii )% ca * ( oms * y * YD ( ii )% ca - omts * z * YD ( ii )% sa ) / BB + & k * YD ( ii )% ta * ( YD ( ii )% ca - alA + YD ( ii )% ca * alB ) + 4.D0 * oms * YD ( ii )% ca * YD ( ii )% cota u = u + sgn * du * Dx v = v + dv * Dx w = w + dw * Dx end if ! and return the displacement components !write (*,*) u,v,w YSHDisp = ( / u , v , w / ) end function YSHDisp recursive subroutine makeYSHdislocation ( i , dinfo , L ) !DEC$ ATTRIBUTES DLLEXPORT :: makeYSHdislocation ! ! this routine pre-computes a number of parameters related to the ! geometry of the Yoffe&Shaibani&Hazzledine (YSH) surface-relaxed dislocation in an elastically ! isotropic matrix.  These parameters are then used in the CalcR routine. ! ! We implemented the YSH expressions instead of Yoffe's ! since the former are more easily handled for numerical computations. ! SH have redefined the x-y-z reference frame used by Yoffe to fall along ! the dislocation line itself.  As a result, the Burgers vector must be decomposed ! into a screw component and two edge components, one in the plane of the ! discontinuity, the other normal to that plane (which is by definition the x-axis). ! Check the SH paper for more details. use local use foilmodule use constants use crystal IMPLICIT NONE real ( kind = sgl ) :: alpha , beta , L , tu ( 3 ), tx ( 3 ), ty ( 3 ), te ( 3 ), tb ( 3 ), bl integer ( kind = irg ) :: i , dinfo ! first, determine the alpha angle between the ! negative z-axis, which is really the negative foil normal, and the line direction ! (make sure to reduce the angle to [0,90] interval). alpha = CalcAngle ( - foil % F , YD ( i )% u , 'd' ) * 18 0.0 / cPi if ( alpha . gt . 9 0.0 ) then alpha = 18 0.0 - alpha YD ( i )% u = - YD ( i )% u ! the u-direction should point down into the foil end if write ( * , * ) 'Foil normal = ' , foil % F write ( * , * ) 'line direction = ' , YD ( i )% u write ( * , * ) '  --> alpha angle = ' , alpha alpha = alpha * cPi / 18 0.0 call TransSpace ( YD ( i )% u , tu , 'd' , 'c' ) call NormVec ( tu , 'c' ) call TransSpace ( foil % F , ty , 'd' , 'c' ) call NormVec ( ty , 'c' ) call CalcCross ( tu , ty , tx , 'c' , 'c' , 0 ) ! x = u x F call NormVec ( tx , 'c' ) call CalcCross ( tx , tu , te , 'c' , 'c' , 0 ) ! e = x x u call NormVec ( te , 'c' ) call CalcCross ( ty , tx , ty , 'c' , 'c' , 0 ) call NormVec ( ty , 'c' ) bl = CalcLength ( YD ( i )% burg , 'd' ) write ( * , * ) ' tx = ' , tx write ( * , * ) ' te = ' , te write ( * , * ) ' tu = ' , tu write ( * , * ) ' ty = ' , ty write ( * , * ) ' bl = ' , bl call TransSpace ( YD ( i )% burg , tb , 'd' , 'c' ) call NormVec ( tb , 'c' ) YD ( i )% bx = bl * CalcDot ( tb , tx , 'c' ) ! edge component normal to cut plane YD ( i )% be = bl * CalcDot ( tb , te , 'c' ) ! edge component in cut plane YD ( i )% bs = bl * CalcDot ( tb , tu , 'c' ) ! screw component write ( * , * ) 'Burgers vector components (bx,be,bs) ' , YD ( i )% bx , YD ( i )% be , YD ( i )% bs ! we will also need to know the rotation matrix between the dislocation reference frame ! and the foil reference frame, so that we can transform the foil coordinates to defect ! coordinates...  We need the angle beta between the defect x axis (tx) and the foil x axis, ! which is the first column of the foil%a_fc matrix ... ty ( 1 : 3 ) = foil % a_fc ( 1 : 3 , 1 ) write ( * , * ) ' tx = ' , tx YD ( i )% beta = CalcAngle ( tx , ty , 'd' ) write ( * , * ) ' ty = ' , ty write ( * , * ) ' beta = ' , YD ( i )% beta beta = YD ( i )% beta YD ( i )% a_di ( 1 , 1 : 3 ) = ( / cos ( beta ), - sin ( beta ), 0.0 / ) YD ( i )% a_di ( 2 , 1 : 3 ) = ( / sin ( beta ), cos ( beta ), 0.0 / ) YD ( i )% a_di ( 3 , 1 : 3 ) = ( / 0.0 , 0.0 , 1.0 / ) YD ( i )% a_id = transpose ( YD ( i )% a_di ) write ( * , * ) YD ( i )% a_di ! finally some geometrical parameters needed for the displacement field computation... YD ( i )% alpha = alpha YD ( i )% ca = cos ( alpha ) YD ( i )% sa = sin ( alpha ) YD ( i )% ta = tan ( alpha ) YD ( i )% cota = 1.0 / YD ( i )% ta write ( * , * ) 'angulars = ' , cos ( alpha ), sin ( alpha ), tan ( alpha ) ! that's it! the rest is handled in the CalcR routine. end subroutine makeYSHdislocation recursive subroutine read_YSH_dislocation_data ( dislYname , numYdisl , DF_npix , DF_npiy , DF_gf , L , dinfo ) !DEC$ ATTRIBUTES DLLEXPORT :: read_YSH_dislocation_data use local use io use files use typedefs IMPLICIT NONE integer ( kind = irg ) :: i , numYdisl , dinfo , DF_npix , DF_npiy real ( kind = sgl ) :: id , jd , u ( 3 ), bv ( 3 ), DF_gf ( 3 ), L , poisson character ( 50 ) :: dislYname ( 3 * maxdefects ) namelist / dislocationdata / id , jd , u , bv , poisson ! allocate the memory for the dislocation parameters allocate ( YD ( numYdisl )) ! these are just the individual dislocations; the ones that belong to ! stacking faults are handled separately do i = 1 , numYdisl mess = 'opening ' // dislYname ( i ); call Message ( \"(/A)\" ) open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( dislYname ( i ))), DELIM = 'APOSTROPHE' ) read ( UNIT = dataunit , NML = dislocationdata ) close ( UNIT = dataunit ) ! top-of-the-foil intersection of dislocation line is transformed to foil coordinates [nm] with DL(i)%kd=0 (center of foil) [verified 4/23/11] ! the point (0,0) is at the center of the image ... hence the factor of 0.5 YD ( i )% id = id * 0.5 * float ( DF_npix ) ! * L   scaling (zooming) is done in the image reference frame... YD ( i )% jd = jd * 0.5 * float ( DF_npiy ) ! * L YD ( i )% u = u YD ( i )% burg = bv YD ( i )% g = DF_gf YD ( i )% sig = poisson ! and pre-compute the dislocation displacement field parameters call makeYSHdislocation ( i , dinfo , L ) end do end subroutine read_YSH_dislocation_data end module YSHModule program dispfield ! use local use typedefs use crystalvars use crystal use symmetryvars use symmetry use postscript use constants use diffraction use dynamical use files use io use foilmodule use stacking_fault use dislocation use void use inclusion use defectmodule use TIFF_global use TIFF_f90 use pgm use timing use STEMmodule use YSHModule IMPLICIT NONE integer ( kind = irg ) :: ira , nn , izero , i , j , k , n , nsl , numi , npix , npiy , ii , jj , numvoids , numdisl , numsf , & numinc , dinfo , t_interval , outputfirst , outputlast , DF_nums_new , numYdisl , & DF_npix_new , DF_npiy_new , numstart , numstop , isg , TID , NTHR , jcnt , numCL , iCL !                                  OMP_GET_THREAD_NUM,OMP_GET_NUM_THREADS real ( kind = sgl ) :: ind ( 3 ), hkl ( 3 ), exerg , cosom , glen , exer , dgr , sl , thr , arg , zmax , thick , mi , ma , & att , xgp , DF_gf ( 3 ), DF_gd ( 3 , maxdefects ) character ( 50 ) :: fname , sgname , voidname , dislname ( 3 * maxdefects ), sfname ( maxdefects ), outputroot , & incname , dispfile , dislYname ( 3 * maxdefects ) character ( 100 ) :: imname character ( 4 ) :: outputformat , illumination_mode , dispmode character ( 5 ) :: fnumber ( - 10 : 10 ) character ( len = 10 ) :: ci complex ( kind = dbl ) :: czero , cone real ( kind = sgl ), allocatable :: disparray (:,:,:,:) namelist / rundata / DF_L , DF_npix , DF_npiy , DF_slice , Nmat , sgname , numvoids , incname , & voidname , numdisl , dislname , numYdisl , dislYname , numsf , sfname , dinfo , outputformat , & outputroot , t_interval , illumination_mode , outputfirst , outputlast , dispfile , & dispmode ! display the standard program info progname = 'dispfield.f90' progdesc = 'Defect displacement field simulation program' call EMsoft ! get the crystal data and microscope voltage SG % SYM_reduce = . TRUE . call CrystalData ! read crystal structure hexset = . FALSE . czero = cmplx ( 0.0 , 0.0 , dbl ) cone = cmplx ( 1.0 , 0.0 , dbl ) ! here we read the general simulation information from a namelist file SRdef_rundata.nml ! first we define the default values DF_L = 1.0 ! edge length of column in nanometers DF_npix = 256 ! number of image pixels along x DF_npiy = 256 ! number of image pixels along y DF_slice = 1.0 ! slice thickness in nanometers Nmat = 10000 ! number of precomputed A matrices to be stored dinfo = 0 ! switch to make makedislocation verbose sgname = 'nofile' ! if this variable is different from 'nofile', then an external sg array is read (to be implemented) numdisl = 0 ! number of dislocation files numYdisl = 0 ! number of Yoffe dislocation files numsf = 0 ! number of stacking fault files numinc = 0 ! number of inclusions numvoids = 0 ! number of voids voidname = 'none' ! filename for void data dislname = '' ! filenames for dislocation data dislYname = '' ! filenames for Yoffe dislocation data sfname = '' ! filenames for stacking fault data incname = 'none' ! filename for inclusion data outputformat = 'data' ! format for output data, can be 'data', 'pgm', or 'tiff' outputroot = 'image' ! default root name for output files outputfirst = 1 ! first image number to be written to file (will be set to first image in SR) outputlast = nn ! last image number to be written to file (will be set to last image in SR) t_interval = 10 ! default timing interval (output every t_interval image columns) dispfile = 'none' ! name of the displacement field output file (will be created if different from none) dispmode = 'not' ! should a diplacement file be written ('new') or read ('old') or neither ('not')? illumination_mode = 'EM' ! default illumination mode (can be 'EM' or 'STEM') ! then we read the rundata namelist, which may override some of these defaults OPEN ( UNIT = dataunit , FILE = 'SRdef_rundata.nml' , DELIM = 'APOSTROPHE' ) READ ( UNIT = dataunit , NML = rundata ) CLOSE ( UNIT = dataunit ) ! next, we read the foildata namelist from the SRdef_foildata.nml file ! this includes material property data, in this case the elastic moduli ! in particular, the foilmodule MUST compute the beam direction from ! the sample tilt angles !!! call read_foil_data ( DF_npix , DF_npiy , DF_L ) ! define the foil thickness, attenuation, and number slices per column thick = foil % zb ! this is the same everywhere for this version; needs to be updated in the next version DF_nums = nint ( thick / DF_slice ) ! this is the number of slices for this particular column ! next, deal with all the defects ! ! if there is a diplacement field file entered in the STEM_rundata.nml file, ! then we simply read that file in; otherwise, we read all the defect descriptor files ! is there a void data filename? If so, then read it if ( voidname . ne . 'none' ) call read_void_data ( numvoids , voidname , DF_L , DF_npix , DF_npiy , dinfo ) ! read namelist files for all dislocations, if any if ( numdisl . gt . 0 ) call read_dislocation_data ( dislname , numdisl , numsf , DF_npix , DF_npiy , DF_gf , DF_L , dinfo ) ! read namelist files for all Yoffe dislocations, if any if ( numYdisl . gt . 0 ) call read_YSH_dislocation_data ( dislYname , numYdisl , DF_npix , DF_npiy , DF_gf , DF_L , dinfo ) ! read namelist files for all stacking faults, if any if ( numsf . gt . 0 ) call read_stacking_fault_data ( numsf , numdisl , sfname , DF_L , DF_npix , DF_npiy , DF_g , dinfo ) ! is there an inclusion data file? if so, then read it if ( incname . ne . 'none' ) call read_inclusion_data ( numinc , incname , DF_L , DF_npix , DF_npiy , dinfo ) ! transform the g-vector to the defect reference frames (needed for all dislocations in CalcR). ! this can only be done AFTER all dislocations and stacking faults have been created. do i = 1 , numdisl DF_gd ( 0 : 2 , i ) = matmul ( DL ( i )% a_dc , DF_gc ) end do ! precompute ALL the defect columns and, if needed, store them in dispfile ! this portion should be carried out in multi-threaded mode as much as possible allocate ( disparray ( DF_nums , DF_npix , DF_npiy , 3 )) disparray = 0.0 mess = ' Starting Displacement Field Computation ' ; call Message ( \"(A/)\" ) call CalcRLocal ( numvoids , numdisl , numYdisl , numsf , numinc , DF_nums , DF_npix , DF_npiy , t_interval , disparray ) write ( * , * ) maxval ( disparray ), minval ( disparray ) ! and, if needed, store the defect displacement field for re-runs mess = 'Displacement field data stored in file ' // dispfile ; call Message ( \"(/A/)\" ) open ( unit = dataunit , file = trim ( EMsoft_toNativePath ( dispfile )), status = 'new' , action = 'write' , form = 'unformatted' ) i = 3 write ( dataunit ) DF_nums , DF_npix , DF_npiy , i write ( dataunit ) disparray call SafeCloseFile ( 'd1' , 'keep' , dispfile ,. FALSE .) end program dispfield recursive subroutine CalcRLocal ( numvoids , numdisl , numYdisl , numsf , numinc , lDFnums , lDFnpix , lDFnpiy , t_interval , disparray ) ! this routine returns the total displacement field (multithreaded with OPENMP) use local use constants use crystal use crystalvars use dislocation use foilmodule use void use stacking_fault use inclusion use defectmodule use timing use YSHModule IMPLICIT NONE integer ( kind = irg ) :: i , j , k , ii , islice , numvoids , numdisl , numYdisl , numsf , numinc , lDFnums , lDFnpix , lDFnpiy , & TID , NTHR , imat , t_interval , jcnt real ( kind = sgl ) :: disparray ( lDFnums , lDFnpix , lDFnpiy , 3 ) real ( kind = sgl ) :: rx , ry , rz , dis , xpos , ypos , zpos , RR ( 3 ), sumR ( 3 ), thick , tmp ( 3 ), tmpf ( 3 ), u ( 3 ), zaamp , zaphase , zar , zai , zr ( 3 ), zi ( 3 ), & zt , fx , fy , fz , z0 , gdotR , nunit ( 3 ) !,& !                                nu,x,y,z,zn,t,pre,r1,r2,r3,th,rn real ( kind = dbl ) :: afi ( 3 , 3 ), afc ( 3 , 3 ), lDFR ( 3 ) complex ( kind = dbl ) :: za ( 3 ) complex ( kind = sgl ) :: zero logical :: void type ( voidtype ), allocatable :: lvoids (:) real ( kind = sgl ), allocatable :: lsg (:,:) type ( dislocationtype ), allocatable :: lDL (:) type ( YDtype ), allocatable :: YDL (:) type ( stackingfaulttype ), allocatable :: lSF (:) type ( inclusiontype ), allocatable :: linclusions (:) ! before we start the threads, we need to copy data from various modules ! into local variables that can then be accessed by the threads ... Nmat = 10000 ! foil unit normal in microscope frame nunit = matmul ( foil % Fn , transpose ( foil % a_mc )) ! foil normal parameters for zpos computation fx = - nunit ( 1 ) / nunit ( 3 ) fy = - nunit ( 2 ) / nunit ( 3 ) fz = foil % zb * 0.5 ! other parameters z0 = foil % z0 thick = foil % zb zero = cmplx ( 0.0 , 0.0 ) afi = foil % a_fi afc = foil % a_fc if ( allocated ( voids )) then allocate ( lvoids ( numvoids )) lvoids = voids endif allocate ( lsg ( foil % npix , foil % npiy )) lsg = foil % sg if ( allocated ( DL )) then allocate ( lDL ( numdisl + 2 * numsf )) lDL = DL endif if ( allocated ( YD )) then allocate ( YDL ( numYdisl )) YDL = YD endif if ( allocated ( SF )) then allocate ( lSF ( numsf )) do ii = 1 , numsf allocate ( lSF ( ii )% zpos ( foil % npix , foil % npiy )) end do lSF = SF endif if ( allocated ( inclusions )) then allocate ( linclusions ( numinc )) linclusions = inclusions end if ! ok, we've copied all the necessary variables into local structures ! now we can perform the multi-threaded loop ! initiate multi-threaded segment !$OMP     PARALLEL PRIVATE(TID,lDFR,gdotR,i,j,k,imat,zt,xpos,ypos,zpos,islice,dis,sumR,tmp,tmpf, & !$OMP&   ii,void,za,zar,zai,zaamp,zaphase,zr,zi,u,jcnt) & !$OMP&   SHARED(NTHR,lDFnpix,lDFnpiy,lDFnums,DF_L,numvoids,numdisl,numsf,numinc,disparray,t_interval, & !$OMP&    fx,fy,fz,z0,thick,zero,afi,afc,lvoids,lsg,lSF,linclusions,lDL,Nmat,YDL) !  NTHR = OMP_GET_NUM_THREADS() !  TID = OMP_GET_THREAD_NUM() TID = 0 NTHR = 1 if ( TID . eq . 0 ) then ! do time reporting only in the master thread write ( * , * ) 'Message from master thread ' , TID , ': splitting into ' , NTHR , ' threads ' call Time_reset call Time_report ( 0.01 * t_interval ) call Time_start jcnt = 0 end if !$OMP barrier !$OMP DO SCHEDULE (GUIDED) do i = 1 , lDFnpix do j = 1 , lDFnpiy ! compute the displacement vectors lDFR for all points in this column ! scale the image coordinates with respect to the origin at the center of the image; ! this is where we need to include the zoom factor ... xpos = float ( i - lDFnpix / 2 ) * DF_L ypos = float ( j - lDFnpiy / 2 ) * DF_L zt = ( xpos * fx + ypos * fy + fz ) ! loop over all slices (this is the main loop) sliceloop : do islice = 1 , lDFnums lDFR = 0.0 ! zpos is the position down the column, starting at zt (in image coordinates) zpos = zt - float ( islice ) * DF_slice ! set the displacements to zero sumR = 0.0 ! convert image point (xpos,ypos,zpos) to tmpf in the foil reference frame !       tmpf = matmul(matmul( (/ xpos, ypos, zpos /),transpose(afi)),afc) tmpf = matmul ( ( / xpos , ypos , zpos / ), transpose ( afi )) ! let's put a few dislocations in ... (see section 8.4.2) do ii = 1 , numdisl ! convert the defect location from untilted image space to the tilted foil reference frame, and subtract it from the current ! column and slice position tmp = ( / xpos , ypos , zpos / ) - matmul ( ( / DF_L * lDL ( ii )% id , DF_L * lDL ( ii )% jd , lDL ( ii )% zfrac * z0 / ), transpose ( afi ) ) ! then convert the difference vector to the defect reference frame for this dislocation (we will only need the x and y coordinates) tmp = matmul ( tmp , lDL ( ii )% a_id ) ! check the z-coordinate; if it falls beyond the dislocation line that is inside the foil, then skip ! the displacement computation... the top and bottom coordinates of the dislocation intersections ! measured along the dislocation line were pre-computed when the dislocations were first read from ! the namelist files... !         if (abs(tmp(3)).le.lDL(ii)%zu) then ! compute x1 + p_alpha x2  (eq. 8.38) za ( 1 : 3 ) = tmp ( 1 ) + lDL ( ii )% pa ( 1 : 3 ) * tmp ( 2 ) ! compute the displacement vector u (eq. 8.38) [this expands the log of a complex number and takes the real part only] if ( tmp ( 1 ). gt . 0.0 ) then do k = 1 , 3 zar = real ( za ( k )) zai = aimag ( za ( k )) zaamp = abs ( za ( k )) zaphase = abs ( zai / zar ) zr ( k ) = log ( zaamp ) zi ( k ) = atan ( zaphase ) if ( zar . le . 0.0 ) then if ( zai . lt . 0.0 ) zi ( k ) = - cPi + zi ( k ) if ( zai . eq . 0.0 ) zi ( k ) = cPi if ( zai . gt . 0.0 ) zi ( k ) = cPi - zi ( k ) else if ( zai . lt . 0.0 ) zi ( k ) = - zi ( k ) end if end do else do k = 1 , 3 zar = real ( za ( k )) zai = aimag ( za ( k )) zaamp = abs ( za ( k )) zaphase = abs ( zai / zar ) zr ( k ) = log ( zaamp ) zi ( k ) = atan ( zaphase ) if ( zar . le . 0.0 ) then if ( zai . gt . 0.0 ) zi ( k ) = cPi - zi ( k ) if ( zai . eq . 0.0 ) zi ( k ) = cPi if ( zai . lt . 0.0 ) zi ( k ) = cPi + zi ( k ) else if ( zai . lt . 0.0 ) zi ( k ) = 2.0 * cPi - zi ( k ) if ( zai . eq . 0.0 ) zi ( k ) = 0.0 end if end do end if u = 2.0 * real ( matmul ( lDL ( ii )% dismat , cmplx ( zr , zi ))) ! transform displacement vector u to the Cartesian crystal reference frame and then to the foil frame u = matmul ( matmul ( u , lDL ( ii )% a_dc ), transpose ( afc )) sumR = sumR + u !         end if end do ! do we have any dislocations with surface relaxations ?  YSH model if ( numYdisl . gt . 0 ) then do ii = 1 , numYdisl ! first, figure out what the coordinates are in the YSH reference frame for this dislocation ... ! translate to the defect origin tmp = ( / xpos , ypos , zpos / ) - ( / DF_L * YDL ( ii )% id , DF_L * YDL ( ii )% jd , z0 * 0.5 / ) ! rotate into the defect reference frame tmp = matmul ( tmp , YDL ( ii )% a_id ) ! compute the displacement vector u = sngl ( YSHDisp ( dble ( tmp ( 1 )), dble ( tmp ( 2 )), dble ( tmp ( 3 )), ii )) !         write (*,*) u ! and rotate back to the image reference frame u = matmul ( u , YDL ( ii )% a_di ) ! that should do it ! sumR = sumR + u end do end if ! stacking faults (this is easy because we've already done all the work in the stacking_fault module) !       do ii=1,numsf !         if ((zpos.lt.lSF(ii)%zpos(i,j)).and.(lSF(ii)%zpos(i,j).ne.-10000.0)) then !           sumR = sumR + lSF(ii)%lpbc !         end if !       end do ! write(*,*) sumR(1:3) disparray ( islice , i , j , 1 : 3 ) = sumR ( 1 : 3 ) !      if (i.eq.10) write (*,*) sumR(1:3) end do sliceloop end do ! j-loop if ( TID . eq . 0 ) then jcnt = jcnt + 1 if ( mod ( jcnt , t_interval ). eq . 0 ) call Time_remaining ( jcnt , lDFnpix / NTHR ) endif end do ! i-loop !$OMP END DO if ( TID . eq . 0 ) call Time_stop ( DF_npix * DF_npiy ) !$OMP END PARALLEL end subroutine CalcRLocal","tags":"","loc":"sourcefile/dispfield.f90.html","title":"dispfield.f90 – Fortran Program"},{"text":"Files Dependent On This One sourcefile~~distortion.f90~~AfferentGraph sourcefile~distortion.f90 distortion.f90 sourcefile~emdymod.f90 EMdymod.f90 sourcefile~distortion.f90->sourcefile~emdymod.f90 sourcefile~simulated_annealing.f90 simulated_annealing.f90 sourcefile~emdymod.f90->sourcefile~simulated_annealing.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules distortion Source Code distortion.f90 Source Code ! ################################################################### ! Copyright (c) 2016, Marc De Graef/Carnegie Mellon University ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without modification, are ! permitted provided that the following conditions are met: ! !     - Redistributions of source code must retain the above copyright notice, this list !        of conditions and the following disclaimer. !     - Redistributions in binary form must reproduce the above copyright notice, this !        list of conditions and the following disclaimer in the documentation and/or !        other materials provided with the distribution. !     - Neither the names of Marc De Graef, Carnegie Mellon University nor the names !        of its contributors may be used to endorse or promote products derived from !        this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE ! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ################################################################### !-------------------------------------------------------------------------- ! EMsoft:Distortion.f90 !-------------------------------------------------------------------------- ! ! MODULE: Distortion ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief !> Everything to do with distortion in electron microscopy ! !> @details !> this module takes care of distortions in electron microscopy modalities due to imperfect lenses ! !> @date 1/18/16 SS 1.0 original !-------------------------------------------------------------------------- module distortion use local IMPLICIT NONE contains !-------------------------------------------------------------------------- ! ! SUBROUTINE:BarrelDistortion ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief barrel distortion observed in TESCAN MIRA microscope ! !> @param D     complex distortion coefficient !> @param img   Input=undistorted image/output = distorted image !> @param nnx   size of image in x !> @param nny   size of image in y ! !> @date 06/24/14  SS 1.0 original !> @date 01/25/16 MDG 1.1 minor mods to make routine more efficient !-------------------------------------------------------------------------- recursive subroutine BarrelDistortion ( D , img , nnx , nny ) !DEC$ ATTRIBUTES DLLEXPORT :: BarrelDistortion use math IMPLICIT NONE complex ( kind = dbl ), INTENT ( IN ) :: D real ( kind = sgl ), INTENT ( INOUT ) :: img ( nnx , nny ) integer ( kind = irg ), INTENT ( IN ) :: nnx , nny real ( kind = sgl ), allocatable :: dimg (:,:) real ( kind = dbl ) :: co ( 4 ), Dp , thetad integer ( kind = irg ) :: ii , jj , I ( 1 ) complex ( kind = dbl ) :: roots ( 3 ) real ( kind = dbl ) :: x , y , r0 , r , Ap , Bp , theta integer ( kind = irg ) :: nix , niy , nixp , niyp real ( kind = dbl ) :: x_new , y_new , dx , dy , dxm , dym , shx , shy , x2 , tmp , x_new_s , y_new_s real ( kind = dbl ), parameter :: epsdp = 1.0D-8 , epsth = 1.0D-2 Dp = abs ( D ) thetad = datan2 ( imag ( D ), real ( D )) if ( Dp . le . epsdp ) return allocate ( dimg ( nnx , nny )) dimg = 0.0 x_new_s = dble ( nnx ) * 0.5D0 y_new_s = dble ( nny ) * 0.5D0 shx = dble ( floor ( x_new_s )) shy = dble ( floor ( y_new_s )) do ii = 1 , nnx x = dble ( ii ) - shx x2 = x * x do jj = 1 , nny y = dble ( jj ) - shy co = ( / Dp * Dp , 2.D0 * Dp * dcos ( thetad ), 1.D0 , - ( x2 + y * y ) / ) r0 = dsqrt ( - co ( 4 )) if ( r0 . eq . 0 D0 ) then r = 0.D0 Ap = 0.D0 Bp = 0.D0 else if ( abs ( thetad ) . le . epsth ) then co = ( / Dp , 0.D0 , 1.D0 , - dsqrt ( x2 + y * y ) / ) call cubicroots ( co , roots ) I = MINLOC (( / abs ( imag ( roots ( 1 ))), abs ( imag ( roots ( 2 ))), abs ( imag ( roots ( 3 ))) / )) r = real ( roots ( I ( 1 ))) theta = datan2 ( y , x ) else call cubicroots ( co , roots ) I = MINLOC (( / abs ( imag ( roots ( 1 ))), abs ( imag ( roots ( 2 ))), abs ( imag ( roots ( 3 ))) / )) r = dsqrt ( real ( roots ( I ( 1 )))) tmp = Dp * r * r * r / r0 Ap = r / r0 + tmp * dcos ( thetad ) Bp = tmp * dsin ( thetad ) theta = datan2 ( y , x ) - datan2 ( Bp , Ap ) end if end if x_new = r * dcos ( theta ) y_new = r * dsin ( theta ) nix = floor ( x_new + x_new_s ) nixp = nix + 1 dx = x_new + shx - dble ( nix ) niy = floor ( y_new + y_new_s ) niyp = niy + 1 dy = y_new + shy - dble ( niy ) if ( nix . lt . 1 ) then nix = 1 dx = 1.D0 end if if ( nix . gt . nnx ) then nix = nnx dx = 0.D0 end if if ( niy . lt . 1 ) then niy = 1 dy = 1.D0 end if if ( niy . gt . nny ) then niy = nny dy = 0.D0 end if if ( nixp . lt . 1 ) nixp = 1 if ( nixp . gt . nnx ) nixp = nnx if ( niyp . lt . 1 ) niyp = 1 if ( niyp . gt . nny ) niyp = nny dxm = 1.D0 - dx dym = 1.D0 - dy dimg ( ii , jj ) = img ( nix , niy ) * dxm * dym + img ( nixp , niy ) * dxm * dy + & img ( nix , niyp ) * dx * dym + img ( nixp , niyp ) * dx * dy end do end do img = dimg deallocate ( dimg ) end subroutine BarrelDistortion end module distortion","tags":"","loc":"sourcefile/distortion.f90.html","title":"distortion.f90 – Fortran Program"},{"text":"This File Depends On sourcefile~~eccimod.f90~~EfferentGraph sourcefile~eccimod.f90 ECCImod.f90 sourcefile~constants.f90 constants.f90 sourcefile~constants.f90->sourcefile~eccimod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules ECCImod Source Code ECCImod.f90 Source Code ! ################################################################### ! Copyright (c) 2013-2015, Marc De Graef/Carnegie Mellon University ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without modification, are ! permitted provided that the following conditions are met: ! !     - Redistributions of source code must retain the above copyright notice, this list !        of conditions and the following disclaimer. !     - Redistributions in binary form must reproduce the above copyright notice, this !        list of conditions and the following disclaimer in the documentation and/or !        other materials provided with the distribution. !     - Neither the names of Marc De Graef, Carnegie Mellon University nor the names !        of its contributors may be used to endorse or promote products derived from !        this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE ! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ################################################################### !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- ! EMsoft:ECCImod.f90 !-------------------------------------------------------------------------- ! ! MODULE: ECCImod ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief EMECCI helper routines ! !> @date 11/25/15 MDG 1.0 original !--------------------------------------------------------------------------- module ECCImod use local IMPLICIT NONE contains !-------------------------------------------------------------------------- ! ! SUBROUTINE: Calckvectorcone ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief compute a set of incident beam directions for single image ECCI mode ! !> @param cell unit cell pointer !> @param khead head of kvector linked list !> @param k incident wave vector (zone axis) !> @param ga principal g vector !> @param ktxy tangential components !> @param ktrad cone opening angle !> @param ktstep number of steps along cone radius !> @param numk resulting number of incident beam directions ! !> @date 11/29/01 MDG 1.0 original !> @date 12/05/13 MDG 2.0 adapted for ECCI simulations !> @date 12/01/15 MDG 2.1 simplification of input parameters !-------------------------------------------------------------------------- recursive subroutine Calckvectorcone ( cell , khead , k , ga , ktxy , ktrad , ktstep , numk ) !DEC$ ATTRIBUTES DLLEXPORT :: Calckvectorcone use io use error use diffraction use crystal use kvectors IMPLICIT NONE type ( unitcell ), pointer :: cell type ( kvectorlist ), pointer :: khead integer ( kind = irg ), INTENT ( IN ) :: k ( 3 ) integer ( kind = irg ), INTENT ( IN ) :: ga ( 3 ) real ( kind = sgl ), INTENT ( IN ) :: ktxy ( 2 ) real ( kind = sgl ), INTENT ( IN ) :: ktrad integer ( kind = irg ), INTENT ( IN ) :: ktstep integer ( kind = irg ), INTENT ( OUT ) :: numk type ( kvectorlist ), pointer :: ktmp , ktail integer :: istat , imin , imax , jmin , jmax , ijmax , i , j , ic , jc , ki real :: kr ( 3 ), glen , delta , kstar ( 3 ), kt ( 3 ), gan ( 3 ), gperp ( 3 ), ktlen , dkt ! compute geometrical factors glen = CalcLength ( cell , float ( ga ), 'r' ) ! length of ga gan = ga / glen ! normalized ga delta = ktrad * glen / float ( ktstep ) ! grid step size in nm-1 dkt = ktrad / float ( ktstep ) call TransSpace ( cell , float ( k ), kstar , 'd' , 'r' ) ! transform incident direction to reciprocal space call CalcCross ( cell , float ( ga ), kstar , gperp , 'r' , 'r' , 0 ) ! compute g_perp = ga x k call NormVec ( cell , gperp , 'r' ) ! normalize g_perp call NormVec ( cell , kstar , 'r' ) ! normalize reciprocal beam vector ! deal only with the incident beam (parallel illumination) if ( ktstep . eq . 0 ) then if (. not . associated ( khead )) then ! allocate the head and ktail of the linked list allocate ( khead , stat = istat ) ! allocate new value if ( istat . ne . 0 ) call FatalError ( 'Calckvectorcone: unable to allocate head pointer' , ' ' ) ktail => khead ! ktail points to new value nullify ( ktail % next ) ! nullify next in new value numk = 1 ! keep track of number of k-vectors so far ! this should be the center vector of the illumination cone !!! kt = - glen * ( ktxy ( 1 ) * gan + ktxy ( 2 ) * gperp ) ktail % kt = kt ! store tangential component of k ktlen = glen ** 2 * ( ktxy ( 1 ) ** 2 + ktxy ( 2 ) ** 2 ) ! squared length of tangential component kr = kt + sqrt ( 1.0 / cell % mLambda ** 2 - ktlen ) * kstar ! complete wave vector ktail % k = kr ! store in pointer list ktail % kn = CalcDot ( cell , ktail % k , dble ( kstar ), 'r' ) ! normal component of k end if else ! next, put the center of the cone in units of (i,j) (original ECP \"screen\" coordinates) ic = int ( ktxy ( 1 ) * glen / delta ) jc = int ( ktxy ( 2 ) * glen / delta ) ki = ktstep if (. not . associated ( khead )) then ! allocate the head and ktail of the linked list allocate ( khead , stat = istat ) ! allocate new value if ( istat . ne . 0 ) call FatalError ( 'Calckvectorcone: unable to allocate head pointer' , ' ' ) ktail => khead ! ktail points to new value nullify ( ktail % next ) ! nullify next in new value numk = 1 ! keep track of number of k-vectors so far ! this should be the center vector of the illumination cone !!! ktail % i = ic ! i-index of beam ktail % j = jc ! j-index of beam kt = - float ( ktail % i ) * delta * gan - float ( ktail % j ) * delta * gperp ! tangential component of k ktail % kt = kt ! store tangential component of k ktlen = delta ** 2 * ( ktail % i ** 2 + ktail % j ** 2 ) ! squared length of tangential component kr = kt + sqrt ( 1.0 / cell % mLambda ** 2 - ktlen ) * kstar ! complete wave vector ktail % k = kr ! store in pointer list ktail % kn = CalcDot ( cell , ktail % k , dble ( kstar ), 'r' ) ! normal component of k else call FatalError ( 'Calckvectorcone: pointer head already allocated' , ' ' ) end if ! the following lines are quite different if symmetry is taken into account; ! check the MBsym.f90 program to determine how that can be done. imin = - ki ; imax = ki ; jmin = - ki ; jmax = ki ; ijmax = ki ** 2 ! now do the real work do i = imin , imax do j = jmin , jmax if (. not .(( i . eq . 0 ). and .( j . eq . 0 ))) then ! the point (0,0) has already been taken care of if (( i ** 2 + j ** 2 ). le . ijmax ) then ! is point inside the incident cone ? allocate ( ktail % next , stat = istat ) ! allocate new value if ( istat . ne . 0 ) call FatalError ( 'Calckvectorcone: unable to allocate pointer' , ' ' ) ktail => ktail % next ! ktail points to new value nullify ( ktail % next ) ! nullify next in new value numk = numk + 1 ! keep track of number of k-vectors so far ktail % i = ic + i ! i-index of beam ktail % j = jc + j ! j-index of beam kt = - float ( ktail % i ) * delta * gan - float ( ktail % j ) * delta * gperp ! tangential component of k ktail % kt = kt ! store tangential component of k ktlen = delta ** 2 * ( ktail % i ** 2 + ktail % j ** 2 ) ! squared length of tangential component kr = kt + sqrt ( 1.0 / cell % mLambda ** 2 - ktlen ) * kstar ! complete wave vector ktail % k = kr ! store in pointer list ktail % kn = CalcDot ( cell , ktail % k , dble ( kstar ), 'r' ) ! normal component of k end if end if end do end do end if end subroutine Calckvectorcone !-------------------------------------------------------------------------- ! ! SUBROUTINE: Calckvectortrace ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief compute a set of incident beam directions for line scan ECCI mode ! !> @param cell unit cell pointer !> @param khead head of k-vector list !> @param k incident wave vector (zone axis) !> @param ga principal g vector !> @param ktxy tangential components of trace start point !> @param ktxy2 tangential components of trace end point !> @param ktrad cone opening angle !> @param ktstep number of steps along cone radius !> @param numk resulting number of incident beam directions ! !> @date 12/08/13 MDG 1.0 original !> @date 12/01/15 MDG 1.1 simplifcation of input variables !-------------------------------------------------------------------------- recursive subroutine Calckvectortrace ( cell , khead , k , ga , ktxy , ktxy2 , ktrad , ktstep , numk ) !DEC$ ATTRIBUTES DLLEXPORT :: Calckvectortrace use io use error use diffraction use crystal use kvectors IMPLICIT NONE type ( unitcell ), pointer :: cell type ( kvectorlist ), pointer :: khead integer ( kind = irg ), INTENT ( IN ) :: k ( 3 ) integer ( kind = irg ), INTENT ( IN ) :: ga ( 3 ) real ( kind = sgl ), INTENT ( IN ) :: ktxy ( 2 ) real ( kind = sgl ), INTENT ( IN ) :: ktxy2 ( 2 ) real ( kind = sgl ), INTENT ( IN ) :: ktrad integer ( kind = irg ), INTENT ( IN ) :: ktstep integer ( kind = irg ), INTENT ( OUT ) :: numk type ( kvectorlist ), pointer :: ktail integer :: istat , j real :: kr ( 3 ), glen , delta , kstar ( 3 ), kt ( 3 ), gan ( 3 ), gperp ( 3 ), ktlen , dktx , dkty ! compute geometrical factors glen = CalcLength ( cell , float ( ga ), 'r' ) ! length of ga gan = ga / glen ! normalized ga delta = 2.0 * ktrad * glen / float ( 2 * ktstep + 1 ) ! grid step size in nm-1 call TransSpace ( cell , float ( k ), kstar , 'd' , 'r' ) ! transform incident direction to reciprocal space call CalcCross ( cell , float ( ga ), kstar , gperp , 'r' , 'r' , 0 ) ! compute g_perp = ga x k call NormVec ( cell , gperp , 'r' ) ! normalize g_perp call NormVec ( cell , kstar , 'r' ) ! normalize reciprocal beam vector j = 0 if (. not . associated ( khead )) then ! allocate the head and ktail of the linked list allocate ( khead , stat = istat ) ! allocate new value if ( istat . ne . 0 ) call FatalError ( 'Calckvectortrace: unable to allocate head pointer' , ' ' ) ktail => khead ! ktail points to new value nullify ( ktail % next ) ! nullify next in new value numk = 1 ! keep track of number of k-vectors so far ! this should be the starting point of the line trace !   kt = - glen * ( ktxy(1)*gan + ktxy(2) * gperp) kt = - glen * ( ktxy ( 1 ) * gan - ktxy ( 2 ) * gperp ) ktail % kt = kt ! store tangential component of k ktlen = glen ** 2 * ( ktxy ( 1 ) ** 2 + ktxy ( 2 ) ** 2 ) ! squared length of tangential component kr = kt + sqrt ( 1.0 / cell % mLambda ** 2 - ktlen ) * kstar ! complete wave vector ktail % k = kr ! store in pointer list ktail % kn = CalcDot ( cell , ktail % k , dble ( kstar ), 'r' ) ! normal component of k end if dktx = ( ktxy2 ( 1 ) - ktxy ( 1 )) / float ( ktstep - 1 ) dkty = ( ktxy2 ( 2 ) - ktxy ( 2 )) / float ( ktstep - 1 ) do j = 1 , ktstep - 1 allocate ( ktail % next , stat = istat ) ! allocate new value if ( istat . ne . 0 ) call FatalError ( 'Calckvectortrace: unable to allocate pointer' , ' ' ) ktail => ktail % next ! ktail points to new value nullify ( ktail % next ) ! nullify next in new value numk = numk + 1 ! keep track of number of k-vectors so far !     kt = - glen * ( (ktxy(1)+float(j)*dktx)*gan + (ktxy(2)+float(j)*dkty) * gperp) ! tangential component of k kt = - glen * ( ( ktxy ( 1 ) + float ( j ) * dktx ) * gan - ( ktxy ( 2 ) + float ( j ) * dkty ) * gperp ) ! tangential component of k ktail % kt = kt ! store tangential component of k ktlen = delta ** 2 * ( ktail % i ** 2 + ktail % j ** 2 ) ! squared length of tangential component kr = kt + sqrt ( 1.0 / cell % mLambda ** 2 - ktlen ) * kstar ! complete wave vector ktail % k = kr ! store in pointer list ktail % kn = CalcDot ( cell , ktail % k , dble ( kstar ), 'r' ) ! normal component of k end do end subroutine Calckvectortrace !-------------------------------------------------------------------------- ! ! SUBROUTINE: ECCICalcSgh ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief compute structure factor-like array for ECCI and ECP simulations ! !> @param nn dimension of array !> @param Sgh output array !> @param nat normalization array ! !> @date 03/05/14  MDG 1.0 original (used to be in-line in ECP and ECCI programs) !> @date 03/11/14  MDG 1.1 converted to diagonal Sgh array only !> @date 10/22/14  MDG 1.2 corrected definition of Sgh and simplified loops; resolves issue #3 !-------------------------------------------------------------------------- recursive subroutine ECCICalcSgh ( cell , nn , Sgh , nat ) !DEC$ ATTRIBUTES DLLEXPORT :: ECCICalcSgh use local use crystal use gvectors use constants use symmetry IMPLICIT NONE type ( unitcell ), pointer :: cell integer ( kind = irg ), INTENT ( IN ) :: nn ! corrected on 10/22/14 in response to issue #3 of release 2.0 raised by jfikar ! Sgh array changed to one dimensional vector instead of 2D array complex ( kind = dbl ), INTENT ( INOUT ) :: Sgh ( nn ) integer ( kind = irg ), INTENT ( INOUT ) :: nat ( 100 ) integer ( kind = irg ) :: ip , ir , ic , kkk ( 3 ), ikk , n , numset real ( kind = sgl ) :: Znsq , DBWF , kkl complex ( kind = dbl ) :: carg real ( kind = dbl ) :: ctmp ( 192 , 3 ), arg , tpi tpi = 2.D0 * cPi Sgh = dcmplx ( 0.D0 , 0.D0 ) numset = cell % ATOM_ntype ! number of special positions in the unit cell ! comment: this can likely be further simplified and we'll take a closer look at this for ! the next release. ! for each special position we need to compute its contribution to the Sgh vector do ip = 1 , numset call CalcOrbit ( cell , ip , n , ctmp ) nat ( ip ) = n ! get Zn-squared for this special position, and include the site occupation parameter as well Znsq = float ( cell % ATOM_type ( ip )) ** 2 * cell % ATOM_pos ( ip , 4 ) ! loop over all contributing reflections ! ir is the row index ! we don't need to actually go through this list, so the lines are commented out !   rltmpa => reflist%next    ! point to the front of the list !   do ir=1,nn  ! we only need a single summation loop since Sgh is a column vector ! Debye-Waller exponential times Z&#94;2 Sgh = Sgh + dcmplx ( n * Znsq , 0.D0 ) !    rltmpa => rltmpa%next  ! move to next row-entry !   end do end do ! this is the older code which I'm leaving here commented [10/22/14] !! for each special position we need to compute its contribution to the Sgh array !  do ip=1,numset !    call CalcOrbit(ip,n,ctmp) !    nat(ip) = n !! get Zn-squared for this special position, and include the site occupation parameter as well !    Znsq = float(cell%ATOM_type(ip))**2 * cell%ATOM_pos(ip,4) !! loop over all contributing reflections !! ir is the row index !    rltmpa => reflist%next    ! point to the front of the list !    do ir=1,nn !! ic is the column index !      rltmpb => reflist%next    ! point to the front of the list !      do ic=1,nn !        kkk = rltmpb%hkl - rltmpa%hkl !! We'll assume isotropic Debye-Waller factors for now ... !! That means we need the square of the length of s=  kk&#94;2/4 !        kkl = 0.25 * CalcLength(float(kkk),'r')**2 !! Debye-Waller exponential times Z&#94;2 !        DBWF = Znsq * exp(-cell%ATOM_pos(ip,5)*kkl) !! here is where we should insert the proper weight factor, Z&#94;2 exp[-M_{h-g}] !! and also the detector geometry...   For now, we do nothing with the detector !! geometry; the Rossouw et al 1994 paper lists a factor A that does not depend !! on anything in particular, so we assume it is 1. !        do ikk=1,n !! get the argument of the complex exponential !          arg = tpi*sum(kkk(1:3)*ctmp(ikk,1:3)) !          carg = dcmplx(dcos(arg),dsin(arg)) !! multiply with the prefactor and add !          Sgh(ir,ic) = Sgh(ir,ic) + carg * dcmplx(DBWF,0.D0) !        end do !        rltmpb => rltmpb%next  ! move to next column-entry !      end do !     rltmpa => rltmpa%next  ! move to next row-entry !   end do !  end do end subroutine ECCICalcSgh !C*********************************************************************** !C !C                        naninfchk.f !C !C      ***************************************************************** !C      *                                                               * !C\t* \tAbsoft Corporation \t\t\t\t\t* !C \t*\t2781 Bond Street\t\t\t\t\t* !C\t*\tRochester Hills, MI  48309\t\t\t\t* !C\t*\t\t\t\t\t\t\t\t* !C\t*\tThis file contains example code for demonstration\t* !C\t*\tpurposes only.  Absoft makes no warranty of the\t* !C\t*\tsuitability of this code for any purpose.\t\t* !C\t*\t\t\t\t\t\t\t\t* !C\t*\tIn no event shall Absoft be liable for any incidental,* !C\t*\tindirect, special, or consequential damages arising\t* !C\t*\tout of the use of this code.\t\t\t\t* !C\t*\t\t\t\t\t\t\t\t* !C\t***************************************************************** !C !C Routines to test real and double values against NaN and INF !C !C            NANCHK(X) - tests REAL*4 value X against NaN !!C            DNANCHK(X) - tests REAL*8 value X against NaN !!C            INFCHK(X) - tests REAL*4 value X against INF !!C            DINFCHK(X) - test REAL*8 value X against INF !C !C For little endian machines (Intel x86), compile with !C !C      f77 -c -DBYTE_SWAPPED=1 naninfchk.f !C\tor !C      f90 -c -DBYTE_SWAPPED=1 naninfchk.f -YBOZTYPE=INT !C !C For big endian machines (PowerPC), compile with !C !C      f77 -c naninfchk.f !C\tor !C      f90 -c naninfchk.f -YBOZTYPE=INT !C !C*********************************************************************** RECURSIVE LOGICAL FUNCTION NANCHK ( X ) !DEC$ ATTRIBUTES DLLEXPORT :: NANCHK IMPLICIT NONE REAL , INTENT ( IN ) :: X REAL :: Y INTEGER :: I EQUIVALENCE ( Y , I ) Y = X NANCHK = isnan ( Y ) !((I .AND. z'7f800000') .EQ. z'7f800000') .AND.((I .AND. z'007fffff') .NE. z'00000000') RETURN END end module ECCImod","tags":"","loc":"sourcefile/eccimod.f90.html","title":"ECCImod.f90 – Fortran Program"},{"text":"Functions pythag Subroutines bakvec balanc balbak bandr bandv bisect bqr cbabk2 cbal cdiv cg ch cinvit combak comhes comlr comlr2 comqr comqr2 cortb corth csroot elmbak elmhes eltran figi figi2 hqr hqr2 htrib3 htribk htrid3 htridi imtql1 imtql2 imtqlv invit minfit ortbak orthes ortran qzhes qzit qzval qzvec r8_swap r8mat_print r8mat_print_some r8vec_print r8vec2_print ratqr rebak rebakb reduc reduc2 rg rgg rs rsb rsg rsgab rsgba rsm rsp rspp rst rt svd timestamp tinvit tql1 tql2 tqlrat trbak1 trbak3 tred1 tred2 tred3 tridib tsturm Source Code eispack.f90 Source Code subroutine bakvec ( n , t , e , m , z , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: bakvec !*****************************************************************************80 ! !! BAKVEC determines eigenvectors by reversing the FIGI transformation. ! !  Discussion: ! !    This subroutine forms the eigenvectors of a nonsymmetric tridiagonal !    matrix by back transforming those of the corresponding symmetric !    matrix determined by FIGI. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, real ( kind = 8 ) T(N,3), contains the nonsymmetric matrix.  Its !    subdiagonal is stored in the positions 2:N of the first column, !    its diagonal in positions 1:N of the second column, !    and its superdiagonal in positions 1:N-1 of the third column. !    T(1,1) and T(N,3) are arbitrary. ! !    Input/output, real ( kind = 8 ) E(N).  On input, E(2:N) contains the !    subdiagonal elements of the symmetric matrix.  E(1) is arbitrary. !    On output, the contents of E have been destroyed. ! !    Input, integer ( kind = 4 ) M, the number of eigenvectors to be back !    transformed. ! !    Input/output, real ( kind = 8 ) Z(N,M), contains the eigenvectors. !    On output, they have been transformed as requested. ! !    Output, integer ( kind = 4 ) IERR, an error flag. !    0, for normal return, !    2*N+I, if E(I) is zero with T(I,1) or T(I-1,3) non-zero. !    In this case, the symmetric matrix is not similar !    to the original matrix, and the eigenvectors !    cannot be found by this program. ! implicit none integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) e ( n ) integer ( kind = 4 ) i integer ( kind = 4 ) ierr integer ( kind = 4 ) j real ( kind = 8 ) t ( n , 3 ) real ( kind = 8 ) z ( n , m ) ierr = 0 if ( m == 0 ) then return end if e ( 1 ) = 1.0D+00 if ( n == 1 ) then return end if do i = 2 , n if ( e ( i ) == 0.0D+00 ) then if ( t ( i , 1 ) /= 0.0D+00 . or . t ( i - 1 , 3 ) /= 0.0D+00 ) then ierr = 2 * n + i return end if e ( i ) = 1.0D+00 else e ( i ) = e ( i - 1 ) * e ( i ) / t ( i - 1 , 3 ) end if end do do j = 1 , m z ( 2 : n , j ) = z ( 2 : n , j ) * e ( 2 : n ) end do return end subroutine balanc ( n , a , low , igh , scale ) !DEC$ ATTRIBUTES DLLEXPORT :: balanc !*****************************************************************************80 ! !! BALANC balances a real matrix before eigenvalue calculations. ! !  Discussion: ! !    This subroutine balances a real matrix and isolates eigenvalues !    whenever possible. ! !    Suppose that the principal submatrix in rows LOW through IGH !    has been balanced, that P(J) denotes the index interchanged !    with J during the permutation step, and that the elements !    of the diagonal matrix used are denoted by D(I,J).  Then ! !      SCALE(J) = P(J),    J = 1,...,LOW-1, !               = D(J,J),  J = LOW,...,IGH, !               = P(J)     J = IGH+1,...,N. ! !    The order in which the interchanges are made is N to IGH+1, !    then 1 to LOW-1. ! !    Note that 1 is returned for LOW if IGH is zero formally. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input/output, real ( kind = 8 ) A(N,N), the N by N matrix.  On output, !    the matrix has been balanced. ! !    Output, integer ( kind = 4 ) LOW, IGH, indicate that A(I,J) is equal to !    zero if !    (1) I is greater than J and !    (2) J=1,...,LOW-1 or I=IGH+1,...,N. ! !    Output, real ( kind = 8 ) SCALE(N), contains information determining the !    permutations and scaling factors used. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) a ( n , n ) real ( kind = 8 ) b2 real ( kind = 8 ) c real ( kind = 8 ) f real ( kind = 8 ) g integer ( kind = 4 ) i integer ( kind = 4 ) iexc integer ( kind = 4 ) igh integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) l integer ( kind = 4 ) low integer ( kind = 4 ) m logical noconv real ( kind = 8 ) r real ( kind = 8 ) radix real ( kind = 8 ) s real ( kind = 8 ) scale ( n ) radix = 1 6.0D+00 iexc = 0 j = 0 m = 0 b2 = radix ** 2 k = 1 l = n go to 100 20 continue scale ( m ) = j if ( j /= m ) then do i = 1 , l call r8_swap ( a ( i , j ), a ( i , m ) ) end do do i = k , n call r8_swap ( a ( j , i ), a ( m , i ) ) end do end if 50 continue if ( iexc == 2 ) then go to 130 end if ! !  Search for rows isolating an eigenvalue and push them down. ! 80 continue if ( l == 1 ) then low = k igh = l return end if l = l - 1 100 continue do j = l , 1 , - 1 do i = 1 , l if ( i /= j ) then if ( a ( j , i ) /= 0.0D+00 ) then go to 120 end if end if end do m = l iexc = 1 go to 20 120 continue end do go to 140 ! !  Search for columns isolating an eigenvalue and push them left. ! 130 continue k = k + 1 140 continue do j = k , l do i = k , l if ( i /= j ) then if ( a ( i , j ) /= 0.0D+00 ) then go to 170 end if end if end do m = k iexc = 2 go to 20 170 continue end do ! !  Balance the submatrix in rows K to L. ! scale ( k : l ) = 1.0D+00 ! !  Iterative loop for norm reduction. ! noconv = . true . do while ( noconv ) noconv = . false . do i = k , l c = 0.0D+00 r = 0.0D+00 do j = k , l if ( j /= i ) then c = c + abs ( a ( j , i ) ) r = r + abs ( a ( i , j ) ) end if end do ! !  Guard against zero C or R due to underflow. ! if ( c /= 0.0D+00 . and . r /= 0.0D+00 ) then g = r / radix f = 1.0D+00 s = c + r do while ( c < g ) f = f * radix c = c * b2 end do g = r * radix do while ( g <= c ) f = f / radix c = c / b2 end do ! !  Balance. ! if ( ( c + r ) / f < 0.95D+00 * s ) then g = 1.0D+00 / f scale ( i ) = scale ( i ) * f noconv = . true . a ( i , k : n ) = a ( i , k : n ) * g a ( 1 : l , i ) = a ( 1 : l , i ) * f end if end if end do end do low = k igh = l return end subroutine balbak ( n , low , igh , scale , m , z ) !DEC$ ATTRIBUTES DLLEXPORT :: balbak !*****************************************************************************80 ! !! BALBAK determines eigenvectors by undoing the BALANC transformation. ! !  Discussion: ! !    This subroutine forms the eigenvectors of a real general matrix by !    back transforming those of the corresponding balanced matrix !    determined by BALANC. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Parlett and Reinsch, !    Numerische Mathematik, !    Volume 13, pages 293-304, 1969. ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, integer ( kind = 4 ) LOW, IGH, column indices determined by BALANC. ! !    Input, real ( kind = 8 ) SCALE(N), contains information determining !    the permutations and scaling factors used by BALANC. ! !    Input, integer ( kind = 4 ) M, the number of columns of Z to be !    back-transformed. ! !    Input/output, real ( kind = 8 ) Z(N,M), contains the real and imaginary parts !    of the eigenvectors, which, on return, have been back-transformed. ! implicit none integer ( kind = 4 ) m integer ( kind = 4 ) n integer ( kind = 4 ) i integer ( kind = 4 ) igh integer ( kind = 4 ) ii integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) low !  real    ( kind = 8 ) s real ( kind = 8 ) scale ( n ) real ( kind = 8 ) z ( n , m ) if ( m <= 0 ) then return end if if ( igh /= low ) then do i = low , igh z ( i , 1 : m ) = z ( i , 1 : m ) * scale ( i ) end do end if do ii = 1 , n i = ii if ( i < low . or . igh < i ) then if ( i < low ) then i = low - ii end if k = int ( scale ( i ) ) if ( k /= i ) then do j = 1 , m call r8_swap ( z ( i , j ), z ( k , j ) ) end do end if end if end do return end subroutine bandr ( n , mb , a , d , e , e2 , matz , z ) !DEC$ ATTRIBUTES DLLEXPORT :: bandr !*****************************************************************************80 ! !! BANDR reduces a symmetric band matrix to symmetric tridiagonal form. ! !  Discussion: ! !    This subroutine reduces a real symmetric band matrix !    to a symmetric tridiagonal matrix using and optionally !    accumulating orthogonal similarity transformations. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, integer ( kind = 4 ) MB, is the (half) band width of the matrix, !    defined as the number of adjacent diagonals, including the principal !    diagonal, required to specify the non-zero portion of the !    lower triangle of the matrix. ! !    Input/output, real ( kind = 8 ) A(N,MB).  On input, contains the lower triangle of !    the symmetric band input matrix stored as an N by MB array.  Its lowest !    subdiagonal is stored in the last N+1-MB positions of the first column, !    its next subdiagonal in the last N+2-MB positions of the second column, !    further subdiagonals similarly, and finally its principal diagonal in !    the N positions of the last column.  Contents of storages not part of !    the matrix are arbitrary.  On output, A has been destroyed, except for !    its last two columns which contain a copy of the tridiagonal matrix. ! !    Output, real ( kind = 8 ) D(N), the diagonal elements of the tridiagonal matrix. ! !    Output, real ( kind = 8 ) E(N), the subdiagonal elements of the tridiagonal !    matrix in E(2:N).  E(1) is set to zero. ! !    Output, real ( kind = 8 ) E2(N), contains the squares of the corresponding elements !    of E.  E2 may coincide with E if the squares are not needed. ! !    Input, logical MATZ, should be set to TRUE if the transformation matrix is !    to be accumulated, and to FALSE otherwise. ! !    Output, real ( kind = 8 ) Z(N,N), the orthogonal transformation matrix produced in !    the reduction if MATZ has been set to TRUE.  Otherwise, Z is not !    referenced. ! implicit none integer ( kind = 4 ) mb integer ( kind = 4 ) n real ( kind = 8 ) a ( n , mb ) real ( kind = 8 ) b1 real ( kind = 8 ) b2 real ( kind = 8 ) c2 real ( kind = 8 ) d ( n ) real ( kind = 8 ) dmin real ( kind = 8 ) dminrt real ( kind = 8 ) e ( n ) real ( kind = 8 ) e2 ( n ) real ( kind = 8 ) f1 real ( kind = 8 ) f2 real ( kind = 8 ) g integer ( kind = 4 ) i integer ( kind = 4 ) i1 integer ( kind = 4 ) i2 integer ( kind = 4 ) j integer ( kind = 4 ) j1 integer ( kind = 4 ) j2 integer ( kind = 4 ) k integer ( kind = 4 ) kr integer ( kind = 4 ) l integer ( kind = 4 ) m1 logical matz integer ( kind = 4 ) maxl integer ( kind = 4 ) maxr integer ( kind = 4 ) mr integer ( kind = 4 ) r integer ( kind = 4 ) r1 real ( kind = 8 ) s2 real ( kind = 8 ) u integer ( kind = 4 ) ugl real ( kind = 8 ) z ( n , n ) dmin = epsilon ( dmin ) dminrt = sqrt ( dmin ) ! !  Initialize the diagonal scaling matrix. ! d ( 1 : n ) = 1.0D+00 if ( matz ) then a ( 1 : n , 1 : n ) = 0.0D+00 do i = 1 , n z ( i , i ) = 1.0D+00 end do end if m1 = mb - 1 if ( m1 < 1 ) then d ( 1 : n ) = a ( 1 : n , mb ) e ( 1 : n ) = 0.0D+00 e2 ( 1 : n ) = 0.0D+00 return end if if ( m1 == 1 ) then go to 800 end if do k = 1 , n - 2 maxr = min ( m1 , n - k ) do r1 = 2 , maxr r = maxr + 2 - r1 kr = k + r mr = mb - r g = a ( kr , mr ) a ( kr - 1 , 1 ) = a ( kr - 1 , mr + 1 ) ugl = k do j = kr , n , m1 j1 = j - 1 j2 = j1 - 1 if ( g == 0.0D+00 ) then go to 600 end if b1 = a ( j1 , 1 ) / g b2 = b1 * d ( j1 ) / d ( j ) s2 = 1.0D+00 / ( 1.0D+00 + b1 * b2 ) if ( s2 < 0.5D+00 ) then b1 = g / a ( j1 , 1 ) b2 = b1 * d ( j ) / d ( j1 ) c2 = 1.0D+00 - s2 d ( j1 ) = c2 * d ( j1 ) d ( j ) = c2 * d ( j ) f1 = 2.0D+00 * a ( j , m1 ) f2 = b1 * a ( j1 , mb ) a ( j , m1 ) = - b2 * ( b1 * a ( j , m1 ) - a ( j , mb ) ) - f2 + a ( j , m1 ) a ( j1 , mb ) = b2 * ( b2 * a ( j , mb ) + f1 ) + a ( j1 , mb ) a ( j , mb ) = b1 * ( f2 - f1 ) + a ( j , mb ) do l = ugl , j2 i2 = mb - j + l u = a ( j1 , i2 + 1 ) + b2 * a ( j , i2 ) a ( j , i2 ) = - b1 * a ( j1 , i2 + 1 ) + a ( j , i2 ) a ( j1 , i2 + 1 ) = u end do ugl = j a ( j1 , 1 ) = a ( j1 , 1 ) + b2 * g if ( j /= n ) then maxl = min ( m1 , n - j1 ) do l = 2 , maxl i1 = j1 + l i2 = mb - l u = a ( i1 , i2 ) + b2 * a ( i1 , i2 + 1 ) a ( i1 , i2 + 1 ) = - b1 * a ( i1 , i2 ) + a ( i1 , i2 + 1 ) a ( i1 , i2 ) = u end do i1 = j + m1 if ( i1 <= n ) then g = b2 * a ( i1 , 1 ) end if end if if ( matz ) then do l = 1 , n u = z ( l , j1 ) + b2 * z ( l , j ) z ( l , j ) = - b1 * z ( l , j1 ) + z ( l , j ) z ( l , j1 ) = u end do end if else u = d ( j1 ) d ( j1 ) = s2 * d ( j ) d ( j ) = s2 * u f1 = 2.0D+00 * a ( j , m1 ) f2 = b1 * a ( j , mb ) u = b1 * ( f2 - f1 ) + a ( j1 , mb ) a ( j , m1 ) = b2 * ( b1 * a ( j , m1 ) - a ( j1 , mb ) ) + f2 - a ( j , m1 ) a ( j1 , mb ) = b2 * ( b2 * a ( j1 , mb ) + f1 ) + a ( j , mb ) a ( j , mb ) = u do l = ugl , j2 i2 = mb - j + l u = b2 * a ( j1 , i2 + 1 ) + a ( j , i2 ) a ( j , i2 ) = - a ( j1 , i2 + 1 ) + b1 * a ( j , i2 ) a ( j1 , i2 + 1 ) = u end do ugl = j a ( j1 , 1 ) = b2 * a ( j1 , 1 ) + g if ( j /= n ) then maxl = min ( m1 , n - j1 ) do l = 2 , maxl i1 = j1 + l i2 = mb - l u = b2 * a ( i1 , i2 ) + a ( i1 , i2 + 1 ) a ( i1 , i2 + 1 ) = - a ( i1 , i2 ) + b1 * a ( i1 , i2 + 1 ) a ( i1 , i2 ) = u end do i1 = j + m1 if ( i1 <= n ) then g = a ( i1 , 1 ) a ( i1 , 1 ) = b1 * a ( i1 , 1 ) end if end if if ( matz ) then do l = 1 , n u = b2 * z ( l , j1 ) + z ( l , j ) z ( l , j ) = - z ( l , j1 ) + b1 * z ( l , j ) z ( l , j1 ) = u end do end if end if end do 600 continue end do ! !  Rescale to avoid underflow or overflow. ! if ( mod ( k , 64 ) == 0 ) then do j = k , n if ( d ( j ) < dmin ) then maxl = max ( 1 , mb + 1 - j ) a ( j , maxl : m1 ) = dminrt * a ( j , maxl : m1 ) if ( j /= n ) then maxl = min ( m1 , n - j ) do l = 1 , maxl i1 = j + l i2 = mb - l a ( i1 , i2 ) = dminrt * a ( i1 , i2 ) end do end if if ( matz ) then z ( 1 : n , j ) = dminrt * z ( 1 : n , j ) end if a ( j , mb ) = dmin * a ( j , mb ) d ( j ) = d ( j ) / dmin end if end do end if end do ! !   Form square root of scaling matrix. ! 800 continue e ( 2 : n ) = sqrt ( d ( 2 : n ) ) if ( matz ) then do k = 2 , n z ( 1 : n , k ) = z ( 1 : n , k ) * e ( k ) end do end if u = 1.0D+00 do j = 2 , n a ( j , m1 ) = u * e ( j ) * a ( j , m1 ) u = e ( j ) e2 ( j ) = a ( j , m1 ) ** 2 a ( j , mb ) = d ( j ) * a ( j , mb ) d ( j ) = a ( j , mb ) e ( j ) = a ( j , m1 ) end do d ( 1 ) = a ( 1 , mb ) e ( 1 ) = 0.0D+00 e2 ( 1 ) = 0.0D+00 return end subroutine bandv ( n , mbw , a , e21 , m , w , z , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: bandv !*****************************************************************************80 ! !! BANDV finds eigenvectors from eigenvalues, for a real symmetric band matrix. ! !  Discussion: ! !    This subroutine finds those eigenvectors of a real symmetric !    band matrix corresponding to specified eigenvalues, using inverse !    iteration.  The subroutine may also be used to solve systems !    of linear equations with a symmetric or non-symmetric band !    coefficient matrix. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, integer ( kind = 4 ) MBW, the number of columns of the array A used !    to store the band matrix.  If the matrix is symmetric, MBW is its (half) !    band width, denoted MB and defined as the number of adjacent !    diagonals, including the principal diagonal, required to !    specify the non-zero portion of the lower triangle of the !    matrix.  If the subroutine is being used to solve systems !    of linear equations and the coefficient matrix is not !    symmetric, it must however have the same number of adjacent !    diagonals above the main diagonal as below, and in this !    case, MBW=2*MB-1. ! !    Input, real ( kind = 8 ) A(N,MBW), the lower triangle of the symmetric band input !    atrix stored as an N by MB array.  Its lowest subdiagonal is stored !    in the last N+1-MB positions of the first column, its next subdiagonal !    in the last N+2-MB positions of the second column, further subdiagonals !    similarly, and finally its principal diagonal in the N positions of !    column MB.  If the subroutine is being used to solve systems of linear !    equations, and the coefficient matrix is not symmetric, A is !    N by 2*MB-1 instead, with lower triangle as above and with its first !    superdiagonal stored in the first N-1 positions of column MB+1, its !    second superdiagonal in the first N-2 positions of column MB+2, further !    superdiagonals similarly, and finally its highest superdiagonal in !    the first N+1-MB positions of the last column.  Contents of storages !    not part of the matrix are arbitrary. ! !    Input, real ( kind = 8 ) E21, specifies the ordering of the eigenvalues and contains !    0.0D+00 if the eigenvalues are in ascending order, or 2.0D+00 if the !    eigenvalues are in descending order.  If the subroutine is being used !    to solve systems of linear equations, E21 should be set to 1.0D+00 !    if the coefficient matrix is symmetric and to -1.0D+00 if not. ! !    Input, integer ( kind = 4 ) M, the number of specified eigenvalues or the number of !    systems of linear equations. ! !    Input, real ( kind = 8 ) W(M), contains the M eigenvalues in ascending or descending !    order.  If the subroutine is being used to solve systems of linear !    equations (A-W(1:M)*I) * X(1:M) = B(1:M), where I is the identity matrix, !    W should be set accordingly. ! !    Input/output, real ( kind = 8 ) Z(N,M).  On input, the constant matrix !    columns B(1:M), if the subroutine is used to solve systems of linear !    equations.  On output, the associated set of orthogonal eigenvectors. !    Any vector which fails to converge is set to zero.  If the !    routine is used to solve systems of linear equations, !    Z contains the solution matrix columns X(1:M). ! !    Output, integer ( kind = 4 ) IERR, error flag. !    0, for normal return, !    -R, if the eigenvector corresponding to the R-th eigenvalue fails to !    converge, or if the R-th system of linear equations is nearly singular. ! implicit none integer ( kind = 4 ) mbw integer ( kind = 4 ) n real ( kind = 8 ) a ( n , mbw ) real ( kind = 8 ) e21 real ( kind = 8 ) eps2 real ( kind = 8 ) eps3 real ( kind = 8 ) eps4 integer ( kind = 4 ) group integer ( kind = 4 ) i integer ( kind = 4 ) ierr integer ( kind = 4 ) ii integer ( kind = 4 ) ij integer ( kind = 4 ) ij1 integer ( kind = 4 ) its integer ( kind = 4 ) j integer ( kind = 4 ) jj integer ( kind = 4 ) k integer ( kind = 4 ) kj integer ( kind = 4 ) kj1 integer ( kind = 4 ) m integer ( kind = 4 ) m1 integer ( kind = 4 ) m21 integer ( kind = 4 ) maxj integer ( kind = 4 ) maxk integer ( kind = 4 ) mb real ( kind = 8 ) norm real ( kind = 8 ) order real ( kind = 8 ) pythag integer ( kind = 4 ) r real ( kind = 8 ) rv ( n * ( 2 * mbw - 1 )) real ( kind = 8 ) rv6 ( n ) real ( kind = 8 ) u real ( kind = 8 ) uk real ( kind = 8 ) v real ( kind = 8 ) w ( m ) real ( kind = 8 ) x0 real ( kind = 8 ) x1 real ( kind = 8 ) xu real ( kind = 8 ) z ( n , m ) ierr = 0 if ( m == 0 ) then return end if x0 = 0.0D+00 if ( e21 < 0.0D+00 ) then mb = ( mbw + 1 ) / 2 else mb = mbw end if m1 = mb - 1 m21 = m1 + mb order = 1.0D+00 - abs ( e21 ) ! !  Find vectors by inverse iteration. ! do r = 1 , m its = 1 x1 = w ( r ) if ( r /= 1 ) go to 100 ! !  Compute norm of matrix. ! norm = 0.0D+00 do j = 1 , mb jj = mb + 1 - j kj = jj + m1 ij = 1 v = 0.0D+00 do i = jj , n v = v + abs ( a ( i , j ) ) if ( e21 < 0.0D+00 ) then v = v + abs ( a ( ij , kj ) ) ij = ij + 1 end if end do norm = max ( norm , v ) end do if ( e21 < 0.0D+00 ) then norm = 0.5D+00 * norm end if ! !  EPS2 is the criterion for grouping, !  EPS3 replaces zero pivots and equal roots are modified by eps3, !  EPS4 is taken very small to avoid overflow. ! if ( norm == 0.0D+00 ) then norm = 1.0D+00 end if eps2 = 0.001D+00 * norm * abs ( order ) eps3 = abs ( norm ) * epsilon ( norm ) uk = n uk = sqrt ( uk ) eps4 = uk * eps3 80 continue group = 0 go to 120 ! !  Look for close or coincident roots. ! 100 continue if ( eps2 <= abs ( x1 - x0 ) ) then go to 80 end if group = group + 1 if ( order * ( x1 - x0 ) <= 0.0D+00 ) then x1 = x0 + order * eps3 end if ! !  Expand matrix, subtract eigenvalue, and initialize vector. ! 120 continue do i = 1 , n ij = i + min ( 0 , i - m1 ) * n kj = ij + mb * n ij1 = kj + m1 * n if ( m1 == 0 ) go to 180 do j = 1 , m1 if ( ij <= m1 ) then if ( ij <= 0 ) then rv ( ij1 ) = 0.0D+00 ij1 = ij1 + n end if else rv ( ij ) = a ( i , j ) end if ij = ij + n ii = i + j if ( ii <= n ) then jj = mb - j if ( e21 < 0.0D+00 ) then ii = i jj = mb + j end if rv ( kj ) = a ( ii , jj ) kj = kj + n end if end do 180 continue rv ( ij ) = a ( i , mb ) - x1 rv6 ( i ) = eps4 if ( order == 0.0D+00 ) then rv6 ( i ) = z ( i , r ) end if end do if ( m1 /= 0 ) then ! !  Elimination with interchanges. ! do i = 1 , n ii = i + 1 maxk = min ( i + m1 - 1 , n ) maxj = min ( n - i , m21 - 2 ) * n do k = i , maxk kj1 = k j = kj1 + n jj = j + maxj do kj = j , jj , n rv ( kj1 ) = rv ( kj ) kj1 = kj end do rv ( kj1 ) = 0.0D+00 end do if ( i /= n ) then u = 0.0D+00 maxk = min ( i + m1 , n ) maxj = min ( n - ii , m21 - 2 ) * n do j = i , maxk if ( abs ( u ) <= abs ( rv ( j ) ) ) then u = rv ( j ) k = j end if end do j = i + n jj = j + maxj if ( k /= i ) then kj = k do ij = i , jj , n call r8_swap ( rv ( ij ), rv ( kj ) ) kj = kj + n end do if ( order == 0.0D+00 ) then call r8_swap ( rv6 ( i ), rv6 ( k ) ) end if end if if ( u /= 0.0D+00 ) then do k = ii , maxk v = rv ( k ) / u kj = k do ij = j , jj , n kj = kj + n rv ( kj ) = rv ( kj ) - v * rv ( ij ) end do if ( order == 0.0D+00 ) then rv6 ( k ) = rv6 ( k ) - v * rv6 ( i ) end if end do end if end if end do end if ! !  Back substitution. ! 600 continue do ii = 1 , n i = n + 1 - ii maxj = min ( ii , m21 ) if ( maxj /= 1 ) then ij1 = i j = ij1 + n jj = j + ( maxj - 2 ) * n do ij = j , jj , n ij1 = ij1 + 1 rv6 ( i ) = rv6 ( i ) - rv ( ij ) * rv6 ( ij1 ) end do end if v = rv ( i ) ! !  Error: nearly singular linear system. ! if ( abs ( v ) < eps3 ) then if ( order == 0.0D+00 ) then ierr = - r end if v = sign ( eps3 , v ) end if rv6 ( i ) = rv6 ( i ) / v end do xu = 1.0D+00 if ( order == 0.0D+00 ) go to 870 ! !  Orthogonalize with respect to previous members of group. ! do jj = 1 , group j = r - group - 1 + jj xu = dot_product ( rv6 ( 1 : n ), z ( 1 : n , j ) ) rv6 ( 1 : n ) = rv6 ( 1 : n ) - xu * z ( 1 : n , j ) end do norm = sum ( abs ( rv6 ( 1 : n ) ) ) ! !  Choose a new starting vector. ! if ( norm < 0.1D+00 ) then if ( its < n ) then its = its + 1 xu = eps4 / ( uk + 1.0D+00 ) rv6 ( 1 ) = eps4 rv6 ( 2 : n ) = xu rv6 ( its ) = rv6 ( its ) - eps4 * uk go to 600 else ierr = - r xu = 0.0D+00 go to 870 end if end if ! !   Normalize so that sum of squares is 1 and expand to full order. ! u = 0.0D+00 do i = 1 , n u = pythag ( u , rv6 ( i ) ) end do xu = 1.0D+00 / u 870 continue z ( 1 : n , r ) = rv6 ( 1 : n ) * xu x0 = x1 end do return end subroutine bisect ( n , eps1 , d , e , e2 , lb , ub , mm , m , w , ind , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: bisect !*****************************************************************************80 ! !! BISECT computes some eigenvalues of a real symmetric tridiagonal matrix. ! !  Discussion: ! !    This subroutine finds those eigenvalues of a real symmetric !    tridiagonal matrix which lie in a specified interval, using bisection. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input/output, real ( kind = 8 ) EPS1, is an absolute error tolerance for the computed !    eigenvalues.  If the input EPS1 is non-positive, it is reset for each !    submatrix to a default value, namely, minus the product of the relative !    machine precision and the 1-norm of the submatrix. ! !    Input, real ( kind = 8 ) D(N), the diagonal elements of the input matrix. ! !    Input, real ( kind = 8 ) E(N), contains in E(2:N) the subdiagonal elements of the !    matrix.  E(1) is arbitrary. ! !    Input/output, real ( kind = 8 ) E2(N).  On input, the squares of the corresponding !    elements of E.  E2(1) is arbitrary.  On output, elements of E2, !    corresponding to elements of E regarded as negligible, have been !    replaced by zero, causing the matrix to split into a direct sum of !    submatrices.  E2(1) is also set to zero. ! !    Input, real ( kind = 8 ) LB, UB, define the interval to be searched for eigenvalues. !    If LB is not less than UB, no eigenvalues will be found. ! !    Input, integer ( kind = 4 ) MM, an upper bound for the number of eigenvalues in the !    interval.  Warning: if more than MM eigenvalues are determined to lie !    in the interval, an error return is made with no eigenvalues found. ! !    Output, integer ( kind = 4 ) M, the number of eigenvalues determined to lie !    in (LB,UB). ! !    Output, real ( kind = 8 ) W(M), the eigenvalues in ascending order. ! !    Output, integer ( kind = 4 ) IND(MM), contains in its first M positions the submatrix !    indices associated with the corresponding eigenvalues in W: !    1 for eigenvalues belonging to the first submatrix from the top, 2 for !    those belonging to the second submatrix, and so on. ! !    Output, integer ( kind = 4 ) IERR, error flag. !    0, for normal return, !    3*N+1, if M exceeds MM. ! implicit none integer ( kind = 4 ) mm integer ( kind = 4 ) n real ( kind = 8 ) d ( n ) real ( kind = 8 ) e ( n ) real ( kind = 8 ) e2 ( n ) real ( kind = 8 ) eps1 integer ( kind = 4 ) i integer ( kind = 4 ) ierr integer ( kind = 4 ) ii integer ( kind = 4 ) ind ( mm ) integer ( kind = 4 ) isturm integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) l real ( kind = 8 ) lb integer ( kind = 4 ) m integer ( kind = 4 ) m1 integer ( kind = 4 ) m2 integer ( kind = 4 ) p integer ( kind = 4 ) q integer ( kind = 4 ) r real ( kind = 8 ) rv4 ( n ) real ( kind = 8 ) rv5 ( n ) integer ( kind = 4 ) s real ( kind = 8 ) t1 real ( kind = 8 ) t2 integer ( kind = 4 ) tag real ( kind = 8 ) tst1 real ( kind = 8 ) tst2 real ( kind = 8 ) u real ( kind = 8 ) ub real ( kind = 8 ) v real ( kind = 8 ) w ( mm ) real ( kind = 8 ) x0 real ( kind = 8 ) x1 real ( kind = 8 ) xu ierr = 0 s = 0 tag = 0 t1 = lb t2 = ub ! !  Look for small sub-diagonal entries. ! e2 ( 1 ) = 0.0D+00 do i = 2 , n tst1 = abs ( d ( i ) ) + abs ( d ( i - 1 ) ) tst2 = tst1 + abs ( e ( i ) ) if ( tst2 <= tst1 ) then e2 ( i ) = 0.0D+00 end if end do ! !  Determine the number of eigenvalues in the interval. ! p = 1 q = n x1 = ub isturm = 1 go to 320 60 continue m = s x1 = lb isturm = 2 go to 320 80 continue m = m - s if ( mm < m ) then go to 980 end if q = 0 r = 0 ! !  Establish and process next submatrix, refining !  interval by the Gerschgorin bounds. ! 100 continue if ( r == m ) go to 1001 tag = tag + 1 p = q + 1 xu = d ( p ) x0 = d ( p ) u = 0.0D+00 do q = p , n x1 = u u = 0.0D+00 v = 0.0D+00 if ( q /= n ) then u = abs ( e ( q + 1 ) ) v = e2 ( q + 1 ) end if xu = min ( d ( q ) - ( x1 + u ), xu ) x0 = max ( d ( q ) + ( x1 + u ), x0 ) if ( v == 0.0D+00 ) then exit end if end do x1 = max ( abs ( xu ), abs ( x0 ) ) * epsilon ( x1 ) if ( eps1 <= 0.0D+00 ) then eps1 = - x1 end if if ( p /= q ) go to 180 ! !  Check for an isolated root within interval. ! if ( d ( p ) < t1 . or . t2 <= d ( p ) ) then go to 940 end if m1 = p m2 = p rv5 ( p ) = d ( p ) go to 900 180 continue x1 = x1 * ( q - p + 1 ) lb = max ( t1 , xu - x1 ) ub = min ( t2 , x0 + x1 ) x1 = lb isturm = 3 go to 320 200 continue m1 = s + 1 x1 = ub isturm = 4 go to 320 220 continue m2 = s if ( m2 < m1 ) then go to 940 end if ! !  Find roots by bisection. ! x0 = ub isturm = 5 rv5 ( m1 : m2 ) = ub rv4 ( m1 : m2 ) = lb ! !  Loop for the K-th eigenvalue. ! k = m2 250 continue xu = lb do ii = m1 , k i = m1 + k - ii if ( xu < rv4 ( i ) ) then xu = rv4 ( i ) go to 280 end if end do 280 continue x0 = min ( x0 , rv5 ( k ) ) ! !  Next bisection step. ! 300 continue x1 = ( xu + x0 ) * 0.5D+00 if ( ( x0 - xu ) <= abs ( eps1 ) ) go to 420 tst1 = 2.0D+00 * ( abs ( xu ) + abs ( x0 ) ) tst2 = tst1 + ( x0 - xu ) if ( tst2 == tst1 ) go to 420 ! !  Sturm sequence. ! 320 continue s = p - 1 u = 1.0D+00 do i = p , q if ( u == 0.0D+00 ) then v = abs ( e ( i ) ) / epsilon ( v ) if ( e2 ( i ) == 0.0D+00 ) v = 0.0D+00 else v = e2 ( i ) / u end if u = d ( i ) - x1 - v if ( u < 0.0D+00 ) then s = s + 1 end if end do go to ( 60 , 80 , 200 , 220 , 360 ), isturm ! !  Refine intervals. ! 360 continue if ( k <= s ) then go to 400 end if xu = x1 if ( s < m1 ) then rv4 ( m1 ) = x1 go to 300 end if 380 continue rv4 ( s + 1 ) = x1 if ( x1 < rv5 ( s ) ) then rv5 ( s ) = x1 end if go to 300 400 continue x0 = x1 go to 300 ! !  K-th eigenvalue found. ! 420 continue rv5 ( k ) = x1 k = k - 1 if ( k >= m1 ) go to 250 ! !  Order eigenvalues tagged with their submatrix associations. ! 900 continue s = r r = r + m2 - m1 + 1 j = 1 k = m1 do l = 1 , r if ( j <= s ) then if ( k > m2 ) then exit end if if ( rv5 ( k ) >= w ( l ) ) then j = j + 1 cycle end if do ii = j , s i = l + s - ii w ( i + 1 ) = w ( i ) ind ( i + 1 ) = ind ( i ) end do end if w ( l ) = rv5 ( k ) ind ( l ) = tag k = k + 1 end do 940 continue if ( q < n ) then go to 100 end if go to 1001 ! !  Set error: underestimate of number of eigenvalues in interval. ! 980 continue ierr = 3 * n + 1 1001 continue lb = t1 ub = t2 return end subroutine bqr ( n , mb , a , t , r , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: bqr !*****************************************************************************80 ! !! BQR finds the smallest eigenvalue of a real symmetric band matrix. ! !  Discussion: ! !    This subroutine finds the eigenvalue of smallest magnitude of a real !    symmetric band matrix using the QR algorithm with shifts of origin. !    Consecutive calls can be made to find further eigenvalues. ! !    Note that for a subsequent call, N should be replaced by N-1, but !    MB should not be altered even when it exceeds the current N. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, integer ( kind = 4 ) MB, the (half) band width of the matrix, defined as the !    number of adjacent diagonals, including the principal !    diagonal, required to specify the non-zero portion of the !    lower triangle of the matrix. ! !    Input/output, real ( kind = 8 ) A(N,MB).  On input, A contains the lower triangle !    of the symmetric band input matrix stored as an N by MB array.  Its !    lowest subdiagonal is stored in the last N+1-MB positions of the first !    column, its next subdiagonal in the last N+2-MB positions of the !    second column, further subdiagonals similarly, and finally its principal !    diagonal in the N positions of the last column.  Contents of storages !    not part of the matrix are arbitrary.  On a subsequent call, its output !    contents from the previous call should be passed.  On output, A contains !    the transformed band matrix.  The matrix A+T*I derived from the output !    parameters is similar to the input A+T*I to within rounding errors. !    Its last row and column are null as long as IERR is zero. ! !    Input/output, real ( kind = 8 ) T.  On input, T specifies the shift (of eigenvalues) !    applied to the diagonal of A in forming the input matrix.  What is !    actually determined is the eigenvalue nearest to T of A+T*I, where I !    is the identity matrix.  On a subsequent call, the output value of T !    from the previous call should be passed if the next nearest eigenvalue !    is sought.  On output, T contains the computed eigenvalue of A+T*I, !    as long as IERR is zero. ! !    Input/output, real ( kind = 8 ) R.  On input for the first call, R should be !    specified as zero, and as its output value from the previous call !    on a subsequent call.  It is used to determine when the last row and !    column of the transformed band matrix can be regarded as negligible. !    On output, R contains the maximum of its input value and the norm of the !    last column of the input matrix A. ! !    Output, integer ( kind = 4 ) IERR, error flag. !    0, normal return. !    N, if the eigenvalue has not been determined after 30 iterations. ! implicit none integer ( kind = 4 ) mb integer ( kind = 4 ) n real ( kind = 8 ) a ( n , mb ) real ( kind = 8 ) f real ( kind = 8 ) g integer ( kind = 4 ) i integer ( kind = 4 ) ierr integer ( kind = 4 ) ii integer ( kind = 4 ) ik integer ( kind = 4 ) imult integer ( kind = 4 ) its integer ( kind = 4 ) j integer ( kind = 4 ) jk integer ( kind = 4 ) jm integer ( kind = 4 ) k integer ( kind = 4 ) kj integer ( kind = 4 ) kj1 integer ( kind = 4 ) kk integer ( kind = 4 ) km integer ( kind = 4 ) l integer ( kind = 4 ) ll integer ( kind = 4 ) m integer ( kind = 4 ) m1 integer ( kind = 4 ) m2 integer ( kind = 4 ) m21 integer ( kind = 4 ) m3 integer ( kind = 4 ) m31 integer ( kind = 4 ) m4 integer ( kind = 4 ) mk integer ( kind = 4 ) mn integer ( kind = 4 ) mz integer ( kind = 4 ) ni real ( kind = 8 ) pythag real ( kind = 8 ) q real ( kind = 8 ) r real ( kind = 8 ) rv ( 2 * mb * mb + 4 * mb - 3 ) real ( kind = 8 ) s real ( kind = 8 ) scale real ( kind = 8 ) t real ( kind = 8 ) tst1 real ( kind = 8 ) tst2 ierr = 0 m1 = min ( mb , n ) m = m1 - 1 m2 = m + m m21 = m2 + 1 m3 = m21 + m m31 = m3 + 1 m4 = m31 + m2 mn = m + n mz = mb - m1 its = 0 ! !  Test for convergence. ! 40 continue g = a ( n , mb ) if ( m == 0 ) go to 360 f = 0.0D+00 do k = 1 , m mk = k + mz f = f + abs ( a ( n , mk ) ) end do if ( its == 0 . and . r < f ) then r = f end if tst1 = r tst2 = tst1 + f if ( tst2 <= tst1 ) go to 360 if ( 30 <= its ) then ierr = n return end if its = its + 1 ! !  Form shift from bottom 2 by 2 minor. ! if ( f <= 0.25D+00 * r . or . its >= 5 ) then f = a ( n , mb - 1 ) if ( f /= 0.0D+00 ) then q = ( a ( n - 1 , mb ) - g ) / ( 2.0D+00 * f ) s = pythag ( q , 1.0D+00 ) g = g - f / ( q + sign ( s , q ) ) end if t = t + g a ( 1 : n , mb ) = a ( 1 : n , mb ) - g end if rv ( m31 : m4 ) = 0.0D+00 do ii = 1 , mn i = ii - m ni = n - ii if ( ni < 0 ) go to 230 ! !  Form column of shifted matrix A-G*I. ! l = max ( 1 , 2 - i ) rv ( 1 : m3 ) = 0.0D+00 do k = l , m1 km = k + m mk = k + mz rv ( km ) = a ( ii , mk ) end do ll = min ( m , ni ) do k = 1 , ll km = k + m21 ik = ii + k mk = mb - k rv ( km ) = a ( ik , mk ) end do ! !  Pre-multiply with Householder reflections. ! ll = m2 imult = 0 ! !  Multiplication procedure. ! 140 continue kj = m4 - m1 do j = 1 , ll kj = kj + m1 jm = j + m3 if ( rv ( jm ) /= 0.0D+00 ) then f = 0.0D+00 do k = 1 , m1 kj = kj + 1 jk = j + k - 1 f = f + rv ( kj ) * rv ( jk ) end do f = f / rv ( jm ) kj = kj - m1 do k = 1 , m1 kj = kj + 1 jk = j + k - 1 rv ( jk ) = rv ( jk ) - rv ( kj ) * f end do kj = kj - m1 end if end do if ( imult /= 0 ) go to 280 ! !  Householder reflection. ! f = rv ( m21 ) s = 0.0D+00 rv ( m4 ) = 0.0D+00 scale = sum ( abs ( rv ( m21 : m3 ) ) ) if ( scale == 0.0D+00 ) then go to 210 end if do k = m21 , m3 s = s + ( rv ( k ) / scale ) ** 2 end do s = scale * scale * s g = - sign ( sqrt ( s ), f ) rv ( m21 ) = g rv ( m4 ) = s - f * g kj = m4 + m2 * m1 + 1 rv ( kj ) = f - g do k = 2 , m1 kj = kj + 1 km = k + m2 rv ( kj ) = rv ( km ) end do ! !  Save column of triangular factor R. ! 210 continue do k = l , m1 km = k + m mk = k + mz a ( ii , mk ) = rv ( km ) end do 230 continue l = max ( 1 , m1 + 1 - i ) if ( i <= 0 ) go to 300 ! !  Perform additional steps. ! rv ( 1 : m21 ) = 0.0D+00 ll = min ( m1 , ni + m1 ) ! !  Get row of triangular factor R. ! do kk = 1 , ll k = kk - 1 km = k + m1 ik = i + k mk = mb - k rv ( km ) = a ( ik , mk ) end do ! !  Post-multiply with Householder reflections. ! ll = m1 imult = 1 go to 140 ! !  Store column of new a matrix. ! 280 continue do k = l , m1 mk = k + mz a ( i , mk ) = rv ( k ) end do ! !  Update Householder reflections. ! 300 continue if ( 1 < l ) then l = l - 1 end if kj1 = m4 + l * m1 do j = l , m2 jm = j + m3 rv ( jm ) = rv ( jm + 1 ) do k = 1 , m1 kj1 = kj1 + 1 kj = kj1 - m1 rv ( kj ) = rv ( kj1 ) end do end do end do go to 40 ! !  Convergence. ! 360 continue t = t + g a ( 1 : n , mb ) = a ( 1 : n , mb ) - g do k = 1 , m1 mk = k + mz a ( n , mk ) = 0.0D+00 end do return end subroutine cbabk2 ( n , low , igh , scale , m , zr , zi ) !DEC$ ATTRIBUTES DLLEXPORT :: cbabk2 !*****************************************************************************80 ! !! CBABK2 finds eigenvectors by undoing the CBAL transformation. ! !  Discussion: ! !    This subroutine forms the eigenvectors of a complex general !    matrix by back transforming those of the corresponding !    balanced matrix determined by CBAL. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, integer ( kind = 4 ) LOW, IGH, values determined by CBAL. ! !    Input, real ( kind = 8 ) SCALE(N), information determining the permutations !    and scaling factors used by CBAL. ! !    Input, integer ( kind = 4 ) M, the number of eigenvectors to be back transformed. ! !    Input/output, real ( kind = 8 ) ZR(N,M), ZI(N,M).  On input, the real and imaginary !    parts, respectively, of the eigenvectors to be back transformed in !    their first M columns.  On output, the transformed eigenvectors. ! implicit none integer ( kind = 4 ) m integer ( kind = 4 ) n integer ( kind = 4 ) i integer ( kind = 4 ) igh integer ( kind = 4 ) ii integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) low real ( kind = 8 ) s real ( kind = 8 ) scale ( n ) real ( kind = 8 ) zi ( n , m ) real ( kind = 8 ) zr ( n , m ) if ( m == 0 ) then return end if if ( igh /= low ) then do i = low , igh s = scale ( i ) zr ( i , 1 : m ) = zr ( i , 1 : m ) * s zi ( i , 1 : m ) = zi ( i , 1 : m ) * s end do end if do ii = 1 , n i = ii if ( i < low . or . i > igh ) then if ( i < low ) then i = low - ii end if k = scale ( i ) if ( k /= i ) then do j = 1 , m call r8_swap ( zr ( i , j ), zr ( k , j ) ) call r8_swap ( zi ( i , j ), zi ( k , j ) ) end do end if end if end do return end subroutine cbal ( n , ar , ai , low , igh , scale ) !DEC$ ATTRIBUTES DLLEXPORT :: cbal !*****************************************************************************80 ! !! CBAL balances a complex matrix before eigenvalue calculations. ! !  Discussion: ! !    This subroutine balances a complex matrix and isolates !    eigenvalues whenever possible. ! !    Suppose that the principal submatrix in rows low through igh !    has been balanced, that P(J) denotes the index interchanged !    with J during the permutation step, and that the elements !    of the diagonal matrix used are denoted by D(I,J).  Then !      SCALE(J) = P(J),    for J = 1,...,LOW-1 !               = D(J,J)       J = LOW,...,IGH !               = P(J)         J = IGH+1,...,N. !    The order in which the interchanges are made is N to IGH+1, !    then 1 to LOW-1. ! !    Note that 1 is returned for IGH if IGH is zero formally. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input/output, real ( kind = 8 ) AR(N,N), AI(N,N).  On input, the real and !    imaginary parts of the complex matrix to be balanced.  On output, !    the real and imaginary parts of the balanced matrix. ! !    Output, integer ( kind = 4 ) LOW, IGH, are values such that AR(I,J) and AI(I,J) !    are zero if I is greater than J and either J=1,...,LOW-1 or !    I=IGH+1,...,N. ! !    Output, real ( kind = 8 ) SCALE(N), information determining the !    permutations and scaling factors used. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) ai ( n , n ) real ( kind = 8 ) ar ( n , n ) real ( kind = 8 ) b2 real ( kind = 8 ) c real ( kind = 8 ) f real ( kind = 8 ) g integer ( kind = 4 ) i integer ( kind = 4 ) iexc integer ( kind = 4 ) igh integer ( kind = 4 ) j integer ( kind = 4 ) jj integer ( kind = 4 ) k integer ( kind = 4 ) l integer ( kind = 4 ) low integer ( kind = 4 ) m logical noconv real ( kind = 8 ) r real ( kind = 8 ) radix real ( kind = 8 ) s real ( kind = 8 ) scale ( n ) radix = 1 6.0D+00 iexc = 0 j = 0 m = 0 b2 = radix * radix k = 1 l = n go to 100 20 continue scale ( m ) = j if ( j /= m ) then do i = 1 , l call r8_swap ( ar ( i , j ), ar ( i , m ) ) call r8_swap ( ai ( i , j ), ai ( i , m ) ) end do do i = k , n call r8_swap ( ar ( j , i ), ar ( m , i ) ) call r8_swap ( ai ( j , i ), ai ( m , i ) ) end do end if if ( iexc == 2 ) then go to 130 end if ! !  Search for rows isolating an eigenvalue and push them down. ! 80 continue if ( l == 1 ) then go to 280 end if l = l - 1 100 continue do jj = 1 , l j = l + 1 - jj do i = 1 , l if ( i /= j ) then if ( ar ( j , i ) /= 0.0D+00 . or . ai ( j , i ) /= 0.0D+00 ) go to 120 end if end do m = l iexc = 1 go to 20 120 continue end do go to 140 ! !  Search for columns isolating an eigenvalue and push them left. ! 130 continue k = k + 1 140 continue do j = k , l do i = k , l if ( i /= j ) then if ( ar ( i , j ) /= 0.0D+00 . or . ai ( i , j ) /= 0.0D+00 ) go to 170 end if end do m = k iexc = 2 go to 20 170 continue end do ! !  Now balance the submatrix in rows k to l. ! scale ( k : l ) = 1.0D+00 ! !  Iterative loop for norm reduction. ! 190 continue noconv = . false . do i = k , l c = 0.0D+00 r = 0.0D+00 do j = k , l if ( j /= i ) then c = c + abs ( ar ( j , i ) ) + abs ( ai ( j , i ) ) r = r + abs ( ar ( i , j ) ) + abs ( ai ( i , j ) ) end if end do ! !  Guard against zero C or R due to underflow. ! if ( c == 0.0D+00 . or . r == 0.0D+00 ) go to 270 g = r / radix f = 1.0D+00 s = c + r do while ( c < g ) f = f * radix c = c * b2 end do g = r * radix do while ( c >= g ) f = f / radix c = c / b2 end do ! !  Now balance. ! if ( ( c + r ) / f < 0.95D+00 * s ) then g = 1.0D+00 / f scale ( i ) = scale ( i ) * f noconv = . true . ar ( i , k : n ) = ar ( i , k : n ) * g ai ( i , k : n ) = ai ( i , k : n ) * g ar ( 1 : l , i ) = ar ( 1 : l , i ) * f ai ( 1 : l , i ) = ai ( 1 : l , i ) * f end if 270 continue end do if ( noconv ) go to 190 280 continue low = k igh = l return end subroutine cdiv ( ar , ai , br , bi , cr , ci ) !DEC$ ATTRIBUTES DLLEXPORT :: cdiv !*****************************************************************************80 ! !! CDIV emulates complex division, using real arithmetic. ! !  Discussion: ! !    This routine performs complex division: ! !      (CR,CI) = (AR,AI) / (BR,BI) ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, real ( kind = 8 ) AR, AI, the real and imaginary parts of the numerator. ! !    Input, real ( kind = 8 ) BR, BI, the real and imaginary parts of the denominator. ! !    Output, real ( kind = 8 ) CR, CI, the real and imaginary parts of the result. ! implicit none real ( kind = 8 ) ai real ( kind = 8 ) ais real ( kind = 8 ) ar real ( kind = 8 ) ars real ( kind = 8 ) bi real ( kind = 8 ) bis real ( kind = 8 ) br real ( kind = 8 ) brs real ( kind = 8 ) ci real ( kind = 8 ) cr real ( kind = 8 ) s s = abs ( br ) + abs ( bi ) ars = ar / s ais = ai / s brs = br / s bis = bi / s s = brs ** 2 + bis ** 2 cr = ( ars * brs + ais * bis ) / s ci = ( ais * brs - ars * bis ) / s return end subroutine cg ( n , ar , ai , wr , wi , matz , zr , zi , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: cg !*****************************************************************************80 ! !! CG gets eigenvalues and eigenvectors of a complex general matrix. ! !  Discussion: ! !    This subroutine calls the recommended sequence of EISPACK subroutines !    to find the eigenvalues and eigenvectors (if desired) !    of a complex general matrix. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input/output, real ( kind = 8 ) AR(N,N), AI(N,N).  On input, the real and !    imaginary parts of the complex matrix.  On output, AR and AI !    have been overwritten by other information. ! !    Output, real ( kind = 8 ) WR(N), WI(N), the real and imaginary parts !    of the eigenvalues. ! !    Input, integer ( kind = 4 ) MATZ, is 0 if only eigenvalues are desired, and !    nonzero if both eigenvalues and eigenvectors are to be computed. ! !    Output, real ( kind = 8 ) ZR(N,N), ZI(N,N), the real and imaginary parts, !    respectively, of the eigenvectors, if MATZ is not zero. ! !    Output, integer ( kind = 4 ) IERR, an error completion code described in the !    documentation for COMQR and COMQR2.  The normal completion code is zero. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) ai ( n , n ) real ( kind = 8 ) ar ( n , n ) real ( kind = 8 ) fv1 ( n ) real ( kind = 8 ) fv2 ( n ) real ( kind = 8 ) fv3 ( n ) integer ( kind = 4 ) ierr integer ( kind = 4 ) is1 integer ( kind = 4 ) is2 integer ( kind = 4 ) matz real ( kind = 8 ) wi ( n ) real ( kind = 8 ) wr ( n ) real ( kind = 8 ) zi ( n , n ) real ( kind = 8 ) zr ( n , n ) call cbal ( n , ar , ai , is1 , is2 , fv1 ) call corth ( n , is1 , is2 , ar , ai , fv2 , fv3 ) if ( matz == 0 ) then call comqr ( n , is1 , is2 , ar , ai , wr , wi , ierr ) if ( ierr /= 0 ) then return end if else call comqr2 ( n , is1 , is2 , fv2 , fv3 , ar , ai , wr , wi , zr , zi , ierr ) if ( ierr /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'CG - Fatal error!' write ( * , '(a)' ) '  Nonzero error return from COMQR2.' return end if call cbabk2 ( n , is1 , is2 , fv1 , n , zr , zi ) end if return end subroutine ch ( n , ar , ai , w , matz , zr , zi , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: ch !*****************************************************************************80 ! !! CH gets eigenvalues and eigenvectors of a complex Hermitian matrix. ! !  Discussion: ! !    This subroutine calls the recommended sequence of subroutines from the !    EISPACK eigensystem package to find the eigenvalues and eigenvectors !    of a complex hermitian matrix. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input/output, real ( kind = 8 ) AR(N,N), AI(N,N).  On input, the real and !    imaginary parts of the complex matrix.  On output, AR and AI !    have been overwritten by other information. ! !    Output, real ( kind = 8 ) W(N), the eigenvalues in ascending order. ! !    Input, integer ( kind = 4 ) MATZ, is 0 if only eigenvalues are desired, and !    nonzero if both eigenvalues and eigenvectors are to be computed. ! !    Output, real ( kind = 8 ) ZR(N,N), ZI(N,N), the real and imaginary parts, !    respectively, of the eigenvectors, if MATZ is not zero. ! !    Output, integer ( kind = 4 ) IERR, an error completion code described in the !    documentation for TQLRAT and TQL2.  The normal completion code is zero. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) ai ( n , n ) real ( kind = 8 ) ar ( n , n ) real ( kind = 8 ) fm1 ( 2 , n ) real ( kind = 8 ) fv1 ( n ) real ( kind = 8 ) fv2 ( n ) integer ( kind = 4 ) i integer ( kind = 4 ) ierr integer ( kind = 4 ) matz real ( kind = 8 ) w ( n ) real ( kind = 8 ) zi ( n , n ) real ( kind = 8 ) zr ( n , n ) call htridi ( n , ar , ai , w , fv1 , fv2 , fm1 ) if ( matz == 0 ) then call tqlrat ( n , w , fv2 , ierr ) else zr ( 1 : n , 1 : n ) = 0.0D+00 do i = 1 , n zr ( i , i ) = 1.0D+00 end do call tql2 ( n , w , fv1 , zr , ierr ) if ( ierr /= 0 ) then return end if call htribk ( n , ar , ai , fm1 , n , zr , zi ) end if return end subroutine cinvit ( n , ar , ai , wr , wi , select , mm , m , zr , zi , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: cinvit !*****************************************************************************80 ! !! CINVIT gets eigenvectors from eigenvalues, for a complex Hessenberg matrix. ! !  Discussion: ! !    This subroutine finds those eigenvectors of a complex upper !    Hessenberg matrix corresponding to specified eigenvalues, !    using inverse iteration. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, real ( kind = 8 ) AR(N,N), AI(N,N), the real and imaginary parts of !    the complex Hessenberg matrix. ! !    Input/output, real ( kind = 8 ) WR(N), WI(N).  On input, the real and imaginary parts !    of the eigenvalues of the matrix.  The eigenvalues must be stored in a !    manner identical to that of subroutine COMLR, which recognizes possible !    splitting of the matrix.  On output, WR may have been altered since !    close eigenvalues are perturbed slightly in searching for independent !    eigenvectors. ! !    Input, logical SELECT(N), specifies the eigenvectors to be found.  The !    eigenvector corresponding to the J-th eigenvalue is specified by !    setting SELECT(J) to TRUE. ! !    Input, integer ( kind = 4 ) MM, an upper bound for the number of eigenvectors !    to be found. ! !    Output, integer ( kind = 4 ) M, the number of eigenvectors actually found. ! !    Output, real ( kind = 8 ) ZR(N,MM), ZI(N,MM), the real and imaginary parts !    of the eigenvectors.  The eigenvectors are normalized so that the !    component of largest magnitude is 1. !    Any vector which fails the acceptance test is set to zero. ! !    Output, integer ( kind = 4 ) IERR, error flag. !    0, for normal return, !    -(2*N+1), if more than MM eigenvectors have been specified, !    -K, if the iteration corresponding to the K-th value fails, !    -(N+K), if both error situations occur. ! implicit none integer ( kind = 4 ) mm integer ( kind = 4 ) n real ( kind = 8 ) ai ( n , n ) real ( kind = 8 ) ar ( n , n ) real ( kind = 8 ) eps3 real ( kind = 8 ) growto integer ( kind = 4 ) i integer ( kind = 4 ) ierr integer ( kind = 4 ) ii real ( kind = 8 ) ilambd integer ( kind = 4 ) its integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) km1 integer ( kind = 4 ) m integer ( kind = 4 ) mp real ( kind = 8 ) norm real ( kind = 8 ) normv real ( kind = 8 ) pythag real ( kind = 8 ) rlambd real ( kind = 8 ) rm1 ( n , n ) real ( kind = 8 ) rm2 ( n , n ) real ( kind = 8 ) rv1 ( n ) real ( kind = 8 ) rv2 ( n ) integer ( kind = 4 ) s logical select ( n ) integer ( kind = 4 ) uk real ( kind = 8 ) ukroot real ( kind = 8 ) wi ( n ) real ( kind = 8 ) wr ( n ) real ( kind = 8 ) x real ( kind = 8 ) y real ( kind = 8 ) zi ( n , mm ) real ( kind = 8 ) zr ( n , mm ) ierr = 0 uk = 0 s = 1 do k = 1 , n if ( . not . select ( k ) ) then cycle end if if ( s > mm ) go to 1000 if ( uk >= k ) go to 200 ! !  Check for possible splitting. ! do uk = k , n - 1 if ( ar ( uk + 1 , uk ) == 0.0D+00 . and . ai ( uk + 1 , uk ) == 0.0D+00 ) then exit end if end do ! !  Compute infinity norm of leading UK by UK (Hessenberg) matrix. ! norm = 0.0D+00 mp = 1 do i = 1 , uk x = 0.0D+00 do j = mp , uk x = x + pythag ( ar ( i , j ), ai ( i , j ) ) end do norm = max ( norm , x ) mp = i end do ! !  EPS3 replaces zero pivot in decomposition !  and close roots are modified by EPS3. ! if ( norm == 0.0D+00 ) norm = 1.0D+00 eps3 = abs ( norm ) * epsilon ( eps3 ) ! !  GROWTO is the criterion for growth. ! ukroot = uk ukroot = sqrt ( ukroot ) growto = 0.1D+00 / ukroot 200 continue rlambd = wr ( k ) ilambd = wi ( k ) if ( k == 1 ) go to 280 km1 = k - 1 go to 240 ! !  Perturb eigenvalue if it is close to any previous eigenvalue. ! 220 continue rlambd = rlambd + eps3 240 continue do ii = 1 , km1 i = k - ii if ( select ( i ) . and . abs ( wr ( i ) - rlambd ) < eps3 . and . & abs ( wi ( i ) - ilambd ) < eps3 ) then go to 220 end if end do wr ( k ) = rlambd ! !  Form upper Hessenberg (ar,ai)-(rlambd,ilambd) * I !  and initial complex vector. ! 280 continue mp = 1 do i = 1 , uk do j = mp , uk rm1 ( i , j ) = ar ( i , j ) rm2 ( i , j ) = ai ( i , j ) end do rm1 ( i , i ) = rm1 ( i , i ) - rlambd rm2 ( i , i ) = rm2 ( i , i ) - ilambd mp = i rv1 ( i ) = eps3 end do ! !  Triangular decomposition with interchanges, replacing zero pivots by eps3. ! do i = 2 , uk mp = i - 1 if ( pythag ( rm1 ( i , mp ), rm2 ( i , mp ) ) > & pythag ( rm1 ( mp , mp ), rm2 ( mp , mp ) ) ) then do j = mp , uk call r8_swap ( rm1 ( i , j ), rm1 ( mp , j ) ) call r8_swap ( rm2 ( i , j ), rm2 ( mp , j ) ) end do end if if ( rm1 ( mp , mp ) == 0.0D+00 . and . rm2 ( mp , mp ) == 0.0D+00 ) then rm1 ( mp , mp ) = eps3 end if call cdiv ( rm1 ( i , mp ), rm2 ( i , mp ), rm1 ( mp , mp ), rm2 ( mp , mp ), x , y ) if ( x /= 0.0D+00 . or . y /= 0.0D+00 ) then do j = i , uk rm1 ( i , j ) = rm1 ( i , j ) - x * rm1 ( mp , j ) + y * rm2 ( mp , j ) rm2 ( i , j ) = rm2 ( i , j ) - x * rm2 ( mp , j ) - y * rm1 ( mp , j ) end do end if end do if ( rm1 ( uk , uk ) == 0.0D+00 . and . rm2 ( uk , uk ) == 0.0D+00 ) then rm1 ( uk , uk ) = eps3 end if its = 0 ! !  Back substitution. ! 660 continue do ii = 1 , uk i = uk + 1 - ii x = rv1 ( i ) y = 0.0D+00 do j = i + 1 , uk x = x - rm1 ( i , j ) * rv1 ( j ) + rm2 ( i , j ) * rv2 ( j ) y = y - rm1 ( i , j ) * rv2 ( j ) - rm2 ( i , j ) * rv1 ( j ) end do call cdiv ( x , y , rm1 ( i , i ), rm2 ( i , i ), rv1 ( i ), rv2 ( i ) ) end do ! !  Acceptance test for eigenvector and normalization. ! its = its + 1 norm = 0.0D+00 normv = 0.0D+00 do i = 1 , uk x = pythag ( rv1 ( i ), rv2 ( i ) ) if ( normv < x ) then normv = x j = i end if norm = norm + x end do if ( norm < growto ) go to 840 ! !  Accept vector. ! x = rv1 ( j ) y = rv2 ( j ) do i = 1 , uk call cdiv ( rv1 ( i ), rv2 ( i ), x , y , zr ( i , s ), zi ( i , s ) ) end do if ( uk == n ) then go to 940 end if j = uk + 1 go to 900 ! !  Choose a new starting vector. ! 840 continue if ( its < uk ) then x = ukroot y = eps3 / ( x + 1.0D+00 ) rv1 ( 1 ) = eps3 rv1 ( 2 : uk ) = y j = uk - its + 1 rv1 ( j ) = rv1 ( j ) - eps3 * x go to 660 end if ! !  Error: unaccepted eigenvector. ! 880 continue j = 1 ierr = - k ! !  Set remaining vector components to zero. ! 900 continue zr ( j : n , s ) = 0.0D+00 zi ( j : n , s ) = 0.0D+00 940 continue s = s + 1 end do go to 1001 ! !  Set error: underestimate of eigenvector space required. ! 1000 continue if ( ierr /= 0 ) ierr = ierr - n if ( ierr == 0 ) ierr = - ( 2 * n + 1 ) 1001 continue m = s - 1 return end subroutine combak ( n , low , igh , ar , ai , int , m , zr , zi ) !DEC$ ATTRIBUTES DLLEXPORT :: combak !*****************************************************************************80 ! !! COMBAK determines eigenvectors by undoing the COMHES transformation. ! !  Discussion: ! !    This subroutine forms the eigenvectors of a complex general !    matrix by back transforming those of the corresponding !    upper Hessenberg matrix determined by COMHES. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, integer ( kind = 4 ) LOW, IGH, are determined by the balancing routine CBAL. !    If CBAL is not used, set LOW = 1 and IGH = to the order of the matrix. ! !    Input, real ( kind = 8 ) AR(N,IGH), AI(N,IGH), the multipliers which were used in the !    reduction by COMHES in their lower triangles below the subdiagonal. ! !    Input, integer ( kind = 4 ) INT(IGH), information on the rows and columns interchanged !    in the reduction by COMHES. ! !    Input, integer ( kind = 4 ) M, the number of eigenvectors to be back transformed. ! !    Input/output, real ( kind = 8 ) ZR(N,M), ZI(N,M).  On input, the real and imaginary !    parts of the eigenvectors to be back transformed.  On output, the real !    and imaginary parts of the transformed eigenvectors. ! implicit none integer ( kind = 4 ) igh integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) ai ( n , igh ) real ( kind = 8 ) ar ( n , igh ) integer ( kind = 4 ) i integer ( kind = 4 ) int ( igh ) integer ( kind = 4 ) j integer ( kind = 4 ) la integer ( kind = 4 ) low integer ( kind = 4 ) mm integer ( kind = 4 ) mp real ( kind = 8 ) xi real ( kind = 8 ) xr real ( kind = 8 ) zi ( n , m ) real ( kind = 8 ) zr ( n , m ) if ( m == 0 ) then return end if la = igh - 1 if ( igh - 1 < low + 1 ) then return end if do mm = low + 1 , la mp = low + igh - mm do i = mp + 1 , igh xr = ar ( i , mp - 1 ) xi = ai ( i , mp - 1 ) if ( xr /= 0.0D+00 . or . xi /= 0.0D+00 ) then zr ( i , 1 : m ) = zr ( i , 1 : m ) + xr * zr ( mp , 1 : m ) - xi * zi ( mp , 1 : m ) zi ( i , 1 : m ) = zi ( i , 1 : m ) + xr * zi ( mp , 1 : m ) + xi * zr ( mp , 1 : m ) end if end do i = int ( mp ) if ( i /= mp ) then do j = 1 , m call r8_swap ( zr ( i , j ), zr ( mp , j ) ) call r8_swap ( zi ( i , j ), zi ( mp , j ) ) end do end if end do return end subroutine comhes ( n , low , igh , ar , ai , int ) !DEC$ ATTRIBUTES DLLEXPORT :: comhes !*****************************************************************************80 ! !! COMHES transforms a complex general matrix to upper Hessenberg form. ! !  Discussion: ! !    Given a complex general matrix, this subroutine !    reduces a submatrix situated in rows and columns !    LOW through IGH to upper Hessenberg form by !    stabilized elementary similarity transformations. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, integer ( kind = 4 ) LOW, IGH, are determined by the balancing routine CBAL. !    If CBAL is not used, set LOW = 1 and IGH = N. ! !    Input/output, real ( kind = 8 ) AR(N,N), AI(N,N).  On input, the real and imaginary !    parts of the complex input matrix.  On output, the real and imaginary !    parts of the Hessenberg matrix.  The multipliers which were used in the !    reduction are stored in the remaining triangles under the !    Hessenberg matrix. ! !    Output, integer ( kind = 4 ) INT(IGH), information on the rows and columns !    interchanged in the reduction. ! implicit none integer ( kind = 4 ) igh integer ( kind = 4 ) n real ( kind = 8 ) ai ( n , n ) real ( kind = 8 ) ar ( n , n ) integer ( kind = 4 ) i integer ( kind = 4 ) int ( igh ) integer ( kind = 4 ) j integer ( kind = 4 ) la integer ( kind = 4 ) low integer ( kind = 4 ) m real ( kind = 8 ) xi real ( kind = 8 ) xr real ( kind = 8 ) yi real ( kind = 8 ) yr la = igh - 1 do m = low + 1 , la xr = 0.0D+00 xi = 0.0D+00 i = m do j = m , igh if ( abs ( ar ( j , m - 1 ) ) + abs ( ai ( j , m - 1 ) ) > & abs ( xr ) + abs ( xi ) ) then xr = ar ( j , m - 1 ) xi = ai ( j , m - 1 ) i = j end if end do int ( m ) = i ! !  Interchange rows and columns of AR and AI. ! if ( i /= m ) then do j = m - 1 , n call r8_swap ( ar ( i , j ), ar ( m , j ) ) call r8_swap ( ai ( i , j ), ai ( m , j ) ) end do do j = 1 , igh call r8_swap ( ar ( j , i ), ar ( j , m ) ) call r8_swap ( ai ( j , i ), ai ( j , m ) ) end do end if if ( xr /= 0.0D+00 . or . xi /= 0.0D+00 ) then do i = m + 1 , igh yr = ar ( i , m - 1 ) yi = ai ( i , m - 1 ) if ( yr /= 0.0D+00 . or . yi /= 0.0D+00 ) then call cdiv ( yr , yi , xr , xi , yr , yi ) ar ( i , m - 1 ) = yr ai ( i , m - 1 ) = yi do j = m , n ar ( i , j ) = ar ( i , j ) - yr * ar ( m , j ) + yi * ai ( m , j ) ai ( i , j ) = ai ( i , j ) - yr * ai ( m , j ) - yi * ar ( m , j ) end do ar ( 1 : igh , m ) = ar ( 1 : igh , m ) + yr * ar ( 1 : igh , i ) - yi * ai ( 1 : igh , i ) ai ( 1 : igh , m ) = ai ( 1 : igh , m ) + yr * ai ( 1 : igh , i ) + yi * ar ( 1 : igh , i ) end if end do end if end do return end subroutine comlr ( n , low , igh , hr , hi , wr , wi , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: comlr !*****************************************************************************80 ! !! COMLR gets all eigenvalues of a complex upper Hessenberg matrix. ! !  Discussion: ! !    This subroutine finds the eigenvalues of a complex upper Hessenberg !    matrix by the modified LR method. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, integer ( kind = 4 ) LOW, IGH, are determined by the balancing routine CBAL. !    If CBAL is not used, set LOW = 1 and IGH = N. ! !    Input/output, real ( kind = 8 ) HR(N,N), HI(N,N).  On input, the real and imaginary !    parts of the complex upper Hessenberg matrix.  Their lower triangles !    below the subdiagonal contain the multipliers which were used in the !    reduction by COMHES if performed.  On output, the upper Hessenberg !    portions of HR and HI have been destroyed.  Therefore, they must be !    saved before calling COMLR if subsequent calculation of eigenvectors !    is to be performed. ! !    Output, real ( kind = 8 ) WR(N), WI(N), the real and imaginary parts of the !    eigenvalues.  If an error exit is made, the eigenvalues should be correct !    for indices IERR+1,...,N. ! !    Output, integer ( kind = 4 ) IERR, error flag. !    0, for normal return, !    J, if the limit of 30*N iterations is exhausted while the J-th !      eigenvalue is being sought. ! implicit none integer ( kind = 4 ) n integer ( kind = 4 ) en integer ( kind = 4 ) enm1 real ( kind = 8 ) hi ( n , n ) real ( kind = 8 ) hr ( n , n ) integer ( kind = 4 ) i integer ( kind = 4 ) ierr integer ( kind = 4 ) igh integer ( kind = 4 ) itn integer ( kind = 4 ) its integer ( kind = 4 ) j integer ( kind = 4 ) l integer ( kind = 4 ) ll integer ( kind = 4 ) low integer ( kind = 4 ) m integer ( kind = 4 ) mm real ( kind = 8 ) si real ( kind = 8 ) sr real ( kind = 8 ) ti real ( kind = 8 ) tr real ( kind = 8 ) tst1 real ( kind = 8 ) tst2 real ( kind = 8 ) wi ( n ) real ( kind = 8 ) wr ( n ) real ( kind = 8 ) xi real ( kind = 8 ) xr real ( kind = 8 ) yi real ( kind = 8 ) yr real ( kind = 8 ) zzi real ( kind = 8 ) zzr ierr = 0 ! !  Store roots isolated by CBAL. ! do i = 1 , n if ( i < low . or . i > igh ) then wr ( i ) = hr ( i , i ) wi ( i ) = hi ( i , i ) end if end do en = igh tr = 0.0D+00 ti = 0.0D+00 itn = 30 * n ! !  Search for next eigenvalue. ! 220 continue if ( en < low ) then return end if its = 0 enm1 = en - 1 ! !  Look for single small sub-diagonal element. ! 240 continue do ll = low , en l = en + low - ll if ( l == low ) go to 300 tst1 = abs ( hr ( l - 1 , l - 1 ) ) + abs ( hi ( l - 1 , l - 1 ) ) + abs ( hr ( l , l ) ) & + abs ( hi ( l , l ) ) tst2 = tst1 + abs ( hr ( l , l - 1 ) ) + abs ( hi ( l , l - 1 ) ) if ( tst2 == tst1 ) go to 300 end do ! !  Form shift. ! 300 continue if ( l == en ) then go to 660 end if if ( itn == 0 ) then ierr = en return end if if ( its == 10 . or . its == 20 ) go to 320 sr = hr ( en , en ) si = hi ( en , en ) xr = hr ( enm1 , en ) * hr ( en , enm1 ) - hi ( enm1 , en ) * hi ( en , enm1 ) xi = hr ( enm1 , en ) * hi ( en , enm1 ) + hi ( enm1 , en ) * hr ( en , enm1 ) if ( xr == 0.0D+00 . and . xi == 0.0D+00 ) go to 340 yr = ( hr ( enm1 , enm1 ) - sr ) / 2.0D+00 yi = ( hi ( enm1 , enm1 ) - si ) / 2.0D+00 call csroot ( yr ** 2 - yi ** 2 + xr , 2.0D+00 * yr * yi + xi , zzr , zzi ) if ( yr * zzr + yi * zzi < 0.0D+00 ) then zzr = - zzr zzi = - zzi end if call cdiv ( xr , xi , yr + zzr , yi + zzi , xr , xi ) sr = sr - xr si = si - xi go to 340 ! !  Form exceptional shift. ! 320 continue sr = abs ( hr ( en , enm1 ) ) + abs ( hr ( enm1 , en - 2 ) ) si = abs ( hi ( en , enm1 ) ) + abs ( hi ( enm1 , en - 2 ) ) 340 continue do i = low , en hr ( i , i ) = hr ( i , i ) - sr hi ( i , i ) = hi ( i , i ) - si end do tr = tr + sr ti = ti + si its = its + 1 itn = itn - 1 ! !  Look for two consecutive small sub-diagonal elements. ! xr = abs ( hr ( enm1 , enm1 ) ) + abs ( hi ( enm1 , enm1 ) ) yr = abs ( hr ( en , enm1 ) ) + abs ( hi ( en , enm1 ) ) zzr = abs ( hr ( en , en ) ) + abs ( hi ( en , en ) ) do mm = l , enm1 m = enm1 + l - mm if ( m == l ) then exit end if yi = yr yr = abs ( hr ( m , m - 1 ) ) + abs ( hi ( m , m - 1 ) ) xi = zzr zzr = xr xr = abs ( hr ( m - 1 , m - 1 ) ) + abs ( hi ( m - 1 , m - 1 ) ) tst1 = zzr / yi * ( zzr + xr + xi ) tst2 = tst1 + yr if ( tst2 == tst1 ) then exit end if end do ! !  Triangular decomposition H=L*R. ! do i = m + 1 , en xr = hr ( i - 1 , i - 1 ) xi = hi ( i - 1 , i - 1 ) yr = hr ( i , i - 1 ) yi = hi ( i , i - 1 ) if ( abs ( xr ) + abs ( xi ) >= abs ( yr ) + abs ( yi ) ) go to 460 ! !  Interchange rows of HR and HI. ! do j = i - 1 , en call r8_swap ( hr ( i - 1 , j ), hr ( i , j ) ) call r8_swap ( hi ( i - 1 , j ), hi ( i , j ) ) end do call cdiv ( xr , xi , yr , yi , zzr , zzi ) wr ( i ) = 1.0D+00 go to 480 460 continue call cdiv ( yr , yi , xr , xi , zzr , zzi ) wr ( i ) = - 1.0D+00 480 continue hr ( i , i - 1 ) = zzr hi ( i , i - 1 ) = zzi do j = i , en hr ( i , j ) = hr ( i , j ) - zzr * hr ( i - 1 , j ) + zzi * hi ( i - 1 , j ) hi ( i , j ) = hi ( i , j ) - zzr * hi ( i - 1 , j ) - zzi * hr ( i - 1 , j ) end do end do ! !  Composition R*L=H. ! do j = m + 1 , en xr = hr ( j , j - 1 ) xi = hi ( j , j - 1 ) hr ( j , j - 1 ) = 0.0D+00 hi ( j , j - 1 ) = 0.0D+00 ! !  Interchange columns of HR and HI, if necessary. ! if ( wr ( j ) > 0.0D+00 ) then do i = l , j call r8_swap ( hr ( i , j - 1 ), hr ( i , j ) ) call r8_swap ( hi ( i , j - 1 ), hi ( i , j ) ) end do end if do i = l , j hr ( i , j - 1 ) = hr ( i , j - 1 ) + xr * hr ( i , j ) - xi * hi ( i , j ) hi ( i , j - 1 ) = hi ( i , j - 1 ) + xr * hi ( i , j ) + xi * hr ( i , j ) end do end do go to 240 ! !  A root found. ! 660 continue wr ( en ) = hr ( en , en ) + tr wi ( en ) = hi ( en , en ) + ti en = enm1 go to 220 end subroutine comlr2 ( n , low , igh , int , hr , hi , wr , wi , zr , zi , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: comlr2 !*****************************************************************************80 ! !! COMLR2 gets eigenvalues/vectors of a complex upper Hessenberg matrix. ! !  Discussion: ! !    This subroutine finds the eigenvalues and eigenvectors of a complex !    upper Hessenberg matrix by the modified LR method.  The eigenvectors !    of a complex general matrix can also be found if COMHES has been used !    to reduce this general matrix to Hessenberg form. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, integer ( kind = 4 ) LOW, IGH, are determined by the balancing routine CBAL. !    If CBAL is not used, set LOW = 1 and IGH = N. ! !    Input, integer ( kind = 4 ) INT(IGH), information on the rows and columns interchanged !    in the reduction by COMHES, if performed.  If the eigenvectors of the !    Hessenberg matrix are desired, set INT(J)=J for these elements. ! !    Input/output, real ( kind = 8 ) HR(N,N), HI(N,N).  On input, the real and imaginary !    parts of the complex upper Hessenberg matrix.  Their lower triangles !    below the subdiagonal contain the multipliers which were used in the !    reduction by COMHES, if performed.  If the eigenvectors of the Hessenberg !    matrix are desired, these elements must be set to zero.  On output, !    the upper Hessenberg portions of HR and HI have been destroyed, but the !    location HR(1,1) contains the norm of the triangularized matrix. ! !    Output, real ( kind = 8 ) WR(N), WI(N), the real and imaginary parts of the !    eigenvalues.  If an error exit is made, the eigenvalues should be !    correct for indices IERR+1,...,N. ! !    Output, real ( kind = 8 ) ZR(N,N), ZI(N,N), the real and imaginary parts of the !    eigenvectors.  The eigenvectors are unnormalized.  If an error exit !    is made, none of the eigenvectors has been found. ! !    Output, integer ( kind = 4 ) IERR, error flag. !    0, for normal return, !    J, if the limit of 30*N iterations is exhausted while the J-th !      eigenvalue is being sought. ! implicit none integer ( kind = 4 ) n integer ( kind = 4 ) en integer ( kind = 4 ) enm1 real ( kind = 8 ) hi ( n , n ) real ( kind = 8 ) hr ( n , n ) integer ( kind = 4 ) i integer ( kind = 4 ) iend integer ( kind = 4 ) ierr integer ( kind = 4 ) igh integer ( kind = 4 ) ii integer ( kind = 4 ) int ( igh ) integer ( kind = 4 ) itn integer ( kind = 4 ) its integer ( kind = 4 ) j integer ( kind = 4 ) jj integer ( kind = 4 ) k integer ( kind = 4 ) l integer ( kind = 4 ) ll integer ( kind = 4 ) low integer ( kind = 4 ) m integer ( kind = 4 ) mm integer ( kind = 4 ) nn real ( kind = 8 ) norm real ( kind = 8 ) si real ( kind = 8 ) sr real ( kind = 8 ) ti real ( kind = 8 ) tr real ( kind = 8 ) tst1 real ( kind = 8 ) tst2 real ( kind = 8 ) wi ( n ) real ( kind = 8 ) wr ( n ) real ( kind = 8 ) xi real ( kind = 8 ) xr real ( kind = 8 ) yi real ( kind = 8 ) yr real ( kind = 8 ) zi ( n , n ) real ( kind = 8 ) zr ( n , n ) real ( kind = 8 ) zzi real ( kind = 8 ) zzr ierr = 0 ! !  Initialize the eigenvector matrix. ! zr ( 1 : n , 1 : n ) = 0.0D+00 do i = 1 , n zr ( i , i ) = 1.0D+00 end do zi ( 1 : n , 1 : n ) = 0.0D+00 ! !  Form the matrix of accumulated transformations from the information left !  by COMHES. ! iend = igh - low - 1 do ii = 1 , iend i = igh - ii do k = i + 1 , igh zr ( k , i ) = hr ( k , i - 1 ) zi ( k , i ) = hi ( k , i - 1 ) end do j = int ( i ) if ( i /= j ) then do k = i , igh zr ( i , k ) = zr ( j , k ) zi ( i , k ) = zi ( j , k ) zr ( j , k ) = 0.0D+00 zi ( j , k ) = 0.0D+00 end do zr ( j , i ) = 1.0D+00 end if end do ! !  Store roots isolated by CBAL. ! do i = 1 , n if ( i < low . or . i > igh ) then wr ( i ) = hr ( i , i ) wi ( i ) = hi ( i , i ) end if end do en = igh tr = 0.0D+00 ti = 0.0D+00 itn = 30 * n ! !  Search for next eigenvalue. ! 220 continue if ( en < low ) then go to 680 end if its = 0 enm1 = en - 1 ! !  Look for single small sub-diagonal element. ! 240 continue do ll = low , en l = en + low - ll if ( l == low ) then exit end if tst1 = abs ( hr ( l - 1 , l - 1 ) ) + abs ( hi ( l - 1 , l - 1 ) ) + abs ( hr ( l , l ) ) & + abs ( hi ( l , l ) ) tst2 = tst1 + abs ( hr ( l , l - 1 ) ) + abs ( hi ( l , l - 1 ) ) if ( tst2 == tst1 ) then exit end if end do ! !  Form shift. ! if ( l == en ) go to 660 if ( itn == 0 ) go to 1000 if ( its == 10 . or . its == 20 ) go to 320 sr = hr ( en , en ) si = hi ( en , en ) xr = hr ( enm1 , en ) * hr ( en , enm1 ) - hi ( enm1 , en ) * hi ( en , enm1 ) xi = hr ( enm1 , en ) * hi ( en , enm1 ) + hi ( enm1 , en ) * hr ( en , enm1 ) if ( xr == 0.0D+00 . and . xi == 0.0D+00 ) go to 340 yr = ( hr ( enm1 , enm1 ) - sr ) / 2.0D+00 yi = ( hi ( enm1 , enm1 ) - si ) / 2.0D+00 call csroot ( yr ** 2 - yi ** 2 + xr , 2.0D+00 * yr * yi + xi , zzr , zzi ) if ( yr * zzr + yi * zzi < 0.0D+00 ) then zzr = - zzr zzi = - zzi end if call cdiv ( xr , xi , yr + zzr , yi + zzi , xr , xi ) sr = sr - xr si = si - xi go to 340 ! !  Form exceptional shift. ! 320 continue sr = abs ( hr ( en , enm1 ) ) + abs ( hr ( enm1 , en - 2 ) ) si = abs ( hi ( en , enm1 ) ) + abs ( hi ( enm1 , en - 2 ) ) 340 continue do i = low , en hr ( i , i ) = hr ( i , i ) - sr hi ( i , i ) = hi ( i , i ) - si end do tr = tr + sr ti = ti + si its = its + 1 itn = itn - 1 ! !  Look for two consecutive small sub-diagonal elements. ! xr = abs ( hr ( enm1 , enm1 ) ) + abs ( hi ( enm1 , enm1 ) ) yr = abs ( hr ( en , enm1 ) ) + abs ( hi ( en , enm1 ) ) zzr = abs ( hr ( en , en ) ) + abs ( hi ( en , en ) ) do mm = l , enm1 m = enm1 + l - mm if ( m == l ) then exit end if yi = yr yr = abs ( hr ( m , m - 1 ) ) + abs ( hi ( m , m - 1 ) ) xi = zzr zzr = xr xr = abs ( hr ( m - 1 , m - 1 ) ) + abs ( hi ( m - 1 , m - 1 ) ) tst1 = zzr / yi * ( zzr + xr + xi ) tst2 = tst1 + yr if ( tst2 == tst1 ) then exit end if end do ! !  Triangular decomposition H=L*R. ! do i = m + 1 , en xr = hr ( i - 1 , i - 1 ) xi = hi ( i - 1 , i - 1 ) yr = hr ( i , i - 1 ) yi = hi ( i , i - 1 ) if ( abs ( xr ) + abs ( xi ) >= abs ( yr ) + abs ( yi ) ) go to 460 ! !  Interchange rows of HR and HI. ! do j = i - 1 , n call r8_swap ( hr ( i - 1 , j ), hr ( i , j ) ) call r8_swap ( hi ( i - 1 , j ), hi ( i , j ) ) end do call cdiv ( xr , xi , yr , yi , zzr , zzi ) wr ( i ) = 1.0D+00 go to 480 460 continue call cdiv ( yr , yi , xr , xi , zzr , zzi ) wr ( i ) = - 1.0D+00 480 continue hr ( i , i - 1 ) = zzr hi ( i , i - 1 ) = zzi do j = i , n hr ( i , j ) = hr ( i , j ) - zzr * hr ( i - 1 , j ) + zzi * hi ( i - 1 , j ) hi ( i , j ) = hi ( i , j ) - zzr * hi ( i - 1 , j ) - zzi * hr ( i - 1 , j ) end do end do ! !  Composition R*L=H. ! do j = m + 1 , en xr = hr ( j , j - 1 ) xi = hi ( j , j - 1 ) hr ( j , j - 1 ) = 0.0D+00 hi ( j , j - 1 ) = 0.0D+00 ! !  Interchange columns of HR, HI, ZR, and ZI. ! if ( wr ( j ) > 0.0D+00 ) then do i = 1 , j call r8_swap ( hr ( i , j - 1 ), hr ( i , j ) ) call r8_swap ( hi ( i , j - 1 ), hi ( i , j ) ) end do do i = low , igh call r8_swap ( zr ( i , j - 1 ), zr ( i , j ) ) call r8_swap ( zi ( i , j - 1 ), zi ( i , j ) ) end do end if do i = 1 , j hr ( i , j - 1 ) = hr ( i , j - 1 ) + xr * hr ( i , j ) - xi * hi ( i , j ) hi ( i , j - 1 ) = hi ( i , j - 1 ) + xr * hi ( i , j ) + xi * hr ( i , j ) end do ! !  Accumulate transformations. ! do i = low , igh zr ( i , j - 1 ) = zr ( i , j - 1 ) + xr * zr ( i , j ) - xi * zi ( i , j ) zi ( i , j - 1 ) = zi ( i , j - 1 ) + xr * zi ( i , j ) + xi * zr ( i , j ) end do end do go to 240 ! !  A root found. ! 660 continue hr ( en , en ) = hr ( en , en ) + tr wr ( en ) = hr ( en , en ) hi ( en , en ) = hi ( en , en ) + ti wi ( en ) = hi ( en , en ) en = enm1 go to 220 ! !  All roots found. !  Backsubstitute to find vectors of upper triangular form. ! 680 continue norm = 0.0D+00 do i = 1 , n do j = i , n tr = abs ( hr ( i , j ) ) + abs ( hi ( i , j ) ) if ( tr > norm ) norm = tr end do end do hr ( 1 , 1 ) = norm if ( n == 1 ) then return end if if ( norm == 0.0D+00 ) then return end if do nn = 2 , n en = n + 2 - nn xr = wr ( en ) xi = wi ( en ) hr ( en , en ) = 1.0D+00 hi ( en , en ) = 0.0D+00 enm1 = en - 1 do ii = 1 , enm1 i = en - ii zzr = 0.0D+00 zzi = 0.0D+00 do j = i + 1 , en zzr = zzr + hr ( i , j ) * hr ( j , en ) - hi ( i , j ) * hi ( j , en ) zzi = zzi + hr ( i , j ) * hi ( j , en ) + hi ( i , j ) * hr ( j , en ) end do yr = xr - wr ( i ) yi = xi - wi ( i ) if ( yr == 0.0D+00 . and . yi == 0.0D+00 ) then tst1 = norm yr = tst1 do yr = 0.01D+00 * yr tst2 = norm + yr if ( tst2 <= tst1 ) then exit end if end do end if call cdiv ( zzr , zzi , yr , yi , hr ( i , en ), hi ( i , en ) ) ! !  Overflow control. ! tr = abs ( hr ( i , en ) ) + abs ( hi ( i , en ) ) if ( tr /= 0.0D+00 ) then tst1 = tr tst2 = tst1 + 1.0D+00 / tst1 if ( tst2 <= tst1 ) then hr ( i : en , en ) = hr ( i : en , en ) / tr hi ( i : en , en ) = hi ( i : en , en ) / tr end if end if end do end do ! !  End backsubstitution. ! enm1 = n - 1 ! !  Vectors of isolated roots. ! do i = 1 , n - 1 if ( i < low . or . i > igh ) then zr ( i , i + 1 : n ) = hr ( i , i + 1 : n ) zi ( i , i + 1 : n ) = hi ( i , i + 1 : n ) end if end do ! !  Multiply by transformation matrix to give vectors of original full matrix. ! do jj = low , n - 1 j = n + low - jj m = min ( j , igh ) do i = low , igh zzr = 0.0D+00 zzi = 0.0D+00 do k = low , m zzr = zzr + zr ( i , k ) * hr ( k , j ) - zi ( i , k ) * hi ( k , j ) zzi = zzi + zr ( i , k ) * hi ( k , j ) + zi ( i , k ) * hr ( k , j ) end do zr ( i , j ) = zzr zi ( i , j ) = zzi end do end do return ! !  Set error: all eigenvalues have not converged after 30*N iterations. ! 1000 continue ierr = en return end subroutine comqr ( n , low , igh , hr , hi , wr , wi , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: comqr !*****************************************************************************80 ! !! COMQR gets eigenvalues of a complex upper Hessenberg matrix. ! !  Discussion: ! !    This subroutine finds the eigenvalues of a complex !    upper Hessenberg matrix by the QR method. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, integer ( kind = 4 ) LOW, IGH, are determined by the balancing routine CBAL. !    If CBAL is not used, set LOW = 1 and IGH = N. ! !    Input/output, real ( kind = 8 ) HR(N,N), HI(N,N).  On input, the real and imaginary !    parts of the complex upper Hessenberg matrix.  Their lower triangles !    below the subdiagonal contain information about the unitary !    transformations used in the reduction by CORTH, if performed.  On output, !    the upper Hessenberg portions of HR and HI have been destroyed. !    Therefore, they must be saved before calling COMQR if subsequent !    calculation of eigenvectors is to be performed. ! !    Output, real ( kind = 8 ) WR(N), WI(N), the real and imaginary parts of the !    eigenvalues.  If an error exit is made, the eigenvalues should be !    correct for indices IERR+1,...,N. ! !    Output, integer ( kind = 4 ) IERR, error flag. !    0, for normal return, !    J, if the limit of 30*N iterations is exhausted while the J-th !       eigenvalue is being sought. ! implicit none integer ( kind = 4 ) n integer ( kind = 4 ) en integer ( kind = 4 ) enm1 real ( kind = 8 ) hi ( n , n ) real ( kind = 8 ) hr ( n , n ) integer ( kind = 4 ) i integer ( kind = 4 ) ierr integer ( kind = 4 ) igh integer ( kind = 4 ) itn integer ( kind = 4 ) its integer ( kind = 4 ) j integer ( kind = 4 ) l integer ( kind = 4 ) ll integer ( kind = 4 ) low real ( kind = 8 ) norm real ( kind = 8 ) pythag real ( kind = 8 ) si real ( kind = 8 ) sr real ( kind = 8 ) ti real ( kind = 8 ) tr real ( kind = 8 ) tst1 real ( kind = 8 ) tst2 real ( kind = 8 ) wi ( n ) real ( kind = 8 ) wr ( n ) real ( kind = 8 ) xi real ( kind = 8 ) xr real ( kind = 8 ) yi real ( kind = 8 ) yr real ( kind = 8 ) zzi real ( kind = 8 ) zzr ierr = 0 ! !  Create real subdiagonal elements. ! l = low + 1 do i = l , igh ll = min ( i + 1 , igh ) if ( hi ( i , i - 1 ) /= 0.0D+00 ) then norm = pythag ( hr ( i , i - 1 ), hi ( i , i - 1 ) ) yr = hr ( i , i - 1 ) / norm yi = hi ( i , i - 1 ) / norm hr ( i , i - 1 ) = norm hi ( i , i - 1 ) = 0.0D+00 do j = i , igh si = yr * hi ( i , j ) - yi * hr ( i , j ) hr ( i , j ) = yr * hr ( i , j ) + yi * hi ( i , j ) hi ( i , j ) = si end do do j = low , ll si = yr * hi ( j , i ) + yi * hr ( j , i ) hr ( j , i ) = yr * hr ( j , i ) - yi * hi ( j , i ) hi ( j , i ) = si end do end if end do ! !  Store roots isolated by CBAL. ! do i = 1 , n if ( i < low . or . i > igh ) then wr ( i ) = hr ( i , i ) wi ( i ) = hi ( i , i ) end if end do en = igh tr = 0.0D+00 ti = 0.0D+00 itn = 30 * n ! !  Search for next eigenvalue. ! 220 continue if ( en < low ) then return end if its = 0 enm1 = en - 1 ! !  Look for single small sub-diagonal element. ! 240 continue do ll = low , en l = en + low - ll if ( l == low ) then exit end if tst1 = abs ( hr ( l - 1 , l - 1 ) ) + abs ( hi ( l - 1 , l - 1 ) ) + abs ( hr ( l , l ) ) & + abs ( hi ( l , l ) ) tst2 = tst1 + abs ( hr ( l , l - 1 ) ) if ( tst2 == tst1 ) then exit end if end do ! !  Form shift. ! if ( l == en ) then go to 660 end if if ( itn == 0 ) go to 1000 if ( its == 10 . or . its == 20 ) go to 320 sr = hr ( en , en ) si = hi ( en , en ) xr = hr ( enm1 , en ) * hr ( en , enm1 ) xi = hi ( enm1 , en ) * hr ( en , enm1 ) if ( xr == 0.0D+00 . and . xi == 0.0D+00 ) go to 340 yr = ( hr ( enm1 , enm1 ) - sr ) / 2.0D+00 yi = ( hi ( enm1 , enm1 ) - si ) / 2.0D+00 call csroot ( yr ** 2 - yi ** 2 + xr , 2.0D+00 * yr * yi + xi , zzr , zzi ) if ( yr * zzr + yi * zzi < 0.0D+00 ) then zzr = - zzr zzi = - zzi end if call cdiv ( xr , xi , yr + zzr , yi + zzi , xr , xi ) sr = sr - xr si = si - xi go to 340 ! !  Form exceptional shift. ! 320 continue sr = abs ( hr ( en , enm1 ) ) + abs ( hr ( enm1 , en - 2 ) ) si = 0.0D+00 340 continue do i = low , en hr ( i , i ) = hr ( i , i ) - sr hi ( i , i ) = hi ( i , i ) - si end do tr = tr + sr ti = ti + si its = its + 1 itn = itn - 1 ! !  Reduce to triangle (rows). ! do i = l + 1 , en sr = hr ( i , i - 1 ) hr ( i , i - 1 ) = 0.0D+00 norm = pythag ( pythag ( hr ( i - 1 , i - 1 ), hi ( i - 1 , i - 1 ) ), sr ) xr = hr ( i - 1 , i - 1 ) / norm wr ( i - 1 ) = xr xi = hi ( i - 1 , i - 1 ) / norm wi ( i - 1 ) = xi hr ( i - 1 , i - 1 ) = norm hi ( i - 1 , i - 1 ) = 0.0D+00 hi ( i , i - 1 ) = sr / norm do j = i , en yr = hr ( i - 1 , j ) yi = hi ( i - 1 , j ) zzr = hr ( i , j ) zzi = hi ( i , j ) hr ( i - 1 , j ) = xr * yr + xi * yi + hi ( i , i - 1 ) * zzr hi ( i - 1 , j ) = xr * yi - xi * yr + hi ( i , i - 1 ) * zzi hr ( i , j ) = xr * zzr - xi * zzi - hi ( i , i - 1 ) * yr hi ( i , j ) = xr * zzi + xi * zzr - hi ( i , i - 1 ) * yi end do end do si = hi ( en , en ) if ( si /= 0.0D+00 ) then norm = pythag ( hr ( en , en ), si ) sr = hr ( en , en ) / norm si = si / norm hr ( en , en ) = norm hi ( en , en ) = 0.0D+00 end if ! !  Inverse operation (columns). ! do j = l + 1 , en xr = wr ( j - 1 ) xi = wi ( j - 1 ) do i = l , j yr = hr ( i , j - 1 ) yi = 0.0D+00 zzr = hr ( i , j ) zzi = hi ( i , j ) if ( i /= j ) then yi = hi ( i , j - 1 ) hi ( i , j - 1 ) = xr * yi + xi * yr + hi ( j , j - 1 ) * zzi end if hr ( i , j - 1 ) = xr * yr - xi * yi + hi ( j , j - 1 ) * zzr hr ( i , j ) = xr * zzr + xi * zzi - hi ( j , j - 1 ) * yr hi ( i , j ) = xr * zzi - xi * zzr - hi ( j , j - 1 ) * yi end do end do if ( si /= 0.0D+00 ) then do i = l , en yr = hr ( i , en ) yi = hi ( i , en ) hr ( i , en ) = sr * yr - si * yi hi ( i , en ) = sr * yi + si * yr end do end if go to 240 ! !  A root found. ! 660 continue wr ( en ) = hr ( en , en ) + tr wi ( en ) = hi ( en , en ) + ti en = enm1 go to 220 ! !  Set error: all eigenvalues have not converged after 30*n iterations. ! 1000 continue ierr = en return end subroutine comqr2 ( n , low , igh , ortr , orti , hr , hi , wr , wi , zr , zi , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: comqr2 !*****************************************************************************80 ! !! COMQR2 gets eigenvalues/vectors of a complex upper Hessenberg matrix. ! !  Discussion: ! !    This subroutine finds the eigenvalues and eigenvectors !    of a complex upper Hessenberg matrix by the QR !    method.  The eigenvectors of a complex general matrix !    can also be found if CORTH has been used to reduce !    this general matrix to Hessenberg form. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, integer ( kind = 4 ) LOW, IGH, are determined by the balancing routine CBAL. !    If CBAL is not used, set LOW = 1 and IGH = N. ! !    Input/output, real ( kind = 8 ) ORTR(N), ORTI(N).  On input, information about the !    unitary transformations used in the reduction by CORTH, if performed. !    If the eigenvectors of the Hessenberg matrix are desired, set ORTR(J) and !    ORTI(J) to 0.0D+00 for these elements.  On output, these arrays !    have been overwritten. ! !    Input/output, real ( kind = 8 ) HR(N,N), HI(N,N).  On input, the real and imaginary !    parts of the complex upper Hessenberg matrix.  Their lower triangles !    below the subdiagonal contain further information about the !    transformations which were used in the reduction by CORTH, if performed. !    If the eigenvectors of the Hessenberg matrix are desired, these elements !    may be arbitrary. ! !    Output, real ( kind = 8 ) WR(N), WI(N), the real and imaginary parts of the !    eigenvalues.  If an error exit is made, the eigenvalues should be !    correct for indices IERR+1,...,N. ! !    Output, real ( kind = 8 ) ZR(N,N), ZI(N,N), the real and imaginary parts of the !    eigenvectors.  The eigenvectors are unnormalized.  If an error exit !    is made, none of the eigenvectors has been found. ! !    Output, integer ( kind = 4 ) IERR, error flag. !    0, for normal return, !    J, if the limit of 30*N iterations is exhausted while the J-th !      eigenvalue is being sought. ! implicit none integer ( kind = 4 ) igh integer ( kind = 4 ) n integer ( kind = 4 ) en integer ( kind = 4 ) enm1 real ( kind = 8 ) hi ( n , n ) real ( kind = 8 ) hr ( n , n ) integer ( kind = 4 ) i integer ( kind = 4 ) iend integer ( kind = 4 ) ierr integer ( kind = 4 ) ii integer ( kind = 4 ) itn integer ( kind = 4 ) its integer ( kind = 4 ) j integer ( kind = 4 ) jj integer ( kind = 4 ) k integer ( kind = 4 ) l integer ( kind = 4 ) ll integer ( kind = 4 ) low integer ( kind = 4 ) m integer ( kind = 4 ) nn real ( kind = 8 ) norm real ( kind = 8 ) orti ( igh ) real ( kind = 8 ) ortr ( igh ) real ( kind = 8 ) pythag real ( kind = 8 ) si real ( kind = 8 ) sr real ( kind = 8 ) ti real ( kind = 8 ) tr real ( kind = 8 ) tst1 real ( kind = 8 ) tst2 real ( kind = 8 ) wi ( n ) real ( kind = 8 ) wr ( n ) real ( kind = 8 ) xi real ( kind = 8 ) xr real ( kind = 8 ) yi real ( kind = 8 ) yr real ( kind = 8 ) zi ( n , n ) real ( kind = 8 ) zr ( n , n ) real ( kind = 8 ) zzi real ( kind = 8 ) zzr ierr = 0 ! !  Initialize eigenvector matrix. ! zr ( 1 : n , 1 : n ) = 0.0D+00 do i = 1 , n zr ( i , i ) = 1.0D+00 end do zi ( 1 : n , 1 : n ) = 0.0D+00 ! !  Form the matrix of accumulated transformations from the information !  left by CORTH. ! iend = igh - low - 1 if ( iend ) 180 , 150 , 105 105 continue do ii = 1 , iend i = igh - ii if ( ortr ( i ) == 0.0D+00 . and . orti ( i ) == 0.0D+00 ) go to 140 if ( hr ( i , i - 1 ) == 0.0D+00 . and . hi ( i , i - 1 ) == 0.0D+00 ) go to 140 ! !  Norm below is negative of H formed in CORTH. ! norm = hr ( i , i - 1 ) * ortr ( i ) + hi ( i , i - 1 ) * orti ( i ) do k = i + 1 , igh ortr ( k ) = hr ( k , i - 1 ) orti ( k ) = hi ( k , i - 1 ) end do do j = i , igh sr = 0.0D+00 si = 0.0D+00 do k = i , igh sr = sr + ortr ( k ) * zr ( k , j ) + orti ( k ) * zi ( k , j ) si = si + ortr ( k ) * zi ( k , j ) - orti ( k ) * zr ( k , j ) end do sr = sr / norm si = si / norm do k = i , igh zr ( k , j ) = zr ( k , j ) + sr * ortr ( k ) - si * orti ( k ) zi ( k , j ) = zi ( k , j ) + sr * orti ( k ) + si * ortr ( k ) end do end do 140 continue end do ! !  Create real subdiagonal elements. ! 150 continue l = low + 1 do i = l , igh ll = min ( i + 1 , igh ) if ( hi ( i , i - 1 ) == 0.0D+00 ) then go to 170 end if norm = pythag ( hr ( i , i - 1 ), hi ( i , i - 1 ) ) yr = hr ( i , i - 1 ) / norm yi = hi ( i , i - 1 ) / norm hr ( i , i - 1 ) = norm hi ( i , i - 1 ) = 0.0D+00 do j = i , n si = yr * hi ( i , j ) - yi * hr ( i , j ) hr ( i , j ) = yr * hr ( i , j ) + yi * hi ( i , j ) hi ( i , j ) = si end do do j = 1 , ll si = yr * hi ( j , i ) + yi * hr ( j , i ) hr ( j , i ) = yr * hr ( j , i ) - yi * hi ( j , i ) hi ( j , i ) = si end do do j = low , igh si = yr * zi ( j , i ) + yi * zr ( j , i ) zr ( j , i ) = yr * zr ( j , i ) - yi * zi ( j , i ) zi ( j , i ) = si end do 170 continue end do ! !  Store roots isolated by CBAL. ! 180 continue do i = 1 , n if ( i < low . or . i > igh ) then wr ( i ) = hr ( i , i ) wi ( i ) = hi ( i , i ) end if end do en = igh tr = 0.0D+00 ti = 0.0D+00 itn = 30 * n ! !  Search for next eigenvalue. ! 220 continue if ( en < low ) go to 680 its = 0 enm1 = en - 1 ! !  Look for single small sub-diagonal element. ! 240 continue do ll = low , en l = en + low - ll if ( l == low ) then exit end if tst1 = abs ( hr ( l - 1 , l - 1 ) ) + abs ( hi ( l - 1 , l - 1 ) ) + abs ( hr ( l , l ) ) & + abs ( hi ( l , l ) ) tst2 = tst1 + abs ( hr ( l , l - 1 ) ) if ( tst2 == tst1 ) then exit end if end do ! !  Form shift. ! if ( l == en ) go to 660 if ( itn == 0 ) go to 1000 if ( its == 10 . or . its == 20 ) go to 320 sr = hr ( en , en ) si = hi ( en , en ) xr = hr ( enm1 , en ) * hr ( en , enm1 ) xi = hi ( enm1 , en ) * hr ( en , enm1 ) if ( xr == 0.0D+00 . and . xi == 0.0D+00 ) go to 340 yr = ( hr ( enm1 , enm1 ) - sr ) / 2.0D+00 yi = ( hi ( enm1 , enm1 ) - si ) / 2.0D+00 call csroot ( yr ** 2 - yi ** 2 + xr , 2.0D+00 * yr * yi + xi , zzr , zzi ) if ( yr * zzr + yi * zzi < 0.0D+00 ) then zzr = - zzr zzi = - zzi end if call cdiv ( xr , xi , yr + zzr , yi + zzi , xr , xi ) sr = sr - xr si = si - xi go to 340 ! !  Form exceptional shift. ! 320 continue sr = abs ( hr ( en , enm1 ) ) + abs ( hr ( enm1 , en - 2 ) ) si = 0.0D+00 340 continue do i = low , en hr ( i , i ) = hr ( i , i ) - sr hi ( i , i ) = hi ( i , i ) - si end do tr = tr + sr ti = ti + si its = its + 1 itn = itn - 1 ! !  Reduce to triangle (rows). ! do i = l + 1 , en sr = hr ( i , i - 1 ) hr ( i , i - 1 ) = 0.0D+00 norm = pythag ( pythag ( hr ( i - 1 , i - 1 ), hi ( i - 1 , i - 1 ) ), sr ) xr = hr ( i - 1 , i - 1 ) / norm wr ( i - 1 ) = xr xi = hi ( i - 1 , i - 1 ) / norm wi ( i - 1 ) = xi hr ( i - 1 , i - 1 ) = norm hi ( i - 1 , i - 1 ) = 0.0D+00 hi ( i , i - 1 ) = sr / norm do j = i , n yr = hr ( i - 1 , j ) yi = hi ( i - 1 , j ) zzr = hr ( i , j ) zzi = hi ( i , j ) hr ( i - 1 , j ) = xr * yr + xi * yi + hi ( i , i - 1 ) * zzr hi ( i - 1 , j ) = xr * yi - xi * yr + hi ( i , i - 1 ) * zzi hr ( i , j ) = xr * zzr - xi * zzi - hi ( i , i - 1 ) * yr hi ( i , j ) = xr * zzi + xi * zzr - hi ( i , i - 1 ) * yi end do end do si = hi ( en , en ) if ( si /= 0.0D+00 ) then norm = pythag ( hr ( en , en ), si ) sr = hr ( en , en ) / norm si = si / norm hr ( en , en ) = norm hi ( en , en ) = 0.0D+00 do j = en + 1 , n yr = hr ( en , j ) yi = hi ( en , j ) hr ( en , j ) = sr * yr + si * yi hi ( en , j ) = sr * yi - si * yr end do end if ! !  Inverse operation (columns). ! do j = l + 1 , en xr = wr ( j - 1 ) xi = wi ( j - 1 ) do i = 1 , j yr = hr ( i , j - 1 ) yi = 0.0D+00 zzr = hr ( i , j ) zzi = hi ( i , j ) if ( i /= j ) then yi = hi ( i , j - 1 ) hi ( i , j - 1 ) = xr * yi + xi * yr + hi ( j , j - 1 ) * zzi end if hr ( i , j - 1 ) = xr * yr - xi * yi + hi ( j , j - 1 ) * zzr hr ( i , j ) = xr * zzr + xi * zzi - hi ( j , j - 1 ) * yr hi ( i , j ) = xr * zzi - xi * zzr - hi ( j , j - 1 ) * yi end do do i = low , igh yr = zr ( i , j - 1 ) yi = zi ( i , j - 1 ) zzr = zr ( i , j ) zzi = zi ( i , j ) zr ( i , j - 1 ) = xr * yr - xi * yi + hi ( j , j - 1 ) * zzr zi ( i , j - 1 ) = xr * yi + xi * yr + hi ( j , j - 1 ) * zzi zr ( i , j ) = xr * zzr + xi * zzi - hi ( j , j - 1 ) * yr zi ( i , j ) = xr * zzi - xi * zzr - hi ( j , j - 1 ) * yi end do end do if ( si /= 0.0D+00 ) then do i = 1 , en yr = hr ( i , en ) yi = hi ( i , en ) hr ( i , en ) = sr * yr - si * yi hi ( i , en ) = sr * yi + si * yr end do do i = low , igh yr = zr ( i , en ) yi = zi ( i , en ) zr ( i , en ) = sr * yr - si * yi zi ( i , en ) = sr * yi + si * yr end do end if go to 240 ! !  A root found. ! 660 continue hr ( en , en ) = hr ( en , en ) + tr wr ( en ) = hr ( en , en ) hi ( en , en ) = hi ( en , en ) + ti wi ( en ) = hi ( en , en ) en = enm1 go to 220 ! !  All roots found. !  Backsubstitute to find vectors of upper triangular form. ! 680 continue norm = 0.0D+00 do i = 1 , n do j = i , n tr = abs ( hr ( i , j ) ) + abs ( hi ( i , j ) ) norm = max ( norm , tr ) end do end do if ( n == 1 ) then return end if if ( norm == 0.0D+00 ) then return end if do nn = 2 , n en = n + 2 - nn xr = wr ( en ) xi = wi ( en ) hr ( en , en ) = 1.0D+00 hi ( en , en ) = 0.0D+00 enm1 = en - 1 do ii = 1 , enm1 i = en - ii zzr = 0.0D+00 zzi = 0.0D+00 do j = i + 1 , en zzr = zzr + hr ( i , j ) * hr ( j , en ) - hi ( i , j ) * hi ( j , en ) zzi = zzi + hr ( i , j ) * hi ( j , en ) + hi ( i , j ) * hr ( j , en ) end do yr = xr - wr ( i ) yi = xi - wi ( i ) if ( yr == 0.0D+00 . and . yi == 0.0D+00 ) then tst1 = norm yr = tst1 do yr = 0.01D+00 * yr tst2 = norm + yr if ( tst2 <= tst1 ) then exit end if end do end if call cdiv ( zzr , zzi , yr , yi , hr ( i , en ), hi ( i , en ) ) ! !  Overflow control. ! tr = abs ( hr ( i , en ) ) + abs ( hi ( i , en ) ) if ( tr /= 0.0D+00 ) then tst1 = tr tst2 = tst1 + 1.0D+00 / tst1 if ( tst2 <= tst1 ) then do j = i , en hr ( j , en ) = hr ( j , en ) / tr hi ( j , en ) = hi ( j , en ) / tr end do end if end if end do end do ! !  End backsubstitution. ! enm1 = n - 1 ! !  Vectors of isolated roots. ! do i = 1 , n - 1 if ( i < low . or . i > igh ) then do j = i + 1 , n zr ( i , j ) = hr ( i , j ) zi ( i , j ) = hi ( i , j ) end do end if end do ! !  Multiply by transformation matrix to give vectors of original full matrix. ! do jj = low , n - 1 j = n + low - jj m = min ( j , igh ) do i = low , igh zzr = 0.0D+00 zzi = 0.0D+00 do k = low , m zzr = zzr + zr ( i , k ) * hr ( k , j ) - zi ( i , k ) * hi ( k , j ) zzi = zzi + zr ( i , k ) * hi ( k , j ) + zi ( i , k ) * hr ( k , j ) end do zr ( i , j ) = zzr zi ( i , j ) = zzi end do end do return ! !  Set error: all eigenvalues have not converged after 30*n iterations. ! 1000 continue ierr = en return end subroutine cortb ( n , low , igh , ar , ai , ortr , orti , m , zr , zi ) !DEC$ ATTRIBUTES DLLEXPORT :: cortb !*****************************************************************************80 ! !! CORTB determines eigenvectors by undoing the CORTH transformation. ! !  Discussion: ! !    This subroutine forms the eigenvectors of a complex general !    matrix by back transforming those of the corresponding !    upper Hessenberg matrix determined by CORTH. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, integer ( kind = 4 ) LOW, IGH, are determined by the balancing routine CBAL. !    If CBAL is not used, set LOW = 1 and IGH to the order of the matrix. ! !    Input, real ( kind = 8 ) AR(N,IGH), AI(N,IGH), information about the unitary !    transformations used in the reduction by CORTH in their strict lower !    triangles. ! !    Input/output, real ( kind = 8 ) ORTR(IGH), ORTI(IGH).  On input, further information !    about the transformations used in the reduction by CORTH.  On output, !    ORTR and ORTI have been further altered. ! !    Input, integer ( kind = 4 ) M, the number of columns of ZR and ZI to be back !    transformed. ! !    Input/output, real ( kind = 8 ) ZR(N,M), ZI(N,M).  On input, the real and imaginary !    parts of the eigenvectors to be back transformed.  On output, the real !    and imaginary parts of the transformed eigenvectors. ! implicit none integer ( kind = 4 ) igh integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) ai ( n , igh ) real ( kind = 8 ) ar ( n , igh ) real ( kind = 8 ) gi real ( kind = 8 ) gr real ( kind = 8 ) h integer ( kind = 4 ) i integer ( kind = 4 ) j integer ( kind = 4 ) la integer ( kind = 4 ) low integer ( kind = 4 ) mm integer ( kind = 4 ) mp real ( kind = 8 ) orti ( igh ) real ( kind = 8 ) ortr ( igh ) real ( kind = 8 ) zi ( n , m ) real ( kind = 8 ) zr ( n , m ) if ( m == 0 ) then return end if la = igh - 1 if ( igh - 1 < low + 1 ) then return end if do mm = low + 1 , la mp = low + igh - mm if ( ar ( mp , mp - 1 ) /= 0.0D+00 . or . ai ( mp , mp - 1 ) /= 0.0D+00 ) then h = ar ( mp , mp - 1 ) * ortr ( mp ) + ai ( mp , mp - 1 ) * orti ( mp ) ortr ( mp + 1 : igh ) = ar ( mp + 1 : igh , mp - 1 ) orti ( mp + 1 : igh ) = ai ( mp + 1 : igh , mp - 1 ) do j = 1 , m gr = ( dot_product ( ortr ( mp : igh ), zr ( mp : igh , j ) ) & + dot_product ( orti ( mp : igh ), zi ( mp : igh , j ) ) ) / h gi = ( dot_product ( ortr ( mp : igh ), zi ( mp : igh , j ) ) & - dot_product ( orti ( mp : igh ), zr ( mp : igh , j ) ) ) / h do i = mp , igh zr ( i , j ) = zr ( i , j ) + gr * ortr ( i ) - gi * orti ( i ) zi ( i , j ) = zi ( i , j ) + gr * orti ( i ) + gi * ortr ( i ) end do end do end if end do return end subroutine corth ( n , low , igh , ar , ai , ortr , orti ) !DEC$ ATTRIBUTES DLLEXPORT :: corth !*****************************************************************************80 ! !! CORTH transforms a complex general matrix to upper Hessenberg form. ! !  Discussion: ! !    Given a complex general matrix, this subroutine !    reduces a submatrix situated in rows and columns !    LOW through IGH to upper Hessenberg form by !    unitary similarity transformations. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, integer ( kind = 4 ) LOW, IGH, are determined by the balancing routine CBAL. !    If CBAL is not used, set LOW = 1 and IGH = N. ! !    Input/output, real ( kind = 8 ) AR(N,N), AI(N,N).  On input, the real and imaginary !    parts of the complex input matrix.  On output, the real and imaginary !    parts of the Hessenberg matrix.  Information about the unitary !    transformations used in the reduction is stored in the remaining !    triangles under the Hessenberg matrix. ! !    Output, real ( kind = 8 ) ORTR(IGH), ORTI(IGH), further information about the !    transformations. ! implicit none integer ( kind = 4 ) igh integer ( kind = 4 ) n real ( kind = 8 ) ai ( n , n ) real ( kind = 8 ) ar ( n , n ) real ( kind = 8 ) f real ( kind = 8 ) fi real ( kind = 8 ) fr real ( kind = 8 ) g real ( kind = 8 ) h integer ( kind = 4 ) i integer ( kind = 4 ) ii integer ( kind = 4 ) j integer ( kind = 4 ) jj integer ( kind = 4 ) la integer ( kind = 4 ) m , mp , low real ( kind = 8 ) orti ( igh ) real ( kind = 8 ) ortr ( igh ) real ( kind = 8 ) pythag real ( kind = 8 ) scale la = igh - 1 if ( igh - 1 < low + 1 ) then return end if do m = low + 1 , la h = 0.0D+00 ortr ( m ) = 0.0D+00 orti ( m ) = 0.0D+00 scale = 0.0D+00 ! !  Scale column. ! do i = m , igh scale = scale + abs ( ar ( i , m - 1 ) ) + abs ( ai ( i , m - 1 ) ) end do if ( scale == 0.0D+00 ) then cycle end if mp = m + igh do ii = m , igh i = mp - ii ortr ( i ) = ar ( i , m - 1 ) / scale orti ( i ) = ai ( i , m - 1 ) / scale h = h + ortr ( i ) * ortr ( i ) + orti ( i ) * orti ( i ) end do g = sqrt ( h ) f = pythag ( ortr ( m ), orti ( m ) ) if ( f /= 0.0D+00 ) then h = h + f * g g = g / f ortr ( m ) = ( 1.0D+00 + g ) * ortr ( m ) orti ( m ) = ( 1.0D+00 + g ) * orti ( m ) else ortr ( m ) = g ar ( m , m - 1 ) = scale end if ! !  Form (I-(U*Ut)/h) * A. ! do j = m , n fr = 0.0D+00 fi = 0.0D+00 do ii = m , igh i = mp - ii fr = fr + ortr ( i ) * ar ( i , j ) + orti ( i ) * ai ( i , j ) fi = fi + ortr ( i ) * ai ( i , j ) - orti ( i ) * ar ( i , j ) end do fr = fr / h fi = fi / h ar ( m : igh , j ) = ar ( m : igh , j ) - fr * ortr ( m : igh ) + fi * orti ( m : igh ) ai ( m : igh , j ) = ai ( m : igh , j ) - fr * orti ( m : igh ) - fi * ortr ( m : igh ) end do ! !  Form (I-(U*Ut)/h) * A * (I-(U*Ut)/h) ! do i = 1 , igh fr = 0.0D+00 fi = 0.0D+00 do jj = m , igh j = mp - jj fr = fr + ortr ( j ) * ar ( i , j ) - orti ( j ) * ai ( i , j ) fi = fi + ortr ( j ) * ai ( i , j ) + orti ( j ) * ar ( i , j ) end do fr = fr / h fi = fi / h ar ( i , m : igh ) = ar ( i , m : igh ) - fr * ortr ( m : igh ) - fi * orti ( m : igh ) ai ( i , m : igh ) = ai ( i , m : igh ) + fr * orti ( m : igh ) - fi * ortr ( m : igh ) end do ortr ( m ) = scale * ortr ( m ) orti ( m ) = scale * orti ( m ) ar ( m , m - 1 ) = - g * ar ( m , m - 1 ) ai ( m , m - 1 ) = - g * ai ( m , m - 1 ) end do return end subroutine csroot ( xr , xi , yr , yi ) !DEC$ ATTRIBUTES DLLEXPORT :: csroot !*****************************************************************************80 ! !! CSROOT computes the complex square root of a complex quantity. ! !  Discussion: ! !    The branch of the square function is chosen so that !      YR >= 0.0D+00 !    and !      sign ( YI ) == sign ( XI ) ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, real ( kind = 8 ) XR, XI, the real and imaginary parts of the quantity !    whose square root is desired. ! !    Output, real ( kind = 8 ) YR, YI, the real and imaginary parts of the square root. ! implicit none real ( kind = 8 ) pythag real ( kind = 8 ) s real ( kind = 8 ) ti real ( kind = 8 ) tr real ( kind = 8 ) xi real ( kind = 8 ) xr real ( kind = 8 ) yi real ( kind = 8 ) yr tr = xr ti = xi s = sqrt ( 0.5D+00 * ( pythag ( tr , ti ) + abs ( tr ) ) ) if ( tr >= 0.0D+00 ) yr = s if ( ti < 0.0D+00 ) s = - s if ( tr <= 0.0D+00 ) yi = s if ( tr < 0.0D+00 ) then yr = 0.5D+00 * ( ti / yi ) else if ( tr > 0.0D+00 ) then yi = 0.5D+00 * ( ti / yr ) end if return end subroutine elmbak ( n , low , igh , a , ind , m , z ) !DEC$ ATTRIBUTES DLLEXPORT :: elmbak !*****************************************************************************80 ! !! ELMBAK determines eigenvectors by undoing the ELMHES transformation. ! !  Discussion: ! !    This subroutine forms the eigenvectors of a real general !    matrix by back transforming those of the corresponding !    upper Hessenberg matrix determined by ELMHES. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, integer ( kind = 4 ) LOW, IGH, integers determined by the balancing !    routine BALANC.  If BALANC has not been used, set LOW = 1 and !    IGH equal to the order of the matrix. ! !    Input, real ( kind = 8 ) A(N,IGH), the multipliers which were used in the !    reduction by ELMHES in its lower triangle below the subdiagonal. ! !    Input, integer ( kind = 4 ) IND(IGH), information on the rows and columns !    interchanged in the reduction by ELMHES. ! !    Input, integer ( kind = 4 ) M, the number of columns of Z to be back transformed. ! !    Input/output, real ( kind = 8 ) Z(N,M).  On input, the real and imaginary parts !    of the eigenvectors to be back transformed.  On output, the real and !    imaginary parts of the transformed eigenvectors. ! implicit none integer ( kind = 4 ) igh integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( n , igh ) integer ( kind = 4 ) i integer ( kind = 4 ) ind ( igh ) integer ( kind = 4 ) j integer ( kind = 4 ) la integer ( kind = 4 ) low integer ( kind = 4 ) mm integer ( kind = 4 ) mp real ( kind = 8 ) x real ( kind = 8 ) z ( n , m ) if ( m == 0 ) then return end if la = igh - 1 if ( la < low + 1 ) then return end if do mm = low + 1 , la mp = low + igh - mm do i = mp + 1 , igh x = a ( i , mp - 1 ) if ( x /= 0.0D+00 ) then do j = 1 , m z ( i , j ) = z ( i , j ) + x * z ( mp , j ) end do end if end do i = ind ( mp ) if ( i /= mp ) then do j = 1 , m call r8_swap ( z ( i , j ), z ( mp , j ) ) end do end if end do return end subroutine elmhes ( n , low , igh , a , ind ) !DEC$ ATTRIBUTES DLLEXPORT :: elmhes !*****************************************************************************80 ! !! ELMHES transforms a real general matrix to upper Hessenberg form. ! !  Discussion: ! !    Given a real general matrix, this subroutine reduces a submatrix !    situated in rows and columns LOW through IGH to upper Hessenberg !    form by stabilized elementary similarity transformations. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Martin and Wilkinson, !    ELMHES, !    Numerische Mathematik, !    Volume 12, pages 349-368, 1968. ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, integer ( kind = 4 ) LOW, IGH, are determined by the balancing routine !    BALANC.  If BALANC has not been used, set LOW = 1, IGH = N. ! !    Input/output, real ( kind = 8 ) A(N,N).  On input, the matrix to be reduced. !    On output, the Hessenberg matrix.  The multipliers !    which were used in the reduction are stored in the !    remaining triangle under the Hessenberg matrix. ! !    Output, integer ( kind = 4 ) IND(N), contains information on the rows and columns !    interchanged in the reduction.  Only elements LOW through IGH are used. ! implicit none integer ( kind = 4 ) igh integer ( kind = 4 ) n real ( kind = 8 ) a ( n , n ) integer ( kind = 4 ) i integer ( kind = 4 ) ind ( igh ) integer ( kind = 4 ) j integer ( kind = 4 ) la integer ( kind = 4 ) low integer ( kind = 4 ) m real ( kind = 8 ) x real ( kind = 8 ) y la = igh - 1 do m = low + 1 , la x = 0.0D+00 i = m do j = m , igh if ( abs ( a ( j , m - 1 ) ) > abs ( x ) ) then x = a ( j , m - 1 ) i = j end if end do ind ( m ) = i ! !  Interchange rows and columns of the matrix. ! if ( i /= m ) then do j = m - 1 , n call r8_swap ( a ( i , j ), a ( m , j ) ) end do do j = 1 , igh call r8_swap ( a ( j , i ), a ( j , m ) ) end do end if if ( x /= 0.0D+00 ) then do i = m + 1 , igh y = a ( i , m - 1 ) if ( y /= 0.0D+00 ) then y = y / x a ( i , m - 1 ) = y do j = m , n a ( i , j ) = a ( i , j ) - y * a ( m , j ) end do a ( 1 : igh , m ) = a ( 1 : igh , m ) + y * a ( 1 : igh , i ) end if end do end if end do return end subroutine eltran ( n , low , igh , a , ind , z ) !DEC$ ATTRIBUTES DLLEXPORT :: eltran !*****************************************************************************80 ! !! ELTRAN accumulates similarity transformations used by ELMHES. ! !  Discussion: ! !    This subroutine accumulates the stabilized elementary !    similarity transformations used in the reduction of a !    real general matrix to upper Hessenberg form by ELMHES. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Peters and WIlkinson, !    ELMTRANS, !    Numerische Mathematik, !    Volume 16, pages 181-204, 1970. ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, integer ( kind = 4 ) LOW, IGH, are determined by the balancing routine !    BALANC.  If BALANC has not been used, set LOW = 1, IGH = N. ! !    Input, real ( kind = 8 ) A(N,IGH), the multipliers which were used in the !    reduction by ELMHES in its lower triangle below the subdiagonal. ! !    Input, integer ( kind = 4 ) IND(IGH), information on the rows and columns !    interchanged in the reduction by ELMHES. ! !    Output, real ( kind = 8 ) Z(N,N), the transformation matrix produced in the !    reduction by ELMHES. ! implicit none integer ( kind = 4 ) igh integer ( kind = 4 ) n real ( kind = 8 ) a ( n , igh ) integer ( kind = 4 ) i integer ( kind = 4 ) ind ( igh ) !  integer ( kind = 4 ) j integer ( kind = 4 ) kl integer ( kind = 4 ) low integer ( kind = 4 ) mm integer ( kind = 4 ) mp real ( kind = 8 ) z ( n , n ) ! !  Initialize Z to the identity matrix. ! z ( 1 : n , 1 : n ) = 0.0D+00 do i = 1 , n z ( i , i ) = 1.0D+00 end do kl = igh - low - 1 if ( kl < 1 ) then return end if do mm = 1 , kl mp = igh - mm do i = mp + 1 , igh z ( i , mp ) = a ( i , mp - 1 ) end do i = ind ( mp ) if ( i /= mp ) then z ( mp , mp : igh ) = z ( i , mp : igh ) z ( i , mp ) = 1.0D+00 z ( i , mp + 1 : igh ) = 0.0D+00 end if end do return end subroutine figi ( n , t , d , e , e2 , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: figi !*****************************************************************************80 ! !! FIGI transforms a real nonsymmetric tridiagonal matrix to symmetric form. ! !  Discussion: ! !    Given a nonsymmetric tridiagonal matrix such that the products !    of corresponding pairs of off-diagonal elements are all !    non-negative, this subroutine reduces it to a symmetric !    tridiagonal matrix with the same eigenvalues.  If, further, !    a zero product only occurs when both factors are zero, !    the reduced matrix is similar to the original matrix. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, real ( kind = 8 ) T(N,3) contains the input matrix.  Its subdiagonal is !    stored in the last N-1 positions of the first column, its diagonal in !    the N positions of the second column, and its superdiagonal in the !    first N-1 positions of the third column.  T(1,1) and T(N,3) are arbitrary. ! !    Output, real ( kind = 8 ) D(N), the diagonal elements of the symmetric matrix. ! !    Output, real ( kind = 8 ) E(N), contains the subdiagonal elements of the symmetric !    matrix in E(2:N).  E(1) is not set. ! !    Output, real ( kind = 8 ) E2(N), the squares of the corresponding elements of E. !    E2 may coincide with E if the squares are not needed. ! !    Output, integer ( kind = 4 ) IERR, error flag. !    0, for normal return, !    N+I, if T(I,1) * T(I-1,3) is negative, !    -(3*N+I), if T(I,1) * T(I-1,3) is zero with one factor non-zero.  In !      this case, the eigenvectors of the symmetric matrix are not simply !      related to those of T and should not be sought. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) d ( n ) real ( kind = 8 ) e ( n ) real ( kind = 8 ) e2 ( n ) integer ( kind = 4 ) i integer ( kind = 4 ) ierr real ( kind = 8 ) t ( n , 3 ) ierr = 0 do i = 1 , n if ( i >= 1 ) then e2 ( i ) = t ( i , 1 ) * t ( i - 1 , 3 ) if ( e2 ( i ) < 0.0D+00 ) then ierr = n + i return else if ( e2 ( i ) == 0.0D+00 ) then if ( t ( i , 1 ) /= 0.0D+00 . or . t ( i - 1 , 3 ) /= 0.0D+00 ) then ierr = - 3 * n - i return end if e ( i ) = 0.0D+00 else e ( i ) = sqrt ( e2 ( i ) ) end if end if d ( i ) = t ( i , 2 ) end do return end subroutine figi2 ( n , t , d , e , z , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: figi2 !*****************************************************************************80 ! !! FIGI2 transforms a real nonsymmetric tridiagonal matrix to symmetric form. ! !  Discussion: ! !    Given a nonsymmetric tridiagonal matrix such that the products !    of corresponding pairs of off-diagonal elements are all !    non-negative, and zero only when both factors are zero, this !    subroutine reduces it to a symmetric tridiagonal matrix !    using and accumulating diagonal similarity transformations. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, real ( kind = 8 ) T(N,3) contains the input matrix.  Its subdiagonal is !    stored in the last N-1 positions of the first column, its diagonal in !    the N positions of the second column, and its superdiagonal in the !    first N-1 positions of the third column.  T(1,1) and T(N,3) are arbitrary. ! !    Output, real ( kind = 8 ) D(N), the diagonal elements of the symmetric matrix. ! !    Output, real ( kind = 8 ) E(N), contains the subdiagonal elements of the symmetric !    matrix in E(2:N).  E(1) is not set. ! !    Output, real ( kind = 8 ) Z(N,N), contains the transformation matrix produced in !    the reduction. ! !    Output, integer ( kind = 4 ) IERR, error flag. !    0, for normal return, !    N+I, if T(I,1) * T(I-1,3) is negative, !    2*N+I, if T(I,1) * T(I-1,3) is zero with one factor non-zero. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) d ( n ) real ( kind = 8 ) e ( n ) real ( kind = 8 ) h integer ( kind = 4 ) i integer ( kind = 4 ) ierr !  integer ( kind = 4 ) j real ( kind = 8 ) t ( n , 3 ) real ( kind = 8 ) z ( n , n ) ierr = 0 do i = 1 , n z ( i , 1 : n ) = 0.0D+00 if ( i == 1 ) then z ( i , i ) = 1.0D+00 else h = t ( i , 1 ) * t ( i - 1 , 3 ) if ( h < 0.0D+00 ) then ierr = n + i return else if ( h == 0 ) then if ( t ( i , 1 ) /= 0.0D+00 . or . t ( i - 1 , 3 ) /= 0.0D+00 ) then ierr = 2 * n + i return end if e ( i ) = 0.0D+00 z ( i , i ) = 1.0D+00 else e ( i ) = sqrt ( h ) z ( i , i ) = z ( i - 1 , i - 1 ) * e ( i ) / t ( i - 1 , 3 ) end if end if d ( i ) = t ( i , 2 ) end do return end subroutine hqr ( n , low , igh , h , wr , wi , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: hqr !*****************************************************************************80 ! !! HQR computes all eigenvalues of a real upper Hessenberg matrix. ! !  Discussion: ! !    This subroutine finds the eigenvalues of a real !    upper Hessenberg matrix by the QR method. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Martin, Peters, and Wilkinson, !    HQR, !    Numerische Mathematik, !    Volume 14, pages 219-231, 1970. ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, integer ( kind = 4 ) LOW, IGH, two integers determined by the routine !    BALANC.  If BALANC is not used, set LOW=1, IGH=N. ! !    Input/output, real ( kind = 8 ) H(N,N), the N by N upper Hessenberg matrix. !    Information about the transformations used in the reduction to !    Hessenberg form by ELMHES or ORTHES, if performed, is stored !    in the remaining triangle under the Hessenberg matrix. !    On output, the information in H has been destroyed. ! !    Output, real ( kind = 8 ) WR(N), WI(N), the real and imaginary parts of the !    eigenvalues.  The eigenvalues are unordered, except that complex !    conjugate pairs of values appear consecutively, with the eigenvalue !    having positive imaginary part listed first.  If an error exit !    occurred, then the eigenvalues should be correct for indices !    IERR+1 through N. ! !    Output, integer ( kind = 4 ) IERR, error flag. !    0, no error. !    J, the limit of 30*N iterations was reached while searching for !      the J-th eigenvalue. ! implicit none integer ( kind = 4 ) n integer ( kind = 4 ) en integer ( kind = 4 ) enm2 real ( kind = 8 ) h ( n , n ) integer ( kind = 4 ) i integer ( kind = 4 ) ierr integer ( kind = 4 ) igh integer ( kind = 4 ) itn integer ( kind = 4 ) its integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) l integer ( kind = 4 ) ll integer ( kind = 4 ) low integer ( kind = 4 ) m integer ( kind = 4 ) mm integer ( kind = 4 ) na real ( kind = 8 ) norm logical notlas real ( kind = 8 ) p real ( kind = 8 ) q real ( kind = 8 ) r real ( kind = 8 ) s real ( kind = 8 ) t real ( kind = 8 ) tst1 real ( kind = 8 ) tst2 real ( kind = 8 ) w real ( kind = 8 ) wi ( n ) real ( kind = 8 ) wr ( n ) real ( kind = 8 ) x real ( kind = 8 ) y real ( kind = 8 ) zz ierr = 0 norm = 0.0D+00 k = 1 ! !  Store roots isolated by BALANC and compute matrix norm. ! do i = 1 , n do j = k , n norm = norm + abs ( h ( i , j ) ) end do k = i if ( i < low . or . i > igh ) then wr ( i ) = h ( i , i ) wi ( i ) = 0.0D+00 end if end do en = igh t = 0.0D+00 itn = 30 * n ! !  Search for next eigenvalues. ! 60 continue if ( en < low ) then return end if its = 0 na = en - 1 enm2 = na - 1 ! !  Look for a single small sub-diagonal element. ! 70 continue do ll = low , en l = en + low - ll if ( l == low ) then exit end if s = abs ( h ( l - 1 , l - 1 ) ) + abs ( h ( l , l ) ) if ( s == 0.0D+00 ) then s = norm end if tst1 = s tst2 = tst1 + abs ( h ( l , l - 1 ) ) if ( tst2 == tst1 ) then exit end if end do ! !  Form shift. ! x = h ( en , en ) if ( l == en ) then go to 270 end if y = h ( na , na ) w = h ( en , na ) * h ( na , en ) if ( l == na ) then go to 280 end if if ( itn == 0 ) then ierr = en return end if ! !  Form an exceptional shift. ! if ( its == 10 . or . its == 20 ) then t = t + x do i = low , en h ( i , i ) = h ( i , i ) - x end do s = abs ( h ( en , na ) ) + abs ( h ( na , enm2 ) ) x = 0.75D+00 * s y = x w = - 0.4375D+00 * s * s end if its = its + 1 itn = itn - 1 ! !  Look for two consecutive small sub-diagonal elements. ! do mm = l , enm2 m = enm2 + l - mm zz = h ( m , m ) r = x - zz s = y - zz p = ( r * s - w ) / h ( m + 1 , m ) + h ( m , m + 1 ) q = h ( m + 1 , m + 1 ) - zz - r - s r = h ( m + 2 , m + 1 ) s = abs ( p ) + abs ( q ) + abs ( r ) p = p / s q = q / s r = r / s if ( m == l ) then exit end if tst1 = abs ( p ) * ( abs ( h ( m - 1 , m - 1 ) ) + abs ( zz ) + abs ( h ( m + 1 , m + 1 ) ) ) tst2 = tst1 + abs ( h ( m , m - 1 ) ) * ( abs ( q ) + abs ( r ) ) if ( tst2 == tst1 ) then exit end if end do do i = m + 2 , en h ( i , i - 2 ) = 0.0D+00 if ( i /= m + 2 ) then h ( i , i - 3 ) = 0.0D+00 end if end do ! !  Double QR step involving rows l to EN and columns M to EN. ! do k = m , na notlas = k /= na if ( k /= m ) then p = h ( k , k - 1 ) q = h ( k + 1 , k - 1 ) if ( notlas ) then r = h ( k + 2 , k - 1 ) else r = 0.0D+00 end if x = abs ( p ) + abs ( q ) + abs ( r ) if ( x == 0.0D+00 ) then cycle end if p = p / x q = q / x r = r / x end if s = sign ( sqrt ( p ** 2 + q ** 2 + r ** 2 ), p ) if ( k /= m ) then h ( k , k - 1 ) = - s * x else if ( l /= m ) then h ( k , k - 1 ) = - h ( k , k - 1 ) end if p = p + s x = p / s y = q / s zz = r / s q = q / p r = r / p if ( . not . notlas ) then ! !  Row modification. ! do j = k , n p = h ( k , j ) + q * h ( k + 1 , j ) h ( k , j ) = h ( k , j ) - p * x h ( k + 1 , j ) = h ( k + 1 , j ) - p * y end do j = min ( en , k + 3 ) ! !  Column modification. ! do i = 1 , j p = x * h ( i , k ) + y * h ( i , k + 1 ) h ( i , k ) = h ( i , k ) - p h ( i , k + 1 ) = h ( i , k + 1 ) - p * q end do else ! !  Row modification. ! do j = k , n p = h ( k , j ) + q * h ( k + 1 , j ) + r * h ( k + 2 , j ) h ( k , j ) = h ( k , j ) - p * x h ( k + 1 , j ) = h ( k + 1 , j ) - p * y h ( k + 2 , j ) = h ( k + 2 , j ) - p * zz end do j = min ( en , k + 3 ) ! !  Column modification. ! do i = 1 , j p = x * h ( i , k ) + y * h ( i , k + 1 ) + zz * h ( i , k + 2 ) h ( i , k ) = h ( i , k ) - p h ( i , k + 1 ) = h ( i , k + 1 ) - p * q h ( i , k + 2 ) = h ( i , k + 2 ) - p * r end do end if end do go to 70 ! !  One root found. ! 270 continue wr ( en ) = x + t wi ( en ) = 0.0D+00 en = na go to 60 ! !  Two roots found. ! 280 continue p = ( y - x ) / 2.0D+00 q = p * p + w zz = sqrt ( abs ( q ) ) x = x + t ! !  Real root, or complex pair. ! if ( q >= 0.0D+00 ) then zz = p + sign ( zz , p ) wr ( na ) = x + zz if ( zz == 0.0D+00 ) then wr ( en ) = wr ( na ) else wr ( en ) = x - w / zz end if wi ( na ) = 0.0D+00 wi ( en ) = 0.0D+00 else wr ( na ) = x + p wr ( en ) = x + p wi ( na ) = zz wi ( en ) = - zz end if en = enm2 go to 60 end subroutine hqr2 ( n , low , igh , h , wr , wi , z , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: hqr2 !*****************************************************************************80 ! !! HQR2 computes eigenvalues and eigenvectors of a real upper Hessenberg matrix. ! !  Discussion: ! !    This subroutine finds the eigenvalues and eigenvectors !    of a real upper Hessenberg matrix by the qr method.  the !    eigenvectors of a real general matrix can also be found !    if ELMHES and ELTRAN or ORTHES and ORTRAN have !    been used to reduce this general matrix to Hessenberg form !    and to accumulate the similarity transformations. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, integer ( kind = 4 ) LOW, IGH, determined by the balancing routine BALANC. !    If BALANC has not been used, set LOW = 1, IGH = N. ! !    Input/output, real ( kind = 8 ) H(N,N), the N by N upper Hessenberg matrix. !    On output, the information in H has been destroyed. ! !    Output, real ( kind = 8 ) WR(N), WI(N), the real and imaginary parts of the !    eigenvalues.  The eigenvalues are unordered, except that complex !    conjugate pairs of values appear consecutively, with the eigenvalue !    having positive imaginary part listed first.  If an error exit !    occurred, then the eigenvalues should be correct for indices !    IERR+1 through N. ! !    Input/output, real ( kind = 8 ) Z(N,N).  On input, the transformation matrix !    produced by ELTRAN after the reduction by ELMHES, or by ORTRAN after the !    reduction by ORTHES, if performed.  If the eigenvectors of the Hessenberg !    matrix are desired, Z must contain the identity matrix.  On output, !    Z contains the real and imaginary parts of the eigenvectors. !    If the I-th eigenvalue is real, the I-th column of Z contains its !    eigenvector.  If the I-th eigenvalue is complex with positive imaginary !    part, the I-th and (I+1)-th columns of Z contain the real and imaginary !    parts of its eigenvector.  The eigenvectors are unnormalized.  If an !    error exit is made, none of the eigenvectors has been found. ! !    Output, integer ( kind = 4 ) IERR, error flag. !    0, for normal return, !    J, if the limit of 30*N iterations is exhausted while the J-th !      eigenvalue is being sought. ! implicit none integer ( kind = 4 ) n integer ( kind = 4 ) en integer ( kind = 4 ) enm2 real ( kind = 8 ) h ( n , n ) !  real    ( kind = 8 ) hnorm integer ( kind = 4 ) i integer ( kind = 4 ) ierr integer ( kind = 4 ) igh integer ( kind = 4 ) ii integer ( kind = 4 ) itn integer ( kind = 4 ) its integer ( kind = 4 ) j integer ( kind = 4 ) jj integer ( kind = 4 ) k integer ( kind = 4 ) l integer ( kind = 4 ) ll integer ( kind = 4 ) low integer ( kind = 4 ) m integer ( kind = 4 ) mm integer ( kind = 4 ) na integer ( kind = 4 ) nn real ( kind = 8 ) norm logical notlas real ( kind = 8 ) p real ( kind = 8 ) q real ( kind = 8 ) r real ( kind = 8 ) ra real ( kind = 8 ) s real ( kind = 8 ) sa real ( kind = 8 ) t !  real    ( kind = 8 ) temp real ( kind = 8 ) tst1 real ( kind = 8 ) tst2 real ( kind = 8 ) vi real ( kind = 8 ) vr real ( kind = 8 ) w real ( kind = 8 ) wi ( n ) real ( kind = 8 ) wr ( n ) real ( kind = 8 ) x real ( kind = 8 ) y real ( kind = 8 ) z ( n , n ) real ( kind = 8 ) zz ierr = 0 norm = 0.0D+00 k = 1 ! !  Store roots isolated by BALANC and compute the matrix norm. ! do i = 1 , n do j = k , n norm = norm + abs ( h ( i , j ) ) end do k = i if ( i < low . or . i > igh ) then wr ( i ) = h ( i , i ) wi ( i ) = 0.0D+00 end if end do en = igh t = 0.0D+00 itn = 30 * n ! !  Search for next eigenvalues. ! 60 continue if ( en < low ) then go to 340 end if its = 0 na = en - 1 enm2 = na - 1 ! !  Look for single small sub-diagonal element. ! 70 continue do ll = low , en l = en + low - ll if ( l == low ) then exit end if s = abs ( h ( l - 1 , l - 1 ) ) + abs ( h ( l , l ) ) if ( s == 0.0D+00 ) then s = norm end if tst1 = s tst2 = tst1 + abs ( h ( l , l - 1 ) ) if ( tst2 == tst1 ) then exit end if end do ! !  Form shift. ! x = h ( en , en ) if ( l == en ) then go to 270 end if y = h ( na , na ) w = h ( en , na ) * h ( na , en ) if ( l == na ) then go to 280 end if if ( itn == 0 ) then ierr = en return end if ! !  Form exceptional shift. ! if ( its == 10 . or . its == 20 ) then t = t + x do i = low , en h ( i , i ) = h ( i , i ) - x end do s = abs ( h ( en , na ) ) + abs ( h ( na , enm2 ) ) x = 0.75D+00 * s y = x w = - 0.4375D+00 * s * s end if its = its + 1 itn = itn - 1 ! !  Look for two consecutive small sub-diagonal elements. ! do mm = l , enm2 m = enm2 + l - mm zz = h ( m , m ) r = x - zz s = y - zz p = ( r * s - w ) / h ( m + 1 , m ) + h ( m , m + 1 ) q = h ( m + 1 , m + 1 ) - zz - r - s r = h ( m + 2 , m + 1 ) s = abs ( p ) + abs ( q ) + abs ( r ) p = p / s q = q / s r = r / s if ( m == l ) then exit end if tst1 = abs ( p ) * ( abs ( h ( m - 1 , m - 1 ) ) + abs ( zz ) + abs ( h ( m + 1 , m + 1 ) ) ) tst2 = tst1 + abs ( h ( m , m - 1 ) ) * ( abs ( q ) + abs ( r ) ) if ( tst2 == tst1 ) then exit end if end do do i = m + 2 , en h ( i , i - 2 ) = 0.0D+00 if ( i /= m + 2 ) then h ( i , i - 3 ) = 0.0D+00 end if end do ! !  Double QR step involving rows L to EN and columns M to EN. ! do k = m , na notlas = k /= na if ( k /= m ) then p = h ( k , k - 1 ) q = h ( k + 1 , k - 1 ) r = 0.0D+00 if ( notlas ) then r = h ( k + 2 , k - 1 ) end if x = abs ( p ) + abs ( q ) + abs ( r ) if ( x == 0.0D+00 ) then cycle end if p = p / x q = q / x r = r / x end if s = sign ( sqrt ( p ** 2 + q ** 2 + r ** 2 ), p ) if ( k /= m ) then h ( k , k - 1 ) = - s * x else if ( l /= m ) then h ( k , k - 1 ) = - h ( k , k - 1 ) end if p = p + s x = p / s y = q / s zz = r / s q = q / p r = r / p if ( notlas ) go to 225 ! !  Row modification. ! do j = k , n p = h ( k , j ) + q * h ( k + 1 , j ) h ( k , j ) = h ( k , j ) - p * x h ( k + 1 , j ) = h ( k + 1 , j ) - p * y end do j = min ( en , k + 3 ) ! !  Column modification. ! do i = 1 , j p = x * h ( i , k ) + y * h ( i , k + 1 ) h ( i , k ) = h ( i , k ) - p h ( i , k + 1 ) = h ( i , k + 1 ) - p * q end do ! !  Accumulate transformations. ! do i = low , igh p = x * z ( i , k ) + y * z ( i , k + 1 ) z ( i , k ) = z ( i , k ) - p z ( i , k + 1 ) = z ( i , k + 1 ) - p * q end do go to 255 225 continue ! !  Row modification. ! do j = k , n p = h ( k , j ) + q * h ( k + 1 , j ) + r * h ( k + 2 , j ) h ( k , j ) = h ( k , j ) - p * x h ( k + 1 , j ) = h ( k + 1 , j ) - p * y h ( k + 2 , j ) = h ( k + 2 , j ) - p * zz end do j = min ( en , k + 3 ) ! !  Column modification. ! do i = 1 , j p = x * h ( i , k ) + y * h ( i , k + 1 ) + zz * h ( i , k + 2 ) h ( i , k ) = h ( i , k ) - p h ( i , k + 1 ) = h ( i , k + 1 ) - p * q h ( i , k + 2 ) = h ( i , k + 2 ) - p * r end do ! !  Accumulate transformations. ! do i = low , igh p = x * z ( i , k ) + y * z ( i , k + 1 ) + zz * z ( i , k + 2 ) z ( i , k ) = z ( i , k ) - p z ( i , k + 1 ) = z ( i , k + 1 ) - p * q z ( i , k + 2 ) = z ( i , k + 2 ) - p * r end do 255 continue 260 continue end do go to 70 ! !  One root found. ! 270 continue h ( en , en ) = x + t wr ( en ) = h ( en , en ) wi ( en ) = 0.0D+00 en = na go to 60 ! !  Two roots found. ! 280 continue p = ( y - x ) / 2.0D+00 q = p * p + w zz = sqrt ( abs ( q ) ) h ( en , en ) = x + t x = h ( en , en ) h ( na , na ) = y + t if ( q < 0.0D+00 ) go to 320 ! !  Real pair. ! zz = p + sign ( zz , p ) wr ( na ) = x + zz wr ( en ) = wr ( na ) if ( zz /= 0.0D+00 ) then wr ( en ) = x - w / zz end if wi ( na ) = 0.0D+00 wi ( en ) = 0.0D+00 x = h ( en , na ) s = abs ( x ) + abs ( zz ) p = x / s q = zz / s r = sqrt ( p ** 2 + q ** 2 ) p = p / r q = q / r ! !  Row modification. ! do j = na , n zz = h ( na , j ) h ( na , j ) = q * zz + p * h ( en , j ) h ( en , j ) = q * h ( en , j ) - p * zz end do ! !  Column modification. ! do i = 1 , en zz = h ( i , na ) h ( i , na ) = q * zz + p * h ( i , en ) h ( i , en ) = q * h ( i , en ) - p * zz end do ! !  Accumulate transformations. ! do i = low , igh zz = z ( i , na ) z ( i , na ) = q * zz + p * z ( i , en ) z ( i , en ) = q * z ( i , en ) - p * zz end do go to 330 ! !  Complex pair ! 320 continue wr ( na ) = x + p wr ( en ) = x + p wi ( na ) = zz wi ( en ) = - zz 330 continue en = enm2 go to 60 ! !  All roots found. !  Backsubstitute to find vectors of upper triangular form. ! 340 continue if ( norm == 0.0D+00 ) then return end if do nn = 1 , n en = n + 1 - nn p = wr ( en ) q = wi ( en ) na = en - 1 if ( q ) 710 , 600 , 800 ! !  Real vector ! 600 continue m = en h ( en , en ) = 1.0D+00 if ( na == 0 ) go to 800 do ii = 1 , na i = en - ii w = h ( i , i ) - p r = dot_product ( h ( i , m : en ), h ( m : en , en ) ) if ( wi ( i ) < 0.0D+00 ) then zz = w s = r go to 700 end if m = i if ( wi ( i ) /= 0.0D+00 ) go to 640 t = w if ( t == 0.0D+00 ) then tst1 = norm t = tst1 do t = 0.01D+00 * t tst2 = norm + t if ( tst2 <= tst1 ) then exit end if end do end if h ( i , en ) = - r / t go to 680 ! !  Solve real equations. ! 640 continue x = h ( i , i + 1 ) y = h ( i + 1 , i ) q = ( wr ( i ) - p ) * ( wr ( i ) - p ) + wi ( i ) * wi ( i ) t = ( x * s - zz * r ) / q h ( i , en ) = t if ( abs ( x ) > abs ( zz ) ) then h ( i + 1 , en ) = ( - r - w * t ) / x else h ( i + 1 , en ) = ( - s - y * t ) / zz end if ! !  Overflow control. ! 680 continue t = abs ( h ( i , en ) ) if ( t /= 0.0D+00 ) then tst1 = t tst2 = tst1 + 1.0D+00 / tst1 if ( tst2 <= tst1 ) then h ( i : en , en ) = h ( i : en , en ) / t end if end if 700 continue end do ! !  End real vector ! go to 800 ! !  Complex vector ! 710 continue m = na ! !  Last vector component chosen imaginary, so that the eigenvector !  matrix is triangular. ! if ( abs ( h ( en , na ) ) > abs ( h ( na , en ) ) ) then h ( na , na ) = q / h ( en , na ) h ( na , en ) = - ( h ( en , en ) - p ) / h ( en , na ) else call cdiv ( 0.0D+00 , - h ( na , en ), h ( na , na ) - p , q , h ( na , na ), h ( na , en ) ) end if h ( en , na ) = 0.0D+00 h ( en , en ) = 1.0D+00 enm2 = na - 1 do ii = 1 , enm2 i = na - ii w = h ( i , i ) - p ra = dot_product ( h ( i , m : en ), h ( m : en , na ) ) sa = dot_product ( h ( i , m : en ), h ( m : en , en ) ) if ( wi ( i ) < 0.0D+00 ) then zz = w r = ra s = sa end if m = i if ( wi ( i ) == 0.0D+00 ) then call cdiv ( - ra , - sa , w , q , h ( i , na ), h ( i , en ) ) go to 790 end if ! !  Solve complex equations. ! x = h ( i , i + 1 ) y = h ( i + 1 , i ) vr = ( wr ( i ) - p ) * ( wr ( i ) - p ) + wi ( i ) * wi ( i ) - q * q vi = ( wr ( i ) - p ) * 2.0D+00 * q if ( vr == 0.0D+00 . and . vi == 0.0D+00 ) then tst1 = norm * ( abs ( w ) + abs ( q ) + abs ( x ) & + abs ( y ) + abs ( zz ) ) vr = tst1 do vr = 0.01D+00 * vr tst2 = tst1 + vr if ( tst2 <= tst1 ) then exit end if end do end if call cdiv ( x * r - zz * ra + q * sa , x * s - zz * sa - q * ra , vr , vi , h ( i , na ), h ( i , en ) ) if ( abs ( x ) > abs ( zz ) + abs ( q ) ) then h ( i + 1 , na ) = ( - ra - w * h ( i , na ) + q * h ( i , en ) ) / x h ( i + 1 , en ) = ( - sa - w * h ( i , en ) - q * h ( i , na ) ) / x else call cdiv ( - r - y * h ( i , na ), - s - y * h ( i , en ), zz , q , h ( i + 1 , na ), h ( i + 1 , en ) ) end if ! !  Overflow control. ! 790 continue t = max ( abs ( h ( i , na ) ), abs ( h ( i , en ) ) ) if ( t /= 0.0D+00 ) then tst1 = t tst2 = tst1 + 1.0D+00 / tst1 if ( tst2 <= tst1 ) then h ( i : en , na ) = h ( i : en , na ) / t h ( i : en , en ) = h ( i : en , en ) / t end if end if 795 continue end do ! !  End complex vector. ! 800 continue end do ! !  End back substitution. ! !  Vectors of isolated roots. ! do i = 1 , n if ( i < low . or . i > igh ) then z ( i , i : n ) = h ( i , i : n ) end if end do ! !  Multiply by transformation matrix to give vectors of original full matrix. ! do jj = low , n j = n + low - jj m = min ( j , igh ) do i = low , igh z ( i , j ) = dot_product ( z ( i , low : m ), h ( low : m , j ) ) end do end do return end subroutine htrib3 ( n , a , tau , m , zr , zi ) !DEC$ ATTRIBUTES DLLEXPORT :: htrib3 !*****************************************************************************80 ! !! HTRIB3 determines eigenvectors by undoing the HTRID3 transformation. ! !  Discussion: ! !    This subroutine forms the eigenvectors of a complex hermitian !    matrix by back transforming those of the corresponding !    real symmetric tridiagonal matrix determined by HTRID3. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, is the order of the matrix. ! !    Input, real ( kind = 8 ) A(N,N), contains information about the unitary !    transformations used in the reduction by HTRID3. ! !    Input, real ( kind = 8 ) TAU(2,N), contains further information about the !    transformations. ! !    Input, integer ( kind = 4 ) M, the number of eigenvectors to be back transformed. ! !    Input/output, real ( kind = 8 ) ZR(N,M), ZI(N,M).  On input, ZR contains the !    eigenvectors to be back transformed.  On output, ZR and ZI contain !    the real and imaginary parts of the transformed eigenvectors. ! implicit none integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( n , n ) real ( kind = 8 ) h integer ( kind = 4 ) i integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) l real ( kind = 8 ) s real ( kind = 8 ) si real ( kind = 8 ) tau ( 2 , n ) real ( kind = 8 ) zi ( n , m ) real ( kind = 8 ) zr ( n , m ) if ( m == 0 ) then return end if ! !  Transform the eigenvectors of the real symmetric tridiagonal matrix !  to those of the hermitian tridiagonal matrix. ! do k = 1 , n do j = 1 , m zi ( k , j ) = - zr ( k , j ) * tau ( 2 , k ) zr ( k , j ) = zr ( k , j ) * tau ( 1 , k ) end do end do ! !  Recover and apply the Householder matrices. ! do i = 2 , n l = i - 1 h = a ( i , i ) if ( h /= 0.0D+00 ) then do j = 1 , m s = 0.0D+00 si = 0.0D+00 do k = 1 , l s = s + a ( i , k ) * zr ( k , j ) - a ( k , i ) * zi ( k , j ) si = si + a ( i , k ) * zi ( k , j ) + a ( k , i ) * zr ( k , j ) end do s = ( s / h ) / h si = ( si / h ) / h zr ( 1 : l , j ) = zr ( 1 : l , j ) - s * a ( i , 1 : l ) - si * a ( 1 : l , i ) zi ( 1 : l , j ) = zi ( 1 : l , j ) - si * a ( i , 1 : l ) + s * a ( 1 : l , i ) end do end if end do return end subroutine htribk ( n , ar , ai , tau , m , zr , zi ) !DEC$ ATTRIBUTES DLLEXPORT :: htribk !*****************************************************************************80 ! !! HTRIBK determines eigenvectors by undoing the HTRIDI transformation. ! !  Discussion: ! !    This subroutine forms the eigenvectors of a complex hermitian !    matrix by back transforming those of the corresponding !    real symmetric tridiagonal matrix determined by HTRIDI. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, real ( kind = 8 ) AR(N,N), AI(N,N), contain information about !    the unitary transformations used in the reduction by HTRIDI in their !    full lower triangles, except for the diagonal of AR. ! !    Input, real ( kind = 8 ) TAU(2,N), contains further information about the !    transformations. ! !    Input, integer ( kind = 4 ) M, the number of eigenvectors to be back transformed. ! !    Input/output, real ( kind = 8 ) ZR(N,M), ZI(N,M).  On input, ZR contains the !    eigenvectors to be back transformed.  On output, ZR and ZI contain !    the real and imaginary parts of the transformed eigenvectors. ! implicit none integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) ai ( n , n ) real ( kind = 8 ) ar ( n , n ) real ( kind = 8 ) h integer ( kind = 4 ) i integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) l real ( kind = 8 ) s real ( kind = 8 ) si real ( kind = 8 ) tau ( 2 , n ) real ( kind = 8 ) zi ( n , m ) real ( kind = 8 ) zr ( n , m ) if ( m == 0 ) then return end if ! !  Transform the eigenvectors of the real symmetric tridiagonal matrix to !  those of the hermitian tridiagonal matrix. ! do k = 1 , n do j = 1 , m zi ( k , j ) = - zr ( k , j ) * tau ( 2 , k ) zr ( k , j ) = zr ( k , j ) * tau ( 1 , k ) end do end do ! !  Recover and apply the Householder matrices. ! do i = 2 , n l = i - 1 h = ai ( i , i ) if ( h /= 0.0D+00 ) then do j = 1 , m s = 0.0D+00 si = 0.0D+00 do k = 1 , l s = s + ar ( i , k ) * zr ( k , j ) - ai ( i , k ) * zi ( k , j ) si = si + ar ( i , k ) * zi ( k , j ) + ai ( i , k ) * zr ( k , j ) end do s = ( s / h ) / h si = ( si / h ) / h zr ( 1 : l , j ) = zr ( 1 : l , j ) - s * ar ( i , 1 : l ) - si * ai ( i , 1 : l ) zi ( 1 : l , j ) = zi ( 1 : l , j ) - si * ar ( i , 1 : l ) + s * ai ( i , 1 : l ) end do end if end do return end subroutine htrid3 ( n , a , d , e , e2 , tau ) !DEC$ ATTRIBUTES DLLEXPORT :: htrid3 !*****************************************************************************80 ! !! HTRID3 tridiagonalizes a complex hermitian packed matrix. ! !  Discussion: ! !    This subroutine reduces a complex hermitian matrix, stored as !    a single square array, to a real symmetric tridiagonal matrix !    using unitary similarity transformations. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input/output, real ( kind = 8 ) A(N,N).  On input, the lower triangle of the complex !    hermitian input matrix.  The real parts of the matrix elements are stored !    in the full lower triangle of A, and the imaginary parts are stored in !    the transposed positions of the strict upper triangle of A.  No storage !    is required for the zero imaginary parts of the diagonal elements. !    On output, A contains information about the unitary transformations !    used in the reduction. ! !    Output, real ( kind = 8 ) D(N), the diagonal elements of the the tridiagonal matrix. ! !    Output, real ( kind = 8 ) E(N), the subdiagonal elements of the tridiagonal !    matrix in E(2:N).  E(1) is set to zero. ! !    Output, real ( kind = 8 ) E2(N), the squares of the corresponding elements of E. !    E2 may coincide with E if the squares are not needed. ! !    Output, real ( kind = 8 ) TAU(2,N), contains further information about the !    transformations. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) a ( n , n ) real ( kind = 8 ) d ( n ) real ( kind = 8 ) e ( n ) real ( kind = 8 ) e2 ( n ) real ( kind = 8 ) f real ( kind = 8 ) fi real ( kind = 8 ) g real ( kind = 8 ) gi real ( kind = 8 ) h real ( kind = 8 ) hh integer ( kind = 4 ) i integer ( kind = 4 ) ii integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) l real ( kind = 8 ) pythag real ( kind = 8 ) scale real ( kind = 8 ) si real ( kind = 8 ) tau ( 2 , n ) tau ( 1 , n ) = 1.0D+00 tau ( 2 , n ) = 0.0D+00 do ii = 1 , n i = n + 1 - ii l = i - 1 h = 0.0D+00 scale = 0.0D+00 if ( l < 1 ) then e ( i ) = 0.0D+00 e2 ( i ) = 0.0D+00 go to 290 end if ! !  Scale row. ! do k = 1 , l scale = scale + abs ( a ( i , k ) ) + abs ( a ( k , i ) ) end do if ( scale == 0.0D+00 ) then tau ( 1 , l ) = 1.0D+00 tau ( 2 , l ) = 0.0D+00 e ( i ) = 0.0D+00 e2 ( i ) = 0.0D+00 go to 290 end if do k = 1 , l a ( i , k ) = a ( i , k ) / scale a ( k , i ) = a ( k , i ) / scale h = h + a ( i , k ) * a ( i , k ) + a ( k , i ) * a ( k , i ) end do e2 ( i ) = scale * scale * h g = sqrt ( h ) e ( i ) = scale * g f = pythag ( a ( i , l ), a ( l , i ) ) ! !  Form next diagonal element of matrix T. ! if ( f /= 0.0D+00 ) then tau ( 1 , l ) = ( a ( l , i ) * tau ( 2 , i ) - a ( i , l ) * tau ( 1 , i ) ) / f si = ( a ( i , l ) * tau ( 2 , i ) + a ( l , i ) * tau ( 1 , i ) ) / f h = h + f * g g = 1.0D+00 + g / f a ( i , l ) = g * a ( i , l ) a ( l , i ) = g * a ( l , i ) if ( l == 1 ) go to 270 else tau ( 1 , l ) = - tau ( 1 , i ) si = tau ( 2 , i ) a ( i , l ) = g end if f = 0.0D+00 do j = 1 , l g = 0.0D+00 gi = 0.0D+00 ! !  Form element of A*U. ! do k = 1 , j - 1 g = g + a ( j , k ) * a ( i , k ) + a ( k , j ) * a ( k , i ) gi = gi - a ( j , k ) * a ( k , i ) + a ( k , j ) * a ( i , k ) end do g = g + a ( j , j ) * a ( i , j ) gi = gi - a ( j , j ) * a ( j , i ) do k = j + 1 , l g = g + a ( k , j ) * a ( i , k ) - a ( j , k ) * a ( k , i ) gi = gi - a ( k , j ) * a ( k , i ) - a ( j , k ) * a ( i , k ) end do ! !  Form element of P. ! e ( j ) = g / h tau ( 2 , j ) = gi / h f = f + e ( j ) * a ( i , j ) - tau ( 2 , j ) * a ( j , i ) end do hh = f / ( h + h ) ! !  Form reduced A. ! do j = 1 , l f = a ( i , j ) g = e ( j ) - hh * f e ( j ) = g fi = - a ( j , i ) gi = tau ( 2 , j ) - hh * fi tau ( 2 , j ) = - gi a ( j , j ) = a ( j , j ) - 2.0D+00 * ( f * g + fi * gi ) do k = 1 , j - 1 a ( j , k ) = a ( j , k ) - f * e ( k ) - g * a ( i , k ) + fi * tau ( 2 , k ) + gi * a ( k , i ) a ( k , j ) = a ( k , j ) - f * tau ( 2 , k ) - g * a ( k , i ) - fi * e ( k ) - gi * a ( i , k ) end do end do 270 continue a ( i , 1 : l ) = scale * a ( i , 1 : l ) a ( 1 : l , i ) = scale * a ( 1 : l , i ) tau ( 2 , l ) = - si 290 continue d ( i ) = a ( i , i ) a ( i , i ) = scale * sqrt ( h ) end do return end subroutine htridi ( n , ar , ai , d , e , e2 , tau ) !DEC$ ATTRIBUTES DLLEXPORT :: htridi !*****************************************************************************80 ! !! HTRIDI tridiagonalizes a complex hermitian matrix. ! !  Discussion: ! !    This subroutine reduces a complex hermitian matrix to a real symmetric !    tridiagonal matrix using unitary similarity transformations. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input/output, real ( kind = 8 ) AR(N,N), AI(N,N).  On input, the real !    and imaginary parts, respectively, of the complex hermitian input matrix. !    Only the lower triangle of the matrix need be supplied. !    On output, information about the unitary transformations used in the !    reduction in their full lower triangles.  Their strict upper triangles !    and the diagonal of AR are unaltered. ! !    Output, real ( kind = 8 ) D(N), the diagonal elements of the the tridiagonal matrix. ! !    Output, real ( kind = 8 ) E(N), the subdiagonal elements of the tridiagonal !    matrix in its last N-1 positions.  E(1) is set to zero. ! !    Output, real ( kind = 8 ) E2(N), the squares of the corresponding elements of E. !    E2 may coincide with E if the squares are not needed. ! !    Output, real ( kind = 8 ) TAU(2,N), contains further information about the !    transformations. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) ai ( n , n ) real ( kind = 8 ) ar ( n , n ) real ( kind = 8 ) d ( n ) real ( kind = 8 ) e ( n ) real ( kind = 8 ) e2 ( n ) real ( kind = 8 ) f real ( kind = 8 ) fi real ( kind = 8 ) g real ( kind = 8 ) gi real ( kind = 8 ) h real ( kind = 8 ) hh integer ( kind = 4 ) i integer ( kind = 4 ) ii integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) l real ( kind = 8 ) pythag real ( kind = 8 ) scale real ( kind = 8 ) si real ( kind = 8 ) tau ( 2 , n ) tau ( 1 , n ) = 1.0D+00 tau ( 2 , n ) = 0.0D+00 do i = 1 , n d ( i ) = ar ( i , i ) end do do ii = 1 , n i = n + 1 - ii l = i - 1 h = 0.0D+00 scale = 0.0D+00 if ( l < 1 ) then e ( i ) = 0.0D+00 e2 ( i ) = 0.0D+00 go to 290 end if ! !  Scale row. ! do k = 1 , l scale = scale + abs ( ar ( i , k ) ) + abs ( ai ( i , k ) ) end do if ( scale == 0.0D+00 ) then tau ( 1 , l ) = 1.0D+00 tau ( 2 , l ) = 0.0D+00 e ( i ) = 0.0D+00 e2 ( i ) = 0.0D+00 go to 290 end if ar ( i , 1 : l ) = ar ( i , 1 : l ) / scale ai ( i , 1 : l ) = ai ( i , 1 : l ) / scale do k = 1 , l h = h + ar ( i , k ) * ar ( i , k ) + ai ( i , k ) * ai ( i , k ) end do e2 ( i ) = scale * scale * h g = sqrt ( h ) e ( i ) = scale * g f = pythag ( ar ( i , l ), ai ( i , l ) ) ! !  Form next diagonal element of matrix T. ! if ( f /= 0.0D+00 ) then tau ( 1 , l ) = ( ai ( i , l ) * tau ( 2 , i ) - ar ( i , l ) * tau ( 1 , i ) ) / f si = ( ar ( i , l ) * tau ( 2 , i ) + ai ( i , l ) * tau ( 1 , i ) ) / f h = h + f * g g = 1.0D+00 + g / f ar ( i , l ) = g * ar ( i , l ) ai ( i , l ) = g * ai ( i , l ) if ( l == 1 ) go to 270 else tau ( 1 , l ) = - tau ( 1 , i ) si = tau ( 2 , i ) ar ( i , l ) = g end if f = 0.0D+00 do j = 1 , l g = 0.0D+00 gi = 0.0D+00 ! !  Form element of A*U. ! do k = 1 , j g = g + ar ( j , k ) * ar ( i , k ) + ai ( j , k ) * ai ( i , k ) gi = gi - ar ( j , k ) * ai ( i , k ) + ai ( j , k ) * ar ( i , k ) end do do k = j + 1 , l g = g + ar ( k , j ) * ar ( i , k ) - ai ( k , j ) * ai ( i , k ) gi = gi - ar ( k , j ) * ai ( i , k ) - ai ( k , j ) * ar ( i , k ) end do ! !  Form element of P. ! e ( j ) = g / h tau ( 2 , j ) = gi / h f = f + e ( j ) * ar ( i , j ) - tau ( 2 , j ) * ai ( i , j ) end do hh = f / ( h + h ) ! !  Form the reduced A. ! do j = 1 , l f = ar ( i , j ) g = e ( j ) - hh * f e ( j ) = g fi = - ai ( i , j ) gi = tau ( 2 , j ) - hh * fi tau ( 2 , j ) = - gi do k = 1 , j ar ( j , k ) = ar ( j , k ) - f * e ( k ) - g * ar ( i , k ) + fi * tau ( 2 , k ) & + gi * ai ( i , k ) ai ( j , k ) = ai ( j , k ) - f * tau ( 2 , k ) - g * ai ( i , k ) - fi * e ( k ) & - gi * ar ( i , k ) end do end do 270 continue ar ( i , 1 : l ) = scale * ar ( i , 1 : l ) ai ( i , 1 : l ) = scale * ai ( i , 1 : l ) tau ( 2 , l ) = - si 290 continue hh = d ( i ) d ( i ) = ar ( i , i ) ar ( i , i ) = hh ai ( i , i ) = scale * sqrt ( h ) end do return end subroutine imtql1 ( n , d , e , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: imtql1 !*****************************************************************************80 ! !! IMTQL1 computes all eigenvalues of a symmetric tridiagonal matrix. ! !  Discussion: ! !    This subroutine finds the eigenvalues of a symmetric !    tridiagonal matrix by the implicit QL method. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input/output, real ( kind = 8 ) D(N).  On input, the diagonal elements of !    the matrix.  On output, the eigenvalues in ascending order.  If an error !    exit is made, the eigenvalues are correct and ordered for indices !    1,2,...IERR-1, but may not be the smallest eigenvalues. ! !    Input/output, real ( kind = 8 ) E(N).  On input, the subdiagonal elements !    of the matrix in its last N-1 positions.  E(1) is arbitrary.  On output, !    E has been overwritten. ! !    Output, integer ( kind = 4 ) IERR, error flag. !    0, normal return, !    J, if the J-th eigenvalue has not been determined after 30 iterations. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) b real ( kind = 8 ) c real ( kind = 8 ) d ( n ) real ( kind = 8 ) e ( n ) real ( kind = 8 ) f real ( kind = 8 ) g integer ( kind = 4 ) i integer ( kind = 4 ) ierr integer ( kind = 4 ) ii integer ( kind = 4 ) j integer ( kind = 4 ) l integer ( kind = 4 ) m integer ( kind = 4 ) mml real ( kind = 8 ) p real ( kind = 8 ) pythag real ( kind = 8 ) r real ( kind = 8 ) s real ( kind = 8 ) tst1 real ( kind = 8 ) tst2 ierr = 0 if ( n == 1 ) then return end if do i = 2 , n e ( i - 1 ) = e ( i ) end do e ( n ) = 0.0D+00 do l = 1 , n j = 0 ! !  Look for a small sub-diagonal element. ! 105 continue do m = l , n if ( m == n ) then exit end if tst1 = abs ( d ( m ) ) + abs ( d ( m + 1 ) ) tst2 = tst1 + abs ( e ( m ) ) if ( tst2 == tst1 ) then exit end if end do p = d ( l ) if ( m == l ) then go to 215 end if if ( 30 <= j ) then ierr = l return end if j = j + 1 ! !  Form shift. ! g = ( d ( l + 1 ) - p ) / ( 2.0D+00 * e ( l ) ) r = pythag ( g , 1.0D+00 ) g = d ( m ) - p + e ( l ) / ( g + sign ( r , g ) ) s = 1.0D+00 c = 1.0D+00 p = 0.0D+00 mml = m - l do ii = 1 , mml i = m - ii f = s * e ( i ) b = c * e ( i ) r = pythag ( f , g ) e ( i + 1 ) = r ! !  Recover from underflow. ! if ( r == 0.0D+00 ) then d ( i + 1 ) = d ( i + 1 ) - p e ( m ) = 0.0D+00 go to 105 end if s = f / r c = g / r g = d ( i + 1 ) - p r = ( d ( i ) - g ) * s + 2.0D+00 * c * b p = s * r d ( i + 1 ) = g + p g = c * r - b end do d ( l ) = d ( l ) - p e ( l ) = g e ( m ) = 0.0D+00 go to 105 ! !  Order the eigenvalues. ! 215 continue do ii = 2 , l i = l + 2 - ii if ( d ( i - 1 ) <= p ) then go to 270 end if d ( i ) = d ( i - 1 ) end do i = 1 270 continue d ( i ) = p end do return end subroutine imtql2 ( n , d , e , z , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: imtql2 !*****************************************************************************80 ! !! IMTQL2 computes all eigenvalues/vectors of a symmetric tridiagonal matrix. ! !  Discussion: ! !    This subroutine finds the eigenvalues and eigenvectors !    of a symmetric tridiagonal matrix by the implicit QL method. !    The eigenvectors of a full symmetric matrix can also !    be found if TRED2 has been used to reduce this !    full matrix to tridiagonal form. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input/output, real ( kind = 8 ) D(N).  On input, the diagonal elements of !    the input matrix.  On output, the eigenvalues in ascending order.  If an !    error exit is made, the eigenvalues are correct but !    unordered for indices 1,2,...,IERR-1. ! !    Input/output, real ( kind = 8 ) E(N).  On input, the subdiagonal elements !    of the input matrix in E(2:N).  E(1) is arbitrary.  On output, E is !    overwritten. ! !    Input/output, real ( kind = 8 ) Z(N,N).  On input, the transformation !    matrix produced in the reduction by TRED2, if performed.  If the !    eigenvectors of the tridiagonal matrix are desired, Z must contain the !    identity matrix.  On output, Z contains orthonormal eigenvectors of the !    symmetric tridiagonal (or full) matrix.  If an error exit is made, Z !    contains the eigenvectors associated with the stored eigenvalues. ! !    Output, integer ( kind = 4 ) IERR, error flag. !    0, for normal return, !    J, if the J-th eigenvalue has not been determined after 30 iterations. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) b real ( kind = 8 ) c real ( kind = 8 ) d ( n ) real ( kind = 8 ) e ( n ) real ( kind = 8 ) f real ( kind = 8 ) g integer ( kind = 4 ) i integer ( kind = 4 ) ierr integer ( kind = 4 ) ii integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) l integer ( kind = 4 ) m integer ( kind = 4 ) mml real ( kind = 8 ) p real ( kind = 8 ) pythag real ( kind = 8 ) r real ( kind = 8 ) s real ( kind = 8 ) t ( n ) real ( kind = 8 ) tst1 real ( kind = 8 ) tst2 real ( kind = 8 ) z ( n , n ) ierr = 0 if ( n == 1 ) then return end if do i = 2 , n e ( i - 1 ) = e ( i ) end do e ( n ) = 0.0D+00 do l = 1 , n j = 0 ! !  Look for a small sub-diagonal element. ! 105 continue do m = l , n if ( m == n ) then exit end if tst1 = abs ( d ( m ) ) + abs ( d ( m + 1 ) ) tst2 = tst1 + abs ( e ( m ) ) if ( tst2 == tst1 ) then exit end if end do p = d ( l ) if ( m == l ) then cycle end if if ( 30 <= j ) then ierr = l return end if j = j + 1 ! !  Form shift. ! g = ( d ( l + 1 ) - p ) / ( 2.0D+00 * e ( l ) ) r = pythag ( g , 1.0D+00 ) g = d ( m ) - p + e ( l ) / ( g + sign ( r , g ) ) s = 1.0D+00 c = 1.0D+00 p = 0.0D+00 mml = m - l do ii = 1 , mml i = m - ii f = s * e ( i ) b = c * e ( i ) r = pythag ( f , g ) e ( i + 1 ) = r ! !  Recover from underflow. ! if ( r == 0.0D+00 ) then d ( i + 1 ) = d ( i + 1 ) - p e ( m ) = 0.0D+00 go to 105 end if s = f / r c = g / r g = d ( i + 1 ) - p r = ( d ( i ) - g ) * s + 2.0D+00 * c * b p = s * r d ( i + 1 ) = g + p g = c * r - b ! !  Form vector. ! do k = 1 , n f = z ( k , i + 1 ) z ( k , i + 1 ) = s * z ( k , i ) + c * f z ( k , i ) = c * z ( k , i ) - s * f end do end do d ( l ) = d ( l ) - p e ( l ) = g e ( m ) = 0.0D+00 go to 105 end do ! !  Order eigenvalues and eigenvectors. ! do ii = 2 , n i = ii - 1 k = i p = d ( i ) do j = ii , n if ( d ( j ) < p ) then k = j p = d ( j ) end if end do if ( k /= i ) then d ( k ) = d ( i ) d ( i ) = p t ( 1 : n ) = z ( 1 : n , i ) z ( 1 : n , i ) = z ( 1 : n , k ) z ( 1 : n , k ) = t ( 1 : n ) end if end do return end subroutine imtqlv ( n , d , e , e2 , w , ind , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: imtqlv !*****************************************************************************80 ! !! IMTQLV computes all eigenvalues of a real symmetric tridiagonal matrix. ! !  Discussion: ! !    This subroutine finds the eigenvalues of a symmetric tridiagonal !    matrix by the implicit QL method and associates with them !    their corresponding submatrix indices. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, real ( kind = 8 ) D(N), the diagonal elements of the input matrix. ! !    Input, real ( kind = 8 ) E(N), the subdiagonal elements of the input matrix !    in E(2:N).  E(1) is arbitrary. ! !    Input/output, real ( kind = 8 ) E2(N).  On input, the squares of the corresponding !    elements of E.  E2(1) is arbitrary.  On output, elements of E2 !    corresponding to elements of E regarded as negligible have been !    replaced by zero, causing the matrix to split into a direct sum of !    submatrices.  E2(1) is also set to zero. ! !    Output, real ( kind = 8 ) W(N), the eigenvalues in ascending order.  If an !    error exit is made, the eigenvalues are correct and ordered for !    indices 1,2,...IERR-1, but may not be the smallest eigenvalues. ! !    Output, integer ( kind = 4 ) IND(N), the submatrix indices associated with the !    corresponding eigenvalues in W: 1 for eigenvalues belonging to the !    first submatrix from the top, 2 for those belonging to the second !    submatrix, and so on. ! !    Output, integer ( kind = 4 ) IERR, error flag. !    0, for normal return, !    J, if the J-th eigenvalue has not been determined after 30 iterations. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) b real ( kind = 8 ) c real ( kind = 8 ) d ( n ) real ( kind = 8 ) e ( n ) real ( kind = 8 ) e2 ( n ) real ( kind = 8 ) f real ( kind = 8 ) g integer ( kind = 4 ) i integer ( kind = 4 ) ierr integer ( kind = 4 ) ii integer ( kind = 4 ) ind ( n ) integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) l integer ( kind = 4 ) m integer ( kind = 4 ) mml real ( kind = 8 ) p real ( kind = 8 ) pythag real ( kind = 8 ) r real ( kind = 8 ) rv1 ( n ) real ( kind = 8 ) s integer ( kind = 4 ) tag real ( kind = 8 ) tst1 real ( kind = 8 ) tst2 real ( kind = 8 ) w ( n ) ierr = 0 k = 0 tag = 0 w ( 1 : n ) = d ( 1 : n ) e2 ( 1 ) = 0.0D+00 rv1 ( 1 : n - 1 ) = e ( 2 : n ) rv1 ( n ) = 0.0D+00 do l = 1 , n j = 0 ! !  Look for a small sub-diagonal element. ! 105 continue do m = l , n if ( m == n ) then exit end if tst1 = abs ( w ( m ) ) + abs ( w ( m + 1 ) ) tst2 = tst1 + abs ( rv1 ( m ) ) if ( tst2 == tst1 ) then exit end if ! !  Guard against underflowed element of E2. ! if ( e2 ( m + 1 ) == 0.0D+00 ) go to 125 end do 120 continue if ( m <= k ) go to 130 if ( m /= n ) e2 ( m + 1 ) = 0.0D+00 125 continue k = m tag = tag + 1 130 continue p = w ( l ) if ( m == l ) go to 215 if ( j >= 30 ) then ierr = l return end if j = j + 1 ! !  Form shift. ! g = ( w ( l + 1 ) - p ) / ( 2.0D+00 * rv1 ( l ) ) r = pythag ( g , 1.0D+00 ) g = w ( m ) - p + rv1 ( l ) / ( g + sign ( r , g ) ) s = 1.0D+00 c = 1.0D+00 p = 0.0D+00 mml = m - l do ii = 1 , mml i = m - ii f = s * rv1 ( i ) b = c * rv1 ( i ) r = pythag ( f , g ) rv1 ( i + 1 ) = r if ( r == 0.0D+00 ) go to 210 s = f / r c = g / r g = w ( i + 1 ) - p r = ( w ( i ) - g ) * s + 2.0D+00 * c * b p = s * r w ( i + 1 ) = g + p g = c * r - b end do w ( l ) = w ( l ) - p rv1 ( l ) = g rv1 ( m ) = 0.0D+00 go to 105 ! !  Recover from underflow. ! 210 continue w ( i + 1 ) = w ( i + 1 ) - p rv1 ( m ) = 0.0D+00 go to 105 ! !  Order the eigenvalues. ! 215 continue do ii = 2 , l i = l + 2 - ii if ( p >= w ( i - 1 ) ) go to 270 w ( i ) = w ( i - 1 ) ind ( i ) = ind ( i - 1 ) end do i = 1 270 continue w ( i ) = p ind ( i ) = tag end do return end subroutine invit ( n , a , wr , wi , select , mm , m , z , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: invit !*****************************************************************************80 ! !! INVIT computes eigenvectors given eigenvalues, for a real upper Hessenberg matrix. ! !  Discussion: ! !    This subroutine finds those eigenvectors of a real upper Hessenberg !    matrix corresponding to specified eigenvalues, using inverse iteration. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, real ( kind = 8 ) A(N,N), the Hessenberg matrix. ! !    Input/output, real ( kind = 8 ) WR(N), WI(N).  On input, the real and imaginary !    parts, respectively, of the eigenvalues of the matrix.  The eigenvalues !    must be stored in a manner identical to that of subroutine HQR, !    which recognizes possible splitting of the matrix.  On output, !    WR may have been altered since close eigenvalues are perturbed !    slightly in searching for independent eigenvectors. ! !    Input/output, logical SELECT(N).  On input, specifies the eigenvectors !    to be found.  The eigenvector corresponding to the J-th eigenvalue is !    specified by setting SELECT(J) to TRUE.  On output, SELECT may have been !    altered.  If the elements corresponding to a pair of conjugate complex !    eigenvalues were each initially set to TRUE, the program resets the !    second of the two elements to FALSE. ! !    Input, integer ( kind = 4 ) MM, an upper bound for the number of columns required !    to store the eigenvectors to be found.  Note that two columns are !    required to store the eigenvector corresponding to a complex eigenvalue. ! !    Input, integer ( kind = 4 ) M, the number of columns actually used to store !    the eigenvectors. ! !    Output, real ( kind = 8 ) Z(N,MM), the real and imaginary parts of the eigenvectors. !    If the next selected eigenvalue is real, the next column !    of Z contains its eigenvector.  If the eigenvalue is complex, the next !    two columns of Z contain the real and imaginary parts of its eigenvector. !    The eigenvectors are normalized so that the component of largest !    magnitude is 1.  Any vector which fails the acceptance test is set to zero. ! !    Output, integer ( kind = 4 ) IERR, error flag. !    0, for normal return, !    -(2*N+1), if more than MM columns of Z are necessary to store the !      eigenvectors corresponding to the specified eigenvalues. !    -K, if the iteration corresponding to the K-th value fails, !    -(N+K), if both error situations occur. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) a ( n , n ) real ( kind = 8 ) eps3 real ( kind = 8 ) growto integer ( kind = 4 ) i integer ( kind = 4 ) ierr integer ( kind = 4 ) ii real ( kind = 8 ) ilambd integer ( kind = 4 ) ip integer ( kind = 4 ) its integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) km1 integer ( kind = 4 ) l integer ( kind = 4 ) m integer ( kind = 4 ) mm integer ( kind = 4 ) mp integer ( kind = 4 ) n1 real ( kind = 8 ) norm real ( kind = 8 ) normv integer ( kind = 4 ) ns real ( kind = 8 ) pythag real ( kind = 8 ) rlambd real ( kind = 8 ) rm1 ( n , n ) real ( kind = 8 ) rv1 ( n ) real ( kind = 8 ) rv2 ( n ) integer ( kind = 4 ) s logical select ( n ) real ( kind = 8 ) t integer ( kind = 4 ) uk real ( kind = 8 ) ukroot real ( kind = 8 ) w real ( kind = 8 ) wi ( n ) real ( kind = 8 ) wr ( n ) real ( kind = 8 ) x real ( kind = 8 ) y real ( kind = 8 ) z ( n , mm ) ierr = 0 uk = 0 s = 1 ! !  The value of IP is: ! !   0, real eigenvalue; !   1, first of conjugate complex pair; !  -1, second of conjugate complex pair. ! ip = 0 n1 = n - 1 do k = 1 , n if ( wi ( k ) /= 0.0D+00 . and . ip >= 0 ) then ip = 1 if ( select ( k ) . and . select ( k + 1 ) ) select ( k + 1 ) = . false . end if if ( . not . select ( k ) ) go to 960 if ( wi ( k ) /= 0.0D+00 ) then s = s + 1 end if if ( s > mm ) go to 1000 if ( uk >= k ) go to 200 ! !  Check for possible splitting. ! do uk = k , n if ( uk == n ) then exit end if if ( a ( uk + 1 , uk ) == 0.0D+00 ) then exit end if end do ! !  Compute infinity norm of leading UK by UK (Hessenberg) matrix. ! norm = 0.0D+00 mp = 1 do i = 1 , uk x = sum ( abs ( a ( i , mp : uk ) ) ) norm = max ( norm , x ) mp = i end do ! !  EPS3 replaces zero pivot in decomposition and close roots are modified !  by EPS3. ! if ( norm == 0.0D+00 ) then norm = 1.0D+00 end if eps3 = abs ( norm ) * epsilon ( eps3 ) ! !  GROWTO is the criterion for the growth. ! ukroot = uk ukroot = sqrt ( ukroot ) growto = 0.1D+00 / ukroot 200 continue rlambd = wr ( k ) ilambd = wi ( k ) if ( k == 1 ) go to 280 km1 = k - 1 go to 240 ! !  Perturb eigenvalue if it is close to any previous eigenvalue. ! 220 continue rlambd = rlambd + eps3 240 continue do ii = 1 , km1 i = k - ii if ( select ( i ) . and . abs ( wr ( i ) - rlambd ) < eps3 . and . & abs ( wi ( i ) - ilambd ) < eps3 ) then go to 220 end if end do wr ( k ) = rlambd ! !  Perturb conjugate eigenvalue to match. ! wr ( k + ip ) = rlambd ! !  Form upper Hessenberg A - rlambd*I (transposed) and initial real vector. ! 280 continue mp = 1 do i = 1 , uk rm1 ( mp : uk , i ) = a ( i , mp : uk ) rm1 ( i , i ) = rm1 ( i , i ) - rlambd mp = i rv1 ( i ) = eps3 end do its = 0 if ( ilambd /= 0.0D+00 ) go to 520 ! !  Real eigenvalue. ! !  Triangular decomposition with interchanges, replacing zero pivots by eps3. ! do i = 2 , uk mp = i - 1 if ( abs ( rm1 ( mp , i ) ) > abs ( rm1 ( mp , mp ) ) ) then do j = mp , uk call r8_swap ( rm1 ( j , i ), rm1 ( j , mp ) ) end do end if if ( rm1 ( mp , mp ) == 0.0D+00 ) then rm1 ( mp , mp ) = eps3 end if x = rm1 ( mp , i ) / rm1 ( mp , mp ) if ( x /= 0.0D+00 ) then rm1 ( i : uk , i ) = rm1 ( i : uk , i ) - x * rm1 ( i : uk , mp ) end if end do if ( rm1 ( uk , uk ) == 0.0D+00 ) then rm1 ( uk , uk ) = eps3 end if ! !  Back substitution for real vector. ! 440 continue do ii = 1 , uk i = uk + 1 - ii y = rv1 ( i ) do j = i + 1 , uk y = y - rm1 ( j , i ) * rv1 ( j ) end do rv1 ( i ) = y / rm1 ( i , i ) end do go to 740 ! !  Complex eigenvalue. ! !  Triangular decomposition with interchanges, !  replacing zero pivots by EPS3. !  Store imaginary parts in upper triangle starting at (1,3) ! 520 continue ns = n - s z ( 1 , s - 1 ) = - ilambd z ( 1 , s ) = 0.0D+00 if ( n /= 2 ) then rm1 ( 1 , 3 ) = - ilambd z ( 1 , s - 1 ) = 0.0D+00 rm1 ( 1 , 4 : n ) = 0.0D+00 end if do i = 2 , uk mp = i - 1 w = rm1 ( mp , i ) if ( i < n ) then t = rm1 ( mp , i + 1 ) else if ( i == n ) then t = z ( mp , s - 1 ) end if x = rm1 ( mp , mp ) * rm1 ( mp , mp ) + t * t if ( w * w <= x ) go to 580 x = rm1 ( mp , mp ) / w y = t / w rm1 ( mp , mp ) = w if ( i < n ) then rm1 ( mp , i + 1 ) = 0.0D+00 else if ( i == n ) then z ( mp , s - 1 ) = 0.0D+00 end if do j = i , uk w = rm1 ( j , i ) rm1 ( j , i ) = rm1 ( j , mp ) - x * w rm1 ( j , mp ) = w if ( j >= n1 ) then l = j - ns z ( i , l ) = z ( mp , l ) - y * w z ( mp , l ) = 0.0D+00 else rm1 ( i , j + 2 ) = rm1 ( mp , j + 2 ) - y * w rm1 ( mp , j + 2 ) = 0.0D+00 end if end do rm1 ( i , i ) = rm1 ( i , i ) - y * ilambd if ( i >= n1 ) then l = i - ns z ( mp , l ) = - ilambd z ( i , l ) = z ( i , l ) + x * ilambd else rm1 ( mp , i + 2 ) = - ilambd rm1 ( i , i + 2 ) = rm1 ( i , i + 2 ) + x * ilambd end if go to 640 580 continue if ( x == 0.0D+00 ) then rm1 ( mp , mp ) = eps3 if ( i < n ) then rm1 ( mp , i + 1 ) = 0.0D+00 else if ( i == n ) then z ( mp , s - 1 ) = 0.0D+00 end if t = 0.0D+00 x = eps3 ** 2 end if w = w / x x = rm1 ( mp , mp ) * w y = - t * w do j = i , uk if ( j >= n1 ) then l = j - ns t = z ( mp , l ) z ( i , l ) = - x * t - y * rm1 ( j , mp ) else t = rm1 ( mp , j + 2 ) rm1 ( i , j + 2 ) = - x * t - y * rm1 ( j , mp ) end if rm1 ( j , i ) = rm1 ( j , i ) - x * rm1 ( j , mp ) + y * t end do if ( i >= n1 ) then l = i - ns z ( i , l ) = z ( i , l ) - ilambd else rm1 ( i , i + 2 ) = rm1 ( i , i + 2 ) - ilambd end if 640 continue end do if ( uk >= n1 ) then l = uk - ns t = z ( uk , l ) else t = rm1 ( uk , uk + 2 ) end if if ( rm1 ( uk , uk ) == 0.0D+00 . and . t == 0.0D+00 ) then rm1 ( uk , uk ) = eps3 end if ! !  Back substitution for complex vector. ! 660 continue do ii = 1 , uk i = uk + 1 - ii x = rv1 ( i ) y = 0.0D+00 do j = i + 1 , uk if ( j >= n1 ) then t = z ( i , j - ns ) else t = rm1 ( i , j + 2 ) end if x = x - rm1 ( j , i ) * rv1 ( j ) + t * rv2 ( j ) y = y - rm1 ( j , i ) * rv2 ( j ) - t * rv1 ( j ) end do if ( i >= n1 ) then t = z ( i , i - ns ) else t = rm1 ( i , i + 2 ) end if call cdiv ( x , y , rm1 ( i , i ), t , rv1 ( i ), rv2 ( i ) ) end do ! !  Acceptance test for real or complex eigenvector and normalization. ! 740 continue its = its + 1 norm = 0.0D+00 normv = 0.0D+00 do i = 1 , uk if ( ilambd == 0.0D+00 ) then x = abs ( rv1 ( i ) ) else x = pythag ( rv1 ( i ), rv2 ( i ) ) end if if ( normv < x ) then normv = x j = i end if norm = norm + x end do if ( norm < growto ) go to 840 ! !  Accept vector. ! x = rv1 ( j ) if ( ilambd == 0.0D+00 ) then x = 1.0D+00 / x else y = rv2 ( j ) end if do i = 1 , uk if ( ilambd == 0.0D+00 ) then z ( i , s ) = rv1 ( i ) * x else call cdiv ( rv1 ( i ), rv2 ( i ), x , y , z ( i , s - 1 ), z ( i , s ) ) end if end do if ( uk == n ) go to 940 j = uk + 1 go to 900 ! !  Choose a new starting vector. ! 840 continue if ( its >= uk ) go to 880 x = ukroot y = eps3 / ( x + 1.0D+00 ) rv1 ( 1 ) = eps3 rv1 ( 2 : uk ) = y j = uk - its + 1 rv1 ( j ) = rv1 ( j ) - eps3 * x if ( ilambd == 0.0D+00 ) go to 440 go to 660 ! !  Set error: unaccepted eigenvector. ! 880 continue j = 1 ierr = - k ! !  Set remaining vector components to zero. ! 900 continue do i = j , n z ( i , s ) = 0.0D+00 if ( ilambd /= 0.0D+00 ) z ( i , s - 1 ) = 0.0D+00 end do 940 continue s = s + 1 960 continue if ( ip == ( - 1 ) ) then ip = 0 end if if ( ip == 1 ) then ip = - 1 end if end do go to 1001 ! !  Set error: underestimate of eigenvector space required. ! 1000 continue if ( ierr /= 0 ) then ierr = ierr - n end if if ( ierr == 0 ) then ierr = - ( 2 * n + 1 ) end if 1001 continue m = s - 1 - abs ( ip ) return end subroutine minfit ( nm , m , n , a , w , ip , b , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: minfit !*****************************************************************************80 ! !! MINFIT solves the least squares problem, for a real overdetermined linear system. ! !  Discussion: ! !    This subroutine is part of an algorithm for solving general linear !    systems of the form A*X=B. ! !    It determines the singular value decomposition !      A = U * S * V' !    of a real M by N rectangular matrix, forming U' * B !    rather than U.  Householder bidiagonalization and a variant of the !    QR algorithm are used. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) NM, the leading dimension of the two-dimensional arrays. !    NM must be at least as large as the maximum of M and N. ! !    Input, integer ( kind = 4 ) M, the number of rows of A and B. ! !    Input, integer ( kind = 4 ) N, the number of columns of A, and the order of V. ! !    Input/output, real ( kind = 8 ) A(NM,N). On input, the rectangular coefficient matrix. !    On output, A has been overwritten by the orthogonal matrix V of the !    decomposition in its first N rows and columns.  If an error exit is made, !    the columns of V corresponding to indices of correct singular values !    should be correct. ! !    Output, real ( kind = 8 ) W(N), the singular values of A.  These are the diagonal !    elements of S.  They are unordered.  If an error exit is made, the !    singular values should be correct for indices IERR+1, IERR+2,...,N. ! !    Input, integer ( kind = 4 ) IP, is the number of columns of B.  IP can be zero. ! !    Input/output, real ( kind = 8 ) B(NM,IP).  On input, the constant column matrix, !    On output, B has been overwritten by U'*B.  If an error exit is made, !    the rows of U'*B corresponding to indices of correct singular values !    should be correct. ! !    Output, integer ( kind = 4 ) IERR, error flag. !    0, for normal return, !    K, if the K-th singular value has not been determined after 30 iterations. ! implicit none integer ( kind = 4 ) ip integer ( kind = 4 ) n integer ( kind = 4 ) nm real ( kind = 8 ) a ( nm , n ) real ( kind = 8 ) b ( nm , ip ) real ( kind = 8 ) c real ( kind = 8 ) f real ( kind = 8 ) g real ( kind = 8 ) h integer ( kind = 4 ) i integer ( kind = 4 ) i1 integer ( kind = 4 ) ierr integer ( kind = 4 ) ii integer ( kind = 4 ) its integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) k1 integer ( kind = 4 ) kk integer ( kind = 4 ) l integer ( kind = 4 ) l1 integer ( kind = 4 ) ll integer ( kind = 4 ) m integer ( kind = 4 ) m1 real ( kind = 8 ) pythag real ( kind = 8 ) rv1 ( n ) real ( kind = 8 ) s real ( kind = 8 ) scale real ( kind = 8 ) tst1 real ( kind = 8 ) tst2 real ( kind = 8 ) w ( n ) real ( kind = 8 ) x real ( kind = 8 ) y real ( kind = 8 ) z ierr = 0 ! !  Householder reduction to bidiagonal form. ! g = 0.0D+00 scale = 0.0D+00 x = 0.0D+00 do i = 1 , n l = i + 1 rv1 ( i ) = scale * g g = 0.0D+00 s = 0.0D+00 scale = 0.0D+00 if ( i <= m ) then scale = sum ( abs ( a ( i : m , i ) ) ) if ( scale /= 0.0D+00 ) then a ( i : m , i ) = a ( i : m , i ) / scale s = s + sum ( a ( i : m , i ) ** 2 ) f = a ( i , i ) g = - sign ( sqrt ( s ), f ) h = f * g - s a ( i , i ) = f - g do j = l , n s = dot_product ( a ( i : m , i ), a ( i : m , j ) ) f = s / h a ( i : m , j ) = a ( i : m , j ) + f * a ( i : m , i ) end do do j = 1 , ip s = dot_product ( a ( i : m , i ), b ( i : m , j ) ) b ( i : m , j ) = b ( i : m , j ) + s * a ( i : m , i ) / h end do a ( i : m , i ) = scale * a ( i : m , i ) end if end if w ( i ) = scale * g g = 0.0D+00 s = 0.0D+00 scale = 0.0D+00 if ( i <= m . and . i /= n ) then do k = l , n scale = scale + abs ( a ( i , k ) ) end do if ( scale /= 0.0D+00 ) then a ( i , l : n ) = a ( i , l : n ) / scale s = s + sum ( a ( i , l : n ) ** 2 ) f = a ( i , l ) g = - sign ( sqrt ( s ), f ) h = f * g - s a ( i , l ) = f - g rv1 ( l : n ) = a ( i , l : n ) / h do j = l , m s = dot_product ( a ( j , l : n ), a ( i , l : n ) ) a ( j , l : n ) = a ( j , l : n ) + s * rv1 ( l : n ) end do a ( i , l : n ) = scale * a ( i , l : n ) end if end if x = max ( x , abs ( w ( i ) ) + abs ( rv1 ( i ) ) ) end do ! !  Accumulation of right-hand transformations. ! do ii = 1 , n i = n + 1 - ii if ( i /= n ) then if ( g /= 0.0D+00 ) then a ( l : n , i ) = ( a ( i , l : n ) / a ( i , l ) ) / g do j = l , n s = dot_product ( a ( i , l : n ), a ( l : n , j ) ) a ( l : n , j ) = a ( l : n , j ) + s * a ( l : n , i ) end do end if a ( i , l : n ) = 0.0D+00 a ( l : n , i ) = 0.0D+00 end if a ( i , i ) = 1.0D+00 g = rv1 ( i ) l = i end do if ( m < n . and . ip /= 0 ) then m1 = m + 1 b ( m + 1 : n , 1 : ip ) = 0.0D+00 end if ! !  Diagonalization of the bidiagonal form. ! tst1 = x do kk = 1 , n k1 = n - kk k = k1 + 1 its = 0 ! !  Test for splitting. ! 520 continue do ll = 1 , k l1 = k - ll l = l1 + 1 tst2 = tst1 + abs ( rv1 ( l ) ) if ( tst2 == tst1 ) then go to 565 end if tst2 = tst1 + abs ( w ( k - ll ) ) if ( tst2 == tst1 ) then exit end if end do ! !  Cancellation of RV1(l) if l greater than 1. ! 540 continue c = 0.0D+00 s = 1.0D+00 do i = l , k f = s * rv1 ( i ) rv1 ( i ) = c * rv1 ( i ) tst2 = tst1 + abs ( f ) if ( tst2 == tst1 ) then exit end if g = w ( i ) h = pythag ( f , g ) w ( i ) = h c = g / h s = - f / h do j = 1 , ip y = b ( l1 , j ) z = b ( i , j ) b ( l1 , j ) = y * c + z * s b ( i , j ) = - y * s + z * c end do end do ! !  Test for convergence. ! 565 continue z = w ( k ) if ( l == k ) go to 650 ! !  Shift from bottom 2 by 2 minor. ! if ( its >= 30 ) then ierr = k return end if its = its + 1 x = w ( l ) y = w ( k1 ) g = rv1 ( k1 ) h = rv1 ( k ) f = 0.5D+00 * ( ( ( g + z ) / h ) * ( ( g - z ) / y ) + y / h - h / y ) g = pythag ( f , 1.0D+00 ) f = x - ( z / x ) * z + ( h / x ) * ( y / ( f + sign ( g , f ) ) - h ) ! !  Next QR transformation. ! c = 1.0D+00 s = 1.0D+00 do i1 = l , k1 i = i1 + 1 g = rv1 ( i ) y = w ( i ) h = s * g g = c * g z = pythag ( f , h ) rv1 ( i1 ) = z c = f / z s = h / z f = x * c + g * s g = - x * s + g * c h = y * s y = y * c do j = 1 , n x = a ( j , i1 ) z = a ( j , i ) a ( j , i1 ) = x * c + z * s a ( j , i ) = - x * s + z * c end do z = pythag ( f , h ) w ( i1 ) = z if ( z /= 0.0D+00 ) then c = f / z s = h / z end if f = c * g + s * y x = - s * g + c * y do j = 1 , ip y = b ( i1 , j ) z = b ( i , j ) b ( i1 , j ) = y * c + z * s b ( i , j ) = - y * s + z * c end do end do rv1 ( l ) = 0.0D+00 rv1 ( k ) = f w ( k ) = x go to 520 ! !  Convergence. ! 650 continue if ( z < 0.0D+00 ) then w ( k ) = - z a ( 1 : n , k ) = - a ( 1 : n , k ) end if end do return end subroutine ortbak ( n , low , igh , a , ort , m , z ) !DEC$ ATTRIBUTES DLLEXPORT :: ortbak !*****************************************************************************80 ! !! ORTBAK determines eigenvectors by undoing the ORTHES transformation. ! !  Discussion: ! !    This subroutine forms the eigenvectors of a real general !    matrix by back transforming those of the corresponding !    upper Hessenberg matrix determined by ORTHES. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, integer ( kind = 4 ) LOW, IGH, are determined by the balancing routine BALANC. !    If BALANC has not been used, set LOW = 1 and IGH equal to the order of !    the matrix. ! !    Input, real ( kind = 8 ) A(N,IGH), contains information about the orthogonal !    transformations used in the reduction by ORTHES in its strict !    lower triangle. ! !    Input/output, real ( kind = 8 ) ORT(IGH), contains further information about the !    transformations used in the reduction by ORTHES.  On output, ORT !    has been altered. ! !    Input, integer ( kind = 4 ) M, the number of columns of Z to be back transformed. ! !    Input/output, real ( kind = 8 ) Z(N,N).  On input, the real and imaginary parts of !    the eigenvectors to be back transformed in the first M columns.  On !    output, the real and imaginary parts of the transformed eigenvectors. ! implicit none integer ( kind = 4 ) igh integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( n , igh ) real ( kind = 8 ) g integer ( kind = 4 ) i integer ( kind = 4 ) j integer ( kind = 4 ) low integer ( kind = 4 ) mp real ( kind = 8 ) ort ( igh ) real ( kind = 8 ) z ( n , m ) if ( m == 0 ) then return end if do mp = igh - 1 , low + 1 , - 1 if ( a ( mp , mp - 1 ) /= 0.0D+00 ) then ort ( mp + 1 : igh ) = a ( mp + 1 : igh , mp - 1 ) do j = 1 , m g = dot_product ( ort ( mp : igh ), z ( mp : igh , j ) ) g = ( g / ort ( mp ) ) / a ( mp , mp - 1 ) do i = mp , igh z ( i , j ) = z ( i , j ) + g * ort ( i ) end do end do end if end do return end subroutine orthes ( n , low , igh , a , ort ) !DEC$ ATTRIBUTES DLLEXPORT :: orthes !*****************************************************************************80 ! !! ORTHES transforms a real general matrix to upper Hessenberg form. ! !  Discussion: ! !    Given a real general matrix, this subroutine reduces a submatrix !    situated in rows and columns LOW through IGH to upper Hessenberg form by !    orthogonal similarity transformations. ! !  Modified: ! !    04 February 2003 ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, integer ( kind = 4 ) LOW, IGH, are determined by the balancing routine BALANC. !    If BALANC has not been used, set LOW = 1 and IGH = N. ! !    Input/output, real ( kind = 8 ) A(N,N).  On input, the matrix.  On output, !    the Hessenberg matrix.  Information about the orthogonal transformations !    used in the reduction is stored in the remaining triangle under the !    Hessenberg matrix. ! !    Output, real ( kind = 8 ) ORT(IGH), contains further information about the !    transformations. ! implicit none integer ( kind = 4 ) igh integer ( kind = 4 ) n real ( kind = 8 ) a ( n , n ) real ( kind = 8 ) f real ( kind = 8 ) g real ( kind = 8 ) h integer ( kind = 4 ) i integer ( kind = 4 ) ii integer ( kind = 4 ) j integer ( kind = 4 ) jj integer ( kind = 4 ) la integer ( kind = 4 ) low integer ( kind = 4 ) m integer ( kind = 4 ) mp real ( kind = 8 ) ort ( igh ) real ( kind = 8 ) scale la = igh - 1 do m = low + 1 , la h = 0.0D+00 ort ( m ) = 0.0D+00 scale = 0.0D+00 ! !  Scale the column. ! do i = m , igh scale = scale + abs ( a ( i , m - 1 ) ) end do if ( scale /= 0.0D+00 ) then mp = m + igh do ii = m , igh i = mp - ii ort ( i ) = a ( i , m - 1 ) / scale h = h + ort ( i ) * ort ( i ) end do g = - sign ( sqrt ( h ), ort ( m ) ) h = h - ort ( m ) * g ort ( m ) = ort ( m ) - g ! !  Form (I-(U*Ut)/h) * A. ! do j = m , n f = 0.0D+00 do ii = m , igh i = mp - ii f = f + ort ( i ) * a ( i , j ) end do f = f / h do i = m , igh a ( i , j ) = a ( i , j ) - f * ort ( i ) end do end do ! !  Form (I-(u*ut)/h) * A * (I-(u*ut)/h). ! do i = 1 , igh f = 0.0D+00 do jj = m , igh j = mp - jj f = f + ort ( j ) * a ( i , j ) end do a ( i , m : igh ) = a ( i , m : igh ) - f * ort ( m : igh ) / h end do ort ( m ) = scale * ort ( m ) a ( m , m - 1 ) = scale * g end if end do return end subroutine ortran ( n , low , igh , a , ort , z ) !DEC$ ATTRIBUTES DLLEXPORT :: ortran !*****************************************************************************80 ! !! ORTRAN accumulates similarity transformations generated by ORTHES. ! !  Discussion: ! !    This subroutine accumulates the orthogonal similarity !    transformations used in the reduction of a real general !    matrix to upper Hessenberg form by ORTHES. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, integer ( kind = 4 ) LOW, IGH, are determined by the balancing !    routine BALANC.  If BALANC has not been used, set LOW = 1, IGH = N. ! !    Input, real ( kind = 8 ) A(N,IGH), contains information about the orthogonal !    transformations used in the reduction by ORTHES in its strict lower !    triangle. ! !    Input/output, real ( kind = 8 ) ORT(IGH), contains further information about the !    transformations used in the reduction by ORTHES.  On output, ORT !    has been further altered. ! !    Output, real ( kind = 8 ) Z(N,N), contains the transformation matrix produced in the !    reduction by ORTHES. ! implicit none integer ( kind = 4 ) igh integer ( kind = 4 ) n real ( kind = 8 ) a ( n , igh ) real ( kind = 8 ) g integer ( kind = 4 ) i integer ( kind = 4 ) j integer ( kind = 4 ) kl integer ( kind = 4 ) low integer ( kind = 4 ) mm integer ( kind = 4 ) mp real ( kind = 8 ) ort ( igh ) real ( kind = 8 ) z ( n , n ) ! !  Initialize Z to the identity matrix. ! z ( 1 : n , 1 : n ) = 0.0D+00 do i = 1 , n z ( i , i ) = 1.0D+00 end do kl = igh - low - 1 if ( kl < 1 ) then return end if do mm = 1 , kl mp = igh - mm if ( a ( mp , mp - 1 ) /= 0.0D+00 ) then ort ( mp + 1 : igh ) = a ( mp + 1 : igh , mp - 1 ) do j = mp , igh g = dot_product ( ort ( mp : igh ), z ( mp : igh , j ) ) g = ( g / ort ( mp ) ) / a ( mp , mp - 1 ) z ( mp : igh , j ) = z ( mp : igh , j ) + g * ort ( mp : igh ) end do end if end do return end function pythag ( a , b ) !DEC$ ATTRIBUTES DLLEXPORT :: pythag !*****************************************************************************80 ! !! PYTHAG computes SQRT ( A * A + B * B ) carefully. ! !  Discussion: ! !    The formula ! !      PYTHAG = sqrt ( A * A + B * B ) ! !    is reasonably accurate, but can fail if, for example, A**2 is larger !    than the machine overflow.  The formula can lose most of its accuracy !    if the sum of the squares is very large or very small. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Modified: ! !    04 February 2003 ! !  Parameters: ! !    Input, real ( kind = 8 ) A, B, the two legs of a right triangle. ! !    Output, real ( kind = 8 ) PYTHAG, the length of the hypotenuse. ! implicit none real ( kind = 8 ) a real ( kind = 8 ) b real ( kind = 8 ) p real ( kind = 8 ) pythag real ( kind = 8 ) r real ( kind = 8 ) s real ( kind = 8 ) t real ( kind = 8 ) u p = max ( abs ( a ), abs ( b ) ) if ( p /= 0.0D+00 ) then r = ( min ( abs ( a ), abs ( b ) ) / p ) ** 2 do t = 4.0D+00 + r if ( t == 4.0D+00 ) then exit end if s = r / t u = 1.0D+00 + 2.0D+00 * s p = u * p r = ( s / u ) ** 2 * r end do end if pythag = p return end subroutine qzhes ( n , a , b , matz , z ) !DEC$ ATTRIBUTES DLLEXPORT :: qzhes !*****************************************************************************80 ! !! QZHES carries out transformations for a generalized eigenvalue problem. ! !  Discussion: ! !    This subroutine is the first step of the QZ algorithm !    for solving generalized matrix eigenvalue problems. ! !    This subroutine accepts a pair of real general matrices and !    reduces one of them to upper Hessenberg form and the other !    to upper triangular form using orthogonal transformations. !    it is usually followed by QZIT, QZVAL and, possibly, QZVEC. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrices. ! !    Input/output, real ( kind = 8 ) A(N,N).  On input, the first real general matrix. !    On output, A has been reduced to upper Hessenberg form.  The elements !    below the first subdiagonal have been set to zero. ! !    Input/output, real ( kind = 8 ) B(N,N).  On input, a real general matrix. !    On output, B has been reduced to upper triangular form.  The elements !    below the main diagonal have been set to zero. ! !    Input, logical MATZ, should be TRUE if the right hand transformations !    are to be accumulated for later use in computing eigenvectors. ! !    Output, real ( kind = 8 ) Z(N,N), contains the product of the right hand !    transformations if MATZ is TRUE. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) a ( n , n ) real ( kind = 8 ) b ( n , n ) integer ( kind = 4 ) i integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) l integer ( kind = 4 ) l1 integer ( kind = 4 ) lb logical matz integer ( kind = 4 ) nk1 integer ( kind = 4 ) nm1 real ( kind = 8 ) r real ( kind = 8 ) rho real ( kind = 8 ) s real ( kind = 8 ) t real ( kind = 8 ) u1 real ( kind = 8 ) u2 real ( kind = 8 ) v1 real ( kind = 8 ) v2 real ( kind = 8 ) z ( n , n ) ! !  Set Z to the identity matrix. ! if ( matz ) then z ( 1 : n , 1 : n ) = 0.0D+00 do i = 1 , n z ( i , i ) = 1.0D+00 end do end if ! !  Reduce B to upper triangular form. ! if ( n <= 1 ) then return end if nm1 = n - 1 do l = 1 , n - 1 l1 = l + 1 s = sum ( abs ( b ( l + 1 : n , l ) ) ) if ( s /= 0.0D+00 ) then s = s + abs ( b ( l , l ) ) b ( l : n , l ) = b ( l : n , l ) / s r = sqrt ( sum ( b ( l : n , l ) ** 2 ) ) r = sign ( r , b ( l , l ) ) b ( l , l ) = b ( l , l ) + r rho = r * b ( l , l ) do j = l + 1 , n t = dot_product ( b ( l : n , l ), b ( l : n , j ) ) b ( l : n , j ) = b ( l : n , j ) - t * b ( l : n , l ) / rho end do do j = 1 , n t = dot_product ( b ( l : n , l ), a ( l : n , j ) ) a ( l : n , j ) = a ( l : n , j ) - t * b ( l : n , l ) / rho end do b ( l , l ) = - s * r b ( l + 1 : n , l ) = 0.0D+00 end if end do ! !  Reduce A to upper Hessenberg form, while keeping B triangular. ! if ( n == 2 ) then return end if do k = 1 , n - 2 nk1 = nm1 - k do lb = 1 , nk1 l = n - lb l1 = l + 1 ! !  Zero A(l+1,k). ! s = abs ( a ( l , k ) ) + abs ( a ( l1 , k ) ) if ( s /= 0.0D+00 ) then u1 = a ( l , k ) / s u2 = a ( l1 , k ) / s r = sign ( sqrt ( u1 ** 2 + u2 ** 2 ), u1 ) v1 = - ( u1 + r ) / r v2 = - u2 / r u2 = v2 / v1 do j = k , n t = a ( l , j ) + u2 * a ( l1 , j ) a ( l , j ) = a ( l , j ) + t * v1 a ( l1 , j ) = a ( l1 , j ) + t * v2 end do a ( l1 , k ) = 0.0D+00 do j = l , n t = b ( l , j ) + u2 * b ( l1 , j ) b ( l , j ) = b ( l , j ) + t * v1 b ( l1 , j ) = b ( l1 , j ) + t * v2 end do ! !  Zero B(l+1,l). ! s = abs ( b ( l1 , l1 ) ) + abs ( b ( l1 , l ) ) if ( s /= 0.0 ) then u1 = b ( l1 , l1 ) / s u2 = b ( l1 , l ) / s r = sign ( sqrt ( u1 ** 2 + u2 ** 2 ), u1 ) v1 = - ( u1 + r ) / r v2 = - u2 / r u2 = v2 / v1 do i = 1 , l1 t = b ( i , l1 ) + u2 * b ( i , l ) b ( i , l1 ) = b ( i , l1 ) + t * v1 b ( i , l ) = b ( i , l ) + t * v2 end do b ( l1 , l ) = 0.0D+00 do i = 1 , n t = a ( i , l1 ) + u2 * a ( i , l ) a ( i , l1 ) = a ( i , l1 ) + t * v1 a ( i , l ) = a ( i , l ) + t * v2 end do if ( matz ) then do i = 1 , n t = z ( i , l1 ) + u2 * z ( i , l ) z ( i , l1 ) = z ( i , l1 ) + t * v1 z ( i , l ) = z ( i , l ) + t * v2 end do end if end if end if end do end do return end subroutine qzit ( n , a , b , eps1 , matz , z , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: qzit !*****************************************************************************80 ! !! QZIT carries out iterations to solve a generalized eigenvalue problem. ! !  Discussion: ! !    This subroutine is the second step of the QZ algorithm !    for solving generalized matrix eigenvalue problems. ! !    This subroutine accepts a pair of real matrices, one of them !    in upper Hessenberg form and the other in upper triangular form. !    It reduces the Hessenberg matrix to quasi-triangular form using !    orthogonal transformations while maintaining the triangular form !    of the other matrix.  It is usually preceded by QZHES and !    followed by QZVAL and, possibly, QZVEC. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrices. ! !    Input/output, real ( kind = 8 ) A(N,N).  On input, a real upper Hessenberg matrix. !    On output, A has been reduced to quasi-triangular form.  The elements !    below the first subdiagonal are still zero and no two consecutive !    subdiagonal elements are nonzero. ! !    Input/output, real ( kind = 8 ) B(N,N).  On input, a real upper triangular matrix. !    On output, B is still in upper triangular form, although its elements !    have been altered.  The location B(N,1) is used to store EPS1 times !    the norm of B for later use by QZVAL and QZVEC. ! !    Input, real ( kind = 8 ) EPS1, a tolerance used to determine negligible elements. !    EPS1 = 0.0D+00 (or negative) may be input, in which case an element !    will be neglected only if it is less than roundoff error times the !    norm of its matrix.  If the input EPS1 is positive, then an element !    will be considered negligible if it is less than EPS1 times the norm !    of its matrix.  A positive value of EPS1 may result in faster execution, !    but less accurate results. ! !    Input, logical MATZ, should be TRUE if the right hand transformations !    are to be accumulated for later use in computing eigenvectors. ! !    Input/output, real ( kind = 8 ) Z(N,N).  If MATZ is FALSE, Z is not referenced. !    Otherwise, on input, the transformation matrix produced in the reduction !    by QZHES, if performed, or else the identity matrix.  On output, Z !    contains the product of the right hand transformations for both steps. ! !    Output, integer ( kind = 4 ) IERR, error flag. !    0, for normal return, !    J, if the limit of 30*N iterations is exhausted while the J-th !      eigenvalue is being sought. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) a ( n , n ) real ( kind = 8 ) a1 real ( kind = 8 ) a11 real ( kind = 8 ) a12 real ( kind = 8 ) a2 real ( kind = 8 ) a21 real ( kind = 8 ) a22 real ( kind = 8 ) a3 real ( kind = 8 ) a33 real ( kind = 8 ) a34 real ( kind = 8 ) a43 real ( kind = 8 ) a44 real ( kind = 8 ) ani real ( kind = 8 ) anorm real ( kind = 8 ) b ( n , n ) real ( kind = 8 ) b11 real ( kind = 8 ) b12 real ( kind = 8 ) b22 real ( kind = 8 ) b33 real ( kind = 8 ) b34 real ( kind = 8 ) b44 real ( kind = 8 ) bni real ( kind = 8 ) bnorm integer ( kind = 4 ) en integer ( kind = 4 ) enm2 integer ( kind = 4 ) enorn real ( kind = 8 ) ep real ( kind = 8 ) eps1 real ( kind = 8 ) epsa real ( kind = 8 ) epsb integer ( kind = 4 ) i integer ( kind = 4 ) ierr integer ( kind = 4 ) ish integer ( kind = 4 ) itn integer ( kind = 4 ) its integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) k1 integer ( kind = 4 ) k2 integer ( kind = 4 ) km1 integer ( kind = 4 ) l integer ( kind = 4 ) l1 integer ( kind = 4 ) ld integer ( kind = 4 ) ll integer ( kind = 4 ) lm1 integer ( kind = 4 ) lor1 logical matz integer ( kind = 4 ) na logical notlas real ( kind = 8 ) r real ( kind = 8 ) s real ( kind = 8 ) sh real ( kind = 8 ) t real ( kind = 8 ) u1 real ( kind = 8 ) u2 real ( kind = 8 ) u3 real ( kind = 8 ) v1 real ( kind = 8 ) v2 real ( kind = 8 ) v3 real ( kind = 8 ) z ( n , n ) ierr = 0 ! !  Compute EPSA and EPSB. ! anorm = 0.0D+00 bnorm = 0.0D+00 do i = 1 , n if ( i == 1 ) then ani = 0.0D+00 else ani = abs ( a ( i , i - 1 ) ) end if bni = 0.0D+00 do j = i , n ani = ani + abs ( a ( i , j ) ) bni = bni + abs ( b ( i , j ) ) end do anorm = max ( anorm , ani ) bnorm = max ( bnorm , bni ) end do if ( anorm == 0.0D+00 ) then anorm = 1.0D+00 end if if ( bnorm == 0.0D+00 ) then bnorm = 1.0D+00 end if ep = eps1 if ( ep > 0.0D+00 ) then go to 50 end if ! !  Use roundoff level if EPS1 is 0. ! ep = epsilon ( ep ) 50 continue epsa = ep * anorm epsb = ep * bnorm ! !  Reduce A to quasi-triangular form, while keeping B triangular. ! lor1 = 1 enorn = n en = n itn = 30 * n ! !  Begin QZ step. ! 60 continue if ( en <= 2 ) then go to 1001 end if if (. not . matz ) enorn = en its = 0 na = en - 1 enm2 = na - 1 70 continue ish = 2 ! !  Check for convergence or reducibility. ! do ll = 1 , en lm1 = en - ll l = lm1 + 1 if ( l == 1 ) go to 95 if ( abs ( a ( l , lm1 ) ) <= epsa ) then exit end if end do 90 continue a ( l , lm1 ) = 0.0D+00 if ( l < na ) go to 95 ! !  1-by-1 or 2-by-2 block isolated. ! en = lm1 go to 60 ! !  Check for small top of B. ! 95 continue ld = l 100 continue l1 = l + 1 b11 = b ( l , l ) if ( abs ( b11 ) > epsb ) go to 120 b ( l , l ) = 0.0D+00 s = abs ( a ( l , l ) ) + abs ( a ( l1 , l ) ) u1 = a ( l , l ) / s u2 = a ( l1 , l ) / s r = sign ( sqrt ( u1 ** 2 + u2 ** 2 ), u1 ) v1 = - ( u1 + r ) / r v2 = - u2 / r u2 = v2 / v1 do j = l , enorn t = a ( l , j ) + u2 * a ( l1 , j ) a ( l , j ) = a ( l , j ) + t * v1 a ( l1 , j ) = a ( l1 , j ) + t * v2 t = b ( l , j ) + u2 * b ( l1 , j ) b ( l , j ) = b ( l , j ) + t * v1 b ( l1 , j ) = b ( l1 , j ) + t * v2 end do if ( l /= 1 ) then a ( l , lm1 ) = - a ( l , lm1 ) end if lm1 = l l = l1 go to 90 120 continue a11 = a ( l , l ) / b11 a21 = a ( l1 , l ) / b11 if ( ish == 1 ) go to 140 ! !  Iteration strategy. ! if ( itn == 0 ) go to 1000 if ( its == 10 ) go to 155 ! !  Determine type of shift. ! b22 = b ( l1 , l1 ) if ( abs ( b22 ) < epsb ) b22 = epsb b33 = b ( na , na ) if ( abs ( b33 ) < epsb ) b33 = epsb b44 = b ( en , en ) if ( abs ( b44 ) < epsb ) b44 = epsb a33 = a ( na , na ) / b33 a34 = a ( na , en ) / b44 a43 = a ( en , na ) / b33 a44 = a ( en , en ) / b44 b34 = b ( na , en ) / b44 t = 0.5D+00 * ( a43 * b34 - a33 - a44 ) r = t * t + a34 * a43 - a33 * a44 if ( r < 0.0D+00 ) go to 150 ! !  Determine single shift zeroth column of A. ! ish = 1 r = sqrt ( r ) sh = - t + r s = - t - r if ( abs ( s - a44 ) < abs ( sh - a44 ) ) sh = s ! !  Look for two consecutive small sub-diagonal elements of A. ! do ll = ld , enm2 l = enm2 + ld - ll if ( l == ld ) then exit end if lm1 = l - 1 l1 = l + 1 t = a ( l , l ) if ( abs ( b ( l , l ) ) > epsb ) t = t - sh * b ( l , l ) if ( abs ( a ( l , lm1 ) ) <= abs ( t / a ( l1 , l ) ) * epsa ) go to 100 end do 140 continue a1 = a11 - sh a2 = a21 if ( l /= ld ) then a ( l , lm1 ) = - a ( l , lm1 ) end if go to 160 ! !  Determine double shift zeroth column of A. ! 150 continue a12 = a ( l , l1 ) / b22 a22 = a ( l1 , l1 ) / b22 b12 = b ( l , l1 ) / b22 a1 = ( ( a33 - a11 ) * ( a44 - a11 ) - a34 * a43 + a43 * b34 * a11 ) & / a21 + a12 - a11 * b12 a2 = ( a22 - a11 ) - a21 * b12 - ( a33 - a11 ) - ( a44 - a11 ) + a43 * b34 a3 = a ( l1 + 1 , l1 ) / b22 go to 160 ! !  Ad hoc shift. ! 155 continue a1 = 0.0D+00 a2 = 1.0D+00 a3 = 1.1605D+00 160 continue its = its + 1 itn = itn - 1 if ( . not . matz ) lor1 = ld ! !  Main loop. ! do k = l , na notlas = k /= na . and . ish == 2 k1 = k + 1 k2 = k + 2 km1 = max ( k - 1 , l ) ll = min ( en , k1 + ish ) if ( notlas ) go to 190 ! !  Zero A(k+1,k-1). ! if ( k /= l ) then a1 = a ( k , km1 ) a2 = a ( k1 , km1 ) end if s = abs ( a1 ) + abs ( a2 ) if ( s == 0.0D+00 ) go to 70 u1 = a1 / s u2 = a2 / s r = sign ( sqrt ( u1 ** 2 + u1 ** 2 ), u1 ) v1 = - ( u1 + r ) / r v2 = - u2 / r u2 = v2 / v1 do j = km1 , enorn t = a ( k , j ) + u2 * a ( k1 , j ) a ( k , j ) = a ( k , j ) + t * v1 a ( k1 , j ) = a ( k1 , j ) + t * v2 t = b ( k , j ) + u2 * b ( k1 , j ) b ( k , j ) = b ( k , j ) + t * v1 b ( k1 , j ) = b ( k1 , j ) + t * v2 end do if ( k /= l ) then a ( k1 , km1 ) = 0.0D+00 end if go to 240 ! !  Zero A(k+1,k-1) and A(k+2,k-1). ! 190 continue if ( k /= l ) then a1 = a ( k , km1 ) a2 = a ( k1 , km1 ) a3 = a ( k2 , km1 ) end if s = abs ( a1 ) + abs ( a2 ) + abs ( a3 ) if ( s == 0.0D+00 ) go to 260 u1 = a1 / s u2 = a2 / s u3 = a3 / s r = sign ( sqrt ( u1 ** 2 + u2 ** 2 + u3 ** 2 ), u1 ) v1 = - ( u1 + r ) / r v2 = - u2 / r v3 = - u3 / r u2 = v2 / v1 u3 = v3 / v1 do j = km1 , enorn t = a ( k , j ) + u2 * a ( k1 , j ) + u3 * a ( k2 , j ) a ( k , j ) = a ( k , j ) + t * v1 a ( k1 , j ) = a ( k1 , j ) + t * v2 a ( k2 , j ) = a ( k2 , j ) + t * v3 t = b ( k , j ) + u2 * b ( k1 , j ) + u3 * b ( k2 , j ) b ( k , j ) = b ( k , j ) + t * v1 b ( k1 , j ) = b ( k1 , j ) + t * v2 b ( k2 , j ) = b ( k2 , j ) + t * v3 end do if ( k /= l ) then a ( k1 , km1 ) = 0.0D+00 a ( k2 , km1 ) = 0.0D+00 end if ! !  Zero B(k+2,k+1) and B(k+2,k). ! s = abs ( b ( k2 , k2 ) ) + abs ( b ( k2 , k1 ) ) + abs ( b ( k2 , k ) ) if ( s == 0.0D+00 ) go to 240 u1 = b ( k2 , k2 ) / s u2 = b ( k2 , k1 ) / s u3 = b ( k2 , k ) / s r = sign ( sqrt ( u1 ** 2 + u2 ** 2 + u3 ** 2 ), u1 ) v1 = - ( u1 + r ) / r v2 = - u2 / r v3 = - u3 / r u2 = v2 / v1 u3 = v3 / v1 do i = lor1 , ll t = a ( i , k2 ) + u2 * a ( i , k1 ) + u3 * a ( i , k ) a ( i , k2 ) = a ( i , k2 ) + t * v1 a ( i , k1 ) = a ( i , k1 ) + t * v2 a ( i , k ) = a ( i , k ) + t * v3 t = b ( i , k2 ) + u2 * b ( i , k1 ) + u3 * b ( i , k ) b ( i , k2 ) = b ( i , k2 ) + t * v1 b ( i , k1 ) = b ( i , k1 ) + t * v2 b ( i , k ) = b ( i , k ) + t * v3 end do b ( k2 , k ) = 0.0D+00 b ( k2 , k1 ) = 0.0D+00 if ( matz ) then do i = 1 , n t = z ( i , k2 ) + u2 * z ( i , k1 ) + u3 * z ( i , k ) z ( i , k2 ) = z ( i , k2 ) + t * v1 z ( i , k1 ) = z ( i , k1 ) + t * v2 z ( i , k ) = z ( i , k ) + t * v3 end do end if ! !  Zero B(k+1,k). ! 240 continue s = abs ( b ( k1 , k1 ) ) + abs ( b ( k1 , k ) ) if ( s /= 0.0D+00 ) then u1 = b ( k1 , k1 ) / s u2 = b ( k1 , k ) / s r = sign ( sqrt ( u1 ** 2 + u2 ** 2 ), u1 ) v1 = - ( u1 + r ) / r v2 = - u2 / r u2 = v2 / v1 do i = lor1 , ll t = a ( i , k1 ) + u2 * a ( i , k ) a ( i , k1 ) = a ( i , k1 ) + t * v1 a ( i , k ) = a ( i , k ) + t * v2 t = b ( i , k1 ) + u2 * b ( i , k ) b ( i , k1 ) = b ( i , k1 ) + t * v1 b ( i , k ) = b ( i , k ) + t * v2 end do b ( k1 , k ) = 0.0D+00 if ( matz ) then do i = 1 , n t = z ( i , k1 ) + u2 * z ( i , k ) z ( i , k1 ) = z ( i , k1 ) + t * v1 z ( i , k ) = z ( i , k ) + t * v2 end do end if end if 260 continue end do go to 70 ! !  Set error: not all eigenvalues have converged after 30*N iterations. ! 1000 continue ierr = en ! !  Save EPSB for use by QZVAL and QZVEC. ! 1001 continue if ( n > 1 ) then b ( n , 1 ) = epsb end if return end subroutine qzval ( n , a , b , alfr , alfi , beta , matz , z ) !DEC$ ATTRIBUTES DLLEXPORT :: qzval !*****************************************************************************80 ! !! QZVAL computes eigenvalues for a generalized eigenvalue problem. ! !  Discussion: ! !    This subroutine is the third step of the QZ algorithm !    for solving generalized matrix eigenvalue problems. ! !    This subroutine accepts a pair of real matrices, one of them !    in quasi-triangular form and the other in upper triangular form. !    It reduces the quasi-triangular matrix further, so that any !    remaining 2-by-2 blocks correspond to pairs of complex !    eigenvalues, and returns quantities whose ratios give the !    generalized eigenvalues.  It is usually preceded by QZHES !    and QZIT and may be followed by QZVEC. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrices. ! !    Input/output, real ( kind = 8 ) A(N,N).  On input, a real upper quasi-triangular !    matrix.  On output, A has been reduced further to a quasi-triangular !    matrix in which all nonzero subdiagonal elements correspond to !    pairs of complex eigenvalues. ! !    Input/output, real ( kind = 8 ) B(N,N).  On input, a real upper triangular matrix. !    In addition, location B(n,1) contains the tolerance quantity EPSB !    computed and saved in QZIT.  On output, B is still in upper triangular !    form, although its elements have been altered.  B(N,1) is unaltered. ! !    Output, real ( kind = 8 ) ALFR(N), ALFI(N), the real and imaginary parts of the !    diagonal elements of the triangular matrix that would be obtained !    if A were reduced completely to triangular form by unitary !    transformations.  Non-zero values of ALFI occur in pairs, the first !    member positive and the second negative. ! !    Output, real ( kind = 8 ) BETA(N), the diagonal elements of the corresponding B, !    normalized to be real and non-negative.  The generalized eigenvalues !    are then the ratios (ALFR + I * ALFI) / BETA. ! !    Input, logical MATZ, should be TRUE if the right hand transformations !    are to be accumulated for later use in computing eigenvectors, and !    to FALSE otherwise. ! !    Input/output, real ( kind = 8 ) Z(N,N), is only used if MATZ is TRUE. !    On input, the transformation matrix produced in the reductions by QZHES !    and QZIT, if performed, or else the identity matrix.  On output, !    the product of the right hand transformations for all three steps. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) a ( n , n ) real ( kind = 8 ) a1 real ( kind = 8 ) a11 real ( kind = 8 ) a11i real ( kind = 8 ) a11r real ( kind = 8 ) a12 real ( kind = 8 ) a12i real ( kind = 8 ) a12r real ( kind = 8 ) a1i real ( kind = 8 ) a2 real ( kind = 8 ) a21 real ( kind = 8 ) a22 real ( kind = 8 ) a22i real ( kind = 8 ) a22r real ( kind = 8 ) a2i real ( kind = 8 ) an real ( kind = 8 ) alfi ( n ) real ( kind = 8 ) alfr ( n ) real ( kind = 8 ) b ( n , n ) real ( kind = 8 ) b11 real ( kind = 8 ) b12 real ( kind = 8 ) b22 real ( kind = 8 ) beta ( n ) real ( kind = 8 ) bn real ( kind = 8 ) c real ( kind = 8 ) cq real ( kind = 8 ) cz real ( kind = 8 ) d real ( kind = 8 ) di real ( kind = 8 ) dr real ( kind = 8 ) e real ( kind = 8 ) ei integer ( kind = 4 ) en real ( kind = 8 ) epsb integer ( kind = 4 ) i integer ( kind = 4 ) isw integer ( kind = 4 ) j logical matz integer ( kind = 4 ) na integer ( kind = 4 ) nn real ( kind = 8 ) r real ( kind = 8 ) s real ( kind = 8 ) sqi real ( kind = 8 ) sqr real ( kind = 8 ) ssi real ( kind = 8 ) ssr real ( kind = 8 ) szi real ( kind = 8 ) szr real ( kind = 8 ) t real ( kind = 8 ) ti real ( kind = 8 ) tr real ( kind = 8 ) u1 real ( kind = 8 ) u2 real ( kind = 8 ) v1 real ( kind = 8 ) v2 real ( kind = 8 ) z ( n , n ) epsb = b ( n , 1 ) isw = 1 ! !  Find eigenvalues of quasi-triangular matrices. ! do nn = 1 , n en = n + 1 - nn na = en - 1 if ( isw == 2 ) go to 505 if ( en == 1 ) go to 410 if ( a ( en , na ) /= 0.0D+00 ) go to 420 ! !  1-by-1 block, one real root. ! 410 continue alfr ( en ) = a ( en , en ) if ( b ( en , en ) < 0.0D+00 ) alfr ( en ) = - alfr ( en ) beta ( en ) = abs ( b ( en , en ) ) alfi ( en ) = 0.0D+00 go to 510 ! !  2-by-2 block. ! 420 continue if ( abs ( b ( na , na ) ) <= epsb ) then a1 = a ( na , na ) a2 = a ( en , na ) go to 460 end if if ( abs ( b ( en , en ) ) <= epsb ) then a1 = a ( en , en ) a2 = a ( en , na ) bn = 0.0D+00 go to 435 end if an = abs ( a ( na , na ) ) + abs ( a ( na , en ) ) + abs ( a ( en , na ) ) & + abs ( a ( en , en ) ) bn = abs ( b ( na , na ) ) + abs ( b ( na , en ) ) + abs ( b ( en , en ) ) a11 = a ( na , na ) / an a12 = a ( na , en ) / an a21 = a ( en , na ) / an a22 = a ( en , en ) / an b11 = b ( na , na ) / bn b12 = b ( na , en ) / bn b22 = b ( en , en ) / bn e = a11 / b11 ei = a22 / b22 s = a21 / ( b11 * b22 ) t = ( a22 - e * b22 ) / b22 if ( abs ( e ) > abs ( ei ) ) then e = ei t = ( a11 - e * b11 ) / b11 end if c = 0.5D+00 * ( t - s * b12 ) d = c ** 2 + s * ( a12 - e * b12 ) if ( d < 0.0D+00 ) then go to 480 end if ! !  Two real roots. !  Zero both A(EN,NA) and B(EN,NA). ! e = e + ( c + sign ( sqrt ( d ), c ) ) a11 = a11 - e * b11 a12 = a12 - e * b12 a22 = a22 - e * b22 if ( abs ( a11 ) + abs ( a12 ) >= abs ( a21 ) + abs ( a22 ) ) then a1 = a12 a2 = a11 else a1 = a22 a2 = a21 end if ! !  Choose and apply real Z. ! 435 continue s = abs ( a1 ) + abs ( a2 ) u1 = a1 / s u2 = a2 / s r = sign ( sqrt ( u1 ** 2 + u2 ** 2 ), u1 ) v1 = - ( u1 + r ) / r v2 = - u2 / r u2 = v2 / v1 do i = 1 , en t = a ( i , en ) + u2 * a ( i , na ) a ( i , en ) = a ( i , en ) + t * v1 a ( i , na ) = a ( i , na ) + t * v2 t = b ( i , en ) + u2 * b ( i , na ) b ( i , en ) = b ( i , en ) + t * v1 b ( i , na ) = b ( i , na ) + t * v2 end do if ( matz ) then do i = 1 , n t = z ( i , en ) + u2 * z ( i , na ) z ( i , en ) = z ( i , en ) + t * v1 z ( i , na ) = z ( i , na ) + t * v2 end do end if 450 continue if ( bn == 0.0D+00 ) go to 475 if ( an >= abs ( e ) * bn ) then a1 = b ( na , na ) a2 = b ( en , na ) else a1 = a ( na , na ) a2 = a ( en , na ) end if ! !  Choose and apply real Q. ! 460 continue s = abs ( a1 ) + abs ( a2 ) if ( s == 0.0D+00 ) go to 475 u1 = a1 / s u2 = a2 / s r = sign ( sqrt ( u1 ** 2 + u2 ** 2 ), u1 ) v1 = - ( u1 + r ) / r v2 = - u2 / r u2 = v2 / v1 do j = na , n t = a ( na , j ) + u2 * a ( en , j ) a ( na , j ) = a ( na , j ) + t * v1 a ( en , j ) = a ( en , j ) + t * v2 t = b ( na , j ) + u2 * b ( en , j ) b ( na , j ) = b ( na , j ) + t * v1 b ( en , j ) = b ( en , j ) + t * v2 end do 475 continue a ( en , na ) = 0.0D+00 b ( en , na ) = 0.0D+00 alfr ( na ) = a ( na , na ) alfr ( en ) = a ( en , en ) if ( b ( na , na ) < 0.0D+00 ) alfr ( na ) = - alfr ( na ) if ( b ( en , en ) < 0.0D+00 ) alfr ( en ) = - alfr ( en ) beta ( na ) = abs ( b ( na , na ) ) beta ( en ) = abs ( b ( en , en ) ) alfi ( en ) = 0.0D+00 alfi ( na ) = 0.0D+00 go to 505 ! !  Two complex roots. ! 480 continue e = e + c ei = sqrt ( - d ) a11r = a11 - e * b11 a11i = ei * b11 a12r = a12 - e * b12 a12i = ei * b12 a22r = a22 - e * b22 a22i = ei * b22 if ( abs ( a11r ) + abs ( a11i ) + abs ( a12r ) + abs ( a12i ) >= & abs ( a21 ) + abs ( a22r ) + abs ( a22i ) ) then a1 = a12r a1i = a12i a2 = - a11r a2i = - a11i else a1 = a22r a1i = a22i a2 = - a21 a2i = 0.0D+00 end if ! !  Choose complex Z. ! cz = sqrt ( a1 ** 2 + a1i ** 2 ) if ( cz /= 0.0D+00 ) then szr = ( a1 * a2 + a1i * a2i ) / cz szi = ( a1 * a2i - a1i * a2 ) / cz r = sqrt ( cz ** 2 + szr ** 2 + szi ** 2 ) cz = cz / r szr = szr / r szi = szi / r else szr = 1.0D+00 szi = 0.0D+00 end if if ( an >= ( abs ( e ) + ei ) * bn ) then a1 = cz * b11 + szr * b12 a1i = szi * b12 a2 = szr * b22 a2i = szi * b22 else a1 = cz * a11 + szr * a12 a1i = szi * a12 a2 = cz * a21 + szr * a22 a2i = szi * a22 end if ! !  Choose complex Q. ! cq = sqrt ( a1 ** 2 + a1i ** 2 ) if ( cq /= 0.0D+00 ) then sqr = ( a1 * a2 + a1i * a2i ) / cq sqi = ( a1 * a2i - a1i * a2 ) / cq r = sqrt ( cq ** 2 + sqr ** 2 + sqi ** 2 ) cq = cq / r sqr = sqr / r sqi = sqi / r else sqr = 1.0D+00 sqi = 0.0D+00 end if ! !  Compute diagonal elements that would result if transformations were applied. ! ssr = sqr * szr + sqi * szi ssi = sqr * szi - sqi * szr i = 1 tr = cq * cz * a11 + cq * szr * a12 + sqr * cz * a21 + ssr * a22 ti = cq * szi * a12 - sqi * cz * a21 + ssi * a22 dr = cq * cz * b11 + cq * szr * b12 + ssr * b22 di = cq * szi * b12 + ssi * b22 go to 503 502 continue i = 2 tr = ssr * a11 - sqr * cz * a12 - cq * szr * a21 + cq * cz * a22 ti = - ssi * a11 - sqi * cz * a12 + cq * szi * a21 dr = ssr * b11 - sqr * cz * b12 + cq * cz * b22 di = - ssi * b11 - sqi * cz * b12 503 continue t = ti * dr - tr * di if ( t < 0.0D+00 ) then j = en else j = na end if r = sqrt ( dr ** 2 + di ** 2 ) beta ( j ) = bn * r alfr ( j ) = an * ( tr * dr + ti * di ) / r alfi ( j ) = an * t / r if ( i == 1 ) go to 502 505 continue isw = 3 - isw 510 continue end do b ( n , 1 ) = epsb return end subroutine qzvec ( n , a , b , alfr , alfi , beta , z ) !DEC$ ATTRIBUTES DLLEXPORT :: qzvec !*****************************************************************************80 ! !! QZVEC computes eigenvectors for a generalized eigenvalue problem. ! !  Discussion: ! !    This subroutine is the optional fourth step of the QZ algorithm !    for solving generalized matrix eigenvalue problems. ! !    This subroutine accepts a pair of real matrices, one of them in !    quasi-triangular form (in which each 2-by-2 block corresponds to !    a pair of complex eigenvalues) and the other in upper triangular !    form.  It computes the eigenvectors of the triangular problem and !    transforms the results back to the original coordinate system. !    it is usually preceded by QZHES, QZIT, and QZVAL. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrices. ! !    Input, real ( kind = 8 ) A(N,N), contains a real upper quasi-triangular matrix. !    Its subdiagonal elements provide information about the storage of !    the complex eigenvectors. ! !    Input/output, real ( kind = 8 ) B(N,N).  On input, a real upper triangular matrix. !    In addition, location B(N,1) contains the tolerance quantity EPSB !    computed and saved in QZIT.  On output, B has been destroyed. ! !    Input, real ( kind = 8 ) ALFR(N), ALFI(N), BETA(N), vectors whose ratios !      ( ALFR + I * ALFI ) / BETA !    are the generalized eigenvalues.  They are usually obtained from QZVAL. ! !    Input/output, real ( kind = 8 ) Z(N,N).  On input, the transformation matrix produced !    in the reductions by QZHES, QZIT, and QZVAL, if performed.  If the !    eigenvectors of the triangular problem are desired, Z must contain the !    identity matrix.  On output, Z contains the real and imaginary parts of !    the eigenvectors: !    If ALFI(I) == 0.0, the I-th eigenvalue is real and the I-th column of Z !    contains its eigenvector. !    If ALFI(I) > 0.0, the eigenvalue is the first of a complex pair and the !    I-th and (I+1)-th columns of Z contain its eigenvector. !    If ALFI(I) < 0.0, the eigenvalue is the second of a complex pair and the !    (I-1)-th and I-th columns of Z contain the conjugate of its eigenvector. !    Each eigenvector is normalized so that the modulus of its largest !    component is 1.0D+00 . ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) a ( n , n ) real ( kind = 8 ) alfi ( n ) real ( kind = 8 ) alfm real ( kind = 8 ) alfr ( n ) real ( kind = 8 ) almi real ( kind = 8 ) almr real ( kind = 8 ) b ( n , n ) real ( kind = 8 ) beta ( n ) real ( kind = 8 ) betm real ( kind = 8 ) d real ( kind = 8 ) di real ( kind = 8 ) dr integer ( kind = 4 ) en integer ( kind = 4 ) enm2 real ( kind = 8 ) epsb integer ( kind = 4 ) i integer ( kind = 4 ) ii integer ( kind = 4 ) isw integer ( kind = 4 ) j integer ( kind = 4 ) jj integer ( kind = 4 ) k integer ( kind = 4 ) m integer ( kind = 4 ) na integer ( kind = 4 ) nn real ( kind = 8 ) q real ( kind = 8 ) r real ( kind = 8 ) ra real ( kind = 8 ) rr real ( kind = 8 ) s real ( kind = 8 ) sa real ( kind = 8 ) t real ( kind = 8 ) t1 real ( kind = 8 ) t2 real ( kind = 8 ) ti real ( kind = 8 ) tr real ( kind = 8 ) w real ( kind = 8 ) w1 real ( kind = 8 ) x real ( kind = 8 ) x1 real ( kind = 8 ) y real ( kind = 8 ) z ( n , n ) real ( kind = 8 ) z1 real ( kind = 8 ) zz epsb = b ( n , 1 ) isw = 1 do nn = 1 , n en = n + 1 - nn na = en - 1 if ( isw == 2 ) go to 795 if ( alfi ( en ) /= 0.0D+00 ) go to 710 ! !  Real vector. ! m = en b ( en , en ) = 1.0D+00 if ( na == 0 ) go to 800 alfm = alfr ( m ) betm = beta ( m ) do ii = 1 , na i = en - ii w = betm * a ( i , i ) - alfm * b ( i , i ) r = 0.0D+00 do j = m , en r = r + ( betm * a ( i , j ) - alfm * b ( i , j ) ) * b ( j , en ) end do if ( i == 1 . or . isw == 2 ) go to 630 if ( betm * a ( i , i - 1 ) == 0.0D+00 ) go to 630 zz = w s = r go to 690 630 continue m = i if ( isw == 2 ) go to 640 ! !  Real 1-by-1 block. ! t = w if ( w == 0.0D+00 ) t = epsb b ( i , en ) = - r / t go to 700 ! !  Real 2-by-2 block. ! 640 continue x = betm * a ( i , i + 1 ) - alfm * b ( i , i + 1 ) y = betm * a ( i + 1 , i ) q = w * zz - x * y t = ( x * s - zz * r ) / q b ( i , en ) = t if ( abs ( x ) <= abs ( zz ) ) go to 650 b ( i + 1 , en ) = ( - r - w * t ) / x go to 690 650 continue b ( i + 1 , en ) = ( - s - y * t ) / zz 690 continue isw = 3 - isw 700 continue end do ! !  End real vector. ! go to 800 ! !  Complex vector. ! 710 continue m = na almr = alfr ( m ) almi = alfi ( m ) betm = beta ( m ) ! !  Last vector component chosen imaginary so eigenvector matrix is triangular. ! y = betm * a ( en , na ) b ( na , na ) = - almi * b ( en , en ) / y b ( na , en ) = ( almr * b ( en , en ) - betm * a ( en , en ) ) / y b ( en , na ) = 0.0D+00 b ( en , en ) = 1.0D+00 enm2 = na - 1 do ii = 1 , enm2 i = na - ii w = betm * a ( i , i ) - almr * b ( i , i ) w1 = - almi * b ( i , i ) ra = 0.0D+00 sa = 0.0D+00 do j = m , en x = betm * a ( i , j ) - almr * b ( i , j ) x1 = - almi * b ( i , j ) ra = ra + x * b ( j , na ) - x1 * b ( j , en ) sa = sa + x * b ( j , en ) + x1 * b ( j , na ) end do if ( i == 1 . or . isw == 2 ) go to 770 if ( betm * a ( i , i - 1 ) == 0.0D+00 ) go to 770 zz = w z1 = w1 r = ra s = sa isw = 2 go to 790 770 continue m = i if ( isw == 2 ) go to 780 ! !  Complex 1-by-1 block. ! tr = - ra ti = - sa 773 continue dr = w di = w1 ! !  Complex divide (t1,t2) = (tr,ti) / (dr,di), ! 775 continue if ( abs ( di ) > abs ( dr ) ) go to 777 rr = di / dr d = dr + di * rr t1 = ( tr + ti * rr ) / d t2 = ( ti - tr * rr ) / d go to ( 787 , 782 ), isw 777 continue rr = dr / di d = dr * rr + di t1 = ( tr * rr + ti ) / d t2 = ( ti * rr - tr ) / d go to ( 787 , 782 ), isw ! !  Complex 2-by-2 block. ! 780 continue x = betm * a ( i , i + 1 ) - almr * b ( i , i + 1 ) x1 = - almi * b ( i , i + 1 ) y = betm * a ( i + 1 , i ) tr = y * ra - w * r + w1 * s ti = y * sa - w * s - w1 * r dr = w * zz - w1 * z1 - x * y di = w * z1 + w1 * zz - x1 * y if ( dr == 0.0D+00 . and . di == 0.0D+00 ) dr = epsb go to 775 782 continue b ( i + 1 , na ) = t1 b ( i + 1 , en ) = t2 isw = 1 if ( abs ( y ) > abs ( w ) + abs ( w1 ) ) go to 785 tr = - ra - x * b ( i + 1 , na ) + x1 * b ( i + 1 , en ) ti = - sa - x * b ( i + 1 , en ) - x1 * b ( i + 1 , na ) go to 773 785 continue t1 = ( - r - zz * b ( i + 1 , na ) + z1 * b ( i + 1 , en ) ) / y t2 = ( - s - zz * b ( i + 1 , en ) - z1 * b ( i + 1 , na ) ) / y 787 continue b ( i , na ) = t1 b ( i , en ) = t2 790 continue end do ! !  End complex vector. ! 795 continue isw = 3 - isw 800 continue end do ! !  End back substitution. !  Transform to original coordinate system. ! do jj = 1 , n j = n + 1 - jj do i = 1 , n zz = 0.0D+00 do k = 1 , j zz = zz + z ( i , k ) * b ( k , j ) end do z ( i , j ) = zz end do end do ! !  Normalize so that modulus of largest component of each vector is 1. !  (ISW is 1 initially from before). ! do j = 1 , n d = 0.0D+00 if ( isw == 2 ) go to 920 if ( alfi ( j ) /= 0.0D+00 ) go to 945 do i = 1 , n d = max ( d , abs ( z ( i , j ) ) ) end do z ( 1 : n , j ) = z ( 1 : n , j ) / d go to 950 920 continue do i = 1 , n r = abs ( z ( i , j - 1 ) ) + abs ( z ( i , j ) ) if ( r /= 0.0D+00 ) then r = r * sqrt ( ( z ( i , j - 1 ) / r ) ** 2 + ( z ( i , j ) / r ) ** 2 ) end if if ( r > d ) d = r end do z ( 1 : n , j - 1 ) = z ( 1 : n , j - 1 ) / d z ( 1 : n , j ) = z ( 1 : n , j ) / d 945 continue isw = 3 - isw 950 continue end do return end subroutine r8_swap ( x , y ) !DEC$ ATTRIBUTES DLLEXPORT :: r8_swap !*****************************************************************************80 ! !! R8_SWAP swaps two R8's. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    22 December 2000 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input/output, real ( kind = 8 ) X, Y.  On output, the values of X and !    Y have been interchanged. ! implicit none real ( kind = 8 ) x real ( kind = 8 ) y real ( kind = 8 ) z z = x x = y y = z return end subroutine r8mat_print ( m , n , a , title ) !DEC$ ATTRIBUTES DLLEXPORT :: r8mat_print !*****************************************************************************80 ! !! R8MAT_PRINT prints an R8MAT. ! !  Discussion: ! !    An R8MAT is an array of R8 values. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    12 September 2004 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer ( kind = 4 ) M, the number of rows in A. ! !    Input, integer ( kind = 4 ) N, the number of columns in A. ! !    Input, real ( kind = 8 ) A(M,N), the matrix. ! !    Input, character ( len = * ) TITLE, a title. ! implicit none integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( m , n ) character ( len = * ) title call r8mat_print_some ( m , n , a , 1 , 1 , m , n , title ) return end subroutine r8mat_print_some ( m , n , a , ilo , jlo , ihi , jhi , title ) !DEC$ ATTRIBUTES DLLEXPORT :: r8mat_print_some !*****************************************************************************80 ! !! R8MAT_PRINT_SOME prints some of an R8MAT. ! !  Discussion: ! !    An R8MAT is an array of R8 values. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    26 March 2005 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer ( kind = 4 ) M, N, the number of rows and columns. ! !    Input, real ( kind = 8 ) A(M,N), an M by N matrix to be printed. ! !    Input, integer ( kind = 4 ) ILO, JLO, the first row and column to print. ! !    Input, integer ( kind = 4 ) IHI, JHI, the last row and column to print. ! !    Input, character ( len = * ) TITLE, a title. ! implicit none integer ( kind = 4 ), parameter :: incx = 5 integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( m , n ) character ( len = 14 ) ctemp ( incx ) integer ( kind = 4 ) i integer ( kind = 4 ) i2hi integer ( kind = 4 ) i2lo integer ( kind = 4 ) ihi integer ( kind = 4 ) ilo integer ( kind = 4 ) inc integer ( kind = 4 ) j integer ( kind = 4 ) j2 integer ( kind = 4 ) j2hi integer ( kind = 4 ) j2lo integer ( kind = 4 ) jhi integer ( kind = 4 ) jlo character ( len = * ) title write ( * , '(a)' ) ' ' write ( * , '(a)' ) trim ( title ) do j2lo = max ( jlo , 1 ), min ( jhi , n ), incx j2hi = j2lo + incx - 1 j2hi = min ( j2hi , n ) j2hi = min ( j2hi , jhi ) inc = j2hi + 1 - j2lo write ( * , '(a)' ) ' ' do j = j2lo , j2hi j2 = j + 1 - j2lo write ( ctemp ( j2 ), '(i8,6x)' ) j end do write ( * , '(''  Col   '',5a14)' ) ctemp ( 1 : inc ) write ( * , '(a)' ) '  Row' write ( * , '(a)' ) ' ' i2lo = max ( ilo , 1 ) i2hi = min ( ihi , m ) do i = i2lo , i2hi do j2 = 1 , inc j = j2lo - 1 + j2 if ( a ( i , j ) == real ( int ( a ( i , j ) ), kind = 8 ) ) then write ( ctemp ( j2 ), '(f8.0,6x)' ) a ( i , j ) else write ( ctemp ( j2 ), '(g14.6)' ) a ( i , j ) end if end do write ( * , '(i5,1x,5a14)' ) i , ( ctemp ( j ), j = 1 , inc ) end do end do return end subroutine r8vec_print ( n , a , title ) !DEC$ ATTRIBUTES DLLEXPORT :: r8vec_print !*****************************************************************************80 ! !! R8VEC_PRINT prints an R8VEC. ! !  Discussion: ! !    An R8VEC is a vector of R8 values. ! !  Modified: ! !    22 August 2000 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the number of components of the vector. ! !    Input, real ( kind = 8 ) A(N), the vector to be printed. ! !    Input, character ( len = * ) TITLE, a title. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) a ( n ) integer ( kind = 4 ) i character ( len = * ) title write ( * , '(a)' ) ' ' write ( * , '(a)' ) trim ( title ) write ( * , '(a)' ) ' ' do i = 1 , n write ( * , '(2x,i8,2x,g16.8)' ) i , a ( i ) end do return end subroutine r8vec2_print ( n , a1 , a2 , title ) !DEC$ ATTRIBUTES DLLEXPORT :: r8vec2_print !*****************************************************************************80 ! !! R8VEC2_PRINT prints an R8VEC2. ! !  Discussion: ! !    An R8VEC2 is a dataset consisting of N pairs of R8's, stored !    as two separate vectors A1 and A2. ! !  Modified: ! !    13 December 2004 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the number of components of the vector. ! !    Input, real ( kind = 8 ) A1(N), A2(N), the vectors to be printed. ! !    Input, character ( len = * ) TITLE, a title. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) a1 ( n ) real ( kind = 8 ) a2 ( n ) integer ( kind = 4 ) i character ( len = * ) title write ( * , '(a)' ) ' ' write ( * , '(a)' ) trim ( title ) write ( * , '(a)' ) ' ' if ( all ( a1 ( 1 : n ) == aint ( a1 ( 1 : n ) ) ) . and . & all ( a2 ( 1 : n ) == aint ( a2 ( 1 : n ) ) ) ) then do i = 1 , n write ( * , '(i8,2i8)' ) i , int ( a1 ( i ) ), int ( a2 ( i ) ) end do else if ( all ( abs ( a1 ( 1 : n ) ) < 100000 0.0D+00 ) . and . & all ( abs ( a2 ( 1 : n ) ) < 100000 0.0D+00 ) ) then do i = 1 , n write ( * , '(i8,2f14.6)' ) i , a1 ( i ), a2 ( i ) end do else do i = 1 , n write ( * , '(i8,2g14.6)' ) i , a1 ( i ), a2 ( i ) end do end if return end subroutine ratqr ( n , eps1 , d , e , e2 , m , w , ind , bd , type , idef , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: ratqr !*****************************************************************************80 ! !! RATQR computes selected eigenvalues of a real symmetric tridiagonal matrix. ! !  Discussion: ! !    This subroutine finds the algebraically smallest or largest !    eigenvalues of a symmetric tridiagonal matrix by the !    rational QR method with Newton corrections. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input/output, real ( kind = 8 ) EPS1.  On input, a theoretical absolute !    error tolerance for the computed eigenvalues.  If the input EPS1 is !    non-positive, or indeed smaller than its default value, it is reset at !    each iteration to the respective default value, namely, the product of !    the relative machine precision and the magnitude of the current eigenvalue !    iterate.  The theoretical absolute error in the K-th eigenvalue is usually !    not greater than K times EPS1.  On output, EPS1 is unaltered unless it has !    been reset to its (last) default value. ! !    Input, real ( kind = 8 ) D(N), the diagonal elements of the input matrix. ! !    Input, real ( kind = 8 ) E(N), the subdiagonal elements of the input matrix !    in E(2:N).  E(1) is arbitrary. ! !    Input/output, real ( kind = 8 ) E2(N).  On input, E2(2:N-1) contains the !    squares of the corresponding elements of E, and E2(1) is arbitrary.  On !    output, elements of E2 corresponding to elements of E regarded as !    negligible have been replaced by zero, causing the matrix to split into !    a direct sum of submatrices.  E2(1) is set to 0.0D+00 if the smallest !    eigenvalues have been found, and to 2.0D+00 if the largest eigenvalues !    have been found.  E2 is otherwise unaltered (unless overwritten by BD). ! !    Input, integer ( kind = 4 ) M, the number of eigenvalues to be found. ! !    Output, real ( kind = 8 ) W(M), the M algebraically smallest eigenvalues in !    ascending order, or the M largest eigenvalues in descending order. !    If an error exit is made because of an incorrect specification of IDEF, !    no eigenvalues are found.  If the Newton iterates for a particular !    eigenvalue are not monotone, the best estimate obtained is returned !    and IERR is set.  W may coincide with D. ! !    Outpt, integer IND(N), contains in its first M positions the submatrix !    indices associated with the corresponding eigenvalues in W: !    1 for eigenvalues belonging to the first submatrix from the top, 2 for !    those belonging to the second submatrix, and so on. ! !    Output, real ( kind = 8 ) BD(N), contains refined bounds for the !    theoretical errors of the corresponding eigenvalues in W.  These bounds !    are usually within the tolerance specified by EPS1.  BD may coincide !    with E2. ! !    Input, integer ( kind = 4 ) IDEF, should be set to 1 if the input matrix !    is known to be positive definite, to -1 if the input matrix is known to !    be negative  definite, and to 0 otherwise. ! !    Input, logical TYPE, should be set to TRUE if the smallest eigenvalues !    are to be found, and to FALSE if the largest eigenvalues are to be found. ! !    Output, integer ( kind = 4 ) IERR, error flag. !    0, for normal return, !    6*N+1, if IDEF is set to 1 and TYPE to .true. when the matrix is not !      positive definite, or if IDEF is set to -1 and TYPE to .false. !      when the matrix is not negative definite, !    5*N+K, if successive iterates to the K-th eigenvalue are not monotone !      increasing, where K refers to the last such occurrence. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) bd ( n ) real ( kind = 8 ) d ( n ) real ( kind = 8 ) delta real ( kind = 8 ) e ( n ) real ( kind = 8 ) e2 ( n ) real ( kind = 8 ) ep real ( kind = 8 ) eps1 real ( kind = 8 ) err real ( kind = 8 ) f integer ( kind = 4 ) i integer ( kind = 4 ) idef integer ( kind = 4 ) ierr integer ( kind = 4 ) ii integer ( kind = 4 ) ind ( n ) integer ( kind = 4 ) j integer ( kind = 4 ) jdef integer ( kind = 4 ) jj integer ( kind = 4 ) k !  integer ( kind = 4 ) k1 integer ( kind = 4 ) m real ( kind = 8 ) p real ( kind = 8 ) q real ( kind = 8 ) qp real ( kind = 8 ) r real ( kind = 8 ) s real ( kind = 8 ) tot logical type real ( kind = 8 ) w ( n ) ierr = 0 jdef = idef w ( 1 : n ) = d ( 1 : n ) if ( . not . type ) then j = 1 go to 400 end if 40 continue err = 0.0D+00 s = 0.0D+00 ! !  Look for small sub-diagonal entries and define initial shift !  from lower Gerschgorin bound. ! !  Copy E2 array into BD. ! tot = w ( 1 ) q = 0.0D+00 j = 0 do i = 1 , n p = q if ( i == 1 ) go to 60 if ( p > ( abs ( d ( i ) ) + abs ( d ( i - 1 ) ) ) * epsilon ( p ) ) then go to 80 end if 60 continue e2 ( i ) = 0.0D+00 80 continue bd ( i ) = e2 ( i ) ! !  Count also if element of E2 has underflowed. ! if ( e2 ( i ) == 0.0D+00 ) j = j + 1 ind ( i ) = j q = 0.0D+00 if ( i /= n ) q = abs ( e ( i + 1 ) ) tot = min ( w ( i ) - p - q , tot ) end do if ( jdef == 1 . and . tot < 0.0D+00 ) then go to 140 end if w ( 1 : n ) = w ( 1 : n ) - tot go to 160 140 continue tot = 0.0D+00 160 continue do k = 1 , m ! !  Next QR transformation. ! 180 continue tot = tot + s delta = w ( n ) - s i = n f = abs ( tot ) * epsilon ( f ) if ( eps1 < f ) eps1 = f if ( delta > eps1 ) go to 190 if ( delta < ( - eps1 ) ) go to 1000 go to 300 ! !  Replace small sub-diagonal squares by zero to reduce the incidence of !  underflows. ! 190 continue do j = k + 1 , n if ( bd ( j ) <= ( abs ( w ( j ) + w ( j - 1 ) ) * epsilon ( bd ( j ) ) ) ** 2 ) then bd ( j ) = 0.0D+00 end if end do f = bd ( n ) / delta qp = delta + f p = 1.0D+00 do ii = 1 , n - k i = n - ii q = w ( i ) - s - f r = q / qp p = p * r + 1.0D+00 ep = f * r w ( i + 1 ) = qp + ep delta = q - ep if ( delta > eps1 ) go to 220 if ( delta < ( - eps1 ) ) go to 1000 go to 300 220 continue f = bd ( i ) / q qp = delta + f bd ( i + 1 ) = qp * ep end do w ( k ) = qp s = qp / p if ( tot + s > tot ) go to 180 ! !  Set error: irregular end of iteration. !  Deflate minimum diagonal element. ! ierr = 5 * n + k s = 0.0D+00 delta = qp do j = k , n if ( w ( j ) <= delta ) then i = j delta = w ( j ) end if end do ! !  Convergence. ! 300 continue if ( i < n ) bd ( i + 1 ) = bd ( i ) * f / qp ii = ind ( i ) do jj = 1 , i - k j = i - jj w ( j + 1 ) = w ( j ) - s bd ( j + 1 ) = bd ( j ) ind ( j + 1 ) = ind ( j ) end do w ( k ) = tot err = err + abs ( delta ) bd ( k ) = err ind ( k ) = ii end do if ( type ) then return end if f = bd ( 1 ) e2 ( 1 ) = 2.0D+00 bd ( 1 ) = f j = 2 ! !  Negate elements of W for largest values. ! 400 continue w ( 1 : n ) = - w ( 1 : n ) jdef = - jdef if ( j == 1 ) then go to 40 end if return ! !  Set error: IDEF specified incorrectly. ! 1000 continue ierr = 6 * n + 1 return end subroutine rebak ( n , b , dl , m , z ) !DEC$ ATTRIBUTES DLLEXPORT :: rebak !*****************************************************************************80 ! !! REBAK determines eigenvectors by undoing the REDUC transformation. ! !  Discussion: ! !    This subroutine forms the eigenvectors of a generalized !    symmetric eigensystem by back transforming those of the !    derived symmetric matrix determined by REDUC. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, real ( kind = 8 ) B(N,N), contains information about the similarity !    transformation (Cholesky decomposition) used in the reduction by REDUC !    in its strict lower triangle. ! !    Input, real ( kind = 8 ) DL(N), further information about the transformation. ! !    Input, integer ( kind = 4 ) M, the number of eigenvectors to be back transformed. ! !    Input/output, real ( kind = 8 ) Z(N,M).  On input, the eigenvectors to be back !    transformed in its first M columns.  On output, the transformed !    eigenvectors. ! implicit none integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) b ( n , n ) real ( kind = 8 ) dl ( n ) integer ( kind = 4 ) i integer ( kind = 4 ) j real ( kind = 8 ) z ( n , m ) do j = 1 , m do i = n , 1 , - 1 z ( i , j ) = ( z ( i , j ) - dot_product ( b ( i + 1 : n , i ), z ( i + 1 : n , j ) ) ) / dl ( i ) end do end do return end subroutine rebakb ( n , b , dl , m , z ) !DEC$ ATTRIBUTES DLLEXPORT :: rebakb !*****************************************************************************80 ! !! REBAKB determines eigenvectors by undoing the REDUC2 transformation. ! !  Discussion: ! !    This subroutine forms the eigenvectors of a generalized !    symmetric eigensystem by back transforming those of the !    derived symmetric matrix determined by REDUC2. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, real ( kind = 8 ) B(N,N), contains information about the similarity !    transformation (Cholesky decomposition) used in the reduction by REDUC2 !    in its strict lower triangle. ! !    Input, real ( kind = 8 ) DL(N), further information about the transformation. ! !    Input, integer ( kind = 4 ) M, the number of eigenvectors to be back transformed. ! !    Input/output, real ( kind = 8 ) Z(N,M).  On input, the eigenvectors to be back !    transformed in its first M columns.  On output, the transformed !    eigenvectors. ! implicit none integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) b ( n , n ) real ( kind = 8 ) dl ( n ) integer ( kind = 4 ) i integer ( kind = 4 ) j real ( kind = 8 ) z ( n , m ) do j = 1 , m do i = n , 1 , - 1 z ( i , j ) = dl ( i ) * z ( i , j ) + dot_product ( b ( i , 1 : i - 1 ), z ( 1 : i - 1 , j ) ) end do end do return end subroutine reduc ( n , a , b , dl , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: reduc !*****************************************************************************80 ! !! REDUC reduces the eigenvalue problem A*x=lambda*B*x to A*x=lambda*x. ! !  Discussion: ! !    This subroutine reduces the generalized symmetric eigenproblem !    ax=(lambda)bx, where B is positive definite, to the standard !    symmetric eigenproblem using the Cholesky factorization of B. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrices A and B.  If the Cholesky !    factor L of B is already available, N should be prefixed with a minus sign. ! !    Input/output, real ( kind = 8 ) A(N,N).  On input, A contains a real symmetric matrix. !    Only the full upper triangle of the matrix need be supplied. !    On output, A contains in its full lower triangle the full lower triangle !    of the symmetric matrix derived from the reduction to the !    standard form.  The strict upper triangle of a is unaltered. ! !    Input/output, real ( kind = 8 ) B(N,N).  On input, the real symmetric input matrix. !    Only the full upper triangle of the matrix need be supplied.  If !    N is negative, the strict lower triangle of B contains, instead, the !    strict lower triangle of its Cholesky factor L.  In any case, on output, !    B contains in its strict lower triangle the strict lower triangle of !    its Cholesky factor L.  The full upper triangle of B is unaltered. ! !    Input/output, real ( kind = 8 ) DL(N).  If N is negative, then the DL contains !    the diagonal elements of L on input.  In any case, DL will contain !    the diagonal elements of L on output, ! !    Output, integer ( kind = 4 ) IERR, error flag. !    0, for normal return, !    7*N+1, if B is not positive definite. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) a ( n , n ) real ( kind = 8 ) b ( n , n ) real ( kind = 8 ) dl ( n ) integer ( kind = 4 ) i integer ( kind = 4 ) ierr integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) nn real ( kind = 8 ) x real ( kind = 8 ) y ierr = 0 nn = abs ( n ) ! !  Form L in the arrays B and DL. ! do i = 1 , n do j = i , n x = b ( i , j ) do k = 1 , i - 1 x = x - b ( i , k ) * b ( j , k ) end do if ( j == i ) then if ( x <= 0.0D+00 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'REDUC - Fatal error!' write ( * , '(a)' ) '  The matrix is not positive definite.' ierr = 7 * n + 1 return end if y = sqrt ( x ) dl ( i ) = y else b ( j , i ) = x / y end if end do end do ! !  Form the transpose of the upper triangle of INV(L)*A !  in the lower triangle of the array A. ! do i = 1 , nn y = dl ( i ) do j = i , nn x = a ( i , j ) do k = 1 , i - 1 x = x - b ( i , k ) * a ( j , k ) end do a ( j , i ) = x / y end do end do ! !  Pre-multiply by INV(L) and overwrite. ! do j = 1 , nn do i = j , nn x = a ( i , j ) do k = j , i - 1 x = x - a ( k , j ) * b ( i , k ) end do do k = 1 , j - 1 x = x - a ( j , k ) * b ( i , k ) end do a ( i , j ) = x / dl ( i ) end do end do return end subroutine reduc2 ( n , a , b , dl , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: reduc2 !*****************************************************************************80 ! !! REDUC2 reduces the eigenvalue problem A*B*x=lamdba*x to A*x=lambda*x. ! !  Discussion: ! !    This subroutine reduces the generalized symmetric eigenproblems !    abx=(lambda)x or bay=(lambda)y, where B is positive definite, !    to the standard symmetric eigenproblem using the Cholesky !    factorization of B. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrices A and B.  If the Cholesky !    factor L of B is already available, N should be prefixed with a minus sign. ! !    Input/output, real ( kind = 8 ) A(N,N).  On input, A contains a real symmetric matrix. !    Only the full upper triangle of the matrix need be supplied. !    On output, A contains in its full lower triangle the full lower triangle !    of the symmetric matrix derived from the reduction to the !    standard form.  The strict upper triangle of a is unaltered. ! !    Input/output, real ( kind = 8 ) B(N,N).  On input, the real symmetric input matrix. !    Only the full upper triangle of the matrix need be supplied.  If !    N is negative, the strict lower triangle of B contains, instead, the !    strict lower triangle of its Cholesky factor L.  In any case, on output, !    B contains in its strict lower triangle the strict lower triangle of !    its Cholesky factor L.  The full upper triangle of B is unaltered. ! !    Input/output, real ( kind = 8 ) DL(N).  If N is negative, then the DL contains !    the diagonal elements of L on input.  In any case, DL will contain !    the diagonal elements of L on output, ! !    Output, integer ( kind = 4 ) IERR, error flag. !    0, for normal return, !    7*N+1, if B is not positive definite. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) a ( n , n ) real ( kind = 8 ) b ( n , n ) real ( kind = 8 ) dl ( n ) integer ( kind = 4 ) i integer ( kind = 4 ) ierr integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) nn real ( kind = 8 ) x real ( kind = 8 ) y ierr = 0 nn = abs ( n ) ! !  Form L in the arrays B and DL. ! do i = 1 , n do j = i , n x = b ( i , j ) do k = 1 , i - 1 x = x - b ( i , k ) * b ( j , k ) end do if ( j == i ) then if ( x <= 0.0D+00 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'REDUC2 - Fatal error!' write ( * , '(a)' ) '  The matrix is not positive definite.' ierr = 7 * n + 1 return end if y = sqrt ( x ) dl ( i ) = y else b ( j , i ) = x / y end if end do end do ! !  Form the lower triangle of A*L in the lower triangle of A. ! do i = 1 , nn do j = 1 , i x = a ( j , i ) * dl ( j ) do k = j + 1 , i x = x + a ( k , i ) * b ( k , j ) end do do k = i + 1 , nn x = x + a ( i , k ) * b ( k , j ) end do a ( i , j ) = x end do end do ! !  Pre-multiply by L' and overwrite. ! do i = 1 , nn y = dl ( i ) do j = 1 , i x = y * a ( i , j ) do k = i + 1 , nn x = x + a ( k , j ) * b ( k , i ) end do a ( i , j ) = x end do end do return end subroutine rg ( n , a , wr , wi , matz , z , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: rg !*****************************************************************************80 ! !! RG computes eigenvalues and eigenvectors of a real general matrix. ! !  Discussion: ! !    This subroutine calls the recommended sequence of !    subroutines from the eigensystem subroutine package (eispack) !    to find the eigenvalues and eigenvectors (if desired) !    of a real general matrix. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input/output, real ( kind = 8 ) A(N,N), the real general matrix.  On output, !    A has been overwritten. ! !    Input, integer ( kind = 4 ) MATZ, is zero if only eigenvalues are desired, and !    nonzero if both eigenvalues and eigenvectors are desired. ! !    Output, real ( kind = 8 ) WR(N), WI(N), the real and imaginary parts, respectively, !    of the eigenvalues.  Complex conjugate pairs of eigenvalues appear !    consecutively with the eigenvalue having the positive imaginary part first. ! !    Output, real ( kind = 8 ) Z(N,N), contains the real and imaginary parts of the !    eigenvectors if MATZ is not zero.  If the J-th eigenvalue is real, the !    J-th column of Z contains its eigenvector.  If the J-th eigenvalue is !    complex with positive imaginary part, the J-th and (J+1)-th columns of !    Z contain the real and imaginary parts of its eigenvector.  The !    conjugate of this vector is the eigenvector for the conjugate eigenvalue. ! !    Output, integer ( kind = 4 ) IERR, an error completion code described in the !    documentation for HQR and HQR2.  The normal completion code is zero. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) a ( n , n ) real ( kind = 8 ) fv1 ( n ) integer ( kind = 4 ) ierr integer ( kind = 4 ) is1 integer ( kind = 4 ) is2 integer ( kind = 4 ) iv1 ( n ) integer ( kind = 4 ) matz real ( kind = 8 ) wi ( n ) real ( kind = 8 ) wr ( n ) real ( kind = 8 ) z ( n , n ) call balanc ( n , a , is1 , is2 , fv1 ) call elmhes ( n , is1 , is2 , a , iv1 ) if ( matz == 0 ) then call hqr ( n , is1 , is2 , a , wr , wi , ierr ) if ( ierr /= 0 ) then return end if else call eltran ( n , is1 , is2 , a , iv1 , z ) call hqr2 ( n , is1 , is2 , a , wr , wi , z , ierr ) if ( ierr /= 0 ) then return end if call balbak ( n , is1 , is2 , fv1 , n , z ) end if return end subroutine rgg ( n , a , b , alfr , alfi , beta , matz , z , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: rgg !*****************************************************************************80 ! !! RGG computes eigenvalues/vectors for the generalized problem A*x = lambda*B*x. ! !  Discussion: ! !    This subroutine calls the recommended sequence of !    subroutines from the eigensystem subroutine package (eispack) !    to find the eigenvalues and eigenvectors (if desired) !    for the real general generalized eigenproblem ! !      A * x = lambda * B * x. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrices A and B. ! !    Input/output, real ( kind = 8 ) A(N,N), B(N,N), the two real general matrices. !    On output, A and B have been overwritten. ! !    Input, integer ( kind = 4 ) MATZ, is zero if only eigenvalues are desired, and !    nonzero if both eigenvalues and eigenvectors are desired. ! !    Output, real ( kind = 8 ) ALFR(N), ALFI(N), the real and imaginary parts, !    respectively, of the numerators of the eigenvalues. ! !    Output, real ( kind = 8 ) BETA(N), the denominators of the eigenvalues, !    which are thus given by the ratios (ALFR + I * ALFI ) / BETA. !    Complex conjugate pairs of eigenvalues appear consecutively !    with the eigenvalue having the positive imaginary part first. ! !    Output, real ( kind = 8 ) Z(N,N), contains the real and imaginary parts of the !    eigenvectors if MATZ is not zero.  If the J-th eigenvalue is real, the !    J-th column of Z contains its eigenvector.  If the J-th eigenvalue is !    complex with positive imaginary part, the J-th and (J+1)-th columns of !    Z contain the real and imaginary parts of its eigenvector.  The !    conjugate of this vector is the eigenvector for the conjugate eigenvalue. ! !    Output, integer ( kind = 4 ) IERR, is set equal to an error completion code !    described in the documentation for QZIT.  The normal completion !    code is zero. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) a ( n , n ) real ( kind = 8 ) alfi ( n ) real ( kind = 8 ) alfr ( n ) real ( kind = 8 ) b ( n , n ) real ( kind = 8 ) beta ( n ) real ( kind = 8 ) eps1 integer ( kind = 4 ) ierr integer ( kind = 4 ) matz logical tf real ( kind = 8 ) z ( n , n ) eps1 = 0.0D+00 if ( matz == 0 ) then tf = . false . else tf = . true . end if call qzhes ( n , a , b , tf , z ) call qzit ( n , a , b , eps1 , tf , z , ierr ) if ( ierr /= 0 ) then return end if call qzval ( n , a , b , alfr , alfi , beta , tf , z ) if ( matz /= 0 ) then call qzvec ( n , a , b , alfr , alfi , beta , z ) end if return end subroutine rs ( n , a , w , matz , z , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: rs !*****************************************************************************80 ! !! RS computes eigenvalues and eigenvectors of real symmetric matrix. ! !  Discussion: ! !    This subroutine calls the recommended sequence of !    subroutines from the eigensystem subroutine package (eispack) !    to find the eigenvalues and eigenvectors (if desired) !    of a real symmetric matrix. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, real ( kind = 8 ) A(N,N), the real symmetric matrix. ! !    Input, integer ( kind = 4 ) MATZ, is zero if only eigenvalues are desired, and !    nonzero if both eigenvalues and eigenvectors are desired. ! !    Output, real ( kind = 8 ) W(N), the eigenvalues in ascending order. ! !    Output, real ( kind = 8 ) Z(N,N), contains the eigenvectors, if MATZ is nonzero. ! !    Output, integer ( kind = 4 ) IERR, is set equal to an error !    completion code described in the documentation for TQLRAT and TQL2. !    The normal completion code is zero. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) a ( n , n ) real ( kind = 8 ) fv1 ( n ) real ( kind = 8 ) fv2 ( n ) integer ( kind = 4 ) ierr integer ( kind = 4 ) matz real ( kind = 8 ) w ( n ) real ( kind = 8 ) z ( n , n ) if ( matz == 0 ) then call tred1 ( n , a , w , fv1 , fv2 ) call tqlrat ( n , w , fv2 , ierr ) else call tred2 ( n , a , w , fv1 , z ) call tql2 ( n , w , fv1 , z , ierr ) end if return end subroutine rsb ( n , mb , a , w , matz , z , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: rsb !*****************************************************************************80 ! !! RSB computes eigenvalues and eigenvectors of a real symmetric band matrix. ! !  Discussion: ! !    This subroutine calls the recommended sequence of !    subroutines from the eigensystem subroutine package (eispack) !    to find the eigenvalues and eigenvectors (if desired) !    of a real symmetric band matrix. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, integer ( kind = 4 ) MB, the half band width of the matrix, defined as the !    number of adjacent diagonals, including the principal diagonal, required !    to specify the non-zero portion of the lower triangle of the matrix. ! !    Input, real ( kind = 8 ) A(N,MB), contains the lower triangle of the real symmetric !    band matrix.  Its lowest subdiagonal is stored in the last N+1-MB !    positions of the first column, its next subdiagonal in the last !    N+2-MB positions of the second column, further subdiagonals similarly, !    and finally its principal diagonal in the N positions of the last !    column.  Contents of storages not part of the matrix are arbitrary. ! !    Input, integer ( kind = 4 ) MATZ, is zero if only eigenvalues are desired, and !    nonzero if both eigenvalues and eigenvectors are desired. ! !    Output, real ( kind = 8 ) W(N), the eigenvalues in ascending order. ! !    Output, real ( kind = 8 ) Z(N,N), contains the eigenvectors, if MATZ is nonzero. ! !    Output, integer ( kind = 4 ) IERR, is set to an error !    completion code described in the documentation for TQLRAT and TQL2. !    The normal completion code is zero. ! implicit none integer ( kind = 4 ) mb integer ( kind = 4 ) n real ( kind = 8 ) a ( n , mb ) real ( kind = 8 ) fv1 ( n ) real ( kind = 8 ) fv2 ( n ) integer ( kind = 4 ) ierr integer ( kind = 4 ) matz logical tf real ( kind = 8 ) w ( n ) real ( kind = 8 ) z ( n , n ) if ( mb <= 0 ) then ierr = 12 * n return end if if ( n < mb ) then ierr = 12 * n return end if if ( matz == 0 ) then tf = . false . call bandr ( n , mb , a , w , fv1 , fv2 , tf , z ) call tqlrat ( n , w , fv2 , ierr ) else tf = . true . call bandr ( n , mb , a , w , fv1 , fv1 , tf , z ) call tql2 ( n , w , fv1 , z , ierr ) end if return end subroutine rsg ( n , a , b , w , matz , z , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: rsg !*****************************************************************************80 ! !! RSG computes eigenvalues/vectors, A*x=lambda*B*x, A symmetric, B pos-def. ! !  Discussion: ! !    This subroutine calls the recommended sequence of !    subroutines from the eigensystem subroutine package (eispack) !    to find the eigenvalues and eigenvectors (if desired) !    for the real symmetric generalized eigenproblem  ax = (lambda)bx. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Modified: ! !    04 February 2003 ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrices A and B. ! !    Input, real ( kind = 8 ) A(N,N), contains a real symmetric matrix. ! !    Input, real ( kind = 8 ) B(N,N), contains a positive definite real symmetric matrix. ! !    Input, integer ( kind = 4 ) MATZ, is zero if only eigenvalues are desired, and !    nonzero if both eigenvalues and eigenvectors are desired. ! !    Output, real ( kind = 8 ) W(N), the eigenvalues in ascending order. ! !    Output, real ( kind = 8 ) Z(N,N), contains the eigenvectors, if MATZ is nonzero. ! !    Output, integer ( kind = 4 ) IERR, is set to an error !    completion code described in the documentation for TQLRAT and TQL2. !    The normal completion code is zero. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) a ( n , n ) real ( kind = 8 ) b ( n , n ) real ( kind = 8 ) fv1 ( n ) real ( kind = 8 ) fv2 ( n ) integer ( kind = 4 ) ierr integer ( kind = 4 ) matz real ( kind = 8 ) w ( n ) real ( kind = 8 ) z ( n , n ) call reduc ( n , a , b , fv2 , ierr ) if ( ierr /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'RSG - Fatal error!' write ( * , '(a)' ) '  Error return from REDUC.' return end if if ( matz == 0 ) then call tred1 ( n , a , w , fv1 , fv2 ) call tqlrat ( n , w , fv2 , ierr ) if ( ierr /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'RSG - Warning!' write ( * , '(a)' ) '  Error return from TQLRAT!' return end if else call tred2 ( n , a , w , fv1 , z ) call tql2 ( n , w , fv1 , z , ierr ) if ( ierr /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'RSG - Fatal error!' write ( * , '(a)' ) '  Error return from TQL2!' return end if call rebak ( n , b , fv2 , n , z ) end if return end subroutine rsgab ( n , a , b , w , matz , z , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: rsgab !*****************************************************************************80 ! !! RSGAB computes eigenvalues/vectors, A*B*x=lambda*x, A symmetric, B pos-def. ! !  Discussion: ! !    This subroutine calls the recommended sequence of !    subroutines from the eigensystem subroutine package (eispack) !    to find the eigenvalues and eigenvectors (if desired) !    for the real symmetric generalized eigenproblem  abx = (lambda)x. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrices A and B. ! !    Input, real ( kind = 8 ) A(N,N), contains a real symmetric matrix. ! !    Input, real ( kind = 8 ) B(N,N), contains a positive definite real symmetric matrix. ! !    Input, integer ( kind = 4 ) MATZ, is zero if only eigenvalues are desired, and !    nonzero if both eigenvalues and eigenvectors are desired. ! !    Output, real ( kind = 8 ) W(N), the eigenvalues in ascending order. ! !    Output, real ( kind = 8 ) Z(N,N), contains the eigenvectors, if MATZ is nonzero. ! !    Output, integer ( kind = 4 ) IERR, is set to an error !    completion code described in the documentation for TQLRAT and TQL2. !    The normal completion code is zero. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) a ( n , n ) real ( kind = 8 ) b ( n , n ) real ( kind = 8 ) fv1 ( n ) real ( kind = 8 ) fv2 ( n ) integer ( kind = 4 ) ierr integer ( kind = 4 ) matz real ( kind = 8 ) w ( n ) real ( kind = 8 ) z ( n , n ) call reduc2 ( n , a , b , fv2 , ierr ) if ( ierr /= 0 ) then return end if if ( matz == 0 ) then call tred1 ( n , a , w , fv1 , fv2 ) call tqlrat ( n , w , fv2 , ierr ) else call tred2 ( n , a , w , fv1 , z ) call tql2 ( n , w , fv1 , z , ierr ) if ( ierr /= 0 ) then return end if call rebak ( n , b , fv2 , n , z ) end if return end subroutine rsgba ( n , a , b , w , matz , z , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: rsgba !*****************************************************************************80 ! !! RSGBA computes eigenvalues/vectors, B*A*x=lambda*x, A symmetric, B pos-def. ! !  Discussion: ! !    This subroutine calls the recommended sequence of !    subroutines from the eigensystem subroutine package (eispack) !    to find the eigenvalues and eigenvectors (if desired) !    for the real symmetric generalized eigenproblem: ! !      B * A * x = lambda * x ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrices A and B. ! !    Input, real ( kind = 8 ) A(N,N), a real symmetric matrix. ! !    Input, real ( kind = 8 ) B(N,N), a positive definite symmetric matrix. ! !    Input, integer ( kind = 4 ) MATZ, is zero if only eigenvalues are desired, and !    nonzero if both eigenvalues and eigenvectors are desired. ! !    Output, real ( kind = 8 ) W(N), the eigenvalues in ascending order. ! !    Output, real ( kind = 8 ) Z(N,N), contains the eigenvectors, if MATZ is nonzero. ! !    Output, integer ( kind = 4 ) IERR, is set to an error !    completion code described in the documentation for TQLRAT and TQL2. !    The normal completion code is zero. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) a ( n , n ) real ( kind = 8 ) b ( n , n ) real ( kind = 8 ) fv1 ( n ) real ( kind = 8 ) fv2 ( n ) integer ( kind = 4 ) ierr integer ( kind = 4 ) matz real ( kind = 8 ) w ( n ) real ( kind = 8 ) z ( n , n ) call reduc2 ( n , a , b , fv2 , ierr ) if ( ierr /= 0 ) then return end if if ( matz == 0 ) then call tred1 ( n , a , w , fv1 , fv2 ) call tqlrat ( n , w , fv2 , ierr ) else call tred2 ( n , a , w , fv1 , z ) call tql2 ( n , w , fv1 , z , ierr ) if ( ierr /= 0 ) then return end if call rebakb ( n , b , fv2 , n , z ) end if return end subroutine rsm ( n , a , w , m , z , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: rsm !*****************************************************************************80 ! !! RSM computes eigenvalues, some eigenvectors, real symmetric matrix. ! !  Discussion: ! !    This subroutine calls the recommended sequence of !    subroutines from the eigensystem subroutine package (eispack) !    to find all of the eigenvalues and some of the eigenvectors !    of a real symmetric matrix. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, real ( kind = 8 ) A(N,N), the symmetric matrix. ! !    Input, integer ( kind = 4 ) M, specifies the number of eigenvectors to compute. ! !    Output, real ( kind = 8 ) W(N), the eigenvalues in ascending order. ! !    Output, real ( kind = 8 ) Z(N,M), contains the orthonormal eigenvectors associated !    with the first M eigenvalues. ! !    Output, integer ( kind = 4 ) IERR, is set to an error !    completion code described in the documentation for TQLRAT, IMTQLV and !    TINVIT.  The normal completion code is zero. ! implicit none integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( n , n ) real ( kind = 8 ) fwork1 ( n ) real ( kind = 8 ) fwork2 ( n ) real ( kind = 8 ) fwork3 ( n ) !  real    ( kind = 8 ) fwork4(n) integer ( kind = 4 ) ierr integer ( kind = 4 ) iwork ( n ) integer ( kind = 4 ) k1 integer ( kind = 4 ) k2 integer ( kind = 4 ) k3 integer ( kind = 4 ) k4 real ( kind = 8 ) w ( n ) real ( kind = 8 ) z ( n , m ) k1 = 1 k2 = k1 + n k3 = k2 + n k4 = k3 + n if ( m <= 0 ) then call tred1 ( n , a , w , fwork1 , fwork2 ) call tqlrat ( n , w , fwork2 , ierr ) else call tred1 ( n , a , fwork1 , fwork2 , fwork3 ) call imtqlv ( n , fwork1 , fwork2 , fwork3 , w , iwork , ierr ) call tinvit ( n , fwork1 , fwork2 , fwork3 , m , w , iwork , z , ierr ) call trbak1 ( n , a , fwork2 , m , z ) end if return end subroutine rsp ( n , nv , a , w , matz , z , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: rsp !*****************************************************************************80 ! !! RSP computes eigenvalues and eigenvectors of real symmetric packed matrix. ! !  Discussion: ! !    This subroutine calls the recommended sequence of !    subroutines from the eigensystem subroutine package (eispack) !    to find the eigenvalues and eigenvectors (if desired) !    of a real symmetric packed matrix. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, integer ( kind = 4 ) NV, the dimension of the array A, which !    must be at least (N*(N+1))/2. ! !    Input, real ( kind = 8 ) A(NV), contains the lower triangle of the real symmetric !    packed matrix stored row-wise. ! !    Input, integer ( kind = 4 ) MATZ, is zero if only eigenvalues are desired, and !    nonzero if both eigenvalues and eigenvectors are desired. ! !    Output, real ( kind = 8 ) W(N), the eigenvalues in ascending order. ! !    Output, real ( kind = 8 ) Z(N,N), contains the eigenvectors, if MATZ is nonzero. ! !    Output, integer ( kind = 4 ) IERR, is set to an error !    completion code described in the documentation for TQLRAT and TQL2. !    The normal completion code is zero. ! implicit none integer ( kind = 4 ) n integer ( kind = 4 ) nv real ( kind = 8 ) a ( nv ) real ( kind = 8 ) fv1 ( n ) real ( kind = 8 ) fv2 ( n ) integer ( kind = 4 ) i integer ( kind = 4 ) ierr integer ( kind = 4 ) matz real ( kind = 8 ) w ( n ) real ( kind = 8 ) z ( n , n ) if ( ( n * ( n + 1 ) ) / 2 > nv ) then ierr = 20 * n return end if call tred3 ( n , nv , a , w , fv1 , fv2 ) if ( matz == 0 ) then call tqlrat ( n , w , fv2 , ierr ) if ( ierr /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'RSP - Fatal error!' write ( * , '(a)' ) '  Error return from TQLRAT.' return end if else z ( 1 : n , 1 : n ) = 0.0D+00 do i = 1 , n z ( i , i ) = 1.0D+00 end do call tql2 ( n , w , fv1 , z , ierr ) if ( ierr /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'RSP - Fatal error!' write ( * , '(a)' ) '  Error return from TQL2.' return end if call trbak3 ( n , nv , a , n , z ) end if return end subroutine rspp ( n , nv , a , w , matz , z , ierr , m , type ) !DEC$ ATTRIBUTES DLLEXPORT :: rspp !*****************************************************************************80 ! !! RSPP computes some eigenvalues/vectors, real symmetric packed matrix. ! !  Discussion: ! !    This routine calls the appropriate routines for the following problem: ! !    Given a symmetric matrix A, which is stored in a packed mode, find !    the M smallest or largest eigenvalues, and corresponding eigenvectors. ! !    The routine RSP returns all eigenvalues and eigenvectors. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of A, the number of rows and !    columns in the original matrix. ! !    Input, integer ( kind = 4 ) NV, is the of the array A as specified in the !    calling program.  NV must not be less than N*(N+1)/2. ! !    Input, real ( kind = 8 ) A((N*(N+1))/2), on input the lower triangle of the !    real symmetric matrix, stored row-wise in the vector, !    in the order A(1,1), / A(2,1), A(2,2), / A(3,1), A(3,2), A(3,3)/ !    and so on. ! !    Output, real ( kind = 8 ) W(M), the eigenvalues requested. ! !    Input, integer ( kind = 4 ) MATZ, is set to 0 if only eigenvalues are !    desired.  Otherwise it is set to any non-zero integer for both eigenvalues !    and eigenvectors. ! !    Output, real ( kind = 8 ) Z(N,M), the eigenvectors. ! !    Output, integer ( kind = 4 ) IERR, error flag from RATQR.  IERR=0 on !    normal return.  IERR nonzero, in this case, means that the algorithm broke !    down while computing an eigenvalue. ! !    Input, integer ( kind = 4 ) M, the number of eigenvalues to be found. ! !    Input, logical TYPE, set to .true. if the smallest eigenvalues !    are to be found, or .false. if the largest ones are sought. ! implicit none integer ( kind = 4 ) m integer ( kind = 4 ) n integer ( kind = 4 ) nv real ( kind = 8 ) a ( nv ) real ( kind = 8 ) bd ( n ) real ( kind = 8 ) eps1 integer ( kind = 4 ) idef integer ( kind = 4 ) ierr integer ( kind = 4 ) iwork ( n ) integer ( kind = 4 ) matz logical type real ( kind = 8 ) w ( m ) real ( kind = 8 ) work1 ( n ) real ( kind = 8 ) work2 ( n ) real ( kind = 8 ) work3 ( n ) real ( kind = 8 ) z ( n , m ) ! !  IDEF = !    -1 if the matrix is known to be negative definite, !    +1 if the matrix is known to be positive definite, or !    0 otherwise. ! idef = 0 ! !  Reduce to symmetric tridiagonal form. ! call tred3 ( n , nv , a , work1 , work2 , work3 ) ! !  Find the eigenvalues. ! eps1 = 0.0D+00 call ratqr ( n , eps1 , work1 , work2 , work3 , m , w , iwork , & bd , type , idef , ierr ) if ( ierr /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'RSPP - Fatal error!' write ( * , '(a)' ) '  Error return from RATQR.' return end if ! !  Find eigenvectors for the first M eigenvalues. ! if ( matz /= 0 ) then call tinvit ( n , work1 , work2 , work3 , m , w , iwork , z , ierr ) if ( ierr /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'RSPP - Fatal error!' write ( * , '(a)' ) '  Error return from TINVIT.' return end if ! !  Reverse the transformation. ! call trbak3 ( n , nv , a , m , z ) end if return end subroutine rst ( n , w , e , matz , z , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: rst !*****************************************************************************80 ! !! RST computes eigenvalues/vectors, real symmetric tridiagonal matrix. ! !  Discussion: ! !    This subroutine calls the recommended sequence of subroutines !    to find the eigenvalues and eigenvectors (if desired) !    of a real symmetric tridiagonal matrix. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input/output, real ( kind = 8 ) W(N).  On input, the diagonal elements !    of the real symmetric tridiagonal matrix.  On output, the eigenvalues in !    ascending order. ! !    Input, real ( kind = 8 ) E(N), the subdiagonal elements of the matrix in !    E(2:N).  E(1) is arbitrary. ! !    Input, integer ( kind = 4 ) MATZ, is zero if only eigenvalues are desired, !    and nonzero if both eigenvalues and eigenvectors are desired. ! !    Output, real ( kind = 8 ) Z(N,N), contains the eigenvectors, if MATZ !    is nonzero. ! !    Output, integer ( kind = 4 ) IERR, is set to an error !    completion code described in the documentation for IMTQL1 and IMTQL2. !    The normal completion code is zero. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) e ( n ) integer ( kind = 4 ) i integer ( kind = 4 ) ierr integer ( kind = 4 ) matz real ( kind = 8 ) w ( n ) real ( kind = 8 ) z ( n , n ) if ( matz == 0 ) then call imtql1 ( n , w , e , ierr ) if ( ierr /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'RST - Fatal error!' write ( * , '(a)' ) '  Error return from IMTQL1.' return end if else z ( 1 : n , 1 : n ) = 0.0D+00 do i = 1 , n z ( i , i ) = 1.0D+00 end do call imtql2 ( n , w , e , z , ierr ) if ( ierr /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'RST - Fatal error!' write ( * , '(a)' ) '  Error return from IMTQL2.' return end if end if return end subroutine rt ( n , a , w , matz , z , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: rt !*****************************************************************************80 ! !! RT computes eigenvalues/vectors, real sign-symmetric tridiagonal matrix. ! !  Discussion: ! !    This subroutine calls the recommended sequence of subroutines !    to find the eigenvalues and eigenvectors (if desired) !    of a special real tridiagonal matrix. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, real ( kind = 8 ) A(N,N), contains the special real tridiagonal !    matrix in its first three columns.  The subdiagonal elements are stored !    in the last N-1 positions of the first column, the diagonal elements !    in the second column, and the superdiagonal elements in the first N-1 !    positions of the third column.  Elements A(1,1) and A(N,3) are arbitrary. ! !    Input, integer ( kind = 4 ) MATZ, is 0 if only eigenvalues are desired, !    and nonzero if both eigenvalues and eigenvectors are desired. ! !    Output, real ( kind = 8 ) W(N), the eigenvalues in ascending order. ! !    Output, real ( kind = 8 ) Z(N,N), contains the eigenvectors, if MATZ !    is nonzero. ! !    Output, integer ( kind = 4 ) IERR, is set to an error !    completion code described in the documentation for IMTQL1 and IMTQL2. !    The normal completion code is zero. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) fv1 ( n ) integer ( kind = 4 ) ierr integer ( kind = 4 ) matz real ( kind = 8 ) a ( n , 3 ) real ( kind = 8 ) w ( n ) real ( kind = 8 ) z ( n , n ) if ( matz == 0 ) then call figi ( n , a , w , fv1 , fv1 , ierr ) if ( ierr /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'RT - Fatal error!' write ( * , '(a)' ) '  Error return from FIGI.' return end if call imtql1 ( n , w , fv1 , ierr ) if ( ierr /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'RT - Fatal error!' write ( * , '(a)' ) '  Error return from IMTQL1.' return end if else call figi2 ( n , a , w , fv1 , z , ierr ) if ( ierr /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'RT - Fatal error!' write ( * , '(a)' ) '  Error return from FIGI2.' return end if call imtql2 ( n , w , fv1 , z , ierr ) if ( ierr /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'RT - Fatal error!' write ( * , '(a)' ) '  Error return from IMTQL2.' return end if end if return end subroutine svd ( m , n , a , w , matu , u , matv , v , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: svd !*****************************************************************************80 ! !! SVD computes the singular value decomposition for a real matrix. ! !  Discussion: ! !    This subroutine determines the singular value decomposition ! !      A = U * S * V' ! !    of a real M by N rectangular matrix.  Householder bidiagonalization !    and a variant of the QR algorithm are used. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Golub and Reinsch, !    Numerische Mathematik, !    Volume 14, 1970, pages 403-420. ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) M, the number of rows of A and U. ! !    Input, integer ( kind = 4 ) N, the number of columns of A and U, and !    the order of V. ! !    Input, real ( kind = 8 ) A(M,N), the M by N matrix to be decomposed. ! !    Output, real ( kind = 8 ) W(N), the singular values of A.  These are the !    diagonal elements of S.  They are unordered.  If an error exit is !    made, the singular values should be correct for indices !    IERR+1, IERR+2,..., N. ! !    Input, logical MATU, should be set to TRUE if the U matrix in the !    decomposition is desired, and to FALSE otherwise. ! !    Output, real ( kind = 8 ) U(M,N), contains the matrix U, with orthogonal !    columns, of the decomposition, if MATU has been set to TRUE.  Otherwise !    U is used as a temporary array.  U may coincide with A. !    If an error exit is made, the columns of U corresponding !    to indices of correct singular values should be correct. ! !    Input, logical MATV, should be set to TRUE if the V matrix in the !    decomposition is desired, and to FALSE otherwise. ! !    Output, real ( kind = 8 ) V(N,N), the orthogonal matrix V of the decomposition if !    MATV has been set to TRUE.  Otherwise V is not referenced. !    V may also coincide with A if U is not needed.  If an error !    exit is made, the columns of V corresponding to indices of !    correct singular values should be correct. ! !    Output, integer ( kind = 4 ) IERR, error flag. !    0, for normal return, !    K, if the K-th singular value has not been determined after 30 iterations. ! implicit none integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( m , n ) real ( kind = 8 ) c real ( kind = 8 ) f real ( kind = 8 ) g real ( kind = 8 ) h integer ( kind = 4 ) i integer ( kind = 4 ) ierr integer ( kind = 4 ) its integer ( kind = 4 ) i1 integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) kk integer ( kind = 4 ) k1 integer ( kind = 4 ) l integer ( kind = 4 ) ll integer ( kind = 4 ) l1 logical matu logical matv integer ( kind = 4 ) mn real ( kind = 8 ) pythag real ( kind = 8 ) rv1 ( n ) real ( kind = 8 ) s real ( kind = 8 ) scale real ( kind = 8 ) tst1 real ( kind = 8 ) tst2 real ( kind = 8 ) u ( m , n ) real ( kind = 8 ) v ( n , n ) real ( kind = 8 ) w ( n ) real ( kind = 8 ) x real ( kind = 8 ) y real ( kind = 8 ) z ierr = 0 u ( 1 : m , 1 : n ) = a ( 1 : m , 1 : n ) ! !  Householder reduction to bidiagonal form. ! g = 0.0D+00 scale = 0.0D+00 x = 0.0D+00 do i = 1 , n l = i + 1 rv1 ( i ) = scale * g g = 0.0D+00 s = 0.0D+00 scale = 0.0D+00 if ( i <= m ) then scale = sum ( abs ( u ( i : m , i ) ) ) if ( scale /= 0.0D+00 ) then u ( i : m , i ) = u ( i : m , i ) / scale s = sum ( u ( i : m , i ) ** 2 ) f = u ( i , i ) g = - sign ( sqrt ( s ), f ) h = f * g - s u ( i , i ) = f - g if ( i /= n ) then do j = l , n s = dot_product ( u ( i : m , i ), u ( i : m , j ) ) u ( i : m , j ) = u ( i : m , j ) + s * u ( i : m , i ) / h end do end if u ( i : m , i ) = scale * u ( i : m , i ) end if end if w ( i ) = scale * g g = 0.0D+00 s = 0.0D+00 scale = 0.0D+00 if ( i <= m . and . i /= n ) then scale = sum ( abs ( u ( i , l : n ) ) ) if ( scale /= 0.0D+00 ) then u ( i , l : n ) = u ( i , l : n ) / scale s = sum ( u ( i , l : n ) ** 2 ) f = u ( i , l ) g = - sign ( sqrt ( s ), f ) h = f * g - s u ( i , l ) = f - g rv1 ( l : n ) = u ( i , l : n ) / h if ( i /= m ) then do j = l , m s = dot_product ( u ( j , l : n ), u ( i , l : n ) ) u ( j , l : n ) = u ( j , l : n ) + s * rv1 ( l : n ) end do end if u ( i , l : n ) = scale * u ( i , l : n ) end if end if x = max ( x , abs ( w ( i ) ) + abs ( rv1 ( i ) ) ) end do ! !  Accumulation of right-hand transformations. ! if ( matv ) then do i = n , 1 , - 1 if ( i /= n ) then if ( g /= 0.0D+00 ) then v ( l : n , i ) = ( u ( i , l : n ) / u ( i , l ) ) / g do j = l , n s = dot_product ( u ( i , l : n ), v ( l : n , j ) ) v ( l : n , j ) = v ( l : n , j ) + s * v ( l : n , i ) end do end if v ( i , l : n ) = 0.0D+00 v ( l : n , i ) = 0.0D+00 end if v ( i , i ) = 1.0D+00 g = rv1 ( i ) l = i end do end if ! !  Accumulation of left-hand transformations. ! if ( matu ) then mn = min ( m , n ) do i = min ( m , n ), 1 , - 1 l = i + 1 g = w ( i ) if ( i /= n ) then u ( i , l : n ) = 0.0D+00 end if if ( g /= 0.0D+00 ) then if ( i /= mn ) then do j = l , n s = dot_product ( u ( l : m , i ), u ( l : m , j ) ) f = ( s / u ( i , i ) ) / g u ( i : m , j ) = u ( i : m , j ) + f * u ( i : m , i ) end do end if u ( i : m , i ) = u ( i : m , i ) / g else u ( i : m , i ) = 0.0D+00 end if u ( i , i ) = u ( i , i ) + 1.0D+00 end do end if ! !  Diagonalization of the bidiagonal form. ! tst1 = x do kk = 1 , n k1 = n - kk k = k1 + 1 its = 0 ! !  Test for splitting. ! 520 continue do ll = 1 , k l1 = k - ll l = l1 + 1 tst2 = tst1 + abs ( rv1 ( l ) ) if ( tst2 == tst1 ) then go to 565 end if tst2 = tst1 + abs ( w ( l1 ) ) if ( tst2 == tst1 ) then exit end if end do ! !  Cancellation of rv1(l) if L greater than 1. ! c = 0.0D+00 s = 1.0D+00 do i = l , k f = s * rv1 ( i ) rv1 ( i ) = c * rv1 ( i ) tst2 = tst1 + abs ( f ) if ( tst2 == tst1 ) then go to 565 end if g = w ( i ) h = pythag ( f , g ) w ( i ) = h c = g / h s = - f / h if ( matu ) then do j = 1 , m y = u ( j , l1 ) z = u ( j , i ) u ( j , l1 ) = y * c + z * s u ( j , i ) = - y * s + z * c end do end if end do ! !  Test for convergence. ! 565 continue z = w ( k ) if ( l == k ) go to 650 ! !  Shift from bottom 2 by 2 minor. ! if ( its >= 30 ) then ierr = k return end if its = its + 1 x = w ( l ) y = w ( k1 ) g = rv1 ( k1 ) h = rv1 ( k ) f = 0.5D+00 * ( ( ( g + z ) / h ) * ( ( g - z ) / y ) + y / h - h / y ) g = pythag ( f , 1.0D+00 ) f = x - ( z / x ) * z + ( h / x ) * ( y / ( f + sign ( g , f ) ) - h ) ! !  Next QR transformation. ! c = 1.0D+00 s = 1.0D+00 do i1 = l , k1 i = i1 + 1 g = rv1 ( i ) y = w ( i ) h = s * g g = c * g z = pythag ( f , h ) rv1 ( i1 ) = z c = f / z s = h / z f = x * c + g * s g = - x * s + g * c h = y * s y = y * c if ( matv ) then do j = 1 , n x = v ( j , i1 ) z = v ( j , i ) v ( j , i1 ) = x * c + z * s v ( j , i ) = - x * s + z * c end do end if z = pythag ( f , h ) w ( i1 ) = z ! !  Rotation can be arbitrary if Z is zero. ! if ( z /= 0.0D+00 ) then c = f / z s = h / z end if f = c * g + s * y x = - s * g + c * y if ( matu ) then do j = 1 , m y = u ( j , i1 ) z = u ( j , i ) u ( j , i1 ) = y * c + z * s u ( j , i ) = - y * s + z * c end do end if end do rv1 ( l ) = 0.0D+00 rv1 ( k ) = f w ( k ) = x go to 520 ! !  Convergence. ! 650 continue if ( z <= 0.0D+00 ) then w ( k ) = - z if ( matv ) then v ( 1 : n , k ) = - v ( 1 : n , k ) end if end if end do return end subroutine timestamp ( ) !DEC$ ATTRIBUTES DLLEXPORT :: timestamp !*****************************************************************************80 ! !! TIMESTAMP prints the current YMDHMS date as a time stamp. ! !  Example: ! !    May 31 2001   9:45:54.872 AM ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    04 February 2003 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    None ! implicit none character ( len = 8 ) ampm integer ( kind = 4 ) d character ( len = 8 ) date integer ( kind = 4 ) h integer ( kind = 4 ) m integer ( kind = 4 ) mm character ( len = 9 ), parameter , dimension ( 12 ) :: month = ( / & 'January  ' , 'February ' , 'March    ' , 'April    ' , & 'May      ' , 'June     ' , 'July     ' , 'August   ' , & 'September' , 'October  ' , 'November ' , 'December ' / ) integer ( kind = 4 ) n integer ( kind = 4 ) s character ( len = 10 ) time integer ( kind = 4 ) values ( 8 ) integer ( kind = 4 ) y character ( len = 5 ) zone call date_and_time ( date , time , zone , values ) y = values ( 1 ) m = values ( 2 ) d = values ( 3 ) h = values ( 5 ) n = values ( 6 ) s = values ( 7 ) mm = values ( 8 ) if ( h < 12 ) then ampm = 'AM' else if ( h == 12 ) then if ( n == 0 . and . s == 0 ) then ampm = 'Noon' else ampm = 'PM' end if else h = h - 12 if ( h < 12 ) then ampm = 'PM' else if ( h == 12 ) then if ( n == 0 . and . s == 0 ) then ampm = 'Midnight' else ampm = 'AM' end if end if end if write ( * , '(a,1x,i2,1x,i4,2x,i2,a1,i2.2,a1,i2.2,a1,i3.3,1x,a)' ) & trim ( month ( m ) ), d , y , h , ':' , n , ':' , s , '.' , mm , trim ( ampm ) return end subroutine tinvit ( n , d , e , e2 , m , w , ind , z , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: tinvit !*****************************************************************************80 ! !! TINVIT computes eigenvectors from eigenvalues, real tridiagonal symmetric. ! !  Discussion: ! !    This subroutine finds those eigenvectors of a tridiagonal !    symmetric matrix corresponding to specified eigenvalues, !    using inverse iteration. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. !    B Smith, J Boyle, J Dongarra, B Garbow, Y Ikebe, V Klema, C Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, real ( kind = 8 ) D(N), the diagonal elements of the matrix. ! !    Input, real ( kind = 8 ) E(N), contains the subdiagonal elements of the input matrix !    in E(2:N).  E(1) is arbitrary. ! !    Input, real ( kind = 8 ) E2(N), contains the squares of the corresponding elements !    of E, with zeros corresponding to negligible elements of E. !    E(I) is considered negligible if it is not larger than the product of !    the relative machine precision and the sum of the magnitudes of D(I) !    and D(I-1).  E2(1) must contain 0.0D+00 if the eigenvalues are in !    ascending order, or 2.0D+00 if the eigenvalues are in descending order. !    If BISECT, TRIDIB, or IMTQLV has been used to find the eigenvalues, !    their output E2 array is exactly what is expected here. ! !    Input, integer ( kind = 4 ) M, the number of specified eigenvalues. ! !    Input, real ( kind = 8 ) W(M), the eigenvalues. ! !    Input, integer ( kind = 4 ) IND(M), the submatrix indices associated with the !    corresponding eigenvalues in W: 1 for eigenvalues belonging to the !    first submatrix from the top, 2 for those belonging to the second !    submatrix, and so on. ! !    Output, real ( kind = 8 ) Z(N,M), the associated set of orthonormal eigenvectors. !    Any vector which fails to converge is set to zero. ! !    Output, integer ( kind = 4 ) IERR, error flag. !    0, for normal return, !    -R, if the eigenvector corresponding to the R-th eigenvalue fails to !      converge in 5 iterations. ! implicit none integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) d ( n ) real ( kind = 8 ) e ( n ) real ( kind = 8 ) e2 ( n ) real ( kind = 8 ) eps2 real ( kind = 8 ) eps3 real ( kind = 8 ) eps4 integer ( kind = 4 ) group integer ( kind = 4 ) i integer ( kind = 4 ) ierr integer ( kind = 4 ) ii integer ( kind = 4 ) ind ( m ) integer ( kind = 4 ) ip integer ( kind = 4 ) its integer ( kind = 4 ) j integer ( kind = 4 ) jj real ( kind = 8 ) norm real ( kind = 8 ) order integer ( kind = 4 ) p real ( kind = 8 ) pythag integer ( kind = 4 ) q integer ( kind = 4 ) r real ( kind = 8 ) rv1 ( n ) real ( kind = 8 ) rv2 ( n ) real ( kind = 8 ) rv3 ( n ) real ( kind = 8 ) rv4 ( n ) real ( kind = 8 ) rv6 ( n ) integer ( kind = 4 ) s integer ( kind = 4 ) tag real ( kind = 8 ) u real ( kind = 8 ) uk real ( kind = 8 ) v real ( kind = 8 ) w ( m ) real ( kind = 8 ) x0 real ( kind = 8 ) x1 real ( kind = 8 ) xu real ( kind = 8 ) z ( n , m ) ierr = 0 if ( m == 0 ) then return end if u = 0.0D+00 x0 = 0.0D+00 tag = 0 order = 1.0D+00 - e2 ( 1 ) q = 0 ! !  Establish and process next submatrix. ! 100 continue p = q + 1 do q = p , n if ( q == n ) then exit end if if ( e2 ( q + 1 ) == 0.0D+00 ) then exit end if end do ! !  Find vectors by inverse iteration. ! 140 continue tag = tag + 1 s = 0 do r = 1 , m if ( ind ( r ) /= tag ) go to 920 its = 1 x1 = w ( r ) if ( s /= 0 ) go to 510 ! !  Check for isolated root. ! xu = 1.0D+00 if ( p == q ) then rv6 ( p ) = 1.0D+00 go to 870 end if norm = abs ( d ( p ) ) ip = p + 1 do i = p + 1 , q norm = max ( norm , abs ( d ( i ) ) + abs ( e ( i ) ) ) end do ! !  EPS2 is the criterion for grouping, !  EPS3 replaces zero pivots and equal roots are modified by EPS3, !  EPS4 is taken very small to avoid overflow. ! eps2 = 0.001D+00 * norm eps3 = abs ( norm ) * epsilon ( eps3 ) uk = q - p + 1 eps4 = uk * eps3 uk = eps4 / sqrt ( uk ) s = p 505 continue group = 0 go to 520 ! !  Look for close or coincident roots. ! 510 continue if ( abs ( x1 - x0 ) >= eps2 ) go to 505 group = group + 1 if ( order * ( x1 - x0 ) <= 0.0D+00 ) then x1 = x0 + order * eps3 end if ! !  Elimination with interchanges and initialization of vector. ! 520 continue v = 0.0D+00 do i = p , q rv6 ( i ) = uk if ( i == p ) go to 560 if ( abs ( e ( i ) ) < abs ( u ) ) go to 540 xu = u / e ( i ) rv4 ( i ) = xu rv1 ( i - 1 ) = e ( i ) rv2 ( i - 1 ) = d ( i ) - x1 rv3 ( i - 1 ) = 0.0D+00 if ( i /= q ) rv3 ( i - 1 ) = e ( i + 1 ) u = v - xu * rv2 ( i - 1 ) v = - xu * rv3 ( i - 1 ) go to 580 540 continue xu = e ( i ) / u rv4 ( i ) = xu rv1 ( i - 1 ) = u rv2 ( i - 1 ) = v rv3 ( i - 1 ) = 0.0D+00 560 continue u = d ( i ) - x1 - xu * v if ( i /= q ) v = e ( i + 1 ) 580 continue end do if ( u == 0.0D+00 ) then u = eps3 end if rv1 ( q ) = u rv2 ( q ) = 0.0D+00 rv3 ( q ) = 0.0D+00 ! !  Back substitution. ! 600 continue do ii = p , q i = p + q - ii rv6 ( i ) = ( rv6 ( i ) - u * rv2 ( i ) - v * rv3 ( i ) ) / rv1 ( i ) v = u u = rv6 ( i ) end do ! !  Orthogonalize with respect to previous members of group. ! j = r do jj = 1 , group do j = j - 1 if ( ind ( j ) == tag ) then exit end if end do xu = dot_product ( rv6 ( p : q ), z ( p : q , j ) ) rv6 ( p : q ) = rv6 ( p : q ) - xu * z ( p : q , j ) end do norm = sum ( abs ( rv6 ( p : q ) ) ) if ( norm >= 1.0D+00 ) go to 840 ! !  Forward substitution. ! if ( its == 5 ) go to 830 if ( norm == 0.0D+00 ) then rv6 ( s ) = eps4 s = s + 1 if ( s > q ) s = p go to 780 end if 740 continue xu = eps4 / norm rv6 ( p : q ) = rv6 ( p : q ) * xu ! !  Elimination operations on next vector iterate. ! 780 continue ! !  If RV1(I-1) == E(I), a row interchange was performed earlier in the !  triangularization process. ! do i = ip , q u = rv6 ( i ) if ( rv1 ( i - 1 ) == e ( i ) ) then u = rv6 ( i - 1 ) rv6 ( i - 1 ) = rv6 ( i ) end if rv6 ( i ) = u - rv4 ( i ) * rv6 ( i - 1 ) end do its = its + 1 go to 600 ! !  Set error: non-converged eigenvector. ! 830 continue ierr = - r xu = 0.0D+00 go to 870 ! !  Normalize so that sum of squares is 1 and expand to full order. ! 840 continue u = 0.0D+00 do i = p , q u = pythag ( u , rv6 ( i ) ) end do xu = 1.0D+00 / u 870 continue z ( 1 : n , r ) = 0.0D+00 z ( p : q , r ) = rv6 ( p : q ) * xu x0 = x1 920 continue end do if ( q < n ) go to 100 return end subroutine tql1 ( n , d , e , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: tql1 !*****************************************************************************80 ! !! TQL1 computes all eigenvalues of a real symmetric tridiagonal matrix. ! !  Discussion: ! !    This subroutine finds the eigenvalues of a symmetric tridiagonal !    matrix by the QL method. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  References: ! !    Bowdler, Martin, Reinsch, Wilkinson, !    Numerische Mathematik, !    Volume 11, 1968, pages 293-306. ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, is the order of the matrix. ! !    Input/output, real ( kind = 8 ) D(N). !    On input, the diagonal elements of the matrix. !    On output, the eigenvalues in ascending order. !    If an error exit is made, the eigenvalues are correct and !    ordered for indices 1, 2,... IERR-1, but may not be !    the smallest eigenvalues. ! !    Input/output, real ( kind = 8 ) E(N).  On input, E(2:N) contains the subdiagonal !    elements of the input matrix, and E(1) is arbitrary. !    On output, E has been destroyed. ! !    Output, integer ( kind = 4 ) IERR, error flag. !    0, normal return, !    J, if the J-th eigenvalue has not been determined after !    30 iterations. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) c real ( kind = 8 ) c2 real ( kind = 8 ) c3 real ( kind = 8 ) d ( n ) real ( kind = 8 ) dl1 real ( kind = 8 ) e ( n ) real ( kind = 8 ) el1 real ( kind = 8 ) f real ( kind = 8 ) g real ( kind = 8 ) h integer ( kind = 4 ) i integer ( kind = 4 ) ierr integer ( kind = 4 ) ii integer ( kind = 4 ) j integer ( kind = 4 ) l integer ( kind = 4 ) l1 integer ( kind = 4 ) l2 integer ( kind = 4 ) m integer ( kind = 4 ) mml real ( kind = 8 ) p real ( kind = 8 ) pythag real ( kind = 8 ) r real ( kind = 8 ) s real ( kind = 8 ) s2 real ( kind = 8 ) tst1 real ( kind = 8 ) tst2 ierr = 0 if ( n == 1 ) then return end if do i = 2 , n e ( i - 1 ) = e ( i ) end do f = 0.0D+00 tst1 = 0.0D+00 e ( n ) = 0.0D+00 do l = 1 , n j = 0 h = abs ( d ( l ) ) + abs ( e ( l ) ) tst1 = max ( tst1 , h ) ! !  Look for a small sub-diagonal element. ! do m = l , n tst2 = tst1 + abs ( e ( m ) ) if ( tst2 == tst1 ) then exit end if end do if ( m == l ) go to 210 130 continue if ( j >= 30 ) then ierr = l return end if j = j + 1 ! !  Form the shift. ! l1 = l + 1 l2 = l1 + 1 g = d ( l ) p = ( d ( l1 ) - g ) / ( 2.0D+00 * e ( l ) ) r = pythag ( p , 1.0D+00 ) d ( l ) = e ( l ) / ( p + sign ( r , p ) ) d ( l1 ) = e ( l ) * ( p + sign ( r , p ) ) dl1 = d ( l1 ) h = g - d ( l ) d ( l2 : n ) = d ( l2 : n ) - h f = f + h ! !  QL transformation. ! p = d ( m ) c = 1.0D+00 c2 = c el1 = e ( l1 ) s = 0.0D+00 mml = m - l do ii = 1 , mml c3 = c2 c2 = c s2 = s i = m - ii g = c * e ( i ) h = c * p r = pythag ( p , e ( i ) ) e ( i + 1 ) = s * r s = e ( i ) / r c = p / r p = c * d ( i ) - s * g d ( i + 1 ) = h + s * ( c * g + s * d ( i ) ) end do p = - s * s2 * c3 * el1 * e ( l ) / dl1 e ( l ) = s * p d ( l ) = c * p tst2 = tst1 + abs ( e ( l ) ) if ( tst2 > tst1 ) go to 130 210 continue p = d ( l ) + f ! !  Order the eigenvalues. ! do ii = 2 , l i = l + 2 - ii if ( p >= d ( i - 1 ) ) then go to 270 end if d ( i ) = d ( i - 1 ) end do i = 1 270 continue d ( i ) = p end do return end subroutine tql2 ( n , d , e , z , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: tql2 !*****************************************************************************80 ! !! TQL2 computes all eigenvalues/vectors, real symmetric tridiagonal matrix. ! !  Discussion: ! !    This subroutine finds the eigenvalues and eigenvectors of a symmetric !    tridiagonal matrix by the QL method.  The eigenvectors of a full !    symmetric matrix can also be found if TRED2 has been used to reduce this !    full matrix to tridiagonal form. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Bowdler, Martin, Reinsch, Wilkinson, !    TQL2, !    Numerische Mathematik, !    Volume 11, pages 293-306, 1968. ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input/output, real ( kind = 8 ) D(N).  On input, the diagonal elements of the matrix. !    On output, the eigenvalues in ascending order.  If an error exit is !    made, the eigenvalues are correct but unordered for indices 1,2,...,IERR-1. ! !    Input/output, real ( kind = 8 ) E(N).  On input, E(2:N) contains the subdiagonal !    elements of the input matrix, and E(1) is arbitrary. !    On output, E has been destroyed. ! !    Input, real ( kind = 8 ) Z(N,N).  On input, the transformation matrix produced in !    the reduction by TRED2, if performed.  If the eigenvectors of the !    tridiagonal matrix are desired, Z must contain the identity matrix. !    On output, Z contains the orthonormal eigenvectors of the symmetric !    tridiagonal (or full) matrix.  If an error exit is made, Z contains !    the eigenvectors associated with the stored eigenvalues. ! !    Output, integer ( kind = 4 ) IERR, error flag. !    0, normal return, !    J, if the J-th eigenvalue has not been determined after !    30 iterations. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) c real ( kind = 8 ) c2 real ( kind = 8 ) c3 real ( kind = 8 ) d ( n ) real ( kind = 8 ) dl1 real ( kind = 8 ) e ( n ) real ( kind = 8 ) el1 real ( kind = 8 ) f real ( kind = 8 ) g real ( kind = 8 ) h integer ( kind = 4 ) i integer ( kind = 4 ) ierr integer ( kind = 4 ) ii integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) l integer ( kind = 4 ) l1 integer ( kind = 4 ) l2 integer ( kind = 4 ) m integer ( kind = 4 ) mml real ( kind = 8 ) p real ( kind = 8 ) pythag real ( kind = 8 ) r real ( kind = 8 ) s real ( kind = 8 ) s2 real ( kind = 8 ) tst1 real ( kind = 8 ) tst2 real ( kind = 8 ) z ( n , n ) ! ierr = 0 if ( n == 1 ) then return end if do i = 2 , n e ( i - 1 ) = e ( i ) end do f = 0.0D+00 tst1 = 0.0D+00 e ( n ) = 0.0D+00 do l = 1 , n j = 0 h = abs ( d ( l ) ) + abs ( e ( l ) ) tst1 = max ( tst1 , h ) ! !  Look for a small sub-diagonal element. ! do m = l , n tst2 = tst1 + abs ( e ( m ) ) if ( tst2 == tst1 ) then exit end if end do if ( m == l ) go to 220 130 continue if ( j >= 30 ) then ierr = l return end if j = j + 1 ! !  Form shift. ! l1 = l + 1 l2 = l1 + 1 g = d ( l ) p = ( d ( l1 ) - g ) / ( 2.0D+00 * e ( l ) ) r = pythag ( p , 1.0D+00 ) d ( l ) = e ( l ) / ( p + sign ( r , p ) ) d ( l1 ) = e ( l ) * ( p + sign ( r , p ) ) dl1 = d ( l1 ) h = g - d ( l ) d ( l2 : n ) = d ( l2 : n ) - h f = f + h ! !  QL transformation. ! p = d ( m ) c = 1.0D+00 c2 = c el1 = e ( l1 ) s = 0.0D+00 mml = m - l do ii = 1 , mml c3 = c2 c2 = c s2 = s i = m - ii g = c * e ( i ) h = c * p r = pythag ( p , e ( i ) ) e ( i + 1 ) = s * r s = e ( i ) / r c = p / r p = c * d ( i ) - s * g d ( i + 1 ) = h + s * ( c * g + s * d ( i ) ) ! !  Form vector. ! do k = 1 , n h = z ( k , i + 1 ) z ( k , i + 1 ) = s * z ( k , i ) + c * h z ( k , i ) = c * z ( k , i ) - s * h end do end do p = - s * s2 * c3 * el1 * e ( l ) / dl1 e ( l ) = s * p d ( l ) = c * p tst2 = tst1 + abs ( e ( l ) ) if ( tst2 > tst1 ) then go to 130 end if 220 continue d ( l ) = d ( l ) + f end do ! !  Order eigenvalues and eigenvectors. ! do ii = 2 , n i = ii - 1 k = i p = d ( i ) do j = ii , n if ( d ( j ) < p ) then k = j p = d ( j ) end if end do if ( k /= i ) then d ( k ) = d ( i ) d ( i ) = p do j = 1 , n call r8_swap ( z ( j , i ), z ( j , k ) ) end do end if end do return end subroutine tqlrat ( n , d , e2 , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: tqlrat !*****************************************************************************80 ! !! TQLRAT computes all eigenvalues of a real symmetric tridiagonal matrix. ! !  Discussion: ! !    This subroutine finds the eigenvalues of a symmetric !    tridiagonal matrix by the rational QL method. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    C Reinsch, !    Algorithm 464, TQLRAT, !    Communications of the ACM, !    Volume 16, page 689, 1973. ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input/output, real ( kind = 8 ) D(N).  On input, D contains the diagonal elements !    of the matrix.  On output, D contains the eigenvalues in ascending !    order.  If an error exit was made, then the eigenvalues are correct !    in positions 1 through IERR-1, but may not be the smallest eigenvalues. ! !    Input/output, real ( kind = 8 ) E2(N), contains in positions 2 through N the !    squares of the subdiagonal elements of the matrix.  E2(1) is !    arbitrary.  On output, E2 has been overwritten by workspace !    information. ! !    Output, integer ( kind = 4 ) IERR, error flag. !    0, for no error, !    J, if the J-th eigenvalue could not be determined after 30 iterations. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) b real ( kind = 8 ) c real ( kind = 8 ) d ( n ) real ( kind = 8 ) e2 ( n ) real ( kind = 8 ) f real ( kind = 8 ) g real ( kind = 8 ) h integer ( kind = 4 ) i integer ( kind = 4 ) ierr integer ( kind = 4 ) ii integer ( kind = 4 ) j integer ( kind = 4 ) l integer ( kind = 4 ) l1 integer ( kind = 4 ) m integer ( kind = 4 ) mml real ( kind = 8 ) p real ( kind = 8 ) pythag real ( kind = 8 ) r real ( kind = 8 ) s real ( kind = 8 ) t ierr = 0 if ( n == 1 ) then return end if do i = 2 , n e2 ( i - 1 ) = e2 ( i ) end do f = 0.0D+00 t = 0.0D+00 e2 ( n ) = 0.0D+00 do l = 1 , n j = 0 h = abs ( d ( l ) ) + sqrt ( e2 ( l ) ) if ( t <= h ) then t = h b = abs ( t ) * epsilon ( b ) c = b * b end if ! !  Look for small squared sub-diagonal element. ! do m = l , n if ( e2 ( m ) <= c ) then exit end if end do if ( m == l ) go to 210 130 continue if ( j >= 30 ) then ierr = l return end if j = j + 1 ! !  Form shift. ! l1 = l + 1 s = sqrt ( e2 ( l ) ) g = d ( l ) p = ( d ( l1 ) - g ) / ( 2.0D+00 * s ) r = pythag ( p , 1.0D+00 ) d ( l ) = s / ( p + sign ( r , p ) ) h = g - d ( l ) d ( l1 : n ) = d ( l1 : n ) - h f = f + h ! !  Rational QL transformation. ! g = d ( m ) if ( g == 0.0D+00 ) g = b h = g s = 0.0D+00 mml = m - l do ii = 1 , mml i = m - ii p = g * h r = p + e2 ( i ) e2 ( i + 1 ) = s * r s = e2 ( i ) / r d ( i + 1 ) = h + s * ( h + d ( i ) ) g = d ( i ) - e2 ( i ) / g if ( g == 0.0D+00 ) g = b h = g * p / r end do e2 ( l ) = s * g d ( l ) = h ! !  Guard against underflow in convergence test. ! if ( h == 0.0D+00 ) go to 210 if ( abs ( e2 ( l ) ) <= abs ( c / h ) ) go to 210 e2 ( l ) = h * e2 ( l ) if ( e2 ( l ) /= 0.0D+00 ) go to 130 210 continue p = d ( l ) + f ! !  Order the eigenvalues. ! do ii = 2 , l i = l + 2 - ii if ( p >= d ( i - 1 ) ) go to 270 d ( i ) = d ( i - 1 ) end do 250 continue i = 1 270 continue d ( i ) = p 290 continue end do return end subroutine trbak1 ( n , a , e , m , z ) !DEC$ ATTRIBUTES DLLEXPORT :: trbak1 !*****************************************************************************80 ! !! TRBAK1 determines eigenvectors by undoing the TRED1 transformation. ! !  Discussion: ! !    This subroutine forms the eigenvectors of a real symmetric !    matrix by back transforming those of the corresponding !    symmetric tridiagonal matrix determined by TRED1. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, real ( kind = 8 ) A(N,N), contains information about the orthogonal !    transformations used in the reduction by TRED1 in its strict lower !    triangle. ! !    Input, real ( kind = 8 ) E(N), the subdiagonal elements of the tridiagonal !    matrix in E(2:N).  E(1) is arbitrary. ! !    Input, integer ( kind = 4 ) M, the number of eigenvectors to be back transformed. ! !    Input/output, real ( kind = 8 ) Z(N,M).  On input, the eigenvectors to be back !    transformed.  On output, the transformed eigenvectors. ! implicit none integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( n , n ) real ( kind = 8 ) e ( n ) integer ( kind = 4 ) i integer ( kind = 4 ) j !  integer ( kind = 4 ) k integer ( kind = 4 ) l real ( kind = 8 ) s real ( kind = 8 ) z ( n , m ) if ( m <= 0 ) then return end if if ( n <= 1 ) then return end if do i = 2 , n l = i - 1 if ( e ( i ) /= 0.0D+00 ) then do j = 1 , m s = dot_product ( a ( i , 1 : l ), z ( 1 : l , j ) ) s = ( s / a ( i , l ) ) / e ( i ) z ( 1 : l , j ) = z ( 1 : l , j ) + s * a ( i , 1 : l ) end do end if end do continue return end subroutine trbak3 ( n , nv , a , m , z ) !DEC$ ATTRIBUTES DLLEXPORT :: trbak3 !*****************************************************************************80 ! !! TRBAK3 determines eigenvectors by undoing the TRED3 transformation. ! !  Discussion: ! !    This subroutine forms the eigenvectors of a real symmetric !    matrix by back transforming those of the corresponding !    symmetric tridiagonal matrix determined by TRED3. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, integer ( kind = 4 ) NV, the dimension of the array paramater A, !    which must be at least N*(N+1)/2. ! !    Input, real ( kind = 8 ) A(NV), information about the orthogonal transformations !    used in the reduction by TRED3. ! !    Input, integer ( kind = 4 ) M, the number of eigenvectors to be back transformed. ! !    Input/output, real ( kind = 8 ) Z(N,M).  On input, the eigenvectors to be back !    transformed.  On output, the transformed eigenvectors. ! implicit none integer ( kind = 4 ) m integer ( kind = 4 ) nv real ( kind = 8 ) a ( nv ) real ( kind = 8 ) h integer ( kind = 4 ) i integer ( kind = 4 ) ik integer ( kind = 4 ) iz integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) l integer ( kind = 4 ) n real ( kind = 8 ) s real ( kind = 8 ) z ( n , m ) if ( m == 0 ) then return end if do i = 2 , n l = i - 1 iz = ( i * l ) / 2 ik = iz + i h = a ( ik ) if ( h /= 0.0D+00 ) then do j = 1 , m s = 0.0D+00 ik = iz do k = 1 , l ik = ik + 1 s = s + a ( ik ) * z ( k , j ) end do s = ( s / h ) / h ik = iz do k = 1 , l ik = ik + 1 z ( k , j ) = z ( k , j ) - s * a ( ik ) end do end do end if end do return end subroutine tred1 ( n , a , d , e , e2 ) !DEC$ ATTRIBUTES DLLEXPORT :: tred1 !*****************************************************************************80 ! !! TRED1 transforms a real symmetric matrix to symmetric tridiagonal form. ! !  Discussion: ! !    The routine reduces a real symmetric matrix to a symmetric !    tridiagonal matrix using orthogonal similarity transformations. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Martin, Reinsch, Wilkinson, !    TRED1, !    Numerische Mathematik, !    Volume 11, pages 181-195, 1968. ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix A. ! !    Input/output, real ( kind = 8 ) A(N,N), on input, contains the real symmetric matrix. !    Only the lower triangle of the matrix need be supplied. !    On output, A contains information about the orthogonal transformations !    used in the reduction in its strict lower triangle. !    The full upper triangle of A is unaltered. ! !    Output, real ( kind = 8 ) D(N), contains the diagonal elements of the tridiagonal !    matrix. ! !    Output, real ( kind = 8 ) E(N), contains the subdiagonal elements of the tridiagonal !    matrix in its last n-1 positions.  e(1) is set to zero. ! !    Output, real ( kind = 8 ) E2(N), contains the squares of the corresponding !    elements of E.  E2 may coincide with E if the squares are not needed. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) a ( n , n ) real ( kind = 8 ) d ( n ) real ( kind = 8 ) e ( n ) real ( kind = 8 ) e2 ( n ) real ( kind = 8 ) f real ( kind = 8 ) g real ( kind = 8 ) h integer ( kind = 4 ) i integer ( kind = 4 ) ii integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) l real ( kind = 8 ) scale d ( 1 : n ) = a ( n , 1 : n ) do i = 1 , n a ( n , i ) = a ( i , i ) end do do ii = 1 , n i = n + 1 - ii l = i - 1 h = 0.0D+00 ! !  Scale row. ! scale = sum ( abs ( d ( 1 : l ) ) ) if ( scale == 0.0D+00 ) then do j = 1 , l d ( j ) = a ( l , j ) a ( l , j ) = a ( i , j ) a ( i , j ) = 0.0D+00 end do e ( i ) = 0.0D+00 e2 ( i ) = 0.0D+00 cycle end if d ( 1 : l ) = d ( 1 : l ) / scale do k = 1 , l h = h + d ( k ) ** 2 end do e2 ( i ) = h * scale ** 2 f = d ( l ) g = - sign ( sqrt ( h ), f ) e ( i ) = scale * g h = h - f * g d ( l ) = f - g if ( l >= 1 ) then ! !  Form A * U. ! e ( 1 : l ) = 0.0D+00 do j = 1 , l f = d ( j ) g = e ( j ) + a ( j , j ) * f do k = j + 1 , l g = g + a ( k , j ) * d ( k ) e ( k ) = e ( k ) + a ( k , j ) * f end do e ( j ) = g end do ! !  Form P. ! f = 0.0D+00 do j = 1 , l e ( j ) = e ( j ) / h f = f + e ( j ) * d ( j ) end do h = f / ( h + h ) ! !  Form Q. ! e ( 1 : l ) = e ( 1 : l ) - h * d ( 1 : l ) ! !  Form reduced A. ! do j = 1 , l f = d ( j ) g = e ( j ) a ( j : l , j ) = a ( j : l , j ) - f * e ( j : l ) - g * d ( j : l ) end do end if do j = 1 , l f = d ( j ) d ( j ) = a ( l , j ) a ( l , j ) = a ( i , j ) a ( i , j ) = f * scale end do end do return end subroutine tred2 ( n , a , d , e , z ) !DEC$ ATTRIBUTES DLLEXPORT :: tred2 !*****************************************************************************80 ! !! TRED2 transforms a real symmetric matrix to symmetric tridiagonal form. ! !  Discussion: ! !    This subroutine reduces a real symmetric matrix to a !    symmetric tridiagonal matrix using and accumulating !    orthogonal similarity transformations. ! !    A and Z may coincide, in which case a single storage area is used !    for the input of A and the output of Z. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Martin, Reinsch, Wilkinson, !    TRED2, !    Numerische Mathematik, !    Volume 11, pages 181-195, 1968. ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, real ( kind = 8 ) A(N,N), the real symmetric input matrix.  Only the !    lower triangle of the matrix need be supplied. ! !    Output, real ( kind = 8 ) D(N), the diagonal elements of the tridiagonal matrix. ! !    Output, real ( kind = 8 ) E(N), contains the subdiagonal elements of the tridiagonal !    matrix in E(2:N).  E(1) is set to zero. ! !    Output, real ( kind = 8 ) Z(N,N), the orthogonal transformation matrix produced !    in the reduction. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) a ( n , n ) real ( kind = 8 ) d ( n ) real ( kind = 8 ) e ( n ) real ( kind = 8 ) f real ( kind = 8 ) g real ( kind = 8 ) h real ( kind = 8 ) hh integer ( kind = 4 ) i integer ( kind = 4 ) ii integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) l real ( kind = 8 ) scale real ( kind = 8 ) z ( n , n ) do i = 1 , n z ( i : n , i ) = a ( i : n , i ) end do d ( 1 : n ) = a ( n , 1 : n ) do ii = 2 , n i = n + 2 - ii l = i - 1 h = 0.0D+00 scale = 0.0D+00 ! !  Scale row. ! do k = 1 , l scale = scale + abs ( d ( k ) ) end do if ( scale == 0.0D+00 ) then e ( i ) = d ( l ) do j = 1 , l d ( j ) = z ( l , j ) z ( i , j ) = 0.0D+00 z ( j , i ) = 0.0D+00 end do go to 290 end if d ( 1 : l ) = d ( 1 : l ) / scale h = h + dot_product ( d ( 1 : l ), d ( 1 : l ) ) f = d ( l ) g = - sign ( sqrt ( h ), f ) e ( i ) = scale * g h = h - f * g d ( l ) = f - g ! !  Form A*U. ! e ( 1 : l ) = 0.0D+00 do j = 1 , l f = d ( j ) z ( j , i ) = f g = e ( j ) + z ( j , j ) * f do k = j + 1 , l g = g + z ( k , j ) * d ( k ) e ( k ) = e ( k ) + z ( k , j ) * f end do e ( j ) = g end do ! !  Form P. ! e ( 1 : l ) = e ( 1 : l ) / h f = dot_product ( e ( 1 : l ), d ( 1 : l ) ) hh = 0.5D+00 * f / h ! !  Form Q. ! e ( 1 : l ) = e ( 1 : l ) - hh * d ( 1 : l ) ! !  Form reduced A. ! do j = 1 , l f = d ( j ) g = e ( j ) z ( j : l , j ) = z ( j : l , j ) - f * e ( j : l ) - g * d ( j : l ) d ( j ) = z ( l , j ) z ( i , j ) = 0.0D+00 end do 290 continue d ( i ) = h end do ! !  Accumulation of transformation matrices. ! do i = 2 , n l = i - 1 z ( n , l ) = z ( l , l ) z ( l , l ) = 1.0D+00 h = d ( i ) if ( h /= 0.0D+00 ) then d ( 1 : l ) = z ( 1 : l , i ) / h do j = 1 , l g = dot_product ( z ( 1 : l , i ), z ( 1 : l , j ) ) do k = 1 , l z ( k , j ) = z ( k , j ) - g * d ( k ) end do end do end if z ( 1 : l , i ) = 0.0D+00 end do d ( 1 : n ) = z ( n , 1 : n ) z ( n , 1 : n - 1 ) = 0.0D+00 z ( n , n ) = 1.0D+00 e ( 1 ) = 0.0D+00 return end subroutine tred3 ( n , nv , a , d , e , e2 ) !DEC$ ATTRIBUTES DLLEXPORT :: tred3 !*****************************************************************************80 ! !! TRED3 transforms a real symmetric packed matrix to symmetric tridiagonal form. ! !  Discussion: ! !    This subroutine reduces a real symmetric matrix, stored as !    a one-dimensional array, to a symmetric tridiagonal matrix !    using orthogonal similarity transformations. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Martin, Reinsch, Wilkinson, !    TRED3, !    Numerische Mathematik, !    Volume 11, pages 181-195, 1968. ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input, integer ( kind = 4 ) NV, the dimension of A, which must be at least !    (N*(N+1))/2. ! !    Input/output, real ( kind = 8 ) A(NV).  On input, the lower triangle of the real !    symmetric matrix, stored row-wise.  On output, information about the !    orthogonal transformations used in the reduction. ! !    Output, real ( kind = 8 ) D(N), the diagonal elements of the tridiagonal matrix. ! !    Output, real ( kind = 8 ) E(N), the subdiagonal elements of the tridiagonal !    matrix in E(2:N).  E(1) is set to zero. ! !    Output, real ( kind = 8 ) E2(N),  the squares of the corresponding elements of E. !    E2 may coincide with E if the squares are not needed. ! implicit none integer ( kind = 4 ) n integer ( kind = 4 ) nv real ( kind = 8 ) a ( nv ) real ( kind = 8 ) d ( n ) real ( kind = 8 ) e ( n ) real ( kind = 8 ) e2 ( n ) real ( kind = 8 ) f real ( kind = 8 ) g real ( kind = 8 ) h real ( kind = 8 ) hh integer ( kind = 4 ) i integer ( kind = 4 ) ii integer ( kind = 4 ) iz integer ( kind = 4 ) j integer ( kind = 4 ) jk integer ( kind = 4 ) k integer ( kind = 4 ) l real ( kind = 8 ) scale do ii = 1 , n i = n + 1 - ii l = i - 1 iz = ( i * l ) / 2 h = 0.0D+00 scale = 0.0D+00 ! !  Scale row. ! do k = 1 , l iz = iz + 1 d ( k ) = a ( iz ) scale = scale + abs ( d ( k ) ) end do if ( scale == 0.0D+00 ) then e ( i ) = 0.0D+00 e2 ( i ) = 0.0D+00 go to 290 end if do k = 1 , l d ( k ) = d ( k ) / scale h = h + d ( k ) ** 2 end do e2 ( i ) = scale * scale * h f = d ( l ) g = - sign ( sqrt ( h ), f ) e ( i ) = scale * g h = h - f * g d ( l ) = f - g a ( iz ) = scale * d ( l ) if ( l == 1 ) go to 290 jk = 1 do j = 1 , l f = d ( j ) g = 0.0D+00 do k = 1 , j - 1 g = g + a ( jk ) * d ( k ) e ( k ) = e ( k ) + a ( jk ) * f jk = jk + 1 end do e ( j ) = g + a ( jk ) * f jk = jk + 1 end do ! !  Form P. ! e ( 1 : l ) = e ( 1 : l ) / h f = dot_product ( e ( 1 : l ), d ( 1 : l ) ) hh = f / ( h + h ) ! !  Form Q. ! e ( 1 : l ) = e ( 1 : l ) - hh * d ( 1 : l ) jk = 1 ! !  Form reduced A. ! do j = 1 , l f = d ( j ) g = e ( j ) do k = 1 , j a ( jk ) = a ( jk ) - f * e ( k ) - g * d ( k ) jk = jk + 1 end do end do 290 continue d ( i ) = a ( iz + 1 ) a ( iz + 1 ) = scale * sqrt ( h ) 300 continue end do return end subroutine tridib ( n , eps1 , d , e , e2 , lb , ub , m11 , m , w , ind , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: tridib !*****************************************************************************80 ! !! TRIDIB computes some eigenvalues of a real symmetric tridiagonal matrix. ! !  Discussion: ! !    This subroutine finds those eigenvalues of a tridiagonal !    symmetric matrix between specified boundary indices, !    using bisection. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input/output, real ( kind = 8 ) EPS1.  On input, an absolute error tolerance for !    the computed eigenvalues.  It should be chosen commensurate with !    relative perturbations in the matrix elements of the order of the !    relative machine precision.  If the input EPS1 is non-positive, it !    is reset for each submatrix to a default value, namely, minus the !    product of the relative machine precision and the 1-norm of the submatrix. ! !    Input, real ( kind = 8 ) D(N), the diagonal elements of the input matrix. ! !    Input, real ( kind = 8 ) E(N), the subdiagonal elements of the input matrix !    in E(2:N).  E(1) is arbitrary. ! !    Input/output, real ( kind = 8 ) E2(N).  On input, the squares of the corresponding !    elements of E.  E2(1) is arbitrary.  On output, elements of E2 !    corresponding to elements of E regarded as negligible, have been !    replaced by zero, causing the matrix to split into a direct sum of !    submatrices.  E2(1) is also set to zero. ! !    Input, integer ( kind = 4 ) M11, the lower boundary index for the desired eigenvalues. ! !    Input, integer ( kind = 4 ) M, the number of eigenvalues desired.  The upper !    boundary index M22 is then obtained as M22 = M11 + M - 1. ! !    Output, real ( kind = 8 ) LB, UB, define an interval containing exactly the desired !    eigenvalues. ! !    Output, real ( kind = 8 ) W(M), the eigenvalues between indices M11 and M22 !    in ascending order. ! !    Output, integer ( kind = 4 ) IND(M), the submatrix indices associated with the !    corresponding eigenvalues in W: 1 for eigenvalues belonging to the !    first submatrix from the top, 2 for those belonging to the second !    submatrix, and so on. ! !    Output, integer ( kind = 4 ) IERR, error flag. !    0, for normal return, !    3*N+1, if multiple eigenvalues at index M11 make unique selection !      impossible, !    3*N+2, if multiple eigenvalues at index M22 make unique selection !      impossible. ! implicit none integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) d ( n ) real ( kind = 8 ) e ( n ) real ( kind = 8 ) e2 ( n ) real ( kind = 8 ) eps1 integer ( kind = 4 ) i integer ( kind = 4 ) ierr integer ( kind = 4 ) ii integer ( kind = 4 ) ind ( m ) integer ( kind = 4 ) isturm integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) l real ( kind = 8 ) lb integer ( kind = 4 ) m1 integer ( kind = 4 ) m11 integer ( kind = 4 ) m2 integer ( kind = 4 ) m22 integer ( kind = 4 ) p integer ( kind = 4 ) q integer ( kind = 4 ) r real ( kind = 8 ) rv4 ( n ) real ( kind = 8 ) rv5 ( n ) integer ( kind = 4 ) s real ( kind = 8 ) t1 real ( kind = 8 ) t2 integer ( kind = 4 ) tag real ( kind = 8 ) tst1 real ( kind = 8 ) tst2 real ( kind = 8 ) u real ( kind = 8 ) ub real ( kind = 8 ) v real ( kind = 8 ) w ( m ) real ( kind = 8 ) x0 real ( kind = 8 ) x1 real ( kind = 8 ) xu ierr = 0 tag = 0 xu = d ( 1 ) x0 = d ( 1 ) s = 0 u = 0.0D+00 ! !  Look for small sub-diagonal entries and determine an !  interval containing all the eigenvalues. ! do i = 1 , n x1 = u if ( i == n ) then u = 0.0D+00 else u = abs ( e ( i + 1 ) ) end if xu = min ( xu , d ( i ) - ( x1 + u ) ) x0 = max ( x0 , d ( i ) + ( x1 + u ) ) if ( i >= 1 ) then tst1 = abs ( d ( i ) ) + abs ( d ( i - 1 ) ) tst2 = tst1 + abs ( e ( i ) ) if ( tst2 <= tst1 ) then e2 ( i ) = 0.0D+00 end if else e2 ( i ) = 0.0D+00 end if end do x1 = n x1 = x1 * max ( abs ( xu ), abs ( x0 ) ) * epsilon ( x1 ) xu = xu - x1 t1 = xu x0 = x0 + x1 t2 = x0 ! !  Determine an interval containing exactly the desired eigenvalues. ! p = 1 q = n m1 = m11 - 1 if ( m1 == 0 ) go to 75 isturm = 1 50 continue v = x1 x1 = xu + ( x0 - xu ) * 0.5D+00 if ( x1 == v ) go to 980 go to 320 60 continue if ( s - m1 ) 65 , 73 , 70 65 continue xu = x1 go to 50 70 continue x0 = x1 go to 50 73 continue xu = x1 t1 = x1 75 continue m22 = m1 + m if ( m22 == n ) go to 90 x0 = t2 isturm = 2 go to 50 80 continue if ( s - m22 ) 65 , 85 , 70 85 continue t2 = x1 90 continue q = 0 r = 0 ! !  Establish and process next submatrix, refining interval by the !  Gerschgorin bounds. ! 100 continue if ( r == m ) then go to 1001 end if tag = tag + 1 p = q + 1 xu = d ( p ) x0 = d ( p ) u = 0.0D+00 do q = p , n x1 = u u = 0.0D+00 v = 0.0D+00 if ( q < n ) then u = abs ( e ( q + 1 ) ) v = e2 ( q + 1 ) end if xu = min ( d ( q ) - ( x1 + u ), xu ) x0 = max ( d ( q ) + ( x1 + u ), x0 ) if ( v == 0.0D+00 ) then exit end if end do x1 = max ( abs ( xu ), abs ( x0 ) ) * epsilon ( x1 ) if ( eps1 <= 0.0D+00 ) eps1 = - x1 if ( p /= q ) go to 180 ! !  Check for isolated root within interval. ! if ( t1 > d ( p ) . or . d ( p ) >= t2 ) go to 940 m1 = p m2 = p rv5 ( p ) = d ( p ) go to 900 180 continue x1 = x1 * ( q - p + 1 ) lb = max ( t1 , xu - x1 ) ub = min ( t2 , x0 + x1 ) x1 = lb isturm = 3 go to 320 200 continue m1 = s + 1 x1 = ub isturm = 4 go to 320 220 continue m2 = s if ( m1 > m2 ) go to 940 ! !  Find roots by bisection. ! x0 = ub isturm = 5 rv5 ( m1 : m2 ) = ub rv4 ( m1 : m2 ) = lb ! !  Loop for the K-th eigenvalue. ! k = m2 250 continue xu = lb do ii = m1 , k i = m1 + k - ii if ( xu < rv4 ( i ) ) then xu = rv4 ( i ) exit end if end do if ( x0 > rv5 ( k ) ) x0 = rv5 ( k ) ! !  Next bisection step. ! 300 continue x1 = ( xu + x0 ) * 0.5D+00 if ( ( x0 - xu ) <= abs ( eps1 ) ) go to 420 tst1 = 2.0D+00 * ( abs ( xu ) + abs ( x0 ) ) tst2 = tst1 + ( x0 - xu ) if ( tst2 == tst1 ) go to 420 ! !  Sturm sequence. ! 320 continue s = p - 1 u = 1.0D+00 do i = p , q if ( u == 0.0D+00 ) then v = abs ( e ( i ) ) / epsilon ( v ) if ( e2 ( i ) == 0.0D+00 ) v = 0.0D+00 else v = e2 ( i ) / u end if u = d ( i ) - x1 - v if ( u < 0.0D+00 ) then s = s + 1 end if end do go to ( 60 , 80 , 200 , 220 , 360 ), isturm ! !  Refine intervals. ! 360 continue if ( s >= k ) go to 400 xu = x1 if ( s >= m1 ) go to 380 rv4 ( m1 ) = x1 go to 300 380 continue rv4 ( s + 1 ) = x1 if ( rv5 ( s ) > x1 ) rv5 ( s ) = x1 go to 300 400 continue x0 = x1 go to 300 ! !  K-th eigenvalue found. ! 420 continue rv5 ( k ) = x1 k = k - 1 if ( k >= m1 ) go to 250 ! !  Order eigenvalues tagged with their submatrix associations. ! 900 continue s = r r = r + m2 - m1 + 1 j = 1 k = m1 do l = 1 , r if ( j > s ) go to 910 if ( k > m2 ) go to 940 if ( rv5 ( k ) >= w ( l ) ) go to 915 do ii = j , s i = l + s - ii w ( i + 1 ) = w ( i ) ind ( i + 1 ) = ind ( i ) end do 910 continue w ( l ) = rv5 ( k ) ind ( l ) = tag k = k + 1 go to 920 915 continue j = j + 1 920 continue end do 940 continue if ( q < n ) then go to 100 end if go to 1001 ! !  Set error: interval cannot be found containing exactly the !  desired eigenvalues. ! 980 continue ierr = 3 * n + isturm 1001 continue lb = t1 ub = t2 return end subroutine tsturm ( n , eps1 , d , e , e2 , lb , ub , mm , m , w , z , ierr ) !DEC$ ATTRIBUTES DLLEXPORT :: tsturm !*****************************************************************************80 ! !! TSTURM computes some eigenvalues/vectors, real symmetric tridiagonal matrix. ! !  Discussion: ! !    This subroutine finds those eigenvalues of a tridiagonal !    symmetric matrix which lie in a specified interval and their !    associated eigenvectors, using bisection and inverse iteration. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    18 October 2009 ! !  Author: ! !    Original FORTRAN77 version by Smith, Boyle, Dongarra, Garbow, Ikebe, !    Klema, Moler. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    James Wilkinson, Christian Reinsch, !    Handbook for Automatic Computation, !    Volume II, Linear Algebra, Part 2, !    Springer, 1971, !    ISBN: 0387054146, !    LC: QA251.W67. ! !    Brian Smith, James Boyle, Jack Dongarra, Burton Garbow, !    Yasuhiko Ikebe, Virginia Klema, Cleve Moler, !    Matrix Eigensystem Routines, EISPACK Guide, !    Lecture Notes in Computer Science, Volume 6, !    Springer Verlag, 1976, !    ISBN13: 978-3540075462, !    LC: QA193.M37. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix. ! !    Input/output, real ( kind = 8 ) EPS1.  On input, an absolute error tolerance for !    the computed eigenvalues.  It should be chosen commensurate with !    relative perturbations in the matrix elements of the order of the !    relative machine precision.  If the input EPS1 is non-positive, it !    is reset for each submatrix to a default value, namely, minus the !    product of the relative machine precision and the 1-norm of the submatrix. ! !    Input, real ( kind = 8 ) D(N), the diagonal elements of the input matrix. ! !    Input, real ( kind = 8 ) E(N), the subdiagonal elements of the input matrix !    in E(2:N).  E(1) is arbitrary. ! !    Input/output, real ( kind = 8 ) E2(N).  On input, the squares of the corresponding !    elements of E.  E2(1) is arbitrary.  On output, elements of E2 !    corresponding to elements of E regarded as negligible have been !    replaced by zero, causing the matrix to split into a direct sum of !    submatrices.  E2(1) is also set to zero. ! !    Input, real ( kind = 8 ) LB, UB, define the interval to be searched for eigenvalues. !    If LB is not less than UB, no eigenvalues will be found. ! !    Input, integer ( kind = 4 ) MM, an upper bound for the number of eigenvalues in !    the interval.  If more than MM eigenvalues are determined to lie in !    the interval, an error return is made with no values or vectors found. ! !    Output, integer ( kind = 4 ) M, the number of eigenvalues determined to lie !    in (LB, UB). ! !    Output, real ( kind = 8 ) W(M), the eigenvalues in ascending order if the matrix !    does not split.  If the matrix splits, the eigenvalues are in ascending !    order for each submatrix.  If a vector error exit is made, W contains !    those values already found. ! !    Output, real ( kind = 8 ) Z(N,MM), the associated set of orthonormal eigenvectors. !    If an error exit is made, Z contains those vectors already found. ! !    Output, integer ( kind = 4 ) IERR, error flag. !    0, normal return. !    3*N+1, if M exceeds MM. !    4*N+R, if the eigenvector corresponding to the R-th !      eigenvalue fails to converge in 5 iterations. ! implicit none integer ( kind = 4 ) mm integer ( kind = 4 ) n real ( kind = 8 ) d ( n ) real ( kind = 8 ) e ( n ) real ( kind = 8 ) e2 ( n ) real ( kind = 8 ) eps1 real ( kind = 8 ) eps2 real ( kind = 8 ) eps3 real ( kind = 8 ) eps4 integer ( kind = 4 ) group integer ( kind = 4 ) i integer ( kind = 4 ) ierr integer ( kind = 4 ) ii integer ( kind = 4 ) ip integer ( kind = 4 ) isturm integer ( kind = 4 ) its integer ( kind = 4 ) j integer ( kind = 4 ) jj integer ( kind = 4 ) k real ( kind = 8 ) lb integer ( kind = 4 ) m integer ( kind = 4 ) m1 integer ( kind = 4 ) m2 real ( kind = 8 ) norm integer ( kind = 4 ) p real ( kind = 8 ) pythag integer ( kind = 4 ) q integer ( kind = 4 ) r real ( kind = 8 ) rv1 ( n ) real ( kind = 8 ) rv2 ( n ) real ( kind = 8 ) rv3 ( n ) real ( kind = 8 ) rv4 ( n ) real ( kind = 8 ) rv5 ( n ) real ( kind = 8 ) rv6 ( n ) integer ( kind = 4 ) s real ( kind = 8 ) t1 real ( kind = 8 ) t2 real ( kind = 8 ) tst1 real ( kind = 8 ) tst2 real ( kind = 8 ) u real ( kind = 8 ) ub real ( kind = 8 ) uk real ( kind = 8 ) v real ( kind = 8 ) w ( mm ) real ( kind = 8 ) x0 real ( kind = 8 ) x1 real ( kind = 8 ) xu real ( kind = 8 ) z ( n , mm ) ierr = 0 s = 0 t1 = lb t2 = ub ! !  Look for small sub-diagonal entries. ! e2 ( 1 ) = 0.0D+00 do i = 2 , n tst1 = abs ( d ( i ) ) + abs ( d ( i - 1 ) ) tst2 = tst1 + abs ( e ( i ) ) if ( tst2 <= tst1 ) then e2 ( i ) = 0.0D+00 end if end do ! !  Determine the number of eigenvalues in the interval. ! p = 1 q = n x1 = ub isturm = 1 go to 320 60 continue m = s x1 = lb isturm = 2 go to 320 80 continue m = m - s if ( m > mm ) go to 980 q = 0 r = 0 ! !  Establish and process next submatrix, refining interval by the !  Gerschgorin bounds. ! 100 continue if ( r == m ) go to 1001 p = q + 1 xu = d ( p ) x0 = d ( p ) u = 0.0D+00 do q = p , n x1 = u u = 0.0D+00 v = 0.0D+00 if ( q /= n ) then u = abs ( e ( q + 1 ) ) v = e2 ( q + 1 ) end if xu = min ( d ( q ) - ( x1 + u ), xu ) x0 = max ( d ( q ) + ( x1 + u ), x0 ) if ( v == 0.0D+00 ) then exit end if end do x1 = max ( abs ( xu ), abs ( x0 ) ) * epsilon ( x1 ) if ( eps1 <= 0.0D+00 ) then eps1 = - x1 end if if ( p /= q ) go to 180 ! !  Check for isolated root within interval. ! if ( t1 > d ( p ) . or . d ( p ) >= t2 ) go to 940 r = r + 1 z ( 1 : n , r ) = 0.0D+00 w ( r ) = d ( p ) z ( p , r ) = 1.0D+00 go to 940 180 continue u = q - p + 1 x1 = u * x1 lb = max ( t1 , xu - x1 ) ub = min ( t2 , x0 + x1 ) x1 = lb isturm = 3 go to 320 200 continue m1 = s + 1 x1 = ub isturm = 4 go to 320 220 continue m2 = s if ( m1 > m2 ) go to 940 ! !  Find roots by bisection. ! x0 = ub isturm = 5 rv5 ( m1 : m2 ) = ub rv4 ( m1 : m2 ) = lb ! !  Loop for K-th eigenvalue. ! k = m2 250 continue xu = lb do ii = m1 , k i = m1 + k - ii if ( xu < rv4 ( i ) ) then xu = rv4 ( i ) exit end if end do 280 continue if ( x0 > rv5 ( k ) ) x0 = rv5 ( k ) ! !  Next bisection step. ! 300 continue x1 = ( xu + x0 ) * 0.5D+00 if ( ( x0 - xu ) <= abs ( eps1 ) ) go to 420 tst1 = 2.0D+00 * ( abs ( xu ) + abs ( x0 ) ) tst2 = tst1 + ( x0 - xu ) if ( tst2 == tst1 ) go to 420 ! !  Sturm sequence. ! 320 continue s = p - 1 u = 1.0D+00 do i = p , q if ( u /= 0.0D+00 ) go to 325 v = abs ( e ( i ) ) / epsilon ( v ) if ( e2 ( i ) == 0.0D+00 ) v = 0.0D+00 go to 330 325 continue v = e2 ( i ) / u 330 continue u = d ( i ) - x1 - v if ( u < 0.0D+00 ) s = s + 1 end do go to ( 60 , 80 , 200 , 220 , 360 ), isturm ! !  Refine intervals. ! 360 continue if ( s >= k ) go to 400 xu = x1 if ( s >= m1 ) go to 380 rv4 ( m1 ) = x1 go to 300 380 continue rv4 ( s + 1 ) = x1 if ( rv5 ( s ) > x1 ) then rv5 ( s ) = x1 end if go to 300 400 continue x0 = x1 go to 300 ! !  K-th eigenvalue found. ! 420 continue rv5 ( k ) = x1 k = k - 1 if ( k >= m1 ) go to 250 ! !  Find vectors by inverse iteration. ! norm = abs ( d ( p ) ) ip = p + 1 do i = ip , q norm = max ( norm , abs ( d ( i ) ) + abs ( e ( i ) ) ) end do ! !  EPS2 is the criterion for grouping, !  EPS3 replaces zero pivots and equal roots are modified by eps3, !  EPS4 is taken very small to avoid overflow. ! eps2 = 0.001D+00 * norm eps3 = abs ( norm ) * epsilon ( eps3 ) uk = q - p + 1 eps4 = uk * eps3 uk = eps4 / sqrt ( uk ) group = 0 s = p do k = m1 , m2 r = r + 1 its = 1 w ( r ) = rv5 ( k ) x1 = rv5 ( k ) ! !  Look for close or coincident roots. ! if ( k /= m1 ) then if ( x1 - x0 >= eps2 ) group = - 1 group = group + 1 if ( x1 <= x0 ) then x1 = x0 + eps3 end if end if ! !  Elimination with interchanges and initialization of vector. ! 520 continue v = 0.0D+00 do i = p , q rv6 ( i ) = uk if ( i == p ) go to 560 if ( abs ( e ( i ) ) >= abs ( u ) ) then xu = u / e ( i ) rv4 ( i ) = xu rv1 ( i - 1 ) = e ( i ) rv2 ( i - 1 ) = d ( i ) - x1 rv3 ( i - 1 ) = 0.0D+00 if ( i /= q ) rv3 ( i - 1 ) = e ( i + 1 ) u = v - xu * rv2 ( i - 1 ) v = - xu * rv3 ( i - 1 ) cycle end if 540 continue xu = e ( i ) / u rv4 ( i ) = xu rv1 ( i - 1 ) = u rv2 ( i - 1 ) = v rv3 ( i - 1 ) = 0.0D+00 560 continue u = d ( i ) - x1 - xu * v if ( i /= q ) then v = e ( i + 1 ) end if end do if ( u == 0.0D+00 ) u = eps3 rv1 ( q ) = u rv2 ( q ) = 0.0D+00 rv3 ( q ) = 0.0D+00 ! !  Back substitution. ! 600 continue do ii = p , q i = p + q - ii rv6 ( i ) = ( rv6 ( i ) - u * rv2 ( i ) - v * rv3 ( i ) ) / rv1 ( i ) v = u u = rv6 ( i ) end do ! !  Orthogonalize with respect to previous members of group. ! do jj = 1 , group j = r - group - 1 + jj xu = dot_product ( rv6 ( p : q ), z ( p : q , j ) ) rv6 ( p : q ) = rv6 ( p : q ) - xu * z ( p : q , j ) end do 700 continue norm = sum ( abs ( rv6 ( p : q ) ) ) if ( norm >= 1.0D+00 ) then go to 840 end if ! !  Forward substitution. ! if ( its == 5 ) then ierr = 4 * n + r go to 1001 end if if ( norm == 0.0D+00 ) then rv6 ( s ) = eps4 s = s + 1 if ( s > q ) then s = p end if go to 780 end if 740 continue xu = eps4 / norm rv6 ( p : q ) = rv6 ( p : q ) * xu ! !  Elimination operations on next vector iterate. ! 780 continue ! !  If rv1(i-1) == e(i), a row interchange was performed earlier in the !  triangularization process. ! do i = p , q u = rv6 ( i ) if ( rv1 ( i - 1 ) == e ( i ) ) then u = rv6 ( i - 1 ) rv6 ( i - 1 ) = rv6 ( i ) end if rv6 ( i ) = u - rv4 ( i ) * rv6 ( i - 1 ) end do its = its + 1 go to 600 ! !  Normalize so that sum of squares is 1 and expand to full order. ! 840 continue u = 0.0D+00 do i = p , q u = pythag ( u , rv6 ( i ) ) end do xu = 1.0D+00 / u z ( 1 : n , r ) = 0.0D+00 z ( p : q , r ) = rv6 ( p : q ) * xu x0 = x1 end do 940 continue if ( q < n ) then go to 100 end if go to 1001 ! !  Set error: underestimate of number of eigenvalues in interval. ! 980 continue ierr = 3 * n + 1 1001 continue lb = t1 ub = t2 return end","tags":"","loc":"sourcefile/eispack.f90.html","title":"eispack.f90 – Fortran Program"},{"text":"This File Depends On sourcefile~~emdymod.f90~~EfferentGraph sourcefile~emdymod.f90 EMdymod.f90 sourcefile~indexingmod.f90 Indexingmod.f90 sourcefile~indexingmod.f90->sourcefile~emdymod.f90 sourcefile~timing.f90 timing.f90 sourcefile~timing.f90->sourcefile~emdymod.f90 sourcefile~filters.f90 filters.f90 sourcefile~filters.f90->sourcefile~emdymod.f90 sourcefile~initializers.f90 initializers.f90 sourcefile~initializers.f90->sourcefile~emdymod.f90 sourcefile~multibeams.f90 multibeams.f90 sourcefile~multibeams.f90->sourcefile~emdymod.f90 sourcefile~clsupport.f90 CLsupport.f90 sourcefile~clsupport.f90->sourcefile~emdymod.f90 sourcefile~clsupport.f90->sourcefile~indexingmod.f90 sourcefile~namelisttypedefs.f90 NameListTypedefs.f90 sourcefile~namelisttypedefs.f90->sourcefile~emdymod.f90 sourcefile~namelisttypedefs.f90->sourcefile~indexingmod.f90 sourcefile~distortion.f90 distortion.f90 sourcefile~distortion.f90->sourcefile~emdymod.f90 sourcefile~constants.f90 constants.f90 sourcefile~constants.f90->sourcefile~emdymod.f90 sourcefile~constants.f90->sourcefile~filters.f90 sourcefile~constants.f90->sourcefile~initializers.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files Dependent On This One sourcefile~~emdymod.f90~~AfferentGraph sourcefile~emdymod.f90 EMdymod.f90 sourcefile~simulated_annealing.f90 simulated_annealing.f90 sourcefile~emdymod.f90->sourcefile~simulated_annealing.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules EMdymod Source Code EMdymod.f90 Source Code ! ################################################################### ! Copyright (c) 2013-2016, Marc De Graef/Carnegie Mellon University ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without modification, are ! permitted provided that the following conditions are met: ! !     - Redistributions of source code must retain the above copyright notice, this list !        of conditions and the following disclaimer. !     - Redistributions in binary form must reproduce the above copyright notice, this !        list of conditions and the following disclaimer in the documentation and/or !        other materials provided with the distribution. !     - Neither the names of Marc De Graef, Carnegie Mellon University nor the names !        of its contributors may be used to endorse or promote products derived from !        this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE ! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ################################################################### !-------------------------------------------------------------------------- ! EMsoft:EMdymod.f90 !-------------------------------------------------------------------------- ! ! MODULE: EMdymod ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief routines that can be called by external code; all routines requiring HDF are in EMdymodHDF.f90 ! !> @date  10/16/15 MDG 1.0 original !> @date  01/11/16 MDG 2.0 split into this file and EMdymodHDF.f90 !> @date  01/12/16 MDG 2.1 added functionality for DREAM.3D progress callback and cancel option !> @date  01/13/16 MDG 2.2 name change of SingleEBSDPattern routine and split into two versions (C and other) !> @date  01/14/16 MDG 2.3 added EMsoftCgetECPatterns routine !> @date  01/25/16 MDG 2.4 several routine name changes !> @date  04/28/16 MDG 2.5 unified the ipar and fpar arrays for all C-callable routines !-------------------------------------------------------------------------- ! ! general information: the ipar and fpar arrays for all the routines that are C-callable ! are identical, so we document here their component definitions; to allow for future expansion, each ! array has 40 entries, of which about half are currently (April 2016) used. ! ! integer(kind=irg) :: ipar(40)  components ! ipar(1) : nx  = (numsx-1)/2 ! ipar(2) : globalworkgrpsz ! ipar(3) : num_el ! ipar(4) : totnum_el ! ipar(5) : multiplier ! ipar(6) : devid ! ipar(7) : platid ! ipar(8) : CrystalSystem ! ipar(9) : Natomtypes ! ipar(10): SpaceGroupNumber ! ipar(11): SpaceGroupSetting ! ipar(12): numEbins ! ipar(13): numzbins ! ipar(14): mcmode  ( 1 = 'full', 2 = 'bse1' ) ! ipar(15): numangle ! ipar(16): nxten = nx/10 ! the following are only used in the master routine ! ipar(17): npx ! ipar(18): nthreads ! the following are only used in the EBSD pattern routine ! ipar(19): numx of detector pixels ! ipar(20): numy of detector pixels ! ipar(21): number of orientation in quaternion set ! ipar(22): binning factor (0-3) ! ipar(23): binned x-dimension ! ipar(24): binned y-dimension ! ipar(25): anglemode  (0 for quaternions, 1 for Euler angles) ! ipar(26:40) : 0 (unused for now) ! real(kind=dbl) :: fpar(40)  components ! fpar(1) : sig ! fpar(2) : omega ! fpar(3) : EkeV ! fpar(4) : Ehistmin ! fpar(5) : Ebinsize ! fpar(6) : depthmax ! fpar(7) : depthstep ! fpar(8) : sigstart ! fpar(9) : sigend ! fpar(10): sigstep ! parameters only used in the master pattern routine ! fpar(11) : dmin ! fpar(12) : Bethe  c1 ! fpar(13) : Bethe  c2 ! fpar(14) : Bethe  c3 ! parameters only used in the EBSD pattern routine ! fpar(15): pattern center x ! fpar(16): pattern center y ! fpar(17): scintillator pixel size ! fpar(18): detector tilt angle ! fpar(19): sample-scintillator distance ! fpar(20): beam current ! fpar(21): dwelltime ! fpar(22): gamma value ! fpar(23:40): 0 (unused for now) ! module EMdymod !-------------------------------------------------------------------------- ! Callback routine(s) to communicate progress with DREAM.3D package ! Define interface of call-back routine ! arguments are: !  objAddress: unique 8-byte integer to identify the calling class in DREAM.3D !  patternCompleted: integer indicating the current pattern ID number ! ABSTRACT INTERFACE SUBROUTINE ProgressCallBack ( objAddress , patternCompleted ) USE , INTRINSIC :: ISO_C_BINDING INTEGER ( c_size_t ), INTENT ( IN ), VALUE :: objAddress INTEGER ( KIND = 4 ), INTENT ( IN ), VALUE :: patternCompleted END SUBROUTINE ProgressCallBack END INTERFACE ! similar callback routine, with two integer arguments ABSTRACT INTERFACE SUBROUTINE ProgressCallBack2 ( objAddress , loopCompleted , totalLoops , bseYield ) USE , INTRINSIC :: ISO_C_BINDING INTEGER ( c_size_t ), INTENT ( IN ), VALUE :: objAddress INTEGER ( KIND = 4 ), INTENT ( IN ), VALUE :: loopCompleted INTEGER ( KIND = 4 ), INTENT ( IN ), VALUE :: totalLoops REAL ( KIND = 4 ), INTENT ( IN ), VALUE :: bseYield END SUBROUTINE ProgressCallBack2 END INTERFACE ! similar callback routine, with two integer arguments ABSTRACT INTERFACE SUBROUTINE ProgressCallBack3 ( objAddress , loopCompleted , totalLoops , EloopCompleted , totalEloops ) USE , INTRINSIC :: ISO_C_BINDING INTEGER ( c_size_t ), INTENT ( IN ), VALUE :: objAddress INTEGER ( KIND = 4 ), INTENT ( IN ), VALUE :: loopCompleted INTEGER ( KIND = 4 ), INTENT ( IN ), VALUE :: totalLoops INTEGER ( KIND = 4 ), INTENT ( IN ), VALUE :: EloopCompleted INTEGER ( KIND = 4 ), INTENT ( IN ), VALUE :: totalELoops END SUBROUTINE ProgressCallBack3 END INTERFACE !-------------------------------------------------------------------------- contains !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- ! the first series of routines starting with EMsoftC are callable from C/C++ ! programs and can handle progress callback and a cancel request. !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- ! ! SUBROUTINE:EMsoftCgetEBSDPatterns ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief This subroutine can be called by a C/C++ program as a standalone function to compute EBSD patterns ! !> @details This subroutine provides a method to compute a series of EBSD patterns and !> can be called from an external C/C++ program; the routine provides a callback mechanism to !> update the calling program about computational progress, as well as a cancel option. !> The routine is intended to be called form a C/C++ program, e.g., DREAM.3D.  This routine is a simplified version !> of the core of the EMEBSD program. !> !> @param ipar array with integer input parameters !> @param fpar array with float input parameters !> @param EBSDpattern output array !> @param quats quaternion input array !> @param accum_e array with Monte Carlo histogram !> @param mLPNH Northern hemisphere master pattern !> @param mLPSH Southern hemisphere master pattern !> @param cproc pointer to a C-function for the callback process !> @param objAddress unique integer identifying the calling class in DREAM.3D !> @param cancel character defined by DREAM.3D; when not equal to NULL (i.e., char(0)), the computation should be halted ! !> @date 10/16/15 MDG 1.0 original !> @date 11/02/15 MDG 1.1 simplification of the input variables !> @date 11/04/15 MDG 1.2 added array of quaternions as input parameter; used complete mLPNH/SH arrays with local sum !> @date 01/12/16 MDG 1.3 added arguments and functionality for interface with DREAM.3D and other calling programs !> @date 01/13/16 MDG 2.0 forked from original SingleEBSDPattern routine; SAVE atrribute removed; ipar redefined (ipar(1) removed) !> @date 04/28/16 MDG 2.1 adjusted ipar and fpar components to new convention !> @date 06/12/16 MDG 2.2 correction for effective pixel area with respect to equal-area Lambert projection !> @date 07/01/16 MDG 2.3 correction of array subscripts in rgx/y/z arrays. !> @date 12/05/16 MDG 2.4 added option to pass in Euler angles instead of quaternions; quats array dimensions are unchanged !-------------------------------------------------------------------------- recursive subroutine EMsoftCgetEBSDPatterns ( ipar , fpar , EBSDpattern , quats , accum_e , mLPNH , mLPSH , cproc , objAddress , cancel ) & bind ( c , name = 'EMsoftCgetEBSDPatterns' ) ! this routine is callable from a C/C++ program !DEC$ ATTRIBUTES DLLEXPORT :: EMsoftCgetEBSDPatterns ! the input parameters are all part of a ipar and fpar input arrays instead of the usual namelist structure to ! make this routine callable by external programs, such as DREAM.3D ! The following is the mapping for the ipar and fpar array components used in this routine: ! ! ipar(1)  = mcnsx ! ipar(9)  = numset ! ipar(12) = detnumEbins ! ipar(17) = mpnpx ! ipar(19) = detnumsx ! ipar(20) = detnumsy ! ipar(21) = numquats ! ipar(22) = binning ! ipar(23) = binned x-dimension ! ipar(24) = binned y-dimension ! ipar(25) = anglemode ! fpar(1)  = enl%MCsig ! fpar(2)  = enl%omega ! fpar(15) = enl%xpc ! fpar(16) = enl%ypc ! fpar(17) = enl%delta ! fpar(18) = enl%thetac ! fpar(19) = enl%L ! fpar(20) = enl%beamcurrent ! fpar(21) = enl%dwelltime ! fpar(22) = gammavalue use local use constants use Lambert use quaternions use rotations use , INTRINSIC :: ISO_C_BINDING IMPLICIT NONE integer ( c_int32_t ), PARAMETER :: nipar = 40 integer ( c_int32_t ), PARAMETER :: nfpar = 40 integer ( c_int32_t ), INTENT ( IN ) :: ipar ( nipar ) real ( kind = sgl ), INTENT ( IN ) :: fpar ( nfpar ) integer ( c_int32_t ), PARAMETER :: nq = 4 real ( kind = sgl ), INTENT ( IN ) :: quats ( nq , ipar ( 21 )) integer ( c_int32_t ), INTENT ( IN ) :: accum_e ( ipar ( 12 ), - ipar ( 1 ): ipar ( 1 ), - ipar ( 1 ): ipar ( 1 )) real ( kind = sgl ), INTENT ( IN ) :: mLPNH ( - ipar ( 17 ): ipar ( 17 ), - ipar ( 17 ): ipar ( 17 ), ipar ( 12 ), ipar ( 9 )) real ( kind = sgl ), INTENT ( IN ) :: mLPSH ( - ipar ( 17 ): ipar ( 17 ), - ipar ( 17 ): ipar ( 17 ), ipar ( 12 ), ipar ( 9 )) real ( kind = sgl ), INTENT ( OUT ) :: EBSDpattern ( ipar ( 23 ), ipar ( 24 ), ipar ( 21 )) TYPE ( C_FUNPTR ), INTENT ( IN ), VALUE :: cproc integer ( c_size_t ), INTENT ( IN ), VALUE :: objAddress character ( len = 1 ), INTENT ( IN ) :: cancel ! various variables and arrays real ( kind = sgl ) :: fullsizepattern ( ipar ( 19 ), ipar ( 20 )), binned ( ipar ( 23 ), ipar ( 24 )) real ( kind = irg ), allocatable :: accum_e_detector (:,:,:) real ( kind = sgl ), allocatable :: rgx (:,:), rgy (:,:), rgz (:,:) real ( kind = sgl ), allocatable :: mLPNHsum (:,:,:), mLPSHsum (:,:,:) real ( kind = sgl ), save :: prefactor real ( kind = sgl ), allocatable :: scin_x (:), scin_y (:) ! scintillator coordinate arrays [microns] real ( kind = sgl ), parameter :: dtor = 0.0174533 ! convert from degrees to radians real ( kind = sgl ) :: alp , ca , sa , cw , sw , quat ( 4 ) real ( kind = sgl ) :: L2 , Ls , Lc ! distances integer ( kind = irg ) :: nix , niy , binx , biny , nixp , niyp , i , j , Emin , Emax , istat , k , ip , dn , cn , & ii , jj , binfac , ipx , ipy ! various parameters real ( kind = sgl ) :: dc ( 3 ), scl , alpha , theta , gam , pcvec ( 3 ), dp , calpha ! direction cosine array real ( kind = sgl ) :: sx , dx , dxm , dy , dym , rhos , x , bindx ! various parameters real ( kind = sgl ) :: ixy ( 2 ) real ( kind = dbl ), parameter :: nAmpere = 6.241D+18 PROCEDURE ( ProgressCallBack ), POINTER :: proc ! link the proc procedure to the cproc argument CALL C_F_PROCPOINTER ( cproc , proc ) ! binned pattern dimensions binx = ipar ( 23 ) biny = ipar ( 24 ) binfac = 2 ** ipar ( 22 ) bindx = 1.0 / float ( binfac ) ** 2 !==================================== ! ------ generate the detector rgx, rgy, rgz arrays (and a few others) !==================================== if ( allocated ( mLPNHsum )) deallocate ( mLPNHsum ) if ( allocated ( mLPSHsum )) deallocate ( mLPSHsum ) allocate ( mLPNHsum ( - ipar ( 17 ): ipar ( 17 ), - ipar ( 17 ): ipar ( 17 ), ipar ( 12 ))) allocate ( mLPSHsum ( - ipar ( 17 ): ipar ( 17 ), - ipar ( 17 ): ipar ( 17 ), ipar ( 12 ))) mLPNHsum = sum ( mLPNH , 4 ) mLPSHsum = sum ( mLPSH , 4 ) allocate ( scin_x ( ipar ( 19 )), scin_y ( ipar ( 20 )), stat = istat ) scin_x = - ( fpar ( 15 ) - ( 1.0 - float ( ipar ( 19 )) ) * 0.5 - ( / ( i - 1 , i = 1 , ipar ( 19 )) / ) ) * fpar ( 17 ) scin_y = ( fpar ( 16 ) - ( 1.0 - float ( ipar ( 20 )) ) * 0.5 - ( / ( i - 1 , i = 1 , ipar ( 20 )) / ) ) * fpar ( 17 ) ! auxiliary angle to rotate between reference frames alp = 0.5 * cPi - ( fpar ( 1 ) - fpar ( 18 )) * dtor ca = cos ( alp ) sa = sin ( alp ) cw = cos ( fpar ( 2 ) * dtor ) sw = sin ( fpar ( 2 ) * dtor ) ! compute auxilliary interpolation arrays if ( allocated ( rgx )) deallocate ( rgx , rgy , rgz ) allocate ( rgx ( ipar ( 19 ), ipar ( 20 )), rgy ( ipar ( 19 ), ipar ( 20 )), rgz ( ipar ( 19 ), ipar ( 20 ))) L2 = fpar ( 19 ) * fpar ( 19 ) do j = 1 , ipar ( 19 ) sx = L2 + scin_x ( j ) * scin_x ( j ) Ls = - sw * scin_x ( j ) + fpar ( 19 ) * cw Lc = cw * scin_x ( j ) + fpar ( 19 ) * sw do i = 1 , ipar ( 20 ) !   rhos = 1.0/sqrt(sx + scin_y(i)**2) rgx ( j , i ) = ( scin_y ( i ) * ca + sa * Ls ) ! * rhos rgy ( j , i ) = Lc ! * rhos rgz ( j , i ) = ( - sa * scin_y ( i ) + ca * Ls ) ! * rhos ! make sure that these vectors are normalized ! x = sqrt ( rgx ( j , i ) ** 2 + rgy ( j , i ) ** 2 + rgz ( j , i ) ** 2 ) rgx ( j , i ) = rgx ( j , i ) / x rgy ( j , i ) = rgy ( j , i ) / x rgz ( j , i ) = rgz ( j , i ) / x end do end do ! remove the auxiliary arrays scin_x and scin_y deallocate ( scin_x , scin_y ) !==================================== ! ------ create the equivalent detector energy array !==================================== ! from the Monte Carlo energy data, we need to extract the relevant ! entries for the detector geometry defined above. ! determine the scale factor for the Lambert interpolation; the square has ! an edge length of 2 x sqrt(pi/2) scl = float ( ipar ( 1 )) ! energy summation will go over all energy bins Emin = 1 Emax = ipar ( 12 ) if ( allocated ( accum_e_detector )) deallocate ( accum_e_detector ) allocate ( accum_e_detector ( ipar ( 12 ), ipar ( 19 ), ipar ( 20 ))) ! correction of change in effective pixel area compared to equal-area Lambert projection alpha = atan ( fpar ( 17 ) / fpar ( 19 ) / sqrt ( sngl ( cPi ))) ipx = ipar ( 19 ) / 2 + nint ( fpar ( 15 )) ipy = ipar ( 20 ) / 2 + nint ( fpar ( 16 )) if ( ipx . gt . ipar ( 19 )) ipx = ipar ( 19 ) if ( ipx . lt . 1 ) ipx = 1 if ( ipy . gt . ipar ( 20 )) ipy = ipar ( 20 ) if ( ipy . lt . 1 ) ipy = 1 pcvec = ( / rgx ( ipx , ipy ), rgy ( ipx , ipy ), rgz ( ipx , ipy ) / ) calpha = cos ( alpha ) do i = 1 , ipar ( 19 ) do j = 1 , ipar ( 20 ) ! do the coordinate transformation for this detector pixel dc = ( / rgx ( i , j ), rgy ( i , j ), rgz ( i , j ) / ) ! make sure the third one is positive; if not, switch all if ( dc ( 3 ). lt . 0.0 ) dc = - dc ! convert these direction cosines to coordinates in the Rosca-Lambert projection ixy = scl * LambertSphereToSquare ( dc , istat ) x = ixy ( 1 ) ixy ( 1 ) = ixy ( 2 ) ixy ( 2 ) = - x ! four-point interpolation (bi-quadratic) nix = int ( ipar ( 1 ) + ixy ( 1 )) - ipar ( 1 ) niy = int ( ipar ( 1 ) + ixy ( 2 )) - ipar ( 1 ) dx = ixy ( 1 ) - nix dy = ixy ( 2 ) - niy dxm = 1.0 - dx dym = 1.0 - dy ! do the area correction for this detector pixel dp = dot_product ( pcvec , dc ) if (( i . eq . ipx ). and .( j . eq . ipy )) then gam = 0.25 else theta = calpha * calpha + dp * dp - 1.0 gam = theta ** 1.5 / ( calpha ** 3 ) * 0.25 end if ! interpolate the intensity do k = Emin , Emax accum_e_detector ( k , i , j ) = gam * ( accum_e ( k , nix , niy ) * dxm * dym + & accum_e ( k , nix + 1 , niy ) * dx * dym + & accum_e ( k , nix , niy + 1 ) * dxm * dy + & accum_e ( k , nix + 1 , niy + 1 ) * dx * dy ) end do end do end do prefactor = 0.25D0 * nAmpere * fpar ( 20 ) * fpar ( 21 ) * 1.0D-15 / sum ( accum_e_detector ) accum_e_detector = accum_e_detector * prefactor ! from here on, we simply compute the EBSD patterns by interpolation, using the above arrays ! no intensity scaling or anything else...other than multiplication by pre-factor ! intensity scaling is left to the user of the calling program. ! define some parameters and initialize EBSDpattern scl = dble ( ipar ( 17 )) EBSDpattern = 0.0 fullsizepattern = 0.0 dn = nint ( float ( ipar ( 21 )) * 0.01 ) cn = dn ! here is the main loop over all quaternions quatloop : do ip = 1 , ipar ( 21 ) binned = 0.0 fullsizepattern = 0.0 if ( ipar ( 25 ). eq . 0 ) then quat = quats ( 1 : 4 , ip ) else quat = eu2qu ( quats ( 1 : 3 , ip )) ! this assumes that the input Euler angles are in radians end if do i = 1 , ipar ( 19 ) do j = 1 , ipar ( 20 ) ! do the active coordinate transformation for this euler angle dc = quat_Lp ( quat , ( / rgx ( i , j ), rgy ( i , j ), rgz ( i , j ) / ) ) ! normalize dc dc = dc / sqrt ( sum ( dc * dc )) ! convert these direction cosines to coordinates in the Rosca-Lambert projection (always square projection !!!) ixy = scl * LambertSphereToSquare ( dc , istat ) if ( istat . eq . 0 ) then ! four-point interpolation (bi-quadratic) nix = int ( ipar ( 17 ) + ixy ( 1 )) - ipar ( 17 ) niy = int ( ipar ( 17 ) + ixy ( 2 )) - ipar ( 17 ) nixp = nix + 1 niyp = niy + 1 if ( nixp . gt . ipar ( 17 )) nixp = nix if ( niyp . gt . ipar ( 17 )) niyp = niy if ( nix . lt . - ipar ( 17 )) nix = nixp if ( niy . lt . - ipar ( 17 )) niy = niyp dx = ixy ( 1 ) - nix dy = ixy ( 2 ) - niy dxm = 1.0 - dx dym = 1.0 - dy if ( dc ( 3 ). gt . 0.0 ) then ! we're in the Northern hemisphere do k = 1 , ipar ( 12 ) fullsizepattern ( i , j ) = fullsizepattern ( i , j ) + accum_e_detector ( k , i , j ) * ( mLPNHsum ( nix , niy , k ) * dxm * dym + & mLPNHsum ( nixp , niy , k ) * dx * dym + mLPNHsum ( nix , niyp , k ) * dxm * dy + & mLPNHsum ( nixp , niyp , k ) * dx * dy ) end do else ! we're in the Southern hemisphere do k = 1 , ipar ( 12 ) fullsizepattern ( i , j ) = fullsizepattern ( i , j ) + accum_e_detector ( k , i , j ) * ( mLPSHsum ( nix , niy , k ) * dxm * dym + & mLPSHsum ( nixp , niy , k ) * dx * dym + mLPSHsum ( nix , niyp , k ) * dxm * dy + & mLPSHsum ( nixp , niyp , k ) * dx * dy ) end do end if end if end do end do ! bin the pattern if necessary and apply the gamma scaling factor if ( binx . ne . ipar ( 19 )) then do ii = 1 , ipar ( 19 ), binfac do jj = 1 , ipar ( 20 ), binfac binned ( ii / binfac + 1 , jj / binfac + 1 ) = & sum ( fullsizepattern ( ii : ii + binfac - 1 , jj : jj + binfac - 1 )) end do end do EBSDpattern ( 1 : binx , 1 : biny , ip ) = ( binned ( 1 : binx , 1 : biny ) * bindx ) ** fpar ( 22 ) else EBSDpattern ( 1 : binx , 1 : biny , ip ) = ( fullsizepattern ( 1 : binx , 1 : biny )) ** fpar ( 22 ) end if ! has the cancel flag been set by the calling program ? if ( cancel . ne . char ( 0 )) EXIT quatloop ! update the progress counter and report it to the calling program via the proc callback routine if ( objAddress . ne . 0 ) then if ( ip . ge . cn ) then cn = cn + dn call proc ( objAddress , ip ) end if end if end do quatloop end subroutine EMsoftCgetEBSDPatterns !-------------------------------------------------------------------------- ! ! SUBROUTINE:EMsoftCgetECPatterns ! !> @author Saransh Singh/Marc De Graef, Carnegie Mellon University ! !> @brief This subroutine can be called by a C/C++ program as a standalone function to compute ECPs ! !> @details This subroutine provides a method to compute a series of ECPs and !> can be called from an external C/C++ program; the routine provides a callback mechanism to !> update the calling program about computational progress, as well as a cancel option. !> The routine is intended to be called form a C/C++ program, e.g., DREAM.3D.  This routine is a simplified version !> of the core of the EMECP program. !> !> This routine will first compute the incident cone vectors etc. if necessary, and then perform !> the usual interpolation from the square Lambert projection. The pattern will be a basic pattern, !> without any intensity scaling or binning etc; the calling program should take care of those !> operations. ! !> @param ipar array with integer input parameters !> @param fpar array with float input parameters !> @param ECPattern output array !> @param quats array of quaternions !> @param accum_e array with Monte Carlo histogram !> @param mLPNH Northern hemisphere master pattern !> @param mLPSH Southern hemisphere master pattern ! !> @date 10/16/15  SS 1.0 original !> @date 11/02/14 MDG 1.1 put all integer parameters inside ipar and fixed size of ipar/fpar !> @date 11/04/15 MDG 1.2 added array of quaternions as input parameter !> @date 01/14/16 MDG 2.0 forked from original SingleECPattern routine; SAVE atrribute removed; ipar redefined (ipar(1) removed) !-------------------------------------------------------------------------- recursive subroutine EMsoftCgetECPatterns ( ipar , fpar , ECpattern , quats , accum_e , mLPNH , mLPSH , cproc , objAddress , cancel ) & bind ( c , name = 'EMsoftCgetECPatterns' ) ! this routine is callable from a C/C++ program !DEC$ ATTRIBUTES DLLEXPORT :: EMsoftCgetECPatterns ! the input parameters are all part of a ipar and fpar input arrays instead of the usual namelist structures. ! The following is the mapping: ! ! ipar(1) = detnumpix ! ipar(2) = numangle ! ipar(3) = mcnsx ! ipar(4) = numset ! ipar(5) = mpnpx ! ipar(6) = numquats ! fpar(1) = ecpnl%thetac ! fpar(2) = ecpnl%sampletilt ! fpar(3) = ecpnl%workingdistance ! fpar(4) = ecpnl%Rin ! fpar(5) = ecpnl%Rout ! fpar(6) = ecpnl%sigstart ! fpar(7) = ecpnl%sigend ! fpar(8) = ecpnl%sigstep use local use constants use Lambert use quaternions use , INTRINSIC :: ISO_C_BINDING IMPLICIT NONE integer ( c_size_t ), PARAMETER :: nipar = 6 integer ( c_size_t ), PARAMETER :: nfpar = 8 integer ( c_size_t ), PARAMETER :: nq = 4 integer ( c_size_t ), INTENT ( IN ) :: ipar ( nipar ) real ( kind = sgl ), INTENT ( IN ) :: fpar ( nfpar ) real ( kind = sgl ), INTENT ( OUT ) :: ECpattern ( ipar ( 1 ), ipar ( 1 ), ipar ( 6 )) real ( kind = sgl ), INTENT ( IN ) :: quats ( nq , ipar ( 6 )) real ( kind = sgl ), INTENT ( IN ) :: accum_e ( ipar ( 2 ), - ipar ( 3 ): ipar ( 3 ), - ipar ( 3 ): ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: mLPNH ( - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 ), ipar ( 4 )) real ( kind = sgl ), INTENT ( IN ) :: mLPSH ( - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 ), ipar ( 4 )) TYPE ( C_FUNPTR ), INTENT ( IN ), VALUE :: cproc integer ( c_size_t ), INTENT ( IN ), VALUE :: objAddress character ( len = 1 ), INTENT ( IN ) :: cancel real ( kind = sgl ), allocatable :: klist (:,:,:), rgx (:,:), rgy (:,:), rgz (:,:), weightfact (:) real ( kind = sgl ), allocatable :: mLPNHsum (:,:), mLPSHsum (:,:) real ( kind = dbl ), parameter :: Rtod = 5 7.2957795131D0 real ( kind = dbl ), parameter :: dtoR = 0.01745329251D0 real ( kind = sgl ) :: kk ( 3 ), thetacr , ktmax , delta , wf , quat ( 4 ) integer ( kind = irg ) :: istat , imin , imax , jmin , jmax , ii , jj , nazimuth , npolar , nsig , ip , dn , cn integer ( kind = irg ) :: ipolar , iazimuth , isig , isampletilt , nix , niy , nixp , niyp , isigp real ( kind = sgl ) :: thetain , thetaout , polar , azimuthal , delpolar , delazimuth , om ( 3 , 3 ) real ( kind = sgl ) :: dc ( 3 ), scl , deltheta , acc_sum , MCangle , ixy ( 2 ), dx , dy , dxm , dym , dp PROCEDURE ( ProgressCallBack ), POINTER :: proc ! link the proc procedure to the cproc argument CALL C_F_PROCPOINTER ( cproc , proc ) !================================================================================== ! ------ generate the detector klist, rgx, rgy, rgz, weightfactors arrays !================================================================================== imin = 1 imax = ipar ( 1 ) jmin = 1 jmax = ipar ( 1 ) if ( allocated ( mLPNHsum )) deallocate ( mLPNHsum ) if ( allocated ( mLPSHsum )) deallocate ( mLPSHsum ) allocate ( mLPNHsum ( - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 ))) allocate ( mLPSHsum ( - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 ))) mLPNHsum = sum ( mLPNH , 3 ) mLPSHsum = sum ( mLPSH , 3 ) if ( allocated ( klist )) deallocate ( klist ) allocate ( klist ( 1 : 3 , 1 : ipar ( 1 ), 1 : ipar ( 1 )), stat = istat ) kk = ( / 0.0 , 0.0 , 1.0 / ) thetacr = DtoR * fpar ( 1 ) ktmax = tan ( thetacr ) delta = 2.0 * ktmax / dble ( ipar ( 1 ) - 1 ) do ii = imin , imax do jj = jmin , jmax klist ( 1 : 3 , ii , jj ) = ( /- ktmax + delta * ( ii - 1 ), - ktmax + delta * ( jj - 1 ), 0.0 / ) + kk ( 1 : 3 ) klist ( 1 : 3 , ii , jj ) = klist ( 1 : 3 , ii , jj ) / sqrt ( sum ( klist ( 1 : 3 , ii , jj ) ** 2 )) end do end do thetain = atan2 ( fpar ( 4 ), fpar ( 3 )) thetaout = atan2 ( fpar ( 5 ), fpar ( 3 )) om ( 1 ,:) = ( / cos ( fpar ( 2 ) * sngl ( dtor )), 0.0 , sin ( fpar ( 2 ) * sngl ( dtor )) / ) om ( 2 ,:) = ( / 0.0 , 1.0 , 0.0 / ) om ( 3 ,:) = ( /- sin ( fpar ( 2 ) * sngl ( dtor )), 0.0 , cos ( fpar ( 2 ) * sngl ( dtor )) / ) npolar = nint (( thetaout - thetain ) * 18 0.0 / cPi ) + 1 delpolar = ( thetaout - thetain ) / float ( npolar - 1 ) nazimuth = 361 delazimuth = 2.0 * cPi / float ( nazimuth - 1 ) if ( allocated ( rgx )) deallocate ( rgx , rgy , rgz ) allocate ( rgx ( npolar , nazimuth ), rgy ( npolar , nazimuth ), rgz ( npolar , nazimuth ), stat = istat ) do ipolar = 1 , npolar polar = thetain + float ( ipolar - 1 ) * delpolar do iazimuth = 1 , nazimuth azimuthal = float ( iazimuth - 1 ) * delazimuth dc ( 1 ) = cos ( azimuthal ) * sin ( polar ) dc ( 2 ) = sin ( azimuthal ) * sin ( polar ) dc ( 3 ) = cos ( polar ) dc = matmul ( om , dc ) rgx ( ipolar , iazimuth ) = dc ( 1 ) rgy ( ipolar , iazimuth ) = dc ( 2 ) rgz ( ipolar , iazimuth ) = dc ( 3 ) end do end do !=================================================================== ! ------ generate the weight factors from the monte carlo histogram !=================================================================== scl = float ( ipar ( 3 )) nsig = nint ( fpar ( 1 ) + abs ( fpar ( 2 ))) + 1 deltheta = ( fpar ( 1 ) + abs ( fpar ( 2 ))) / float ( nsig - 1 ) if ( allocated ( weightfact )) deallocate ( weightfact ) allocate ( weightfact ( 1 : nsig ), stat = istat ) weightfact = 0.0 do isig = 1 , nsig acc_sum = 0.0 MCangle = ( isig - 1 ) * deltheta isampletilt = nint (( MCangle - fpar ( 6 )) / fpar ( 8 )) if ( isampletilt . lt . 1 ) then isampletilt = abs ( isampletilt ) + 1 else isampletilt = isampletilt + 1 end if do ipolar = 1 , npolar do iazimuth = 1 , nazimuth dc ( 1 : 3 ) = ( / rgx ( ipolar , iazimuth ), rgy ( ipolar , iazimuth ), rgz ( ipolar , iazimuth ) / ) ! convert to Rosca-lambert projection ixy = scl * LambertSphereToSquare ( dc , istat ) nix = int ( ipar ( 3 ) + ixy ( 1 )) - ipar ( 3 ) niy = int ( ipar ( 3 ) + ixy ( 2 )) - ipar ( 3 ) nixp = nix + 1 niyp = niy + 1 if ( nixp . gt . ipar ( 3 )) nixp = nix if ( niyp . gt . ipar ( 3 )) niyp = niy if ( nix . lt . - ipar ( 3 )) nix = nixp if ( niy . lt . - ipar ( 3 )) niy = niyp dx = ixy ( 1 ) - nix dy = ixy ( 2 ) - niy dxm = 1.0 - dx dym = 1.0 - dy acc_sum = 0.25 * ( accum_e ( isampletilt , nix , niy ) * dxm * dym + & accum_e ( isampletilt , nixp , niy ) * dx * dym + & accum_e ( isampletilt , nix , niyp ) * dxm * dy + & accum_e ( isampletilt , nixp , niyp ) * dx * dy ) weightfact ( isig ) = weightfact ( isig ) + acc_sum end do end do end do weightfact ( 1 : nsig ) = weightfact ( 1 : nsig ) / weightfact ( 1 ) !=================================================================== ! ------ perform interpolation from square lambert map !=================================================================== scl = float ( ipar ( 5 )) ECPattern = 0.0 dn = nint ( float ( ipar ( 6 )) * 0.01 ) cn = dn quatloop : do ip = 1 , ipar ( 6 ) do ii = imin , imax do jj = jmin , jmax dc ( 1 : 3 ) = klist ( 1 : 3 , ii , jj ) dc = dc / sqrt ( sum ( dc * dc )) dp = DOT_PRODUCT ( dc ( 1 : 3 ),( / sin ( fpar ( 2 ) * dtoR ), 0.D0 , cos ( fpar ( 2 ) * dtoR ) / )) if ( dp . gt . 1.D0 ) dp = 1.0 MCangle = acos ( dp ) * Rtod isig = int ( MCangle ) + 1 if ( isig . gt . nsig ) isig = nsig isigp = isig + 1 if ( isigp . gt . nsig ) isigp = nsig dx = MCangle - int ( MCangle ) dxm = 1.0 - dx wf = weightfact ( isig ) * dxm + weightfact ( isigp ) * dx wf = 1.0 dc = quat_LP ( quats ( 1 : 4 , ip ), dc ) dc = dc / sqrt ( sum ( dc * dc )) ixy = scl * LambertSphereToSquare ( dc , istat ) nix = int ( ipar ( 5 ) + ixy ( 1 )) - ipar ( 5 ) niy = int ( ipar ( 5 ) + ixy ( 2 )) - ipar ( 5 ) nixp = nix + 1 niyp = niy + 1 if ( nixp . gt . ipar ( 5 )) nixp = nix if ( niyp . gt . ipar ( 5 )) niyp = niy if ( nix . lt . - ipar ( 5 )) nix = nixp if ( niy . lt . - ipar ( 5 )) niy = niyp dx = ixy ( 1 ) - nix dy = ixy ( 2 ) - niy dxm = 1.0 - dx dym = 1.0 - dy if ( dc ( 3 ). ge . 0.D0 ) then ECpattern ( ii , jj , ip ) = wf * ( mLPNHsum ( nix , niy ) * dxm * dym + & mLPNHsum ( nixp , niy ) * dx * dym + & mLPNHsum ( nix , niyp ) * dxm * dy + & mLPNHsum ( nixp , niyp ) * dx * dy ) else ECpattern ( ii , jj , ip ) = wf * ( mLPSHsum ( nix , niy ) * dxm * dym + & mLPSHsum ( nixp , niy ) * dx * dym + & mLPSHsum ( nix , niyp ) * dxm * dy + & mLPSHsum ( nixp , niyp ) * dx * dy ) end if end do end do ! has the cancel flag been set by the calling program ? if ( cancel . ne . char ( 0 )) EXIT quatloop ! update the progress counter and report it to the calling program via the proc callback routine if ( objAddress . ne . 0 ) then if ( ip . ge . cn ) then cn = cn + dn call proc ( objAddress , ip ) end if end if end do quatloop end subroutine EMsoftCgetECPatterns !-------------------------------------------------------------------------- ! ! SUBROUTINE:EMsoftCgetMCOpenCL ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief This subroutine can be called by a C/C++ program as a standalone routine to compute Monte Carlo data ! !> @details This subroutine provides a method to compute a Monte Carlo data set, normally computed !> with the EMMCOpenCL.f90 program.  The routine can be called from an external C/C++ program; !> the routine provides a callback mechanism to update the calling program about computational !> progress, as well as a cancel option. !> !> The routine is intended to be called from a C/C++ program, e.g., DREAM.3D.  This routine is a !> simplified version of the core of the EMMCOpenCL program. !> !> Since the HDF5 library with fortran90 support can only be a static library on Mac OS X, we must !> have the calling program read the .xtal HDF5 file and pass the necessary information on to !> this routine.  This is a workaround until the HDF group fixes the static library issue; DREAM.3D !> requires a dynamical HDF5 library, so for DREAM.3D and EMsoft to properly work together, the !> callable routines in this file may not depend on any HDF code at all, either directly or indirectly. !> !> @param ipar array with integer input parameters !> @param fpar array with float input parameters !> @param atdata atom coordinate array !> @param attypes atom type array !> @param latparm lattice parameter array !> @param accum_e output array with Monte Carlo energy histogram !> @param accum_z output array with Monte Carlo depth histogram ! !> @date 03/08/16 MDG 1.0 original !> @date 03/19/16 MDG 1.1 corrections to a few variable types !> @date 04/13/16 MDG 1.2 correction to accum_z array size due to changes in calling DREAM.3D filter !> @date 04/18/16 MDG 1.3 increased number of entries in ipar, fpar for compatibility with EMsoftCgetEBSDmaster routine !> @date 04/28/16 MDG 1.4 corrected error in indexing of init_seeds array; caused DREAM.3D to crash randomly !-------------------------------------------------------------------------- recursive subroutine EMsoftCgetMCOpenCL ( ipar , fpar , atompos , atomtypes , latparm , accum_e , accum_z , cproc , objAddress , cancel ) & bind ( c , name = 'EMsoftCgetMCOpenCL' ) ! this routine is callable from a C/C++ program !DEC$ ATTRIBUTES DLLEXPORT :: EMsoftCgetMCOpenCL ! ipar components ! ipar(1) : integer(kind=irg)       :: nx  = (numsx-1)/2 ! ipar(2) : integer(kind=irg)       :: globalworkgrpsz ! ipar(3) : integer(kind=irg)       :: num_el ! ipar(4) : integer(kind=irg)       :: totnum_el ! ipar(5) : integer(kind=irg)       :: multiplier ! ipar(6) : integer(kind=irg)       :: devid ! ipar(7) : integer(kind=irg)       :: platid ! ipar(8) : integer(kind=irg)       :: CrystalSystem ! ipar(9) : integer(kind=irg)       :: Natomtypes ! ipar(10): integer(kind=irg)       :: SpaceGroupNumber ! ipar(11): integer(kind=irg)       :: SpaceGroupSetting ! ipar(12): integer(kind=irg)       :: numEbins ! ipar(13): integer(kind=irg)       :: numzbins ! ipar(14): integer(kind=irg)       :: mcmode  ( 1 = 'full', 2 = 'bse1' ) ! ipar(15): integer(kind=irg)       :: numangle ! ipar(16): integer(kind=irg)       :: nxten = nx/10 ! other entries are not used ! fpar components ! fpar(1) : real(kind=dbl)          :: sig ! fpar(2) : real(kind=dbl)          :: omega ! fpar(3) : real(kind=dbl)          :: EkeV ! fpar(4) : real(kind=dbl)          :: Ehistmin ! fpar(5) : real(kind=dbl)          :: Ebinsize ! fpar(6) : real(kind=dbl)          :: depthmax ! fpar(7) : real(kind=dbl)          :: depthstep ! fpar(8) : real(kind=dbl)          :: sigstart ! fpar(9) : real(kind=dbl)          :: sigend ! fpar(10): real(kind=dbl)          :: sigstep ! other entries are not used use local use constants use crystal use constants use symmetry use io use typedefs use clfortran use CLsupport use timing use , INTRINSIC :: ISO_C_BINDING IMPLICIT NONE integer ( c_int32_t ), PARAMETER :: nipar = 40 integer ( c_int32_t ), PARAMETER :: nfpar = 40 integer ( c_int32_t ), INTENT ( IN ) :: ipar ( nipar ) real ( kind = sgl ), INTENT ( IN ) :: fpar ( nfpar ) real ( kind = sgl ), INTENT ( IN ) :: atompos ( ipar ( 9 ), 5 ) integer ( kind = irg ), INTENT ( IN ) :: atomtypes ( ipar ( 9 )) real ( kind = sgl ), INTENT ( IN ) :: latparm ( 6 ) integer ( kind = irg ), INTENT ( OUT ) :: accum_e ( ipar ( 12 ), - ipar ( 1 ): ipar ( 1 ), - ipar ( 1 ): ipar ( 1 )) integer ( kind = irg ), INTENT ( OUT ) :: accum_z ( ipar ( 12 ), ipar ( 13 ), - ipar ( 16 ): ipar ( 16 ), - ipar ( 16 ): ipar ( 16 )) TYPE ( C_FUNPTR ), INTENT ( IN ), VALUE :: cproc integer ( c_size_t ), INTENT ( IN ), VALUE :: objAddress character ( len = 1 ), INTENT ( IN ) :: cancel ! local variables and parameters type ( unitcell ), pointer :: cell character ( 4 ) :: mode integer ( kind = ill ) :: i , j , k , io_int ( 1 ), num_max , totnum_el , ipg , isave , istat integer ( kind = irg ) :: nx , numEbins , numzbins , numangle , iang , cn , dn , totn integer ( kind = irg ), target :: globalworkgrpsz , num_el , steps integer ( kind = 8 ), target :: globalsize ( 2 ), localsize ( 2 ) integer ( kind = 8 ) :: size_in_bytes , size_in_bytes_seeds real ( kind = sgl ), target :: dens , avA , avZ , omega , EkeV , sig , bseyield , io_real ( 3 ) real ( kind = 4 ), target :: density , Ze , at_wt , delta real ( kind = 8 ), parameter :: dtoR = 0.01745329251D0 ! pi/180 real ( kind = 4 ), allocatable , target :: Lamresx (:), Lamresy (:), depthres (:), energyres (:) integer ( kind = 4 ), allocatable :: rnseeds (:) integer ( kind = 4 ), allocatable , target :: init_seeds (:) integer ( kind = 4 ) :: idxy ( 2 ), iE , px , py , iz , nseeds , hdferr , tstart ! auxiliary variables real ( kind = 4 ) :: cxyz ( 3 ), edis , bse , xy ( 2 ), xs , ys , zs , sclf ! auxiliary variables real ( kind = 8 ) :: rand logical :: f_exists ! OpenCL variables integer ( c_intptr_t ), allocatable , target :: platform (:) integer ( c_intptr_t ), allocatable , target :: device (:) integer ( c_intptr_t ), target :: context integer ( c_intptr_t ), target :: command_queue integer ( c_intptr_t ), target :: prog integer ( c_intptr_t ), target :: kernel integer ( c_intptr_t ), target :: LamX , LamY , LamZ , depth , energy , seeds type ( c_ptr ) :: event integer ( c_int32_t ) :: ierr , pcnt integer ( c_size_t ), target :: slength integer ( c_intptr_t ), target :: ctx_props ( 3 ) character ( 2 ), target :: kernelname character ( 19 ), target :: progoptions character ( fnlen ), target :: info ! info about the GPU integer ( c_int64_t ) :: cmd_queue_props integer , parameter :: iunit = 10 integer , parameter :: source_length = 50000 character ( len = source_length ), target :: source character ( len = source_length , KIND = c_char ), TARGET :: csource type ( c_ptr ), target :: psource integer ( c_int ) :: nump , numd , irec , val , val1 ! auxiliary variables integer ( c_size_t ) :: cnum , cnuminfo character ( fnlen ) :: instring , dataname , fname , sourcefile PROCEDURE ( ProgressCallBack2 ), POINTER :: proc ! link the proc procedure to the cproc argument CALL C_F_PROCPOINTER ( cproc , proc ) ! since this routine needs to read a .cl file, we need to make sure that the pathnames are ! properly set... call EMsoft_path_init ! the following is necessitated by the fact that none of this code may ! depend on HDF5 routines, so we need to cut-and-paste from various ! other library routines to set things up so that we can compute the ! density, and the average atomic number and atomic mass... ! copy all the unit cell parameters into the proper fields and compute the ! density parameters needed by the Monte Carlo routine; then discard the cell structure nullify ( cell ) allocate ( cell ) ! lattice parameters cell % a = dble ( latparm ( 1 )) cell % b = dble ( latparm ( 2 )) cell % c = dble ( latparm ( 3 )) cell % alpha = dble ( latparm ( 4 )) cell % beta = dble ( latparm ( 5 )) cell % gamma = dble ( latparm ( 6 )) ! symmetry parameters cell % xtal_system = ipar ( 8 ) cell % SYM_SGset = ipar ( 11 ) cell % SYM_SGnum = ipar ( 10 ) if (( cell % SYM_SGnum . ge . 143 ). and .( cell % SYM_SGnum . le . 167 )) then cell % SG % SYM_trigonal = . TRUE . else cell % SG % SYM_trigonal = . FALSE . end if ! atom type and coordinate parameters cell % ATOM_ntype = ipar ( 9 ) cell % ATOM_type ( 1 : cell % ATOM_ntype ) = atomtypes ( 1 : cell % ATOM_ntype ) cell % ATOM_pos ( 1 : cell % ATOM_ntype , 1 : 5 ) = atompos ( 1 : cell % ATOM_ntype , 1 : 5 ) ! generate the symmetry operations cell % hexset = . FALSE . if ( cell % xtal_system . eq . 4 ) cell % hexset = . TRUE . if (( cell % xtal_system . eq . 5 ). AND .( cell % SYM_SGset . ne . 2 )) cell % hexset = . TRUE . ! compute the metric matrices call CalcMatrices ( cell ) ! First generate the point symmetry matrices, then the actual space group. ! Get the symmorphic space group corresponding to the point group ! of the actual space group ipg = 0 do i = 1 , 32 if ( SGPG ( i ). le . cell % SYM_SGnum ) ipg = i end do ! if the actual group is also the symmorphic group, then both ! steps can be done simultaneously, otherwise two calls to ! GenerateSymmetry are needed. if ( SGPG ( ipg ). eq . cell % SYM_SGnum ) then call GenerateSymmetry ( cell ,. TRUE .) else isave = cell % SYM_SGnum cell % SYM_SGnum = SGPG ( ipg ) call GenerateSymmetry ( cell ,. TRUE .) cell % SYM_SGnum = isave call GenerateSymmetry ( cell ,. FALSE .) end if ! next we get all the atom positions call CalcPositions ( cell , 'v' ) ! and now we have all we need to compute the density, average A and average Z call CalcDensity ( cell , dens , avZ , avA ) ! deallocate the cell structure deallocate ( cell ) ! and copy these values into the desired variables density = dble ( dens ) Ze = dble ( avZ ) at_wt = dble ( avA ) ! define a number of parameters steps = 300 mode = 'full' if ( ipar ( 14 ). ne . 1 ) mode = 'bse1' EkeV = sngl ( fpar ( 3 )) !sig = mcnl%sig*dtoR    ! this is defined later on and depends on the mode omega = sngl ( fpar ( 2 )) * dtoR globalworkgrpsz = ipar ( 2 ) num_el = int ( ipar ( 3 )) ! no. of electron simulation by one work item num_max = globalworkgrpsz * globalworkgrpsz * num_el ! total simulation in one loop totnum_el = ipar ( 4 ) * ipar ( 5 ) ! total number of electrons to simulate globalsize = ( / globalworkgrpsz , globalworkgrpsz / ) !localsize = (/ globalworkgrpsz, globalworkgrpsz /) !localsize = (/ globalworkgrpsz/10, globalworkgrpsz/10 /) numEbins = int ( ipar ( 12 )) numzbins = int ( ipar ( 13 )) nx = int ( ipar ( 1 )) delta = dble ( nx ) size_in_bytes = num_max * sizeof ( EkeV ) size_in_bytes_seeds = 4 * globalworkgrpsz * globalworkgrpsz * sizeof ( EkeV ) numangle = int ( ipar ( 15 )) ! next allocate and initialize a couple of arrays allocate ( Lamresx ( num_max ), Lamresy ( num_max ), depthres ( num_max ), energyres ( num_max ), stat = istat ) depthres = 0.0 energyres = 0.0 Lamresx = 0.0 Lamresy = 0.0 accum_e = 0 accum_z = 0 !====================== ! OpenCL INITIALIZATION !====================== call CLinit_PDCCQ ( platform , nump , int ( ipar ( 7 )), device , numd , int ( ipar ( 6 )), info , context , command_queue ) !===================== ! BUILD THE KERNEL !===================== ! read the source file sourcefile = 'EMMC.cl' call CLread_source_file ( sourcefile , csource , slength ) ! we disable all screen output; perhaps we can feed error messages back to the calling program... ! create the program pcnt = 1 psource = C_LOC ( csource ) prog = clCreateProgramWithSource ( context , pcnt , C_LOC ( psource ), C_LOC ( slength ), ierr ) ! if(ierr /= CL_SUCCESS) call FatalError(\"clCreateProgramWithSource: \",'Error: cannot create program from source.') ! build the program progoptions = '-cl-no-signed-zeros' ierr = clBuildProgram ( prog , numd , C_LOC ( device ), C_LOC ( progoptions ), C_NULL_FUNPTR , C_NULL_PTR ) ! if(ierr /= CL_SUCCESS) call FatalError(\"clBuildProgram: \",'Error: cannot build program.') ! get the compilation log ierr = clGetProgramBuildInfo ( prog , device ( ipar ( 6 )), CL_PROGRAM_BUILD_LOG , sizeof ( source ), C_LOC ( source ), cnum ) ! if(len(trim(source)) > 0) call Message(trim(source(1:cnum)),frm='(A)') ! if(ierr /= CL_SUCCESS) call FatalError(\"clGetProgramBuildInfo: \",'Error building program.') ! if we get here, then the program build was successful and we can proceed with the creation of the kernel ! call Message('Program Build Successful... Creating kernel') ! finally get the kernel and release the program kernelname = 'MC' kernel = clCreateKernel ( prog , C_LOC ( kernelname ), ierr ) ! if(ierr /= CL_SUCCESS) call FatalError(\"clCreateKernel: \",'Error creating kernel MC.') ierr = clReleaseProgram ( prog ) ! if(ierr /= CL_SUCCESS) call FatalError(\"clReleaseProgram: \",'Error releasing program.') open ( unit = iunit , file = trim ( EMsoft_toNativePath ( EMsoft_getRandomseedfilename ())), form = 'unformatted' , status = 'old' ) read ( iunit ) nseeds allocate ( rnseeds ( nseeds )) read ( iunit ) rnseeds close ( unit = iunit , status = 'keep' ) ! the next error needs to be checked in the calling program ! if (globalworkgrpsz**2 .gt. nseeds) call FatalError('EMMCOpenCL:','insufficient prime numbers') allocate ( init_seeds ( 4 * globalworkgrpsz * globalworkgrpsz ), stat = istat ) init_seeds = 0 do i = 1 , globalworkgrpsz do j = 1 , globalworkgrpsz do k = 1 , 4 init_seeds ( 4 * (( i - 1 ) * globalworkgrpsz + ( j - 1 )) + k ) = rnseeds ( 4 * (( i - 1 ) * globalworkgrpsz + j ) + k ) end do end do end do ! create device memory buffers LamX = clCreateBuffer ( context , CL_MEM_WRITE_ONLY , size_in_bytes , C_NULL_PTR , ierr ) ! if(ierr /= CL_SUCCESS) call FatalError('clCreateBuffer: ','cannot allocate device memory for LamX.') LamY = clCreateBuffer ( context , CL_MEM_WRITE_ONLY , size_in_bytes , C_NULL_PTR , ierr ) ! if(ierr /= CL_SUCCESS) call FatalError('clCreateBuffer: ','cannot allocate device memory for LamY.') depth = clCreateBuffer ( context , CL_MEM_WRITE_ONLY , size_in_bytes , C_NULL_PTR , ierr ) !   if(ierr /= CL_SUCCESS) call FatalError('clCreateBuffer: ','cannot allocate device memory for depth.') energy = clCreateBuffer ( context , CL_MEM_WRITE_ONLY , size_in_bytes , C_NULL_PTR , ierr ) !   if(ierr /= CL_SUCCESS) call FatalError('clCreateBuffer: ','cannot allocate device memory for energy.') seeds = clCreateBuffer ( context , CL_MEM_READ_WRITE , size_in_bytes , C_NULL_PTR , ierr ) ! if(ierr /= CL_SUCCESS) call FatalError('clCreateBuffer: ','cannot allocate device memory for seeds.') ierr = clEnqueueWriteBuffer ( command_queue , seeds , CL_TRUE , 0 _ 8 , size_in_bytes_seeds , C_LOC ( init_seeds ( 1 )), & 0 , C_NULL_PTR , C_NULL_PTR ) ! if(ierr /= CL_SUCCESS) call FatalError('clEnqueueWriteBuffer: ','cannot Enqueue write buffer.') ! set the callback parameters dn = 1 cn = dn totn = numangle * ( totnum_el / num_max + 1 ) call Time_tick ( tstart ) ! loop over angles (used for BSE1, single run for full) angleloop : do iang = 1 , numangle if ( mode . eq . 'bse1' ) then sig = ( fpar ( 8 ) + ( iang - 1 ) * fpar ( 10 )) * dtoR else sig = fpar ( 1 ) * dtoR end if mainloop : do i = 1 ,( totnum_el / num_max + 1 ) ! set the kernel arguments ierr = clSetKernelArg ( kernel , 0 , sizeof ( LamX ), C_LOC ( LamX )) !   if(ierr /= CL_SUCCESS) stop 'Error: cannot set kernel argument.' ierr = clSetKernelArg ( kernel , 1 , sizeof ( LamY ), C_LOC ( LamY )) !   if(ierr /= CL_SUCCESS) stop 'Error: cannot set kernel argument.' ierr = clSetKernelArg ( kernel , 2 , sizeof ( EkeV ), C_LOC ( EkeV )) !   if(ierr /= CL_SUCCESS) stop 'Error: cannot set kernel argument.' ierr = clSetKernelArg ( kernel , 3 , sizeof ( globalworkgrpsz ), C_LOC ( globalworkgrpsz )) !   if(ierr /= CL_SUCCESS) stop 'Error: cannot set kernel argument.' ierr = clSetKernelArg ( kernel , 4 , sizeof ( Ze ), C_LOC ( Ze )) !   if(ierr /= CL_SUCCESS) stop 'Error: cannot set kernel argument.' ierr = clSetKernelArg ( kernel , 5 , sizeof ( density ), C_LOC ( density )) !   if(ierr /= CL_SUCCESS) stop 'Error: cannot set kernel argument.' ierr = clSetKernelArg ( kernel , 6 , sizeof ( at_wt ), C_LOC ( at_wt )) !   if(ierr /= CL_SUCCESS) stop 'Error: cannot set kernel argument.' ierr = clSetKernelArg ( kernel , 7 , sizeof ( num_el ), C_LOC ( num_el )) !   if(ierr /= CL_SUCCESS) stop 'Error: cannot set kernel argument.' ierr = clSetKernelArg ( kernel , 8 , sizeof ( seeds ), C_LOC ( seeds )) !   if(ierr /= CL_SUCCESS) stop 'Error: cannot set kernel argument.' ierr = clSetKernelArg ( kernel , 9 , sizeof ( sig ), C_LOC ( sig )) !   if(ierr /= CL_SUCCESS) stop 'Error: cannot set kernel argument.' ierr = clSetKernelArg ( kernel , 10 , sizeof ( omega ), C_LOC ( omega )) !   if(ierr /= CL_SUCCESS) stop 'Error: cannot set kernel argument.' ierr = clSetKernelArg ( kernel , 11 , sizeof ( depth ), C_LOC ( depth )) !   if(ierr /= CL_SUCCESS) stop 'Error: cannot set kernel argument.' ierr = clSetKernelArg ( kernel , 12 , sizeof ( energy ), C_LOC ( energy )) !   if(ierr /= CL_SUCCESS) stop 'Error: cannot set kernel argument.' ierr = clSetKernelArg ( kernel , 13 , sizeof ( steps ), C_LOC ( steps )) !   if(ierr /= CL_SUCCESS) stop 'Error: cannot set kernel argument.' ! execute the kernel !   ierr = clEnqueueNDRangeKernel(command_queue, kernel, 2, C_NULL_PTR, C_LOC(globalsize), C_LOC(localsize), & !                                 0, C_NULL_PTR, C_NULL_PTR) ierr = clEnqueueNDRangeKernel ( command_queue , kernel , 2 , C_NULL_PTR , C_LOC ( globalsize ), C_NULL_PTR , & 0 , C_NULL_PTR , C_NULL_PTR ) ! wait for the commands to finish ierr = clFinish ( command_queue ) ! read the resulting vector from device memory ierr = clEnqueueReadBuffer ( command_queue , LamX , CL_TRUE , 0 _ 8 , size_in_bytes , C_LOC ( Lamresx ( 1 )), 0 , C_NULL_PTR , C_NULL_PTR ) ierr = clEnqueueReadBuffer ( command_queue , LamY , CL_TRUE , 0 _ 8 , size_in_bytes , C_LOC ( Lamresy ( 1 )), 0 , C_NULL_PTR , C_NULL_PTR ) ierr = clEnqueueReadBuffer ( command_queue , depth , CL_TRUE , 0 _ 8 , size_in_bytes , C_LOC ( depthres ( 1 )), 0 , C_NULL_PTR , C_NULL_PTR ) ierr = clEnqueueReadBuffer ( command_queue , energy , CL_TRUE , 0 _ 8 , size_in_bytes , C_LOC ( energyres ( 1 )), 0 , C_NULL_PTR , C_NULL_PTR ) if ( mode . eq . 'full' ) then subloopfull : do j = 1 , num_max if (( Lamresx ( j ) . ne . - 1 0.0 ) . and . ( Lamresy ( j ) . ne . - 1 0.0 ) & . and . ( depthres ( j ) . ne . 1 0.0 ) . and . ( energyres ( j ) . ne . 0.0 ) & . and . . not . isnan ( Lamresx ( j )) . and . . not . isnan ( Lamresy ( j ))) then ! and get the nearest pixel [ take into account reversal of coordinate frame (x,y) -> (y,-x) ] if (( nint ( delta * Lamresy ( j )) . eq . 0.0 ) . and . ( nint ( - delta * Lamresx ( j )) . eq . 0.0 )) then val1 = val1 + 1 end if val = val + 1 idxy = ( / nint ( delta * Lamresy ( j )), nint ( - delta * Lamresx ( j )) / ) if ( maxval ( abs ( idxy )). le . nx ) then ! If Ec larger than Emin, then we should count this electron if ( energyres ( j ). gt . fpar ( 4 )) then iE = nint (( energyres ( j ) - fpar ( 4 )) / fpar ( 5 )) + 1 ! first add this electron to the correct exit distance vs. energy bin (coarser than the angular plot) edis = abs ( depthres ( j )) ! distance from last scattering point to surface along trajectory iz = nint ( edis / fpar ( 7 )) + 1 if ( ( iz . gt . 0 ). and .( iz . le . ipar ( 13 )) ) then px = nint ( idxy ( 1 ) / 1 0.0 ) py = nint ( idxy ( 2 ) / 1 0.0 ) accum_z ( iE , iz , px , py ) = accum_z ( iE , iz , px , py ) + 1 end if ! then add it to the modified Lambert accumulator array. accum_e ( iE , idxy ( 1 ), idxy ( 2 )) = accum_e ( iE , idxy ( 1 ), idxy ( 2 )) + 1 end if end if end if end do subloopfull end if if ( mode . eq . 'bse1' ) then subloopbse1 : do j = 1 , num_max if (( Lamresx ( j ) . ne . - 1 0.0 ) . and . ( Lamresy ( j ) . ne . - 1 0.0 ) & . and . ( depthres ( j ) . ne . 1 0.0 ) . and . ( energyres ( j ) . ne . 0.0 ) & . and . . not . isnan ( Lamresx ( j )) . and . . not . isnan ( Lamresy ( j ))) then ! and get the nearest pixel [ take into account reversal of coordinate frame (x,y) -> (y,-x) ] if (( nint ( delta * Lamresy ( j )) . eq . 0.0 ) . and . ( nint ( - delta * Lamresx ( j )) . eq . 0.0 )) then val1 = val1 + 1 end if val = val + 1 idxy = ( / nint ( delta * Lamresy ( j )), nint ( - delta * Lamresx ( j )) / ) if ( maxval ( abs ( idxy )). le . nx ) then ! first add this electron to the correct exit distance vs. sigma (coarser than the angular plot) edis = abs ( depthres ( j )) ! distance from last scattering point to surface along trajectory iz = nint ( edis / fpar ( 7 )) + 1 if ( ( iz . gt . 0 ). and .( iz . le . ipar ( 13 )) ) then px = nint ( idxy ( 1 ) / 1 0.0 ) py = nint ( idxy ( 2 ) / 1 0.0 ) accum_z ( iang , iz , px , py ) = accum_z ( iang , iz , px , py ) + 1 end if ! then add it to the modified Lambert accumulator array. accum_e ( iang , idxy ( 1 ), idxy ( 2 )) = accum_e ( iang , idxy ( 1 ), idxy ( 2 )) + 1 end if end if end do subloopbse1 end if ! has the cancel flag been set by the calling program ? if ( cancel . ne . char ( 0 )) EXIT angleloop ! update the progress counter and report it to the calling program via the proc callback routine if ( objAddress . ne . 0 ) then cn = cn + dn bseyield = 10 0.0 * float ( sum ( accum_e )) / float ( i * num_max ) write ( * , * ) cn , totn , bseyield call proc ( objAddress , cn , totn , bseyield ) end if end do mainloop end do angleloop write ( * , * ) 'Total GPU time [s] = ' , Time_tock ( tstart ) !===================== ! RELEASE EVERYTHING !===================== ierr = clReleaseKernel ( kernel ) ierr = clReleaseCommandQueue ( command_queue ) ierr = clReleaseContext ( context ) ierr = clReleaseMemObject ( LamX ) ierr = clReleaseMemObject ( LamY ) ierr = clReleaseMemObject ( depth ) ierr = clReleaseMemObject ( energy ) ierr = clReleaseMemObject ( seeds ) end subroutine EMsoftCgetMCOpenCL !-------------------------------------------------------------------------- ! ! SUBROUTINE:EMsoftCgetEBSDmaster ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief This subroutine can be called by a C/C++ program as a standalone routine to compute EBSD master patterns ! !> @details This subroutine provides a method to compute an EBSD master pattern for the northern and southern !> hemispheres, i.e., it implements the EMEBSDmaster.f90 program.  The routine can be called from an external C/C++ program; !> the routine provides a callback mechanism to update the calling program about computational !> progress, as well as a cancel option. !> !> The routine is intended to be called from a C/C++ program, e.g., DREAM.3D.  This routine is a !> simplified version of the core of the EMEBSDmaster program. !> !> Since the HDF5 library with fortran90 support can only be a static library on Mac OS X, we must !> have the calling program read the .xtal HDF5 file and pass the necessary information on to !> this routine.  This is a workaround until the HDF group fixes the static library issue; DREAM.3D !> requires a dynamical HDF5 library, so for DREAM.3D and EMsoft to properly work together, the !> callable routines in this file may not depend on any HDF code at all, either directly or indirectly. !> !> @param ipar array with integer input parameters !> @param fpar array with float input parameters !> @param atdata atom coordinate array !> @param attypes atom type array !> @param latparm lattice parameter array !> @param accum_z output array with Monte Carlo depth histogram !> @param mLPNH modified Lambert projection northern hemisphere (output) !> @param mLPSH modified Lambert projection southern hemisphere (output) ! !> @date 04/17/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine EMsoftCgetEBSDmaster ( ipar , fpar , atompos , atomtypes , latparm , accum_z , mLPNH , mLPSH , cproc , objAddress , cancel ) & bind ( c , name = 'EMsoftCgetEBSDmaster' ) ! this routine is callable from a C/C++ program !DEC$ ATTRIBUTES DLLEXPORT :: EMsoftCgetEBSDmaster ! these are the same as in the EMsoftCgetMCOpenCL routine, with a few extras at the end. ! ipar components ! ipar(1) : integer(kind=irg)       :: nx  = (numsx-1)/2 ! ipar(2) : integer(kind=irg)       :: globalworkgrpsz ! ipar(3) : integer(kind=irg)       :: num_el ! ipar(4) : integer(kind=irg)       :: totnum_el ! ipar(5) : integer(kind=irg)       :: multiplier ! ipar(6) : integer(kind=irg)       :: devid ! ipar(7) : integer(kind=irg)       :: platid ! ipar(8) : integer(kind=irg)       :: CrystalSystem ! ipar(9) : integer(kind=irg)       :: Natomtypes ! ipar(10): integer(kind=irg)       :: SpaceGroupNumber ! ipar(11): integer(kind=irg)       :: SpaceGroupSetting ! ipar(12): integer(kind=irg)       :: numEbins ! ipar(13): integer(kind=irg)       :: numzbins ! ipar(14): integer(kind=irg)       :: mcmode  ( 1 = 'full', 2 = 'bse1' ) ! ipar(15): integer(kind=irg)       :: numangle ! ipar(16): integer(kind=irg)       :: nxten = nx/10 ! the following are only used in this routine, not in the Monte Carlo routine ! ipar(17): integer(kind=irg)       :: npx ! ipar(18): integer(kind=irg)       :: nthreads ! fpar components ! fpar(1) : real(kind=dbl)          :: sig ! fpar(2) : real(kind=dbl)          :: omega ! fpar(3) : real(kind=dbl)          :: EkeV ! fpar(4) : real(kind=dbl)          :: Ehistmin ! fpar(5) : real(kind=dbl)          :: Ebinsize ! fpar(6) : real(kind=dbl)          :: depthmax ! fpar(7) : real(kind=dbl)          :: depthstep ! fpar(8) : real(kind=dbl)          :: sigstart ! fpar(9) : real(kind=dbl)          :: sigend ! fpar(10): real(kind=dbl)          :: sigstep ! parameters only used in this routine, this includes the Bethe Parameters !!!! ! fpar(11) : real(kind=dbl)         :: dmin ! fpar(12) : real(kind=dbl)         :: Bethe  c1 ! fpar(13) : real(kind=dbl)         :: Bethe  c2 ! fpar(14) : real(kind=dbl)         :: Bethe  c3 use typedefs use NameListTypedefs use initializers use MBmodule use symmetry use crystal use constants use error use gvectors use kvectors use io use local use files use diffraction use multibeams use timing use Lambert use ISO_C_BINDING use omp_lib IMPLICIT NONE integer ( c_int32_t ), PARAMETER :: nipar = 40 integer ( c_int32_t ), PARAMETER :: nfpar = 40 integer ( c_int32_t ), INTENT ( IN ) :: ipar ( nipar ) real ( kind = sgl ), INTENT ( IN ) :: fpar ( nfpar ) real ( kind = sgl ), INTENT ( IN ) :: atompos ( ipar ( 9 ), 5 ) integer ( kind = irg ), INTENT ( IN ) :: atomtypes ( ipar ( 9 )) real ( kind = sgl ), INTENT ( IN ) :: latparm ( 6 ) integer ( kind = irg ), INTENT ( IN ) :: accum_z ( ipar ( 12 ), ipar ( 13 ), - ipar ( 16 ): ipar ( 16 ), - ipar ( 16 ): ipar ( 16 )) real ( kind = sgl ), INTENT ( OUT ) :: mLPNH ( - ipar ( 17 ): ipar ( 17 ), - ipar ( 17 ): ipar ( 17 ), 1 : ipar ( 12 ), 1 : ipar ( 9 )) real ( kind = sgl ), INTENT ( OUT ) :: mLPSH ( - ipar ( 17 ): ipar ( 17 ), - ipar ( 17 ): ipar ( 17 ), 1 : ipar ( 12 ), 1 : ipar ( 9 )) TYPE ( C_FUNPTR ), INTENT ( IN ), VALUE :: cproc integer ( c_size_t ), INTENT ( IN ), VALUE :: objAddress character ( len = 1 ), INTENT ( IN ) :: cancel real ( kind = dbl ) :: ctmp ( 192 , 3 ), arg integer ( kind = irg ) :: isym , i , j , ik , npy , ipx , ipy , ipz , debug , iE , izz , izzmax , iequiv ( 3 , 48 ), nequiv , num_el , MCnthreads , & ! counters numk , & ! number of independent incident beam directions ir , nat ( 100 ), kk ( 3 ), skip , ijmax , one , NUMTHREADS , TID , SamplingType , cancelerr , & numset , n , ix , iy , iz , nns , nnw , nref , Estart , ipg , isave , npx , nthreads , & istat , gzero , ic , ip , ikk , totstrong , totweak , jh , ierr , nix , niy , nixp , niyp , nxten ! counters real ( kind = dbl ) :: tpi , Znsq , kkl , DBWF , kin , delta , h , lambda , omtl , srt , dc ( 3 ), xy ( 2 ), edge , scl , tmp , & dx , dxm , dy , dym , dmin ! real ( kind = sgl ) :: io_real ( 5 ), selE , kn , FN ( 3 ), kkk ( 3 ), tstart , tstop , bp ( 4 ) real ( kind = sgl ), allocatable :: EkeVs (:), svals (:), auxNH (:,:,:), auxSH (:,:,:) ! results complex ( kind = dbl ) :: czero complex ( kind = dbl ), allocatable :: Lgh (:,:), Sgh (:,:,:) logical :: usehex , switchmirror , verbose ! Monte Carlo derived quantities integer ( kind = irg ) :: numEbins , numzbins , nsx , nsy , hdferr , nlines , lastEnergy , cn , dn , totn , cn2 , totn2 ! variables used in MC energy file real ( kind = dbl ) :: EkeV , Ehistmin , Ebinsize , depthmax , depthstep , etotal ! enery variables from MC program integer ( kind = irg ), allocatable :: thick (:), acc_z (:,:,:,:) real ( kind = sgl ), allocatable :: lambdaE (:,:) logical :: f_exists , readonly , overwrite = . TRUE ., insert = . TRUE ., stereog character ( fnlen , KIND = c_char ), allocatable , TARGET :: stringarray (:) character ( fnlen , kind = c_char ) :: line2 ( 1 ) integer ( kind = irg ) :: imh , imk , iml , gg ( 3 ) real ( kind = sgl ) :: dhkl , ddt type ( unitcell ), pointer :: cell type ( DynType ), save :: Dyn type ( gnode ), save :: rlp type ( reflisttype ), pointer :: reflist , firstw , rltmp type ( BetheParameterType ) :: BetheParameters type ( kvectorlist ), pointer :: khead , ktmp real ( kind = sgl ), allocatable :: karray (:,:) integer ( kind = irg ), allocatable :: kij (:,:) complex ( kind = dbl ), allocatable :: DynMat (:,:) character ( fnlen ) :: dataset , instring PROCEDURE ( ProgressCallBack3 ), POINTER :: proc !$OMP THREADPRIVATE(rlp) ! link the proc procedure to the cproc argument CALL C_F_PROCPOINTER ( cproc , proc ) ! initalize a few variables tpi = 2.D0 * cPi czero = dcmplx ( 0.D0 , 0.D0 ) ! parameters that would normally be read from the MC HDF5 file npx = ipar ( 17 ) nxten = ipar ( 16 ) EkeV = fpar ( 3 ) Ehistmin = fpar ( 4 ) Ebinsize = fpar ( 5 ) depthmax = fpar ( 6 ) depthstep = fpar ( 7 ) numEbins = ipar ( 12 ) Estart = numEbins numzbins = ipar ( 13 ) num_el = ipar ( 3 ) dmin = fpar ( 11 ) nthreads = ipar ( 18 ) etotal = dble ( ipar ( 4 )) * dble ( ipar ( 5 )) ! extract the BetheParameters ... BetheParameters % c1 = fpar ( 12 ) BetheParameters % c2 = fpar ( 13 ) BetheParameters % c3 = fpar ( 14 ) !============================================= !============================================= ! crystallography section nullify ( cell ) allocate ( cell ) ! lattice parameters cell % a = dble ( latparm ( 1 )) cell % b = dble ( latparm ( 2 )) cell % c = dble ( latparm ( 3 )) cell % alpha = dble ( latparm ( 4 )) cell % beta = dble ( latparm ( 5 )) cell % gamma = dble ( latparm ( 6 )) ! symmetry parameters cell % xtal_system = ipar ( 8 ) cell % SYM_SGset = ipar ( 11 ) cell % SYM_SGnum = ipar ( 10 ) if (( cell % SYM_SGnum . ge . 143 ). and .( cell % SYM_SGnum . le . 167 )) then cell % SG % SYM_trigonal = . TRUE . else cell % SG % SYM_trigonal = . FALSE . end if ! atom type and coordinate parameters cell % ATOM_ntype = ipar ( 9 ) cell % ATOM_type ( 1 : cell % ATOM_ntype ) = atomtypes ( 1 : cell % ATOM_ntype ) cell % ATOM_pos ( 1 : cell % ATOM_ntype , 1 : 5 ) = atompos ( 1 : cell % ATOM_ntype , 1 : 5 ) ! generate the symmetry operations cell % hexset = . FALSE . if ( cell % xtal_system . eq . 4 ) cell % hexset = . TRUE . if (( cell % xtal_system . eq . 5 ). AND .( cell % SYM_SGset . ne . 2 )) cell % hexset = . TRUE . ! compute the metric matrices call CalcMatrices ( cell ) ! First generate the point symmetry matrices, then the actual space group. ! Get the symmorphic space group corresponding to the point group ! of the actual space group ipg = 0 do i = 1 , 32 if ( SGPG ( i ). le . cell % SYM_SGnum ) ipg = i end do ! if the actual group is also the symmorphic group, then both ! steps can be done simultaneously, otherwise two calls to ! GenerateSymmetry are needed. if ( SGPG ( ipg ). eq . cell % SYM_SGnum ) then call GenerateSymmetry ( cell ,. TRUE .) else isave = cell % SYM_SGnum cell % SYM_SGnum = SGPG ( ipg ) call GenerateSymmetry ( cell ,. TRUE .) cell % SYM_SGnum = isave call GenerateSymmetry ( cell ,. FALSE .) end if ! next we get all the atom positions call CalcPositions ( cell , 'v' ) ! voltage will be set in the energyloop later on... cell % voltage = dble ( EkeV ) skip = 3 ! always use Weickenmeier&Kohl scattering coefficients, including absorptive form factors call CalcWaveLength ( cell , rlp , skip ) ! compute the range of reflections for the lookup table and allocate the table ! The master list is easily created by brute force imh = 1 do dhkl = 1.0 / CalcLength ( cell , ( / float ( imh ) , 0.0_sgl , 0.0_sgl / ), 'r' ) if ( dhkl . lt . dmin ) EXIT imh = imh + 1 end do imk = 1 do dhkl = 1.0 / CalcLength ( cell , ( / 0.0_sgl , float ( imk ), 0.0_sgl / ), 'r' ) if ( dhkl . lt . dmin ) EXIT imk = imk + 1 end do iml = 1 do dhkl = 1.0 / CalcLength ( cell , ( / 0.0_sgl , 0.0_sgl , float ( iml ) / ), 'r' ) if ( dhkl . lt . dmin ) EXIT iml = iml + 1 end do ! the LUT array stores all the Fourier coefficients, so that we only need to compute them once... i.e., here and now allocate ( cell % LUT ( - 2 * imh : 2 * imh , - 2 * imk : 2 * imk , - 2 * iml : 2 * iml ), stat = istat ) if ( istat . ne . 0 ) call FatalError ( 'InitializeCell:' , ' unable to allocate cell%LUT array' ) cell % LUT = dcmplx ( 0.D0 , 0.D0 ) allocate ( cell % LUTqg ( - 2 * imh : 2 * imh , - 2 * imk : 2 * imk , - 2 * iml : 2 * iml ), stat = istat ) if ( istat . ne . 0 ) call FatalError ( 'InitializeCell:' , ' unable to allocate cell%LUTqg array' ) cell % LUTqg = dcmplx ( 0.D0 , 0.D0 ) ! allocate an array that keeps track of potential double diffraction reflections allocate ( cell % dbdiff ( - 2 * imh : 2 * imh , - 2 * imk : 2 * imk , - 2 * iml : 2 * iml ), stat = istat ) if ( istat . ne . 0 ) call FatalError ( 'InitializeCell:' , ' unable to allocate cell%dbdiff array' ) cell % dbdiff = . FALSE . ddt = 1.0e-5 ! changed from 1.0e-10 on 08/14/15 by MDG in response to some issues with double ! diffraction spots not being taken into account in EBSD master pattern simulations ! next, we compute the overall lookup table cell%LUT; we do not, at this point, create a ! list of linked reflections; in the old code, this was done at the same time, but it appears ! it is better to decouple these two computations. In this new approach, we'll compute a much ! shorter linked list based on the incident wave vector direction. ! first, we deal with the transmitted beam gg = ( / 0 , 0 , 0 / ) call CalcUcg ( cell , rlp , gg , applyqgshift = . TRUE .) Dyn % Upz = rlp % Vpmod ! U'0 normal absorption parameter ! and add this reflection to the look-up table cell % LUT ( 0 , 0 , 0 ) = rlp % Ucg cell % LUTqg ( 0 , 0 , 0 ) = rlp % qg ! now do the same for the other allowed reflections ! note that the lookup table must be twice as large as the list of participating reflections, ! since the dynamical matrix uses g-h as its index !!! ixl : do ix =- 2 * imh , 2 * imh iyl : do iy =- 2 * imk , 2 * imk izl : do iz =- 2 * iml , 2 * iml gg = ( / ix , iy , iz / ) if ( IsGAllowed ( cell , gg )) then ! is this reflection allowed by lattice centering ? ! add the reflection to the look up table call CalcUcg ( cell , rlp , gg , applyqgshift = . TRUE .) cell % LUT ( ix , iy , iz ) = rlp % Ucg cell % LUTqg ( ix , iy , iz ) = rlp % qg ! flag this reflection as a double diffraction candidate if cabs(Ucg)<ddt threshold if ( cabs ( rlp % Ucg ). le . ddt ) then cell % dbdiff ( ix , iy , iz ) = . TRUE . end if end if ! IsGAllowed end do izl end do iyl end do ixl ! determine the point group number j = 0 do i = 1 , 32 if ( SGPG ( i ). le . cell % SYM_SGnum ) j = i end do isym = j ! here is new code dealing with all the special cases (quite a few more compared to the ! Laue group case)...  isym is the point group number. Once the symmetry case has been ! fully determined (taking into account things like 31m and 3m1 an such), then the only places ! that symmetry is handled are the modified Calckvectors routine, and the filling of the modified ! Lambert projections after the dynamical simulation step.  We are also changing the name of the ! sr array (or srhex) to mLPNH and mLPSH (modified Lambert Projection Northern/Southern Hemisphere). ! Here, we encode isym into a new number that describes the sampling scheme; the new schemes are ! described in detail in the EBSD manual pdf file. SamplingType = PGSamplingType ( isym ) ! next, intercept the special cases (hexagonal vs. rhombohedral cases that require special treatment) if (( SamplingType . eq . - 1 ). or .( isym . eq . 14 ). or .( isym . eq . 26 )) then SamplingType = getHexvsRho ( cell , isym ) end if ! if the point group is trigonal or hexagonal, we need to switch usehex to .TRUE. so that ! the program will use the hexagonal sampling method usehex = . FALSE . if (( cell % xtal_system . eq . 4 ). or .( cell % xtal_system . eq . 5 )) usehex = . TRUE . ! ---------- end of symmetry and crystallography section !============================================= !============================================= !============================================= !============================================= ! this is where we determine the value for the thickness integration limit for the CalcLgh3 routine... allocate ( EkeVs ( numEbins ), thick ( numEbins )) do i = 1 , numEbins EkeVs ( i ) = Ehistmin + float ( i - 1 ) * Ebinsize end do ! then, for each energy determine the 95% histogram thickness izzmax = 0 do iE = 1 , numEbins do ix =- nxten , nxten do iy =- nxten , nxten istat = sum ( accum_z ( iE ,:, ix , iy )) izz = 1 do while ( sum ( accum_z ( iE , 1 : izz , ix , iy )). lt .( 0.99 * istat )) izz = izz + 1 end do if ( izz . gt . izzmax ) izzmax = izz end do end do thick ( iE ) = dble ( izzmax ) * depthstep end do izz = nint ( maxval ( thick ) / depthstep ) allocate ( lambdaE ( 1 : numEbins , 1 : izz ), stat = istat ) do iE = 1 , numEbins do iz = 1 , izz lambdaE ( iE , iz ) = float ( sum ( accum_z ( iE , iz , - nxten : nxten , - nxten : nxten ))) / etotal end do end do ! ---------- end of 'read Monte Carlo output file and extract necessary parameters' section !============================================= !============================================= !============================================= !============================================= ! ---------- a couple of initializations numset = cell % ATOM_ntype npy = npx allocate ( svals ( numset ), stat = istat ) gzero = 1 ! index of incident beam debug = 0 ! no longer used ! ---------- !============================================= !============================================= !============================================= !============================================= ! ---------- allocate memory for the master patterns (done in calling program) ! allocate(mLPNH(-emnl%npx:emnl%npx,-npy:npy,1,1:numset),stat=istat) ! allocate(mLPSH(-emnl%npx:emnl%npx,-npy:npy,1,1:numset),stat=istat) ! set various arrays to zero mLPNH = 0.0 mLPSH = 0.0 ! force dynamical matrix routine to read new Bethe parameters from file ! this will all be changed with the new version of the Bethe potentials ! these parameters were already defined above, having been passed in ! from the external calling program !  call Set_Bethe_Parameters(BetheParameters) ! set the callback parameters dn = 1 cn = dn cn2 = 0 totn2 = Estart !============================================= !============================================= ! ---------- from here on, we need to repeat the entire computation for each energy value cancelerr = 0 energyloop : do iE = Estart , 1 , - 1 cn2 = cn2 + dn ! set the accelerating voltage skip = 3 cell % voltage = dble ( EkeVs ( iE )) call CalcWaveLength ( cell , rlp , skip ) !============================================= ! ---------- create the incident beam directions list ! determine all independent incident beam directions (use a linked list starting at khead) ! numk is the total number of k-vectors to be included in this computation; ! note that this needs to be redone for each energy, since the wave vector changes with energy nullify ( khead ) if ( usehex ) then call Calckvectors ( khead , cell , ( / 0.D0 , 0.D0 , 1.D0 / ), ( / 0.D0 , 0.D0 , 0.D0 / ), 0.D0 , npx , npy , numk , & SamplingType , ijmax , 'RoscaLambert' , usehex ) else call Calckvectors ( khead , cell , ( / 0.D0 , 0.D0 , 1.D0 / ), ( / 0.D0 , 0.D0 , 0.D0 / ), 0.D0 , npx , npy , numk , & SamplingType , ijmax , 'RoscaLambert' , usehex ) end if totn = numk cn = dn ! convert part of the kvector linked list into arrays for OpenMP allocate ( karray ( 4 , numk ), kij ( 3 , numk ), stat = istat ) ! point to the first beam direction ktmp => khead ! and loop through the list, keeping k, kn, and i,j karray ( 1 : 3 , 1 ) = sngl ( ktmp % k ( 1 : 3 )) karray ( 4 , 1 ) = sngl ( ktmp % kn ) kij ( 1 : 3 , 1 ) = ( / ktmp % i , ktmp % j , ktmp % hs / ) do ik = 2 , numk ktmp => ktmp % next karray ( 1 : 3 , ik ) = sngl ( ktmp % k ( 1 : 3 )) karray ( 4 , ik ) = sngl ( ktmp % kn ) kij ( 1 : 3 , ik ) = ( / ktmp % i , ktmp % j , ktmp % hs / ) end do ! and remove the linked list call Delete_kvectorlist ( khead ) verbose = . FALSE . totstrong = 0 totweak = 0 ! ---------- end of \"create the incident beam directions list\" !============================================= ! here's where we introduce the OpenMP calls, to spead up the overall calculations... ! set the number of OpenMP threads call OMP_SET_NUM_THREADS ( nthreads ) ! use OpenMP to run on multiple cores ... !$OMP PARALLEL COPYIN(rlp) & !$OMP& PRIVATE(DynMat,Sgh,Lgh,ik,FN,TID,kn,ipx,ipy,ix,iequiv,nequiv,reflist,firstw) & !$OMP& PRIVATE(kkk,nns,nnw,nref,svals,nat) SHARED(cancelerr) NUMTHREADS = OMP_GET_NUM_THREADS () TID = OMP_GET_THREAD_NUM () !$OMP DO SCHEDULE(DYNAMIC,100) ! ---------- and here we start the beam direction loop beamloop : do ik = 1 , numk !============================================= ! ---------- create the master reflection list for this beam direction ! Then we must determine the masterlist of reflections (also a linked list); ! This list basically samples a large reciprocal space volume; it does not ! distinguish between zero and higher order Laue zones, since that ! distinction becomes meaningless when we consider the complete ! reciprocal lattice. nullify ( reflist ) kkk = karray ( 1 : 3 , ik ) FN = kkk call Initialize_ReflectionList ( cell , reflist , BetheParameters , FN , kkk , sngl ( dmin ), nref ) ! ---------- end of \"create the master reflection list\" !============================================= ! determine strong and weak reflections nullify ( firstw ) nns = 0 nnw = 0 call Apply_BethePotentials ( cell , reflist , firstw , BetheParameters , nref , nns , nnw ) ! generate the dynamical matrix allocate ( DynMat ( nns , nns )) call GetDynMat ( cell , reflist , firstw , rlp , DynMat , nns , nnw ) totstrong = totstrong + nns totweak = totweak + nnw ! then we need to initialize the Sgh and Lgh arrays if ( allocated ( Sgh )) deallocate ( Sgh ) if ( allocated ( Lgh )) deallocate ( Lgh ) allocate ( Sgh ( nns , nns , numset ), Lgh ( nns , nns )) Sgh = czero Lgh = czero nat = 0 call CalcSgh ( cell , reflist , nns , numset , Sgh , nat ) ! solve the dynamical eigenvalue equation for this beam direction kn = karray ( 4 , ik ) call CalcLgh ( DynMat , Lgh , dble ( thick ( iE )), dble ( kn ), nns , gzero , depthstep , lambdaE ( iE , 1 : izzmax ), izzmax ) deallocate ( DynMat ) ! sum over the element-wise (Hadamard) product of the Lgh and Sgh arrays svals = 0.0 do ix = 1 , numset svals ( ix ) = real ( sum ( Lgh ( 1 : nns , 1 : nns ) * Sgh ( 1 : nns , 1 : nns , ix ))) end do svals = svals / float ( sum ( nat ( 1 : numset ))) ! and store the resulting svals values, applying point group symmetry where needed. ipx = kij ( 1 , ik ) ipy = kij ( 2 , ik ) ipz = kij ( 3 , ik ) ! if ( usehex ) then call Apply3DPGSymmetry ( cell , ipx , ipy , ipz , npx , iequiv , nequiv , usehex ) else if (( cell % SYM_SGnum . ge . 195 ). and .( cell % SYM_SGnum . le . 230 )) then call Apply3DPGSymmetry ( cell , ipx , ipy , ipz , npx , iequiv , nequiv , cubictype = SamplingType ) else call Apply3DPGSymmetry ( cell , ipx , ipy , ipz , npx , iequiv , nequiv ) end if end if !$OMP CRITICAL do ix = 1 , nequiv if ( iequiv ( 3 , ix ). eq . - 1 ) mLPSH ( iequiv ( 1 , ix ), iequiv ( 2 , ix ), iE , 1 : numset ) = svals ( 1 : numset ) if ( iequiv ( 3 , ix ). eq . 1 ) mLPNH ( iequiv ( 1 , ix ), iequiv ( 2 , ix ), iE , 1 : numset ) = svals ( 1 : numset ) end do !$OMP END CRITICAL call Delete_gvectorlist ( reflist ) ! has the cancel flag been set by the calling program ? !!!!$OMP CANCELLATION POINT if ( cancel . ne . char ( 0 )) then !$OMP ATOMIC WRITE cancelerr = 1 !$OMP CANCEL DO end if ! update the progress counter and report it to the calling program via the proc callback routine !$OMP CRITICAL if ( objAddress . ne . 0 ) then cn = cn + dn if ( mod ( cn , 1000 ). eq . 0 ) then call proc ( objAddress , cn , totn , cn2 , totn2 ) end if end if !$OMP END CRITICAL end do beamloop ! end of OpenMP portion !$OMP END PARALLEL ! was the Cancel button pressed in the calling program? if ( cancelerr . ne . 0 ) EXIT energyloop deallocate ( karray , kij ) if ( usehex ) then ! and finally, we convert the hexagonally sampled array to a square Lambert projection which will be used ! for all EBSD pattern interpolations;  we need to do this for both the Northern and Southern hemispheres ! we begin by allocating auxiliary arrays to hold copies of the hexagonal data; the original arrays will ! then be overwritten with the newly interpolated data. allocate ( auxNH ( - npx : npx , - npy : npy , 1 : numset ), stat = istat ) allocate ( auxSH ( - npx : npx , - npy : npy , 1 : numset ), stat = istat ) auxNH = mLPNH ( - npx : npx , - npy : npy , iE , 1 : numset ) auxSH = mLPSH ( - npx : npx , - npy : npy , iE , 1 : numset ) ! edge = 1.D0 / dble ( npx ) scl = float ( npx ) do i =- npx , npx do j =- npy , npy ! determine the spherical direction for this point xy = ( / dble ( i ), dble ( j ) / ) * edge dc = LambertSquareToSphere ( xy , ierr ) ! convert direction cosines to hexagonal Lambert projections xy = scl * LambertSphereToHex ( dc , ierr ) ! interpolate intensity from the neighboring points if ( ierr . eq . 0 ) then nix = floor ( xy ( 1 )) niy = floor ( xy ( 2 )) nixp = nix + 1 niyp = niy + 1 if ( nixp . gt . npx ) nixp = nix if ( niyp . gt . npx ) niyp = niy dx = xy ( 1 ) - nix dy = xy ( 2 ) - niy dxm = 1.D0 - dx dym = 1.D0 - dy mLPNH ( i , j , iE , 1 : numset ) = auxNH ( nix , niy , 1 : numset ) * dxm * dym + auxNH ( nixp , niy , 1 : numset ) * dx * dym + & auxNH ( nix , niyp , 1 : numset ) * dxm * dy + auxNH ( nixp , niyp , 1 : numset ) * dx * dy mLPSH ( i , j , iE , 1 : numset ) = auxSH ( nix , niy , 1 : numset ) * dxm * dym + auxSH ( nixp , niy , 1 : numset ) * dx * dym + & auxSH ( nix , niyp , 1 : numset ) * dxm * dy + auxSH ( nixp , niyp , 1 : numset ) * dx * dy end if end do end do deallocate ( auxNH , auxSH ) end if ! make sure that the outer pixel rim of the mLPSH patterns is identical to ! that of the mLPNH array. mLPSH ( - npx , - npx : npx , iE , 1 : numset ) = mLPNH ( - npx , - npx : npx , iE , 1 : numset ) mLPSH ( npx , - npx : npx , iE , 1 : numset ) = mLPNH ( npx , - npx : npx , iE , 1 : numset ) mLPSH ( - npx : npx , - npx , iE , 1 : numset ) = mLPNH ( - npx : npx , - npx , iE , 1 : numset ) mLPSH ( - npx : npx , npx , iE , 1 : numset ) = mLPNH ( - npx : npx , npx , iE , 1 : numset ) end do energyloop ! that's the end of it... end subroutine EMsoftCgetEBSDmaster !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- ! ! SUBROUTINE:getEBSDPatterns ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief This function can be called as a standalone function to compute an EBSD pattern ! !> @etails The main purpose of this routine and its accompanying wrapper routine is to !> provide a way for an external program to compute a channeling pattern.  The idea is that !> all the necessary arrays and variables are passed in by reference as arguments, without !> the need for the routine to fetch any other data from files etc...  The initial goal is !> to have a function that can be called with the CALL_EXTERNAL mechanism in IDL or MatLab. !> This routine should be called via the getEBSDPatternsWrapper routine!  For calls from !> a C/C++ program, use the EMsoftCgetEBSDPatterns routine instead. ! !> @param ipar array with integer input parameters !> @param fpar array with float input parameters !> @param EBSDpattern output array !> @param quats quaternion input array !> @param accum_e array with Monte Carlo histogram !> @param mLPNH Northern hemisphere master pattern !> @param mLPSH Southern hemisphere master pattern ! !> @date 10/16/15 MDG 1.0 original !> @date 11/02/15 MDG 1.1 simplification of the input variables !> @date 11/04/15 MDG 1.2 added array of quaternions as input parameter; used complete mLPNH/SH arrays with local sum !> @date 01/12/15 MDG 1.3 added arguments and functionality for interface with DREAM.3D and other calling programs !> @date 01/13/15 MDG 1.4 after split with EMsoftCgetEBSDPatterns subroutine, removed DREAM.3D interfacing stuff !> @date 07/10/16 MDG 1.5 added energy min/max parameters !> @date 08/03/16 MDG 1.6 corrected normalizing issue in rgx,y,z arrays that causes NANs to be returned from Lambert projection routines !> @date 08/R2516 MDG 1.7 added transfer optics barrel distortion to rgx,y,z arrays. !-------------------------------------------------------------------------- recursive subroutine getEBSDPatterns ( ipar , fpar , EBSDpattern , quats , accum_e , mLPNH , mLPSH ) !DEC$ ATTRIBUTES DLLEXPORT :: getEBSDPatterns ! the input parameters are all part of a ipar and fpar input arrays instead of the usual namelist structure to ! make this routine callable by external programs; for calls from  C/C++, use the EsoftCgetEBSDPatterns routine instead. ! The following is the mapping for the ipar and fpar arrays: ! ! ipar(1) = 2 if rgx, rgy, rgz detector arrays need to be computed, 1 if not (arrays will have save status) ! ipar(2) = detnumsx ! ipar(3) = detnumsy ! ipar(4) = detnumEbins ! ipar(5) = mcnsx ! ipar(6) = mpnpx ! ipar(7) = numset ! ipar(8) = numquats ! ipar(9) = Eminsel ! ipar(10) = Emaxsel ! fpar(1) = enl%xpc ! fpar(2) = enl%ypc ! fpar(3) = enl%delta ! fpar(4) = enl%MCsig ! fpar(5) = enl%omega ! fpar(6) = enl%thetac ! fpar(7) = enl%L ! fpar(8) = enl%beamcurrent ! fpar(9) = enl%dwelltime ! fpar(10) = enl%alphaBD use local use constants use Lambert use quaternions use , INTRINSIC :: ISO_C_BINDING IMPLICIT NONE integer ( c_size_t ), PARAMETER :: nipar = 10 integer ( c_size_t ), PARAMETER :: nfpar = 10 integer ( c_size_t ), PARAMETER :: nq = 4 integer ( c_size_t ), INTENT ( IN ) :: ipar ( nipar ) real ( kind = sgl ), INTENT ( IN ) :: fpar ( nfpar ) real ( kind = sgl ), INTENT ( IN ) :: quats ( nq , ipar ( 8 )) real ( kind = sgl ), INTENT ( IN ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( kind = sgl ), INTENT ( IN ) :: mLPNH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 4 ), ipar ( 7 )) real ( kind = sgl ), INTENT ( IN ) :: mLPSH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 4 ), ipar ( 7 )) real ( kind = sgl ), INTENT ( OUT ) :: EBSDpattern ( ipar ( 2 ), ipar ( 3 ), ipar ( 8 )) ! variables that must potentially be saved for the next time this function is called real ( kind = sgl ), allocatable , save :: accum_e_detector (:,:,:) real ( kind = sgl ), allocatable , save :: rgx (:,:), rgy (:,:), rgz (:,:) real ( kind = sgl ), allocatable , save :: mLPNHsum (:,:,:), mLPSHsum (:,:,:) real ( kind = sgl ), save :: prefactor ! other variables real ( kind = sgl ), allocatable :: scin_x (:), scin_y (:) ! scintillator coordinate arrays [microns] real ( kind = sgl ), parameter :: dtor = 0.0174533 ! convert from degrees to radians real ( kind = sgl ) :: alp , ca , sa , cw , sw real ( kind = sgl ) :: L2 , Ls , Lc , pcxd , pcyd , xx , yy ! distances integer ( kind = irg ) :: nix , niy , binx , biny , nixp , niyp , i , j , Emin , Emax , istat , k , ip , ipx , ipy ! various parameters real ( kind = sgl ) :: dc ( 3 ), scl , alpha , theta , gam , pcvec ( 3 ), dp , calpha ! direction cosine array real ( kind = sgl ) :: sx , dx , dxm , dy , dym , rhos , x , bindx ! various parameters real ( kind = sgl ) :: ixy ( 2 ) real ( kind = dbl ), parameter :: nAmpere = 6.241D+18 !==================================== ! ------ generate the detector rgx, rgy, rgz arrays if needed (calling program must decide this via ipar(1)) !==================================== if ( ipar ( 1 ). ge . 1 ) then if (( ipar ( 1 ). eq . 2 ). or .(. not . allocated ( mLPNHsum ))) then ! complete reset, including the mLPNHsum and mLPSHsum arrays if ( allocated ( mLPNHsum )) deallocate ( mLPNHsum ) if ( allocated ( mLPSHsum )) deallocate ( mLPSHsum ) allocate ( mLPNHsum ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 4 ))) allocate ( mLPSHsum ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 4 ))) mLPNHsum = sum ( mLPNH , 4 ) mLPSHsum = sum ( mLPSH , 4 ) end if ! This needs to be done only once for a given detector geometry (i.e., when ipar(1)=1 or larger) allocate ( scin_x ( ipar ( 2 )), scin_y ( ipar ( 3 )), stat = istat ) pcxd = fpar ( 1 ) * fpar ( 3 ) pcyd = fpar ( 2 ) * fpar ( 3 ) scin_x = - ( fpar ( 1 ) - ( 1.0 - float ( ipar ( 2 )) ) * 0.5 - ( / ( i - 1 , i = 1 , ipar ( 2 )) / ) ) * fpar ( 3 ) scin_y = ( fpar ( 2 ) - ( 1.0 - float ( ipar ( 3 )) ) * 0.5 - ( / ( i - 1 , i = 1 , ipar ( 3 )) / ) ) * fpar ( 3 ) ! auxiliary angle to rotate between reference frames alp = 0.5 * cPi - ( fpar ( 4 ) - fpar ( 6 )) * dtor ca = cos ( alp ) sa = sin ( alp ) cw = cos ( fpar ( 5 ) * dtor ) sw = sin ( fpar ( 5 ) * dtor ) ! compute auxilliary interpolation arrays if ( allocated ( rgx )) deallocate ( rgx , rgy , rgz ) allocate ( rgx ( ipar ( 2 ), ipar ( 3 )), rgy ( ipar ( 2 ), ipar ( 3 )), rgz ( ipar ( 2 ), ipar ( 3 ))) ! do we need to perform a Barrel Distortion? ! we will do this here by expanding/contracting the radial component of the ! (rgx, rgy) to (rgx,rgy) * (1+alphaBD * (rgx&#94;2+rgy&#94;2)) ! in other words, we pre-distort the sampling grid with the barrel distortion. L2 = fpar ( 7 ) * fpar ( 7 ) do j = 1 , ipar ( 2 ) Ls = - sw * scin_x ( j ) + fpar ( 7 ) * cw Lc = cw * scin_x ( j ) + fpar ( 7 ) * sw do i = 1 , ipar ( 3 ) !    rhos = 1.0/sqrt(sx + scin_y(i)**2) rgx ( j , i ) = ( scin_y ( i ) * ca + sa * Ls ) ! * rhos rgy ( j , i ) = Lc ! * rhos rgz ( j , i ) = ( - sa * scin_y ( i ) + ca * Ls ) ! * rhos ! apply Barrel Distortion ? if ( fpar ( 10 ). ne . 0.0 ) then ! shift the components to the detector center coordinate frame xx = rgx ( j , i ) - pcyd yy = rgy ( j , i ) + pcxd ! compute the distortion amount; the factor of 10&#94;(-10) is inserted here... sx = 1.0 + 1.E-10 * fpar ( 10 ) * ( xx ** 2 + yy ** 2 ) ! and shift them back to the pattern center reference frame rgx ( j , i ) = xx * sx + pcyd rgy ( j , i ) = yy * sx - pcxd end if ! make sure that these vectors are normalized ! x = sqrt ( rgx ( j , i ) ** 2 + rgy ( j , i ) ** 2 + rgz ( j , i ) ** 2 ) rgx ( j , i ) = rgx ( j , i ) / x rgy ( j , i ) = rgy ( j , i ) / x rgz ( j , i ) = rgz ( j , i ) / x end do end do ! test dump of rgx/y/z arrays to check for proper inclusion of barrel distortion: !open(unit=dataunit,file='rgxyz.data',status='unknown',form='unformatted') !write(dataunit) rgx !write(dataunit) rgy !write(dataunit) rgz !close(unit=dataunit,status='keep') ! remove the auxiliary arrays scin_x and scin_y deallocate ( scin_x , scin_y ) !==================================== ! ------ create the equivalent detector energy array !==================================== ! from the Monte Carlo energy data, we need to extract the relevant ! entries for the detector geometry defined above. ! determine the scale factor for the Lambert interpolation; the square has ! an edge length of 2 x sqrt(pi/2) scl = float ( ipar ( 5 )) ! energy summation will go over all energy bins Emin = ipar ( 9 ) Emax = ipar ( 10 ) if ( allocated ( accum_e_detector )) deallocate ( accum_e_detector ) allocate ( accum_e_detector ( ipar ( 4 ), ipar ( 2 ), ipar ( 3 ))) ! correction of change in effective pixel area compared to equal-area Lambert projection alpha = atan ( fpar ( 3 ) / fpar ( 7 ) / sqrt ( sngl ( cPi ))) ipx = ipar ( 2 ) / 2 + nint ( fpar ( 1 )) ipy = ipar ( 3 ) / 2 + nint ( fpar ( 2 )) if (( abs ( ipy ). gt . ipar ( 3 )). or .( abs ( ipx ). gt . ipar ( 2 ))) then pcvec = ( / pcyd * ca + pcxd * sa * sw + fpar ( 7 ) * cw * sa , & fpar ( 7 ) * sw - pcxd * cw ,& fpar ( 7 ) * ca * cw + pcxd * ca * sw - pcyd * sa / ) pcvec = pcvec / NORM2 ( pcvec ) else pcvec = ( / rgx ( ipx , ipy ), rgy ( ipx , ipy ), rgz ( ipx , ipy ) / ) end if calpha = cos ( alpha ) do i = 1 , ipar ( 2 ) do j = 1 , ipar ( 3 ) ! do the coordinate transformation for this detector pixel dc = ( / rgx ( i , j ), rgy ( i , j ), rgz ( i , j ) / ) ! make sure the third one is positive; if not, switch all if ( dc ( 3 ). lt . 0.0 ) dc = - dc ! convert these direction cosines to coordinates in the Rosca-Lambert projection ixy = scl * LambertSphereToSquare ( dc , istat ) x = ixy ( 1 ) ixy ( 1 ) = ixy ( 2 ) ixy ( 2 ) = - x ! four-point interpolation (bi-quadratic) nix = int ( ipar ( 5 ) + ixy ( 1 )) - ipar ( 5 ) niy = int ( ipar ( 5 ) + ixy ( 2 )) - ipar ( 5 ) nixp = nix + 1 niyp = niy + 1 if ( nix . gt . ipar ( 5 )) nix = ipar ( 5 ) if ( niy . gt . ipar ( 5 )) niy = ipar ( 5 ) if ( nix . lt . - ipar ( 5 )) nix = - ipar ( 5 ) if ( niy . lt . - ipar ( 5 )) niy = - ipar ( 5 ) if ( nixp . gt . ipar ( 5 )) nixp = ipar ( 5 ) if ( niyp . gt . ipar ( 5 )) niyp = ipar ( 5 ) if ( nixp . lt . - ipar ( 5 )) nixp = - ipar ( 5 ) if ( niyp . lt . - ipar ( 5 )) niyp = - ipar ( 5 ) dx = ixy ( 1 ) - nix dy = ixy ( 2 ) - niy dxm = 1.0 - dx dym = 1.0 - dy ! do the area correction for this detector pixel dp = dot_product ( pcvec , dc ) if (( i . eq . ipx ). and .( j . eq . ipy )) then gam = 0.25 else gam = (( calpha * calpha + dp * dp - 1.0 ) ** 1.5 ) / ( calpha ** 3 ) * 0.25 end if ! interpolate the intensity do k = Emin , Emax accum_e_detector ( k , i , j ) = gam * ( accum_e ( k , nix , niy ) * dxm * dym + & accum_e ( k , nixp , niy ) * dx * dym + & accum_e ( k , nix , niyp ) * dxm * dy + & accum_e ( k , nixp , niyp ) * dx * dy ) end do end do end do prefactor = 0.25D0 * nAmpere * fpar ( 8 ) * fpar ( 9 ) * 1.0D-15 / sum ( accum_e_detector ) end if ! end of ipar(1)=1 test !open(unit=dataunit,file='TKDdetectorarray_dymod.data',status='unknown',form='unformatted') !write(dataunit) accum_e_detector !close(unit=dataunit,status='keep') ! from here on, we simply compute the EBSD patterns by interpolation, using the saved arrays from above ! no intensity scaling or anything else...other than multiplication by pre-factor ! intensity scaling is left to the user of the calling program. ! define some parameters and initialize EBSDpattern scl = dble ( ipar ( 6 )) EBSDpattern = 0.0 ! here is the main loop over all quaternions quatloop : do ip = 1 , ipar ( 8 ) do i = 1 , ipar ( 2 ) do j = 1 , ipar ( 3 ) ! do the active coordinate transformation for this euler angle dc = quat_Lp ( quats ( 1 : 4 , ip ), ( / rgx ( i , j ), rgy ( i , j ), rgz ( i , j ) / ) ) ! normalize dc dc = dc / sqrt ( sum ( dc * dc )) ! convert these direction cosines to coordinates in the Rosca-Lambert projection (always square projection !!!) ixy = scl * LambertSphereToSquare ( dc , istat ) if ( istat . eq . 0 ) then ! four-point interpolation (bi-quadratic) nix = int ( ipar ( 6 ) + ixy ( 1 )) - ipar ( 6 ) niy = int ( ipar ( 6 ) + ixy ( 2 )) - ipar ( 6 ) nixp = nix + 1 niyp = niy + 1 if ( nix . gt . ipar ( 6 )) nix = ipar ( 6 ) if ( niy . gt . ipar ( 6 )) niy = ipar ( 6 ) if ( nix . lt . - ipar ( 6 )) nix = - ipar ( 6 ) if ( niy . lt . - ipar ( 6 )) niy = - ipar ( 6 ) if ( nixp . gt . ipar ( 6 )) nixp = ipar ( 6 ) if ( niyp . gt . ipar ( 6 )) niyp = ipar ( 6 ) if ( nixp . lt . - ipar ( 6 )) nixp = - ipar ( 6 ) if ( niyp . lt . - ipar ( 6 )) niyp = - ipar ( 6 ) dx = ixy ( 1 ) - nix dy = ixy ( 2 ) - niy dxm = 1.0 - dx dym = 1.0 - dy if ( dc ( 3 ). gt . 0.0 ) then ! we're in the Northern hemisphere do k = Emin , Emax EBSDpattern ( i , j , ip ) = EBSDpattern ( i , j , ip ) + accum_e_detector ( k , i , j ) * ( mLPNHsum ( nix , niy , k ) * dxm * dym + & mLPNHsum ( nixp , niy , k ) * dx * dym + mLPNHsum ( nix , niyp , k ) * dxm * dy + & mLPNHsum ( nixp , niyp , k ) * dx * dy ) end do else ! we're in the Southern hemisphere do k = Emin , Emax EBSDpattern ( i , j , ip ) = EBSDpattern ( i , j , ip ) + accum_e_detector ( k , i , j ) * ( mLPSHsum ( nix , niy , k ) * dxm * dym + & mLPSHsum ( nixp , niy , k ) * dx * dym + mLPSHsum ( nix , niyp , k ) * dxm * dy + & mLPSHsum ( nixp , niyp , k ) * dx * dy ) end do end if end if end do end do end do quatloop ! finally, scale the patterns by the appropriate factor and return to the calling program EBSDpattern = prefactor * EBSDpattern end subroutine getEBSDPatterns !-------------------------------------------------------------------------- ! ! SUBROUTINE:getEBSDPatterns2 ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief This function can be called as a standalone function to compute an EBSD pattern ! !> @etails The main purpose of this routine and its accompanying wrapper routine is to !> provide a way for an external program to compute a channeling pattern.  The idea is that !> all the necessary arrays and variables are passed in by reference as arguments, without !> the need for the routine to fetch any other data from files etc...  The initial goal is !> to have a function that can be called with the CALL_EXTERNAL mechanism in IDL or MatLab. !> This routine should be called via the getEBSDPatternsWrapper routine!  For calls from !> a C/C++ program, use the EMsoftCgetEBSDPatterns routine instead.  This routine is a slightly !> modified version of the regular getEBSDPatterns routine and does not SAVE any variables. ! !> @param ipar array with integer input parameters !> @param fpar array with float input parameters !> @param EBSDpattern output array !> @param quats quaternion input array !> @param accum_e array with Monte Carlo histogram !> @param mLPNH Northern hemisphere master pattern !> @param mLPSH Southern hemisphere master pattern ! !> @date 10/16/15 MDG 1.0 original !> @date 11/02/15 MDG 1.1 simplification of the input variables !> @date 11/04/15 MDG 1.2 added array of quaternions as input parameter; used complete mLPNH/SH arrays with local sum !> @date 01/12/15 MDG 1.3 added arguments and functionality for interface with DREAM.3D and other calling programs !> @date 01/13/15 MDG 1.4 after split with EMsoftCgetEBSDPatterns subroutine, removed DREAM.3D interfacing stuff !> @date 07/10/16 MDG 1.5 added energy min/max parameters !> @date 08/03/16 MDG 1.6 corrected normalizing issue in rgx,y,z arrays that causes NANs to be returned from Lambert projection routines !> @date 08/25/16 MDG 1.7 added transfer optics barrel distortion to rgx,y,z arrays. !> @date 04/24/17 MDG 1.8 forked from original routine without SAVEd variables !-------------------------------------------------------------------------- recursive subroutine getEBSDPatterns2 ( ipar , fpar , EBSDpattern , quats , accum_e , mLPNHsum , mLPSHsum ) !DEC$ ATTRIBUTES DLLEXPORT :: getEBSDPatterns2 ! the input parameters are all part of a ipar and fpar input arrays instead of the usual namelist structure to ! make this routine callable by external programs; for calls from  C/C++, use the EsoftCgetEBSDPatterns routine instead. ! The following is the mapping for the ipar and fpar arrays: ! ! ipar(1) = 2 if rgx, rgy, rgz detector arrays need to be computed, 1 if not (arrays will have save status) ! ipar(2) = detnumsx ! ipar(3) = detnumsy ! ipar(4) = detnumEbins ! ipar(5) = mcnsx ! ipar(6) = mpnpx ! ipar(7) = numset ! ipar(8) = numquats ! ipar(9) = Eminsel ! ipar(10) = Emaxsel ! fpar(1) = enl%xpc ! fpar(2) = enl%ypc ! fpar(3) = enl%delta ! fpar(4) = enl%MCsig ! fpar(5) = enl%omega ! fpar(6) = enl%thetac ! fpar(7) = enl%L ! fpar(8) = enl%beamcurrent ! fpar(9) = enl%dwelltime ! fpar(10) = enl%alphaBD use local use constants use Lambert use quaternions use , INTRINSIC :: ISO_C_BINDING IMPLICIT NONE integer ( c_size_t ), PARAMETER :: nipar = 10 integer ( c_size_t ), PARAMETER :: nfpar = 10 integer ( c_size_t ), PARAMETER :: nq = 4 integer ( c_size_t ), INTENT ( IN ) :: ipar ( nipar ) real ( kind = sgl ), INTENT ( IN ) :: fpar ( nfpar ) real ( kind = sgl ), INTENT ( IN ) :: quats ( nq , ipar ( 8 )) real ( kind = sgl ), INTENT ( IN ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( kind = sgl ), INTENT ( IN ) :: mLPNHsum ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 4 )) real ( kind = sgl ), INTENT ( IN ) :: mLPSHsum ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 4 )) real ( kind = sgl ), INTENT ( OUT ) :: EBSDpattern ( ipar ( 2 ), ipar ( 3 ), ipar ( 8 )) ! allocatable variables real ( kind = sgl ), allocatable :: accum_e_detector (:,:,:) real ( kind = sgl ), allocatable :: rgx (:,:), rgy (:,:), rgz (:,:) real ( kind = sgl ), save :: prefactor ! other variables real ( kind = sgl ), allocatable :: scin_x (:), scin_y (:) ! scintillator coordinate arrays [microns] real ( kind = sgl ), parameter :: dtor = 0.0174533 ! convert from degrees to radians real ( kind = sgl ) :: alp , ca , sa , cw , sw real ( kind = sgl ) :: L2 , Ls , Lc , pcxd , pcyd , xx , yy ! distances integer ( kind = irg ) :: nix , niy , binx , biny , nixp , niyp , i , j , Emin , Emax , istat , k , ip , ipx , ipy ! various parameters real ( kind = sgl ) :: dc ( 3 ), scl , alpha , theta , gam , pcvec ( 3 ), dp , calpha ! direction cosine array real ( kind = sgl ) :: sx , dx , dxm , dy , dym , rhos , x , bindx ! various parameters real ( kind = sgl ) :: ixy ( 2 ) real ( kind = dbl ), parameter :: nAmpere = 6.241D+18 !==================================== ! ------ generate the detector rgx, rgy, rgz arrays !==================================== ! This needs to be done only once for a given detector geometry (i.e., when ipar(1)=1 or larger) allocate ( scin_x ( ipar ( 2 )), scin_y ( ipar ( 3 )), stat = istat ) pcxd = fpar ( 1 ) * fpar ( 3 ) pcyd = fpar ( 2 ) * fpar ( 3 ) scin_x = - ( fpar ( 1 ) - ( 1.0 - float ( ipar ( 2 )) ) * 0.5 - ( / ( i - 1 , i = 1 , ipar ( 2 )) / ) ) * fpar ( 3 ) scin_y = ( fpar ( 2 ) - ( 1.0 - float ( ipar ( 3 )) ) * 0.5 - ( / ( i - 1 , i = 1 , ipar ( 3 )) / ) ) * fpar ( 3 ) ! auxiliary angle to rotate between reference frames alp = 0.5 * cPi - ( fpar ( 4 ) - fpar ( 6 )) * dtor ca = cos ( alp ) sa = sin ( alp ) cw = cos ( fpar ( 5 ) * dtor ) sw = sin ( fpar ( 5 ) * dtor ) ! compute auxilliary interpolation arrays allocate ( rgx ( ipar ( 2 ), ipar ( 3 )), rgy ( ipar ( 2 ), ipar ( 3 )), rgz ( ipar ( 2 ), ipar ( 3 ))) ! do we need to perform a Barrel Distortion? ! we will do this here by expanding/contracting the radial component of the ! (rgx, rgy) to (rgx,rgy) * (1+alphaBD * (rgx&#94;2+rgy&#94;2)) ! in other words, we pre-distort the sampling grid with the barrel distortion. L2 = fpar ( 7 ) * fpar ( 7 ) do j = 1 , ipar ( 2 ) Ls = - sw * scin_x ( j ) + fpar ( 7 ) * cw Lc = cw * scin_x ( j ) + fpar ( 7 ) * sw do i = 1 , ipar ( 3 ) !    rhos = 1.0/sqrt(sx + scin_y(i)**2) rgx ( j , i ) = ( scin_y ( i ) * ca + sa * Ls ) ! * rhos rgy ( j , i ) = Lc ! * rhos rgz ( j , i ) = ( - sa * scin_y ( i ) + ca * Ls ) ! * rhos ! apply Barrel Distortion ? if ( fpar ( 10 ). ne . 0.0 ) then ! shift the components to the detector center coordinate frame xx = rgx ( j , i ) - pcyd yy = rgy ( j , i ) + pcxd ! compute the distortion amount; the factor of 10&#94;(-10) is inserted here... sx = 1.0 + 1.E-10 * fpar ( 10 ) * ( xx ** 2 + yy ** 2 ) ! and shift them back to the pattern center reference frame rgx ( j , i ) = xx * sx + pcyd rgy ( j , i ) = yy * sx - pcxd end if ! make sure that these vectors are normalized ! x = sqrt ( rgx ( j , i ) ** 2 + rgy ( j , i ) ** 2 + rgz ( j , i ) ** 2 ) rgx ( j , i ) = rgx ( j , i ) / x rgy ( j , i ) = rgy ( j , i ) / x rgz ( j , i ) = rgz ( j , i ) / x end do end do ! remove the auxiliary arrays scin_x and scin_y deallocate ( scin_x , scin_y ) !==================================== ! ------ create the equivalent detector energy array !==================================== ! from the Monte Carlo energy data, we need to extract the relevant ! entries for the detector geometry defined above. ! determine the scale factor for the Lambert interpolation; the square has ! an edge length of 2 x sqrt(pi/2) scl = float ( ipar ( 5 )) ! energy summation will go over all energy bins Emin = ipar ( 9 ) Emax = ipar ( 10 ) allocate ( accum_e_detector ( ipar ( 4 ), ipar ( 2 ), ipar ( 3 ))) ! correction of change in effective pixel area compared to equal-area Lambert projection alpha = atan ( fpar ( 3 ) / fpar ( 7 ) / sqrt ( sngl ( cPi ))) ipx = ipar ( 2 ) / 2 + nint ( fpar ( 1 )) ipy = ipar ( 3 ) / 2 + nint ( fpar ( 2 )) if ( ipx . gt . ipar ( 2 )) ipx = ipar ( 2 ) if ( ipx . lt . 1 ) ipx = 1 if ( ipy . gt . ipar ( 3 )) ipy = ipar ( 3 ) if ( ipy . lt . 1 ) ipy = 1 pcvec = ( / rgx ( ipx , ipy ), rgy ( ipx , ipy ), rgz ( ipx , ipy ) / ) calpha = cos ( alpha ) do i = 1 , ipar ( 2 ) do j = 1 , ipar ( 3 ) ! do the coordinate transformation for this detector pixel dc = ( / rgx ( i , j ), rgy ( i , j ), rgz ( i , j ) / ) ! make sure the third one is positive; if not, switch all if ( dc ( 3 ). lt . 0.0 ) dc = - dc ! convert these direction cosines to coordinates in the Rosca-Lambert projection ixy = scl * LambertSphereToSquare ( dc , istat ) x = ixy ( 1 ) ixy ( 1 ) = ixy ( 2 ) ixy ( 2 ) = - x ! four-point interpolation (bi-quadratic) nix = int ( ipar ( 5 ) + ixy ( 1 )) - ipar ( 5 ) niy = int ( ipar ( 5 ) + ixy ( 2 )) - ipar ( 5 ) nixp = nix + 1 niyp = niy + 1 if ( nix . gt . ipar ( 5 )) nix = ipar ( 5 ) if ( niy . gt . ipar ( 5 )) niy = ipar ( 5 ) if ( nix . lt . - ipar ( 5 )) nix = - ipar ( 5 ) if ( niy . lt . - ipar ( 5 )) niy = - ipar ( 5 ) if ( nixp . gt . ipar ( 5 )) nixp = ipar ( 5 ) if ( niyp . gt . ipar ( 5 )) niyp = ipar ( 5 ) if ( nixp . lt . - ipar ( 5 )) nixp = - ipar ( 5 ) if ( niyp . lt . - ipar ( 5 )) niyp = - ipar ( 5 ) dx = ixy ( 1 ) - nix dy = ixy ( 2 ) - niy dxm = 1.0 - dx dym = 1.0 - dy ! do the area correction for this detector pixel dp = dot_product ( pcvec , dc ) if (( i . eq . ipx ). and .( j . eq . ipy )) then gam = 0.25 else gam = (( calpha * calpha + dp * dp - 1.0 ) ** 1.5 ) / ( calpha ** 3 ) * 0.25 end if ! interpolate the intensity do k = Emin , Emax accum_e_detector ( k , i , j ) = gam * ( accum_e ( k , nix , niy ) * dxm * dym + & accum_e ( k , nixp , niy ) * dx * dym + & accum_e ( k , nix , niyp ) * dxm * dy + & accum_e ( k , nixp , niyp ) * dx * dy ) end do end do end do prefactor = 0.25D0 * nAmpere * fpar ( 8 ) * fpar ( 9 ) * 1.0D-15 / sum ( accum_e_detector ) ! from here on, we simply compute the EBSD patterns by interpolation, ! no intensity scaling or anything else...other than multiplication by pre-factor ! intensity scaling is left to the user of the calling program. ! define some parameters and initialize EBSDpattern scl = dble ( ipar ( 6 )) EBSDpattern = 0.0 ! here is the main loop over all quaternions quatloop : do ip = 1 , ipar ( 8 ) do i = 1 , ipar ( 2 ) do j = 1 , ipar ( 3 ) ! do the active coordinate transformation for this euler angle dc = quat_Lp ( quats ( 1 : 4 , ip ), ( / rgx ( i , j ), rgy ( i , j ), rgz ( i , j ) / ) ) ! normalize dc dc = dc / sqrt ( sum ( dc * dc )) ! convert these direction cosines to coordinates in the Rosca-Lambert projection (always square projection !!!) ixy = scl * LambertSphereToSquare ( dc , istat ) if ( istat . eq . 0 ) then ! four-point interpolation (bi-quadratic) nix = int ( ipar ( 6 ) + ixy ( 1 )) - ipar ( 6 ) niy = int ( ipar ( 6 ) + ixy ( 2 )) - ipar ( 6 ) nixp = nix + 1 niyp = niy + 1 if ( nix . gt . ipar ( 6 )) nix = ipar ( 6 ) if ( niy . gt . ipar ( 6 )) niy = ipar ( 6 ) if ( nix . lt . - ipar ( 6 )) nix = - ipar ( 6 ) if ( niy . lt . - ipar ( 6 )) niy = - ipar ( 6 ) if ( nixp . gt . ipar ( 6 )) nixp = ipar ( 6 ) if ( niyp . gt . ipar ( 6 )) niyp = ipar ( 6 ) if ( nixp . lt . - ipar ( 6 )) nixp = - ipar ( 6 ) if ( niyp . lt . - ipar ( 6 )) niyp = - ipar ( 6 ) dx = ixy ( 1 ) - nix dy = ixy ( 2 ) - niy dxm = 1.0 - dx dym = 1.0 - dy if ( dc ( 3 ). gt . 0.0 ) then ! we're in the Northern hemisphere do k = Emin , Emax EBSDpattern ( i , j , ip ) = EBSDpattern ( i , j , ip ) + accum_e_detector ( k , i , j ) * ( mLPNHsum ( nix , niy , k ) * dxm * dym + & mLPNHsum ( nixp , niy , k ) * dx * dym + mLPNHsum ( nix , niyp , k ) * dxm * dy + & mLPNHsum ( nixp , niyp , k ) * dx * dy ) end do else ! we're in the Southern hemisphere do k = Emin , Emax EBSDpattern ( i , j , ip ) = EBSDpattern ( i , j , ip ) + accum_e_detector ( k , i , j ) * ( mLPSHsum ( nix , niy , k ) * dxm * dym + & mLPSHsum ( nixp , niy , k ) * dx * dym + mLPSHsum ( nix , niyp , k ) * dxm * dy + & mLPSHsum ( nixp , niyp , k ) * dx * dy ) end do end if end if end do end do end do quatloop deallocate ( accum_e_detector ) ! finally, scale the patterns by the appropriate factor and return to the calling program EBSDpattern = prefactor * EBSDpattern end subroutine getEBSDPatterns2 !-------------------------------------------------------------------------- ! ! SUBROUTINE:getECPatterns ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief This function can be called as a standalone function to compute an electron channeling pattern !> based on Marc's code above ! !> @etails The main purpose of this routine and its accompanying wrapper routine is to !> provide a way for an external program to compute an EC pattern.  The idea is that !> all the necessary arrays and variables are passed in by reference as arguments, without !> the need for the routine to fetch any other data from files etc...  The initial goal is !> to have a function that can be called with the CALL_EXTERNAL mechanism in IDL, but !> in the long run this will also be the approach for calling the routine from C/C++, which !> is an essential part of integration with DREAM.3D.  This routine is a simplified version !> of the core of the EMECP program. !> !> This routine will first compute the incident cone vectors etc. if necessary, and then perform !> the usual interpolation from the square Lambert projection. The pattern will be a basic pattern, !> without any intensity scaling or binning etc; the calling program should take care of those !> operations. ! !> @param ipar array with integer input parameters !> @param fpar array with float input parameters !> @param ECPattern output array !> @param quats array of quaternions !> @param accum_e array with Monte Carlo histogram !> @param mLPNH Northern hemisphere master pattern !> @param mLPSH Southern hemisphere master pattern ! !> @date 10/16/15  SS 1.0 original !> @date 11/02/14 MDG 1.1 put all integer parameters inside ipar and fixed size of ipar/fpar !> @date 11/04/15 MDG 1.2 added array of quaternions as input parameter !-------------------------------------------------------------------------- recursive subroutine getECPatterns ( ipar , fpar , ECpattern , quats , accum_e , mLPNH , mLPSH ) !DEC$ ATTRIBUTES DLLEXPORT :: GetECPatterns ! the input parameters are all part of a ipar and fpar input arrays instead of the usual namelist structures. ! The following is the mapping: ! ! ipar(1) = 1 if GetVectorsCone detector arrays need to be computed, 0 if not (arrays will have save status) ! ipar(2) = detnumsx ! ipar(3) = detnumsy ! ipar(4) = numangle ! ipar(5) = mcnsx ! ipar(6) = numset ! ipar(7) = mpnpx ! ipar(8) = numquats ! fpar(1) = ecpnl%thetac ! fpar(2) = ecpnl%sampletilt ! fpar(3) = ecpnl%workingdistance ! fpar(4) = ecpnl%Rin ! fpar(5) = ecpnl%Rout ! fpar(6) = ecpnl%sigstart ! fpar(7) = ecpnl%sigend ! fpar(8) = ecpnl%sigstep !!!!!!!! removed:  fpar(9-12) =  quaternion for requested Euler angles use local use constants use Lambert use quaternions use distortion use , INTRINSIC :: ISO_C_BINDING IMPLICIT NONE integer ( c_size_t ), PARAMETER :: nipar = 8 integer ( c_size_t ), PARAMETER :: nfpar = 8 integer ( c_size_t ), PARAMETER :: nq = 4 integer ( c_size_t ), INTENT ( IN ) :: ipar ( nipar ) real ( kind = sgl ), INTENT ( IN ) :: fpar ( nfpar ) real ( kind = sgl ), INTENT ( OUT ) :: ECpattern ( ipar ( 2 ), ipar ( 3 ), ipar ( 8 )) real ( kind = sgl ), INTENT ( IN ) :: quats ( nq , ipar ( 8 )) real ( kind = sgl ), INTENT ( IN ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( kind = sgl ), INTENT ( IN ) :: mLPNH ( - ipar ( 7 ): ipar ( 7 ), - ipar ( 7 ): ipar ( 7 ), ipar ( 6 )) real ( kind = sgl ), INTENT ( IN ) :: mLPSH ( - ipar ( 7 ): ipar ( 7 ), - ipar ( 7 ): ipar ( 7 ), ipar ( 6 )) real ( kind = sgl ), allocatable , save :: klist (:,:,:), rgx (:,:), rgy (:,:), rgz (:,:), weightfact (:) real ( kind = sgl ), allocatable , save :: mLPNHsum (:,:), mLPSHsum (:,:) real ( kind = dbl ), parameter :: Rtod = 5 7.2957795131D0 real ( kind = dbl ), parameter :: dtoR = 0.01745329251D0 real ( kind = sgl ) :: kk ( 3 ), thetacr , ktmax , delta , wf , quat ( 4 ) integer ( kind = irg ) :: istat , imin , imax , jmin , jmax , ii , jj , nazimuth , npolar , nsig , ip integer ( kind = irg ) :: ipolar , iazimuth , isig , isampletilt , nix , niy , nixp , niyp , isigp real ( kind = sgl ) :: thetain , thetaout , polar , azimuthal , delpolar , delazimuth , om ( 3 , 3 ) real ( kind = sgl ) :: dc ( 3 ), scl , deltheta , acc_sum , MCangle , ixy ( 2 ), dx , dy , dxm , dym , dp !================================================================================== ! ------ generate the detector klist, rgx, rgy, rgz, weightfactors arrays if needed !------- (calling program must decide this via ipar(1)) !================================================================================== imin = 1 imax = ipar ( 2 ) jmin = 1 jmax = ipar ( 3 ) if ( ipar ( 1 ). ge . 1 ) then if ( ipar ( 1 ). eq . 2 ) then ! complete reset, including the mLPNHsum and mLPSHsum arrays if ( allocated ( mLPNHsum )) deallocate ( mLPNHsum ) if ( allocated ( mLPSHsum )) deallocate ( mLPSHsum ) allocate ( mLPNHsum ( - ipar ( 7 ): ipar ( 7 ), - ipar ( 7 ): ipar ( 7 ))) allocate ( mLPSHsum ( - ipar ( 7 ): ipar ( 7 ), - ipar ( 7 ): ipar ( 7 ))) mLPNHsum = sum ( mLPNH , 3 ) mLPSHsum = sum ( mLPSH , 3 ) end if if ( allocated ( klist )) deallocate ( klist ) allocate ( klist ( 1 : 3 , 1 : ipar ( 2 ), 1 : ipar ( 3 )), stat = istat ) kk = ( / 0.0 , 0.0 , 1.0 / ) thetacr = DtoR * fpar ( 1 ) ktmax = tan ( thetacr ) delta = 2.0 * ktmax / dble ( ipar ( 2 ) - 1 ) do ii = imin , imax do jj = jmin , jmax klist ( 1 : 3 , ii , jj ) = ( /- ktmax + delta * ( ii - 1 ), - ktmax + delta * ( jj - 1 ), 0.0 / ) + kk ( 1 : 3 ) klist ( 1 : 3 , ii , jj ) = klist ( 1 : 3 , ii , jj ) / sqrt ( sum ( klist ( 1 : 3 , ii , jj ) ** 2 )) end do end do thetain = atan2 ( fpar ( 4 ), fpar ( 3 )) thetaout = atan2 ( fpar ( 5 ), fpar ( 3 )) om ( 1 ,:) = ( / cos ( fpar ( 2 ) * sngl ( dtor )), 0.0 , sin ( fpar ( 2 ) * sngl ( dtor )) / ) om ( 2 ,:) = ( / 0.0 , 1.0 , 0.0 / ) om ( 3 ,:) = ( /- sin ( fpar ( 2 ) * sngl ( dtor )), 0.0 , cos ( fpar ( 2 ) * sngl ( dtor )) / ) npolar = nint (( thetaout - thetain ) * 18 0.0 / cPi ) + 1 delpolar = ( thetaout - thetain ) / float ( npolar - 1 ) nazimuth = 361 delazimuth = 2.0 * cPi / float ( nazimuth - 1 ) if ( allocated ( rgx )) deallocate ( rgx , rgy , rgz ) allocate ( rgx ( npolar , nazimuth ), rgy ( npolar , nazimuth ), rgz ( npolar , nazimuth ), stat = istat ) do ipolar = 1 , npolar polar = thetain + float ( ipolar - 1 ) * delpolar do iazimuth = 1 , nazimuth azimuthal = float ( iazimuth - 1 ) * delazimuth dc ( 1 ) = cos ( azimuthal ) * sin ( polar ) dc ( 2 ) = sin ( azimuthal ) * sin ( polar ) dc ( 3 ) = cos ( polar ) dc = matmul ( om , dc ) rgx ( ipolar , iazimuth ) = dc ( 1 ) rgy ( ipolar , iazimuth ) = dc ( 2 ) rgz ( ipolar , iazimuth ) = dc ( 3 ) end do end do !=================================================================== ! ------ generate the weight factors from the monte carlo histogram !=================================================================== scl = float ( ipar ( 5 )) nsig = nint ( fpar ( 1 ) + abs ( fpar ( 2 ))) + 1 deltheta = ( fpar ( 1 ) + abs ( fpar ( 2 ))) / float ( nsig - 1 ) if ( allocated ( weightfact )) deallocate ( weightfact ) allocate ( weightfact ( 1 : nsig ), stat = istat ) weightfact = 0.0 do isig = 1 , nsig acc_sum = 0.0 MCangle = ( isig - 1 ) * deltheta isampletilt = nint (( MCangle - fpar ( 6 )) / fpar ( 8 )) if ( isampletilt . lt . 1 ) then isampletilt = abs ( isampletilt ) + 1 else isampletilt = isampletilt + 1 end if do ipolar = 1 , npolar do iazimuth = 1 , nazimuth dc ( 1 : 3 ) = ( / rgx ( ipolar , iazimuth ), rgy ( ipolar , iazimuth ), rgz ( ipolar , iazimuth ) / ) ! convert to Rosca-lambert projection ixy = scl * LambertSphereToSquare ( dc , istat ) nix = int ( ipar ( 5 ) + ixy ( 1 )) - ipar ( 5 ) niy = int ( ipar ( 5 ) + ixy ( 2 )) - ipar ( 5 ) nixp = nix + 1 niyp = niy + 1 if ( nixp . gt . ipar ( 5 )) nixp = nix if ( niyp . gt . ipar ( 5 )) niyp = niy if ( nix . lt . - ipar ( 5 )) nix = nixp if ( niy . lt . - ipar ( 5 )) niy = niyp dx = ixy ( 1 ) - nix dy = ixy ( 2 ) - niy dxm = 1.0 - dx dym = 1.0 - dy acc_sum = 0.25 * ( accum_e ( isampletilt , nix , niy ) * dxm * dym + & accum_e ( isampletilt , nixp , niy ) * dx * dym + & accum_e ( isampletilt , nix , niyp ) * dxm * dy + & accum_e ( isampletilt , nixp , niyp ) * dx * dy ) weightfact ( isig ) = weightfact ( isig ) + acc_sum end do end do end do weightfact ( 1 : nsig ) = weightfact ( 1 : nsig ) / weightfact ( 1 ) end if !=================================================================== ! ------ perform interpolation from square lambert map !=================================================================== scl = float ( ipar ( 7 )) do ip = 1 , ipar ( 8 ) do ii = imin , imax do jj = jmin , jmax dc ( 1 : 3 ) = klist ( 1 : 3 , ii , jj ) dc = dc / sqrt ( sum ( dc * dc )) dp = DOT_PRODUCT ( dc ( 1 : 3 ),( / sin ( fpar ( 2 ) * dtoR ), 0.D0 , cos ( fpar ( 2 ) * dtoR ) / )) if ( dp . gt . 1.D0 ) dp = 1.0 MCangle = acos ( dp ) * Rtod isig = int ( MCangle ) + 1 if ( isig . gt . nsig ) isig = nsig isigp = isig + 1 if ( isigp . gt . nsig ) isigp = nsig dx = MCangle - int ( MCangle ) dxm = 1.0 - dx wf = weightfact ( isig ) * dxm + weightfact ( isigp ) * dx wf = 1.0 dc = quat_LP ( quats ( 1 : 4 , ip ), dc ) dc = dc / sqrt ( sum ( dc * dc )) ixy = scl * LambertSphereToSquare ( dc , istat ) nix = int ( ipar ( 7 ) + ixy ( 1 )) - ipar ( 7 ) niy = int ( ipar ( 7 ) + ixy ( 2 )) - ipar ( 7 ) nixp = nix + 1 niyp = niy + 1 if ( nixp . gt . ipar ( 7 )) nixp = nix if ( niyp . gt . ipar ( 7 )) niyp = niy if ( nix . lt . - ipar ( 7 )) nix = nixp if ( niy . lt . - ipar ( 7 )) niy = niyp dx = ixy ( 1 ) - nix dy = ixy ( 2 ) - niy dxm = 1.0 - dx dym = 1.0 - dy if ( dc ( 3 ). gt . 0.0 ) then ECpattern ( ii , jj , ip ) = wf * ( mLPNHsum ( nix , niy ) * dxm * dym + & mLPNHsum ( nixp , niy ) * dx * dym + & mLPNHsum ( nix , niyp ) * dxm * dy + & mLPNHsum ( nixp , niyp ) * dx * dy ) else ECpattern ( ii , jj , ip ) = wf * ( mLPSHsum ( nix , niy ) * dxm * dym + & mLPSHsum ( nixp , niy ) * dx * dym + & mLPSHsum ( nix , niyp ) * dxm * dy + & mLPSHsum ( nixp , niyp ) * dx * dy ) end if end do end do end do end subroutine getECPatterns !-------------------------------------------------------------------------- ! ! SUBROUTINE:getKosselPatterns ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief This function can be called as a standalone function to compute a Kossel pattern ! !> @etails The main purpose of this routine and its accompanying wrapper routine is to !> provide a way for an external program to compute a Kossel pattern.  The idea is that !> all the necessary arrays and variables are passed in by reference as arguments, without !> the need for the routine to fetch any other data from files etc...  The initial goal is !> to have a function that can be called with the CALL_EXTERNAL mechanism in IDL, but !> in the long run this will also be the approach for calling the routine from C/C++, which !> is an essential part of integration with DREAM.3D. !> !> This routine will first compute the incident cone vectors etc. if necessary, and then perform !> the usual interpolation from the square Lambert projection. The pattern will be a basic pattern, !> without any intensity scaling or binning etc; the calling program should take care of those !> operations. This is simpler than the ECP case, since there is no energy dependent stuff to !> worry about. We're also keeping the ipar and fpar arrays the same as for the ECP case, even !> though we could in principle simplify them; this facilitates integration with the SEMDisplay !> program. ! !> @param ipar array with integer input parameters !> @param fpar array with float input parameters !> @param KosselPattern output array !> @param quats array of quaternions !> @param mLPNH Northern hemisphere master pattern !> @param mLPSH Southern hemisphere master pattern ! !> @date 11/09/15 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine getKosselPatterns ( ipar , fpar , Kosselpattern , quats , mLPNH , mLPSH ) !DEC$ ATTRIBUTES DLLEXPORT :: getKosselPatterns ! the input parameters are all part of a ipar and fpar input arrays instead of the usual namelist structures. ! The following is the mapping: ! ! ipar(1) = 1 if GetVectorsCone detector arrays need to be computed, 0 if not (arrays will have save status) ! ipar(2) = detnumsx ! ipar(3) = mpnpx ! ipar(4) = numquats ! ipar(5) = numdepths ! ipar(6) = depthsel ! fpar(1) = ecpnl%thetac use local use constants use Lambert use quaternions use , INTRINSIC :: ISO_C_BINDING IMPLICIT NONE integer ( c_size_t ), PARAMETER :: nipar = 6 integer ( c_size_t ), PARAMETER :: nfpar = 1 integer ( c_size_t ), PARAMETER :: nq = 4 integer ( c_size_t ), INTENT ( IN ) :: ipar ( nipar ) real ( kind = sgl ), INTENT ( IN ) :: fpar ( nfpar ) real ( kind = sgl ), INTENT ( OUT ) :: Kosselpattern ( ipar ( 2 ), ipar ( 2 ), ipar ( 4 )) real ( kind = sgl ), INTENT ( IN ) :: quats ( nq , ipar ( 4 )) real ( kind = sgl ), INTENT ( IN ) :: mLPNH ( - ipar ( 3 ): ipar ( 3 ), - ipar ( 3 ): ipar ( 3 ), ipar ( 5 )) real ( kind = sgl ), INTENT ( IN ) :: mLPSH ( - ipar ( 3 ): ipar ( 3 ), - ipar ( 3 ): ipar ( 3 ), ipar ( 5 )) real ( kind = sgl ), allocatable , save :: klist (:,:,:) real ( kind = dbl ), parameter :: Rtod = 5 7.2957795131D0 real ( kind = dbl ), parameter :: dtoR = 0.01745329251D0 real ( kind = sgl ) :: kk ( 3 ), thetacr , ktmax , delta , quat ( 4 ) integer ( kind = irg ) :: istat , imin , imax , jmin , jmax , ii , jj , nsig , ip integer ( kind = irg ) :: isig , nix , niy , nixp , niyp , isigp real ( kind = sgl ) :: dc ( 3 ), scl , ixy ( 2 ), dx , dy , dxm , dym , dp !================================================================================== ! ------ generate the detector klist array if needed !------- (calling program must decide this via ipar(1)) !================================================================================== if ( ipar ( 1 ). ge . 1 ) then if ( allocated ( klist )) deallocate ( klist ) allocate ( klist ( 1 : 3 , - ipar ( 2 ): ipar ( 2 ), - ipar ( 2 ): ipar ( 2 )), stat = istat ) kk = ( / 0.0 , 0.0 , 1.0 / ) thetacr = DtoR * fpar ( 1 ) ktmax = tan ( thetacr ) delta = 2.0 * ktmax / dble ( ipar ( 2 ) - 1 ) imin = 1 imax = ipar ( 2 ) jmin = 1 jmax = ipar ( 2 ) do ii = imin , imax do jj = jmin , jmax klist ( 1 : 3 , ii , jj ) = ( /- ktmax + delta * ( ii - 1 ), - ktmax + delta * ( jj - 1 ), 0.0 / ) + kk ( 1 : 3 ) klist ( 1 : 3 , ii , jj ) = klist ( 1 : 3 , ii , jj ) / sqrt ( sum ( klist ( 1 : 3 , ii , jj ) ** 2 )) end do end do end if !=================================================================== ! ------ perform interpolation from square lambert map !=================================================================== scl = float ( ipar ( 3 )) do ip = 1 , ipar ( 4 ) do ii = imin , imax do jj = jmin , jmax dc ( 1 : 3 ) = klist ( 1 : 3 , ii , jj ) dc = quat_LP ( quats ( 1 : 4 , ip ), dc ) dc = dc / sqrt ( sum ( dc * dc )) ixy = scl * LambertSphereToSquare ( dc , istat ) nix = int ( ipar ( 3 ) + ixy ( 1 )) - ipar ( 3 ) niy = int ( ipar ( 3 ) + ixy ( 2 )) - ipar ( 3 ) nixp = nix + 1 niyp = niy + 1 if ( nixp . gt . ipar ( 3 )) nixp = nix if ( niyp . gt . ipar ( 3 )) niyp = niy if ( nix . lt . - ipar ( 3 )) nix = nixp if ( niy . lt . - ipar ( 3 )) niy = niyp dx = ixy ( 1 ) - nix dy = ixy ( 2 ) - niy dxm = 1.0 - dx dym = 1.0 - dy if ( dc ( 3 ). gt . 0.0 ) then Kosselpattern ( ii , jj , ip ) = mLPNH ( nix , niy , ipar ( 6 )) * dxm * dym + & mLPNH ( nixp , niy , ipar ( 6 )) * dx * dym + & mLPNH ( nix , niyp , ipar ( 6 )) * dxm * dy + & mLPNH ( nixp , niyp , ipar ( 6 )) * dx * dy else Kosselpattern ( ii , jj , ip ) = mLPSH ( nix , niy , ipar ( 6 )) * dxm * dym + & mLPSH ( nixp , niy , ipar ( 6 )) * dx * dym + & mLPSH ( nix , niyp , ipar ( 6 )) * dxm * dy + & mLPSH ( nixp , niyp , ipar ( 6 )) * dx * dy end if end do end do end do end subroutine getKosselPatterns !-------------------------------------------------------------------------- ! ! SUBROUTINE:EBSD4calfun ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief This function is used by bobyqa to fit an EBSD pattern ! !> @details The main purpose of this routine is to calculte the difference of 1 with the dot !> product of an experimental pattern with the given set of detector parameters. This is used !> by bobyqa module to fit an EBSD pattern when 4 patterns are fitted simultaneously !> !> This routine will first compute the detector arrays rgx etc. if necessary, and then perform !> the usual interpolation from the square Lambert projection. The pattern will be a basic pattern, !> without any intensity scaling or binning etc; the calling program should take care of those !> operations. ! !> @param ipar array with integer input parameters !> @param fpar array with float input parameters !> @param initmeanval mean value of search space !> @param EBSDpattern output array !> @param quats quaternion input array !> @param accum_e array with Monte Carlo histogram !> @param mLPNH Northern hemisphere master pattern !> @param mLPSH Southern hemisphere master pattern ! !> @date 12/12/15 SS 1.0 original !> @date 03/28/16 SS 1.1 omega is no longer a variable parameter !-------------------------------------------------------------------------- recursive subroutine EBSD4calfun ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt , accum_e , & mLPNH , mLPSH , n , x , f , expt2 , expt3 , expt4 , nstep , stepsize , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: EBSD4calfun ! the input parameters are all part of a ipar and fpar input arrays instead of the usual namelist structures. ! The following is the mapping: ! ! ipar(1) = 2 ! ipar(2) = detnumsx ! ipar(3) = detnumsy ! ipar(4) = detnumEbins ! ipar(5) = mcnsx ! ipar(6) = mpnpx ! ipar(7) = numset ! ipar(8) = numquats ! ipar(9) = Emin ! ipar(10) = Emax ! ipar(11) = 0/1 ;0 for no mask, 1 for mask ! ipar(12) = binning ! ipar(13) = pixx_pat1 ! ipar(14) = pixy_pat1 ! ipar(15) = pixx_pat2 ! ipar(16) = pixy_pat2 ! ipar(17) = pixx_pat3 ! ipar(18) = pixy_pat3 ! ipar(19) = pixx_pat4 ! ipar(20) = pixy_pat4 ! fpar(1) = enl%xpc ! fpar(2) = enl%ypc ! fpar(3) = enl%delta ! fpar(4) = enl%MCsig ! fpar(5) = enl%omega ! fpar(6) = enl%thetac ! fpar(7) = enl%L ! fpar(8) = enl%beamcurrent ! fpar(9) = enl%dwelltime ! fpar(10) = enl%gammavalue ! fpar(11) = maskradius ! fpar(12) = stepx ! fpar(13) = stepy ! initmeanval(1) = fpar(7) ! initmeanval(2) = phi1 ! initmeanval(3) = phi ! initmeanval(4) = phi2 ! initmeanval(5) = xpc ! initmeanval(6) = ypc ! stepsize(1) = step_xpc ! stepsize(2) = step_ypc ! stepsize(3) = step_phi1 ; all 4 patterns ! stepsize(4) = step_phi ; all 4 patterns ! stepsize(5) = step_phi2 ; all 4 patterns ! stepsize(6) = step_L ! X = (/xpc, ypc, omega, L, phi1, phi, phi2/) use local use rotations use constants use distortion use filters use Indexingmod , ONLY : Jaccard_Distance use , INTRINSIC :: ISO_C_BINDING implicit none integer ( irg ), intent ( in ) :: nipar integer ( irg ), intent ( in ) :: nfpar integer ( irg ), intent ( in ) :: ninit integer ( c_size_t ), intent ( in ) :: ipar ( nipar ) real ( sgl ), intent ( inout ) :: fpar ( nfpar ) real ( sgl ), intent ( in ) :: initmeanval ( ninit ) integer ( irg ), intent ( in ) :: nstep real ( sgl ), intent ( in ) :: stepsize ( nstep ) real ( c_float ), intent ( in ) :: expt ( ipar ( 2 ) * ipar ( 3 ) / ipar ( 12 ) / ipar ( 12 )) real ( c_float ), intent ( in ) :: expt2 ( ipar ( 2 ) * ipar ( 3 ) / ipar ( 12 ) / ipar ( 12 )) real ( c_float ), intent ( in ) :: expt3 ( ipar ( 2 ) * ipar ( 3 ) / ipar ( 12 ) / ipar ( 12 )) real ( c_float ), intent ( in ) :: expt4 ( ipar ( 2 ) * ipar ( 3 ) / ipar ( 12 ) / ipar ( 12 )) real ( kind = sgl ), INTENT ( in ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( kind = sgl ), INTENT ( in ) :: mLPNH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) real ( kind = sgl ), INTENT ( in ) :: mLPSH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) integer ( irg ), intent ( in ) :: n real ( dbl ), dimension (:), intent ( in ) :: x real ( dbl ), intent ( out ) :: f logical , intent ( in ), optional :: verbose integer ( kind = irg ) :: nnx , nny , binx , biny complex ( dbl ) :: D real ( kind = sgl ) :: quats ( 4 , 1 ), bindx , ma , mi real ( kind = sgl ), allocatable :: EBSDpattern (:,:,:), binned (:,:) real ( kind = sgl ), allocatable :: EBSDpatternintd (:,:) integer ( kind = irg ), allocatable :: EBSDpatterninteger (:,:), EBSDpatternad (:,:) ! variables that must be saved for the next time this function is called real ( kind = sgl ) :: prefactor integer ( kind = irg ), allocatable :: img1 (:), img2 (:), img_fit_cumul (:), img_expt_cumul (:) ! other variables real ( kind = sgl ), parameter :: dtor = 0.0174533 ! convert from degrees to radians real ( kind = sgl ) :: ixy ( 2 ), eu ( 3 ), eu2 ( 3 ), eu3 ( 3 ), eu4 ( 3 ) real ( kind = sgl ), allocatable :: EBSDvector (:), EBSDflip (:,:), mask (:,:) integer ( kind = irg ) :: i , j , istat logical :: stat , readonly integer ( kind = irg ) :: hdferr , nlines real ( kind = sgl ) :: fpar2 ( nfpar ) !fpar(1) = sngl(X(1))*ipar(2) - ipar(2)/2 + initmeanval(5) ! xpc +/- detnumx/2 pixels !fpar(2) = sngl(X(2))*ipar(3) - ipar(3)/2 + initmeanval(6) ! ypc +/- detnumy/2 pixels fpar ( 1 ) = sngl ( X ( 1 )) * 2.0 * stepsize ( 1 ) - stepsize ( 1 ) + initmeanval ( 5 ) ! xpc +/- 5 pixels fpar ( 2 ) = sngl ( X ( 2 )) * 2.0 * stepsize ( 2 ) - stepsize ( 2 ) + initmeanval ( 6 ) ! ypc +/- 5 pixels !fpar(1) = initmeanval(5) ! xpc +/- detnumx/2 pixels !fpar(2) = initmeanval(6) ! ypc +/- detnumy/2 pixels fpar ( 7 ) = sngl ( X ( 4 )) * 2.0 * stepsize ( 6 ) * fpar ( 3 ) - stepsize ( 6 ) * fpar ( 3 ) + initmeanval ( 1 ) ! mean +/- 5 pixels !fpar(7) = initmeanval(1) ! mean +/- 2000 microns ! 03/28/16 omega is no longer a variable parameter anymore fpar ( 5 ) = sngl ( X ( 3 )) * 0.0 - 0.0 ! omega 0 +/- 5 degrees !eu = (/initmeanval(2), initmeanval(3), initmeanval(4)/)*dtor ! don't change the values for euler angles eu = ( / X ( 5 ) * 2.0 * stepsize ( 3 ) - stepsize ( 3 ) + initmeanval ( 2 ), X ( 6 ) * 2.0 * stepsize ( 4 ) - stepsize ( 4 ) + initmeanval ( 3 ), & X ( 7 ) * 2.0 * stepsize ( 5 ) - stepsize ( 5 ) + initmeanval ( 4 ) / ) * dtor ! mean +/- 2 degrees eu2 = ( / X ( 8 ) * 2.0 * stepsize ( 3 ) - stepsize ( 3 ) + initmeanval ( 7 ), X ( 9 ) * 2.0 * stepsize ( 4 ) - stepsize ( 4 ) + initmeanval ( 8 ), & X ( 10 ) * 2.0 * stepsize ( 5 ) - stepsize ( 5 ) + initmeanval ( 9 ) / ) * dtor ! mean +/- 2 degrees eu3 = ( / X ( 11 ) * 2.0 * stepsize ( 3 ) - stepsize ( 3 ) + initmeanval ( 10 ), X ( 12 ) * 2.0 * stepsize ( 4 ) - stepsize ( 4 ) + initmeanval ( 11 ), & X ( 13 ) * 2.0 * stepsize ( 5 ) - stepsize ( 5 ) + initmeanval ( 12 ) / ) * dtor ! mean +/- 2 degrees eu4 = ( / X ( 14 ) * 2.0 * stepsize ( 3 ) - stepsize ( 3 ) + initmeanval ( 13 ), X ( 15 ) * 2.0 * stepsize ( 4 ) - stepsize ( 4 ) + initmeanval ( 14 ), & X ( 16 ) * 2.0 * stepsize ( 5 ) - stepsize ( 5 ) + initmeanval ( 15 ) / ) * dtor ! mean +/- 2 degrees !D = dcmplx(X(8)*0.000002D0 - 0.000001D0 + dble(initmeanval(5)), X(9)*0.000002D0 - 0.000001D0 + dble(initmeanval(6))) binx = ipar ( 2 ) / ipar ( 12 ) biny = ipar ( 3 ) / ipar ( 12 ) bindx = 1.0 / float ( ipar ( 12 ) ** 2 ) allocate ( EBSDvector ( binx * biny ), mask ( binx , biny )) allocate ( EBSDpattern ( ipar ( 2 ), ipar ( 3 ), 1 )) allocate ( binned ( binx , biny )) allocate ( EBSDpatternintd ( ipar ( 2 ), ipar ( 3 )), EBSDpatterninteger ( ipar ( 2 ), ipar ( 3 )), EBSDpatternad ( ipar ( 2 ), ipar ( 3 ))) allocate ( img1 ( binx * biny ), img2 ( binx * biny )) allocate ( img_fit_cumul ( 4 * binx * biny ), img_expt_cumul ( 4 * binx * biny )) binned = 0.0 EBSDpatternintd = 0.0 EBSDpatterninteger = 0 EBSDpatternad = 0 img1 = 0 img2 = 0 img_fit_cumul = 0 img_expt_cumul = 0 mask = 1.0 if ( present ( verbose )) then if ( verbose ) then print * , 'xpc, ypc, L, eu_pat1, eu_pat2, eu_pat3, eu_pat4 = ' , fpar ( 1 ), fpar ( 2 ), fpar ( 7 ), eu ( 1 : 3 ) * 18 0.0 / cPi ,& eu2 ( 1 : 3 ) * 18 0.0 / cPi , eu3 ( 1 : 3 ) * 18 0.0 / cPi , eu4 ( 1 : 3 ) * 18 0.0 / cPi end if end if fpar2 ( 1 : nfpar ) = fpar ( 1 : nfpar ) !============================================================================== !============IMAGE 1=========================================================== !============================================================================== quats ( 1 : 4 , 1 ) = eu2qu ( eu ) fpar2 ( 1 : nfpar ) = fpar ( 1 : nfpar ) fpar2 ( 1 ) = fpar ( 1 ) + ipar ( 13 ) * fpar ( 12 ) / fpar ( 3 ) fpar2 ( 2 ) = fpar ( 2 ) - ipar ( 14 ) * fpar ( 13 ) / fpar ( 3 ) call getEBSDPatterns ( ipar , fpar2 , EBSDpattern , quats , accum_e , mLPNH , mLPSH ) !nnx = ipar(2) !nny = ipar(3) !EBSDpatternintd = ((EBSDPattern(:,:,1) - mi)/ (ma-mi)) !EBSDpatterninteger = nint(EBSDpatternintd*255.0) !EBSDpatternad =  adhisteq(10,nnx,nny,EBSDpatterninteger) !EBSDPattern(:,:,1) = float(EBSDpatternad) if ( ipar ( 12 ) . ne . 1 ) then do i = 1 , binx do j = 1 , biny binned ( i , j ) = sum ( EBSDpattern (( i - 1 ) * ipar ( 12 ) + 1 : i * ipar ( 12 ),( j - 1 ) * ipar ( 12 ) + 1 : j * ipar ( 12 ), 1 )) end do end do binned = binned * bindx else binned ( 1 : binx , 1 : biny ) = EBSDpattern ( 1 : binx , 1 : biny , 1 ) end if if ( ipar ( 11 ) . eq . 1 ) then do i = 1 , binx do j = 1 , biny if ((( float ( i ) - ceiling ( float ( binx ) / 2.0 )) ** 2 + ( float ( j ) - ceiling ( float ( biny ) / 2.0 )) ** 2 ) . gt . fpar ( 11 ) ** 2 ) then mask ( i , j ) = 0.0 end if end do end do end if binned ( 1 : binx , 1 : biny ) = binned ( 1 : binx , 1 : biny ) * mask ( 1 : binx , 1 : biny ) binned = binned ** fpar ( 10 ) do i = 1 , biny do j = 1 , binx EBSDvector (( i - 1 ) * binx + j ) = binned ( j , i ) end do end do ma = maxval ( EBSDvector ) mi = minval ( EBSDvector ) img1 = nint ( 25 5.0 * ( EBSDvector - mi ) / ( ma - mi )) ma = maxval ( expt ) mi = minval ( expt ) img2 = nint ( 25 5.0 * ( expt - mi ) / ( ma - mi )) img_fit_cumul ( 1 : binx * biny ) = img1 ( 1 : binx * biny ) img_expt_cumul ( 1 : binx * biny ) = img2 ( 1 : binx * biny ) !open(unit=13,file='/Users/saranshsingh/Desktop/testd.txt',action='write') !open(unit=14,file='/Users/saranshsingh/Desktop/teste.txt',action='write') !do i = 1,binx !    do j = 1,biny !        write(13,'(F15.6)',advance='no')EBSDvector((i-1)*biny+j) !        write(14,'(F15.6)',advance='no')expt((i-1)*biny+j) !    end do !    write(13,*)'' !    write(14,*)'' !end do !close(13) !close(14) !stop !============================================================================== !============IMAGE 2=========================================================== !============================================================================== quats ( 1 : 4 , 1 ) = eu2qu ( eu2 ) fpar2 ( 1 : nfpar ) = fpar ( 1 : nfpar ) fpar2 ( 1 ) = fpar ( 1 ) + ipar ( 15 ) * fpar ( 12 ) / fpar ( 3 ) fpar2 ( 2 ) = fpar ( 2 ) - ipar ( 16 ) * fpar ( 13 ) / fpar ( 3 ) call getEBSDPatterns ( ipar , fpar2 , EBSDpattern , quats , accum_e , mLPNH , mLPSH ) if ( ipar ( 12 ) . ne . 1 ) then do i = 1 , binx do j = 1 , biny binned ( i , j ) = sum ( EBSDpattern (( i - 1 ) * ipar ( 12 ) + 1 : i * ipar ( 12 ),( j - 1 ) * ipar ( 12 ) + 1 : j * ipar ( 12 ), 1 )) end do end do binned = binned * bindx else binned ( 1 : binx , 1 : biny ) = EBSDpattern ( 1 : binx , 1 : biny , 1 ) end if binned ( 1 : binx , 1 : biny ) = binned ( 1 : binx , 1 : biny ) * mask ( 1 : binx , 1 : biny ) binned = binned ** fpar ( 10 ) do i = 1 , biny do j = 1 , binx EBSDvector (( i - 1 ) * binx + j ) = binned ( j , i ) end do end do ma = maxval ( EBSDvector ) mi = minval ( EBSDvector ) img1 = nint ( 25 5.0 * ( EBSDvector - mi ) / ( ma - mi )) ma = maxval ( expt2 ) mi = minval ( expt2 ) img2 = nint ( 25 5.0 * ( expt2 - mi ) / ( ma - mi )) img_fit_cumul ( binx * biny + 1 : 2 * binx * biny ) = img1 ( 1 : binx * biny ) img_expt_cumul ( binx * biny + 1 : 2 * binx * biny ) = img2 ( 1 : binx * biny ) !============================================================================== !============IMAGE 3=========================================================== !============================================================================== quats ( 1 : 4 , 1 ) = eu2qu ( eu3 ) fpar2 ( 1 : nfpar ) = fpar ( 1 : nfpar ) fpar2 ( 1 ) = fpar ( 1 ) + ipar ( 17 ) * fpar ( 12 ) / fpar ( 3 ) fpar2 ( 2 ) = fpar ( 2 ) - ipar ( 18 ) * fpar ( 13 ) / fpar ( 3 ) call getEBSDPatterns ( ipar , fpar2 , EBSDpattern , quats , accum_e , mLPNH , mLPSH ) if ( ipar ( 12 ) . ne . 1 ) then do i = 1 , binx do j = 1 , biny binned ( i , j ) = sum ( EBSDpattern (( i - 1 ) * ipar ( 12 ) + 1 : i * ipar ( 12 ),( j - 1 ) * ipar ( 12 ) + 1 : j * ipar ( 12 ), 1 )) end do end do binned = binned * bindx else binned ( 1 : binx , 1 : biny ) = EBSDpattern ( 1 : binx , 1 : biny , 1 ) end if binned ( 1 : binx , 1 : biny ) = binned ( 1 : binx , 1 : biny ) * mask ( 1 : binx , 1 : biny ) binned = binned ** fpar ( 10 ) do i = 1 , biny do j = 1 , binx EBSDvector (( i - 1 ) * binx + j ) = binned ( j , i ) end do end do ma = maxval ( EBSDvector ) mi = minval ( EBSDvector ) img1 = nint ( 25 5.0 * ( EBSDvector - mi ) / ( ma - mi )) ma = maxval ( expt3 ) mi = minval ( expt3 ) img2 = nint ( 25 5.0 * ( expt3 - mi ) / ( ma - mi )) img_fit_cumul ( 2 * binx * biny + 1 : 3 * binx * biny ) = img1 ( 1 : binx * biny ) img_expt_cumul ( 2 * binx * biny + 1 : 3 * binx * biny ) = img2 ( 1 : binx * biny ) !============================================================================== !============IMAGE 4=========================================================== !============================================================================== quats ( 1 : 4 , 1 ) = eu2qu ( eu4 ) fpar2 ( 1 : nfpar ) = fpar ( 1 : nfpar ) fpar2 ( 1 ) = fpar ( 1 ) + ipar ( 19 ) * fpar ( 12 ) / fpar ( 3 ) fpar2 ( 2 ) = fpar ( 2 ) - ipar ( 20 ) * fpar ( 13 ) / fpar ( 3 ) call getEBSDPatterns ( ipar , fpar2 , EBSDpattern , quats , accum_e , mLPNH , mLPSH ) if ( ipar ( 12 ) . ne . 1 ) then do i = 1 , binx do j = 1 , biny binned ( i , j ) = sum ( EBSDpattern (( i - 1 ) * ipar ( 12 ) + 1 : i * ipar ( 12 ),( j - 1 ) * ipar ( 12 ) + 1 : j * ipar ( 12 ), 1 )) end do end do binned = binned * bindx else binned ( 1 : binx , 1 : biny ) = EBSDpattern ( 1 : binx , 1 : biny , 1 ) end if binned ( 1 : binx , 1 : biny ) = binned ( 1 : binx , 1 : biny ) * mask ( 1 : binx , 1 : biny ) binned = binned ** fpar ( 10 ) do i = 1 , biny do j = 1 , binx EBSDvector (( i - 1 ) * binx + j ) = binned ( j , i ) end do end do ma = maxval ( EBSDvector ) mi = minval ( EBSDvector ) img1 = nint ( 25 5.0 * ( EBSDvector - mi ) / ( ma - mi )) ma = maxval ( expt4 ) mi = minval ( expt4 ) img2 = nint ( 25 5.0 * ( expt4 - mi ) / ( ma - mi )) img_fit_cumul ( 3 * binx * biny + 1 : 4 * binx * biny ) = img1 ( 1 : binx * biny ) img_expt_cumul ( 3 * binx * biny + 1 : 4 * binx * biny ) = img2 ( 1 : binx * biny ) F = Jaccard_Distance ( img_fit_cumul , img_expt_cumul , 4 * binx * biny ) !F = 1.0 - DOT_PRODUCT(EBSDvector,expt) end subroutine EBSD4calfun !-------------------------------------------------------------------------- ! ! SUBROUTINE:EBSDcalfun ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief This function is used by bobyqa to fit an EBSD pattern ! !> @details The main purpose of this routine is to calculte the difference of 1 with the dot !> product of an experimental pattern with the given set of detector parameters. This is used !> by bobyqa module to fit an EBSD pattern. !> !> This routine will first compute the detector arrays rgx etc. if necessary, and then perform !> the usual interpolation from the square Lambert projection. The pattern will be a basic pattern, !> without any intensity scaling or binning etc; the calling program should take care of those !> operations. ! !> @param ipar array with integer input parameters !> @param fpar array with float input parameters !> @param initmeanval mean value of search space !> @param EBSDpattern output array !> @param quats quaternion input array !> @param accum_e array with Monte Carlo histogram !> @param mLPNH Northern hemisphere master pattern !> @param mLPSH Southern hemisphere master pattern ! !> @date 12/12/15 SS 1.0 original !> @date 03/28/16 SS 1.1 omega is no longer a variable parameter !-------------------------------------------------------------------------- recursive subroutine EBSDcalfun ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt , accum_e , & mLPNH , mLPSH , n , x , f , nstep , stepsize , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: EBSDcalfun ! the input parameters are all part of a ipar and fpar input arrays instead of the usual namelist structures. ! The following is the mapping: ! ! ipar(1) = 2 ! ipar(2) = detnumsx ! ipar(3) = detnumsy ! ipar(4) = detnumEbins ! ipar(5) = mcnsx ! ipar(6) = mpnpx ! ipar(7) = numset ! ipar(8) = numquats ! ipar(9) = Emin ! ipar(10) = Emax ! ipar(11) = 0/1 ;0 for no mask, 1 for mask ! ipar(12) = binning ! ipar(13) = 0/1; 0 for DP and 1 for JD ! ipar(14) = nregions ! fpar(1) = enl%xpc ! fpar(2) = enl%ypc ! fpar(3) = enl%delta ! fpar(4) = enl%MCsig ! fpar(5) = enl%omega ! fpar(6) = enl%thetac ! fpar(7) = enl%L ! fpar(8) = enl%beamcurrent ! fpar(9) = enl%dwelltime ! fpar(10) = alphaBD ; barrell distortion coefficient ! fpar(11) = maskradius ! fpar(12) = enl%gammavalue ! initmeanval(1) = fpar(7) ! initmeanval(2) = phi1 ! initmeanval(3) = phi ! initmeanval(4) = phi2 ! initmeanval(5) = xpc ! initmeanval(6) = ypc ! stepsize(1) = step_xpc ! stepsize(2) = step_ypc ! stepsize(3) = step_phi1 ! stepsize(4) = step_phi ! stepsize(5) = step_phi2 ! stepsize(6) = step_L ! X = (/xpc, ypc, omega, L, phi1, phi, phi2/) use local use rotations use constants use distortion use filters use Indexingmod , ONLY : Jaccard_Distance use , INTRINSIC :: ISO_C_BINDING implicit none integer ( irg ), intent ( in ) :: nipar integer ( irg ), intent ( in ) :: nfpar integer ( irg ), intent ( in ) :: ninit integer ( c_size_t ), intent ( in ) :: ipar ( nipar ) real ( sgl ), intent ( inout ) :: fpar ( nfpar ) real ( sgl ), intent ( in ) :: initmeanval ( ninit ) integer ( irg ), intent ( in ) :: nstep real ( sgl ), intent ( in ) :: stepsize ( nstep ) real ( c_float ), intent ( in ) :: expt ( ipar ( 2 ) * ipar ( 3 ) / ipar ( 12 ) ** 2 ) real ( kind = sgl ), INTENT ( in ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( kind = sgl ), INTENT ( in ) :: mLPNH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) real ( kind = sgl ), INTENT ( in ) :: mLPSH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) integer ( irg ), intent ( in ) :: n real ( dbl ), dimension (:), intent ( in ) :: x real ( dbl ), intent ( out ) :: f logical , intent ( in ), optional :: verbose integer ( kind = irg ) :: nnx , nny , binx , biny complex ( dbl ) :: D real ( kind = sgl ) :: quats ( 4 , 1 ), bindx , ma , mi real ( kind = sgl ), allocatable :: EBSDpattern (:,:,:), binned (:,:) real ( kind = sgl ), allocatable :: EBSDpatternintd (:,:) integer ( kind = irg ), allocatable :: EBSDpatterninteger (:,:), EBSDpatternad (:,:) ! variables that must be saved for the next time this function is called real ( kind = sgl ) :: prefactor integer ( kind = irg ), allocatable :: img1 (:), img2 (:) ! other variables real ( kind = sgl ), parameter :: dtor = 0.0174533 ! convert from degrees to radians real ( kind = sgl ) :: ixy ( 2 ), eu ( 3 ), eu2 ( 3 ), eu3 ( 3 ), eu4 ( 3 ) real ( kind = sgl ), allocatable :: EBSDvector (:), EBSDflip (:,:), mask (:,:) integer ( kind = irg ) :: i , j , istat logical :: stat , readonly integer ( kind = irg ) :: hdferr , nlines , nregions real ( kind = sgl ) :: fpar2 ( 10 ) integer ( kind = 8 ) :: ipar2 ( 10 ) fpar ( 1 ) = sngl ( X ( 1 )) * 2.0 * stepsize ( 1 ) - stepsize ( 1 ) + initmeanval ( 5 ) ! xpc +/- 5 pixels fpar ( 2 ) = sngl ( X ( 2 )) * 2.0 * stepsize ( 2 ) - stepsize ( 2 ) + initmeanval ( 6 ) ! ypc +/- 5 pixels fpar ( 7 ) = sngl ( X ( 4 )) * 2.0 * stepsize ( 6 ) * fpar ( 3 ) - stepsize ( 6 ) * fpar ( 3 ) + initmeanval ( 1 ) ! mean +/- 5 pixels ! 03/28/16 omega is no longer a variable parameter anymore fpar ( 5 ) = sngl ( X ( 3 )) * 0.0 - 0.0 eu = ( / X ( 5 ) * 2.0 * stepsize ( 3 ) - stepsize ( 3 ) + initmeanval ( 2 ), X ( 6 ) * 2.0 * stepsize ( 4 ) - stepsize ( 4 ) + initmeanval ( 3 ), & X ( 7 ) * 2.0 * stepsize ( 5 ) - stepsize ( 5 ) + initmeanval ( 4 ) / ) * dtor ! mean +/- 2 degrees binx = ipar ( 2 ) / ipar ( 12 ) biny = ipar ( 3 ) / ipar ( 12 ) bindx = 1.0 / float ( ipar ( 12 ) ** 2 ) nnx = ipar ( 2 ) nny = ipar ( 3 ) nregions = IPAR ( 14 ) allocate ( EBSDvector ( binx * biny ), mask ( binx , biny )) allocate ( EBSDpattern ( ipar ( 2 ), ipar ( 3 ), 1 )) allocate ( binned ( binx , biny )) allocate ( EBSDpatternintd ( ipar ( 2 ), ipar ( 3 )), EBSDpatterninteger ( ipar ( 2 ), ipar ( 3 )), EBSDpatternad ( ipar ( 2 ), ipar ( 3 ))) allocate ( img1 ( binx * biny ), img2 ( binx * biny )) binned = 0.0 EBSDpatternintd = 0.0 EBSDpatterninteger = 0 EBSDpatternad = 0 img1 = 0 img2 = 0 mask = 1.0 if ( present ( verbose )) then if ( verbose ) then print * , 'xpc, ypc, L, eu = ' , fpar ( 1 ), fpar ( 2 ), fpar ( 7 ), eu ( 1 : 3 ) * 18 0.0 / cPi end if end if fpar2 ( 1 : 10 ) = fpar ( 1 : 10 ) ipar2 ( 1 : 10 ) = ipar ( 1 : 10 ) quats ( 1 : 4 , 1 ) = eu2qu ( eu ) call getEBSDPatterns ( ipar2 , fpar2 , EBSDpattern , quats , accum_e , mLPNH , mLPSH ) ma = maxval ( EBSDPattern (:,:, 1 )) mi = minval ( EBSDPattern (:,:, 1 )) EBSDpatternintd = (( EBSDPattern (:,:, 1 ) - mi ) / ( ma - mi )) EBSDpatterninteger = nint ( EBSDpatternintd * 25 5.0 ) EBSDpatternad = adhisteq ( nregions , nnx , nny , EBSDpatterninteger ) EBSDPattern (:,:, 1 ) = float ( EBSDpatternad ) if ( ipar ( 12 ) . ne . 1 ) then do i = 1 , binx do j = 1 , biny binned ( i , j ) = sum ( EBSDpattern (( i - 1 ) * ipar ( 12 ) + 1 : i * ipar ( 12 ),( j - 1 ) * ipar ( 12 ) + 1 : j * ipar ( 12 ), 1 )) end do end do binned = binned * bindx else binned ( 1 : binx , 1 : biny ) = EBSDpattern ( 1 : binx , 1 : biny , 1 ) end if if ( ipar ( 11 ) . eq . 1 ) then do i = 1 , binx do j = 1 , biny if ((( float ( i ) - ceiling ( float ( binx ) / 2.0 )) ** 2 + ( float ( j ) - ceiling ( float ( biny ) / 2.0 )) ** 2 ) . gt . fpar ( 11 ) ** 2 ) then mask ( i , j ) = 0.0 end if end do end do end if binned ( 1 : binx , 1 : biny ) = binned ( 1 : binx , 1 : biny ) * mask ( 1 : binx , 1 : biny ) binned = binned ** fpar ( 12 ) do i = 1 , biny do j = 1 , binx EBSDvector (( i - 1 ) * binx + j ) = binned ( j , i ) end do end do EBSDvector = EBSDvector / NORM2 ( EBSDvector ) if ( IPAR ( 13 ) . eq . 1 ) then ma = maxval ( EBSDvector ) mi = minval ( EBSDvector ) img1 = nint ( 25 5.0 * ( EBSDvector - mi ) / ( ma - mi )) ma = maxval ( expt ) mi = minval ( expt ) img2 = nint ( 25 5.0 * ( expt - mi ) / ( ma - mi )) F = Jaccard_Distance ( img1 , img2 , binx * biny ) else F = 1.0 - DOT_PRODUCT ( EBSDvector , expt ) end if end subroutine EBSDcalfun !-------------------------------------------------------------------------- ! ! SUBROUTINE:ECPcalfun ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief This function is used by bobyqa to fit an EBSD pattern ! !> @etails The main purpose of this routine is to calculte the difference of 1 with the dot !> product of an experimental pattern with the given set of detector parameters. This is used !> by bobyqa module to fit an EBSD pattern. !> !> This routine will first compute the detector arrays rgx etc. if necessary, and then perform !> the usual interpolation from the square Lambert projection. The pattern will be a basic pattern, !> without any intensity scaling or binning etc; the calling program should take care of those !> operations. ! !> @param ipar array with integer input parameters !> @param fpar array with float input parameters !> @param initmeanval array with mean value of search space !> @param ECPattern output array !> @param quats array of quaternions !> @param accum_e array with Monte Carlo histogram !> @param mLPNH Northern hemisphere master pattern !> @param mLPSH Southern hemisphere master pattern ! !> @date 12/12/15  SS 1.0 original !-------------------------------------------------------------------------- recursive subroutine ECPcalfun ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt , accum_e , mLPNH , mLPSH , & n , x , f , nstep , stepsize , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: ECPcalfun ! the input parameters are all part of a ipar and fpar input arrays instead of the usual namelist structures. ! The following is the mapping: ! ! ipar(1) = 1 ! ipar(2) = detnumsx ! ipar(3) = detnumsy ! ipar(4) = numangle ! ipar(5) = mcnsx ! ipar(6) = mpnpx ! ipar(7) = numset ! ipar(8) = numquats ! ipar(9) = 0/1 ;0 for no mask, 1 for mask ! ipar(10) = 1; equal to numEbins ! ipar(11) = 0/1; 0 for DP 1 for JD ! ipar(12) = 1 ;binning ! fpar(1) = ecpnl%thetac ! fpar(2) = ecpnl%sampletilt ! fpar(3) = ecpnl%workingdistance ! fpar(4) = ecpnl%Rin ! fpar(5) = ecpnl%Rout ! fpar(6) = ecpnl%sigstart ! fpar(7) = ecpnl%sigend ! fpar(8) = ecpnl%sigstep ! fpar(9) = ecpnl%gammavalue ! fpar(10) = maskradius ! initmeanval(1) = thetac ! initmeanval(2) = sampletilt ! initmeanval(3) = working distance ! initmeanval(4) = phi1 ! initmeanval(5) = phi ! initmeanval(6) = phi2 ! stepsize(1) = step_thetacone ! stepsize(2) = step_phi1 ! stepsize(3) = step_phi ; all 4 patterns ! stepsize(4) = step_phi2 ; all 4 patterns use local use rotations use constants use distortion use , INTRINSIC :: ISO_C_BINDING use filters use Indexingmod , ONLY : Jaccard_Distance IMPLICIT NONE integer ( c_size_t ), intent ( in ) :: ipar ( nipar ) real ( sgl ), intent ( inout ) :: fpar ( nfpar ) real ( sgl ), intent ( in ) :: initmeanval ( ninit ) integer ( irg ), intent ( in ) :: nipar integer ( irg ), intent ( in ) :: nfpar integer ( irg ), intent ( in ) :: ninit real ( c_float ), intent ( in ) :: expt ( ipar ( 2 ) * ipar ( 3 ) / ipar ( 12 ) ** 2 ) integer ( irg ), intent ( in ) :: nstep real ( sgl ), intent ( in ) :: stepsize ( nstep ) real ( kind = sgl ), INTENT ( in ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( kind = sgl ), INTENT ( in ) :: mLPNH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) real ( kind = sgl ), INTENT ( in ) :: mLPSH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) integer ( irg ), intent ( in ) :: n real ( dbl ), dimension (:), intent ( in ) :: x real ( dbl ), intent ( out ) :: f logical , intent ( in ), optional :: verbose integer ( kind = irg ) :: nnx , nny complex ( dbl ) :: D real ( kind = sgl ) :: quats ( 4 , 1 ), ma , mi real ( kind = sgl ), allocatable :: ECPpattern (:,:,:) real ( kind = sgl ), allocatable :: binned (:,:) real ( kind = sgl ), allocatable :: ECPpatternintd (:,:) integer ( kind = irg ), allocatable :: ECPpatterninteger (:,:), ECPpatternad (:,:) real ( kind = sgl ), allocatable :: ECPvector (:), ECPvectorcpy (:), ECPtmp (:,:) real ( kind = sgl ), allocatable :: mask (:,:) integer ( kind = irg ), allocatable :: img1 (:), img2 (:) integer ( kind = irg ) :: istat , i , j real ( kind = sgl ), parameter :: dtor = 0.0174533 ! convert from degrees to radians real ( kind = sgl ) :: eu ( 3 ) logical :: stat , readonly integer ( kind = irg ) :: hdferr , nlines , nregions fpar ( 1 ) = sngl ( X ( 1 )) * 2.0 * stepsize ( 1 ) - stepsize ( 1 ) + initmeanval ( 1 ) ! thetac mean +/- stepsize degrees degrees only eu = ( / X ( 2 ) * 2.0 * stepsize ( 2 ) - stepsize ( 2 ) + initmeanval ( 2 ), X ( 3 ) * 2.0 * stepsize ( 3 ) - stepsize ( 3 ) + initmeanval ( 3 ), & X ( 4 ) * 2.0 * stepsize ( 4 ) - stepsize ( 4 ) + initmeanval ( 4 ) / ) * cPi / 18 0.0 ! mean +/- stepsize quats ( 1 : 4 , 1 ) = eu2qu ( eu ) !D = dcmplx(0.D0,0.D0) ! read all the files allocate ( ECPvector ( ipar ( 2 ) * ipar ( 3 )), mask ( ipar ( 2 ), ipar ( 3 ))) allocate ( ECPpattern ( ipar ( 2 ), ipar ( 3 ), ipar ( 8 ))) allocate ( ECPpatternintd ( ipar ( 2 ), ipar ( 3 )), ECPpatterninteger ( ipar ( 2 ), ipar ( 3 )), ECPpatternad ( ipar ( 2 ), ipar ( 3 ))) ECPpatternintd = 0.0 ECPpatterninteger = 0 ECPpatternad = 0 if ( present ( verbose )) then if ( verbose ) then print * , 'thetac, eu = ' , sngl ( X ( 1 )) * 2.0 * stepsize ( 1 ) - stepsize ( 1 ) + initmeanval ( 1 ), eu * 18 0.0 / cPi end if end if mask = 1.0 do i = 1 , ipar ( 2 ) do j = 1 , ipar ( 3 ) if ((( float ( i ) - ceiling ( float ( ipar ( 2 )) / 2.0 )) ** 2 + ( float ( j ) - ceiling ( float ( ipar ( 3 )) / 2.0 )) ** 2 ) . gt . fpar ( 10 ) ** 2 ) then mask ( i , j ) = 0.0 end if end do end do call getECPatterns ( ipar , fpar , ECPpattern , quats , accum_e , mLPNH , mLPSH ) nnx = ipar ( 2 ) nny = ipar ( 3 ) !nregions = ipar(12) allocate ( ECPvector ( ipar ( 2 ) * ipar ( 3 )), stat = istat ) if ( ipar ( 9 ) . eq . 1 ) then do i = 1 , ipar ( 8 ) ECPpattern (:,:, i ) = ECPpattern (:,:, i ) * mask end do end if do i = 1 , ipar ( 2 ) do j = 1 , ipar ( 3 ) ECPvector (( i - 1 ) * ipar ( 3 ) + j ) = ECPpattern ( j , i , 1 ) end do end do !ECPvector = 0.0 !do i = 1,ipar(2) !    ECPvector((i-1)*ipar(3)+1:i*ipar(3)) = ECPvectorcpy((ipar(2)-i)*ipar(3)+1:(ipar(2)-i+1)*ipar(3)) !end do ECPvector = ECPvector ** fpar ( 9 ) ECPvector = ECPvector / NORM2 ( ECPvector ) if ( IPAR ( 11 ) . eq . 0 ) then F = 1.0 - DOT_PRODUCT ( ECPvector , expt ) else allocate ( img1 ( ipar ( 2 ) * ipar ( 3 )), img2 ( ipar ( 2 ) * ipar ( 3 ))) ma = maxval ( ECPvector ) mi = minval ( ECPvector ) img1 = nint ( 25 5.0 * ( ECPvector - mi ) / ( ma - mi )) ma = maxval ( expt ) mi = minval ( expt ) img2 = nint ( 25 5.0 * ( expt - mi ) / ( ma - mi )) F = Jaccard_Distance ( img1 , img2 , nnx * nny ) end if end subroutine ECPcalfun !=================================================================== !=================================================================== ! here we start with the Wrapper routines that are actually ! called from another language ! ! Tested languages:  IDL ! To be tested:  Matlab !=================================================================== !=================================================================== !-------------------------------------------------------------------------- ! ! SUBROUTINE:getEBSDPatternsWrapper ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief wrapper routine for getEBSDPatterns !> !> see example at https://groups.google.com/forum/#!topic/comp.lang.idl-pvwave/Gk0xxVFbW8E ! !> @param argc number of argument !> @param argv pointers to subroutine parameters ! !> @date 10/16/15 MDG 1.0 original !> @date 11/02/15 MDG 1.1 simplified parameters !> @date 01/12/16 MDG 1.2 added dummy arguments for progress callback and cancel handling !> @date 01/13/16 MDG 1.3 removed dummy arguments for progress callback and cancel handling !> @date 07/10/16 MDG 1.4 added energy min/max indices !-------------------------------------------------------------------------- recursive function getEBSDPatternsWrapper ( argc , argv ) bind ( c , name = 'getEBSDPatternsWrapper' ) !DEC$ ATTRIBUTES DLLEXPORT :: getEBSDPatternsWrapper use , INTRINSIC :: ISO_C_BINDING IMPLICIT NONE INTEGER ( c_size_t ), VALUE , INTENT ( IN ) :: argc type ( c_ptr ), dimension ( argc ), INTENT ( INOUT ) :: argv REAL ( c_float ) :: getEBSDPatternsWrapper ! wrapper function dependent declarations; they are all pointers ! since we pass everything by reference from IDL integer ( c_size_t ) :: nipar , nfpar , nq integer ( c_size_t ), dimension (:), pointer :: ipar real ( c_float ), dimension (:), pointer :: fpar real ( c_float ), dimension (:,:), pointer :: quats real ( c_float ), dimension (:,:,:), pointer :: EBSDpattern , accum_e real ( c_float ), dimension (:,:,:,:), pointer :: mLPNH , mLPSH ! the following line just helps in identifying the correct order of the subroutine arguments... !                             1      2      3           4         5       6     7 !subroutine getEBSDPatterns(ipar, fpar, EBSDpattern, quats, accum_e, mLPNH, mLPSH) ! ! transform the C pointers above to fortran pointers, and use them in the regular function call nipar = 10 nfpar = 10 nq = 4 call c_f_pointer ( argv ( 1 ), ipar ,( / nipar / )) call c_f_pointer ( argv ( 2 ), fpar ,( / nfpar / )) call c_f_pointer ( argv ( 3 ), EBSDpattern ,( / ipar ( 2 ), ipar ( 3 ), ipar ( 8 ) / )) call c_f_pointer ( argv ( 4 ), quats ,( / nq , ipar ( 8 ) / )) call c_f_pointer ( argv ( 5 ), accum_e ,( / ipar ( 4 ), 2 * ipar ( 5 ) + 1 , 2 * ipar ( 5 ) + 1 / )) call c_f_pointer ( argv ( 6 ), mLPNH ,( / 2 * ipar ( 6 ) + 1 , 2 * ipar ( 6 ) + 1 , ipar ( 4 ), ipar ( 7 ) / )) call c_f_pointer ( argv ( 7 ), mLPSH ,( / 2 * ipar ( 6 ) + 1 , 2 * ipar ( 6 ) + 1 , ipar ( 4 ), ipar ( 7 ) / )) call getEBSDPatterns ( ipar , fpar , EBSDpattern , quats , accum_e , mLPNH , mLPSH ) getEBSDPatternsWrapper = 1._c_float end function getEBSDPatternsWrapper !-------------------------------------------------------------------------- ! ! SUBROUTINE:getECPatternsWrapper ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief wrapper routine for SingleECPPattern; based on Marc's routine above !> !> see https://groups.google.com/forum/#!topic/comp.lang.idl-pvwave/Gk0xxVFbW8E !> ! !> @param argc number of argument !> @param argv pointers to subroutine parameters ! !> @date 10/28/15  SS 1.0 original !> @date 11/02/15 MDG 1.1 simplified parameters !-------------------------------------------------------------------------- recursive function getECPatternsWrapper ( argc , argv ) bind ( c , name = 'getECPatternsWrapper' ) !DEC$ ATTRIBUTES DLLEXPORT :: getECPatternsWrapper use , INTRINSIC :: ISO_C_BINDING IMPLICIT NONE INTEGER ( c_size_t ), VALUE , INTENT ( IN ) :: argc type ( c_ptr ), dimension ( argc ), INTENT ( INOUT ) :: argv REAL ( c_float ) :: getECPatternsWrapper ! wrapper function dependent declarations; they are all pointers ! since we pass everything by reference from IDL integer ( c_size_t ) :: nipar , nfpar , nq integer ( c_size_t ), dimension (:), pointer :: ipar real ( c_float ), dimension (:), pointer :: fpar real ( c_float ), dimension (:,:,:), pointer :: accum_e , mLPNH , mLPSH , ECPattern real ( c_float ), dimension (:,:), pointer :: quats ! the following line just helps in identifying the correct order of the subroutine arguments... !                             1      2     3       4       5       6       7 !subroutine getECPatterns(ipar, fpar, ECPattern, quats, accum_e, mLPNH, mLPSH) ! ! transform the C pointers above to fortran pointers, and use them in the regular function call nipar = 8 nfpar = 8 nq = 4 call c_f_pointer ( argv ( 1 ), ipar ,( / nipar / )) call c_f_pointer ( argv ( 2 ), fpar ,( / nfpar / )) call c_f_pointer ( argv ( 3 ), ECpattern ,( / ipar ( 2 ), ipar ( 3 ), ipar ( 8 ) / )) call c_f_pointer ( argv ( 4 ), quats ,( / nq , ipar ( 8 ) / )) call c_f_pointer ( argv ( 5 ), accum_e ,( / ipar ( 4 ), 2 * ipar ( 5 ) + 1 , 2 * ipar ( 5 ) + 1 / )) call c_f_pointer ( argv ( 6 ), mLPNH ,( / 2 * ipar ( 7 ) + 1 , 2 * ipar ( 7 ) + 1 , ipar ( 6 ) / )) call c_f_pointer ( argv ( 7 ), mLPSH ,( / 2 * ipar ( 7 ) + 1 , 2 * ipar ( 7 ) + 1 , ipar ( 6 ) / )) call getECPatterns ( ipar , fpar , ECpattern , quats , accum_e , mLPNH , mLPSH ) getECPatternsWrapper = 1._c_float end function getECPatternsWrapper !-------------------------------------------------------------------------- ! ! SUBROUTINE: getKosselPatternsWrapper ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief wrapper routine for SingleKosselPattern; nearly identical to ECP case !> !> see https://groups.google.com/forum/#!topic/comp.lang.idl-pvwave/Gk0xxVFbW8E ! !> @param argc number of argument !> @param argv pointers to subroutine parameters ! !> @date 11/09/15 MDG 1.0 first version !-------------------------------------------------------------------------- recursive function getKosselPatternsWrapper ( argc , argv ) bind ( c , name = 'getKosselPatternsWrapper' ) !DEC$ ATTRIBUTES DLLEXPORT :: getKosselPatternsWrapper use , INTRINSIC :: ISO_C_BINDING IMPLICIT NONE INTEGER ( c_size_t ), VALUE , INTENT ( IN ) :: argc type ( c_ptr ), dimension ( argc ), INTENT ( INOUT ) :: argv REAL ( c_float ) :: getKosselPatternsWrapper ! wrapper function dependent declarations; they are all pointers ! since we pass everything by reference from IDL integer ( c_size_t ) :: nipar , nfpar , nq integer ( c_size_t ), dimension (:), pointer :: ipar real ( c_float ), dimension (:), pointer :: fpar real ( c_float ), dimension (:,:), pointer :: quats real ( c_float ), dimension (:,:,:), pointer :: KosselPattern , mLPNH , mLPSH ! the following line just helps in identifying the correct order of the subroutine arguments... !                             1      2     3             4       5       6 !subroutine getKosselPatterns(ipar, fpar, KosselPattern, quats, mLPNH, mLPSH) ! ! transform the C pointers above to fortran pointers, and use them in the regular function call nipar = 6 nfpar = 1 nq = 4 call c_f_pointer ( argv ( 1 ), ipar ,( / nipar / )) call c_f_pointer ( argv ( 2 ), fpar ,( / nfpar / )) call c_f_pointer ( argv ( 3 ), Kosselpattern ,( / ipar ( 2 ), ipar ( 2 ), ipar ( 4 ) / )) call c_f_pointer ( argv ( 4 ), quats ,( / nq , ipar ( 4 ) / )) call c_f_pointer ( argv ( 5 ), mLPNH ,( / 2 * ipar ( 3 ) + 1 , 2 * ipar ( 3 ) + 1 , ipar ( 5 ) / )) call c_f_pointer ( argv ( 6 ), mLPSH ,( / 2 * ipar ( 3 ) + 1 , 2 * ipar ( 3 ) + 1 , ipar ( 5 ) / )) call getKosselPatterns ( ipar , fpar , Kosselpattern , quats , mLPNH , mLPSH ) getKosselPatternsWrapper = 1._c_float end function getKosselPatternsWrapper !-------------------------------------------------------------------------- ! ! SUBROUTINE:efitECPWrapper ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief wrapper routine for fitting ECP pattern !> !> see https://groups.google.com/forum/#!topic/comp.lang.idl-pvwave/Gk0xxVFbW8E !> ! !> @param argc number of argument !> @param argv pointers to subroutine parameters ! !> @date 12/15/15  SS 1.0 original !-------------------------------------------------------------------------- recursive function efitECPWrapper ( argc , argv ) bind ( c , name = 'efitECPWrapper' ) !DEC$ ATTRIBUTES DLLEXPORT :: efitECPWrapper use , INTRINSIC :: ISO_C_BINDING ! use bobyqa_module use local IMPLICIT NONE INTEGER ( c_size_t ), VALUE , INTENT ( IN ) :: argc type ( c_ptr ), dimension ( argc ), INTENT ( INOUT ) :: argv REAL ( c_float ) :: efitECPWrapper ! wrapper function dependent declarations; they are all pointers ! since we pass everything by reference from IDL integer ( 4 ) :: nipar , nfpar , ninit , n , iprint , maxfun , npt real ( c_double ), dimension (:), pointer :: rhobeg , rhoend integer ( c_size_t ), dimension (:), pointer :: ipar real ( c_float ), dimension (:), pointer :: fpar real ( c_float ), dimension (:), pointer :: initmeanval real ( c_float ), dimension (:), pointer :: expt real ( c_float ), dimension (:,:,:), pointer :: accum_e real ( c_float ), dimension (:,:,:,:), pointer :: mLPNH real ( c_float ), dimension (:,:,:,:), pointer :: mLPSH real ( c_double ), dimension (:), pointer :: X real ( c_double ), dimension (:), pointer :: XL real ( c_double ), dimension (:), pointer :: XU ! the following line just helps in identifying the correct order of the subroutine arguments... ! !subroutine BOBYQA(nipar, nfpar, ninit, ipar, fpar, initmeanval, expt, N, NPT, X, XL, XU, RHOBEG, RHOEND, IPRINT, MAXFUN, ECPCALFUN, ACCUM_E, mLPNH, mLPSH) ! ! transform the C pointers above to fortran pointers, and use them in the regular function call nipar = 9 nfpar = 10 ninit = 6 n = 6 iprint = 2 maxfun = 10000 npt = n + 6 call c_f_pointer ( argv ( 1 ), ipar ,( / nipar / )) call c_f_pointer ( argv ( 2 ), fpar ,( / nfpar / )) call c_f_pointer ( argv ( 4 ), initmeanval ,( / n / )) call c_f_pointer ( argv ( 5 ), expt ,( / ipar ( 2 ) * ipar ( 3 ) / )) call c_f_pointer ( argv ( 6 ), X ,( / n / )) call c_f_pointer ( argv ( 7 ), XL ,( / n / )) call c_f_pointer ( argv ( 8 ), XU ,( / n / )) call c_f_pointer ( argv ( 9 ), RHOBEG ,( / 1 / )) call c_f_pointer ( argv ( 10 ), RHOEND ,( / 1 / )) call c_f_pointer ( argv ( 11 ), accum_e ,( / ipar ( 4 ), 2 * ipar ( 5 ) + 1 , 2 * ipar ( 5 ) + 1 / )) call c_f_pointer ( argv ( 12 ), mLPNH ,( / 2 * ipar ( 6 ) + 1 , 2 * ipar ( 6 ) + 1 , ipar ( 4 ), ipar ( 7 ) / )) call c_f_pointer ( argv ( 13 ), mLPSH ,( / 2 * ipar ( 6 ) + 1 , 2 * ipar ( 6 ) + 1 , ipar ( 4 ), ipar ( 7 ) / )) ! call BOBYQA(NIPAR, NFPAR, NINIT, IPAR, FPAR, INITMEANVAL, EXPT, N, NPT, X, XL, XU, RHOBEG(1), RHOEND(1),& !      IPRINT, MAXFUN, ECPCALFUN, accum_e, mLPNH, mLPSH) efitECPWrapper = 1._c_float end function efitECPWrapper !-------------------------------------------------------------------------- ! ! SUBROUTINE:efitEBSDWrapper ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief wrapper routine for fitting EBSD pattern !> !> see https://groups.google.com/forum/#!topic/comp.lang.idl-pvwave/Gk0xxVFbW8E !> ! !> @param argc number of argument !> @param argv pointers to subroutine parameters ! !> @date 12/15/15  SS 1.0 original !-------------------------------------------------------------------------- recursive function efitEBSDWrapper ( argc , argv ) bind ( c , name = 'efitEBSDWrapper' ) !DEC$ ATTRIBUTES DLLEXPORT :: efitEBSDWrapper use , INTRINSIC :: ISO_C_BINDING !use bobyqa_module use local IMPLICIT NONE INTEGER ( c_size_t ), VALUE , INTENT ( IN ) :: argc type ( c_ptr ), dimension ( argc ), INTENT ( INOUT ) :: argv REAL ( c_float ) :: efitEBSDWrapper ! wrapper function dependent declarations; they are all pointers ! since we pass everything by reference from IDL integer ( 4 ) :: nipar , nfpar , ninit , n , iprint , maxfun , npt real ( c_double ), dimension (:), pointer :: rhobeg , rhoend integer ( c_size_t ), dimension (:), pointer :: ipar real ( c_float ), dimension (:), pointer :: fpar real ( c_float ), dimension (:), pointer :: initmeanval real ( c_float ), dimension (:), pointer :: expt real ( c_float ), dimension (:,:,:), pointer :: accum_e real ( c_float ), dimension (:,:,:,:), pointer :: mLPNH real ( c_float ), dimension (:,:,:,:), pointer :: mLPSH real ( c_double ), dimension (:), pointer :: X real ( c_double ), dimension (:), pointer :: XL real ( c_double ), dimension (:), pointer :: XU ! the following line just helps in identifying the correct order of the subroutine arguments... !                                        1      2     3       4           5           6   7   8   9        10 !subroutine BOBYQA(nipar, nfpar, ninit, ipar, fpar, fname, initmeanval, expt, N, NPT, X, XL, XU, RHOBEG, RHOEND, IPRINT, MAXFUN, EBSDCALFUN) ! ! transform the C pointers above to fortran pointers, and use them in the regular function call nipar = 9 nfpar = 11 ninit = 4 n = 7 iprint = 2 maxfun = 10000 npt = n + 6 call c_f_pointer ( argv ( 1 ), ipar ,( / nipar / )) call c_f_pointer ( argv ( 2 ), fpar ,( / nfpar / )) call c_f_pointer ( argv ( 3 ), initmeanval ,( / n / )) call c_f_pointer ( argv ( 4 ), expt ,( / ipar ( 2 ) * ipar ( 3 ) / )) call c_f_pointer ( argv ( 5 ), X ,( / n / )) call c_f_pointer ( argv ( 6 ), XL ,( / n / )) call c_f_pointer ( argv ( 7 ), XU ,( / n / )) call c_f_pointer ( argv ( 8 ), RHOBEG ,( / 1 / )) call c_f_pointer ( argv ( 9 ), RHOEND ,( / 1 / )) call c_f_pointer ( argv ( 10 ), accum_e ,( / ipar ( 4 ), 2 * ipar ( 5 ) + 1 , 2 * ipar ( 5 ) + 1 / )) call c_f_pointer ( argv ( 11 ), mLPNH ,( / 2 * ipar ( 6 ) + 1 , 2 * ipar ( 6 ) + 1 , ipar ( 4 ), ipar ( 7 ) / )) call c_f_pointer ( argv ( 12 ), mLPSH ,( / 2 * ipar ( 6 ) + 1 , 2 * ipar ( 6 ) + 1 , ipar ( 4 ), ipar ( 7 ) / )) ! call BOBYQA(NIPAR, NFPAR, NINIT, IPAR, FPAR, INITMEANVAL, EXPT, N, NPT, X, XL, XU, RHOBEG(1), RHOEND(1),& !      IPRINT, MAXFUN, EBSDCALFUN, accum_e, mLPNH, mLPSH) efitEBSDWrapper = 1._c_float end function efitEBSDWrapper end module EMdymod","tags":"","loc":"sourcefile/emdymod.f90.html","title":"EMdymod.f90 – Fortran Program"},{"text":"This File Depends On sourcefile~~filters.f90~~EfferentGraph sourcefile~filters.f90 filters.f90 sourcefile~constants.f90 constants.f90 sourcefile~constants.f90->sourcefile~filters.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files Dependent On This One sourcefile~~filters.f90~~AfferentGraph sourcefile~filters.f90 filters.f90 sourcefile~emdymod.f90 EMdymod.f90 sourcefile~filters.f90->sourcefile~emdymod.f90 sourcefile~simulated_annealing.f90 simulated_annealing.f90 sourcefile~emdymod.f90->sourcefile~simulated_annealing.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules filters Source Code filters.f90 Source Code ! ################################################################### ! Copyright (c) 2016, Marc De Graef/Carnegie Mellon University ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without modification, are ! permitted provided that the following conditions are met: ! !     - Redistributions of source code must retain the above copyright notice, this list !        of conditions and the following disclaimer. !     - Redistributions in binary form must reproduce the above copyright notice, this !        list of conditions and the following disclaimer in the documentation and/or !        other materials provided with the distribution. !     - Neither the names of Marc De Graef, Carnegie Mellon University nor the names !        of its contributors may be used to endorse or promote products derived from !        this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE ! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ################################################################### !-------------------------------------------------------------------------- ! EMsoft:filters.f90 !-------------------------------------------------------------------------- ! ! MODULE: filters ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief various useful filters ! !> @date 01/21/16 MDG 1.0 original !> @date 02/02/16 MDG 1.1 added Hough Transform !-------------------------------------------------------------------------- module filters use local IMPLICIT NONE contains !-------------------------------------------------------------------------- ! ! FUNCTION: image_histogram ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief  compute the histogram of an image ! !> @param nx x dimension !> @param ny y dimension !> @param im image array; must have values in range [1..256] ! !> @date 01/23/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive function image_histogram ( nx , ny , im ) result ( h ) !DEC$ ATTRIBUTES DLLEXPORT :: image_histogram IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: nx integer ( kind = irg ), INTENT ( IN ) :: ny integer ( kind = irg ), INTENT ( IN ) :: im ( nx , ny ) integer ( kind = irg ) :: h ( 256 ) integer ( kind = irg ), parameter :: nh = 256 integer ( kind = irg ) :: i , j ! initialize parameters h = 0 do i = 1 , nx do j = 1 , ny h ( im ( i , j )) = h ( im ( i , j )) + 1 end do end do end function image_histogram !-------------------------------------------------------------------------- ! ! FUNCTION: image_jointhistogram ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief  compute the joint histogram of two images ! !> @param nx x dimension !> @param ny y dimension !> @param im1 image array; must have values in range [1..256] !> @param im2 image array; must have values in range [1..256] ! !> @date 04/23/17 MDG 1.0 original !-------------------------------------------------------------------------- recursive function image_jointhistogram ( nx , ny , im1 , im2 ) result ( h ) !DEC$ ATTRIBUTES DLLEXPORT :: image_jointhistogram IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: nx integer ( kind = irg ), INTENT ( IN ) :: ny integer ( kind = irg ), INTENT ( IN ) :: im1 ( nx , ny ) integer ( kind = irg ), INTENT ( IN ) :: im2 ( nx , ny ) integer ( kind = irg ) :: h ( 256 , 256 ) integer ( kind = irg ), parameter :: nh = 256 integer ( kind = irg ) :: i , j ! initialize parameters h = 0 do i = 1 , nx do j = 1 , ny h ( im1 ( i , j ), im2 ( i , j )) = h ( im1 ( i , j ), im2 ( i , j )) + 1 end do end do end function image_jointhistogram !-------------------------------------------------------------------------- ! ! FUNCTION: cumul_histogram ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief  compute the cumulative histogram of an image ! !> @param nx x dimension !> @param ny y dimension !> @param im image array; must have values in range [1..256] ! !> @date 01/23/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive function cumul_histogram ( nx , ny , im ) result ( h ) !DEC$ ATTRIBUTES DLLEXPORT :: cumul_histogram IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: nx integer ( kind = irg ), INTENT ( IN ) :: ny integer ( kind = irg ), INTENT ( IN ) :: im ( nx , ny ) integer ( kind = irg ) :: h ( 256 ) integer ( kind = irg ), parameter :: nh = 256 integer ( kind = irg ) :: i , j , low , high , hst ( nh ), np , nploc ( 1 ) np = nx * ny hst = 0 ! get the regular histogram h = image_histogram ( nx , ny , im ) ! if all the intensities equal 0, then we need to return a zero cumulative ! histogram. if ( h ( 1 ). eq . np ) then h = 0 return end if ! we need to allow for the possibility that the image is flat, so that ! all intensity is in a single bin.  In that case, the cumulative histogram ! will be a step function and the usual noramlization to [1..256] will ! not work if ( maxval ( h ). eq . np ) then nploc = maxloc ( h ) hst ( 1 : nploc ( 1 ) - 1 ) = h ( 1 ) hst ( nploc ( 1 ): nh ) = 256 h = hst else ! convert h to a cumulative histogram hst hst = 0 hst ( 1 ) = h ( 1 ) do i = 2 , nh hst ( i ) = h ( i ) + hst ( i - 1 ) end do ! and rescale to [1..256] h = int ( 25 5.0 * (( float ( hst ) - float ( hst ( 1 ))) / float ( hst ( nh ) - hst ( 1 )))) + 1 end if end function cumul_histogram !-------------------------------------------------------------------------- ! ! FUNCTION: image_entropy ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief  compute the Shannon entropy of an image ! !> @param h a 256 element intensity histogram ! !> @date 04/23/17 MDG 1.0 original !-------------------------------------------------------------------------- recursive function image_entropy ( h ) result ( e ) !DEC$ ATTRIBUTES DLLEXPORT :: image_entropy IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: h ( 256 ) real ( kind = sgl ) :: e integer ( kind = irg ), parameter :: nh = 256 integer ( kind = irg ) :: i , j real ( kind = sgl ) :: hnorm ( 256 ) ! initialize parameters hnorm = float ( h ) ! normalize the histogram hnorm = hnorm / sum ( hnorm ) ! add up the natural logarithm factors for the non-zero bins e = 0.0 do i = 1 , nh if ( h ( i ). ne . 0 ) e = e - hnorm ( i ) * log ( hnorm ( i )) end do end function image_entropy !-------------------------------------------------------------------------- ! ! FUNCTION: image_jointentropy ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief  compute the Shannon joint entropy of two images ! !> @param h a 256x256 element intensity joint histogram ! !> @date 04/23/17 MDG 1.0 original !-------------------------------------------------------------------------- recursive function image_jointentropy ( h ) result ( e ) !DEC$ ATTRIBUTES DLLEXPORT :: image_jointentropy IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: h ( 256 , 256 ) real ( kind = sgl ) :: e integer ( kind = irg ), parameter :: nh = 256 integer ( kind = irg ) :: i , j real ( kind = sgl ) :: hnorm ( 256 , 256 ) ! initialize parameters hnorm = float ( h ) ! normalize the histogram hnorm = hnorm / sum ( hnorm ) ! add up the natural logarithm factors for the non-zero bins e = 0.0 do i = 1 , nh do j = 1 , nh if ( h ( i , j ). ne . 0 ) e = e - hnorm ( i , j ) * log ( hnorm ( i , j )) end do end do end function image_jointentropy !-------------------------------------------------------------------------- ! ! FUNCTION: image_mutualinformation ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief  compute the mutual information of two images ! !> @param nx x dimension !> @param ny y dimension !> @param im image array; must have values in range [1..256] ! !> @date 04/23/17 MDG 1.0 original !-------------------------------------------------------------------------- recursive function image_mutualinformation ( nx , ny , im1 , im2 ) result ( mi ) !DEC$ ATTRIBUTES DLLEXPORT :: image_mutualinformation IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: nx integer ( kind = irg ), INTENT ( IN ) :: ny integer ( kind = irg ), INTENT ( IN ) :: im1 ( nx , ny ) integer ( kind = irg ), INTENT ( IN ) :: im2 ( nx , ny ) real ( kind = sgl ) :: mi real ( kind = sgl ) :: e1 , e2 , je ! get the individual and joint histograms e1 = image_entropy ( image_histogram ( nx , ny , im1 )) e2 = image_entropy ( image_histogram ( nx , ny , im2 )) je = image_jointentropy ( image_jointhistogram ( nx , ny , im1 , im2 )) ! compute the mutual information mi = e1 + e2 - je end function image_mutualinformation !-------------------------------------------------------------------------- ! ! FUNCTION: adhisteq ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief  adaptive histogram equalization ! !> @details This algorithm is based on the original paper by Pizer et al., !> \"Adaptive Histogram Equalization and its Variations\", Computer Vision, !> Graphics, and Image Processing, 39:355-368, 1987. ! !> @param nr number of subregions to split the image into [10 works well] !> @param dimx x dimension !> @param dimy y dimension !> @param im image array; must have integer values in range [0..255] ! !> @date 01/23/16 MDG 1.0 original !> @date 01/27/16 MDG 1.1 correction of off-by-one error in final array copy !-------------------------------------------------------------------------- recursive function adhisteq ( nr , dimx , dimy , im , verbose ) result ( output ) !DEC$ ATTRIBUTES DLLEXPORT :: adhisteq IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: nr integer ( kind = irg ), INTENT ( IN ) :: dimx integer ( kind = irg ), INTENT ( IN ) :: dimy integer ( kind = irg ), INTENT ( IN ) :: im ( dimx , dimy ) logical , INTENT ( IN ), OPTIONAL :: verbose integer ( kind = irg ) :: output ( dimx , dimy ) integer ( kind = irg ) :: ts , hts , ntx , nty , i , j , i1 , i2 , ir , ic , istop , jstop , ix0 , iy0 , Tvalx , Tvaly integer ( kind = irg ), parameter :: nh = 256 integer ( kind = irg ), allocatable :: subim (:,:) real ( kind = sgl ), allocatable :: tmp (:), tintx (:,:), tinty (:,:), LL (:,:), LR (:,:), UL (:,:), UR (:,:) integer ( kind = irg ), allocatable :: chistarr (:,:,:) if ( PRESENT ( verbose )) write ( * , * ) minval ( im ), maxval ( im ) output = 0 ! determine integer parameters ts = int ( maxval ( ( / dimx , dimy / )) / nr ) ! size of a single tile for histogram computation hts = maxval ( ( / ts / 2 , 1 / ) ) ! half the tile size ntx = ( dimx - 1 ) / hts ! number of tiles along x nty = ( dimy - 1 ) / hts ! number of tiles along y ! allocate temporary array to create tile interpolation matrices allocate ( tmp ( hts )) tmp = ( / ( dble ( i ), i = 0 , hts - 1 ) / ) / dble ( hts ) allocate ( tintx ( hts , hts ), tinty ( hts , hts )) do j = 1 , hts tintx ( 1 : hts , j ) = tmp ( 1 : hts ) end do tinty = transpose ( tintx ) deallocate ( tmp ) ! define the array that will hold two rows of cumulative histograms allocate ( chistarr ( nh , ntx , 2 )) chistarr = 0 do ir = 1 , nty + 1 do i = 1 , ntx chistarr ( 1 : 256 , i , 1 ) = chistarr ( 1 : 256 , i , 2 ) ! copy the histograms from the next row end do ! get the cumulative histograms for this row of tiles if ( ir . lt . nty + 1 ) then do ic = 1 , ntx ! set the sub image array limits ix0 = ( ic - 1 ) * hts + 1 istop = minval ( ( / ix0 + ts - 1 , dimx / ) ) Tvalx = ts if ( istop . eq . dimx ) Tvalx = istop - ix0 + 1 iy0 = ( ir - 1 ) * hts + 1 jstop = minval ( ( / iy0 + ts - 1 , dimy / ) ) Tvaly = ts if ( jstop . eq . dimy ) Tvaly = jstop - iy0 + 1 !if (PRESENT(verbose)) write(*,*) ix0, istop, iy0, jstop, Tvalx, Tvaly ! extract the sub image and compute its cumulative histogram (histogram starts at bin 1) allocate ( subim ( Tvalx , Tvaly )) subim = 0 subim ( 1 : Tvalx , 1 : Tvaly ) = im ( ix0 : istop , iy0 : jstop ) + 1 !if (PRESENT(verbose)) write (*,*) 'subim : ',minval(subim),maxval(subim) chistarr ( 1 : nh , ic , 2 ) = cumul_histogram ( Tvalx , Tvaly , subim ) deallocate ( subim ) end do end if !if (PRESENT(verbose)) write(*,*) minval(chistarr),maxval(chistarr) !stop if ( ir . eq . 1 ) then ! this is done only the first time through... do i = 1 , ntx chistarr ( 1 : 256 , i , 1 ) = chistarr ( 1 : 256 , i , 2 ) ! copy the histograms from the next row end do end if ! and here is the actual interpolation part do ic = 1 , ntx + 1 ! set the sub image array limits (different from above!) ix0 = ( ic - 1 ) * hts + 1 istop = minval ( ( / ix0 + hts - 1 , dimx / ) ) Tvalx = hts if ( istop . eq . dimx ) Tvalx = istop - ix0 + 1 iy0 = ( ir - 1 ) * hts + 1 jstop = minval ( ( / iy0 + hts - 1 , dimy / ) ) Tvaly = hts if ( jstop . eq . dimy ) Tvaly = jstop - iy0 + 1 ! allocate the sub image and the four interpolation arrays allocate ( subim ( Tvalx , Tvaly ), LL ( Tvalx , Tvaly ), LR ( Tvalx , Tvaly ), UL ( Tvalx , Tvaly ), UR ( Tvalx , Tvaly )) ! get the sub image subim ( 1 : Tvalx , 1 : Tvaly ) = im ( ix0 : istop , iy0 : jstop ) + 1 ! set the coordinates to be used in the histogram array i1 = maxval ( ( / ic - 1 , 1 / ) ) i2 = minval ( ( / ic , ntx / ) ) ! and extract the cumulative histogram values for the intensities in the sub image, ! for each of the four interpolation arrays do i = 1 , Tvalx do j = 1 , Tvaly LL ( i , j ) = float ( chistarr ( subim ( i , j ), i1 , 1 )) LR ( i , j ) = float ( chistarr ( subim ( i , j ), i2 , 1 )) UL ( i , j ) = float ( chistarr ( subim ( i , j ), i1 , 2 )) UR ( i , j ) = float ( chistarr ( subim ( i , j ), i2 , 2 )) end do end do ! perform the interpolation along x LL = LL + ( LR - LL ) * tintx ( 1 : Tvalx , 1 : Tvaly ) UL = UL + ( UR - UL ) * tintx ( 1 : Tvalx , 1 : Tvaly ) ! and interpolate along y; store the result in the output array output ( ix0 : istop , iy0 : jstop ) = int ( LL + ( UL - LL ) * tinty ( 1 : Tvalx , 1 : Tvaly )) ! deallocate the arrays deallocate ( subim , LL , LR , UL , UR ) end do end do end function adhisteq !-------------------------------------------------------------------------- ! ! SUBROUTINE: CalcHoughLUT ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief  create a look-up table for a square Hough transform ! !> @param dimx x dimension !> @param LUT look-up table, allocated in calling program ! !> @date 02/02/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine CalcHoughLUT ( dimx , LUT ) !DEC$ ATTRIBUTES DLLEXPORT :: CalcHoughLUT use constants IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dimx real ( kind = sgl ), INTENT ( OUT ) :: LUT ( dimx * dimx , dimx ) real ( kind = sgl ) :: ct ( dimx ), st ( dimx ), pre , line ( dimx ), d2 , x , y integer ( kind = irg ) :: i , j , k , icnt d2 = float ( dimx / 2 ) + 0.5 ! trigonometric look-up tables ct = 0.0 st = 0.0 pre = sngl ( cPi ) / float ( dimx ) line = ( / ( i , i = 0 , dimx - 1 ) / ) * pre ct = cos ( line ) st = sin ( line ) ! and create the look up table LUT = 0.0 icnt = 1 do j = 1 , dimx y = float ( j ) - d2 do i = 1 , dimx x = float ( i ) - d2 LUT ( icnt ,:) = nint ( x * ct (:) + y * st (:)) icnt = icnt + 1 end do end do LUT = LUT + dimx / 2 + 1 ! this is here just so the ped indexing program can be tested out. ! the out of bounds error in the main chunk of the program should be corrected do i = 1 , dimx * dimx do j = 1 , dimx if ( LUT ( i , j ) . gt . dimx ) LUT ( i , j ) = dimx if ( LUT ( i , j ) . lt . 1.0 ) LUT ( i , j ) = 1.0 end do end do end subroutine CalcHoughLUT !-------------------------------------------------------------------------- ! ! SUBROUTINE: HoughTransform ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief  Perform a square Hough transform ! !> @param dimx x dimension !> @param LUT look-up table from CalcHoughLUT !> @param im image array (must be mean-subtracted) !> @param HT resulting Hough transform array ! !> @date 02/02/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine HoughTransform ( dimx , LUT , im , HT ) !DEC$ ATTRIBUTES DLLEXPORT :: HoughTransform IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dimx real ( kind = sgl ), INTENT ( IN ) :: LUT ( dimx * dimx , dimx ) real ( kind = sgl ), INTENT ( IN ) :: im ( dimx * dimx ) real ( kind = sgl ), INTENT ( OUT ) :: HT ( dimx , dimx ) integer ( kind = irg ) :: i , j , k , d2 HT = 0.0 d2 = dimx / 2 do j = 1 , dimx do i = 1 , dimx * dimx k = LUT ( i , j ) HT ( k , j ) = HT ( k , j ) + im ( i ) end do end do HT = transpose ( HT ) end subroutine HoughTransform !-------------------------------------------------------------------------- ! ! SUBROUTINE: HiPassFilter ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief  Perform a high pass filter ! !> @param rdata real data to be transformed !> @param dims dimensions of rdata array !> @param w width of Gaussian profile !> @param init (optional) initialize without computing anything !> @param destroy (optional) destroy fft plans ! !> @date 02/02/16 MDG 1.0 original !> @date 06/03/16 MDG 1.1 modified mask to inverted Gaussian profile; added init optional parameter !-------------------------------------------------------------------------- recursive function HiPassFilter ( rdata , dims , w , init , destroy ) result ( fdata ) !DEC$ ATTRIBUTES DLLEXPORT :: HiPassFilter use FFTW3mod IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dims ( 2 ) real ( kind = dbl ), INTENT ( IN ) :: w real ( kind = dbl ), INTENT ( IN ) :: rdata ( dims ( 1 ), dims ( 2 )) logical , INTENT ( IN ), OPTIONAL :: init logical , INTENT ( IN ), OPTIONAL :: destroy real ( kind = dbl ) :: fdata ( dims ( 1 ), dims ( 2 )) complex ( kind = dbl ), SAVE , allocatable :: hpmask (:,:) complex ( kind = dbl ) :: cone = cmplx ( 1.D0 , 0.D0 ), czero = cmplx ( 0.D0 , 0.D0 ) integer ( kind = irg ) :: i , j , k , ii , jj real ( kind = dbl ) :: x , y , val ! fftw variables type ( C_PTR ), SAVE :: planf , planb complex ( C_DOUBLE_COMPLEX ), SAVE , allocatable :: inp (:,:), outp (:,:) ! are we just destroying the fftw plans ? if ( present ( destroy )) then if ( destroy ) then deallocate ( hpmask , inp , outp ) call fftw_destroy_plan ( planf ) call fftw_destroy_plan ( planb ) fdata = 0.D0 return end if end if ! if init=.TRUE. then initialize the hpmask variable and the fftw plans if ( present ( init )) then if ( init ) then ! allocate arrays allocate ( hpmask ( dims ( 1 ), dims ( 2 )), inp ( dims ( 1 ), dims ( 2 )), outp ( dims ( 1 ), dims ( 2 ))) ! generate the complex inverted Gaussian mask; w = 0.05 produces good results (usually) do i = 1 , dims ( 1 ) / 2 x = float ( i ) do j = 1 , dims ( 2 ) / 2 y = float ( j ) val = 1.D0 - dexp ( - w * ( x * x + y * y )) hpmask ( i , j ) = cmplx ( val , 0.D0 ) hpmask ( dims ( 1 ) + 1 - i , j ) = cmplx ( val , 0.D0 ) hpmask ( i , dims ( 2 ) + 1 - j ) = cmplx ( val , 0.D0 ) hpmask ( dims ( 1 ) + 1 - i , dims ( 2 ) + 1 - j ) = cmplx ( val , 0.D0 ) fdata ( i , j ) = val fdata ( dims ( 1 ) + 1 - i , j ) = val fdata ( i , dims ( 2 ) + 1 - j ) = val fdata ( dims ( 1 ) + 1 - i , dims ( 2 ) + 1 - j ) = val end do end do ! then we set up the fftw plans for forward and reverse transforms planf = fftw_plan_dft_2d ( dims ( 2 ), dims ( 1 ), inp , outp , FFTW_FORWARD , FFTW_ESTIMATE ) planb = fftw_plan_dft_2d ( dims ( 2 ), dims ( 1 ), inp , outp , FFTW_BACKWARD , FFTW_ESTIMATE ) ! and return return end if end if ! apply the hi-pass mask to rdata do j = 1 , dims ( 1 ) do k = 1 , dims ( 2 ) inp ( j , k ) = cmplx ( rdata ( j , k ), 0.D0 ) end do end do call fftw_execute_dft ( planf , inp , outp ) inp = outp * hpmask call fftw_execute_dft ( planb , inp , outp ) fdata ( 1 : dims ( 1 ), 1 : dims ( 2 )) = real ( outp ) end function HiPassFilter !-------------------------------------------------------------------------- ! ! SUBROUTINE: ButterflyMask9x9 ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief apply 9x9 butterfly mask to the hough image ! !> @param input input image !> @param output output image !> @param dims dimension of these images ! !> @date 12/06/16 SS 1.0 original !-------------------------------------------------------------------------- recursive subroutine ButterflyMask9x9 ( input , output , dims ) !DEC$ ATTRIBUTES DLLEXPORT :: ButterflyMask9x9 use constants IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dims real ( kind = sgl ), INTENT ( IN ) :: input ( dims , dims ) real ( kind = sgl ), INTENT ( OUT ) :: output ( dims , dims ) integer ( kind = irg ) :: ii , jj , kk , ll real ( kind = sgl ), allocatable :: inputpadded (:,:) allocate ( inputpadded ( - 3 : dims + 4 , - 3 : dims + 4 )) inputpadded = 0.0 inputpadded ( 1 : dims , 1 : dims ) = input ( 1 : dims , 1 : dims ) !inputpadded(-3:0,:1:dims) = input(dims-3:dims,1:dims) !inputpadded(dims+1:dims+4,1:dims) = input(1:4,1:dims) !inputpadded(1:dims,-3:0) = inputpadded(1:dims,dims-3:dims) !inputpadded(1:dims,dims+1:dims+4) = inputpadded(1:dims,1:4) output = 0.0 do ii = 1 , dims do jj = 1 , dims do kk = - 4 , 4 do ll = - 4 , 4 output ( ii , jj ) = output ( ii , jj ) + inputpadded ( ii + kk , jj + ll ) * Butterfly9x9 (( kk + 4 ) * 9 + ll + 5 ) end do end do end do end do deallocate ( inputpadded ) end subroutine ButterflyMask9x9 !-------------------------------------------------------------------------- ! ! SUBROUTINE: InversionDivision ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief Inversion division operation to enhance contrast of hough image ! !> @param input input image; must be between 0-1 !> @param output output image !> @param dims dimension of these image ! !> @date 12/06/16 SS 1.0 original !-------------------------------------------------------------------------- recursive subroutine InversionDivision ( input , output , dims ) !DEC$ ATTRIBUTES DLLEXPORT :: InversionDivision IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dims real ( kind = sgl ), INTENT ( IN ) :: input ( dims , dims ) real ( kind = sgl ), INTENT ( OUT ) :: output ( dims , dims ) integer ( kind = irg ) :: ii , jj real ( kind = sgl ), allocatable :: inverse (:,:) real ( kind = sgl ) :: ma , mi allocate ( inverse ( dims , dims )) inverse = ( 1.0 - Input ) do ii = 1 , dims do jj = 1 , dims if ( inverse ( ii , jj ) . ne . 0.0 ) then output ( ii , jj ) = input ( ii , jj ) / inverse ( ii , jj ) else output ( ii , jj ) = 1.0 end if end do end do deallocate ( inverse ) ma = maxval ( output ) mi = minval ( output ) output = ( output - mi ) / ( ma - mi ) end subroutine InversionDivision end module filters","tags":"","loc":"sourcefile/filters.f90.html","title":"filters.f90 – Fortran Program"},{"text":"Programs hdftest Subroutines timestamp Source Code hdftest.f90 Source Code program hdftest use hdf5 use h5lt IMPLICIT NONE CHARACTER ( LEN = 5 ), PARAMETER :: filename = \"atest\" !File name CHARACTER ( LEN = 80 ) :: fix_filename CHARACTER ( LEN = 9 ), PARAMETER :: dsetname = \"atestdset\" !Dataset name CHARACTER ( LEN = 11 ), PARAMETER :: aname = \"attr_string\" !String Attribute name CHARACTER ( LEN = 14 ), PARAMETER :: aname2 = \"attr_character\" !Character Attribute name CHARACTER ( LEN = 11 ), PARAMETER :: aname3 = \"attr_double\" !DOuble Attribute name CHARACTER ( LEN = 9 ), PARAMETER :: aname4 = \"attr_real\" !Real Attribute name CHARACTER ( LEN = 12 ), PARAMETER :: aname5 = \"attr_integer\" !Integer Attribute name CHARACTER ( LEN = 9 ), PARAMETER :: aname6 = \"attr_null\" !Null Attribute name ! !data space rank and dimensions ! INTEGER , PARAMETER :: RANK = 2 INTEGER , PARAMETER :: NX = 4 INTEGER , PARAMETER :: NY = 5 INTEGER ( HID_T ) :: file_id ! File identifier INTEGER ( HID_T ) :: dset_id ! Dataset identifier INTEGER ( HID_T ) :: dataspace ! Dataspace identifier for dataset INTEGER ( HID_T ) :: attr_id !String Attribute identifier INTEGER ( HID_T ) :: attr2_id !Character Attribute identifier INTEGER ( HID_T ) :: attr3_id !Double Attribute identifier INTEGER ( HID_T ) :: attr4_id !Real Attribute identifier INTEGER ( HID_T ) :: attr5_id !Integer Attribute identifier INTEGER ( HID_T ) :: attr6_id !Null Attribute identifier INTEGER ( HID_T ) :: aspace_id !String Attribute Dataspace identifier INTEGER ( HID_T ) :: aspace2_id !Character Attribute Dataspace identifier INTEGER ( HID_T ) :: aspace6_id !Null Attribute Dataspace identifier INTEGER ( HID_T ) :: dtype_id ! INTEGER ( HID_T ) :: atype_id !String Attribute Datatype identifier INTEGER ( HID_T ) :: atype2_id !Character Attribute Datatype identifier INTEGER ( HID_T ) :: atype3_id !Double Attribute Datatype identifier INTEGER ( HID_T ) :: atype4_id !Real Attribute Datatype identifier INTEGER ( HID_T ) :: atype5_id !Integer Attribute Datatype identifier INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: adims = ( / 2 / ) ! Attribute dimension INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: adims2 = ( / 1 / ) ! Attribute dimension INTEGER :: arank = 1 ! Attribure rank INTEGER ( SIZE_T ) :: attrlen ! Length of the attribute string INTEGER ( HID_T ) :: attr_space !Returned String Attribute Space identifier INTEGER ( HID_T ) :: attr2_space !Returned other Attribute Space identifier INTEGER ( HID_T ) :: attr_type !Returned Attribute Datatype identifier INTEGER ( HID_T ) :: attr2_type !Returned CHARACTER Attribute Datatype identifier INTEGER ( HID_T ) :: attr3_type !Returned DOUBLE Attribute Datatype identifier INTEGER ( HID_T ) :: attr4_type !Returned REAL Attribute Datatype identifier INTEGER ( HID_T ) :: attr5_type !Returned INTEGER Attribute Datatype identifier INTEGER ( HID_T ) :: attr6_type !Returned NULL Attribute Datatype identifier INTEGER :: num_attrs !number of attributes INTEGER ( HSIZE_T ) :: attr_storage ! attributes storage requirements .MSB. CHARACTER ( LEN = 256 ) :: attr_name !buffer to put attr_name INTEGER ( SIZE_T ) :: name_size = 80 !attribute name length CHARACTER ( LEN = 35 ), DIMENSION ( 2 ) :: attr_data ! String attribute data CHARACTER ( LEN = 35 ), DIMENSION ( 2 ) :: aread_data ! Buffer to put read back ! string attr data CHARACTER :: attr_character_data = 'A' DOUBLE PRECISION , DIMENSION ( 1 ) :: attr_double_data = 3.459 REAL , DIMENSION ( 1 ) :: attr_real_data = 4.0 INTEGER , DIMENSION ( 1 ) :: attr_integer_data = 5 CHARACTER :: aread_character_data ! variable to put read back Character attr data INTEGER , DIMENSION ( 1 ) :: aread_integer_data ! variable to put read back integer attr data INTEGER , DIMENSION ( 1 ) :: aread_null_data = 7 ! variable to put read back null attr data DOUBLE PRECISION , DIMENSION ( 1 ) :: aread_double_data ! variable to put read back double attr data REAL , DIMENSION ( 1 ) :: aread_real_data ! variable to put read back real attr data character ( len = 80 ) :: fname , datapath , g1 , g2 , g3 , s integer :: error , total_error , i ! Error flag INTEGER ( HSIZE_T ), allocatable :: data_dims (:) INTEGER ( HSIZE_T ) :: npoints integer :: rnk , type_class integer ( SIZE_T ) :: type_size integer ( HID_T ) :: grp1_id , grp2_id , grp3_id real ( kind = 8 ), allocatable :: buf_dbl1 (:), buf_dbl2 (:,:), buf_dbl3 (:,:,:) real ( kind = 4 ), allocatable :: buf_flt1 (:) character ( 8 ) :: scversion character ( 11 ) :: dstring character ( 15 ) :: tstring call timestamp ( datestring = dstring , timestring = tstring ) fname = 'Nidata.h5' scversion = '3.x.x' write ( * , * ) 'Date = ' // dstring write ( * , * ) 'Time = ' // tstring ! ! Initialize FORTRAN interface. ! CALL h5open_EMsoft ( error ) write ( * , * ) 'Initialize Fortran interface error   = ' , error write ( * , * ) 'calling h5fopen_f to open file ' // fname CALL h5fopen_f ( fname , H5F_ACC_RDWR_F , file_id , error ) write ( * , * ) 'file_id = ' , file_id write ( * , * ) 'error   = ' , error ! datapath = \"/Scan 1/EBSD/Data/CI\" call h5ltget_dataset_ndims_f ( file_id , datapath , rnk , error ) write ( * , * ) ' data dimensionality = ' , rnk allocate ( data_dims ( rnk )) call h5ltget_dataset_info_f ( file_id , datapath , data_dims , type_class , type_size , error ) write ( * , * ) ' data set info : ' , data_dims ( 1 ), type_class , type_size , error allocate ( buf_flt1 ( data_dims ( 1 ))) call h5ltread_dataset_f ( file_id , datapath , H5T_NATIVE_REAL , buf_flt1 , data_dims , error ) do i = 1 , 10 write ( * , * ) i , buf_flt1 ( i ) end do write ( * , * ) 'calling h5fclose_f to close file ' CALL h5fclose_f ( file_id , error ) write ( * , * ) 'error   = ' , error ! now let's do a test an create a new file with this dataset written to it in a different location fname = 'test.h5' call h5fcreate_f ( fname , H5F_ACC_TRUNC_F , file_id , error ) g1 = 'EMheader' call h5gcreate_f ( file_id , g1 , grp1_id , error ) write ( * , * ) 'open group ' , trim ( g1 ), ' ' , error ! version number /EMheader/Version 'character' call h5ltmake_dataset_string_f ( grp1_id , 'Version' , scversion , error ) ! execution data /EMheader/Date 'character' call h5ltmake_dataset_string_f ( grp1_id , 'Date' , dstring , error ) ! start time /EMheader/StartTime 'character' call h5ltmake_dataset_string_f ( grp1_id , 'StartTime' , tstring , error ) ! stop time /EMheader/StopTime 'character' call h5ltmake_dataset_string_f ( grp1_id , 'StopTime' , tstring , error ) call h5gclose_f ( grp1_id , error ) g1 = 'level1' g2 = 'level2' g3 = 'CI' s = '/' call h5gcreate_f ( file_id , g1 , grp1_id , error ) write ( * , * ) 'open group ' , trim ( g1 ), ' ' , error call h5gcreate_f ( grp1_id , g2 , grp2_id , error ) write ( * , * ) 'open group ' , trim ( g2 ), ' ' , error datapath = trim ( s ) // trim ( g1 ) // trim ( s ) // trim ( g2 ) // trim ( s ) // trim ( g3 ) write ( * , * ) 'datapath = ' , datapath call h5ltmake_dataset_f ( file_id , datapath , rnk , data_dims , H5T_NATIVE_REAL , buf_flt1 , error ) call h5gclose_f ( grp2_id , error ) call h5gclose_f ( grp1_id , error ) call h5fclose_f ( file_id , error ) ! ! Close FORTRAN interface. ! CALL h5close_EMsoft ( error ) write ( * , * ) 'close fortran interface error   = ' , error end program hdftest subroutine timestamp ( stdout , timestring , datestring ) IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ), OPTIONAL :: stdout character ( len = 11 ), INTENT ( OUT ), OPTIONAL :: datestring character ( len = 15 ), INTENT ( OUT ), OPTIONAL :: timestring integer ( kind = 4 ) :: std character ( len = 8 ) :: ampm integer ( kind = 4 ) :: d character ( len = 8 ) :: date integer ( kind = 4 ) :: h integer ( kind = 4 ) :: mo integer ( kind = 4 ) :: mm character ( len = 3 ), parameter , dimension ( 12 ) :: month = ( / & 'Jan' , 'Feb' , 'Mar' , 'Apr' , 'May' , 'Jun' , 'Jul' , 'Aug' , 'Sep' , 'Oct' , 'Nov' , 'Dec' / ) integer ( kind = 4 ) :: n integer ( kind = 4 ) :: s character ( len = 10 ) :: time integer ( kind = 4 ) :: values ( 8 ) integer ( kind = 4 ) :: y character ( len = 5 ) :: zone std = 6 if ( PRESENT ( stdout )) std = stdout call date_and_time ( date , time , zone , values ) y = values ( 1 ) mo = values ( 2 ) d = values ( 3 ) h = values ( 5 ) n = values ( 6 ) s = values ( 7 ) mm = values ( 8 ) if ( h < 12 ) then ampm = 'AM' else if ( h == 12 ) then if ( n == 0 . and . s == 0 ) then ampm = 'Noon' else ampm = 'PM' end if else h = h - 12 if ( h < 12 ) then ampm = 'PM' else if ( h == 12 ) then if ( n == 0 . and . s == 0 ) then ampm = 'Midnight' else ampm = 'AM' end if end if end if if ((. not . PRESENT ( datestring )). and .(. not . PRESENT ( timestring ))) then write ( std , '(a,1x,i2,1x,i4,2x,i2,a1,i2.2,a1,i2.2,a1,i3.3,1x,a)' ) & month ( mo ), d , y , h , ':' , n , ':' , s , '.' , mm , trim ( ampm ) else if ( PRESENT ( datestring )) write ( datestring , '(a,1x,i2,1x,i4)' ) month ( mo ), d , y if ( PRESENT ( timestring )) then write ( timestring , '(i2,a1,i2.2,a1,i2.2,a1,i3.3,1x,a)' ) h , ':' , n , ':' , s , '.' , mm , trim ( ampm ) end if end if end subroutine timestamp","tags":"","loc":"sourcefile/hdftest.f90.html","title":"hdftest.f90 – Fortran Program"},{"text":"This File Depends On sourcefile~~indexingmod.f90~~EfferentGraph sourcefile~indexingmod.f90 Indexingmod.f90 sourcefile~clsupport.f90 CLsupport.f90 sourcefile~clsupport.f90->sourcefile~indexingmod.f90 sourcefile~namelisttypedefs.f90 NameListTypedefs.f90 sourcefile~namelisttypedefs.f90->sourcefile~indexingmod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files Dependent On This One sourcefile~~indexingmod.f90~~AfferentGraph sourcefile~indexingmod.f90 Indexingmod.f90 sourcefile~emdymod.f90 EMdymod.f90 sourcefile~indexingmod.f90->sourcefile~emdymod.f90 sourcefile~simulated_annealing.f90 simulated_annealing.f90 sourcefile~emdymod.f90->sourcefile~simulated_annealing.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules Indexingmod Source Code Indexingmod.f90 Source Code ! ################################################################### ! Copyright (c) 2013-2014, Marc De Graef/Carnegie Mellon University ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without modification, are ! permitted provided that the following conditions are met: ! !     - Redistributions of source code must retain the above copyright notice, this list !        of conditions and the following disclaimer. !     - Redistributions in binary form must reproduce the above copyright notice, this !        list of conditions and the following disclaimer in the documentation and/or !        other materials provided with the distribution. !     - Neither the names of Marc De Graef, Carnegie Mellon University nor the names !        of its contributors may be used to endorse or promote products derived from !        this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE ! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ################################################################### !-------------------------------------------------------------------------- ! EMsoft:Indexingmod.f90 !-------------------------------------------------------------------------- ! ! MODULE: Indexingmod ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief everything to do with indexing and such ! !> @date 11/17/15 SS 1.0 original !--------------------------------------------------------------------------- module Indexingmod use local use NameListTypedefs IMPLICIT NONE contains !-------------------------------------------------------------------------- ! ! SUBROUTINE:InnerProdGPU ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief Perform the inner product computations for the dictionary approach ! !> @param expt vector with list of observed patterns !> @param dict vector with list of calculated patterns !> @param Ne number of patterns in the expt vector !> @param Nd number of patterns in the dict vector !> @param L size of one single pattern !> @param result result of the matrix multiplication !> @param source the opencl kernel as a character array !> @param length of character array !> @param platform opencl platform type !> @param device opencl device type !> @param context opencl context type !> @param command_queue opencl command queue ! !> @date 12/09/14  SS 1.0 original !> @date 27/01/15  SS 1.1 modified to call the subroutine from mastersubroutine !> @date 02/24/16 MDG 1.2 converted OpenCL calls to clfortran from fortrancl !> @date 03/03/16 MDG 1.3 added C_NULL_CHAR to kernelname !> @date 06/07/17 MDG 1.4 removed progoptions from Build Program call; caused some issues on Linux in Release mode !-------------------------------------------------------------------------- recursive subroutine InnerProdGPU ( cl_expt , cl_dict , Ne , Nd , correctsize , results , numd , selnumd , csource , source_length , & platform , device , context , command_queue ) !DEC$ ATTRIBUTES DLLEXPORT :: InnerProdGPU use local use clfortran use CLsupport use ISO_C_BINDING use io use error IMPLICIT NONE real ( kind = 4 ), INTENT ( OUT ), target :: results ( Ne * Nd ) integer ( c_intptr_t ), target , INTENT ( INOUT ) :: cl_expt integer ( c_intptr_t ), target , INTENT ( INOUT ) :: cl_dict integer ( kind = 4 ), INTENT ( IN ) :: Ne integer ( kind = 4 ), INTENT ( IN ) :: Nd integer ( kind = 4 ), INTENT ( IN ) :: correctsize integer ( kind = irg ), INTENT ( IN ) :: numd , selnumd integer ( c_size_t ), INTENT ( IN ), target :: source_length character ( len = source_length , KIND = c_char ), TARGET , INTENT ( IN ) :: csource integer ( c_intptr_t ), allocatable , target , INTENT ( IN ) :: platform (:) integer ( c_intptr_t ), allocatable , target , INTENT ( INOUT ) :: device (:) integer ( c_intptr_t ), target , INTENT ( INOUT ) :: context integer ( c_intptr_t ), target , INTENT ( INOUT ) :: command_queue type ( c_ptr ), target :: psource integer ( c_int32_t ) :: ierr , ierr2 , pcnt integer ( c_intptr_t ), target :: prog integer ( c_intptr_t ), target :: kernel integer ( c_intptr_t ), target :: cl_result character ( 19 ), target :: progoptions integer ( c_size_t ) :: cnum character ( len = source_length ), target :: source real ( kind = 4 ) :: dicttranspose ( Nd * correctsize ) integer ( kind = 4 ), parameter :: iunit = 40 character ( fnlen ) :: info ! info about the GPU integer ( kind = 8 ), target :: globalsize ( 2 ), localsize ( 2 ) integer , parameter :: source_length_build_info = 10000 character ( len = source_length ) :: source_build_info integer ( kind = 4 ) :: num , istat , i , j , ii , jj , kk , io_int ( 1 ) integer ( kind = 4 ), target :: Wexp , Wdict integer ( kind = 8 ) :: size_in_bytes_expt , size_in_bytes_dict , size_in_bytes_result character ( 9 ), target :: kernelname character ( 10 , KIND = c_char ), target :: ckernelname integer ( kind = irg ) :: irec size_in_bytes_result = Ne * Nd * sizeof ( results ( 1 )) Wexp = correctsize Wdict = Nd localsize = ( / 16 , 16 / ) globalsize = ( / Ne , Nd / ) !===================== ! INITIALIZATION !===================== ! was performed in the calling program !===================== ! BUILD THE KERNEL !===================== ! create the program pcnt = 1 psource = C_LOC ( csource ) prog = clCreateProgramWithSource ( context , pcnt , C_LOC ( psource ), C_LOC ( source_length ), ierr ) call CLerror_check ( 'InnerProdGPU:clCreateProgramWithSource' , ierr ) ! build the program progoptions = '-cl-no-signed-zeros' ! ierr = clBuildProgram(prog, numd, C_LOC(device), C_LOC(progoptions), C_NULL_FUNPTR, C_NULL_PTR) ierr = clBuildProgram ( prog , numd , C_LOC ( device ), C_NULL_PTR , C_NULL_FUNPTR , C_NULL_PTR ) ! get the compilation log ierr2 = clGetProgramBuildInfo ( prog , device ( selnumd ), CL_PROGRAM_BUILD_LOG , sizeof ( source ), C_LOC ( source ), cnum ) ! if(cnum > 1) call Message(trim(source(1:cnum))//'test',frm='(A)') call CLerror_check ( 'InnerProdGPU:clBuildProgram' , ierr ) call CLerror_check ( 'InnerProdGPU:clGetProgramBuildInfo' , ierr2 ) ! finally get the kernel and release the program kernelname = 'InnerProd' ckernelname = kernelname ckernelname ( 10 : 10 ) = C_NULL_CHAR kernel = clCreateKernel ( prog , C_LOC ( ckernelname ), ierr ) call CLerror_check ( 'InnerProdGPU:clCreateKernel' , ierr ) ierr = clReleaseProgram ( prog ) call CLerror_check ( 'InnerProdGPU:clReleaseProgram' , ierr ) ! create buffer cl_result = clCreateBuffer ( context , CL_MEM_READ_WRITE , size_in_bytes_result , C_NULL_PTR , ierr ) call CLerror_check ( 'InnerProdGPU:clCreateBuffer' , ierr ) ! set kernel arguments ierr = clSetKernelArg ( kernel , 0 , sizeof ( cl_expt ), C_LOC ( cl_expt )) call CLerror_check ( 'InnerProdGPU:clSetKernelArg:cl_expt' , ierr ) ierr = clSetKernelArg ( kernel , 1 , sizeof ( cl_dict ), C_LOC ( cl_dict )) call CLerror_check ( 'InnerProdGPU:clSetKernelArg:cl_dict' , ierr ) ierr = clSetKernelArg ( kernel , 2 , sizeof ( Wexp ), C_LOC ( Wexp )) call CLerror_check ( 'InnerProdGPU:clSetKernelArg:Wexp' , ierr ) ierr = clSetKernelArg ( kernel , 3 , sizeof ( Wdict ), C_LOC ( Wdict )) call CLerror_check ( 'InnerProdGPU:clSetKernelArg:Wdict' , ierr ) ierr = clSetKernelArg ( kernel , 4 , sizeof ( cl_result ), C_LOC ( cl_result )) call CLerror_check ( 'InnerProdGPU:clSetKernelArg:cl_result' , ierr ) !execute the kernel ierr = clEnqueueNDRangeKernel ( command_queue , kernel , 2 , C_NULL_PTR , C_LOC ( globalsize ), C_LOC ( localsize ), & 0 , C_NULL_PTR , C_NULL_PTR ) call CLerror_check ( 'InnerProdGPU:clEnqueueNDRangeKernel' , ierr ) ! wait for the commands to finish ierr = clFinish ( command_queue ) call CLerror_check ( 'InnerProdGPU:clFinish' , ierr ) ! read the resulting vector from device memory ierr = clEnqueueReadBuffer ( command_queue , cl_result , CL_TRUE , 0 _ 8 , size_in_bytes_result , C_LOC ( results ( 1 )), 0 , C_NULL_PTR , C_NULL_PTR ) call CLerror_check ( 'InnerProdGPU:clEnqueueReadBuffer' , ierr ) ierr = clReleaseKernel ( kernel ) call CLerror_check ( 'InnerProdGPU:clReleaseKernel' , ierr ) ierr = clReleaseMemObject ( cl_result ) call CLerror_check ( 'InnerProdGPU:clReleaseMemObject:cl_result' , ierr ) end subroutine InnerProdGPU !-------------------------------------------------------------------------- recursive function Jaccard_Distance ( img1 , img2 , nn ) result ( JD ) !DEC$ ATTRIBUTES DLLEXPORT :: Jaccard_Distance use local IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: img1 ( nn ) integer ( kind = irg ), INTENT ( IN ) :: img2 ( nn ) integer ( kind = irg ), INTENT ( IN ) :: nn real ( kind = dbl ) :: JD real ( kind = sgl ) :: hist1 ( 256 ), hist2 ( 256 ), jhist ( 256 , 256 ), H1 , H2 , H12 integer ( kind = irg ) :: ii , jj , kk hist1 = 0.D0 hist2 = 0.D0 jhist = 0.D0 H1 = 0.D0 H2 = 0.D0 H12 = 0.D0 do ii = 1 , nn jj = img1 ( ii ) + 1 kk = img2 ( ii ) + 1 jhist ( jj , kk ) = jhist ( jj , kk ) + 1.D0 end do jhist = jhist / nn hist1 ( 1 : 256 ) = sum ( jhist , 2 ) hist2 ( 1 : 256 ) = sum ( jhist , 1 ) !open(unit=13,file='/Users/saranshsingh/Desktop/jh.txt',form='formatted') do ii = 0 , 255 if ( hist1 ( ii + 1 ) . ne . 0.0 ) then H1 = H1 + hist1 ( ii + 1 ) * log ( hist1 ( ii + 1 )) end if if ( hist2 ( ii + 1 ) . ne . 0.0 ) then H2 = H2 + hist2 ( ii + 1 ) * log ( hist2 ( ii + 1 )) end if do jj = 0 , 255 !write(13,'(F15.6)',advance='no')jhist(ii+1,jj+1) if ( jhist ( ii + 1 , jj + 1 ) . ne . 0.0 ) then H12 = H12 + jhist ( ii + 1 , jj + 1 ) * log ( jhist ( ii + 1 , jj + 1 )) end if end do !write(13,*)'' end do !JD = -H12 + (H1 + H2) JD = 2.D0 - ( H1 + H2 ) / H12 end function Jaccard_Distance end module","tags":"","loc":"sourcefile/indexingmod.f90.html","title":"Indexingmod.f90 – Fortran Program"},{"text":"This File Depends On sourcefile~~initializers.f90~~EfferentGraph sourcefile~initializers.f90 initializers.f90 sourcefile~constants.f90 constants.f90 sourcefile~constants.f90->sourcefile~initializers.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files Dependent On This One sourcefile~~initializers.f90~~AfferentGraph sourcefile~initializers.f90 initializers.f90 sourcefile~emdymod.f90 EMdymod.f90 sourcefile~initializers.f90->sourcefile~emdymod.f90 sourcefile~simulated_annealing.f90 simulated_annealing.f90 sourcefile~emdymod.f90->sourcefile~simulated_annealing.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules initializers Source Code initializers.f90 Source Code ! ################################################################### ! Copyright (c) 2014, Marc De Graef/Carnegie Mellon University ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without modification, are ! permitted provided that the following conditions are met: ! !     - Redistributions of source code must retain the above copyright notice, this list !        of conditions and the following disclaimer. !     - Redistributions in binary form must reproduce the above copyright notice, this !        list of conditions and the following disclaimer in the documentation and/or !        other materials provided with the distribution. !     - Neither the names of Marc De Graef, Carnegie Mellon University nor the names !        of its contributors may be used to endorse or promote products derived from !        this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE ! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ################################################################### !-------------------------------------------------------------------------- ! EMsoft:initializers.f90 !-------------------------------------------------------------------------- ! ! MODULE: initializers ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief several basic initialization routines ! !> @date 01/10/14 MDG 1.0 new version !> @date 01/11/15 MDG 2.0 split file into routines without and with HDF stuff !-------------------------------------------------------------------------- module initializers public :: Initialize_ReflectionList interface Initialize_ReflectionList module procedure Initialize_ReflectionList module procedure Initialize_ReflectionList_EwaldSweep end interface contains !-------------------------------------------------------------------------- ! ! SUBROUTINE: Initialize_ReflectionList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief initialize the potential reflection list for a given wave vector ! !> @param cell unit cell pointer !> @param BetheParameter Bethe potential structure !> @param FN  foil normal !> @param k zone axis direction cosines in direct Bravais lattice !> @param dmin smallest lattice d-spacing to consider !> @param listroot pointer to top of list (could be cell%reflist) !> @param nref number of reflections in main list (used to be DynNbeams) !> @param verbose (optional) used for debugging purposes mostly ! !> @date 01/10/14 MDG 1.0 original, based on old Compute_ReflectionList !> @date 01/13/14 MDG 1.1 update for new cell type definition and new Bethe potential criterion !> @date 06/15/14 MDG 2.0 update for removal of all globals !> @date 06/16/14 MDG 2.1 added recursive !> @date 06/23/14 MDG 2.2 replaced Dyn structure by FN !-------------------------------------------------------------------------- recursive subroutine Initialize_ReflectionList ( cell , listroot , BetheParameter , FN , k , dmin , nref , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: Initialize_ReflectionList use local use typedefs use io use crystal use constants use gvectors use diffraction use symmetry IMPLICIT NONE type ( unitcell ), pointer :: cell type ( reflisttype ), pointer :: listroot type ( BetheParameterType ), INTENT ( INOUT ) :: BetheParameter real ( kind = sgl ), INTENT ( IN ) :: FN ( 3 ) real ( kind = sgl ), INTENT ( IN ) :: k ( 3 ) real ( kind = sgl ), INTENT ( IN ) :: dmin integer ( kind = irg ), INTENT ( INOUT ) :: nref logical , INTENT ( IN ), OPTIONAL :: verbose integer ( kind = irg ) :: imh , imk , iml , gg ( 3 ), ix , iy , iz , i , minholz , RHOLZ , im , istat , N , & ig , numr , ir , irsel real ( kind = sgl ) :: dhkl , io_real ( 9 ), H , g3 ( 3 ), g3n ( 3 ), FNg ( 3 ), ddt , s , kr ( 3 ), exer , & rBethe_i , rBethe_d , sgp , r_g , la , dval integer ( kind = irg ) :: io_int ( 3 ), gshort ( 3 ), gp ( 3 ) type ( reflisttype ), pointer :: rltail ! set the truncation parameters rBethe_i = BetheParameter % c3 ! if larger than this value, we ignore the reflection completely rBethe_d = BetheParameter % sgdbdiff ! excitation error cutoff for double diffraction reflections la = 1.0 / sngl ( cell % mLambda ) ! get the size of the lookup table gp = shape ( cell % LUT ) imh = ( gp ( 1 ) - 1 ) / 4 imk = ( gp ( 2 ) - 1 ) / 4 iml = ( gp ( 3 ) - 1 ) / 4 nullify ( listroot ) nullify ( rltail ) ! transmitted beam has excitation error zero gg = ( / 0 , 0 , 0 / ) call AddReflection ( rltail , listroot , cell , nref , gg ) ! this guarantees that 000 is always the first reflection rltail % sg = 0.0 ! now compute |sg|/|U_g|/lambda for the other allowed reflections; if this parameter is less than ! the threshhold, rBethe_i, then add the reflection to the list of potential reflections ixl : do ix =- imh , imh iyl : do iy =- imk , imk izl : do iz =- iml , iml if (( abs ( ix ) + abs ( iy ) + abs ( iz )). ne . 0 ) then ! avoid double counting the origin gg = ( / ix , iy , iz / ) dval = 1.0 / CalcLength ( cell , float ( gg ), 'r' ) if (( IsGAllowed ( cell , gg )). and .( dval . gt . dmin )) then ! allowed by the lattice centering, if any sgp = Calcsg ( cell , float ( gg ), k , FN ) if ( cell % dbdiff ( ix , iy , iz )) then ! potential double diffraction reflection if ( abs ( sgp ). le . rBethe_d ) then call AddReflection ( rltail , listroot , cell , nref , gg ) rltail % sg = sgp rltail % dbdiff = . TRUE . end if else r_g = la * abs ( sgp ) / cdabs ( cell % LUT ( ix , iy , iz )) if ( r_g . le . rBethe_i ) then call AddReflection ( rltail , listroot , cell , nref , gg ) rltail % sg = sgp rltail % dbdiff = . FALSE . end if end if end if ! IsGAllowed end if end do izl end do iyl end do ixl if ( present ( verbose )) then if ( verbose ) then io_int ( 1 ) = nref call WriteValue ( ' Length of the master list of reflections : ' , io_int , 1 , \"(I8)\" ) end if end if end subroutine Initialize_ReflectionList !-------------------------------------------------------------------------- ! ! SUBROUTINE: Initialize_ReflectionList_EwaldSweep ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief initialize the potential reflection list for a given precession electron diffraction geometry ! !> @param cell unit cell pointer !> @param listroot main pointer for reflection linked list (typically reflist in calling routine) !> @param FN  foil normal !> @param k zone axis direction cosines in direct Bravais lattice !> @param nref number of reflections in main list (used to be DynNbeams) !> @param pedangle precession cone angle in mrad !> @param goffset offset parameter for reflections to be included outside the Ewald sphere precession volume !> @param verbose (optional) used for debugging purposes mostly ! !> @date 01/10/14 MDG 1.0 original, based on old Compute_ReflectionList !> @date 01/13/14 MDG 1.1 update for new cell type definition and new Bethe potential criterion !> @date 06/15/14 MDG 2.0 update for removal of all globals !> @date 06/16/14 MDG 2.1 added recursive !> @date 06/23/14 MDG 2.2 replaced Dyn structure by FN !> @date 11/30/14 MDG 3.0 forked from original to accommodate PED case !-------------------------------------------------------------------------- recursive subroutine Initialize_ReflectionList_EwaldSweep ( cell , listroot , FN , k , nref , pedangle , goffset , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: Initialize_ReflectionList_EwaldSweep use local use typedefs use io use crystal use constants use gvectors use diffraction use symmetry IMPLICIT NONE type ( unitcell ), pointer :: cell type ( reflisttype ), pointer :: listroot real ( kind = sgl ), INTENT ( IN ) :: FN ( 3 ) real ( kind = sgl ), INTENT ( IN ) :: k ( 3 ) integer ( kind = irg ), INTENT ( INOUT ) :: nref real ( kind = sgl ), INTENT ( IN ) :: pedangle real ( kind = sgl ), INTENT ( IN ) :: goffset logical , INTENT ( IN ), OPTIONAL :: verbose integer ( kind = irg ) :: imh , imk , iml , gg ( 3 ), ix , iy , iz , io_int ( 3 ), gp ( 3 ) real ( kind = sgl ) :: FNg ( 3 ), c , s , kr ( 3 ), sgp , la , kstar ( 3 ), gperp ( 3 ), gpara ( 3 ), bup , blo , y , z , & gdk , glen , gplen type ( reflisttype ), pointer :: rltail ! init a couple of parameters la = 1.0 / sngl ( cell % mLambda ) c = la * cos ( pedangle / 100 0.0 ) s = 2.0 * la * sin ( pedangle / 100 0.0 ) ! reciprocal space wave vector call TransSpace ( cell , k , kstar , 'd' , 'r' ) call NormVec ( cell , kstar , 'r' ) kstar = la * kstar ! get the size of the lookup table gp = shape ( cell % LUT ) imh = ( gp ( 1 ) - 1 ) / 4 imk = ( gp ( 2 ) - 1 ) / 4 iml = ( gp ( 3 ) - 1 ) / 4 nullify ( listroot ) nullify ( rltail ) ! transmitted beam has excitation error zero, and set xg to zero; xg will store the accumulated intensity for each reflection gg = ( / 0 , 0 , 0 / ) call AddReflection ( rltail , listroot , cell , nref , gg ) ! this guarantees that 000 is always the first reflection rltail % sg = 0.0 rltail % xg = 0.0 ! scan through the reciprocal lattice volume corresponding to the dmin value ixl : do ix =- imh , imh iyl : do iy =- imk , imk izl : do iz =- iml , iml if (( abs ( ix ) + abs ( iy ) + abs ( iz )). ne . 0 ) then ! avoid double counting the origin gg = ( / ix , iy , iz / ) if ( IsGAllowed ( cell , gg )) then ! allowed by the lattice centering, if any ! first we need to determine the parallel and perpendicular components of this g vector with respect to the beam direction in reciprocal space gdk = CalcDot ( cell , float ( gg ), kstar , 'r' ) ! projection of gg onto k* gpara = gdk * kstar gperp = float ( gg ) - gpara ! then get the length of the perpendicular and parallel components, including sign of parallel component glen = CalcLength ( cell , gperp , 'r' ) gplen = CalcLength ( cell , gpara , 'r' ) ! sign of length depends on dot product sign of gg onto k* if ( gdk . le . 0.0 ) gplen = - gplen ! compute the upper and lower bounds for this value of glen y = glen * s z = c * c - glen * glen bup = goffset + c - sqrt ( z - y ) blo = - goffset + c - sqrt ( z + y ) ! and check whether or not this point should be taken into account if (( blo . le . gplen ). and .( gplen . le . bup )) then sgp = Calcsg ( cell , float ( gg ), k , FN ) ! note that we are not applying any Bethe parameter conditions here since those will be applied for each beam orientation separately if ( cell % dbdiff ( ix , iy , iz )) then ! potential double diffraction reflection call AddReflection ( rltail , listroot , cell , nref , gg ) rltail % sg = sgp rltail % xg = 0.0 rltail % dbdiff = . TRUE . else call AddReflection ( rltail , listroot , cell , nref , gg ) rltail % sg = sgp rltail % xg = 0.0 rltail % dbdiff = . FALSE . end if end if ! reflection inside precession-swept Ewald sphere volume end if ! IsGAllowed end if ! not the origin end do izl end do iyl end do ixl if ( present ( verbose )) then if ( verbose ) then io_int ( 1 ) = nref call WriteValue ( ' Length of the master list of reflections : ' , io_int , 1 , \"(I8)\" ) end if end if end subroutine Initialize_Reflectionlist_EwaldSweep end module initializers","tags":"","loc":"sourcefile/initializers.f90.html","title":"initializers.f90 – Fortran Program"},{"text":"This File Depends On sourcefile~~jsonsupport.f90~~EfferentGraph sourcefile~jsonsupport.f90 JSONsupport.f90 sourcefile~namelisthandlers.f90 NameListHandlers.f90 sourcefile~namelisthandlers.f90->sourcefile~jsonsupport.f90 sourcefile~namelisttypedefs.f90 NameListTypedefs.f90 sourcefile~namelisttypedefs.f90->sourcefile~jsonsupport.f90 sourcefile~namelisttypedefs.f90->sourcefile~namelisthandlers.f90 sourcefile~constants.f90 constants.f90 sourcefile~constants.f90->sourcefile~namelisthandlers.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files Dependent On This One sourcefile~~jsonsupport.f90~~AfferentGraph sourcefile~jsonsupport.f90 JSONsupport.f90 sourcefile~defectmodule.f90 defectmodule.f90 sourcefile~jsonsupport.f90->sourcefile~defectmodule.f90 sourcefile~dispfield.f90 dispfield.f90 sourcefile~defectmodule.f90->sourcefile~dispfield.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules JSONsupport Source Code JSONsupport.f90 Source Code ! ################################################################### ! Copyright (c) 2013-2015, Marc De Graef/Carnegie Mellon University ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without modification, are ! permitted provided that the following conditions are met: ! !     - Redistributions of source code must retain the above copyright notice, this list !        of conditions and the following disclaimer. !     - Redistributions in binary form must reproduce the above copyright notice, this !        list of conditions and the following disclaimer in the documentation and/or !        other materials provided with the distribution. !     - Neither the names of Marc De Graef, Carnegie Mellon University nor the names !        of its contributors may be used to endorse or promote products derived from !        this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE ! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ################################################################### !-------------------------------------------------------------------------- ! EMsoft:JSONsupport.f90 !-------------------------------------------------------------------------- ! ! MODULE: JSONsupport ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief routines for conversion between json and nml files and reading of json files ! !> @date  08/11/15 MDG 1.0 original !> @date  08/12/15 MDG 1.1 added all routines currently also in NameListHDFwriters.f90 !> @date  08/12/15 MDG 1.2 replaced all the json_failed stuff by short routine JSON_failtest !> @date  11/20/15 MDG 1.3 started defect file format !-------------------------------------------------------------------------- module JSONsupport use local use typedefs use , intrinsic :: iso_fortran_env , only : error_unit , wp => real64 use NameListTypedefs use json_module IMPLICIT NONE contains ! these are the jsonfortran public functions from jsonmodule.mod ! !    public :: json_add                   ! add data to a JSON structure !    public :: json_check_for_errors      ! check for error and get error message !    public :: json_clear_exceptions      ! clear exceptions !    public :: json_count                 ! count the number of children !    public :: json_create_array          ! allocate a json_value array !    public :: json_create_double         ! allocate a json_value double !    public :: json_create_integer        ! allocate a json_value integer !    public :: json_create_logical        ! allocate a json_value logical !    public :: json_create_null           ! allocate a json_value null !    public :: json_create_object         ! allocate a json_value object !    public :: json_create_string         ! allocate a json_value string !    public :: json_destroy               ! clear a JSON structure (destructor) !    public :: json_failed                ! check for error !    public :: json_get                   ! get data from the JSON structure !    public :: json_get_child             ! get a child of a json_value !    public :: json_info                  ! get info about a json_value !    public :: json_initialize            ! to initialize the module !    public :: json_parse                 ! read a JSON file and populate the structure !    public :: json_print                 ! print the JSON structure to a file !    public :: json_print_to_string       ! write the JSON structure to a string !    public :: json_remove                ! remove from a JSON structure !    public :: json_remove_if_present     ! remove from a JSON structure (if it is present) !    public :: json_update                ! update a value in a JSON structure !    public :: json_traverse              ! to traverse all elements of a JSON structure !    public :: json_print_error_message   ! !    public :: to_unicode                 ! Function to convert from 'DEFAULT' to 'ISO_10646' strings !-------------------------------------------------------------------------- ! ! FUNCTION:JSON_minify ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief remove all fortran comment lines from a JSON input file and store file in tmp folder ! !> @param jsonname json file name !> @param jsonreturn filename of stripped down JSON input file (in EMsoft tmp folder) ! !> @date 05/11/17  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive function JSON_minify ( jsonname ) result ( jsonreturn ) !DEC$ ATTRIBUTES DLLEXPORT :: JSON_minify IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: jsonname character ( fnlen ) :: jsonreturn ! the JSON syntax standard does not allow for comment lines/statements of any kind. ! In the XXX.jtemplate files, comment lines starting with the f90 ! comment character ! are interspersed with the name-value pairs.  Those are present to make it easier for ! the user to figure out what each variable means.  They need to be removed before the ! file is sent to the json parser routine, and this is done here.  The stripped down ! file is stored in the EMsoft tmp folder with the same name and must be deleted after ! the parsing has been completed. ! with the 5.3 version of json-fortran, it is possible to convert a json file to a namelist ! file, so since we are already set up to handle namelist files, this will signficantly ! simplify the implementation of the JSON format... ! jsonname is jsonreturn = '' end function JSON_minify !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSON_failtest ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief executes the json_fail routine; mostly to shorten the remaining code a little ! !> @param error_cnt error counter ! !> @date 08/12/15  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSON_failtest ( error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSON_failtest IMPLICIT NONE integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt if ( json_failed (). eqv .. TRUE .) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine JSON_failtest !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSON_writeNMLintegers ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief write a series of integer namelist entries to a json structure ! !> @param inp json structure pointer !> @param io_int list of integers !> @param intlist list of string descriptors !> @param n_int number of entries !> @param error_cnt error counter ! !> @date 08/11/15  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSON_writeNMLintegers IMPLICIT NONE type ( json_value ), INTENT ( INOUT ), pointer :: inp integer ( kind = irg ), INTENT ( IN ) :: io_int ( n_int ) character ( 20 ), INTENT ( IN ) :: intlist ( n_int ) integer ( kind = irg ), INTENT ( IN ) :: n_int integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt integer ( kind = irg ) :: i character ( fnlen ) :: dataset do i = 1 , n_int dataset = intlist ( i ) call json_add ( inp , dataset , io_int ( i )); call JSON_failtest ( error_cnt ) end do end subroutine JSON_writeNMLintegers !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSON_writeNMLreals ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief write a series of real namelist entries to a json structure ! !> @param inp pointer to json_value !> @param io_real list of reals !> @param reallist list of string descriptors !> @param n_real number of entries !> @param error_cnt error counter ! !> @date 08/11/15  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSON_writeNMLreals ( inp , io_real , reallist , n_real , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSON_writeNMLreals IMPLICIT NONE type ( json_value ), INTENT ( INOUT ), pointer :: inp real ( kind = sgl ), INTENT ( IN ) :: io_real ( n_real ) character ( 20 ), INTENT ( IN ) :: reallist ( n_real ) integer ( kind = irg ), INTENT ( IN ) :: n_real integer ( kind = irg ) :: hdferr , i character ( fnlen ) :: dataset integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt do i = 1 , n_real dataset = reallist ( i ) call json_add ( inp , dataset , dble ( io_real ( i ))); call JSON_failtest ( error_cnt ) end do end subroutine JSON_writeNMLreals !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSON_writeNMLdoubles ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief write a series of double namelist entries to a json structure ! !> @param inp pointer to json_value !> @param io_real list ofadoubles !> @param reallist list of string descriptors !> @param n_real number of entries !> @param error_cnt error counter ! !> @date 08/11/15  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSON_writeNMLdoubles ( inp , io_real , reallist , n_real , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSON_writeNMLdoubles IMPLICIT NONE type ( json_value ), INTENT ( INOUT ), pointer :: inp real ( kind = dbl ), INTENT ( IN ) :: io_real ( n_real ) character ( 20 ), INTENT ( IN ) :: reallist ( n_real ) integer ( kind = irg ), INTENT ( IN ) :: n_real integer ( kind = irg ) :: hdferr , i character ( fnlen ) :: dataset integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt do i = 1 , n_real dataset = reallist ( i ) call json_add ( inp , dataset , io_real ( i )); call JSON_failtest ( error_cnt ) end do end subroutine JSON_writeNMLdoubles !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSON_initpointers ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief initialize the necessary pointers to write a namelist json file ! !> @param inp pointer to json_value !> @param io_real list of reals !> @param reallist list of string descriptors !> @param n_real number of entries !> @param error_cnt error counter ! !> @date 08/11/15  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSON_initpointers IMPLICIT NONE type ( json_value ), INTENT ( INOUT ), pointer :: p , inp character ( fnlen ), INTENT ( IN ) :: jsonname , namelistname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt ! initialize the json state variables error_cnt = 0 call json_initialize (); call JSON_failtest ( error_cnt ) ! create the json root pointer call json_create_object ( p , trim ( jsonname )); call JSON_failtest ( error_cnt ) ! we'll use the namelist name to configure the inp structure and add it to p call json_create_object ( inp , trim ( namelistname )); call JSON_failtest ( error_cnt ) call json_add ( p , inp ); call JSON_failtest ( error_cnt ) end subroutine JSON_initpointers !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSON_cleanuppointers ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief clean up the pointers and write the json file ! !> @param p pointer to json_value !> @param inp pointer to json_value !> @param jsonname json output file name !> @param error_cnt error counter ! !> @date 08/11/15  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSON_cleanuppointers use io IMPLICIT NONE type ( json_value ), INTENT ( INOUT ), pointer :: p , inp character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt character ( fnlen ) :: fname ! get rid of inp nullify ( inp ) ! write the json file fname = EMsoft_toNativePath ( jsonname ) open ( unit = dataunit , file = trim ( fname ), status = 'REPLACE' ) call json_print ( p , dataunit ); call JSON_failtest ( error_cnt ) close ( dataunit ) ! final cleanup call json_destroy ( p ); call JSON_failtest ( error_cnt ) end subroutine JSON_cleanuppointers !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- ! from here on we have the Namelist->json conversion routines for all the ! namelists defined in the NameListTypedefs.f90 file. !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONwriteKosselNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief write namelist file into json file ! !> @param knl Kossel name list structure ! !> @date 08/11/15  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSONwriteKosselNameList ( knl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwriteKosselNameList use ISO_C_BINDING IMPLICIT NONE type ( KosselNameListType ), INTENT ( IN ) :: knl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 5 , n_real = 6 integer ( kind = irg ) :: hdferr , io_int ( n_int ) real ( kind = sgl ) :: io_real ( n_real ) character ( 20 ) :: intlist ( n_int ), reallist ( n_real ) character ( fnlen ) :: dataset , namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'Kossellist' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! then we need to add all the necessary fields to the inp structure ! write all the single integers io_int = ( / knl % stdout , knl % numthick , knl % npix , knl % maxHOLZ , knl % nthreads / ) intlist ( 1 ) = 'stdout' intlist ( 2 ) = 'numthick' intlist ( 3 ) = 'npix' intlist ( 4 ) = 'maxHOLZ' intlist ( 5 ) = 'nthreads' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) ! integer vectors dataset = 'k' call json_add ( inp , dataset , knl % k ); call JSON_failtest ( error_cnt ) dataset = 'fn' call json_add ( inp , dataset , knl % fn ); call JSON_failtest ( error_cnt ) ! write all the single reals io_real = ( / knl % voltage , knl % dmin , knl % convergence , knl % startthick , knl % thickinc , knl % minten / ) reallist ( 1 ) = 'voltage' reallist ( 2 ) = 'dmin' reallist ( 3 ) = 'convergence' reallist ( 4 ) = 'startthick' reallist ( 5 ) = 'thickinc' reallist ( 6 ) = 'minten' call JSON_writeNMLreals ( inp , io_real , reallist , n_real , error_cnt ) ! write all the strings dataset = 'xtalname' call json_add ( inp , dataset , knl % xtalname ); call JSON_failtest ( error_cnt ) dataset = 'outname' call json_add ( inp , dataset , knl % outname ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwriteKosselNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONwriteKosselMasterNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief write namelist file into json file ! !> @param knl Kossel name list structure !> @param jsonname output file name !> @param error_cnt total number of errors encountered by json routines ! !> @date 08/11/15  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSONwriteKosselMasterNameList ( knl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwriteKosselMasterNameList use ISO_C_BINDING IMPLICIT NONE type ( KosselMasterNameListType ), INTENT ( IN ) :: knl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 4 , n_real = 5 integer ( kind = irg ) :: io_int ( n_int ) real ( kind = sgl ) :: io_real ( n_real ) character ( 20 ) :: intlist ( n_int ), reallist ( n_real ) character ( fnlen ) :: dataset , namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'Kosselmasterlist' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! then we need to add all the necessary fields to the inp structure ! write all the single integers io_int = ( / knl % stdout , knl % numthick , knl % npx , knl % nthreads / ) intlist ( 1 ) = 'stdout' intlist ( 2 ) = 'numthick' intlist ( 3 ) = 'npx' intlist ( 4 ) = 'nthreads' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) ! write all the single reals io_real = ( / knl % voltage , knl % dmin , knl % startthick , knl % thickinc , knl % tfraction / ) reallist ( 1 ) = 'voltage' reallist ( 2 ) = 'dmin' reallist ( 3 ) = 'startthick' reallist ( 4 ) = 'thickinc' reallist ( 5 ) = 'tfraction' call JSON_writeNMLreals ( inp , io_real , reallist , n_real , error_cnt ) ! write all the strings dataset = 'Kosselmode' call json_add ( inp , dataset , knl % Kosselmode ); call JSON_failtest ( error_cnt ) dataset = 'xtalname' call json_add ( inp , dataset , knl % xtalname ); call JSON_failtest ( error_cnt ) dataset = 'outname' call json_add ( inp , dataset , knl % outname ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwriteKosselMasterNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONwriteMCNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief write namelist file into JSON file ! !> @param mcnl Monte Carlo name list structure !> @param jsonname output file name !> @param error_cnt total number of errors encountered by json routines ! !> @date 08/11/15  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSONwriteMCNameList ( mcnl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwriteMCNameList use ISO_C_BINDING IMPLICIT NONE type ( MCNameListType ), INTENT ( INOUT ) :: mcnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 5 , n_real = 7 integer ( kind = irg ) :: io_int ( n_int ) real ( kind = dbl ) :: io_real ( n_real ) character ( 20 ) :: intlist ( n_int ), reallist ( n_real ) character ( fnlen ) :: dataset , sval ( 1 ), namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'MCdata' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! write all the single integers io_int = ( / mcnl % stdout , mcnl % numsx , mcnl % primeseed , mcnl % num_el , mcnl % nthreads / ) intlist ( 1 ) = 'stdout' intlist ( 2 ) = 'numsx' intlist ( 3 ) = 'primeseed' intlist ( 4 ) = 'num_el' intlist ( 5 ) = 'nthreads' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) ! write all the single doubles io_real = ( / mcnl % sig , mcnl % omega , mcnl % EkeV , mcnl % Ehistmin , mcnl % Ebinsize , mcnl % depthmax , mcnl % depthstep / ) reallist ( 1 ) = 'sig' reallist ( 2 ) = 'omega' reallist ( 3 ) = 'EkeV' reallist ( 4 ) = 'Ehistmin' reallist ( 5 ) = 'Ebinsize' reallist ( 6 ) = 'depthmax' reallist ( 7 ) = 'depthstep' call JSON_writeNMLdoubles ( inp , io_real , reallist , n_real , error_cnt ) ! write all the strings dataset = 'MCmode' call json_add ( inp , dataset , mcnl % MCmode ); call JSON_failtest ( error_cnt ) dataset = 'xtalname' call json_add ( inp , dataset , mcnl % xtalname ); call JSON_failtest ( error_cnt ) dataset = 'dataname' call json_add ( inp , dataset , mcnl % dataname ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwriteMCNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONwriteMCCLNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief write namelist to JSON file !> @param jsonname output file name !> @param error_cnt total number of errors encountered by json routines ! !> @param mcnl Monte Carlo name list structure ! !> @date 03/21/15 MDG 1.0 new routine !> @date 09/09/15 MDG 1.1 added devid !> @date 10/12/15 SS  1.2 changes to handle new mc program !-------------------------------------------------------------------------- recursive subroutine JSONwriteMCCLNameList ( mcnl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwriteMCCLNameList use ISO_C_BINDING IMPLICIT NONE type ( MCCLNameListType ), INTENT ( INOUT ) :: mcnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 8 , n_real_bse1 = 9 , n_real_full = 7 integer ( kind = irg ) :: io_int ( n_int ) real ( kind = dbl ) :: io_real_bse1 ( n_real_bse1 ), io_real_full ( n_real_full ) character ( 20 ) :: intlist ( n_int ), reallist_bse1 ( n_real_bse1 ), reallist_full ( n_real_full ) character ( fnlen ) :: dataset , sval ( 1 ), namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'MCCLdata' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! write all the single integers io_int = ( / mcnl % stdout , mcnl % numsx , mcnl % globalworkgrpsz , mcnl % num_el , mcnl % totnum_el , mcnl % multiplier , mcnl % devid , mcnl % platid / ) intlist ( 1 ) = 'stdout' intlist ( 2 ) = 'numsx' intlist ( 3 ) = 'globalworkgrpsz' intlist ( 4 ) = 'num_el' intlist ( 5 ) = 'totnum_el' intlist ( 6 ) = 'multiplier' intlist ( 7 ) = 'devid' intlist ( 8 ) = 'platid' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) ! write all the single doubles for bse1 mode if ( mcnl % mode . eq . 'bse1' ) then io_real_bse1 = ( / mcnl % sigstart , mcnl % sigend , mcnl % sigstep , mcnl % omega , mcnl % EkeV , mcnl % Ehistmin , & mcnl % Ebinsize , mcnl % depthmax , mcnl % depthstep / ) reallist_bse1 ( 1 ) = 'sigstart' reallist_bse1 ( 2 ) = 'sigend' reallist_bse1 ( 3 ) = 'sigstep' reallist_bse1 ( 4 ) = 'omega' reallist_bse1 ( 5 ) = 'EkeV' reallist_bse1 ( 6 ) = 'Ehistmin' reallist_bse1 ( 7 ) = 'Ebinsize' reallist_bse1 ( 8 ) = 'depthmax' reallist_bse1 ( 9 ) = 'depthstep' call JSON_writeNMLdoubles ( inp , io_real_bse1 , reallist_bse1 , n_real_bse1 , error_cnt ) else if ( mcnl % mode . eq . 'full' ) then io_real_full = ( / mcnl % sig , mcnl % omega , mcnl % EkeV , mcnl % Ehistmin , & mcnl % Ebinsize , mcnl % depthmax , mcnl % depthstep / ) reallist_full ( 1 ) = 'sig' reallist_full ( 2 ) = 'omega' reallist_full ( 3 ) = 'EkeV' reallist_full ( 4 ) = 'Ehistmin' reallist_full ( 5 ) = 'Ebinsize' reallist_full ( 6 ) = 'depthmax' reallist_full ( 7 ) = 'depthstep' call JSON_writeNMLdoubles ( inp , io_real_full , reallist_full , n_real_full , error_cnt ) end if ! write all the strings dataset = 'MCmode' call json_add ( inp , dataset , mcnl % MCmode ); call JSON_failtest ( error_cnt ) dataset = 'xtalname' call json_add ( inp , dataset , mcnl % xtalname ); call JSON_failtest ( error_cnt ) dataset = 'dataname' call json_add ( inp , dataset , mcnl % dataname ); call JSON_failtest ( error_cnt ) dataset = 'mode' call json_add ( inp , dataset , mcnl % mode ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwriteMCCLNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONwriteMCCLMultiLayerNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief write namelist to JSON file ! !> @param mcnl Monte Carlo name list structure !> @param jsonname output file name !> @param error_cnt total number of errors encountered by json routines ! !> @date 08/11/15 MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSONwriteMCCLMultiLayerNameList ( mcnl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwriteMCCLMultiLayerNameList use ISO_C_BINDING IMPLICIT NONE type ( MCCLMultiLayerNameListType ), INTENT ( INOUT ) :: mcnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 5 , n_real = 9 integer ( kind = irg ) :: io_int ( n_int ) real ( kind = dbl ) :: io_real ( n_real ) character ( 20 ) :: intlist ( n_int ), reallist ( n_real ) character ( fnlen ) :: dataset , namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'MCCLdata' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! write all the single integers io_int = ( / mcnl % stdout , mcnl % numsx , mcnl % globalworkgrpsz , mcnl % num_el , mcnl % totnum_el / ) intlist ( 1 ) = 'stdout' intlist ( 2 ) = 'numsx' intlist ( 3 ) = 'globalworkgrpsz' intlist ( 4 ) = 'num_el' intlist ( 5 ) = 'totnum_el' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) ! write all the single doubles io_real = ( / mcnl % sig , mcnl % omega , mcnl % EkeV , mcnl % Ehistmin , mcnl % Ebinsize , mcnl % depthmax , mcnl % depthstep , & mcnl % filmthickness , mcnl % filmstep / ) reallist ( 1 ) = 'sig' reallist ( 2 ) = 'omega' reallist ( 3 ) = 'EkeV' reallist ( 4 ) = 'Ehistmin' reallist ( 5 ) = 'Ebinsize' reallist ( 6 ) = 'depthmax' reallist ( 7 ) = 'depthstep' reallist ( 8 ) = 'filmthickness' reallist ( 9 ) = 'filmstep' call JSON_writeNMLdoubles ( inp , io_real , reallist , n_real , error_cnt ) ! write all the strings dataset = 'MCmode' call json_add ( inp , dataset , mcnl % MCmode ); call JSON_failtest ( error_cnt ) dataset = 'xtalname_film' call json_add ( inp , dataset , mcnl % xtalname_film ); call JSON_failtest ( error_cnt ) dataset = 'xtalname_subs' call json_add ( inp , dataset , mcnl % xtalname_subs ); call JSON_failtest ( error_cnt ) dataset = 'dataname' call json_add ( inp , dataset , mcnl % dataname ); call JSON_failtest ( error_cnt ) dataset = 'mode' call json_add ( inp , dataset , mcnl % mode ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwriteMCCLMultiLayerNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONwriteEBSDMasterNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief write namelist to JSON file ! !> @param emnl EBSD master name list structure !> @param jsonname output file name !> @param error_cnt total number of errors encountered by json routines ! !> @date 08/12/15 MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSONwriteEBSDMasterNameList ( emnl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwriteEBSDMasterNameList use ISO_C_BINDING IMPLICIT NONE type ( EBSDMasterNameListType ), INTENT ( INOUT ) :: emnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 6 , n_real = 1 integer ( kind = irg ) :: io_int ( n_int ), restart , uniform real ( kind = sgl ) :: io_real ( n_real ) character ( 20 ) :: intlist ( n_int ), reallist ( n_real ) character ( fnlen ) :: dataset , namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'EBSDmastervars' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! write all the single integers if ( emnl % restart . eqv .. TRUE .) then restart = 1 else restart = 0 end if if ( emnl % uniform . eqv .. TRUE .) then uniform = 1 else uniform = 0 end if io_int = ( / emnl % stdout , emnl % npx , emnl % Esel , emnl % nthreads , restart , uniform / ) intlist ( 1 ) = 'stdout' intlist ( 2 ) = 'npx' intlist ( 3 ) = 'Esel' intlist ( 4 ) = 'nthreads' intlist ( 5 ) = 'restart' intlist ( 6 ) = 'uniform' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) ! write a single real dataset = 'dmin' call json_add ( inp , dataset , dble ( emnl % dmin )); call JSON_failtest ( error_cnt ) ! write all the strings dataset = 'outname' call json_add ( inp , dataset , emnl % outname ); call JSON_failtest ( error_cnt ) dataset = 'energyfile' call json_add ( inp , dataset , emnl % energyfile ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwriteEBSDMasterNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONwriteEBSDclusterNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief write namelist to JSON file ! !> @param emnl EBSD cluster name list structure !> @param jsonname output file name !> @param error_cnt total number of errors encountered by json routines ! !> @date 12/28/15 MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSONwriteEBSDclusterNameList ( emnl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwriteEBSDclusterNameList use ISO_C_BINDING IMPLICIT NONE type ( EBSDclusterNameListType ), INTENT ( INOUT ) :: emnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 3 , n_real = 1 integer ( kind = irg ) :: io_int ( n_int ) real ( kind = sgl ) :: io_real ( n_real ) character ( 20 ) :: intlist ( n_int ), reallist ( n_real ) character ( fnlen ) :: dataset , namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'EBSDclustervars' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! write all the single integers io_int = ( / emnl % NClusters , emnl % NIterations , emnl % binfactor / ) intlist ( 1 ) = 'NClusters' intlist ( 2 ) = 'NIterations' intlist ( 3 ) = 'binfactor' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) ! write all the strings dataset = 'inputfilename' call json_add ( inp , dataset , emnl % inputfilename ); call JSON_failtest ( error_cnt ) dataset = 'groupname' call json_add ( inp , dataset , emnl % groupname ); call JSON_failtest ( error_cnt ) dataset = 'datasetname' call json_add ( inp , dataset , emnl % datasetname ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwriteEBSDclusterNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONwriteECPMasterNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief write namelist to JSON file ! !> @param ecpnl ECP master name list structure !> @param jsonname output file name !> @param error_cnt total number of errors encountered by json routines ! !> @date 08/12/15 MDG 1.0 new routine !> @date 09/15/15 SS  1.1 changes after clean up of ECPmasterListType !-------------------------------------------------------------------------- recursive subroutine JSONwriteECPMasterNameList ( ecpnl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwriteECPMasterNameList use ISO_C_BINDING IMPLICIT NONE type ( ECPMasterNameListType ), INTENT ( INOUT ) :: ecpnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 4 , n_real = 1 integer ( kind = irg ) :: io_int ( n_int ) real ( kind = dbl ) :: io_real ( n_real ) character ( 20 ) :: intlist ( n_int ), reallist ( n_real ) character ( fnlen ) :: dataset , namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'ECPmastervars' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! write all the single integers io_int = ( / ecpnl % stdout , ecpnl % Esel , ecpnl % npx , ecpnl % nthreads / ) intlist ( 1 ) = 'stdout' intlist ( 2 ) = 'Esel' intlist ( 3 ) = 'npx' intlist ( 4 ) = 'nthreads' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) !dataset = 'distort' !call json_add(inp, dataset, ecpnl%distort); call JSON_failtest(error_cnt) ! integer vectors !dataset = 'fn' !call json_add(inp, dataset, dble(ecpnl%fn)); call JSON_failtest(error_cnt) ! write all the single doubles io_real = ( / ecpnl % dmin / ) reallist ( 1 ) = 'dmin' !reallist(2) = 'startthick' call JSON_writeNMLdoubles ( inp , io_real , reallist , n_real , error_cnt ) ! 3-vectors (real) !dataset = 'abcdist' !call json_add(inp, dataset, dble(ecpnl%abcdist)); call JSON_failtest(error_cnt) !dataset = 'albegadist' !call json_add(inp, dataset, dble(ecpnl%albegadist)); call JSON_failtest(error_cnt) ! write all the strings dataset = 'outname' call json_add ( inp , dataset , ecpnl % outname ); call JSON_failtest ( error_cnt ) dataset = 'energyfile' call json_add ( inp , dataset , ecpnl % energyfile ); call JSON_failtest ( error_cnt ) dataset = 'compmode' call json_add ( inp , dataset , ecpnl % compmode ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwriteECPMasterNameList ! !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONwriteEBSDNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief write namelist to JSON file ! !> @param enl EBSD name list structure !> @param jsonname output file name !> @param error_cnt total number of errors encountered by json routines ! !> @date 08/12/15 MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSONwriteEBSDNameList ( enl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwriteEBSDNameList use ISO_C_BINDING IMPLICIT NONE type ( EBSDNameListType ), INTENT ( INOUT ) :: enl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 6 , n_real = 9 integer ( kind = irg ) :: io_int ( n_int ) real ( kind = sgl ) :: io_real ( n_real ) real ( kind = dbl ) :: t ( 1 ) character ( 20 ) :: intlist ( n_int ), reallist ( n_real ) character ( fnlen ) :: dataset , namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'EBSDdata' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! write all the single integers io_int = ( / enl % stdout , enl % numsx , enl % numsy , enl % binning , enl % nthreads , enl % energyaverage / ) intlist ( 1 ) = 'stdout' intlist ( 2 ) = 'numsx' intlist ( 3 ) = 'numsy' intlist ( 4 ) = 'binning' intlist ( 5 ) = 'nthreads' intlist ( 6 ) = 'energyaverage' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) ! write all the single reals io_real = ( / enl % L , enl % thetac , enl % delta , enl % xpc , enl % ypc , enl % energymin , enl % energymax , enl % gammavalue , enl % alphaBD / ) reallist ( 1 ) = 'L' reallist ( 2 ) = 'thetac' reallist ( 3 ) = 'delta' reallist ( 4 ) = 'xpc' reallist ( 5 ) = 'ypc' reallist ( 6 ) = 'energymin' reallist ( 7 ) = 'energymax' reallist ( 8 ) = 'gammavalue' reallist ( 9 ) = 'alphaBD' call JSON_writeNMLreals ( inp , io_real , reallist , n_real , error_cnt ) ! a 4-vector dataset = 'axisangle' call json_add ( inp , dataset , dble ( enl % axisangle )); call JSON_failtest ( error_cnt ) ! a few doubles dataset = 'beamcurrent' call json_add ( inp , dataset , enl % beamcurrent ); call JSON_failtest ( error_cnt ) dataset = 'dwelltime' call json_add ( inp , dataset , enl % dwelltime ); call JSON_failtest ( error_cnt ) ! write all the strings dataset = 'maskpattern' call json_add ( inp , dataset , enl % maskpattern ); call JSON_failtest ( error_cnt ) dataset = 'scalingmode' call json_add ( inp , dataset , enl % scalingmode ); call JSON_failtest ( error_cnt ) dataset = 'eulerconvention' call json_add ( inp , dataset , enl % eulerconvention ); call JSON_failtest ( error_cnt ) dataset = 'outputformat' call json_add ( inp , dataset , enl % outputformat ); call JSON_failtest ( error_cnt ) dataset = 'energyfile' call json_add ( inp , dataset , enl % energyfile ); call JSON_failtest ( error_cnt ) dataset = 'masterfile' call json_add ( inp , dataset , enl % masterfile ); call JSON_failtest ( error_cnt ) dataset = 'anglefile' call json_add ( inp , dataset , enl % anglefile ); call JSON_failtest ( error_cnt ) dataset = 'datafile' call json_add ( inp , dataset , enl % datafile ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwriteEBSDNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONwriteECPNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief write namelist to JSON file ! !> @param ecpnl ECP namelist structure !> @param jsonname output file name !> @param error_cnt total number of errors encountered by json routines ! !> @date 08/12/15 MDG 1.0 new routine !> @date 09/15/15 SS  1.1 changes after modification of ECPListType !> @date 10/15/15 SS  1.2 changes for release !-------------------------------------------------------------------------- recursive subroutine JSONwriteECPNameList ( ecpnl , jsonname , error_cnt , twolayerflag ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwriteECPNameList use ISO_C_BINDING use error IMPLICIT NONE type ( ECPNameListType ), INTENT ( INOUT ) :: ecpnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt logical , INTENT ( IN ) :: twolayerflag type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 2 integer ( kind = irg ) :: n_real , istat integer ( kind = irg ) :: io_int ( n_int ) real ( kind = sgl ), allocatable :: io_real (:) character ( 20 ), allocatable :: reallist (:) character ( 20 ) :: intlist ( n_int ) character ( fnlen ) :: dataset , namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'ECPlist' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! write all the single integers io_int = ( / ecpnl % nthreads , ecpnl % npix / ) intlist ( 1 ) = 'nthreads' intlist ( 2 ) = 'npix' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) if ( twolayerflag ) then ! integer vectors dataset = 'fn_f' call json_add ( inp , dataset , ecpnl % fn_f ); call JSON_failtest ( error_cnt ) dataset = 'fn_s' call json_add ( inp , dataset , ecpnl % fn_s ); call JSON_failtest ( error_cnt ) dataset = 'gF' call json_add ( inp , dataset , ecpnl % gF ); call JSON_failtest ( error_cnt ) dataset = 'gS' call json_add ( inp , dataset , ecpnl % gS ); call JSON_failtest ( error_cnt ) dataset = 'tF' call json_add ( inp , dataset , ecpnl % tF ); call JSON_failtest ( error_cnt ) dataset = 'tS' call json_add ( inp , dataset , ecpnl % tS ); call JSON_failtest ( error_cnt ) n_real = 8 allocate ( reallist ( n_real ), io_real ( n_real ), stat = istat ) if ( istat . ne . 0 ) then call FatalError ( 'HDFwriteECPNameList' , 'Cannot allocate the reallist array' ) end if ! write all the single reals io_real = ( / ecpnl % dmin , ecpnl % thetac , sngl ( ecpnl % sampletilt ), ecpnl % workingdistance , & ecpnl % filmthickness , ecpnl % gammavalue , ecpnl % Rin , ecpnl % Rout / ) reallist ( 1 ) = 'dmin' reallist ( 2 ) = 'thetac' reallist ( 3 ) = 'sampletilt' reallist ( 4 ) = 'workingdistance' reallist ( 5 ) = 'filmthickness' reallist ( 6 ) = 'gammavalue' reallist ( 7 ) = 'Rin' reallist ( 8 ) = 'Rout' call JSON_writeNMLreals ( inp , io_real , reallist , n_real , error_cnt ) else n_real = 6 allocate ( reallist ( n_real ), io_real ( n_real ), stat = istat ) if ( istat . ne . 0 ) then call FatalError ( 'HDFwriteECPNameList' , 'Cannot allocate the reallist array' ) end if ! write all the single reals io_real = ( / ecpnl % thetac , sngl ( ecpnl % sampletilt ), & ecpnl % gammavalue , ecpnl % workingdistance , ecpnl % Rin , ecpnl % Rout / ) reallist ( 1 ) = 'thetac' reallist ( 2 ) = 'sampletilt' reallist ( 3 ) = 'gammavalue' reallist ( 4 ) = 'workingdistance' reallist ( 5 ) = 'Rin' reallist ( 6 ) = 'Rout' call JSON_writeNMLreals ( inp , io_real , reallist , n_real , error_cnt ) end if ! write all the strings dataset = 'energyfile' call json_add ( inp , dataset , ecpnl % energyfile ); call JSON_failtest ( error_cnt ) dataset = 'masterfile' call json_add ( inp , dataset , ecpnl % masterfile ); call JSON_failtest ( error_cnt ) dataset = 'datafile' call json_add ( inp , dataset , ecpnl % datafile ); call JSON_failtest ( error_cnt ) dataset = 'xtalname' call json_add ( inp , dataset , ecpnl % xtalname ); call JSON_failtest ( error_cnt ) if ( twolayerflag ) then dataset = 'xtalname2' call json_add ( inp , dataset , ecpnl % xtalname2 ); call JSON_failtest ( error_cnt ) dataset = 'filmfile' call json_add ( inp , dataset , ecpnl % filmfile ); call JSON_failtest ( error_cnt ) dataset = 'subsfile' call json_add ( inp , dataset , ecpnl % subsfile ); call JSON_failtest ( error_cnt ) end if dataset = 'maskpattern' call json_add ( inp , dataset , ecpnl % maskpattern ); call JSON_failtest ( error_cnt ) dataset = 'anglefile' call json_add ( inp , dataset , ecpnl % anglefile ); call JSON_failtest ( error_cnt ) dataset = 'outputformat' call json_add ( inp , dataset , ecpnl % outputformat ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwriteECPNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONwriteLACBEDNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief write namelist to JSON file ! !> @param lacbednl LACBED name list structure !> @param jsonname output file name !> @param error_cnt total number of errors encountered by json routines ! !> @date 08/12/15 MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSONwriteLACBEDNameList ( lacbednl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwriteLACBEDNameList use ISO_C_BINDING IMPLICIT NONE type ( LACBEDNameListType ), INTENT ( INOUT ) :: lacbednl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 5 , n_real = 6 integer ( kind = irg ) :: io_int ( n_int ) real ( kind = sgl ) :: io_real ( n_real ) character ( 20 ) :: intlist ( n_int ), reallist ( n_real ) character ( fnlen ) :: dataset , namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'inputlist' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! write all the single integers io_int = ( / lacbednl % stdout , lacbednl % maxHOLZ , lacbednl % numthick , lacbednl % npix , lacbednl % nthreads / ) intlist ( 1 ) = 'stdout' intlist ( 2 ) = 'maxHOLZ' intlist ( 3 ) = 'numthick' intlist ( 4 ) = 'npix' intlist ( 5 ) = 'nthreads' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) ! vectors dataset = 'k' call json_add ( inp , dataset , lacbednl % k ); call JSON_failtest ( error_cnt ) dataset = 'fn' call json_add ( inp , dataset , lacbednl % fn ); call JSON_failtest ( error_cnt ) ! write all the single reals io_real = ( / lacbednl % voltage , lacbednl % dmin , lacbednl % convergence , lacbednl % startthick , lacbednl % thickinc , lacbednl % minten / ) reallist ( 1 ) = 'voltage' reallist ( 2 ) = 'dmin' reallist ( 3 ) = 'convergence' reallist ( 4 ) = 'startthick' reallist ( 5 ) = 'thickinc' reallist ( 6 ) = 'minten' call JSON_writeNMLreals ( inp , io_real , reallist , n_real , error_cnt ) ! write all the strings dataset = 'outname' call json_add ( inp , dataset , lacbednl % outname ); call JSON_failtest ( error_cnt ) dataset = 'xtalname' call json_add ( inp , dataset , lacbednl % xtalname ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwriteLACBEDNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONwriteECPpatternNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief write namelist into JSON file ! !> @param ecpnl ECP name list structure !> @param jsonname output file name !> @param error_cnt total number of errors encountered by json routines ! !> @date 08/12/15 MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSONwriteECPpatternNameList ( ecpnl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwriteECPpatternNameList use ISO_C_BINDING IMPLICIT NONE type ( ECPpatternNameListType ), INTENT ( INOUT ) :: ecpnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 2 , n_real = 6 integer ( kind = irg ) :: io_int ( n_int ) real ( kind = sgl ) :: io_real ( n_real ) character ( 20 ) :: intlist ( n_int ), reallist ( n_real ) character ( fnlen ) :: dataset , namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'ECPvars' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! write all the single integers io_int = ( / ecpnl % stdout , ecpnl % npix / ) intlist ( 1 ) = 'stdout' intlist ( 2 ) = 'npix' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) ! single real dataset = 'thetac' call json_add ( inp , dataset , dble ( ecpnl % thetac )); call JSON_failtest ( error_cnt ) ! real vector dataset = 'k' call json_add ( inp , dataset , dble ( ecpnl % k )); call JSON_failtest ( error_cnt ) ! write all the strings dataset = 'outname' call json_add ( inp , dataset , ecpnl % outname ); call JSON_failtest ( error_cnt ) dataset = 'masterfile' call json_add ( inp , dataset , ecpnl % masterfile ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwriteECPpatternNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONwritePEDkinNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief write namelist to JSON file ! !> @param pednl PED name list structure !> @param jsonname output file name !> @param error_cnt total number of errors encountered by json routines ! !> @date 08/12/15 MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSONwritePEDkinNameList ( pednl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwritePEDkinNameList use ISO_C_BINDING IMPLICIT NONE type ( PEDkinNameListType ), INTENT ( INOUT ) :: pednl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 4 , n_real = 4 integer ( kind = irg ) :: io_int ( n_int ) real ( kind = sgl ) :: io_real ( n_real ) character ( 20 ) :: intlist ( n_int ), reallist ( n_real ) character ( fnlen ) :: dataset , namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'PEDkinNameList' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! write all the single integers io_int = ( / pednl % stdout , pednl % npix , pednl % ncubochoric , pednl % nthreads / ) intlist ( 1 ) = 'stdout' intlist ( 2 ) = 'npix' intlist ( 3 ) = 'ncubochoric' intlist ( 4 ) = 'nthreads' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) ! write all the single reals io_real = ( / pednl % voltage , pednl % thickness , pednl % dmin , pednl % rnmpp / ) reallist ( 1 ) = 'voltage' reallist ( 2 ) = 'thickness' reallist ( 3 ) = 'dmin' reallist ( 4 ) = 'rnmpp' call JSON_writeNMLreals ( inp , io_real , reallist , n_real , error_cnt ) ! write all the strings dataset = 'outname' call json_add ( inp , dataset , pednl % outname ); call JSON_failtest ( error_cnt ) dataset = 'xtalname' call json_add ( inp , dataset , pednl % xtalname ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwritePEDkinNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONwritePEDZANameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief write namelist to JSON file ! !> @param pednl PED name list structure !> @param jsonname output file name !> @param error_cnt total number of errors encountered by json routines ! !> @date 08/12/15 MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSONwritePEDZANameList ( pednl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwritePEDZANameList use ISO_C_BINDING IMPLICIT NONE type ( PEDZANameListType ), INTENT ( INOUT ) :: pednl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 5 , n_real = 6 integer ( kind = irg ) :: io_int ( n_int ) real ( kind = sgl ) :: io_real ( n_real ) character ( 20 ) :: intlist ( n_int ), reallist ( n_real ) character ( fnlen ) :: dataset , namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'EMPEDZA' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! write all the single integers io_int = ( / pednl % stdout , pednl % precsample , pednl % precazimuthal , pednl % npix , pednl % nthreads / ) intlist ( 1 ) = 'stdout' intlist ( 2 ) = 'precsample' intlist ( 3 ) = 'precazimuthal' intlist ( 4 ) = 'npix' intlist ( 5 ) = 'nthreads' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) ! vectors dataset = 'k' call json_add ( inp , dataset , pednl % k ); call JSON_failtest ( error_cnt ) dataset = 'fn' call json_add ( inp , dataset , pednl % fn ); call JSON_failtest ( error_cnt ) ! single reals io_real = ( / pednl % voltage , pednl % dmin , pednl % precangle , pednl % prechalfwidth , pednl % thickness , pednl % camlen / ) reallist ( 1 ) = 'voltage' reallist ( 2 ) = 'dmin' reallist ( 3 ) = 'precangle' reallist ( 4 ) = 'prechalfwidth' reallist ( 5 ) = 'thickness' reallist ( 6 ) = 'camlen' call JSON_writeNMLreals ( inp , io_real , reallist , n_real , error_cnt ) ! write all the strings dataset = 'outname' call json_add ( inp , dataset , pednl % outname ); call JSON_failtest ( error_cnt ) dataset = 'xtalname' call json_add ( inp , dataset , pednl % xtalname ); call JSON_failtest ( error_cnt ) dataset = 'filemode' call json_add ( inp , dataset , pednl % filemode ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwritePEDZANameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONwriteECCINameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief write namelist to JSON file ! !> @param eccinl ECCI name list structure !> @param jsonname output file name !> @param error_cnt total number of errors encountered by json routines ! !> @date 08/12/15 MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSONwriteECCINameList ( eccinl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwriteECCINameList use ISO_C_BINDING IMPLICIT NONE type ( ECCINameListType ), INTENT ( INOUT ) :: eccinl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 5 , n_real = 6 integer ( kind = irg ) :: io_int ( n_int ) real ( kind = sgl ) :: io_real ( n_real ) character ( 20 ) :: intlist ( n_int ), reallist ( n_real ) integer ( kind = irg ) :: i character ( fnlen ) :: dataset , namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'ECCIlist' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! write all the single integers io_int = ( / eccinl % stdout , eccinl % nthreads , eccinl % nktstep , eccinl % DF_npix , eccinl % DF_npiy / ) intlist ( 1 ) = 'stdout' intlist ( 2 ) = 'nthreads' intlist ( 3 ) = 'nktstep' intlist ( 4 ) = 'DF_npix' intlist ( 5 ) = 'DF_npiy' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) ! vectors dataset = 'k' call json_add ( inp , dataset , eccinl % k ); call JSON_failtest ( error_cnt ) ! single reals io_real = ( / eccinl % voltage , eccinl % dkt , eccinl % ktmax , eccinl % dmin , eccinl % DF_L , eccinl % DF_slice / ) reallist ( 1 ) = 'voltage' reallist ( 2 ) = 'dkt' reallist ( 3 ) = 'ktmax' reallist ( 4 ) = 'dmin' reallist ( 5 ) = 'DF_L' reallist ( 6 ) = 'DF_slice' call JSON_writeNMLreals ( inp , io_real , reallist , n_real , error_cnt ) ! 2-vectors dataset = 'lauec' call json_add ( inp , dataset , dble ( eccinl % lauec )); call JSON_failtest ( error_cnt ) dataset = 'lauec2' call json_add ( inp , dataset , dble ( eccinl % lauec2 )); call JSON_failtest ( error_cnt ) ! write all the strings dataset = 'dispmode' call json_add ( inp , dataset , eccinl % dispmode ); call JSON_failtest ( error_cnt ) dataset = 'summode' call json_add ( inp , dataset , eccinl % summode ); call JSON_failtest ( error_cnt ) dataset = 'progmode' call json_add ( inp , dataset , eccinl % progmode ); call JSON_failtest ( error_cnt ) dataset = 'xtalname' call json_add ( inp , dataset , eccinl % xtalname ); call JSON_failtest ( error_cnt ) dataset = 'defectfilename' call json_add ( inp , dataset , eccinl % defectfilename ); call JSON_failtest ( error_cnt ) dataset = 'dispfile' call json_add ( inp , dataset , eccinl % dispfile ); call JSON_failtest ( error_cnt ) dataset = 'dataname' call json_add ( inp , dataset , eccinl % dataname ); call JSON_failtest ( error_cnt ) dataset = 'ECPname' call json_add ( inp , dataset , eccinl % ECPname ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwriteECCINameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONwriteRFZNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief write namelist to an JSON file ! !> @param rfznl RFZ name list structure !> @param jsonname output file name !> @param error_cnt total number of errors encountered by json routines ! !> @date 08/12/15 MDG 1.0 new routine !> @date 08/18/15 MDG 1.1 added other rotation representations !-------------------------------------------------------------------------- recursive subroutine JSONwriteRFZNameList ( rfznl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwriteRFZNameList use ISO_C_BINDING IMPLICIT NONE type ( RFZNameListType ), INTENT ( INOUT ) :: rfznl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 3 , n_real = 1 integer ( kind = irg ) :: io_int ( n_int ) real ( kind = sgl ) :: io_real ( n_real ) character ( 20 ) :: intlist ( n_int ), reallist ( n_real ) integer ( kind = irg ) :: i character ( fnlen ) :: dataset , namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'RFZlist' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! write all the single integers io_int = ( / rfznl % pgnum , rfznl % nsteps , rfznl % gridtype / ) intlist ( 1 ) = 'pgnum' intlist ( 2 ) = 'nsteps' intlist ( 3 ) = 'gridtype' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) ! strings dataset = 'euoutname' call json_add ( inp , dataset , rfznl % euoutname ); call JSON_failtest ( error_cnt ) dataset = 'cuoutname' call json_add ( inp , dataset , rfznl % cuoutname ); call JSON_failtest ( error_cnt ) dataset = 'hooutname' call json_add ( inp , dataset , rfznl % hooutname ); call JSON_failtest ( error_cnt ) dataset = 'quoutname' call json_add ( inp , dataset , rfznl % quoutname ); call JSON_failtest ( error_cnt ) dataset = 'rooutname' call json_add ( inp , dataset , rfznl % rooutname ); call JSON_failtest ( error_cnt ) dataset = 'omoutname' call json_add ( inp , dataset , rfznl % omoutname ); call JSON_failtest ( error_cnt ) dataset = 'axoutname' call json_add ( inp , dataset , rfznl % axoutname ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwriteRFZNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONwriteDictIndxOpenCLNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief write namelist to JSON file ! !> @param rfznl RFZ name list structure !> @param jsonname output file name !> @param error_cnt total number of errors encountered by json routines ! !> @date 08/12/15 MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSONwriteDictIndxOpenCLNameList ( dictindxnl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwriteDictIndxOpenCLNameList use ISO_C_BINDING use local IMPLICIT NONE type ( DictIndxOpenCLListType ), INTENT ( INOUT ) :: dictindxnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 7 , n_real = 1 integer ( kind = irg ) :: io_int ( n_int ) real ( kind = sgl ) :: io_real ( n_real ) character ( 20 ) :: intlist ( n_int ), reallist ( n_real ) integer ( kind = irg ) :: i character ( fnlen ) :: dataset , namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'DictIndxOpenCLvars' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! write all the single integers io_int = ( / dictindxnl % numexptsingle , dictindxnl % numdictsingle , dictindxnl % totnumdict , dictindxnl % totnumexpt , dictindxnl % imght , & dictindxnl % imgwd , dictindxnl % nnk / ) intlist ( 1 ) = 'numexptsingle' intlist ( 2 ) = 'numdictsingle' intlist ( 3 ) = 'totnumdict' intlist ( 4 ) = 'totnumexpt' intlist ( 5 ) = 'imght' intlist ( 6 ) = 'imgwd' intlist ( 7 ) = 'nnk' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) dataset = 'MeanSubtraction' call json_add ( inp , dataset , dictindxnl % MeanSubtraction ); call JSON_failtest ( error_cnt ) ! strings dataset = 'exptfile' call json_add ( inp , dataset , dictindxnl % exptfile ); call JSON_failtest ( error_cnt ) dataset = 'dictfile' call json_add ( inp , dataset , dictindxnl % dictfile ); call JSON_failtest ( error_cnt ) dataset = 'eulerfile' call json_add ( inp , dataset , dictindxnl % eulerfile ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwriteDictIndxOpenCLNameList !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- ! here we have the json->namelist conversion routines for all the ! namelists defined in the NameListTypedefs.f90 file. ! ! To convert a json file to a namelist, we first initialize the namelist ! to the default values, to make sure that any omissions in the json file ! are intercepted.  To do so, we call the NameListHandler routines with ! the \"initonly\" optional keyword. !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONreadInteger ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read integer from json file into namelist structure (with auto missing detection) ! !> @param json structure !> @param ep entry path string !> @param ival integer variable !> @param dval integer variable (default value) ! !> @date 08/12/15  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSONreadInteger ( json , ep , ival , dval ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadInteger use ISO_C_BINDING use io IMPLICIT NONE type ( json_file ), INTENT ( INOUT ) :: json character ( fnlen ), INTENT ( IN ) :: ep integer ( kind = irg ), INTENT ( INOUT ) :: ival integer ( kind = irg ), INTENT ( IN ) :: dval logical :: found ! if we find the field 'ep' in the file, then we read its corresponding value ! if it is not there, then we return the dval default value call json % get ( ep , ival , found ) if (. not . found ) then write ( error_unit , '(A)' ) 'WARNING: field ' // trim ( ep ) // ' not found in json file; using default value from namelist template' ival = dval end if end subroutine JSONreadInteger !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONreadIntegerVec ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read integer vector from json file into namelist structure (with auto missing detection) ! !> @param json structure !> @param ep entry path string !> @param ival integer vector variable !> @param dval integer vector variable (default value) ! !> @date 08/12/15  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSONreadIntegerVec ( json , ep , ivec , dvec , n ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadIntegerVec use ISO_C_BINDING use io IMPLICIT NONE type ( json_file ), INTENT ( INOUT ) :: json character ( fnlen ), INTENT ( IN ) :: ep integer ( kind = irg ), INTENT ( INOUT ) :: ivec ( n ) integer ( kind = irg ), INTENT ( IN ) :: dvec ( n ) integer ( kind = irg ), INTENT ( IN ) :: n logical :: found integer ( kind = irg ), dimension (:), allocatable :: rv ! if we find the field 'ep' in the file, then we read its corresponding value ! if it is not there, then we return the dval default value call json % get ( ep , rv , found ) if (. not . found ) then write ( error_unit , '(A)' ) 'WARNING: field ' // trim ( ep ) // ' not found in json file; using default value from namelist template' ivec = dvec else ivec = rv end if end subroutine JSONreadIntegerVec !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONreadReal ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read single precision real from json file into namelist structure (with auto missing detection) ! !> @param json structure !> @param ep entry path string !> @param rval real variable !> @param dval real variable (default value) ! !> @date 08/12/15  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSONreadReal ( json , ep , rval , dval ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadReal use ISO_C_BINDING use io IMPLICIT NONE type ( json_file ), INTENT ( INOUT ) :: json character ( fnlen ), INTENT ( IN ) :: ep real ( kind = sgl ), INTENT ( INOUT ) :: rval real ( kind = sgl ), INTENT ( IN ) :: dval logical :: found real ( kind = dbl ) :: rv ! if we find the field 'ep' in the file, then we read its corresponding value ! if it is not there, then we return the dval default value call json % get ( ep , rv , found ) if (. not . found ) then write ( error_unit , '(A)' ) 'WARNING: field ' // trim ( ep ) // ' not found in json file; using default value from namelist template' rval = dval else rval = sngl ( rv ) end if end subroutine JSONreadReal !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONreadRealVec ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read single precision real vector from json file into namelist structure (with auto missing detection) ! !> @param json structure !> @param ep entry path string !> @param rval real vector variable !> @param dval real vector variable (default value) ! !> @date 08/12/15  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSONreadRealVec ( json , ep , rvec , dvec , n ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadRealVec use ISO_C_BINDING use io IMPLICIT NONE type ( json_file ), INTENT ( INOUT ) :: json character ( fnlen ), INTENT ( IN ) :: ep real ( kind = sgl ), INTENT ( INOUT ) :: rvec ( n ) real ( kind = sgl ), INTENT ( IN ) :: dvec ( n ) integer ( kind = irg ), INTENT ( IN ) :: n logical :: found real ( kind = dbl ), dimension (:), allocatable :: rv ! if we find the field 'ep' in the file, then we read its corresponding value ! if it is not there, then we return the dvec default value call json % get ( ep , rv , found ) if (. not . found ) then write ( error_unit , '(A)' ) 'WARNING: field ' // trim ( ep ) // ' not found in json file; using default value from namelist template' rvec = dvec else rvec = sngl ( rv ) end if end subroutine JSONreadRealVec !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONreadDouble ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read double precision real from json file into namelist structure (with auto missing detection) ! !> @param json structure !> @param ep entry path string !> @param rval real variable !> @param dval real variable (default value) ! !> @date 08/12/15  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSONreadDouble ( json , ep , rval , dval ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadDouble use ISO_C_BINDING use io IMPLICIT NONE type ( json_file ), INTENT ( INOUT ) :: json character ( fnlen ), INTENT ( IN ) :: ep real ( kind = dbl ), INTENT ( INOUT ) :: rval real ( kind = dbl ), INTENT ( IN ) :: dval logical :: found real ( kind = dbl ) :: rv ! if we find the field 'ep' in the file, then we read its corresponding value ! if it is not there, then we return the dval default value call json % get ( ep , rv , found ) if (. not . found ) then write ( error_unit , '(A)' ) 'WARNING: field ' // trim ( ep ) // ' not found in json file; using default value from namelist template' rval = dval else rval = rv end if end subroutine JSONreadDouble !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONreadDoubleVec ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read double precision real vector from json file into namelist structure (with auto missing detection) ! !> @param json structure !> @param ep entry path string !> @param rval real vector variable !> @param dval real vector variable (default value) ! !> @date 08/12/15  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSONreadDoubleVec ( json , ep , rvec , dvec , n ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadDoubleVec use ISO_C_BINDING use io IMPLICIT NONE type ( json_file ), INTENT ( INOUT ) :: json character ( fnlen ), INTENT ( IN ) :: ep real ( kind = dbl ), INTENT ( INOUT ) :: rvec ( n ) real ( kind = dbl ), INTENT ( IN ) :: dvec ( n ) integer ( kind = irg ), INTENT ( IN ) :: n logical :: found real ( kind = dbl ), dimension (:), allocatable :: rv ! if we find the field 'ep' in the file, then we read its corresponding value ! if it is not there, then we return the dvec default value call json % get ( ep , rv , found ) if (. not . found ) then write ( error_unit , '(A)' ) 'WARNING: field ' // trim ( ep ) // ' not found in json file; using default value from namelist template' rvec = dvec else rvec = rv end if end subroutine JSONreadDoubleVec !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONreadString ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read string from json file into namelist structure (with auto missing detection) ! !> @param json structure !> @param ep entry path string !> @param sval string !> @param dval string (default value) ! !> @date 08/12/15  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSONreadString ( json , ep , sval , dval ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadString use ISO_C_BINDING use io IMPLICIT NONE type ( json_file ), INTENT ( INOUT ) :: json character ( fnlen ), INTENT ( IN ) :: ep character ( fnlen ), INTENT ( INOUT ) :: sval character ( fnlen ), INTENT ( IN ) :: dval logical :: found character ( kind = jsonCK , len = :), allocatable :: cval ! if we find the field 'ep' in the file, then we read its corresponding value ! if it is not there, then we return the dval default value call json % get ( ep , cval , found ) if (. not . found ) then write ( error_unit , '(A)' ) 'WARNING: field ' // trim ( ep ) // ' not found in json file; using default value from namelist template' sval = dval else sval = trim ( cval ) end if end subroutine JSONreadString !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONreadLogical ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read logical from json file into namelist structure (with auto missing detection) ! !> @param json structure !> @param ep entry path string !> @param sval logical !> @param dval logical (default value) ! !> @date 08/20/15  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSONreadLogical ( json , ep , sval , dval ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadLogical use ISO_C_BINDING use io IMPLICIT NONE type ( json_file ), INTENT ( INOUT ) :: json character ( fnlen ), INTENT ( IN ) :: ep logical , INTENT ( INOUT ) :: sval logical , INTENT ( IN ) :: dval logical :: found , cval ! if we find the field 'ep' in the file, then we read its corresponding value ! if it is not there, then we return the dval default value call json % get ( ep , cval , found ) if (. not . found ) then write ( error_unit , '(A)' ) 'WARNING: field ' // trim ( ep ) // ' not found in json file; using default value from namelist template' sval = dval else sval = cval end if end subroutine JSONreadLogical !-------------------------------------------------------------------------- ! ! FUNCTION:JSONgetDouble ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief get vector from a json_value ! !> @param child json_value structure !> @param str text with variable name !> @param v verbose if 1 ! !> @date 11/21/15  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive function JSONgetDouble ( child , str , v ) result ( oval ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONgetDouble use io use , intrinsic :: iso_fortran_env , only : wp => real64 IMPLICIT NONE type ( json_value ), pointer , INTENT ( IN ) :: child character ( fnlen ) :: str integer ( kind = irg ), INTENT ( IN ) :: v real ( kind = dbl ) :: oval real ( kind = wp ) :: val real ( kind = sgl ) :: io_real ( 1 ) call json_get ( child , val ) if ( v . eq . 1 ) then io_real ( 1 ) = val call WriteValue ( str , io_real , 1 ) end if oval = val end function JSONgetDouble !-------------------------------------------------------------------------- ! ! FUNCTION:JSONgetDoubleVector ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief get vector from a json_value ! !> @param child json_value structure !> @param nc number of items to read !> @param str text with variable name !> @param v verbose if 1 ! !> @date 11/21/15  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive function JSONgetDoubleVector ( child , nc , str , v ) result ( ovec ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONgetDoubleVector use io use , intrinsic :: iso_fortran_env , only : wp => real64 IMPLICIT NONE type ( json_value ), pointer , INTENT ( IN ) :: child integer ( kind = irg ), INTENT ( IN ) :: nc character ( fnlen ) :: str integer ( kind = irg ), INTENT ( IN ) :: v real ( kind = dbl ) :: ovec ( nc ) real ( kind = wp ), dimension (:), allocatable :: vec real ( kind = sgl ) :: io_real ( nc ) allocate ( vec ( nc )) call json_get ( child , vec ) if ( v . eq . 1 ) then io_real ( 1 : nc ) = vec ( 1 : nc ) call WriteValue ( str , io_real , nc ) end if ovec ( 1 : nc ) = vec ( 1 : nc ) deallocate ( vec ) end function JSONgetDoubleVector !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONreadFoilData ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief parse json foil file into defect namelist structures ! !> @param cell unit cell pointer !> @param defects defect structure, to be filled by this routine !> @param error_cnt total number of errors encountered by json routines !> @param verbose [optional] print a lot of output if present and true ! !> @date 11/21/15  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSONreadFoilData ( cell , defects , error_cnt , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadFoilData use ISO_C_BINDING use NameListHandlers use io use error use crystal use , intrinsic :: iso_fortran_env , only : wp => real64 IMPLICIT NONE type ( unitcell ), pointer , INTENT ( IN ) :: cell type ( defecttype ), INTENT ( INOUT ) :: defects integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt logical , INTENT ( IN ), OPTIONAL :: verbose type ( json_value ), pointer :: jval , child , child2 , child3 type ( json_value ), pointer :: tmp_json_ptr character ( kind = jsonCK , len = :), allocatable :: name integer ( kind = irg ) :: v , i , j , jj , vart , nc , nc2 , nc3 , io_int ( 3 ) real ( kind = wp ), dimension (:), allocatable :: vec3 real ( kind = wp ) :: val real ( kind = sgl ) :: io_real ( 6 ), x logical :: found character ( 4 ), parameter :: row ( 6 ) = ( / 'row1' , 'row2' , 'row3' , 'row4' , 'row5' , 'row6' / ) character ( fnlen ) :: str , filename v = 0 if ( PRESENT ( verbose )) then if ( verbose ) then v = 1 end if end if ! set the default values for all entries defects % foil % elmo = 0.0 ! elastic moduli defects % foil % F = ( / 0.0 , 0.0 , 1.0 / ) ! foil normal in direct space Bravais reference frame defects % foil % q = ( / 1.0 , 0.0 , 0.0 / ) ! reciprocal space vector along primary tilt axis towards airlock defects % foil % alP = 0.0 ! primary tilt angle in degrees defects % foil % alS = 0.0 ! secondary tilt angle (for double tilt holder) defects % foil % alR = 0.0 ! secondary tilt angle (for rotation tilt holder) defects % foil % beP = 0.0 ! angle of primary tilt axis w.r.t. image bottom edge defects % foil % z0 = 10 0.0 ! foil thickness in nm ! the following are not used currently, but need to be initialized properly defects % foil % brx = 0.0 ! parameters to describe the foil shape as a quadratic surface defects % foil % bry = 0.0 defects % foil % brxy = 0.0 defects % foil % cpx = 0.0 ! center of the foil quadratic surface within [-1,1] range in pixel coordinates defects % foil % cpy = 0.0 filename = trim ( EMsoft_getEMdatapathname ()) // trim ( defects % foilname ) filename = EMsoft_toNativePath ( filename ) ! json has alrady been initialized, so we should be ok directly reading the data from the file call json_parse ( trim ( filename ), jval ) if ( json_failed (). eqv .. TRUE .) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else call json_info ( jval , vart , nc , name ) ! jval name = filename ! loop over the children (only 1) do i = 1 , nc call json_get_child ( jval , i , child ) call json_info ( child , vart , nc2 , name ) ! child name = FoilDescriptor nc2loop : do j = 1 , nc2 call json_get_child ( child , j , child2 ) call json_info ( child2 , vart , nc3 , name ) ! foil normal if ( name . eq . 'foilF' ) then str = '   Foil normal F = ' defects % foil % F = JSONgetDoubleVector ( child2 , nc3 , str , v ) end if ! foil q vector if ( name . eq . 'foilq' ) then str = '   Foil q-vector = ' defects % foil % q = JSONgetDoubleVector ( child2 , nc3 , str , v ) end if ! foil alP tilt if ( name . eq . 'foilalP' ) then str = '   Foil alP tilt = ' defects % foil % alP = JSONgetDouble ( child2 , str , v ) end if ! foil alS tilt if ( name . eq . 'foilalS' ) then str = '   Foil alS tilt = ' defects % foil % alS = JSONgetDouble ( child2 , str , v ) end if ! foil alR tilt if ( name . eq . 'foilalR' ) then str = '   Foil alR tilt = ' defects % foil % alR = JSONgetDouble ( child2 , str , v ) end if ! foil thickness if ( name . eq . 'foilz0' ) then str = '   Foil thickness = ' defects % foil % z0 = JSONgetDouble ( child2 , str , v ) end if ! foil shape parameters if ( name . eq . 'brx' ) then str = '   shape brx = ' defects % foil % brx = JSONgetDouble ( child2 , str , v ) end if ! foil shape parameters if ( name . eq . 'bry' ) then str = '   shape bry = ' defects % foil % bry = JSONgetDouble ( child2 , str , v ) end if ! foil shape parameters if ( name . eq . 'brxy' ) then str = '   shape brxy = ' defects % foil % brxy = JSONgetDouble ( child2 , str , v ) end if ! foil shape parameters if ( name . eq . 'cpx' ) then str = '   shape cpx = ' defects % foil % cpx = JSONgetDouble ( child2 , str , v ) end if ! foil shape parameters if ( name . eq . 'cpy' ) then str = '   shape cpy = ' defects % foil % cpy = JSONgetDouble ( child2 , str , v ) end if ! foil elastic modulus tensor  (6x6 format) if ( name . eq . 'foilelmo' ) then str = '' do jj = 1 , 6 call json_get_child ( child2 , jj , child3 ) call json_info ( child3 , vart , nc3 , name ) if ( name . eq . row ( jj )) defects % foil % elmo ( jj , 1 : 6 ) = JSONgetDoubleVector ( child3 , nc3 , str , 0 ) end do if ( v . eq . 1 ) then call WriteValue ( '   Elastic moduli tensor (Voigt notation)' , '' ) do jj = 1 , 6 io_real ( 1 : 6 ) = defects % foil % elmo ( jj , 1 : 6 ) call WriteValue ( '' , io_real , 6 ) end do end if end if end do nc2loop end do end if call JSON_failtest ( error_cnt ) ! verify that the foil normal (in real space) and q (in reciprocal space) are orthogonal ! in other words, we do a cartesian dot product... x = CalcDot ( cell , defects % foil % F , defects % foil % q , 'c' ) if ( abs ( x ). gt . 0.005 ) then call Message ( 'Foil normal F must be orthogonal to q' , frm = \"(A)\" ) !  stop end if end subroutine JSONreadFoilData !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONreadDefectFile ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief parse json file into defect namelist structures ! !> @param cell unit cell pointer !> @param jsonname input file name !> @param defects defect structure, to be filled by this routine !> @param error_cnt total number of errors encountered by json routines !> @param verbose [optional] print a lot of output if present and true ! !> @date 11/20/15 MDG 1.0 new routine !> @date 12/08/15 MDG 1.1 added Einclusion defect type !-------------------------------------------------------------------------- recursive subroutine JSONreadDefectFile ( cell , jsonname , defects , error_cnt , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadDefectFile use ISO_C_BINDING use NameListHandlers use io use error use , intrinsic :: iso_fortran_env , only : wp => real64 IMPLICIT NONE type ( unitcell ), pointer , INTENT ( IN ) :: cell character ( fnlen ), INTENT ( IN ) :: jsonname type ( defecttype ), INTENT ( INOUT ) :: defects integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt logical , INTENT ( IN ), OPTIONAL :: verbose type ( json_file ) :: json !the JSON structure read from the file: type ( json_value ), pointer :: jval , child , child2 , child3 , child4 character ( kind = jsonCK , len = :), allocatable :: name integer ( kind = irg ) :: i , j , jj , kk , v , io_int ( 3 ), jskip , ndis integer ( kind = irg ) :: vart , nc , nc2 , nc3 , nc4 , nc5 logical :: found character ( fnlen ) :: foilfilename , str , filename , dummystr real ( wp ) :: v4 ( 4 ), v5 ( 5 ), v6 ( 6 ), v9 ( 9 ), io_real ( 6 ) v = 0 if ( PRESENT ( verbose )) then if ( verbose ) then v = 1 end if end if dummystr = '' ! first of all, initialize json and return an error message if it does not exist error_cnt = 0 call json_initialize (); call JSON_failtest ( error_cnt ) filename = trim ( EMsoft_getEMdatapathname ()) // trim ( jsonname ) filename = EMsoft_toNativePath ( filename ) ! populate the jval json_value structure call json_parse ( trim ( filename ), jval ) if ( json_failed (). eqv .. TRUE .) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! get the top level file descriptor (should be the file name) and the number of its children nc (should really be 1) call json_info ( jval , vart , nc , name ) ! jval name = filename if ( v . eq . 1 ) then call WriteValue ( ' Defect file name : ' , name , \"(' ',A)\" ) end if ! loop over the children do i = 1 , nc call json_get_child ( jval , i , child ) call json_info ( child , vart , nc2 , name ) ! child name = DefectDescriptors ! loop over those children, which are the actual defect descriptors and deal with each of them separately ! the foil date must be the first entry; if it is not, then loop until we find it found = . FALSE . nc2loop : do j = 1 , nc2 call json_get_child ( child , j , child2 ) call json_info ( child2 , vart , nc3 , name ) if (. not .( name . eq . 'foil' )) CYCLE nc2loop ! name = foil, so read the name of the foil descriptor file call json_get ( child2 , 'foilfilename' , child3 , found ) jskip = j if ( found ) then call json_get ( child3 , name ) if ( v . eq . 1 ) call WriteValue ( ' Foil file name = ' , trim ( name ), \"(' ',A)\" ) defects % foilname = trim ( name ) end if end do nc2loop if (. not . found ) then call FatalError ( 'JSONreadDefectFile' , 'JSON file does not contain a foilfilename entry' ) end if ! here we call the foil reading routine to first fill all the foil parameters call JSONreadFoilData ( cell , defects , error_cnt , verbose ) ! then we need to get the total number of defects in the file, so that we can allocate ! the correct array sizes in the defects structure ndis = 0 nc2loop2 : do j = 1 , nc2 if ( j . eq . jskip ) CYCLE nc2loop2 call json_get_child ( child , j , child2 ) call json_info ( child2 , vart , nc3 , name ) if ( name . eq . 'voids' ) then allocate ( defects % voids ( nc3 )) defects % numvoids = nc3 end if if ( name . eq . 'inclusions' ) then allocate ( defects % inclusions ( nc3 )) defects % numinc = nc3 end if if ( name . eq . 'Einclusions' ) then allocate ( defects % Einclusions ( nc3 )) defects % numEinc = nc3 end if if ( name . eq . 'Ydislocations' ) then allocate ( defects % YD ( nc3 )) defects % numYdisl = nc3 end if if ( name . eq . 'dislocations' ) then ndis = ndis + nc3 defects % numdisl = nc3 end if if ( name . eq . 'stackingfaults' ) then allocate ( defects % SF ( nc3 )) ndis = ndis + 2 * nc3 defects % numsf = nc3 end if end do nc2loop2 if ( ndis . gt . 0 ) allocate ( defects % DL ( ndis )) ! now loop over all entries at the child level (Except for the foil data) and ! read the individual defect parameters; note that these are nested on level 4... ndis = 1 nc2loop3 : do j = 1 , nc2 if ( j . eq . jskip ) CYCLE nc2loop3 call json_get_child ( child , j , child2 ) call json_info ( child2 , vart , nc3 , name ) ! dislocations if ( name . eq . 'dislocations' ) then do jj = 1 , nc3 if ( v . eq . 1 ) then io_int ( 1 ) = jj call WriteValue ( '   dislocation #  ' , io_int , 1 , \"(I4)\" ) end if call json_get_child ( child2 , jj , child3 ) call json_info ( child3 , vart , nc4 , name ) do kk = 1 , nc4 call json_get_child ( child3 , kk , child4 ) call json_info ( child4 , vart , nc5 , name ) if ( name . eq . 'id' ) then str = '        x-coordinate  = ' defects % DL ( ndis )% id = JSONgetDouble ( child4 , str , v ) end if if ( name . eq . 'jd' ) then str = '        y-coordinate  = ' defects % DL ( ndis )% jd = JSONgetDouble ( child4 , str , v ) end if if ( name . eq . 'zfrac' ) then str = '        zfrac         = ' defects % DL ( ndis )% zfrac = JSONgetDouble ( child4 , str , v ) end if if ( name . eq . 'u' ) then str = '        u             = ' defects % DL ( ndis )% u = JSONgetDoubleVector ( child4 , nc5 , str , v ) end if if ( name . eq . 'bv' ) then str = '        bv            = ' defects % DL ( ndis )% burg = JSONgetDoubleVector ( child4 , nc5 , str , v ) end if end do ndis = ndis + 1 end do CYCLE nc2loop3 end if ! Ydislocations if ( name . eq . 'Ydislocations' ) then do jj = 1 , nc3 if ( v . eq . 1 ) then io_int ( 1 ) = jj call WriteValue ( '   Ydislocation #  ' , io_int , 1 , \"(I4)\" ) end if call json_get_child ( child2 , jj , child3 ) call json_info ( child3 , vart , nc4 , name ) do kk = 1 , nc4 call json_get_child ( child3 , kk , child4 ) call json_info ( child4 , vart , nc5 , name ) if ( name . eq . 'id' ) then str = '        x-coordinate  = ' defects % YD ( jj )% id = JSONgetDouble ( child4 , str , v ) end if if ( name . eq . 'jd' ) then str = '        y-coordinate  = ' defects % YD ( jj )% jd = JSONgetDouble ( child4 , str , v ) end if if ( name . eq . 'poisson' ) then str = '        poisson       = ' defects % YD ( jj )% sig = JSONgetDouble ( child4 , str , v ) end if if ( name . eq . 'u' ) then str = '        u             = ' defects % YD ( jj )% u = JSONgetDoubleVector ( child4 , nc5 , str , v ) end if if ( name . eq . 'bv' ) then str = '        bv            = ' defects % YD ( jj )% burg = JSONgetDoubleVector ( child4 , nc5 , str , v ) end if end do end do CYCLE nc2loop3 end if ! stacking faults if ( name . eq . 'stackingfaults' ) then do jj = 1 , nc3 if ( v . eq . 1 ) then io_int ( 1 ) = jj call WriteValue ( '   Stacking Fault #  ' , io_int , 1 , \"(I4)\" ) end if call json_get_child ( child2 , jj , child3 ) call json_info ( child3 , vart , nc4 , name ) do kk = 1 , nc4 call json_get_child ( child3 , kk , child4 ) call json_info ( child4 , vart , nc5 , name ) if ( name . eq . 'SFi' ) then str = '        x-coordinate  = ' defects % SF ( jj )% id = JSONgetDouble ( child4 , str , v ) end if if ( name . eq . 'SFj' ) then str = '        y-coordinate  = ' defects % SF ( jj )% jd = JSONgetDouble ( child4 , str , v ) end if if ( name . eq . 'SFsep' ) then str = '        SF separation = ' defects % SF ( jj )% sep = JSONgetDouble ( child4 , str , v ) end if if ( name . eq . 'SFplane' ) then str = '        SF plane      = ' defects % SF ( jj )% plane = JSONgetDoubleVector ( child4 , nc5 , str , v ) end if if ( name . eq . 'SFlpu' ) then str = '        SF lpu        = ' defects % SF ( jj )% lpu = JSONgetDoubleVector ( child4 , nc5 , str , v ) end if if ( name . eq . 'SFtpu' ) then str = '        SF tpu        = ' defects % SF ( jj )% tpu = JSONgetDoubleVector ( child4 , nc5 , str , v ) end if if ( name . eq . 'SFlpb' ) then str = '        SF lpb        = ' defects % SF ( jj )% lpb = JSONgetDoubleVector ( child4 , nc5 , str , v ) end if if ( name . eq . 'SFtpb' ) then str = '        SF tpb        = ' defects % SF ( jj )% tpb = JSONgetDoubleVector ( child4 , nc5 , str , v ) end if end do end do CYCLE nc2loop3 end if ! voids if ( name . eq . 'voids' ) then do jj = 1 , nc3 call json_get_child ( child2 , jj , child3 ) call json_info ( child3 , vart , nc4 , name ) v4 = JSONgetDoubleVector ( child3 , nc4 , dummystr , 0 ) defects % voids ( jj )% xpos = v4 ( 1 ) defects % voids ( jj )% ypos = v4 ( 2 ) defects % voids ( jj )% zpos = v4 ( 3 ) defects % voids ( jj )% radius = v4 ( 4 ) if ( v . eq . 1 ) then io_real ( 1 : 4 ) = v4 ( 1 : 4 ) io_int ( 1 ) = jj call WriteValue ( ' void   ' , io_int , 1 , \"(I4,$)\" ) call WriteValue ( '' , io_real , 4 ) end if end do CYCLE nc2loop3 end if ! inclusions if ( name . eq . 'inclusions' ) then do jj = 1 , nc3 call json_get_child ( child2 , jj , child3 ) call json_info ( child3 , vart , nc4 , name ) v5 = JSONgetDoubleVector ( child3 , nc4 , dummystr , 0 ) defects % inclusions ( jj )% xpos = v5 ( 1 ) defects % inclusions ( jj )% ypos = v5 ( 2 ) defects % inclusions ( jj )% zpos = v5 ( 3 ) defects % inclusions ( jj )% radius = v5 ( 4 ) defects % inclusions ( jj )% C = v5 ( 5 ) if ( v . eq . 1 ) then io_real ( 1 : 5 ) = v5 ( 1 : 5 ) io_int ( 1 ) = jj call WriteValue ( ' inclusion    ' , io_int , 1 , \"(I4,$)\" ) call WriteValue ( '' , io_real , 5 ) end if end do CYCLE nc2loop3 end if ! Eshelby ellipsoidal inclusions (isotropic) if ( name . eq . 'Einclusions' ) then do jj = 1 , nc3 if ( v . eq . 1 ) then io_int ( 1 ) = jj call WriteValue ( '   Einclusion   #  ' , io_int , 1 , \"(I4)\" ) end if call json_get_child ( child2 , jj , child3 ) call json_info ( child3 , vart , nc4 , name ) do kk = 1 , nc4 call json_get_child ( child3 , kk , child4 ) call json_info ( child4 , vart , nc5 , name ) if ( name . eq . 'xyz' ) then str = '        xyz           = ' defects % Einclusions ( jj )% xyz = JSONgetDoubleVector ( child4 , nc5 , str , v ) end if if ( name . eq . 'a123' ) then str = '        a123          = ' defects % Einclusions ( jj )% a123 = JSONgetDoubleVector ( child4 , nc5 , str , v ) end if if ( name . eq . 'nu' ) then str = '        nu            = ' defects % Einclusions ( jj )% nu = JSONgetDouble ( child4 , str , v ) end if if ( name . eq . 'epsstarvoigt' ) then str = '        eps* (Voigt)  = ' v6 = JSONgetDoubleVector ( child4 , nc5 , str , v ) defects % Einclusions ( jj )% epsstar ( 1 , 1 ) = v6 ( 1 ) defects % Einclusions ( jj )% epsstar ( 2 , 2 ) = v6 ( 2 ) defects % Einclusions ( jj )% epsstar ( 3 , 3 ) = v6 ( 3 ) defects % Einclusions ( jj )% epsstar ( 1 , 2 ) = v6 ( 6 ) * 0.5D0 defects % Einclusions ( jj )% epsstar ( 2 , 1 ) = v6 ( 6 ) * 0.5D0 defects % Einclusions ( jj )% epsstar ( 1 , 3 ) = v6 ( 5 ) * 0.5D0 defects % Einclusions ( jj )% epsstar ( 3 , 1 ) = v6 ( 5 ) * 0.5D0 defects % Einclusions ( jj )% epsstar ( 2 , 3 ) = v6 ( 4 ) * 0.5D0 defects % Einclusions ( jj )% epsstar ( 3 , 2 ) = v6 ( 4 ) * 0.5D0 end if if ( name . eq . 'principalaxes' ) then str = '        principalaxes = ' v9 = JSONgetDoubleVector ( child4 , nc5 , str , v ) defects % Einclusions ( jj )% principalaxes ( 1 , 1 : 3 ) = v9 ( 1 : 3 ) defects % Einclusions ( jj )% principalaxes ( 2 , 1 : 3 ) = v9 ( 4 : 6 ) defects % Einclusions ( jj )% principalaxes ( 3 , 1 : 3 ) = v9 ( 7 : 9 ) end if end do end do CYCLE nc2loop3 end if ! other defct types to be added here end do nc2loop3 end do end if call JSON_failtest ( error_cnt ) end subroutine JSONreadDefectFile !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONreadKosselNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read json file into namelist structure ! !> @param knl Kossel name list structure !> @param jsonname input file name !> @param error_cnt total number of errors encountered by json routines ! !> @date 08/12/15  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSONreadKosselNameList ( knl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadKosselNameList use ISO_C_BINDING use NameListHandlers IMPLICIT NONE type ( KosselNameListType ), INTENT ( INOUT ) :: knl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_file ) :: json !the JSON structure read from the file: type ( KosselNameListType ) :: defknl logical :: init = . TRUE . character ( fnlen ) :: nmlfile = '' , ep real ( kind = wp ) :: rval character ( kind = jsonCK , len = :), allocatable :: cval real ( wp ), dimension (:), allocatable :: rvec ! first of all, open the file and return an error message if it does not exist error_cnt = 0 call json_initialize (); call JSON_failtest ( error_cnt ) ! populate the json structure call json % load_file ( filename = trim ( jsonname )) if ( json_failed (). eqv .. TRUE .) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! ok, we got here so we need to initialize the namelist first to its default values (set in NameListHandlers) call GetKosselNameList ( nmlfile , defknl , initonly = init ) ! then we start reading the values in the json file ep = 'Kossellist.stdout' call JSONreadInteger ( json , ep , knl % stdout , defknl % stdout ) ep = 'Kossellist.numthick' call JSONreadInteger ( json , ep , knl % numthick , defknl % numthick ) ep = 'Kossellist.npix' call JSONreadInteger ( json , ep , knl % npix , defknl % npix ) ep = 'Kossellist.maxHOLZ' call JSONreadInteger ( json , ep , knl % maxHOLZ , defknl % maxHOLZ ) ep = 'Kossellist.nthreads' call JSONreadInteger ( json , ep , knl % nthreads , defknl % nthreads ) ep = 'Kossellist.k' call JSONreadIntegerVec ( json , ep , knl % k , defknl % k , size ( knl % k )) ep = 'Kossellist.fn' call JSONreadIntegerVec ( json , ep , knl % fn , defknl % fn , size ( knl % fn )) ep = 'Kossellist.voltage' call JSONreadReal ( json , ep , knl % voltage , defknl % voltage ) ep = 'Kossellist.dmin' call JSONreadReal ( json , ep , knl % dmin , defknl % dmin ) ep = 'Kossellist.convergence' call JSONreadReal ( json , ep , knl % convergence , defknl % convergence ) ep = 'Kossellist.startthick' call JSONreadReal ( json , ep , knl % startthick , defknl % startthick ) ep = 'Kossellist.thickinc' call JSONreadReal ( json , ep , knl % thickinc , defknl % thickinc ) ep = 'Kossellist.minten' call JSONreadReal ( json , ep , knl % minten , defknl % minten ) ep = 'Kossellist.xtalname' call JSONreadString ( json , ep , knl % xtalname , defknl % xtalname ) ep = 'Kossellist.outname' call JSONreadString ( json , ep , knl % outname , defknl % outname ) end if call json % destroy (); call JSON_failtest ( error_cnt ) end subroutine JSONreadKosselNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONreadKosselMasterNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read json file and fill knl structure (used by EMKosselmaster.f90) ! !> @param knl Kossel name list structure !> @param jsonname input file name !> @param error_cnt total number of errors encountered by json routines ! !> @date 08/19/15  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSONreadKosselMasterNameList ( knl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadKosselMasterNameList use ISO_C_BINDING use NameListHandlers IMPLICIT NONE type ( KosselMasterNameListType ), INTENT ( INOUT ) :: knl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_file ) :: json !the JSON structure read from the file: type ( KosselMasterNameListType ) :: defknl logical :: init = . TRUE . character ( fnlen ) :: nmlfile = '' , ep , s , s2 real ( kind = wp ) :: rval character ( kind = jsonCK , len = :), allocatable :: cval real ( wp ), dimension (:), allocatable :: rvec ! first of all, open the file and return an error message if it does not exist error_cnt = 0 call json_initialize (); call JSON_failtest ( error_cnt ) ! populate the json structure call json % load_file ( filename = trim ( jsonname )) if ( json_failed (). eqv .. TRUE .) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! ok, we got here so we need to initialize the namelist first to its default values (set in NameListHandlers) call GetKosselMasterNameList ( nmlfile , defknl , initonly = init ) ! then we start reading the values in the json file ep = 'Kosselmasterlist.stdout' call JSONreadInteger ( json , ep , knl % stdout , defknl % stdout ) ep = 'Kosselmasterlist.numthick' call JSONreadInteger ( json , ep , knl % numthick , defknl % numthick ) ep = 'Kosselmasterlist.npix' call JSONreadInteger ( json , ep , knl % npx , defknl % npx ) ep = 'Kosselmasterlist.nthreads' call JSONreadInteger ( json , ep , knl % nthreads , defknl % nthreads ) ep = 'Kosselmasterlist.voltage' call JSONreadReal ( json , ep , knl % voltage , defknl % voltage ) ep = 'Kosselmasterlist.dmin' call JSONreadReal ( json , ep , knl % dmin , defknl % dmin ) ep = 'Kosselmasterlist.startthick' call JSONreadReal ( json , ep , knl % startthick , defknl % startthick ) ep = 'Kosselmasterlist.thickinc' call JSONreadReal ( json , ep , knl % thickinc , defknl % thickinc ) ep = 'Kosselmasterlist.tfraction' call JSONreadReal ( json , ep , knl % tfraction , defknl % tfraction ) ep = 'Kosselmasterlist.Kosselmode' s = knl % Kosselmode s2 = defknl % Kosselmode call JSONreadString ( json , ep , s , s2 ) ep = 'Kosselmasterlist.xtalname' call JSONreadString ( json , ep , knl % xtalname , defknl % xtalname ) ep = 'Kosselmasterlist.outname' call JSONreadString ( json , ep , knl % outname , defknl % outname ) end if call json % destroy (); call JSON_failtest ( error_cnt ) end subroutine JSONreadKosselMasterNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONreadreflectorNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read json file and fill mcnl structure (used by EMMC.f90) ! !> @param mcnl Monte Carloname list structure !> @param jsonname input file name !> @param error_cnt total number of errors encountered by json routines ! !> @date 08/19/15  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSONreadreflectorNameList ( rnl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadreflectorNameList use ISO_C_BINDING use NameListHandlers IMPLICIT NONE type ( reflectorNameListType ), INTENT ( INOUT ) :: rnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_file ) :: json !the JSON structure read from the file: type ( reflectorNameListType ) :: defrnl logical :: init = . TRUE . character ( fnlen ) :: nmlfile = '' , ep , s , s2 real ( kind = wp ) :: rval character ( kind = jsonCK , len = :), allocatable :: cval real ( wp ), dimension (:), allocatable :: rvec ! first of all, open the file and return an error message if it does not exist error_cnt = 0 call json_initialize (); call JSON_failtest ( error_cnt ) ! populate the json structure call json % load_file ( filename = trim ( jsonname )) if ( json_failed (). eqv .. TRUE .) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! ok, we got here so we need to initialize the namelist first to its default values (set in NameListHandlers) call GetreflectorNameList ( nmlfile , defrnl , initonly = init ) ! then we start reading the values in the json file ep = 'EBSDreflectors.numphi' call JSONreadInteger ( json , ep , rnl % numphi , defrnl % numphi ) ep = 'EBSDreflectors.numtheta' call JSONreadInteger ( json , ep , rnl % numtheta , defrnl % numtheta ) ep = 'EBSDreflectors.dmin' call JSONreadReal ( json , ep , rnl % dmin , defrnl % dmin ) ep = 'EBSDreflectors.masterfile' call JSONreadString ( json , ep , rnl % masterfile , defrnl % masterfile ) ep = 'EBSDreflectors.energyfile' call JSONreadString ( json , ep , rnl % energyfile , defrnl % energyfile ) end if call json % destroy (); call JSON_failtest ( error_cnt ) end subroutine JSONreadreflectorNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONreadMCNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read json file and fill mcnl structure (used by EMMC.f90) ! !> @param mcnl Monte Carloname list structure !> @param jsonname input file name !> @param error_cnt total number of errors encountered by json routines ! !> @date 08/19/15  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSONreadMCNameList ( mcnl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadMCNameList use ISO_C_BINDING use NameListHandlers IMPLICIT NONE type ( MCNameListType ), INTENT ( INOUT ) :: mcnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_file ) :: json !the JSON structure read from the file: type ( MCNameListType ) :: defmcnl logical :: init = . TRUE . character ( fnlen ) :: nmlfile = '' , ep , s , s2 real ( kind = wp ) :: rval character ( kind = jsonCK , len = :), allocatable :: cval real ( wp ), dimension (:), allocatable :: rvec ! first of all, open the file and return an error message if it does not exist error_cnt = 0 call json_initialize (); call JSON_failtest ( error_cnt ) ! populate the json structure call json % load_file ( filename = trim ( jsonname )) if ( json_failed (). eqv .. TRUE .) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! ok, we got here so we need to initialize the namelist first to its default values (set in NameListHandlers) call GetMCNameList ( nmlfile , defmcnl , initonly = init ) ! then we start reading the values in the json file ep = 'MCdata.stdout' call JSONreadInteger ( json , ep , mcnl % stdout , defmcnl % stdout ) ep = 'MCdata.numsx' call JSONreadInteger ( json , ep , mcnl % numsx , defmcnl % numsx ) ep = 'MCdata.num_el' call JSONreadInteger ( json , ep , mcnl % num_el , defmcnl % num_el ) ep = 'MCdata.primeseeds' call JSONreadInteger ( json , ep , mcnl % primeseed , defmcnl % primeseed ) ep = 'MCdata.nthreads' call JSONreadInteger ( json , ep , mcnl % nthreads , defmcnl % nthreads ) ep = 'MCdata.sig' call JSONreadDouble ( json , ep , mcnl % sig , defmcnl % sig ) ep = 'MCdata.omega' call JSONreadDouble ( json , ep , mcnl % omega , defmcnl % omega ) ep = 'MCdata.EkeV' call JSONreadDouble ( json , ep , mcnl % EkeV , defmcnl % EkeV ) ep = 'MCdata.Ehistmin' call JSONreadDouble ( json , ep , mcnl % Ehistmin , defmcnl % Ehistmin ) ep = 'MCdata.Ebinsize' call JSONreadDouble ( json , ep , mcnl % Ebinsize , defmcnl % Ebinsize ) ep = 'MCdata.depthmax' call JSONreadDouble ( json , ep , mcnl % depthmax , defmcnl % depthmax ) ep = 'MCdata.depthstep' call JSONreadDouble ( json , ep , mcnl % depthstep , defmcnl % depthstep ) ep = 'MCdata.MCmode' s = mcnl % MCmode s2 = defmcnl % MCmode call JSONreadString ( json , ep , s , s2 ) ep = 'MCdata.xtalname' call JSONreadString ( json , ep , mcnl % xtalname , defmcnl % xtalname ) ep = 'MCdata.dataname' call JSONreadString ( json , ep , mcnl % dataname , defmcnl % dataname ) end if call json % destroy (); call JSON_failtest ( error_cnt ) end subroutine JSONreadMCNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONreadMCCLNameList ! !> @author Saransh Singh/Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill mcnl structure (used by EMMCCL.f90) ! !> @param mcnl Monte Carlo name list structure !> @param jsonname input file name !> @param error_cnt total number of errors encountered by json routines ! !> @date 08/19/15  MDG 1.0 new routine !> @date 09/09/15  MDG 1.1 added devid !-------------------------------------------------------------------------- recursive subroutine JSONreadMCCLNameList ( mcnl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadMCCLNameList use ISO_C_BINDING use NameListHandlers IMPLICIT NONE type ( MCCLNameListType ), INTENT ( INOUT ) :: mcnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_file ) :: json !the JSON structure read from the file: type ( MCCLNameListType ) :: defmcnl logical :: init = . TRUE . character ( fnlen ) :: nmlfile = '' , ep , s , s2 real ( kind = wp ) :: rval character ( kind = jsonCK , len = :), allocatable :: cval real ( wp ), dimension (:), allocatable :: rvec ! first of all, open the file and return an error message if it does not exist error_cnt = 0 call json_initialize (); call JSON_failtest ( error_cnt ) ! populate the json structure call json % load_file ( filename = trim ( jsonname )) if ( json_failed (). eqv .. TRUE .) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! ok, we got here so we need to initialize the namelist first to its default values (set in NameListHandlers) call GetMCCLNameList ( nmlfile , defmcnl , initonly = init ) ! then we start reading the values in the json file ep = 'MCCLdata.stdout' call JSONreadInteger ( json , ep , mcnl % stdout , defmcnl % stdout ) ep = 'MCCLdata.numsx' call JSONreadInteger ( json , ep , mcnl % numsx , defmcnl % numsx ) ep = 'MCCLdata.globalworkgrpsz' call JSONreadInteger ( json , ep , mcnl % globalworkgrpsz , defmcnl % globalworkgrpsz ) ep = 'MCCLdata.num_el' call JSONreadInteger ( json , ep , mcnl % num_el , defmcnl % num_el ) ep = 'MCCLdata.totnum_el' call JSONreadInteger ( json , ep , mcnl % totnum_el , defmcnl % totnum_el ) ep = 'MCCLdata.multiplier' call JSONreadInteger ( json , ep , mcnl % multiplier , defmcnl % multiplier ) ep = 'MCCLdata.devid' call JSONreadInteger ( json , ep , mcnl % devid , defmcnl % devid ) ep = 'MCCLdata.platid' call JSONreadInteger ( json , ep , mcnl % platid , defmcnl % platid ) ep = 'MCCLdata.sigstart' call JSONreadDouble ( json , ep , mcnl % sigstart , defmcnl % sigstart ) ep = 'MCCLdata.sigend' call JSONreadDouble ( json , ep , mcnl % sigend , defmcnl % sigend ) ep = 'MCCLdata.sigstep' call JSONreadDouble ( json , ep , mcnl % sigstep , defmcnl % sigstep ) ep = 'MCCLdata.omega' call JSONreadDouble ( json , ep , mcnl % omega , defmcnl % omega ) ep = 'MCCLdata.EkeV' call JSONreadDouble ( json , ep , mcnl % EkeV , defmcnl % EkeV ) ep = 'MCCLdata.Ehistmin' call JSONreadDouble ( json , ep , mcnl % Ehistmin , defmcnl % Ehistmin ) ep = 'MCCLdata.Ebinsize' call JSONreadDouble ( json , ep , mcnl % Ebinsize , defmcnl % Ebinsize ) ep = 'MCCLdata.depthmax' call JSONreadDouble ( json , ep , mcnl % depthmax , defmcnl % depthmax ) ep = 'MCCLdata.depthstep' call JSONreadDouble ( json , ep , mcnl % depthstep , defmcnl % depthstep ) ep = 'MCCLdata.MCmode' s = mcnl % MCmode s2 = defmcnl % MCmode call JSONreadString ( json , ep , s , s2 ) ep = 'MCCLdata.xtalname' call JSONreadString ( json , ep , mcnl % xtalname , defmcnl % xtalname ) ep = 'MCCLdata.dataname' call JSONreadString ( json , ep , mcnl % dataname , defmcnl % dataname ) ep = 'MCCLdata.mode' call JSONreadString ( json , ep , mcnl % mode , defmcnl % mode ) end if call json % destroy (); call JSON_failtest ( error_cnt ) end subroutine JSONreadMCCLNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONreadMCCLMultiLayerNameList ! !> @author Saransh Singh/Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill mcnl structure (used by EMMCCL.f90) ! !> @param mcnl Monte Carloname list structure !> @param jsonname input file name !> @param error_cnt total number of errors encountered by json routines ! !> @date 08/19/15  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSONreadMCCLMultiLayerNameList ( mcnl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadMCCLMultiLayerNameList use ISO_C_BINDING use NameListHandlers IMPLICIT NONE type ( MCCLMultiLayerNameListType ), INTENT ( INOUT ) :: mcnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_file ) :: json !the JSON structure read from the file: type ( MCCLMultiLayerNameListType ) :: defmcnl logical :: init = . TRUE . character ( fnlen ) :: nmlfile = '' , ep , s , s2 real ( kind = wp ) :: rval character ( kind = jsonCK , len = :), allocatable :: cval real ( wp ), dimension (:), allocatable :: rvec ! first of all, open the file and return an error message if it does not exist error_cnt = 0 call json_initialize (); call JSON_failtest ( error_cnt ) ! populate the json structure call json % load_file ( filename = trim ( jsonname )) if ( json_failed (). eqv .. TRUE .) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! ok, we got here so we need to initialize the namelist first to its default values (set in NameListHandlers) call GetMCCLMultiLayerNameList ( nmlfile , defmcnl , initonly = init ) ! then we start reading the values in the json file ep = 'MCCLdata.stdout' call JSONreadInteger ( json , ep , mcnl % stdout , defmcnl % stdout ) ep = 'MCCLdata.numsx' call JSONreadInteger ( json , ep , mcnl % numsx , defmcnl % numsx ) ep = 'MCCLdata.globalworkgrpsz' call JSONreadInteger ( json , ep , mcnl % globalworkgrpsz , defmcnl % globalworkgrpsz ) ep = 'MCCLdata.num_el' call JSONreadInteger ( json , ep , mcnl % num_el , defmcnl % num_el ) ep = 'MCCLdata.totnum_el' call JSONreadInteger ( json , ep , mcnl % totnum_el , defmcnl % totnum_el ) ep = 'MCCLdata.sig' call JSONreadDouble ( json , ep , mcnl % sig , defmcnl % sig ) ep = 'MCCLdata.omega' call JSONreadDouble ( json , ep , mcnl % omega , defmcnl % omega ) ep = 'MCCLdata.EkeV' call JSONreadDouble ( json , ep , mcnl % EkeV , defmcnl % EkeV ) ep = 'MCCLdata.Ehistmin' call JSONreadDouble ( json , ep , mcnl % Ehistmin , defmcnl % Ehistmin ) ep = 'MCCLdata.Ebinsize' call JSONreadDouble ( json , ep , mcnl % Ebinsize , defmcnl % Ebinsize ) ep = 'MCCLdata.depthmax' call JSONreadDouble ( json , ep , mcnl % depthmax , defmcnl % depthmax ) ep = 'MCCLdata.depthstep' call JSONreadDouble ( json , ep , mcnl % depthstep , defmcnl % depthstep ) ep = 'MCCLdata.filmthickness' call JSONreadDouble ( json , ep , mcnl % filmthickness , defmcnl % filmthickness ) ep = 'MCCLdata.filmstep' call JSONreadDouble ( json , ep , mcnl % filmstep , defmcnl % filmstep ) ep = 'MCCLdata.MCmode' s = mcnl % MCmode s2 = defmcnl % MCmode call JSONreadString ( json , ep , s , s2 ) ep = 'MCCLdata.xtalname_film' call JSONreadString ( json , ep , mcnl % xtalname_film , defmcnl % xtalname_film ) ep = 'MCCLdata.xtalname_subs' call JSONreadString ( json , ep , mcnl % xtalname_subs , defmcnl % xtalname_subs ) ep = 'MCCLdata.dataname' call JSONreadString ( json , ep , mcnl % dataname , defmcnl % dataname ) ep = 'MCCLdata.mode' call JSONreadString ( json , ep , mcnl % mode , defmcnl % mode ) end if call json % destroy (); call JSON_failtest ( error_cnt ) end subroutine JSONreadMCCLMultiLayerNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONreadEBSDMasterNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read json file and fill emnl structure (used by EMEBSDmaster.f90) ! !> @param emnl EBSD master name list structure !> @param jsonname input file name !> @param error_cnt total number of errors encountered by json routines ! !> @date 08/19/15  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSONreadEBSDMasterNameList ( emnl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadEBSDMasterNameList use ISO_C_BINDING use NameListHandlers IMPLICIT NONE type ( EBSDMasterNameListType ), INTENT ( INOUT ) :: emnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_file ) :: json !the JSON structure read from the file: type ( EBSDMasterNameListType ) :: defemnl logical :: init = . TRUE . character ( fnlen ) :: nmlfile = '' , ep , s , s2 real ( kind = wp ) :: rval character ( kind = jsonCK , len = :), allocatable :: cval real ( wp ), dimension (:), allocatable :: rvec ! first of all, open the file and return an error message if it does not exist error_cnt = 0 call json_initialize (); call JSON_failtest ( error_cnt ) ! populate the json structure call json % load_file ( filename = trim ( jsonname )) if ( json_failed (). eqv .. TRUE .) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! ok, we got here so we need to initialize the namelist first to its default values (set in NameListHandlers) call GetEBSDMasterNameList ( nmlfile , defemnl , initonly = init ) ! then we start reading the values in the json file ep = 'EBSDmastervars.stdout' call JSONreadInteger ( json , ep , emnl % stdout , defemnl % stdout ) ep = 'EBSDmastervars.npx' call JSONreadInteger ( json , ep , emnl % npx , defemnl % npx ) ep = 'EBSDmastervars.Esel' call JSONreadInteger ( json , ep , emnl % Esel , defemnl % Esel ) ep = 'EBSDmastervars.nthreads' call JSONreadInteger ( json , ep , emnl % nthreads , defemnl % nthreads ) ep = 'EBSDmastervars.dmin' call JSONreadReal ( json , ep , emnl % dmin , defemnl % dmin ) ep = 'EBSDmastervars.energyfile' call JSONreadString ( json , ep , emnl % energyfile , defemnl % energyfile ) ep = 'EBSDmastervars.outname' call JSONreadString ( json , ep , emnl % outname , defemnl % outname ) ep = 'EBSDmastervars.restart' call JSONreadLogical ( json , ep , emnl % restart , defemnl % restart ) end if call json % destroy (); call JSON_failtest ( error_cnt ) end subroutine JSONreadEBSDMasterNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONreadEBSDclusterNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read json file and fill emnl structure (used by EMEBSDcluster.f90) ! !> @param emnl EBSD cluster name list structure !> @param jsonname input file name !> @param error_cnt total number of errors encountered by json routines ! !> @date 12/28/15  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSONreadEBSDclusterNameList ( emnl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadEBSDclusterNameList use ISO_C_BINDING use NameListHandlers IMPLICIT NONE type ( EBSDclusterNameListType ), INTENT ( INOUT ) :: emnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_file ) :: json !the JSON structure read from the file: type ( EBSDclusterNameListType ) :: defemnl logical :: init = . TRUE . character ( fnlen ) :: nmlfile = '' , ep , s , s2 real ( kind = wp ) :: rval character ( kind = jsonCK , len = :), allocatable :: cval real ( wp ), dimension (:), allocatable :: rvec ! first of all, open the file and return an error message if it does not exist error_cnt = 0 call json_initialize (); call JSON_failtest ( error_cnt ) ! populate the json structure call json % load_file ( filename = trim ( jsonname )) if ( json_failed (). eqv .. TRUE .) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! ok, we got here so we need to initialize the namelist first to its default values (set in NameListHandlers) call GetEBSDclusterNameList ( nmlfile , defemnl , initonly = init ) ! then we start reading the values in the json file ep = 'EBSDclustervars.NClusters' call JSONreadInteger ( json , ep , emnl % NClusters , defemnl % NClusters ) ep = 'EBSDclustervars.NIterations' call JSONreadInteger ( json , ep , emnl % NIterations , defemnl % NIterations ) ep = 'EBSDclustervars.inputfilename' call JSONreadString ( json , ep , emnl % inputfilename , defemnl % inputfilename ) ep = 'EBSDclustervars.groupname' call JSONreadString ( json , ep , emnl % groupname , defemnl % groupname ) ep = 'EBSDclustervars.datasetname' call JSONreadString ( json , ep , emnl % datasetname , defemnl % datasetname ) end if call json % destroy (); call JSON_failtest ( error_cnt ) end subroutine JSONreadEBSDclusterNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONreadECPMasterNameList ! !> @author Saransh Singh/Marc De Graef, Carnegie Mellon University ! !> @brief read json file and fill mcnl structure (used by EMECPmaster.f90) ! !> @param emnl ECP master name list structure !> @param jsonname input file name !> @param error_cnt total number of errors encountered by json routines ! !> @date 08/20/15  MDG 1.0 new routine !> @date 09/15/15  SS  1.1 changes after clean up of ECPmasterListType !-------------------------------------------------------------------------- recursive subroutine JSONreadECPMasterNameList ( ecpnl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadECPMasterNameList use ISO_C_BINDING use NameListHandlers IMPLICIT NONE type ( ECPMasterNameListType ), INTENT ( INOUT ) :: ecpnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_file ) :: json !the JSON structure read from the file: type ( ECPMasterNameListType ) :: defecpnl logical :: init = . TRUE . character ( fnlen ) :: nmlfile = '' , ep , s , s2 real ( kind = wp ) :: rval character ( kind = jsonCK , len = :), allocatable :: cval real ( wp ), dimension (:), allocatable :: rvec ! first of all, open the file and return an error message if it does not exist error_cnt = 0 call json_initialize (); call JSON_failtest ( error_cnt ) ! populate the json structure call json % load_file ( filename = trim ( jsonname )) if ( json_failed (). eqv .. TRUE .) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! ok, we got here so we need to initialize the namelist first to its default values (set in NameListHandlers) call GetECPMasterNameList ( nmlfile , defecpnl , initonly = init ) ! then we start reading the values in the json file ep = 'ECPmastervars.stdout' call JSONreadInteger ( json , ep , ecpnl % stdout , defecpnl % stdout ) ep = 'ECPmastervars.npx' call JSONreadInteger ( json , ep , ecpnl % npx , defecpnl % npx ) ep = 'ECPmastervars.Esel' call JSONreadInteger ( json , ep , ecpnl % Esel , defecpnl % Esel ) ep = 'ECPmastervars.nthreads' call JSONreadInteger ( json , ep , ecpnl % nthreads , defecpnl % nthreads ) !ep = 'ECPmastervars.startthick' !call JSONreadReal(json, ep, ecpnl%startthick, defecpnl%startthick) ep = 'ECPmastervars.dmin' call JSONreadReal ( json , ep , ecpnl % dmin , defecpnl % dmin ) !ep = 'ECPmastervars.fn' !call JSONreadRealVec(json, ep, ecpnl%fn, defecpnl%fn, size(ecpnl%fn)) !ep = 'ECPmastervars.abcdist' !call JSONreadRealVec(json, ep, ecpnl%abcdist, defecpnl%abcdist, size(ecpnl%abcdist)) !ep = 'ECPmastervars.albegadist' !call JSONreadRealVec(json, ep, ecpnl%albegadist, defecpnl%albegadist, size(ecpnl%albegadist)) ep = 'ECPmastervars.compmode' call JSONreadString ( json , ep , ecpnl % compmode , defecpnl % compmode ) ep = 'ECPmastervars.energyfile' call JSONreadString ( json , ep , ecpnl % energyfile , defecpnl % energyfile ) ep = 'ECPmastervars.outname' call JSONreadString ( json , ep , ecpnl % outname , defecpnl % outname ) !ep = 'ECPmastervars.distort' !call JSONreadLogical(json, ep, ecpnl%distort, defecpnl%distort) end if call json % destroy (); call JSON_failtest ( error_cnt ) end subroutine JSONreadECPMasterNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONreadEBSDNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read json file and fill enl structure (used by EMEBSD.f90) ! !> @param enl EBSD name list structure !> @param jsonname input file name !> @param error_cnt total number of errors encountered by json routines ! !> @date 08/20/15  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSONreadEBSDNameList ( enl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadEBSDNameList use ISO_C_BINDING use NameListHandlers use error IMPLICIT NONE type ( EBSDNameListType ), INTENT ( INOUT ) :: enl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_file ) :: json !the JSON structure read from the file: type ( EBSDNameListType ) :: defenl logical :: init = . TRUE . character ( fnlen ) :: nmlfile = '' , ep , s , s2 real ( kind = wp ) :: rval character ( kind = jsonCK , len = :), allocatable :: cval real ( wp ), dimension (:), allocatable :: rvec ! first of all, open the file and return an error message if it does not exist error_cnt = 0 call json_initialize (); call JSON_failtest ( error_cnt ) ! populate the json structure call json % load_file ( filename = trim ( jsonname )) if ( json_failed (). eqv .. TRUE .) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! ok, we got here so we need to initialize the namelist first to its default values (set in NameListHandlers) call GetEBSDNameList ( nmlfile , defenl , initonly = init ) ep = 'EBSDdata.stdout' call JSONreadInteger ( json , ep , enl % stdout , defenl % stdout ) ep = 'EBSDdata.numsx' call JSONreadInteger ( json , ep , enl % numsx , defenl % numsx ) ep = 'EBSDdata.numsy' call JSONreadInteger ( json , ep , enl % numsy , defenl % numsy ) ep = 'EBSDdata.binning' call JSONreadInteger ( json , ep , enl % binning , defenl % binning ) ep = 'EBSDdata.nthreads' call JSONreadInteger ( json , ep , enl % nthreads , defenl % nthreads ) ep = 'EBSDdata.energyaverage' call JSONreadInteger ( json , ep , enl % energyaverage , defenl % energyaverage ) ep = 'EBSDdata.L' call JSONreadReal ( json , ep , enl % L , defenl % L ) ep = 'EBSDdata.thetac' call JSONreadReal ( json , ep , enl % thetac , defenl % thetac ) ep = 'EBSDdata.delta' call JSONreadReal ( json , ep , enl % delta , defenl % delta ) ep = 'EBSDdata.xpc' call JSONreadReal ( json , ep , enl % xpc , defenl % xpc ) ep = 'EBSDdata.ypc' call JSONreadReal ( json , ep , enl % ypc , defenl % ypc ) ep = 'EBSDdata.omega' call JSONreadReal ( json , ep , enl % omega , defenl % omega ) ep = 'EBSDdata.energymin' call JSONreadReal ( json , ep , enl % energymin , defenl % energymin ) ep = 'EBSDdata.energymax' call JSONreadReal ( json , ep , enl % energymax , defenl % energymax ) ep = 'EBSDdata.gammavalue' call JSONreadReal ( json , ep , enl % gammavalue , defenl % gammavalue ) ep = 'EBSDdata.axisangle' call JSONreadRealVec ( json , ep , enl % axisangle , defenl % axisangle , size ( enl % axisangle )) ep = 'EBSDdata.beamcurrent' call JSONreadDouble ( json , ep , enl % beamcurrent , defenl % beamcurrent ) ep = 'EBSDdata.dwelltime' call JSONreadDouble ( json , ep , enl % dwelltime , defenl % dwelltime ) ep = 'EBSDdata.maskpattern' s = enl % maskpattern s2 = defenl % maskpattern call JSONreadString ( json , ep , s , s2 ) ep = 'EBSDdata.scalingmode' s = enl % scalingmode s2 = defenl % scalingmode call JSONreadString ( json , ep , s , s2 ) ep = 'EBSDdata.eulerconvention' s = enl % eulerconvention s2 = defenl % eulerconvention call JSONreadString ( json , ep , s , s2 ) ep = 'EBSDdata.outputformat' s = enl % outputformat s2 = defenl % outputformat call JSONreadString ( json , ep , s , s2 ) ep = 'EBSDdata.anglefile' call JSONreadString ( json , ep , enl % anglefile , defenl % anglefile ) ep = 'EBSDdata.masterfile' call JSONreadString ( json , ep , enl % masterfile , defenl % masterfile ) ep = 'EBSDdata.energyfile' call JSONreadString ( json , ep , enl % energyfile , defenl % energyfile ) ep = 'EBSDdata.datafile' call JSONreadString ( json , ep , enl % datafile , defenl % datafile ) end if call json % destroy (); call JSON_failtest ( error_cnt ) end subroutine JSONreadEBSDNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:JSONreadEBSDoverlapNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read jsonfile and fill enl structure (used by EMEBSDoverlap.f90) ! !> @param enl EBSD name list structure !> @param jsonname input file name !> @param error_cnt total number of errors encountered by json routines ! !> @date 08/20/15  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine JSONreadEBSDoverlapNameList ( enl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadEBSDoverlapNameList use ISO_C_BINDING use NameListHandlers use error IMPLICIT NONE type ( EBSDoverlapNameListType ), INTENT ( INOUT ) :: enl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_file ) :: json !the JSON structure read from the file: type ( EBSDoverlapNameListType ) :: defenl logical :: init = . TRUE . character ( fnlen ) :: nmlfile = '' , ep , s , s2 real ( kind = wp ) :: rval character ( kind = jsonCK , len = :), allocatable :: cval real ( wp ), dimension (:), allocatable :: rvec ! first of all, open the file and return an error message if it does not exist error_cnt = 0 call json_initialize (); call JSON_failtest ( error_cnt ) ! populate the json structure call json % load_file ( filename = trim ( jsonname )) if ( json_failed (). eqv .. TRUE .) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! ok, we got here so we need to initialize the namelist first to its default values (set in NameListHandlers) call GetEBSDoverlapNameList ( nmlfile , defenl , initonly = init ) ep = 'EBSDdata.stdout' call JSONreadInteger ( json , ep , enl % stdout , defenl % stdout ) ep = 'EBSDdata.PatternAxisA' call JSONreadIntegerVec ( json , ep , enl % PatternAxisA , defenl % PatternAxisA , size ( defenl % PatternAxisA )) ep = 'EBSDdata.HorizontalAxisA' call JSONreadIntegerVec ( json , ep , enl % HorizontalAxisA , defenl % HorizontalAxisA , size ( defenl % HorizontalAxisA )) ep = 'EBSDdata.tA' call JSONreadRealVec ( json , ep , enl % tA , defenl % tA , size ( enl % tA )) ep = 'EBSDdata.tB' call JSONreadRealVec ( json , ep , enl % tB , defenl % tB , size ( enl % tB )) ep = 'EBSDdata.gA' call JSONreadRealVec ( json , ep , enl % gA , defenl % gA , size ( enl % gA )) ep = 'EBSDdata.gB' call JSONreadRealVec ( json , ep , enl % gB , defenl % gB , size ( enl % gB )) ep = 'EBSDdata.fracA' call JSONreadReal ( json , ep , enl % fracA , defenl % fracA ) ep = 'EBSDdata.masterfileA' call JSONreadString ( json , ep , enl % masterfileA , defenl % masterfileA ) ep = 'EBSDdata.masterfileB' call JSONreadString ( json , ep , enl % masterfileB , defenl % masterfileB ) ep = 'EBSDdata.datafile' call JSONreadString ( json , ep , enl % datafile , defenl % datafile ) end if call json % destroy (); call JSON_failtest ( error_cnt ) end subroutine JSONreadEBSDoverlapNameList ! line 870 of NameListHandlers end module JSONsupport","tags":"","loc":"sourcefile/jsonsupport.f90.html","title":"JSONsupport.f90 – Fortran Program"},{"text":"This File Depends On sourcefile~~muellercalculus.f90~~EfferentGraph sourcefile~muellercalculus.f90 MuellerCalculus.f90 sourcefile~constants.f90 constants.f90 sourcefile~constants.f90->sourcefile~muellercalculus.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules MuellerCalculus Source Code MuellerCalculus.f90 Source Code ! ################################################################### ! Copyright (c) 2013-2017, Marc De Graef Research Group/Carnegie Mellon University ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without modification, are ! permitted provided that the following conditions are met: ! !     - Redistributions of source code must retain the above copyright notice, this list !        of conditions and the following disclaimer. !     - Redistributions in binary form must reproduce the above copyright notice, this !        list of conditions and the following disclaimer in the documentation and/or !        other materials provided with the distribution. !     - Neither the names of Marc De Graef, Carnegie Mellon University nor the names !        of its contributors may be used to endorse or promote products derived from !        this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE ! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ################################################################### !-------------------------------------------------------------------------- ! EMsoft:MuellerCalculus.f90 !-------------------------------------------------------------------------- ! ! PROGRAM: MuellerCalculus ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief routines to generate and handle Mueller matrices and Stokes vectors for polarized light microscopy ! !> @details Most of the routines in this module are based on the book by Collett: !> Polarized Light: Fundamentals and Applications, E. Collett, 1993 (M. Decker, Inc) ! !> @date 02/12/17 MDG 1.0 initial version !-------------------------------------------------------------------------- module MuellerCalculus use local use typedefs use error IMPLICIT NONE contains !-------------------------------------------------------------------------- ! ! FUNCTION: MC_get_basicMuellerMatrix ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief returns a basic 4x4 Mueller matrix by type ! !> @param MMtype integer describing the optical element (0 prduces list) ! !> @date   02/14/17 MDG 1.0 original !-------------------------------------------------------------------------- recursive function MC_get_basicMuellerMatrix ( MMtype ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_get_basicMuellerMatrix use io IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: MMtype type ( MuellerMatrixType ) :: res select case ( MMtype ) case ( 0 ) call Message ( 'The following basic Mueller matrix types are available:' ) call Message ( '1: linear horizontal polarizer (along x)' ) call Message ( '2: linear vertical polarizer (along y)' ) call Message ( '3: linear polarizer at +45°' ) call Message ( '4: linear polarizer at -45°' ) call Message ( '5: quarter-wave plate, fast axis vertical' ) call Message ( '6: quarter-wave plate, fast axis horizontal' ) call Message ( '7: circular polarizer, right-handed' ) call Message ( '8: circular polarizer, left-handed' ) case ( 1 ) res % descriptor = 'linear horizontal polarizer' res % M ( 1 , 1 : 4 ) = ( / 1.D0 , 1.D0 , 0.D0 , 0.D0 / ) res % M ( 2 , 1 : 4 ) = ( / 1.D0 , 1.D0 , 0.D0 , 0.D0 / ) res % M ( 3 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M ( 4 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M = 0.5D0 * res % M case ( 2 ) res % descriptor = 'linear vertical polarizer' res % M ( 1 , 1 : 4 ) = ( / 1.D0 , - 1.D0 , 0.D0 , 0.D0 / ) res % M ( 2 , 1 : 4 ) = ( /- 1.D0 , 1.D0 , 0.D0 , 0.D0 / ) res % M ( 3 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M ( 4 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M = 0.5D0 * res % M case ( 3 ) res % descriptor = 'linear polarizer at +45°' res % M ( 1 , 1 : 4 ) = ( / 1.D0 , 0.D0 , 1.D0 , 0.D0 / ) res % M ( 2 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M ( 3 , 1 : 4 ) = ( / 1.D0 , 0.D0 , 1.D0 , 0.D0 / ) res % M ( 4 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M = 0.5D0 * res % M case ( 4 ) res % descriptor = 'linear polarizer at -45°' res % M ( 1 , 1 : 4 ) = ( / 1.D0 , 0.D0 , - 1.D0 , 0.D0 / ) res % M ( 2 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M ( 3 , 1 : 4 ) = ( /- 1.D0 , 0.D0 , 1.D0 , 0.D0 / ) res % M ( 4 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M = 0.5D0 * res % M case ( 5 ) res % descriptor = 'quarter-wave plate, fast axis vertical' res % M ( 1 , 1 : 4 ) = ( / 1.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M ( 2 , 1 : 4 ) = ( / 0.D0 , 1.D0 , 0.D0 , 0.D0 / ) res % M ( 3 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , - 1.D0 / ) res % M ( 4 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 1.D0 , 0.D0 / ) case ( 6 ) res % descriptor = 'quarter-wave plate, fast axis horizontal' res % M ( 1 , 1 : 4 ) = ( / 1.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M ( 2 , 1 : 4 ) = ( / 0.D0 , 1.D0 , 0.D0 , 0.D0 / ) res % M ( 3 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , 1.D0 / ) res % M ( 4 , 1 : 4 ) = ( / 0.D0 , 0.D0 , - 1.D0 , 0.D0 / ) case ( 7 ) res % descriptor = 'circular polarizer, right-handed' res % M ( 1 , 1 : 4 ) = ( / 1.D0 , 0.D0 , 0.D0 , 1.D0 / ) res % M ( 2 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M ( 3 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M ( 4 , 1 : 4 ) = ( / 1.D0 , 0.D0 , 0.D0 , 1.D0 / ) res % M = 0.5D0 * res % M case ( 8 ) res % descriptor = 'circular polarizer, left-handed' res % M ( 1 , 1 : 4 ) = ( / 1.D0 , 0.D0 , 0.D0 , - 1.D0 / ) res % M ( 2 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M ( 3 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M ( 4 , 1 : 4 ) = ( /- 1.D0 , 0.D0 , 0.D0 , 1.D0 / ) res % M = 0.5D0 * res % M case default end select end function MC_get_basicMuellerMatrix !-------------------------------------------------------------------------- ! ! FUNCTION: MC_get_diattenuator ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief returns a 4x4 Mueller matrix for a diattenuator (polarizer) ! !> @param px amplitude attenuation coefficient along x or magnitude of vector p !> @param py amplitude attenuation coefficient along y or polar angle of vector p !> @param polar (OPTIONAL) absent/FALSE: cartesian components; TRUE: polar components of px + i py = (p, alpha) ! !> @date   02/12/17 MDG 1.0 original !-------------------------------------------------------------------------- recursive function MC_get_diattenuator ( px , py , polar ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_get_diattenuator IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: px real ( kind = dbl ), INTENT ( IN ) :: py logical , OPTIONAL , INTENT ( IN ) :: polar type ( MuellerMatrixType ) :: res logical :: usepolar ! initialize a Mueller matrix for a diattenuator res % descriptor = 'diattenuator' usepolar = . FALSE . if ( present ( polar )) then if ( polar . eqv .. TRUE .) usepolar = . TRUE . end if if ( usepolar ) then if (( px . lt . 0.D0 ). or .( px . gt . 1.D0 )) then call FatalError ( 'MC_get_diattenuator' , 'attenuation magnitude must lie in range [0,1]' ) end if res % M ( 1 , 1 : 4 ) = ( / 1.D0 , cos ( 2.D0 * py ), 0.D0 , 0.D0 / ) res % M ( 2 , 1 : 4 ) = ( / cos ( 2.D0 * py ), 1.D0 , 0.D0 , 0.D0 / ) res % M ( 3 , 1 : 4 ) = ( / 0.D0 , 0.D0 , sin ( 2.D0 * py ), 0.D0 / ) res % M ( 4 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , sin ( 2.D0 * py ) / ) res % M = 0.5D0 * px * px * res % M else if (( minval (( / px , py / )). lt . 0.D0 ). or .( maxval (( / px , py / )). gt . 1.D0 )) then call FatalError ( 'MC_get_diattenuator' , 'attenuation factors must lie in range [0,1]' ) end if res % M ( 1 , 1 : 4 ) = ( / px * px + py * py , px * px - py * py , 0.D0 , 0.D0 / ) res % M ( 2 , 1 : 4 ) = ( / px * px - py * py , px * px + py * py , 0.D0 , 0.D0 / ) res % M ( 3 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 2.D0 * px * py , 0.D0 / ) res % M ( 4 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , 2.D0 * px * py / ) res % M = 0.5D0 * res % M end if end function MC_get_diattenuator !-------------------------------------------------------------------------- ! ! FUNCTION: MC_get_rotator ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief returns a 4x4 Mueller matrix for a rotator ! !> @param theta rotator angle (radians) ! !> @date   02/12/17 MDG 1.0 original !-------------------------------------------------------------------------- recursive function MC_get_rotator ( theta ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_get_rotator IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: theta type ( MuellerMatrixType ) :: res real ( kind = dbl ) :: ct , st ct = cos ( 2.D0 * theta ) st = sin ( 2.D0 * theta ) ! initialize a Mueller matrix for a rotator res % descriptor = 'rotator' res % M ( 1 , 1 : 4 ) = ( / 1.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M ( 2 , 1 : 4 ) = ( / 0.D0 , ct , st , 0.D0 / ) res % M ( 3 , 1 : 4 ) = ( / 0.D0 , - st , ct , 0.D0 / ) res % M ( 4 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , 1.D0 / ) end function MC_get_rotator !-------------------------------------------------------------------------- ! ! FUNCTION: MC_get_retarder ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief returns a 4x4 Mueller matrix for a retarder ! !> @param phi retardation angle (radians) ! !> @date   02/12/17 MDG 1.0 original !-------------------------------------------------------------------------- recursive function MC_get_retarder ( phi ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_get_retarder IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: phi type ( MuellerMatrixType ) :: res real ( kind = dbl ) :: cp , sp cp = cos ( phi ) sp = sin ( phi ) ! initialize a Mueller matrix for a retarder res % descriptor = 'retarder' res % M ( 1 , 1 : 4 ) = ( / 1.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M ( 2 , 1 : 4 ) = ( / 0.D0 , 1.D0 , 0.D0 , 0.D0 / ) res % M ( 3 , 1 : 4 ) = ( / 0.D0 , 0.D0 , cp , - sp / ) res % M ( 4 , 1 : 4 ) = ( / 0.D0 , 0.D0 , sp , cp / ) end function MC_get_retarder !-------------------------------------------------------------------------- ! ! FUNCTION: MC_rotate_MuellerMatrix ! !> @author Marc De Graef, Carnegie Mellon University ! !> @param MM input Mueller matrix !> @param theta rotation angle (radians) ! !> @date   02/12/17 MDG 1.0 original !-------------------------------------------------------------------------- recursive function MC_rotate_MuellerMatrix ( MM , theta ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_rotate_MuellerMatrix IMPLICIT NONE type ( MuellerMatrixType ), INTENT ( IN ) :: MM real ( kind = dbl ), INTENT ( IN ) :: theta type ( MuellerMatrixType ) :: res type ( MuellerMatrixType ) :: Mrot ! initialize the output Mueller matrix descriptor res % descriptor = trim ( MM % descriptor ) // '-rotated' Mrot = MC_get_rotator ( theta ) res % M = matmul ( transpose ( Mrot % M ), matmul ( MM % M , Mrot % M )) end function MC_rotate_MuellerMatrix !-------------------------------------------------------------------------- ! ! SUBROUTINE: MC_print_MuellerMatrix ! !> @author Marc De Graef, Carnegie Mellon University ! !> @param MM input Mueller matrix ! !> @date   02/12/17 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine MC_print_MuellerMatrix ( MM ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_print_MuellerMatrix use io IMPLICIT NONE type ( MuellerMatrixType ), INTENT ( IN ) :: MM real ( kind = dbl ) :: io_double ( 4 ) integer ( kind = irg ) :: i call Message ( 'Mueller Matrix Type : ' // trim ( MM % descriptor )) do i = 1 , 4 io_double ( 1 : 4 ) = MM % M ( i , 1 : 4 ) call WriteValue ( '  --> ' , io_double , 4 ) end do end subroutine MC_print_MuellerMatrix !-------------------------------------------------------------------------- ! ! FUNCTION: MC_propagateStokesVector ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief multiplies a Stokes vector by a Mueller matrix ! !> @param MM Mueller matrix structure !> @param SV Stokes vector structure !> @param descriptor string to describe the state of the Stokes vector ! !> @date   02/12/17 MDG 1.0 original !-------------------------------------------------------------------------- recursive function MC_propagateStokesVector ( MM , SV , descriptor ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_propagateStokesVector IMPLICIT NONE type ( MuellerMatrixType ), INTENT ( IN ) :: MM type ( StokesVectorType ), INTENT ( IN ) :: SV character ( fnlen ), INTENT ( IN ) :: descriptor type ( StokesVectorType ) :: res res % S = matmul ( MM % M , SV % S ) res % descriptor = trim ( descriptor ) end function MC_propagateStokesVector !-------------------------------------------------------------------------- ! ! FUNCTION: MC_concatenateMuellerMatrices ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief multiplies a Mueller matrix M1 by M2, in the order  M2 x M1 ! !> @param MM1 Mueller matrix structure (earlier in the optical path) !> @param MM2 Mueller matrix structure (later in the optical path) ! !> @date   02/14/17 MDG 1.0 original !-------------------------------------------------------------------------- recursive function MC_concatenateMuellerMatrices ( MM1 , MM2 ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_concatenateMuellerMatrices IMPLICIT NONE type ( MuellerMatrixType ), INTENT ( IN ) :: MM1 type ( MuellerMatrixType ), INTENT ( IN ) :: MM2 type ( MuellerMatrixType ) :: res res % M = matmul ( MM2 % M , MM1 % M ) res % descriptor = trim ( MM1 % descriptor ) // '->' // trim ( MM2 % descriptor ) end function MC_concatenateMuellerMatrices !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- ! conversion routines between Stokes vector components and other ellipsometry parameters !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- ! ! FUNCTION: MC_get_EllipticityAngle ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief extracts the ellipticity angle from a Stokes vector ! !> @param SV Stokes vector structure ! !> @date   02/12/17 MDG 1.0 original !-------------------------------------------------------------------------- recursive function MC_get_EllipticityAngle ( SV ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_get_EllipticityAngle use constants use io IMPLICIT NONE type ( StokesVectorType ), INTENT ( IN ) :: SV real ( kind = dbl ) :: res real ( kind = dbl ) :: p4 , io_double ( 1 ) p4 = cPi * 0.25D0 res = 0.5D0 * asin ( SV % S ( 3 ) / SV % S ( 0 )) if ( abs ( res ). gt . p4 ) then io_double ( 1 ) = res call WriteValue ( 'Ellipticity angle = ' , io_double , 1 ) call FatalError ( 'MC_get_EllipticityAngle' , 'Ellipticity angle does not lie in range [-pi/4,pi/4]' ) end if end function MC_get_EllipticityAngle !-------------------------------------------------------------------------- ! ! FUNCTION: MC_get_OrientationAngle ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief extracts the polarization ellipse orientation angle from a Stokes vector ! !> @param SV Stokes vector structure ! !> @date   02/12/17 MDG 1.0 original !-------------------------------------------------------------------------- recursive function MC_get_OrientationAngle ( SV ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_get_OrientationAngle use constants IMPLICIT NONE type ( StokesVectorType ), INTENT ( IN ) :: SV real ( kind = dbl ) :: res res = 0.5D0 * atan2 ( SV % S ( 2 ), SV % S ( 1 )) res = mod ( res + 2.D0 * cPi , cPi ) end function MC_get_OrientationAngle !-------------------------------------------------------------------------- ! ! FUNCTION: MC_get_AuxiliaryAngle ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief extracts the auxiliary angle from a Stokes vector ! !> @param SV Stokes vector structure ! !> @date   02/13/17 MDG 1.0 original !-------------------------------------------------------------------------- recursive function MC_get_AuxiliaryAngle ( SV ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_get_AuxiliaryAngle use constants use io IMPLICIT NONE type ( StokesVectorType ), INTENT ( IN ) :: SV real ( kind = dbl ) :: res real ( kind = dbl ) :: psi , chi , alpha , delta chi = MC_get_EllipticityAngle ( SV ) psi = MC_get_OrientationAngle ( SV ) call MC_get_AD_from_EO ( chi , psi , alpha , delta ) res = alpha end function MC_get_AuxiliaryAngle !-------------------------------------------------------------------------- ! ! FUNCTION: MC_get_PhaseShiftAngle ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief extracts the phase shift angle from a Stokes vector ! !> @param SV Stokes vector structure ! !> @date   02/13/17 MDG 1.0 original !-------------------------------------------------------------------------- recursive function MC_get_PhaseShiftAngle ( SV ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_get_PhaseShiftAngle use constants use io IMPLICIT NONE type ( StokesVectorType ), INTENT ( IN ) :: SV real ( kind = dbl ) :: res real ( kind = dbl ) :: psi , chi , alpha , delta chi = MC_get_EllipticityAngle ( SV ) psi = MC_get_OrientationAngle ( SV ) call MC_get_AD_from_EO ( chi , psi , alpha , delta ) res = delta end function MC_get_PhaseShiftAngle !-------------------------------------------------------------------------- ! ! FUNCTION: MC_get_Polarization ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief extracts the polarization from a Stokes vector ! !> @param SV Stokes vector structure ! !> @date   02/12/17 MDG 1.0 original !-------------------------------------------------------------------------- recursive function MC_get_Polarization ( SV ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_get_Polarization use io IMPLICIT NONE type ( StokesVectorType ), INTENT ( IN ) :: SV real ( kind = dbl ) :: res if ( SV % S ( 0 ). eq . 0.D0 ) then call FatalError ( 'MC_get_Polarization' , 'Total intensity in Stokes Vector is zero' ) end if res = dsqrt ( sum ( SV % S ( 1 : 3 ) ** 2 )) / SV % S ( 0 ) end function MC_get_Polarization !-------------------------------------------------------------------------- ! ! FUNCTION: MC_get_Stokes_EO ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief generate a Stokes vector for a given Ellipticity and Orientation angle ! !> @param chi ellipticity angle (radians) !> @param psi orientation angle (radians) ! !> @date   02/13/17 MDG 1.0 original !-------------------------------------------------------------------------- recursive function MC_get_Stokes_EO ( chi , psi , descriptor ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_get_Stokes_EO IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: chi real ( kind = dbl ), INTENT ( IN ) :: psi character ( fnlen ), INTENT ( IN ) :: descriptor type ( StokesVectorType ) :: res real ( kind = dbl ) :: cp , sp , cc , sc cp = cos ( 2.D0 * psi ) sp = sin ( 2.D0 * psi ) cc = cos ( 2.D0 * chi ) sc = sin ( 2.D0 * chi ) res % descriptor = trim ( descriptor ) res % S = ( / 1.D0 , cc * cp , cc * sp , sc / ) end function MC_get_Stokes_EO !-------------------------------------------------------------------------- ! ! FUNCTION: MC_get_Stokes_AD ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief generate a Stokes vector for a given auxiliary and phase shift angle ! !> @param alpha auxiliary angle (radians) !> @param delta phase shift angle (radians) ! !> @date   02/13/17 MDG 1.0 original !-------------------------------------------------------------------------- recursive function MC_get_Stokes_AD ( alpha , delta , descriptor ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_get_Stokes_AD IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: alpha real ( kind = dbl ), INTENT ( IN ) :: delta character ( fnlen ), INTENT ( IN ) :: descriptor type ( StokesVectorType ) :: res real ( kind = dbl ) :: ca , sa , cd , sd ca = cos ( 2.D0 * alpha ) sa = sin ( 2.D0 * alpha ) cd = cos ( delta ) sd = sin ( delta ) res % descriptor = trim ( descriptor ) res % S = ( / 1.D0 , ca , sa * cd , sa * sd / ) end function MC_get_Stokes_AD !-------------------------------------------------------------------------- ! ! SUBROUTINE: MC_get_AD_from_EO ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief convert auxiliary and phase shift angle to ellipticity and orientation angles ! !> @details determined using a Mathematica script ! !> @param chi ellipticity angle (radians) !> @param psi orientation angle (radians) !> @param alpha auxiliary angle (radians) !> @param delta phase shift angle (radians) ! !> @date   02/13/17 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine MC_get_AD_from_EO ( chi , psi , alpha , delta ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_get_AD_from_EO use constants IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: chi real ( kind = dbl ), INTENT ( IN ) :: psi real ( kind = dbl ), INTENT ( OUT ) :: alpha real ( kind = dbl ), INTENT ( OUT ) :: delta real ( kind = dbl ) :: sc , tp , cp , cc , p2 , p4 , st , tt , ss , ct , sa p2 = cPi * 0.5D0 p4 = cPi * 0.25D0 cc = cos ( 2.D0 * chi ) sc = sin ( 2.D0 * chi ) tp = tan ( 2.D0 * psi ) cp = cos ( 2.D0 * psi ) st = dsqrt ( sc * sc + tp * tp ) tt = dsqrt ( 1.D0 + tp * tp ) ss = dsqrt ( 1.D0 - sc * sc ) ct = cos ( 2.D0 * chi ) * tan ( 2.D0 * psi ) sa = sc / abs ( cp ) ! get alpha if ( abs ( psi - p2 ). ge . p4 ) then alpha = 0.5D0 * atan2 ( st / tt , ss / tt ) else alpha = 0.5D0 * ( cPi - atan2 ( st / tt , ss / tt )) end if ! get delta, such that there is only one cut in the delta surface for chi=0, psi<pi/2 if ( abs ( psi - p2 ). lt . p4 ) then delta = atan2 ( - sa / st , ct / st ) - cPi else delta = atan2 ( sa / st , ct / st ) if ( chi . gt . 0.D0 ) delta = delta - 2.0D0 * cPi end if end subroutine MC_get_AD_from_EO !-------------------------------------------------------------------------- ! ! SUBROUTINE: MC_get_EO_from_AD ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief convert ellipticity and orientation angles to auxiliary and phase shift angles ! !> @details determined using a Mathematica script ! !> @param alpha auxiliary angle (radians) !> @param delta phase shift angle (radians) !> @param chi ellipticity angle (radians) !> @param psi orientation angle (radians) ! !> @date   02/13/17 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine MC_get_EO_from_AD ( alpha , delta , chi , psi ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_get_EO_from_AD use constants IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: alpha real ( kind = dbl ), INTENT ( IN ) :: delta real ( kind = dbl ), INTENT ( OUT ) :: chi real ( kind = dbl ), INTENT ( OUT ) :: psi real ( kind = dbl ) :: p2 , p4 p2 = cPi * 0.5D0 p4 = cPi * 0.25D0 chi = 0.5D0 * asin ( sin ( 2.D0 * alpha ) * sin ( delta )) if ( delta . le . p2 ) then psi = 0.5D0 * atan ( cos ( delta ) * tan ( 2.D0 * alpha )) else psi = cPi - 0.5D0 * atan ( cos ( delta ) * tan ( 2.D0 * alpha )) end if ! make sure chi falls in the range [-pi/4,pi/4] if ( abs ( chi ). gt . p4 ) then call FatalError ( 'MC_get_EO_from_AD' , 'ellipticity angle must be in interval [-pi/4,pi/4]' ) end if ! make sure psi falls in the range [0,pi] if ( psi . lt . 0.D0 ) psi = psi + cPi end subroutine MC_get_EO_from_AD ! we could use a routine to \"interpret\" a Stokes vector end module MuellerCalculus","tags":"","loc":"sourcefile/muellercalculus.f90.html","title":"MuellerCalculus.f90 – Fortran Program"},{"text":"Files Dependent On This One sourcefile~~multibeams.f90~~AfferentGraph sourcefile~multibeams.f90 multibeams.f90 sourcefile~emdymod.f90 EMdymod.f90 sourcefile~multibeams.f90->sourcefile~emdymod.f90 sourcefile~simulated_annealing.f90 simulated_annealing.f90 sourcefile~emdymod.f90->sourcefile~simulated_annealing.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules multibeams Source Code multibeams.f90 Source Code !-------------------------------------------------------------------------- ! EMsoft:multibeams.f90 !-------------------------------------------------------------------------- ! ! MODULE: multibeams ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief Anything related to dynamical diffraction ! !> @details these variables are passed back and forth between the main !> multi beam program and the various subroutines. ! !> @todo prepend MB to all the variable names and propagate into other code ! !> @date   10/13/98 MDG 1.0 original !> @date    5/22/01 MDG 2.0 f90 !> @date   11/27/01 MDG 2.1 added kind support !> @date    3/14/02 MDG 2.2 added CalcDynMat routine !-------------------------------------------------------------------------- module multibeams use local integer ( kind = irg ), parameter :: numr = 500 ! max number of families of reflections in zone integer ( kind = irg ) :: family ( numr , 48 , 3 ), numfam ( numr ) integer ( kind = irg ), allocatable :: idx (:) real ( kind = sgl ) :: glen ( numr ) ! length of g-vectors real ( kind = sgl ), allocatable :: gm (:), V (:,:) logical , allocatable :: al (:) ! array of allowed reflections !DEC$ ATTRIBUTES DLLEXPORT :: numr !DEC$ ATTRIBUTES DLLEXPORT :: family !DEC$ ATTRIBUTES DLLEXPORT :: numfam !DEC$ ATTRIBUTES DLLEXPORT :: idx !DEC$ ATTRIBUTES DLLEXPORT :: glen !DEC$ ATTRIBUTES DLLEXPORT :: gm !DEC$ ATTRIBUTES DLLEXPORT :: V !DEC$ ATTRIBUTES DLLEXPORT :: al end module multibeams","tags":"","loc":"sourcefile/multibeams.f90.html","title":"multibeams.f90 – Fortran Program"},{"text":"This File Depends On sourcefile~~namelisthandlers.f90~~EfferentGraph sourcefile~namelisthandlers.f90 NameListHandlers.f90 sourcefile~namelisttypedefs.f90 NameListTypedefs.f90 sourcefile~namelisttypedefs.f90->sourcefile~namelisthandlers.f90 sourcefile~constants.f90 constants.f90 sourcefile~constants.f90->sourcefile~namelisthandlers.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files Dependent On This One sourcefile~~namelisthandlers.f90~~AfferentGraph sourcefile~namelisthandlers.f90 NameListHandlers.f90 sourcefile~jsonsupport.f90 JSONsupport.f90 sourcefile~namelisthandlers.f90->sourcefile~jsonsupport.f90 sourcefile~defectmodule.f90 defectmodule.f90 sourcefile~jsonsupport.f90->sourcefile~defectmodule.f90 sourcefile~dispfield.f90 dispfield.f90 sourcefile~defectmodule.f90->sourcefile~dispfield.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules NameListHandlers Source Code NameListHandlers.f90 Source Code ! ################################################################### ! Copyright (c) 2013-2014, Marc De Graef/Carnegie Mellon University ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without modification, are ! permitted provided that the following conditions are met: ! !     - Redistributions of source code must retain the above copyright notice, this list !        of conditions and the following disclaimer. !     - Redistributions in binary form must reproduce the above copyright notice, this !        list of conditions and the following disclaimer in the documentation and/or !        other materials provided with the distribution. !     - Neither the names of Marc De Graef, Carnegie Mellon University nor the names !        of its contributors may be used to endorse or promote products derived from !        this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE ! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ################################################################### !-------------------------------------------------------------------------- ! EMsoft:NameListHandlers.f90 !-------------------------------------------------------------------------- ! ! PROGRAM: NameListHandlers ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief routines for reading and returning name list type structures ! !> @date 06/13/14 MDG 1.0 original !> @date 05/05/15 MDG 1.1 removed primelist variable from name list files !> @date 08/12/15 MDG 1.2 added initonly optional keyword to skip reading from file !-------------------------------------------------------------------------- module NameListHandlers use local use NameListTypedefs contains !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetMultiPhaseNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill enl structure (used by EMMultiphase.f90) ! !> @param nmlfile namelist file name !> @param enl multiphase name list structure !> @param initonly [optional] logical ! !> @date 02/21/17  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine GetMultiPhaseNameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetMultiPhaseNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( MultiPhaseNameListType ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: nthreads character ( fnlen ) :: dp1file character ( fnlen ) :: dp2file character ( fnlen ) :: dp3file character ( fnlen ) :: outputfile namelist / multiphaselist / dp1file , dp2file , dp3file , outputfile , nthreads nthreads = 1 dp1file = 'undefined' dp2file = 'undefined' dp3file = 'undefined' outputfile = 'undefined' if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = multiphaselist ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( dp1file ). eq . 'undefined' ) then call FatalError ( 'Emultiphase:' , ' dp1 file name is undefined in ' // nmlfile ) end if if ( trim ( dp2file ). eq . 'undefined' ) then call FatalError ( 'Emultiphase:' , ' dp2 file name is undefined in ' // nmlfile ) end if if ( trim ( dp3file ). eq . 'undefined' ) then call FatalError ( 'Emultiphase:' , ' dp3 file name is undefined in ' // nmlfile ) end if if ( trim ( outputfile ). eq . 'undefined' ) then call FatalError ( 'Emultiphase:' , ' output file name is undefined in ' // nmlfile ) end if end if enl % nthreads = nthreads enl % dp1file = dp1file enl % dp2file = dp2file enl % dp3file = dp3file enl % outputfile = outputfile end subroutine GetMultiPhaseNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetKosselNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill knl structure (used by EMKossel.f90) ! !> @param nmlfile namelist file name !> @param knl Kossel name list structure !> @param initonly [optional] logical ! !> @date 06/13/14  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine GetKosselNameList ( nmlfile , knl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetKosselNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( KosselNameListType ), INTENT ( INOUT ) :: knl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numthick integer ( kind = irg ) :: npix integer ( kind = irg ) :: maxHOLZ integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: k ( 3 ) integer ( kind = irg ) :: fn ( 3 ) real ( kind = sgl ) :: voltage real ( kind = sgl ) :: dmin real ( kind = sgl ) :: convergence real ( kind = sgl ) :: startthick real ( kind = sgl ) :: thickinc real ( kind = sgl ) :: minten character ( fnlen ) :: xtalname character ( fnlen ) :: outname namelist / Kossellist / stdout , xtalname , voltage , k , fn , dmin , convergence , minten , nthreads , & startthick , thickinc , numthick , outname , npix , maxHOLZ ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 ! standard output numthick = 10 ! number of increments npix = 256 ! output arrays will have size npix x npix maxHOLZ = 3 ! output arrays will have size npix x npix nthreads = 4 ! default number of threads for OpenMP k = ( / 0 , 0 , 1 / ) ! beam direction [direction indices] fn = ( / 0 , 0 , 1 / ) ! foil normal [direction indices] voltage = 20000 0.0 ! acceleration voltage [V] dmin = 0.025 ! smallest d-spacing to include in dynamical matrix [nm] convergence = 2 5.0 ! beam convergence angle [mrad] startthick = 1 0.0 ! starting thickness [nm] thickinc = 1 0.0 ! thickness increment minten = 1.0E-5 ! minimum intensity in diffraction disk to make it into the output file xtalname = 'undefined' ! initial value to check that the keyword is present in the nml file outname = 'Kosselout.data' ! output filename if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = Kossellist ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'EMKossel:' , ' structure file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the knl fields knl % stdout = stdout knl % numthick = numthick knl % npix = npix knl % maxHOLZ = maxHOLZ knl % nthreads = nthreads knl % k = k knl % fn = fn knl % voltage = voltage knl % dmin = dmin knl % convergence = convergence knl % startthick = startthick knl % thickinc = thickinc knl % minten = minten knl % xtalname = xtalname knl % outname = outname end subroutine GetKosselNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetKosselMasterNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill knl structure (used by EMKosselmaster.f90) ! !> @param nmlfile namelist file name !> @param knl Kossel name list structure ! !> @date 09/09/14  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine GetKosselMasterNameList ( nmlfile , knl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetKosselMasterNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( KosselMasterNameListType ), INTENT ( INOUT ) :: knl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numthick integer ( kind = irg ) :: npx integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: voltage real ( kind = sgl ) :: dmin real ( kind = sgl ) :: startthick real ( kind = sgl ) :: thickinc real ( kind = sgl ) :: tfraction character ( 6 ) :: Kosselmode character ( fnlen ) :: xtalname character ( fnlen ) :: outname namelist / Kosselmasterlist / stdout , xtalname , voltage , dmin , nthreads , & startthick , thickinc , numthick , tfraction , outname , npx , Kosselmode ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 ! standard output numthick = 10 ! number of increments npx = 256 ! output arrays will have size npix x npix nthreads = 4 ! default number of threads for OpenMP voltage = 20000 0.0 ! acceleration voltage [V] dmin = 0.025 ! smallest d-spacing to include in dynamical matrix [nm] startthick = 1 0.0 ! starting thickness [nm] thickinc = 1 0.0 ! thickness increment xtalname = 'undefined' ! initial value to check that the keyword is present in the nml file outname = 'Kosselout.data' ! output filename Kosselmode = 'normal' ! 'thicks' for thickness determination, 'normal' for normal plot tfraction = 0.1 ! thickness fraction for 'thicks' mode if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = Kosselmasterlist ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'EMKosselMaster:' , ' structure file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the knl fields knl % stdout = stdout knl % numthick = numthick knl % npx = npx knl % nthreads = nthreads knl % voltage = voltage knl % dmin = dmin knl % startthick = startthick knl % thickinc = thickinc knl % tfraction = tfraction knl % Kosselmode = Kosselmode knl % xtalname = xtalname knl % outname = outname end subroutine GetKosselMasterNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetMCNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill mcnl structure (used by EMMC.f90) ! !> @param nmlfile namelist file name !> @param mcnl Monte Carloname list structure ! !> @date 06/18/14  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine GetMCNameList ( nmlfile , mcnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetMCNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( MCNameListType ), INTENT ( INOUT ) :: mcnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numsx integer ( kind = irg ) :: num_el integer ( kind = irg ) :: primeseed integer ( kind = irg ) :: nthreads real ( kind = dbl ) :: sig real ( kind = dbl ) :: omega real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep character ( 4 ) :: MCmode character ( fnlen ) :: xtalname character ( fnlen ) :: dataname ! define the IO namelist to facilitate passing variables to the program. namelist / MCdata / stdout , xtalname , sig , numsx , num_el , primeseed , EkeV , & dataname , nthreads , Ehistmin , Ebinsize , depthmax , depthstep , omega , MCmode ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 numsx = 1501 primeseed = 932117 num_el = 12500000 nthreads = 1 sig = 7 0.D0 omega = 0.D0 EkeV = 3 0.D0 Ehistmin = 5.D0 Ebinsize = 0.5D0 depthmax = 10 0.D0 depthstep = 1.0D0 MCmode = 'CSDA' xtalname = 'undefined' dataname = 'MCoutput.data' if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = MCdata ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'EMMC:' , ' structure file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the mcnl fields mcnl % stdout = stdout mcnl % numsx = numsx mcnl % primeseed = primeseed mcnl % num_el = num_el mcnl % nthreads = nthreads mcnl % sig = sig mcnl % omega = omega mcnl % EkeV = EkeV mcnl % Ehistmin = Ehistmin mcnl % Ebinsize = Ebinsize mcnl % depthmax = depthmax mcnl % depthstep = depthstep mcnl % MCmode = MCmode mcnl % xtalname = xtalname mcnl % dataname = dataname mcnl % stdout = stdout end subroutine GetMCNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetMCLIPSSNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill mcnl structure (used by EMMC.f90) ! !> @param nmlfile namelist file name !> @param mcnl Monte Carloname list structure ! !> @date 12/01/15  PGC 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine GetMCLIPSSNameList ( nmlfile , mcnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetMCLIPSSNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( MCLIPSSNameListType ), INTENT ( INOUT ) :: mcnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numsx integer ( kind = irg ) :: num_el integer ( kind = irg ) :: primeseed integer ( kind = irg ) :: nthreads real ( kind = dbl ) :: sig real ( kind = dbl ) :: omega real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep real ( kind = dbl ) :: lipssamp ! lipss amplitude real ( kind = dbl ) :: lipsswave ! lipss wavelength real ( kind = dbl ) :: scaled ! scale factor integer ( kind = irg ) :: npx ! array size of trajectory accumulator integer ( kind = irg ) :: vis ! write large trajectory accumulator (0-no, 1-yes) character ( 4 ) :: MCmode character ( fnlen ) :: xtalname character ( fnlen ) :: dataname ! define the IO namelist to facilitate passing variables to the program. namelist / MCdata / stdout , xtalname , sig , numsx , num_el , primeseed , EkeV , & dataname , nthreads , Ehistmin , Ebinsize , depthmax , depthstep , & lipssamp , lipsswave , scaled , npx , vis , omega , MCmode ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 numsx = 1501 primeseed = 932117 num_el = 12500000 nthreads = 1 sig = 7 0.D0 omega = 0.D0 EkeV = 3 0.D0 Ehistmin = 5.D0 Ebinsize = 0.5D0 depthmax = 10 0.D0 depthstep = 1.0D0 lipssamp = 5 0.D0 lipsswave = 30 0.D0 scaled = 1.0D7 npx = 500 vis = 0 MCmode = 'CSDA' xtalname = 'undefined' dataname = 'MCLIPSSoutput.data' if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = MCdata ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'EMMCLIPSS:' , ' structure file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the mcnl fields mcnl % stdout = stdout mcnl % numsx = numsx mcnl % primeseed = primeseed mcnl % num_el = num_el mcnl % nthreads = nthreads mcnl % sig = sig mcnl % omega = omega mcnl % EkeV = EkeV mcnl % Ehistmin = Ehistmin mcnl % Ebinsize = Ebinsize mcnl % depthmax = depthmax mcnl % depthstep = depthstep mcnl % MCmode = MCmode mcnl % xtalname = xtalname mcnl % dataname = dataname mcnl % stdout = stdout mcnl % lipssamp = lipssamp mcnl % lipsswave = lipsswave mcnl % scaled = scaled mcnl % npx = npx mcnl % vis = vis end subroutine GetMCLIPSSNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetConvertOrientationsNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill mcnl structure (used by EMConvertOrientations.f90 program) ! !> @param nmlfile namelist file name !> @param enl name list structure ! !> @date 01/31/17 MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine GetConvertOrientationsNameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetConvertOrientationsNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( ConvertOrientationsNameListType ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: cnt integer ( kind = irg ) :: reducetoRFZ character ( fnlen ) :: xtalname character ( fnlen ) :: cubochoric character ( fnlen ) :: homochoric character ( fnlen ) :: rodrigues character ( fnlen ) :: stereographic character ( fnlen ) :: eulerangles character ( fnlen ) :: axisangle character ( fnlen ) :: quaternion character ( fnlen ) :: rotationmatrix character ( fnlen ) :: anglefile ! define the IO namelist to facilitate passing variables to the program. namelist / EMConvertOrientations / cubochoric , homochoric , rodrigues , stereographic , eulerangles , & axisangle , quaternion , rotationmatrix , xtalname , anglefile , reducetoRFZ ! initialize reducetoRFZ = 1 cubochoric = 'undefined' homochoric = 'undefined' rodrigues = 'undefined' stereographic = 'undefined' eulerangles = 'undefined' axisangle = 'undefined' quaternion = 'undefined' rotationmatrix = 'undefined' xtalname = 'undefined' anglefile = 'undefined' if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = EMConvertOrientations ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'GetConvertOrientationsNameList:' , ' structure file name is undefined in ' // nmlfile ) end if if ( trim ( anglefile ). eq . 'undefined' ) then call FatalError ( 'GetConvertOrientationsNameList:' , ' angle file name is undefined in ' // nmlfile ) end if ! at least one of the output file strings must be different from 'undefined' cnt = 0 if ( cubochoric . eq . 'undefined' ) cnt = cnt + 1 if ( homochoric . eq . 'undefined' ) cnt = cnt + 1 if ( rodrigues . eq . 'undefined' ) cnt = cnt + 1 if ( stereographic . eq . 'undefined' ) cnt = cnt + 1 if ( eulerangles . eq . 'undefined' ) cnt = cnt + 1 if ( quaternion . eq . 'undefined' ) cnt = cnt + 1 if ( axisangle . eq . 'undefined' ) cnt = cnt + 1 if ( rotationmatrix . eq . 'undefined' ) cnt = cnt + 1 if ( cnt . eq . 8 ) then call FatalError ( 'GetConvertOrientationsNameList' , ' at least one output file name must be defined in ' // nmlfile ) end if end if enl % reducetoRFZ = reducetoRFZ enl % cubochoric = trim ( cubochoric ) enl % homochoric = trim ( homochoric ) enl % rodrigues = trim ( rodrigues ) enl % stereographic = trim ( stereographic ) enl % eulerangles = trim ( eulerangles ) enl % axisangle = trim ( axisangle ) enl % quaternion = trim ( quaternion ) enl % rotationmatrix = trim ( rotationmatrix ) enl % xtalname = trim ( xtalname ) enl % anglefile = trim ( anglefile ) end subroutine GetConvertOrientationsNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetOrientationVizNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill mcnl structure (used by EMOrientationViz.f90 program) ! !> @param nmlfile namelist file name !> @param enl name list structure ! !> @date 01/30/17 MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine GetOrientationVizNameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetOrientationVizNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( OrientationVizNameListType ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: cubochoric integer ( kind = irg ) :: homochoric integer ( kind = irg ) :: rodrigues integer ( kind = irg ) :: stereographic integer ( kind = irg ) :: eulerspace integer ( kind = irg ) :: reducetoRFZ integer ( kind = irg ) :: nx integer ( kind = irg ) :: ny integer ( kind = irg ) :: nz integer ( kind = irg ) :: overridepgnum integer ( kind = irg ) :: MacKenzieCell real ( kind = sgl ) :: rgb ( 3 ) real ( kind = sgl ) :: sphrad real ( kind = sgl ) :: distance character ( 3 ) :: scalingmode character ( fnlen ) :: df3file character ( fnlen ) :: xtalname character ( fnlen ) :: povrayfile character ( fnlen ) :: anglefile ! define the IO namelist to facilitate passing variables to the program. namelist / EMOrientationViz / cubochoric , homochoric , rodrigues , stereographic , eulerspace , & xtalname , povrayfile , anglefile , reducetoRFZ , rgb , sphrad , df3file , & nx , ny , nz , distance , scalingmode , overridepgnum , MacKenzieCell ! initialize cubochoric = 0 homochoric = 0 rodrigues = 0 stereographic = 0 eulerspace = 0 reducetoRFZ = 1 overridepgnum = 0 MacKenzieCell = 0 rgb = ( / 0.0 , 0.0 , 1.0 / ) sphrad = 0.015 distance = 4.0 nx = 64 ny = 64 nz = 64 scalingmode = 'lev' ! or 'log' or 'lev' (for equi-level contours) df3file = 'undefined' xtalname = 'undefined' povrayfile = 'undefined' anglefile = 'undefined' if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = EMOrientationViz ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'EMOrientationViz:' , ' structure file name is undefined in ' // nmlfile ) end if if ( trim ( povrayfile ). eq . 'undefined' ) then call FatalError ( 'EMOrientationViz:' , ' povray file name is undefined in ' // nmlfile ) end if if ( trim ( anglefile ). eq . 'undefined' ) then call FatalError ( 'EMOrientationViz:' , ' angle file name is undefined in ' // nmlfile ) end if end if enl % cubochoric = cubochoric enl % homochoric = homochoric enl % rodrigues = rodrigues enl % stereographic = stereographic enl % eulerspace = eulerspace enl % reducetoRFZ = reducetoRFZ enl % nx = nx enl % ny = ny enl % nz = nz enl % overridepgnum = overridepgnum enl % MacKenzieCell = MacKenzieCell enl % rgb = rgb enl % sphrad = sphrad enl % distance = distance enl % scalingmode = scalingmode enl % df3file = df3file enl % xtalname = trim ( xtalname ) enl % povrayfile = trim ( povrayfile ) enl % anglefile = trim ( anglefile ) end subroutine GetOrientationVizNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetMCCLNameList ! !> @author Saransh Singh/Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill mcnl structure (used by EMMCCL.f90 and other programs) ! !> @param nmlfile namelist file name !> @param mcnl Monte Carloname list structure ! !> @date 06/18/14  SS 1.0 new routine !> @date 09/09/15 MDG 1.1 added devid (GPU device id) !-------------------------------------------------------------------------- recursive subroutine GetMCCLNameList ( nmlfile , mcnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetMCCLNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( MCCLNameListType ), INTENT ( INOUT ) :: mcnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numsx integer ( kind = irg ) :: globalworkgrpsz integer ( kind = irg ) :: num_el integer ( kind = irg ) :: totnum_el integer ( kind = irg ) :: multiplier integer ( kind = irg ) :: devid integer ( kind = irg ) :: platid real ( kind = dbl ) :: sig real ( kind = dbl ) :: sigstart real ( kind = dbl ) :: sigend real ( kind = dbl ) :: sigstep real ( kind = dbl ) :: omega real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep character ( 4 ) :: MCmode character ( fnlen ) :: xtalname character ( fnlen ) :: dataname character ( fnlen ) :: mode ! define the IO namelist to facilitate passing variables to the program. namelist / MCCLdata / stdout , xtalname , sigstart , numsx , num_el , globalworkgrpsz , EkeV , multiplier , & dataname , totnum_el , Ehistmin , Ebinsize , depthmax , depthstep , omega , MCmode , mode , devid , platid , & sigend , sigstep , sig ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 numsx = 1501 globalworkgrpsz = 100 num_el = 10 totnum_el = 2000000000 multiplier = 1 devid = 1 platid = 1 sig = 7 0.D0 sigstart = 7 0.D0 sigend = 7 0.D0 sigstep = 1.D0 omega = 0.D0 EkeV = 3 0.D0 Ehistmin = 5.D0 Ebinsize = 0.5D0 depthmax = 10 0.D0 depthstep = 1.0D0 MCmode = 'CSDA' xtalname = 'undefined' dataname = 'MCoutput.data' mode = 'full' if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if write ( * , * ) EMsoft_toNativePath ( nmlfile ) if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = MCCLdata ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'EMMC:' , ' structure file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the mcnl fields mcnl % stdout = stdout mcnl % numsx = numsx mcnl % globalworkgrpsz = globalworkgrpsz mcnl % num_el = num_el mcnl % totnum_el = totnum_el mcnl % multiplier = multiplier mcnl % devid = devid mcnl % platid = platid mcnl % sigstart = sigstart mcnl % sigend = sigend mcnl % sigstep = sigstep mcnl % sig = sig mcnl % omega = omega mcnl % EkeV = EkeV mcnl % Ehistmin = Ehistmin mcnl % Ebinsize = Ebinsize mcnl % depthmax = depthmax mcnl % depthstep = depthstep mcnl % MCmode = MCmode mcnl % xtalname = xtalname mcnl % dataname = dataname mcnl % mode = mode end subroutine GetMCCLNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetMCCLMultiLayerNameList ! !> @author Saransh Singh/Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill mcnl structure (used by EMMCCL.f90) ! !> @param nmlfile namelist file name !> @param mcnl Monte Carloname list structure ! !> @date 06/18/14  SS 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine GetMCCLMultiLayerNameList ( nmlfile , mcnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetMCCLMultiLayerNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( MCCLMultiLayerNameListType ), INTENT ( INOUT ) :: mcnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numsx integer ( kind = irg ) :: globalworkgrpsz integer ( kind = irg ) :: num_el integer ( kind = irg ) :: totnum_el real ( kind = dbl ) :: sig real ( kind = dbl ) :: omega real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep real ( kind = dbl ) :: filmthickness real ( kind = dbl ) :: filmstep character ( 4 ) :: MCmode character ( fnlen ) :: xtalname_film character ( fnlen ) :: xtalname_subs character ( fnlen ) :: dataname character ( fnlen ) :: mode ! define the IO namelist to facilitate passing variables to the program. namelist / MCCLdata / stdout , sig , numsx , num_el , globalworkgrpsz , EkeV , & dataname , totnum_el , Ehistmin , Ebinsize , depthmax , & depthstep , omega , MCmode , mode , xtalname_film , xtalname_subs , & filmthickness , filmstep ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 numsx = 1501 globalworkgrpsz = 100 num_el = 10 totnum_el = 100000 sig = 7 0.D0 omega = 0.D0 EkeV = 3 0.D0 Ehistmin = 5.D0 Ebinsize = 0.5D0 depthmax = 10 0.D0 depthstep = 1.0D0 MCmode = 'CSDA' xtalname_film = 'undefined' xtalname_subs = 'undefined' dataname = 'MCoutput.data' mode = 'full' filmthickness = 2 0.D0 filmstep = 2.D0 if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = MCCLdata ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if (( trim ( xtalname_film ). eq . 'undefined' ) . or . ( trim ( xtalname_subs ). eq . 'undefined' )) then call FatalError ( 'EMMC:' , ' structure file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the mcnl fields mcnl % stdout = stdout mcnl % numsx = numsx mcnl % globalworkgrpsz = globalworkgrpsz mcnl % num_el = num_el mcnl % totnum_el = totnum_el mcnl % sig = sig mcnl % omega = omega mcnl % EkeV = EkeV mcnl % Ehistmin = Ehistmin mcnl % Ebinsize = Ebinsize mcnl % depthmax = depthmax mcnl % depthstep = depthstep mcnl % MCmode = MCmode mcnl % xtalname_film = xtalname_film mcnl % xtalname_subs = xtalname_subs mcnl % dataname = dataname mcnl % mode = mode mcnl % filmthickness = filmthickness mcnl % filmstep = filmstep end subroutine GetMCCLMultiLayerNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetDisorientationsNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill mcnl structure (used by EMDisorientations.f90) ! !> @param nmlfile namelist file name !> @param emnl name list structure ! !> @date 06/24/16  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine GetDisorientationsNameList ( nmlfile , emnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetDisorientationsNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( DisorientationsNameListType ), INTENT ( INOUT ) :: emnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: pgnum integer ( kind = irg ) :: pgnum2 character ( fnlen ) :: inputfile character ( fnlen ) :: outputfile ! define the IO namelist to facilitate passing variables to the program. namelist / Disorientations / pgnum , pgnum2 , inputfile , outputfile ! set the input parameters to default values pgnum = 32 ! pgnum2 = 32 ! inputfile = 'undefined' ! default filename for input file outputfile = 'undefined' ! default filename for input file if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = Disorientations ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( inputfile ). eq . 'undefined' ) then call FatalError ( ' EMDisorientations' , ' input file name is undefined in ' // nmlfile ) end if if ( trim ( outputfile ). eq . 'undefined' ) then call FatalError ( ' EMDisorientations' , ' output file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields emnl % pgnum = pgnum emnl % pgnum2 = pgnum2 emnl % inputfile = inputfile emnl % outputfile = outputfile end subroutine GetDisorientationsNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetAverageOrientationNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill mcnl structure (used by EMAverageOrient.f90) ! !> @param nmlfile namelist file name !> @param emnl name list structure ! !> @date 06/24/16  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine GetAverageOrientationNameList ( nmlfile , emnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetAverageOrientationNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( AverageOrientationNameListType ), INTENT ( INOUT ) :: emnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: nmuse integer ( kind = irg ) :: reldisx integer ( kind = irg ) :: reldisy logical :: oldformat character ( fnlen ) :: dotproductfile character ( fnlen ) :: averagectffile character ( fnlen ) :: averagetxtfile character ( fnlen ) :: disorientationmap ! define the IO namelist to facilitate passing variables to the program. namelist / AverageOrientation / nmuse , dotproductfile , averagectffile , oldformat , averagetxtfile , & reldisx , reldisy , disorientationmap ! set the input parameters to default values (except for xtalname, which must be present) nmuse = 10 ! number of near-matches to use reldisx = 0 ! x-coordinate for relative disorientation map reldisy = 0 ! y-coordinate for relative disorientation map oldformat = . FALSE . ! switch for older format of dot product files dotproductfile = 'undefined' ! default filename for input dotproduct file (HDF5) averagectffile = 'undefined' ! default filename for output ctf file averagetxtfile = 'undefined' ! default filename for output txt file (only with oldformat=.TRUE. disorientationmap = 'undefined' ! default filename for relative disorientation map file if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = AverageOrientation ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( dotproductfile ). eq . 'undefined' ) then call FatalError ( ' EMAverageOrient' , ' dotproduct file name is undefined in ' // nmlfile ) end if if ( oldformat . eqv .. TRUE .) then if ( trim ( averagetxtfile ). eq . 'undefined' ) then call FatalError ( ' EMAverageOrient' , ' txt output file name is undefined in ' // nmlfile ) end if else if ( trim ( averagectffile ). eq . 'undefined' ) then call FatalError ( ' EMAverageOrient' , ' ctf output file name is undefined in ' // nmlfile ) end if end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields emnl % nmuse = nmuse emnl % reldisx = reldisx emnl % reldisy = reldisy emnl % oldformat = oldformat emnl % dotproductfile = dotproductfile emnl % averagectffile = averagectffile emnl % averagetxtfile = averagetxtfile emnl % disorientationmap = disorientationmap end subroutine GetAverageOrientationNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetOrientationSimilarityNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill mcnl structure (used by EMOrientationSimilarity.f90) ! !> @param nmlfile namelist file name !> @param emnl name list structure ! !> @date 07/29/16  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine GetOrientationSimilarityNameList ( nmlfile , emnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetOrientationSimilarityNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( OrientationSimilarityNameListType ), INTENT ( INOUT ) :: emnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: nmuse character ( fnlen ) :: dotproductfile character ( fnlen ) :: osmtiff ! define the IO namelist to facilitate passing variables to the program. namelist / OrientationSimilarity / nmuse , dotproductfile , osmtiff ! set the input parameters to default values (except for xtalname, which must be present) nmuse = 10 ! number of near-matches to use dotproductfile = 'undefined' ! default filename for input dotproduct file (HDF5) osmtiff = 'undefined' ! default filename for input dotproduct file (HDF5) if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = OrientationSimilarity ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( dotproductfile ). eq . 'undefined' ) then call FatalError ( ' EMOrientationSimilarity' , ' dotproduct file name is undefined in ' // nmlfile ) end if if ( trim ( osmtiff ). eq . 'undefined' ) then call FatalError ( ' EMOrientationSimilarity' , ' osm.tiff output file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields emnl % nmuse = nmuse emnl % dotproductfile = dotproductfile emnl % osmtiff = osmtiff end subroutine GetOrientationSimilarityNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetKAMNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill mcnl structure (used by EMOrientationSimilarity.f90) ! !> @param nmlfile namelist file name !> @param emnl name list structure ! !> @date 07/29/16  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine GetKAMNameList ( nmlfile , emnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetKAMNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( KAMNameListType ), INTENT ( INOUT ) :: emnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . real ( kind = sgl ) :: kamcutoff integer ( kind = irg ) :: orav character ( fnlen ) :: dotproductfile character ( fnlen ) :: kamtiff ! define the IO namelist to facilitate passing variables to the program. namelist / KAM / kamcutoff , orav , dotproductfile , kamtiff ! set the input parameters to default values (except for xtalname, which must be present) kamcutoff = 5.0 ! number of near-matches to use orav = 0 ! perform orientation average first ? dotproductfile = 'undefined' ! default filename for input dotproduct file (HDF5) kamtiff = 'undefined' ! default filename for input dotproduct file (HDF5) if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = KAM ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( dotproductfile ). eq . 'undefined' ) then call FatalError ( ' EMKAM' , ' dotproduct file name is undefined in ' // nmlfile ) end if if ( trim ( kamtiff ). eq . 'undefined' ) then call FatalError ( ' EMKAM' , ' kam.tiff output file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields emnl % kamcutoff = kamcutoff emnl % orav = orav emnl % dotproductfile = dotproductfile emnl % kamtiff = kamtiff end subroutine GetKAMNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetDvsDNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill mcnl structure (used by EMOrientationSimilarity.f90) ! !> @param nmlfile namelist file name !> @param emnl name list structure ! !> @date 07/29/16  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine GetDvsDNameList ( nmlfile , emnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetDvsDNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( DvsDNameListType ), INTENT ( INOUT ) :: emnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: nmuse real ( kind = sgl ) :: maxdis real ( kind = sgl ) :: minang real ( kind = sgl ) :: maxang character ( fnlen ) :: dotproductfile character ( fnlen ) :: outfile character ( fnlen ) :: povfile character ( fnlen ) :: xtalfile ! define the IO namelist to facilitate passing variables to the program. namelist / DvsD / nmuse , maxdis , minang , maxang , dotproductfile , outfile , povfile , xtalfile ! set the input parameters to default values (except for xtalname, which must be present) nmuse = 10 maxdis = 3.0 minang = 1 0.0 maxang = 2 0.0 dotproductfile = 'undefined' ! default filename for input dotproduct file (HDF5) outfile = 'undefined' ! default filename for output file (txt) povfile = 'undefined' ! default filename for output file (txt) xtalfile = 'undefined' ! default filename for output file (txt) if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = DvsD ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalfile ). eq . 'undefined' ) then call FatalError ( ' EMDvsD' , ' xtal file name is undefined in ' // nmlfile ) end if if ( trim ( dotproductfile ). eq . 'undefined' ) then call FatalError ( ' EMDvsD' , ' dotproduct file name is undefined in ' // nmlfile ) end if if ( trim ( outfile ). eq . 'undefined' ) then call FatalError ( ' EMDvsD' , ' outfile output file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields emnl % nmuse = nmuse emnl % maxdis = maxdis emnl % minang = minang emnl % maxang = maxang emnl % dotproductfile = dotproductfile emnl % outfile = outfile emnl % povfile = povfile emnl % xtalfile = xtalfile end subroutine GetDvsDNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetEBSDMasterNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill mcnl structure (used by EMEBSDmaster.f90) ! !> @param nmlfile namelist file name !> @param emnl EBSD master name list structure ! !> @date 06/19/14  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine GetEBSDMasterNameList ( nmlfile , emnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetEBSDMasterNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( EBSDMasterNameListType ), INTENT ( INOUT ) :: emnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: npx integer ( kind = irg ) :: Esel integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: dmin character ( fnlen ) :: energyfile logical :: restart logical :: uniform ! define the IO namelist to facilitate passing variables to the program. namelist / EBSDmastervars / dmin , npx , nthreads , energyfile , Esel , restart , uniform ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 npx = 500 ! Nx pixels (total = 2Nx+1) nthreads = 1 Esel = - 1 ! selected energy value for single energy run dmin = 0.025 ! smallest d-spacing to include in dynamical matrix [nm] energyfile = 'undefined' ! default filename for z_0(E_e) data from EMMC Monte Carlo simulations restart = . FALSE . ! when .TRUE. an existing file will be assumed uniform = . FALSE . ! when .TRUE., the output master patterns will contain 1.0 everywhere if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = EBSDmastervars ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( energyfile ). eq . 'undefined' ) then call FatalError ( 'EMEBSDmaster:' , ' energy file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields emnl % stdout = stdout emnl % npx = npx emnl % Esel = Esel emnl % nthreads = nthreads emnl % dmin = dmin emnl % energyfile = energyfile emnl % outname = energyfile ! as off release 3.1, outname must be the same as energyfile emnl % restart = restart emnl % uniform = uniform end subroutine GetEBSDMasterNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetTKDMasterNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill mcnl structure (used by EMTKDmaster.f90) ! !> @param nmlfile namelist file name !> @param emnl TKD master name list structure ! !> @date 01/16/17  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine GetTKDMasterNameList ( nmlfile , emnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetTKDMasterNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( TKDMasterNameListType ), INTENT ( INOUT ) :: emnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: npx integer ( kind = irg ) :: Esel integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: dmin character ( fnlen ) :: energyfile logical :: restart logical :: uniform ! define the IO namelist to facilitate passing variables to the program. namelist / TKDmastervars / dmin , npx , nthreads , energyfile , Esel , restart , uniform ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 npx = 500 ! Nx pixels (total = 2Nx+1) nthreads = 1 Esel = - 1 ! selected energy value for single energy run dmin = 0.025 ! smallest d-spacing to include in dynamical matrix [nm] energyfile = 'undefined' ! default filename for z_0(E_e) data from EMMC Monte Carlo simulations restart = . FALSE . ! when .TRUE. an existing file will be assumed uniform = . FALSE . ! when .TRUE., the output master patterns will contain 1.0 everywhere if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = TKDmastervars ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( energyfile ). eq . 'undefined' ) then call FatalError ( 'EMTKDmaster:' , ' energy file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields emnl % stdout = stdout emnl % npx = npx emnl % Esel = Esel emnl % nthreads = nthreads emnl % dmin = dmin emnl % energyfile = energyfile emnl % outname = energyfile ! as off release 3.1, outname must be the same as energyfile emnl % restart = restart emnl % uniform = uniform end subroutine GetTKDMasterNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetEBSDMasterOpenCLNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill mcnl structure (used by EMEBSDmasterOpenCL.f90) ! !> @param nmlfile namelist file name !> @param emnl EBSD master name list structure ! !> @date 12/10/16  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine GetEBSDMasterOpenCLNameList ( nmlfile , emnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetEBSDMasterOpenCLNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( EBSDMasterOpenCLNameListType ), INTENT ( INOUT ) :: emnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: npx integer ( kind = irg ) :: Esel integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: platid integer ( kind = irg ) :: devid integer ( kind = irg ) :: globalworkgrpsz real ( kind = sgl ) :: dmin character ( fnlen ) :: energyfile logical :: restart logical :: uniform ! define the IO namelist to facilitate passing variables to the program. namelist / EBSDmastervars / stdout , dmin , npx , platid , devid , globalworkgrpsz , energyfile , restart , uniform , Esel , nthreads ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 npx = 500 ! Nx pixels (total = 2Nx+1) nthreads = 1 platid = 1 devid = 1 globalworkgrpsz = 150 Esel = - 1 ! selected energy value for single energy run dmin = 0.025 ! smallest d-spacing to include in dynamical matrix [nm] energyfile = 'undefined' ! default filename for z_0(E_e) data from EMMC Monte Carlo simulations restart = . FALSE . ! when .TRUE. an existing file will be assumed uniform = . FALSE . ! when .TRUE., the output master patterns will contain 1.0 everywhere if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = EBSDmastervars ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( energyfile ). eq . 'undefined' ) then call FatalError ( 'EMEBSDmaster:' , ' energy file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields emnl % stdout = stdout emnl % npx = npx emnl % Esel = Esel emnl % nthreads = nthreads emnl % platid = platid emnl % devid = devid emnl % globalworkgrpsz = globalworkgrpsz emnl % dmin = dmin emnl % energyfile = energyfile emnl % restart = restart emnl % uniform = uniform end subroutine GetEBSDMasterOpenCLNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetEBSDclusterNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill emnl structure (used by EMEBSDcluster.f90) ! !> @param nmlfile namelist file name !> @param emnl EBSD master name list structure ! !> @date 06/19/14  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine GetEBSDclusterNameList ( nmlfile , emnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetEBSDclusterNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( EBSDclusterNameListType ), INTENT ( INOUT ) :: emnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: NClusters , NIterations , binfactor character ( fnlen ) :: inputfilename , groupname , datasetname ! define the IO namelist to facilitate passing variables to the program. namelist / EBSDclustervars / NClusters , NIterations , binfactor , inputfilename , groupname , datasetname ! set the input parameters to default values (except for xtalname, which must be present) NClusters = 100 ! initial number of clusters to look for NIterations = 50 ! number of iterations in K-means algorithm binfactor = 1 ! no binning by default inputfilename = 'undefined' ! default filename for HDF5 data input file groupname = 'undefined' ! default groupname for EBSD data datasetname = 'undefined' ! default dataset name if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = EBSDclustervars ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( inputfilename ). eq . 'undefined' ) then call FatalError ( 'EMEBSDcluster:' , ' HDF5 input data file name is undefined in ' // nmlfile ) end if if ( trim ( groupname ). eq . 'undefined' ) then call FatalError ( 'EMEBSDcluster:' , ' Data group name is undefined in ' // nmlfile ) end if if ( trim ( datasetname ). eq . 'undefined' ) then call FatalError ( 'EMEBSDcluster:' , ' Data set name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields emnl % NClusters = NClusters emnl % NIterations = NIterations emnl % binfactor = binfactor emnl % inputfilename = inputfilename emnl % groupname = groupname emnl % datasetname = datasetname ! parameters that are not in the nml file emnl % NScanColumns = 0 emnl % NScanRows = 0 end subroutine GetEBSDclusterNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetECPMasterNameList ! !> @author Saransh Singh/Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill mcnl structure (used by EMECPmaster.f90) ! !> @param nmlfile namelist file name !> @param emnl ECP master name list structure ! !> @date 06/19/14  SS 1.0 new routine !> @date 08/12/15 MDG 1.1 correction of type for startthick and fn(3) !> @date 09/15/15  SS 1.2 clean up of the subroutine !-------------------------------------------------------------------------- recursive subroutine GetECPMasterNameList ( nmlfile , ecpnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetECPMasterNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( ECPMasterNameListType ), INTENT ( INOUT ) :: ecpnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: npx integer ( kind = irg ) :: Esel integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: dmin character ( fnlen ) :: compmode character ( fnlen ) :: energyfile ! define the IO namelist to facilitate passing variables to the program. namelist / ECPmastervars / stdout , dmin , compmode , & energyfile , Esel , npx , nthreads ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 Esel = - 1 ! selected energy value for single energy run nthreads = 1 dmin = 0.04 ! smallest d-spacing to include in dynamical matrix [nm] npx = 256 compmode = 'Blochwv' energyfile = 'undefined' ! default filename for z_0(E_e) data from EMMC Monte Carlo simulations if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = ECPmastervars ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( energyfile ). eq . 'undefined' ) then call FatalError ( 'EMECPmaster:' , ' energy file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields ecpnl % stdout = stdout ecpnl % Esel = Esel ecpnl % npx = npx ecpnl % nthreads = nthreads ecpnl % dmin = dmin ecpnl % compmode = compmode ecpnl % energyfile = energyfile ecpnl % outname = energyfile end subroutine GetECPMasterNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetreflectorNameList ! !> @author Marc De Graef ! !> @brief read reflector namelist for EMreflectors program ! !> @param nmlfile namelist file name !> @param rnl reflect name list structure ! !> @date 05/31/16 MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine GetreflectorNameList ( nmlfile , rnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetreflectorNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( reflectorNameListType ), INTENT ( INOUT ) :: rnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: numphi integer ( kind = irg ) :: numtheta real ( kind = sgl ) :: dmin character ( fnlen ) :: masterfile character ( fnlen ) :: energyfile ! define the IO namelist to facilitate passing variables to the program. namelist / EBSDreflectors / numphi , numtheta , dmin , masterfile , energyfile ! set the input parameters to default values (except for xtalname, which must be present) numphi = 360 numtheta = 10 dmin = 0.05 ! smallest d-spacing to include in dynamical matrix [nm] masterfile = 'undefined' ! default filename for z_0(E_e) data from EMMC Monte Carlo simulations energyfile = 'undefined' ! default filename for z_0(E_e) data from EMMC Monte Carlo simulations if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = EBSDreflectors ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( energyfile ). eq . 'undefined' ) then call FatalError ( 'EMreflectors:' , ' energy file name is undefined in ' // nmlfile ) end if if ( trim ( masterfile ). eq . 'undefined' ) then call FatalError ( 'EMreflectors:' , ' master file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields rnl % numphi = numphi rnl % numtheta = numtheta rnl % dmin = dmin rnl % masterfile = masterfile rnl % energyfile = energyfile end subroutine GetreflectorNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetkinematicalNameList ! !> @author Marc De Graef ! !> @brief read reflector namelist for EMreflectors program ! !> @param nmlfile namelist file name !> @param rnl reflect name list structure ! !> @date 05/31/16 MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine GetkinematicalNameList ( nmlfile , knl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetkinematicalNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( kinematicalNameListType ), INTENT ( INOUT ) :: knl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . real ( kind = sgl ) :: dmin real ( kind = sgl ) :: thr real ( kind = sgl ) :: voltage character ( fnlen ) :: xtalname character ( fnlen ) :: datafile ! define the IO namelist to facilitate passing variables to the program. namelist / EMkinematical / dmin , voltage , thr , xtalname , datafile ! set the input parameters to default values (except for xtalname, which must be present) dmin = 0.05 ! smallest d-spacing to include in dynamical matrix [nm] thr = 1.0 ! smallest |structurefactor|&#94;2 to include voltage = 3000 0.0 ! microscope voltage [V] datafile = 'undefined' ! output file name xtalname = 'undefined' ! structure file name if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = EMkinematical ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'EMkinematical:' , '  crystal structure file name is undefined in ' // nmlfile ) end if if ( trim ( datafile ). eq . 'undefined' ) then call FatalError ( 'EMkinematical:' , ' output file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields knl % dmin = dmin knl % thr = thr knl % voltage = voltage knl % xtalname = xtalname knl % datafile = datafile end subroutine GetkinematicalNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetEBSDdetparmscanNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill enl structure (used by EMEBSD.f90) ! !> @param nmlfile namelist file name !> @param enl EBSD name list structure ! !> @date 06/23/14  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine GetEBSDdetparmscanNameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetEBSDdetparmscanNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( EBSDdetparmscanNameListType ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: numdetparm integer ( kind = irg ) :: numeuler real ( kind = sgl ) :: DetParms ( 3 ) real ( kind = sgl ) :: Eulertriplet ( 3 ) real ( kind = sgl ) :: DetParmstepsize ( 3 ) real ( kind = sgl ) :: Cubochoricstepsize ( 3 ) ! define the IO namelist to facilitate passing variables to the program. namelist / EBSDscandata / numdetparm , numeuler , DetParms , Eulertriplet , DetParmstepsize , Cubochoricstepsize ! set the input parameters to default values (except for xtalname, which must be present) numdetparm = 10 ! number of detector parameter steps (2x+1) numeuler = 10 ! number of Euler angle steps (2x+1) DetParms = ( / 0.0 , 0.0 , 1500 0.0 / ) Eulertriplet = ( / 0.0 , 0.0 , 0.0 / ) DetParmstepsize = ( / 1.0 , 1.0 , 10 0.0 / ) Cubochoricstepsize = ( / 0.01 , 0.01 , 0.01 / ) if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = EBSDscandata ) close ( UNIT = dataunit , STATUS = 'keep' ) end if ! if we get here, then all appears to be ok, and we need to fill in the enl fields enl % numdetparm = numdetparm enl % numeuler = numeuler enl % DetParms = DetParms enl % DetParmstepsize = DetParmstepsize enl % Eulertriplet = Eulertriplet enl % Cubochoricstepsize = Cubochoricstepsize end subroutine GetEBSDdetparmscanNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetEBSDNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill enl structure (used by EMEBSD.f90) ! !> @param nmlfile namelist file name !> @param enl EBSD name list structure ! !> @date 06/23/14  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine GetEBSDNameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetEBSDNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( EBSDNameListType ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numsx integer ( kind = irg ) :: numsy integer ( kind = irg ) :: binning integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: energyaverage real ( kind = sgl ) :: L real ( kind = sgl ) :: thetac real ( kind = sgl ) :: delta real ( kind = sgl ) :: xpc real ( kind = sgl ) :: ypc real ( kind = sgl ) :: omega real ( kind = sgl ) :: energymin real ( kind = sgl ) :: energymax real ( kind = sgl ) :: gammavalue real ( kind = sgl ) :: alphaBD real ( kind = sgl ) :: axisangle ( 4 ) real ( kind = dbl ) :: beamcurrent real ( kind = dbl ) :: dwelltime character ( 1 ) :: maskpattern character ( 1 ) :: spatialaverage character ( 3 ) :: scalingmode character ( 3 ) :: eulerconvention character ( 3 ) :: outputformat character ( fnlen ) :: anglefile character ( fnlen ) :: masterfile character ( fnlen ) :: energyfile character ( fnlen ) :: datafile ! define the IO namelist to facilitate passing variables to the program. namelist / EBSDdata / stdout , L , thetac , delta , numsx , numsy , xpc , ypc , anglefile , eulerconvention , masterfile , & energyfile , datafile , beamcurrent , dwelltime , energymin , energymax , binning , gammavalue , alphaBD , & scalingmode , axisangle , nthreads , outputformat , maskpattern , energyaverage , omega , spatialaverage ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 numsx = 640 ! [dimensionless] numsy = 480 ! [dimensionless] binning = 1 ! binning mode  (1, 2, 4, or 8) L = 2000 0.0 ! [microns] nthreads = 1 ! number of OpenMP threads energyaverage = 0 ! apply energy averaging (1) or not (0); useful for dictionary computations thetac = 0.0 ! [degrees] delta = 2 5.0 ! [microns] xpc = 0.0 ! [pixels] ypc = 0.0 ! [pixels] omega = 0.0 energymin = 1 5.0 ! minimum energy to consider energymax = 3 0.0 ! maximum energy to consider gammavalue = 1.0 ! gamma factor alphaBD = 0.0 ! transfer lens barrel distortion parameter axisangle = ( / 0.0 , 0.0 , 1.0 , 0.0 / ) ! no additional axis angle rotation beamcurrent = 1 4.513D0 ! beam current (actually emission current) in nano ampere dwelltime = 10 0.0D0 ! in microseconds maskpattern = 'n' ! 'y' or 'n' to include a circular mask scalingmode = 'not' ! intensity selector ('lin', 'gam', or 'not') eulerconvention = 'tsl' ! convention for the first Euler angle ['tsl' or 'hkl'] outputformat = 'gui' ! output format for 'bin' or 'gui' use anglefile = 'undefined' ! filename masterfile = 'undefined' ! filename energyfile = 'undefined' ! name of file that contains energy histograms for all scintillator pixels (output from MC program) datafile = 'undefined' ! output file name spatialaverage = 'n' if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = EBSDdata ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( energyfile ). eq . 'undefined' ) then call FatalError ( 'EMEBSD:' , ' energy file name is undefined in ' // nmlfile ) end if if ( trim ( anglefile ). eq . 'undefined' ) then call FatalError ( 'EMEBSD:' , ' angle file name is undefined in ' // nmlfile ) end if if ( trim ( masterfile ). eq . 'undefined' ) then call FatalError ( 'EMEBSD:' , ' master pattern file name is undefined in ' // nmlfile ) end if if ( trim ( datafile ). eq . 'undefined' ) then call FatalError ( 'EMEBSD:' , ' output file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields enl % stdout = stdout enl % numsx = numsx enl % numsy = numsy enl % binning = binning enl % L = L enl % nthreads = nthreads enl % energyaverage = energyaverage enl % thetac = thetac enl % delta = delta enl % xpc = xpc enl % ypc = ypc enl % energymin = energymin enl % energymax = energymax enl % gammavalue = gammavalue enl % alphaBD = alphaBD enl % axisangle = axisangle enl % beamcurrent = beamcurrent enl % dwelltime = dwelltime enl % maskpattern = maskpattern enl % scalingmode = scalingmode enl % eulerconvention = eulerconvention enl % outputformat = outputformat enl % anglefile = anglefile enl % masterfile = masterfile enl % energyfile = energyfile enl % datafile = datafile enl % omega = omega enl % spatialaverage = spatialaverage end subroutine GetEBSDNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetTKDNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill enl structure (used by EMTKD.f90) ! !> @param nmlfile namelist file name !> @param enl TKD name list structure ! !> @date 05/09/17  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine GetTKDNameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetTKDNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( TKDNameListType ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numsx integer ( kind = irg ) :: numsy integer ( kind = irg ) :: binning integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: energyaverage real ( kind = sgl ) :: L real ( kind = sgl ) :: thetac real ( kind = sgl ) :: delta real ( kind = sgl ) :: xpc real ( kind = sgl ) :: ypc real ( kind = sgl ) :: omega real ( kind = sgl ) :: energymin real ( kind = sgl ) :: energymax real ( kind = sgl ) :: gammavalue real ( kind = sgl ) :: alphaBD real ( kind = sgl ) :: axisangle ( 4 ) real ( kind = dbl ) :: beamcurrent real ( kind = dbl ) :: dwelltime character ( 1 ) :: maskpattern character ( 1 ) :: spatialaverage character ( 3 ) :: scalingmode character ( 3 ) :: eulerconvention character ( 3 ) :: outputformat character ( fnlen ) :: anglefile character ( fnlen ) :: masterfile character ( fnlen ) :: energyfile character ( fnlen ) :: datafile ! define the IO namelist to facilitate passing variables to the program. namelist / TKDdata / stdout , L , thetac , delta , numsx , numsy , xpc , ypc , anglefile , eulerconvention , masterfile , & energyfile , datafile , beamcurrent , dwelltime , energymin , energymax , binning , gammavalue , alphaBD , & scalingmode , axisangle , nthreads , outputformat , maskpattern , energyaverage , omega , spatialaverage ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 numsx = 640 ! [dimensionless] numsy = 480 ! [dimensionless] binning = 1 ! binning mode  (1, 2, 4, or 8) L = 2000 0.0 ! [microns] nthreads = 1 ! number of OpenMP threads energyaverage = 0 ! apply energy averaging (1) or not (0); useful for dictionary computations thetac = 0.0 ! [degrees] delta = 2 5.0 ! [microns] xpc = 0.0 ! [pixels] ypc = 0.0 ! [pixels] omega = 0.0 energymin = 1 5.0 ! minimum energy to consider energymax = 3 0.0 ! maximum energy to consider gammavalue = 1.0 ! gamma factor alphaBD = 0.0 ! transfer lens barrel distortion parameter axisangle = ( / 0.0 , 0.0 , 1.0 , 0.0 / ) ! no additional axis angle rotation beamcurrent = 10 0.0D0 ! beam current (actually emission current) in nano ampere dwelltime = 10 0.0D0 ! in microseconds maskpattern = 'n' ! 'y' or 'n' to include a circular mask scalingmode = 'not' ! intensity selector ('lin', 'gam', or 'not') eulerconvention = 'tsl' ! convention for the first Euler angle ['tsl' or 'hkl'] outputformat = 'gui' ! output format for 'bin' or 'gui' use anglefile = 'undefined' ! filename masterfile = 'undefined' ! filename energyfile = 'undefined' ! name of file that contains energy histograms for all scintillator pixels (output from MC program) datafile = 'undefined' ! output file name spatialaverage = 'n' if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = TKDdata ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( energyfile ). eq . 'undefined' ) then call FatalError ( 'GetTKDNameList:' , ' energy file name is undefined in ' // nmlfile ) end if if ( trim ( anglefile ). eq . 'undefined' ) then call FatalError ( 'GetTKDNameList:' , ' angle file name is undefined in ' // nmlfile ) end if if ( trim ( masterfile ). eq . 'undefined' ) then call FatalError ( 'GetTKDNameList:' , ' master pattern file name is undefined in ' // nmlfile ) end if if ( trim ( datafile ). eq . 'undefined' ) then call FatalError ( 'GetTKDNameList:' , ' output file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields enl % stdout = stdout enl % numsx = numsx enl % numsy = numsy enl % binning = binning enl % L = L enl % nthreads = nthreads enl % energyaverage = energyaverage enl % thetac = thetac enl % delta = delta enl % xpc = xpc enl % ypc = ypc enl % energymin = energymin enl % energymax = energymax enl % gammavalue = gammavalue enl % alphaBD = alphaBD enl % axisangle = axisangle enl % beamcurrent = beamcurrent enl % dwelltime = dwelltime enl % maskpattern = maskpattern enl % scalingmode = scalingmode enl % eulerconvention = eulerconvention enl % outputformat = outputformat enl % anglefile = anglefile enl % masterfile = masterfile enl % energyfile = energyfile enl % datafile = datafile enl % omega = omega enl % spatialaverage = spatialaverage end subroutine GetTKDNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetEBSDoverlapNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill enl structure (used by EMEBSDoverlap.f90) ! !> @param nmlfile namelist file name !> @param enl EBSD name list structure ! !> @date 04/29/15  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine GetEBSDoverlapNameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetEBSDoverlapNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( EBSDoverlapNameListType ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: PatternAxisA ( 3 ) integer ( kind = irg ) :: HorizontalAxisA ( 3 ) real ( kind = sgl ) :: tA ( 3 ) real ( kind = sgl ) :: tB ( 3 ) real ( kind = sgl ) :: gA ( 3 ) real ( kind = sgl ) :: gB ( 3 ) real ( kind = sgl ) :: fracA character ( fnlen ) :: masterfileA character ( fnlen ) :: masterfileB character ( fnlen ) :: datafile ! define the IO namelist to facilitate passing variables to the program. namelist / EBSDdata / stdout , PatternAxisA , tA , tB , gA , gB , fracA , masterfileA , masterfileB , datafile , HorizontalAxisA ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 PatternAxisA = ( / 0 , 0 , 1 / ) ! center axis for output pattern HorizontalAxisA = ( / 1 , 0 , 0 / ) ! horizontal axis for output pattern tA = ( / 0.0 , 0.0 , 1.0 / ) ! direction vector in crystal A tB = ( / 0.0 , 0.0 , 1.0 / ) ! direction vector in crystal B gA = ( / 1.0 , 0.0 , 0.0 / ) ! plane normal in crystal A gB = ( / 1.0 , 0.0 , 0.0 / ) ! plane normal in crystal B fracA = 0.5 ! volume fraction of phase A masterfileA = 'undefined' ! filename masterfileB = 'undefined' ! filename datafile = 'undefined' ! output file name if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = EBSDdata ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( masterfileA ). eq . 'undefined' ) then call FatalError ( 'EMEBSD:' , ' master pattern file name A is undefined in ' // nmlfile ) end if if ( trim ( masterfileB ). eq . 'undefined' ) then call FatalError ( 'EMEBSD:' , ' master pattern file name B is undefined in ' // nmlfile ) end if if ( trim ( datafile ). eq . 'undefined' ) then call FatalError ( 'EMEBSD:' , ' output file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields enl % stdout = stdout enl % PatternAxisA = PatternAxisA enl % HorizontalAxisA = HorizontalAxisA enl % tA = tA enl % tB = tB enl % gA = gA enl % gB = gB enl % fracA = fracA enl % masterfileA = masterfileA enl % masterfileB = masterfileB enl % datafile = datafile end subroutine GetEBSDoverlapNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetECPZANameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill ecpnl structure (used by EMECPZA.f90) ! !> @param nmlfile namelist file name !> @param ecpnl name list structure ! !> @date 01/25/17 MDG 1.0 new structure !-------------------------------------------------------------------------- recursive subroutine GetECPZANameList ( nmlfile , ecpnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetECPZANameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( ECPZANameListType ), INTENT ( INOUT ) :: ecpnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: fn ( 3 ) integer ( kind = irg ) :: k ( 3 ) integer ( kind = irg ) :: npix integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: dmin real ( kind = sgl ) :: ktmax character ( 1 ) :: maskpattern character ( fnlen ) :: energyfile character ( fnlen ) :: outname namelist / ECPZAlist / k , fn , dmin , ktmax , npix , outname , nthreads , maskpattern , energyfile ! default values k = ( / 0 , 0 , 1 / ) ! beam direction [direction indices] fn = ( / 0 , 0 , 1 / ) ! foil normal [direction indices] dmin = 0.05 ! smallest d-spacing to include in dynamical matrix [nm] ktmax = 0.0 ! beam convergence in units of |g_a| npix = 256 ! output arrays will have size npix x npix nthreads = 1 maskpattern = 'n' outname = 'undefined' ! output filename energyfile = 'undefined' ! output filename if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = ECPZAlist ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( outname ). eq . 'undefined' ) then call FatalError ( 'EMECPZA:' , ' output file name is undefined in ' // nmlfile ) end if if ( trim ( energyfile ). eq . 'undefined' ) then call FatalError ( 'EMECPZA:' , ' Monte Carlo input file name is undefined in ' // nmlfile ) end if end if ecpnl % fn = fn ecpnl % k = k ecpnl % npix = npix ecpnl % dmin = dmin ecpnl % ktmax = ktmax ecpnl % outname = outname ecpnl % energyfile = energyfile ecpnl % nthreads = nthreads ecpnl % maskpattern = maskpattern end subroutine GetECPZANameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetECPNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill ecpnl structure (used by EMECP.f90) ! !> @param nmlfile namelist file name !> @param knl Kossel name list structure ! !> @date 06/13/14  MDG 1.0 new routine !> @date 11/25/14  MDG 2.0 added parameters for film on substrate mode !> @date 10/15/15 SS  1.2 changes for release !-------------------------------------------------------------------------- recursive subroutine GetECPNameList ( nmlfile , ecpnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetECPNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( ECPNameListType ), INTENT ( INOUT ) :: ecpnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: fn_f ( 3 ) integer ( kind = irg ) :: fn_s ( 3 ) integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: npix integer ( kind = irg ) :: gF ( 3 ) integer ( kind = irg ) :: gS ( 3 ) integer ( kind = irg ) :: tF ( 3 ) integer ( kind = irg ) :: tS ( 3 ) real ( kind = sgl ) :: dmin real ( kind = sgl ) :: thetac real ( kind = sgl ) :: filmthickness character ( fnlen ) :: xtalname character ( fnlen ) :: xtalname2 character ( fnlen ) :: energyfile character ( fnlen ) :: filmfile character ( fnlen ) :: subsfile character ( fnlen ) :: masterfile character ( fnlen ) :: datafile character ( 1 ) :: maskpattern character ( fnlen ) :: anglefile character ( 3 ) :: eulerconvention integer ( kind = irg ) :: numangle_anglefile real ( kind = sgl ) :: gammavalue character ( 3 ) :: outputformat real ( kind = dbl ) :: sampletilt real ( kind = sgl ) :: workingdistance real ( kind = sgl ) :: Rin real ( kind = sgl ) :: Rout ! namelist /ECPlist/ stdout, xtalname, voltage, k, fn, dmin, distort, abcdist, albegadist, ktmax, & namelist / ECPlist / stdout , xtalname , xtalname2 , fn_f , fn_s , dmin , filmthickness , anglefile , & nthreads , thetac , npix , maskpattern , eulerconvention , Rin , Rout , & gF , gS , tF , tS , energyfile , filmfile , subsfile , masterfile , datafile , & numangle_anglefile , gammavalue , outputformat , sampletilt , workingdistance ! default values stdout = 6 ! standard output fn_f = ( / 0 , 0 , 1 / ) ! beam direction [direction indices] fn_s = ( / 0 , 0 , 1 / ) ! foil normal [direction indices] gF = ( / 0 , 0 , 0 / ) ! plane normal in film gS = ( / 0 , 0 , 0 / ) ! plane normal in substrate tF = ( / 0 , 0 , 0 / ) ! direction in film tS = ( / 0 , 0 , 0 / ) ! direction in substrate npix = 200 ! number of pixels in final image (npix x npix) nthreads = 1 ! number of OpenMP threads dmin = 0.04 ! smallest d-spacing to include in dynamical matrix [nm] thetac = 0.0 ! beam convergence in mrad (either ktmax or thetac must be given) filmthickness = 0.0 ! 0.0 if there is no film xtalname = 'undefined' ! initial value to check that the keyword is present in the nml file xtalname2 = 'undefined' ! initial value for substrate structure name energyfile = 'undefined' filmfile = 'undefined' subsfile = 'undefined' masterfile = 'undefined' datafile = 'undefined' maskpattern = 'y' anglefile = 'undefined' eulerconvention = 'hkl' numangle_anglefile = 0 gammavalue = 1.0 outputformat = 'gui' sampletilt = 0.D0 Workingdistance = 1 3.0 Rin = 2.0 Rout = 6.0 if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = ECPlist ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'EMEECP:' , ' crystal file name is undefined in ' // nmlfile ) end if end if ecpnl % stdout = stdout ecpnl % fn_f = fn_f ecpnl % fn_s = fn_s ecpnl % gF = gF ecpnl % gS = gS ecpnl % tF = tF ecpnl % tS = tS ecpnl % npix = npix ecpnl % nthreads = nthreads ecpnl % dmin = dmin ecpnl % thetac = thetac ecpnl % filmthickness = filmthickness ecpnl % datafile = datafile ecpnl % xtalname = xtalname ecpnl % xtalname2 = xtalname2 ecpnl % energyfile = energyfile ecpnl % filmfile = filmfile ecpnl % subsfile = subsfile ecpnl % masterfile = masterfile ecpnl % maskpattern = maskpattern ecpnl % anglefile = anglefile ecpnl % numangle_anglefile = numangle_anglefile ecpnl % eulerconvention = eulerconvention ecpnl % gammavalue = gammavalue ecpnl % outputformat = outputformat ecpnl % sampletilt = sampletilt ecpnl % workingdistance = workingdistance ecpnl % Rin = Rin ecpnl % Rout = Rout end subroutine GetECPNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetLACBEDNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill lacbednl structure (used by EMLACBED.f90) ! !> @param nmlfile namelist file name !> @param lacbednl LACBED name list structure ! !> @date 07/01/14  MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine GetLACBEDNameList ( nmlfile , lacbednl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetLACBEDNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( LACBEDNameListType ), INTENT ( INOUT ) :: lacbednl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: k ( 3 ) integer ( kind = irg ) :: fn ( 3 ) integer ( kind = irg ) :: maxHOLZ integer ( kind = irg ) :: numthick integer ( kind = irg ) :: npix integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: voltage real ( kind = sgl ) :: dmin real ( kind = sgl ) :: convergence real ( kind = sgl ) :: startthick real ( kind = sgl ) :: thickinc real ( kind = sgl ) :: minten character ( fnlen ) :: xtalname character ( fnlen ) :: outname namelist / inputlist / stdout , xtalname , voltage , k , fn , dmin , convergence , minten , & nthreads , startthick , thickinc , numthick , outname , npix , maxHOLZ stdout = 6 ! standard output k = ( / 0 , 0 , 1 / ) ! beam direction [direction indices] fn = ( / 0 , 0 , 1 / ) ! foil normal [direction indices] maxHOLZ = 2 ! maximum HOLZ layer index to be used for the output file; note that his number ! does not affect the actual computations; it only determines which reflection ! families will end up in the output file numthick = 10 ! number of increments npix = 256 ! output arrays will have size npix x npix nthreads = 1 ! number of computational threads voltage = 20000 0.0 ! acceleration voltage [V] dmin = 0.025 ! smallest d-spacing to include in dynamical matrix [nm] convergence = 2 5.0 ! beam convergence angle [mrad] startthick = 1 0.0 ! starting thickness [nm] thickinc = 1 0.0 ! thickness increment minten = 1.0E-5 ! minimum intensity in diffraction disk to make it into the output file xtalname = 'undefined' ! initial value to check that the keyword is present in the nml file outname = 'lacbedout.data' ! output filename if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = inputlist ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'EMLACBED:' , ' structure file name is undefined in ' // nmlfile ) end if end if lacbednl % stdout = stdout lacbednl % k = k lacbednl % fn = fn lacbednl % maxHOLZ = maxHOLZ lacbednl % numthick = numthick lacbednl % npix = npix lacbednl % nthreads = nthreads lacbednl % voltage = voltage lacbednl % dmin = dmin lacbednl % convergence = convergence lacbednl % startthick = startthick lacbednl % thickinc = thickinc lacbednl % minten = minten lacbednl % xtalname = xtalname lacbednl % outname = outname end subroutine GetLACBEDNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetECPpatternNameList ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief read namelist file and fill mcnl structure (used by EMECPpattern.f90) ! !> @param nmlfile namelist file name !> @param emnl ECP name list structure ! !> @date 06/19/14  SS 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine GetECPpatternNameList ( nmlfile , ecpnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetECPpatternNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( ECPpatternNameListType ), INTENT ( INOUT ) :: ecpnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: npix real ( kind = sgl ) :: thetac real ( kind = sgl ) :: k ( 3 ) character ( fnlen ) :: masterfile character ( fnlen ) :: outname ! define the IO namelist to facilitate passing variables to the program. namelist / ECPvars / stdout , npix , masterfile , outname , thetac , k ! set the input parameters to default values (except for masterfile, which must be present) stdout = 6 npix = 256 thetac = 5.0 k = ( / 0.0 , 0.0 , 1.0 / ) masterfile = 'undefined' ! default filename for master data from EMECPmaster outname = 'ECP.data' ! default filename for final output if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = ECPvars ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( masterfile ). eq . 'undefined' ) then call FatalError ( 'EMECP:' , ' master file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields ecpnl % stdout = stdout ecpnl % npix = npix ecpnl % thetac = thetac ecpnl % k = k ecpnl % masterfile = masterfile ecpnl % outname = outname end subroutine GetECPpatternNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetPEDkinNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill pednl structure (used by EMpedKIN.f90) ! !> @param nmlfile namelist file name !> @param pednl PED name list structure ! !> @date 03/02/15 MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine GetPEDkinNameList ( nmlfile , pednl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetPEDkinNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( PEDkinNameListType ), INTENT ( INOUT ) :: pednl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: npix integer ( kind = irg ) :: ncubochoric integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: voltage real ( kind = sgl ) :: thickness real ( kind = sgl ) :: rnmpp real ( kind = sgl ) :: dmin character ( fnlen ) :: xtalname character ( fnlen ) :: outname ! define the IO namelist to facilitate passing variables to the program. namelist / PEDkinNameList / stdout , xtalname , voltage , npix , rnmpp , ncubochoric , nthreads , & thickness , outname , dmin ! set the input parameters to default values (except for xtalname, which must be present) xtalname = 'undefined' ! initial value to check that the keyword is present in the nml file stdout = 6 ! standard output voltage = 20000 0.0 ! acceleration voltage [V] nthreads = 1 ! number of OpenMP threads to start thickness = 1 0.0 ! sample thickness [nm] npix = 256 ! output arrays will have size npix x npix outname = 'pedout.data' ! output filename dmin = 0.04 ! smallest d-spacing [nm] ncubochoric = 100 ! number of samples along the cubochoric edge length rnmpp = 0.2 ! nm&#94;{-1} per pattern pixel if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = PEDkinNameList ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'EMPED:' , ' crystal structure file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the pednl fields pednl % xtalname = xtalname pednl % stdout = stdout pednl % voltage = voltage pednl % thickness = thickness pednl % dmin = dmin pednl % npix = npix pednl % nthreads = nthreads pednl % outname = outname pednl % rnmpp = rnmpp pednl % ncubochoric = ncubochoric end subroutine GetPEDKINNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetPEDZANameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill pednl structure (used by EMPEDZA.f90) ! !> @param nmlfile namelist file name !> @param pednl PED name list structure ! !> @date 07/09/14 MDG 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine GetPEDZANameList ( nmlfile , pednl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetPEDZANameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( PEDZANameListType ), INTENT ( INOUT ) :: pednl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: k ( 3 ) integer ( kind = irg ) :: fn ( 3 ) integer ( kind = irg ) :: precsample integer ( kind = irg ) :: precazimuthal integer ( kind = irg ) :: npix integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: voltage real ( kind = sgl ) :: dmin real ( kind = sgl ) :: precangle real ( kind = sgl ) :: prechalfwidth real ( kind = sgl ) :: thickness real ( kind = sgl ) :: camlen character ( 5 ) :: filemode character ( fnlen ) :: xtalname character ( fnlen ) :: outname ! define the IO namelist to facilitate passing variables to the program. namelist / EMPEDZA / stdout , xtalname , voltage , k , fn , dmin , precangle , prechalfwidth , precsample , precazimuthal , & thickness , outname , npix , camlen , filemode , nthreads ! set the input parameters to default values (except for xtalname, which must be present) xtalname = 'undefined' ! initial value to check that the keyword is present in the nml file stdout = 6 ! standard output voltage = 20000 0.0 ! acceleration voltage [V] k = ( / 0 , 0 , 1 / ) ! beam direction [direction indices] fn = ( / 0 , 0 , 1 / ) ! foil normal [direction indices] dmin = 0.025 ! smallest d-spacing to include in dynamical matrix [nm] precangle = 1 0.472 ! beam precession angle [mrad]; default = 0.6 degrees prechalfwidth = 0.25 ! beam half width in the tilt direction [mrad] nthreads = 1 ! number of OpenMP threads to start precsample = 10 ! number of samples (concentric circles) in beam half width (total = 2*precsample + 1) precazimuthal = 360 ! number of azimuthal samples for each precession circle thickness = 1 0.0 ! sample thickness [nm] filemode = 'total' ! 'total' mode or 'eachp' npix = 256 ! output arrays will have size npix x npix outname = 'pedout.data' ! output filename camlen = 100 0.0 ! camera length [mm] if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = EMPEDZA ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'EMPEDZA:' , ' crystal structure file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the pednl fields pednl % xtalname = xtalname pednl % stdout = stdout pednl % voltage = voltage pednl % k = k pednl % fn = fn pednl % dmin = dmin pednl % precangle = precangle pednl % prechalfwidth = prechalfwidth pednl % precsample = precsample pednl % precazimuthal = precazimuthal pednl % thickness = thickness pednl % filemode = filemode pednl % npix = npix pednl % nthreads = nthreads pednl % outname = outname pednl % camlen = camlen end subroutine GetPEDZANameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetECCINameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill eccinl structure (used by EMECCI.f90) ! !> @param nmlfile namelist file name !> @param eccinl ECCI name list structure ! !> @date 10/04/14 MDG 1.0 new routine !> @date 11/24/15 MDG 1.1 adapted for new namelist variables !-------------------------------------------------------------------------- recursive subroutine GetECCINameList ( nmlfile , eccinl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetECCINameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( ECCINameListType ), INTENT ( INOUT ) :: eccinl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: i integer ( kind = irg ) :: stdout integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: k ( 3 ) integer ( kind = irg ) :: nktstep integer ( kind = irg ) :: DF_npix integer ( kind = irg ) :: DF_npiy real ( kind = sgl ) :: voltage real ( kind = sgl ) :: dkt real ( kind = sgl ) :: ktmax real ( kind = sgl ) :: lauec ( 2 ) real ( kind = sgl ) :: lauec2 ( 2 ) real ( kind = sgl ) :: dmin real ( kind = sgl ) :: DF_L real ( kind = sgl ) :: DF_slice character ( 4 ) :: dispmode character ( 4 ) :: summode character ( 5 ) :: progmode character ( fnlen ) :: xtalname character ( fnlen ) :: defectfilename character ( fnlen ) :: dispfile character ( fnlen ) :: dataname character ( fnlen ) :: ECPname character ( fnlen ) :: sgname ! define the IO namelist to facilitate passing variables to the program. namelist / ECCIlist / DF_L , DF_npix , DF_npiy , DF_slice , dmin , sgname , stdout , & progmode , dispfile , ktmax , dkt , ECPname , summode , lauec , lauec2 , & dispmode , nthreads , xtalname , voltage , k , nktstep , & dataname , defectfilename ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 nthreads = 1 k = ( / 0 , 0 , 1 / ) nktstep = 20 DF_npix = 256 DF_npiy = 256 voltage = 3000 0. dkt = 0.1 ktmax = 5.0 lauec = ( / 0.0 , 0.0 / ) lauec2 = ( / 0.0 , 0.0 / ) dmin = 0.1 DF_L = 1.0 DF_slice = 1.0 dispmode = 'not' summode = 'diag' progmode = 'array' xtalname = 'undefined' defectfilename = 'undefined' dispfile = 'displacements.data' dataname = 'ECCIout.data' ECPname = 'undefined' sgname = 'nofile' if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = ECCIlist ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'EMECCI:' , ' crystal structure file name is undefined in ' // nmlfile ) end if ! make sure the ECPname variable has been properly defined if ( trim ( ECPname ). eq . 'undefined' ) then call FatalError ( 'EMECCI:' , ' ECP pattern file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields eccinl % stdout = stdout eccinl % nthreads = nthreads eccinl % k = k eccinl % nktstep = nktstep eccinl % DF_npix = DF_npix eccinl % DF_npiy = DF_npiy eccinl % voltage = voltage eccinl % dkt = dkt eccinl % ktmax = ktmax eccinl % lauec = lauec eccinl % lauec2 = lauec2 eccinl % dmin = dmin eccinl % DF_L = DF_L eccinl % DF_slice = DF_slice eccinl % dispmode = dispmode eccinl % summode = summode eccinl % progmode = progmode eccinl % xtalname = xtalname eccinl % defectfilename = defectfilename eccinl % dispfile = dispfile eccinl % dataname = dataname eccinl % ECPname = ECPname eccinl % sgname = sgname end subroutine GetECCINameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetRFZNameList ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill rfznl structure (used by EMsampleRFZ.f90) ! !> @param nmlfile namelist file name !> @param rfznl RFZ name list structure ! !> @date 12/09/14 MDG 1.0 new routine !> @date 08/18/15 MDG 1.1 added options for all seven representations !> @date 01/17/15 MDG 1.2 added gridtype option !> @date 12/22/16 MDG 1.3 added new sampling mode !> @date 02/01/17 MDG 1.4 added conical sampling mode !-------------------------------------------------------------------------- recursive subroutine GetRFZNameList ( nmlfile , rfznl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetRFZNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( RFZNameListType ), INTENT ( INOUT ) :: rfznl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: pgnum , nsteps , gridtype real ( kind = dbl ) :: rodrigues ( 4 ), maxmisor , conevector ( 3 ), semiconeangle character ( fnlen ) :: samplemode character ( fnlen ) :: euoutname character ( fnlen ) :: cuoutname character ( fnlen ) :: hooutname character ( fnlen ) :: rooutname character ( fnlen ) :: quoutname character ( fnlen ) :: omoutname character ( fnlen ) :: axoutname ! namelist components namelist / RFZlist / pgnum , nsteps , gridtype , euoutname , cuoutname , hooutname , rooutname , quoutname , omoutname , axoutname , & samplemode , rodrigues , maxmisor , conevector , semiconeangle ! initialize to default values pgnum = 32 nsteps = 50 gridtype = 0 rodrigues = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) ! initialize as the identity rotation maxmisor = 5.D0 ! in degrees samplemode = 'RFZ' ! or 'MIS' for sampling inside a ball with constant misorientation w.r.t. rodrigues ! or 'CON' for conical sampling around a unitvector for a cone with semi opening angle semiconangle conevector = ( / 0.D0 , 0.D0 , 1.D0 / ) ! default unit vector for cone axis semiconeangle = 2.0 ! default opening semi-angle (in degrees) euoutname = 'undefined' cuoutname = 'undefined' hooutname = 'undefined' rooutname = 'undefined' quoutname = 'undefined' omoutname = 'undefined' axoutname = 'undefined' if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = RFZlist ) close ( UNIT = dataunit , STATUS = 'keep' ) end if ! and copy the variables to the rfznl variable rfznl % pgnum = pgnum rfznl % nsteps = nsteps rfznl % gridtype = gridtype rfznl % rodrigues = rodrigues rfznl % maxmisor = maxmisor rfznl % samplemode = samplemode rfznl % conevector = conevector rfznl % semiconeangle = semiconeangle rfznl % euoutname = euoutname rfznl % cuoutname = cuoutname rfznl % hooutname = hooutname rfznl % rooutname = rooutname rfznl % quoutname = quoutname rfznl % omoutname = omoutname rfznl % axoutname = axoutname end subroutine GetRFZNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetDictIndxOpenCLNameList ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief read namelist file and fill DictIndxOpenCLListType (used by EMDictIndxOpenCL.f90) ! !> @param nmlfile namelist file name !> @param DictIndxOpenCL name list structure ! !> @date 13/01/15 SS 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine GetDictIndxOpenCLNameList ( nmlfile , dictindxnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetDictIndxOpenCLNameList use error use local IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( DictIndxOpenCLListType ), INTENT ( INOUT ) :: dictindxnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: numexptsingle integer ( kind = irg ) :: numdictsingle integer ( kind = irg ) :: totnumexpt integer ( kind = irg ) :: totnumdict integer ( kind = irg ) :: imght integer ( kind = irg ) :: imgwd integer ( kind = irg ) :: nnk character ( fnlen ) :: exptfile character ( fnlen ) :: dictfile character ( fnlen ) :: eulerfile logical :: MeanSubtraction logical :: patternflip ! define the IO namelist to facilitate passing variables to the program. namelist / DictIndxOpenCLvars / numexptsingle , numdictsingle , totnumexpt , totnumdict ,& imght , imgwd , exptfile , dictfile , eulerfile , nnk , MeanSubtraction , patternflip ! set some of the input parameters to default values numdictsingle = 1024 numexptsingle = 1024 imght = 0 imgwd = 0 nnk = 40 exptfile = 'undefined' dictfile = 'undefined' eulerfile = 'undefined' totnumdict = 0 totnumexpt = 0 MeanSubtraction = . TRUE . patternflip = . TRUE . if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = DictIndxOpenCLvars ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( exptfile ). eq . 'undefined' ) then call FatalError ( 'EMDictIndxOpenCL:' , ' experimental file name is undefined in ' // nmlfile ) end if if ( trim ( dictfile ). eq . 'undefined' ) then call FatalError ( 'EMDictIndxOpenCL:' , ' dictionary file name is undefined in ' // nmlfile ) end if if ( trim ( eulerfile ). eq . 'undefined' ) then call FatalError ( 'EMDictIndxOpenCL:' , ' euler angle file name is undefined in ' // nmlfile ) end if if ( totnumexpt . eq . 0 ) then call FatalError ( 'EMDictIndxOpenCL:' , ' total number of experimental patterns is undefined in ' // nmlfile ) end if if ( totnumdict . eq . 0 ) then call FatalError ( 'EMDictIndxOpenCL:' , ' total number of dictionary patterns is undefined in ' // nmlfile ) end if if ( imght . eq . 0 ) then call FatalError ( 'EMDictIndxOpenCL:' , ' height of single pattern is undefined in ' // nmlfile ) end if if ( imgwd . eq . 0 ) then call FatalError ( 'EMDictIndxOpenCL:' , ' width of single pattern is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields dictindxnl % numexptsingle = numexptsingle dictindxnl % numdictsingle = numdictsingle dictindxnl % imght = imght dictindxnl % imgwd = imgwd dictindxnl % exptfile = exptfile dictindxnl % dictfile = dictfile dictindxnl % eulerfile = eulerfile dictindxnl % totnumdict = totnumdict dictindxnl % totnumexpt = totnumexpt dictindxnl % nnk = nnk dictindxnl % MeanSubtraction = MeanSubtraction dictindxnl % patternflip = patternflip end subroutine GetDictIndxOpenCLNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetPEDIndxNameList ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief read namelist file and fill PEDKINIndxListType (used by EMPEDIndexing.f90) ! !> @param nmlfile namelist file name !> @param pednl PEDKINIndx name list structure ! !> @date 13/01/15 SS 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine GetPEDIndxNameList ( nmlfile , pednl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetPEDIndxNameList use error use local IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( PEDKINIndxListType ), INTENT ( INOUT ) :: pednl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: npix integer ( kind = irg ) :: ncubochoric real ( kind = sgl ) :: voltage real ( kind = sgl ) :: dmin real ( kind = sgl ) :: thickness real ( kind = sgl ) :: rnmpp ! reciprocal nanometers per pixel character ( fnlen ) :: xtalname integer ( kind = irg ) :: numexptsingle integer ( kind = irg ) :: numdictsingle integer ( kind = irg ) :: ipf_ht integer ( kind = irg ) :: ipf_wd integer ( kind = irg ) :: nnk real ( kind = sgl ) :: sgmax ! maximum sg value for a beam to be considered real ( kind = sgl ) :: ww ! 2*ww+1 is the size of the spot real ( kind = sgl ) :: var ! variance of gaussian peak character ( fnlen ) :: exptfile character ( fnlen ) :: datafile character ( fnlen ) :: ctffile integer ( kind = irg ) :: devid integer ( kind = irg ) :: platid integer ( kind = irg ) :: nthreads ! define the IO namelist to facilitate passing variables to the program. namelist / inputlist / npix , ncubochoric , numexptsingle , numdictsingle , voltage , dmin , thickness , rnmpp , xtalname , & exptfile , nnk , ipf_ht , ipf_wd , nthreads , sgmax , ww , var , devid , platid , datafile , ctffile ! set some of the input parameters to default values npix = 0 ncubochoric = 50 voltage = 20000 0.0 dmin = 0.04 thickness = 5 0.0 rnmpp = 0.20 xtalname = 'undefined' numdictsingle = 1024 numexptsingle = 1024 nnk = 40 exptfile = 'undefined' datafile = 'undefined' ctffile = 'undefined' sgmax = 0.50 ww = 3 var = 0.0020 ipf_ht = 0 ipf_wd = 0 nthreads = 1 platid = 1 devid = 1 if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = inputlist ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( npix . eq . 0 ) then call FatalError ( 'EMPEDIndexing:' , ' size of dictionary pattern not specified or set to 0 in ' // nmlfile ) end if if ( trim ( xtalname ) . eq . 'undefined' ) then call FatalError ( 'EMPEDIndexing:' , ' crystal file undefined in ' // nmlfile ) end if if ( trim ( exptfile ). eq . 'undefined' ) then call FatalError ( 'EMPEDIndexing:' , ' experimental file name is undefined in ' // nmlfile ) end if if ( ipf_ht . eq . 0 ) then call FatalError ( 'EMPEDIndexing:' , ' total number of experimental patterns is either set to 0 or is undefined in ' // nmlfile ) end if if ( ipf_wd . eq . 0 ) then call FatalError ( 'EMPEDIndexing:' , ' total number of experimental patterns is either set to 0 or is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields pednl % npix = npix pednl % ncubochoric = ncubochoric pednl % voltage = voltage pednl % dmin = dmin pednl % thickness = thickness pednl % rnmpp = rnmpp pednl % xtalname = xtalname pednl % numexptsingle = numexptsingle pednl % numdictsingle = numdictsingle pednl % exptfile = exptfile pednl % datafile = datafile pednl % ctffile = ctffile pednl % nnk = nnk pednl % sgmax = sgmax pednl % ww = ww pednl % var = var pednl % ipf_ht = ipf_ht pednl % ipf_wd = ipf_wd pednl % nthreads = nthreads pednl % platid = platid pednl % devid = devid end subroutine GetPEDIndxNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetEBSDIndxNameList ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief read namelist file and fill enl structure (used by EMDynamicEBSDIndeixing.f90) ! !> @param nmlfile namelist file name !> @param enl EBSD indexing name list structure ! !> @date 06/10/15  SS 1.0 new routine !> @date 11/19/15  SS 1.1 added new variables !> @date 01/26/16  SS 1.2 adjusted for EBSDIndexing !-------------------------------------------------------------------------- recursive subroutine GetEBSDIndexingNameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetEBSDIndexingNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( EBSDIndexingNameListType ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: numsx integer ( kind = irg ) :: numsy integer ( kind = irg ) :: binning integer ( kind = irg ) :: energyaverage integer ( kind = irg ) :: devid integer ( kind = irg ) :: platid integer ( kind = irg ) :: nregions real ( kind = sgl ) :: L real ( kind = sgl ) :: thetac real ( kind = sgl ) :: delta real ( kind = sgl ) :: xpc real ( kind = sgl ) :: ypc real ( kind = sgl ) :: gammavalue real ( kind = dbl ) :: beamcurrent real ( kind = dbl ) :: dwelltime real ( kind = dbl ) :: hipassw real ( kind = sgl ) :: omega real ( kind = sgl ) :: stepX real ( kind = sgl ) :: stepY integer ( kind = irg ) :: nthreads character ( 1 ) :: maskpattern character ( 3 ) :: scalingmode character ( fnlen ) :: dotproductfile character ( fnlen ) :: masterfile real ( kind = sgl ) :: energymin real ( kind = sgl ) :: energymax character ( 1 ) :: spatialaverage character ( fnlen ) :: tmpfile character ( fnlen ) :: datafile character ( fnlen ) :: ctffile character ( fnlen ) :: avctffile character ( fnlen ) :: angfile character ( fnlen ) :: eulerfile integer ( kind = irg ) :: ncubochoric integer ( kind = irg ) :: numexptsingle integer ( kind = irg ) :: numdictsingle integer ( kind = irg ) :: ipf_ht integer ( kind = irg ) :: ipf_wd integer ( kind = irg ) :: nnk integer ( kind = irg ) :: nnav integer ( kind = irg ) :: nosm integer ( kind = irg ) :: maskradius character ( fnlen ) :: exptfile character ( fnlen ) :: dictfile character ( fnlen ) :: indexingmode ! define the IO namelist to facilitate passing variables to the program. namelist / EBSDIndexingdata / thetac , delta , numsx , numsy , xpc , ypc , masterfile , devid , platid , & beamcurrent , dwelltime , binning , gammavalue , energymin , spatialaverage , nregions , & scalingmode , maskpattern , energyaverage , L , omega , nthreads , energymax , datafile , angfile , ctffile , & ncubochoric , numexptsingle , numdictsingle , ipf_ht , ipf_wd , nnk , nnav , exptfile , maskradius ,& dictfile , indexingmode , hipassw , stepX , stepY , tmpfile , avctffile , nosm , eulerfile ! set the input parameters to default values (except for xtalname, which must be present) ncubochoric = 50 numexptsingle = 1024 numdictsingle = 1024 platid = 1 devid = 1 nregions = 10 nnk = 50 nnav = 20 nosm = 20 exptfile = 'undefined' numsx = 640 ! [dimensionless] numsy = 480 ! [dimensionless] maskradius = 240 binning = 1 ! binning mode  (1, 2, 4, or 8) L = 2000 0.0 ! [microns] energyaverage = 1 ! apply energy averaging (1) or not (0); useful for dictionary computations thetac = 0.0 ! [degrees] delta = 2 5.0 ! [microns] xpc = 0.0 ! [pixels] ypc = 0.0 ! [pixels] gammavalue = 1.0 ! gamma factor beamcurrent = 1 4.513D0 ! beam current (actually emission current) in nano ampere dwelltime = 10 0.0D0 ! in microseconds hipassw = 0.05D0 ! hi pass inverted Gaussian mask parameter stepX = 1.0 ! sampling step size along X stepY = 1.0 ! sampling step size along Y maskpattern = 'n' ! 'y' or 'n' to include a circular mask scalingmode = 'not' ! intensity selector ('lin', 'gam', or 'not') masterfile = 'undefined' ! filename dotproductfile = 'undefined' energymin = 1 0.0 energymax = 2 0.0 ipf_ht = 100 ipf_wd = 100 nthreads = 1 spatialaverage = 'n' datafile = 'undefined' ctffile = 'undefined' avctffile = 'undefined' angfile = 'undefined' eulerfile = 'undefined' omega = 0.0 tmpfile = 'EMEBSDDict_tmp.data' dictfile = 'undefined' indexingmode = 'dynamic' if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = EBSDIndexingdata ) close ( UNIT = dataunit , STATUS = 'keep' ) if ( trim ( indexingmode ) . eq . 'static' ) then if ( trim ( dictfile ) . eq . 'undefined' ) then call FatalError ( 'EMEBSDIndexing:' , ' dictionary file name is undefined in ' // nmlfile ) end if end if ! check for required entries if ( trim ( indexingmode ) . eq . 'dynamic' ) then if ( trim ( masterfile ). eq . 'undefined' ) then call FatalError ( 'EMEBSDIndexing:' , ' master pattern file name is undefined in ' // nmlfile ) end if end if if ( trim ( exptfile ). eq . 'undefined' ) then call FatalError ( 'EMEBSDIndexing:' , ' experimental file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the enl fields enl % devid = devid enl % platid = platid enl % nregions = nregions enl % maskpattern = maskpattern enl % exptfile = exptfile enl % nnk = nnk enl % nnav = nnav enl % nosm = nosm enl % ipf_ht = ipf_ht enl % ipf_wd = ipf_wd enl % nthreads = nthreads enl % datafile = datafile enl % tmpfile = tmpfile enl % ctffile = ctffile enl % avctffile = avctffile enl % angfile = angfile enl % eulerfile = eulerfile enl % maskradius = maskradius enl % numdictsingle = numdictsingle enl % numexptsingle = numexptsingle enl % hipassw = hipassw enl % masterfile = masterfile enl % energyfile = enl % masterfile enl % StepX = stepX enl % StepY = stepY enl % indexingmode = trim ( indexingmode ) if ( trim ( indexingmode ) . eq . 'dynamic' ) then enl % L = L enl % numsx = numsx enl % numsy = numsy enl % binning = binning enl % energyaverage = energyaverage enl % thetac = thetac enl % delta = delta enl % xpc = xpc enl % ypc = ypc enl % gammavalue = gammavalue enl % beamcurrent = beamcurrent enl % dwelltime = dwelltime enl % scalingmode = scalingmode enl % ncubochoric = ncubochoric enl % omega = omega enl % energymin = energymin enl % energymax = energymax enl % spatialaverage = spatialaverage enl % dictfile = 'undefined' else if ( trim ( indexingmode ) . eq . 'static' ) then enl % dictfile = dictfile enl % ncubochoric = 0 else call FatalError ( 'EMEBSDIndexing:' , ' indexingmode is not known in ' // nmlfile ) end if end subroutine GetEBSDIndexingNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetTKDIndexingNameList ! !> @author Marc De Graef , Carnegie Mellon University ! !> @brief read namelist file and fill enl structure (used by EMTKDDI.f90) ! !> @param nmlfile namelist file name !> @param enl TKD indexing name list structure ! !> @date 05/07/17 MDG 1.0 new routine, based on EBSD routine !-------------------------------------------------------------------------- recursive subroutine GetTKDIndexingNameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetTKDIndexingNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( TKDIndexingNameListType ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: numsx integer ( kind = irg ) :: numsy integer ( kind = irg ) :: binning integer ( kind = irg ) :: energyaverage integer ( kind = irg ) :: devid integer ( kind = irg ) :: platid integer ( kind = irg ) :: nregions real ( kind = sgl ) :: L real ( kind = sgl ) :: thetac real ( kind = sgl ) :: delta real ( kind = sgl ) :: xpc real ( kind = sgl ) :: ypc real ( kind = sgl ) :: gammavalue real ( kind = dbl ) :: beamcurrent real ( kind = dbl ) :: dwelltime real ( kind = dbl ) :: hipassw real ( kind = sgl ) :: omega real ( kind = sgl ) :: stepX real ( kind = sgl ) :: stepY integer ( kind = irg ) :: nthreads character ( 1 ) :: maskpattern character ( 3 ) :: scalingmode character ( fnlen ) :: dotproductfile character ( fnlen ) :: masterfile real ( kind = sgl ) :: energymin real ( kind = sgl ) :: energymax character ( 1 ) :: spatialaverage character ( fnlen ) :: tmpfile character ( fnlen ) :: datafile character ( fnlen ) :: ctffile character ( fnlen ) :: avctffile character ( fnlen ) :: angfile character ( fnlen ) :: eulerfile integer ( kind = irg ) :: ncubochoric integer ( kind = irg ) :: numexptsingle integer ( kind = irg ) :: numdictsingle integer ( kind = irg ) :: ipf_ht integer ( kind = irg ) :: ipf_wd integer ( kind = irg ) :: nnk integer ( kind = irg ) :: nnav integer ( kind = irg ) :: nosm integer ( kind = irg ) :: maskradius character ( fnlen ) :: exptfile character ( fnlen ) :: dictfile character ( fnlen ) :: indexingmode ! define the IO namelist to facilitate passing variables to the program. namelist / TKDIndexingdata / thetac , delta , numsx , numsy , xpc , ypc , masterfile , devid , platid , & beamcurrent , dwelltime , binning , gammavalue , energymin , spatialaverage , nregions , & scalingmode , maskpattern , energyaverage , L , omega , nthreads , energymax , datafile , angfile , ctffile , & ncubochoric , numexptsingle , numdictsingle , ipf_ht , ipf_wd , nnk , nnav , exptfile , maskradius ,& dictfile , indexingmode , hipassw , stepX , stepY , tmpfile , avctffile , nosm , eulerfile ! set the input parameters to default values (except for xtalname, which must be present) ncubochoric = 50 numexptsingle = 1024 numdictsingle = 1024 platid = 1 devid = 1 nregions = 10 nnk = 50 nnav = 20 nosm = 20 exptfile = 'undefined' numsx = 640 ! [dimensionless] numsy = 480 ! [dimensionless] maskradius = 240 binning = 1 ! binning mode  (1, 2, 4, or 8) L = 2000 0.0 ! [microns] energyaverage = 1 ! apply energy averaging (1) or not (0); useful for dictionary computations thetac = 0.0 ! [degrees] delta = 2 5.0 ! [microns] xpc = 0.0 ! [pixels] ypc = 0.0 ! [pixels] gammavalue = 1.0 ! gamma factor beamcurrent = 1 4.513D0 ! beam current (actually emission current) in nano ampere dwelltime = 10 0.0D0 ! in microseconds hipassw = 0.05D0 ! hi pass inverted Gaussian mask parameter stepX = 1.0 ! sampling step size along X stepY = 1.0 ! sampling step size along Y maskpattern = 'n' ! 'y' or 'n' to include a circular mask scalingmode = 'not' ! intensity selector ('lin', 'gam', or 'not') masterfile = 'undefined' ! filename dotproductfile = 'undefined' energymin = 1 0.0 energymax = 2 0.0 ipf_ht = 100 ipf_wd = 100 nthreads = 1 spatialaverage = 'n' datafile = 'undefined' ctffile = 'undefined' avctffile = 'undefined' angfile = 'undefined' eulerfile = 'undefined' omega = 0.0 tmpfile = 'EMEBSDDict_tmp.data' dictfile = 'undefined' indexingmode = 'dynamic' if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = TKDIndexingdata ) close ( UNIT = dataunit , STATUS = 'keep' ) if ( trim ( indexingmode ) . eq . 'static' ) then if ( trim ( dictfile ) . eq . 'undefined' ) then call FatalError ( 'EMTKDIndexing:' , ' dictionary file name is undefined in ' // nmlfile ) end if end if ! check for required entries if ( trim ( indexingmode ) . eq . 'dynamic' ) then if ( trim ( masterfile ). eq . 'undefined' ) then call FatalError ( 'EMTKDIndexing:' , ' master pattern file name is undefined in ' // nmlfile ) end if end if if ( trim ( exptfile ). eq . 'undefined' ) then call FatalError ( 'EMTKDIndexing:' , ' experimental file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the enl fields enl % devid = devid enl % platid = platid enl % nregions = nregions enl % maskpattern = maskpattern enl % exptfile = exptfile enl % nnk = nnk enl % nnav = nnav enl % nosm = nosm enl % ipf_ht = ipf_ht enl % ipf_wd = ipf_wd enl % nthreads = nthreads enl % datafile = datafile enl % tmpfile = tmpfile enl % ctffile = ctffile enl % avctffile = avctffile enl % angfile = angfile enl % eulerfile = eulerfile enl % maskradius = maskradius enl % numdictsingle = numdictsingle enl % numexptsingle = numexptsingle enl % hipassw = hipassw enl % masterfile = masterfile enl % energyfile = enl % masterfile enl % StepX = stepX enl % StepY = stepY enl % indexingmode = trim ( indexingmode ) if ( trim ( indexingmode ) . eq . 'dynamic' ) then enl % L = L enl % numsx = numsx enl % numsy = numsy enl % binning = binning enl % energyaverage = energyaverage enl % thetac = thetac enl % delta = delta enl % xpc = xpc enl % ypc = ypc enl % gammavalue = gammavalue enl % beamcurrent = beamcurrent enl % dwelltime = dwelltime enl % scalingmode = scalingmode enl % ncubochoric = ncubochoric enl % omega = omega enl % energymin = energymin enl % energymax = energymax enl % spatialaverage = spatialaverage enl % dictfile = 'undefined' else if ( trim ( indexingmode ) . eq . 'static' ) then enl % dictfile = dictfile enl % ncubochoric = 0 else call FatalError ( 'EMTKDIndexing:' , ' indexingmode is not known in ' // nmlfile ) end if end subroutine GetTKDIndexingNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetZAdefectNameList ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief read namelist file and fill ZAdefect structure (used by CTEMDefect.f90) ! !> @param nmlfile namelist file name !> @param ZAdefect Zone Axis defect simulation name list structure ! !> @date 06/24/15  SS 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine GetZAdefectNameList ( nmlfile , ZAdefect , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetZAdefectNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( ZAdefectnameListType ), INTENT ( INOUT ) :: ZAdefect logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . character ( fnlen ) :: xtalname real ( kind = sgl ) :: voltage integer ( kind = irg ) :: kk ( 3 ) real ( kind = sgl ) :: lauec ( 2 ) real ( kind = sgl ) :: dmin ! EM or STEM ? character ( fnlen ) :: progmode character ( fnlen ) :: STEMnmlfile character ( fnlen ) :: foilnmlfile ! column approximation parameters and image parameters real ( kind = sgl ) :: DF_L real ( kind = sgl ) :: DF_npix real ( kind = sgl ) :: DF_npiy real ( kind = sgl ) :: DF_slice integer ( kind = irg ) :: dinfo character ( fnlen ) :: sgname ! defect parameters integer ( kind = irg ) :: numdisl integer ( kind = irg ) :: numsf integer ( kind = irg ) :: numinc integer ( kind = irg ) :: numvoids character ( fnlen ) :: voidname character ( fnlen ) :: dislname character ( fnlen ) :: sfname character ( fnlen ) :: incname character ( fnlen ) :: dispfile character ( fnlen ) :: dispmode ! output parameters character ( fnlen ) :: dataname integer ( kind = irg ) :: t_interval ! define the IO namelist to facilitate passing variables to the program. namelist / rundata / xtalname , voltage , kk , lauec , dmin , progmode , STEMnmlfile , foilnmlfile ,& DF_L , DF_npix , DF_npiy , DF_slice , dinfo , sgname , numdisl , numsf , numinc ,& numvoids , voidname , dislname , sfname , incname , dispfile , dispmode , dataname , t_interval ! set the input parameters to default values (except for xtalname, which must be present) xtalname = 'undefined' voltage = 20000 0.0 kk = ( / 0.0 , 0.0 , 1.0 / ) lauec = ( / 0.0 , 0.0 / ) dmin = 0.04 progmode = 'CTEM' STEMnmlfile = 'STEM_rundata.nml' foilnmlfile = 'FOIL_rundata.nml' DF_L = 1.0 DF_npix = 256 DF_npiy = 256 DF_slice = 1.0 dinfo = 0 sgname = 'undefined' numdisl = 0 numsf = 0 numinc = 0 numvoids = 0 voidname = 'void.nml' dislname = 'dislocation.nml' sfname = 'stackingfault.nml' incname = 'inclusion.nml' dispfile = 'undefined' dispmode = 'undefined' dataname = 'undefined' t_interval = 10 if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = rundata ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'CTEMDefect:' , ' xtal file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields ZAdefect % xtalname = xtalname ZAdefect % voltage = voltage ZAdefect % kk = kk ZAdefect % lauec = lauec ZAdefect % dmin = dmin ZAdefect % progmode = progmode ZAdefect % STEMnmlfile = STEMnmlfile ZAdefect % foilnmlfile = foilnmlfile ZAdefect % DF_L = DF_L ZAdefect % DF_npix = DF_npix ZAdefect % DF_npiy = DF_npiy ZAdefect % DF_slice = DF_slice ZAdefect % dinfo = dinfo ZAdefect % sgname = sgname ZAdefect % numdisl = numdisl ZAdefect % numsf = numsf ZAdefect % numinc = numinc ZAdefect % numvoids = numvoids ZAdefect % voidname = voidname ZAdefect % dislname = dislname ZAdefect % sfname = sfname ZAdefect % incname = incname ZAdefect % dispfile = dispfile ZAdefect % dispmode = dispmode ZAdefect % dataname = dataname ZAdefect % t_interval = t_interval end subroutine GetZADefectNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetECPIndexingNameList ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief read namelist file and fill enl structure (used by EMDynamicECPIndeixing.f90) ! !> @param nmlfile namelist file name !> @param enl ECP indexing name list structure ! !> @date 11/19/15  SS 1.0 original !> @date 01/26/16  SS 1.1 modified for EMsoft3.1 indexing code !-------------------------------------------------------------------------- recursive subroutine GetECPIndexingNameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetECPIndexingNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( ECPIndexingNameListType ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: ncubochoric integer ( kind = irg ) :: numexptsingle integer ( kind = irg ) :: numdictsingle integer ( kind = irg ) :: totnumexpt integer ( kind = irg ) :: maskradius integer ( kind = irg ) :: nnk integer ( kind = irg ) :: platid integer ( kind = irg ) :: devid integer ( kind = irg ) :: nregions character ( fnlen ) :: exptfile integer ( kind = irg ) :: stdout integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: npix real ( kind = sgl ) :: thetac character ( 1 ) :: maskpattern character ( fnlen ) :: masterfile character ( fnlen ) :: tmpfile character ( fnlen ) :: datafile character ( fnlen ) :: ctffile real ( kind = sgl ) :: gammavalue real ( kind = dbl ) :: sampletilt real ( kind = sgl ) :: workingdistance real ( kind = sgl ) :: Rin real ( kind = sgl ) :: Rout namelist / ECPIndexingdata / ncubochoric , numexptsingle , numdictsingle , totnumexpt , nnk , exptfile , & stdout , nthreads , npix , thetac , maskpattern , masterfile , datafile , gammavalue , platid , & sampletilt , workingdistance , Rin , Rout , maskradius , devid , nregions , ctffile , tmpfile ncubochoric = 100 numexptsingle = 1024 numdictsingle = 1024 totnumexpt = 10 nregions = 10 nnk = 2 platid = 1 devid = 1 exptfile = 'undefined' nthreads = 1 npix = 256 thetac = 1 0.0 maskpattern = 'y' masterfile = 'undefined' datafile = 'undefined' tmpfile = 'EMECPDict_tmp.data' ctffile = 'undefined' gammavalue = 1.0 sampletilt = 0.0 workingdistance = 1 0.0 Rin = 3.0 Rout = 5.0 maskradius = 128 if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = ECPIndexingdata ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( masterfile ). eq . 'undefined' ) then call FatalError ( 'EMECPIndexing:' , ' master pattern file name is undefined in ' // nmlfile ) end if if ( trim ( exptfile ). eq . 'undefined' ) then call FatalError ( 'EMECPIndexing:' , ' experimental file name is undefined in ' // nmlfile ) end if end if enl % ncubochoric = ncubochoric enl % numexptsingle = numexptsingle enl % numdictsingle = numdictsingle enl % totnumexpt = totnumexpt enl % nnk = nnk enl % devid = devid enl % platid = platid enl % nregions = nregions enl % exptfile = exptfile enl % nthreads = nthreads enl % npix = npix enl % thetac = thetac enl % maskpattern = maskpattern enl % masterfile = masterfile enl % energyfile = enl % masterfile enl % datafile = datafile enl % gammavalue = gammavalue enl % sampletilt = sampletilt enl % workingdistance = workingdistance enl % Rin = Rin enl % Rout = Rout enl % maskradius = maskradius enl % ctffile = ctffile enl % tmpfile = tmpfile end subroutine GetECPIndexingNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetEMDPFit4NameList ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief read namelist file and fill enl structure (used by EMDPFit.f90) ! !> @param nmlfile namelist file name !> @param enl DPFit name list structure ! !> @date 02/22/16  SS 1.0 original !-------------------------------------------------------------------------- recursive subroutine GetEMDPFit4NameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetEMDPFit4NameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( EMDPFit4ListType ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . character ( fnlen ) :: masterfile character ( fnlen ) :: modalityname character ( fnlen ) :: exptfile_pat1 character ( fnlen ) :: exptfile_pat2 character ( fnlen ) :: exptfile_pat3 character ( fnlen ) :: exptfile_pat4 real ( kind = dbl ) :: rhobeg , rhoend logical :: verbose , mask real ( kind = sgl ) :: gammavalue real ( kind = sgl ) :: phi_pat1 , phi1_pat1 , phi2_pat1 real ( kind = sgl ) :: phi_pat2 , phi1_pat2 , phi2_pat2 real ( kind = sgl ) :: phi_pat3 , phi1_pat3 , phi2_pat3 real ( kind = sgl ) :: phi_pat4 , phi1_pat4 , phi2_pat4 real ( kind = sgl ) :: L real ( kind = sgl ) :: thetac real ( kind = sgl ) :: delta real ( kind = sgl ) :: omega integer ( kind = irg ) :: numsx integer ( kind = irg ) :: numsy integer ( kind = irg ) :: binning real ( kind = sgl ) :: xpc real ( kind = sgl ) :: ypc real ( kind = sgl ) :: beamcurrent real ( kind = sgl ) :: dwelltime integer ( kind = irg ) :: npix real ( kind = sgl ) :: Rin real ( kind = sgl ) :: Rout real ( kind = sgl ) :: thetacone real ( kind = sgl ) :: sampletilt real ( kind = sgl ) :: workingdistance real ( kind = sgl ) :: maskradius real ( kind = sgl ) :: step_xpc real ( kind = sgl ) :: step_ypc real ( kind = sgl ) :: step_L real ( kind = sgl ) :: step_phi1 real ( kind = sgl ) :: step_phi real ( kind = sgl ) :: step_phi2 real ( kind = sgl ) :: step_thetacone integer ( kind = irg ) :: nrun integer ( kind = irg ) :: pixx_pat1 , pixx_pat2 , pixx_pat3 , pixx_pat4 integer ( kind = irg ) :: pixy_pat1 , pixy_pat2 , pixy_pat3 , pixy_pat4 real ( kind = sgl ) :: stepx real ( kind = sgl ) :: stepy namelist / DPFitdata / masterfile , modalityname , exptfile_pat1 , rhobeg , rhoend , verbose , mask , & phi1_pat1 , phi_pat1 , phi2_pat1 , L , thetac , delta , omega , numsx , numsy , binning , xpc , ypc , beamcurrent , & dwelltime , npix , Rin , Rout , thetacone , sampletilt , workingdistance , gammavalue , maskradius , & phi1_pat2 , phi_pat2 , phi2_pat2 , phi1_pat3 , phi_pat3 , phi2_pat3 , phi1_pat4 , phi_pat4 , phi2_pat4 , & exptfile_pat2 , exptfile_pat3 , exptfile_pat4 , step_xpc , step_ypc , step_L , step_phi1 , step_phi , step_phi2 ,& step_thetacone , nrun , pixx_pat1 , pixy_pat1 , stepx , stepy , pixx_pat2 , pixy_pat2 , pixx_pat3 , pixy_pat3 ,& pixx_pat4 , pixy_pat4 masterfile = 'undefined' modalityname = 'undefined' exptfile_pat1 = 'undefined' exptfile_pat2 = 'undefined' exptfile_pat3 = 'undefined' exptfile_pat4 = 'undefined' rhobeg = 1.0D-2 rhoend = 1.0D-7 verbose = . TRUE . mask = . TRUE . phi1_pat1 = 0.0 phi_pat1 = 0.0 phi2_pat1 = 0.0 phi1_pat2 = 0.0 phi_pat2 = 0.0 phi2_pat2 = 0.0 phi1_pat3 = 0.0 phi_pat3 = 0.0 phi2_pat3 = 0.0 phi1_pat4 = 0.0 phi_pat4 = 0.0 phi2_pat4 = 0.0 step_phi1 = 2.0 step_phi = 2.0 step_phi2 = 2.0 L = 1500 0.0 thetac = 1 0.0 delta = 5 0.0 omega = 0.0 numsx = 640 numsy = 480 binning = 1 xpc = 0.0 ypc = 0.0 beamcurrent = 100 0.0 dwelltime = 100 0.0 npix = 512 Rin = 2.0 Rout = 5.0 thetacone = 5.0 sampletilt = 0.0 workingdistance = 7.0 gammavalue = 1.0 maskradius = 25 6.0 step_xpc = 5.0 step_ypc = 5.0 step_L = 5.0 step_thetacone = 1.0 pixx_pat1 = 0 pixy_pat1 = 0 pixx_pat2 = 0 pixy_pat2 = 0 pixx_pat3 = 0 pixy_pat3 = 0 pixx_pat4 = 0 pixy_pat4 = 0 stepx = 5.0 stepy = 5.0 nrun = 2 if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( nmlfile ), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = DPFitdata ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( masterfile ). eq . 'undefined' ) then call FatalError ( 'EMDPFit:' , ' master pattern file name is undefined in ' // nmlfile ) end if if ( trim ( modalityname ). eq . 'undefined' ) then call FatalError ( 'EMDPFit:' , ' modality name is undefined in ' // nmlfile ) end if if ( trim ( exptfile_pat1 ). eq . 'undefined' ) then call FatalError ( 'EMDPFit:' , ' experimental file name is undefined in ' // nmlfile ) end if end if enl % masterfile = masterfile enl % modalityname = modalityname enl % exptfile_pat1 = exptfile_pat1 enl % exptfile_pat2 = exptfile_pat2 enl % exptfile_pat3 = exptfile_pat3 enl % exptfile_pat4 = exptfile_pat4 enl % rhobeg = rhobeg enl % rhoend = rhoend enl % verbose = verbose enl % mask = mask enl % phi1_pat1 = phi1_pat1 enl % phi_pat1 = phi_pat1 enl % phi2_pat1 = phi2_pat1 enl % phi1_pat2 = phi1_pat2 enl % phi_pat2 = phi_pat2 enl % phi2_pat2 = phi2_pat2 enl % phi1_pat3 = phi1_pat3 enl % phi_pat3 = phi_pat3 enl % phi2_pat3 = phi2_pat3 enl % phi1_pat4 = phi1_pat4 enl % phi_pat4 = phi_pat4 enl % phi2_pat4 = phi2_pat4 enl % L = L enl % thetac = thetac enl % omega = omega enl % numsx = numsx enl % numsy = numsy enl % binning = binning enl % xpc = xpc enl % ypc = ypc enl % beamcurrent = beamcurrent enl % dwelltime = dwelltime enl % npix = npix enl % Rin = Rin enl % Rout = Rout enl % thetacone = thetacone enl % sampletilt = sampletilt enl % workingdistance = workingdistance enl % gammavalue = gammavalue enl % maskradius = maskradius enl % delta = delta enl % step_xpc = step_xpc enl % step_ypc = step_ypc enl % step_L = step_L enl % step_phi1 = step_phi1 enl % step_phi = step_phi enl % step_phi2 = step_phi2 enl % step_thetacone = step_thetacone enl % nrun = nrun enl % stepx = stepx enl % stepy = stepy enl % pixx_pat1 = pixx_pat1 enl % pixy_pat1 = pixy_pat1 enl % pixx_pat2 = pixx_pat2 enl % pixy_pat2 = pixy_pat2 enl % pixx_pat3 = pixx_pat3 enl % pixy_pat3 = pixy_pat3 enl % pixx_pat4 = pixx_pat4 enl % pixy_pat4 = pixy_pat4 end subroutine GetEMDPFit4NameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetEMDPFitNameList ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief read namelist file and fill enl structure (used by EMDPFit.f90) ! !> @param nmlfile namelist file name !> @param enl DPFit name list structure ! !> @date 02/22/16  SS 1.0 original !-------------------------------------------------------------------------- recursive subroutine GetEMDPFitNameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetEMDPFitNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( EMDPFitListType ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . character ( fnlen ) :: masterfile character ( fnlen ) :: modalityname character ( fnlen ) :: exptfile real ( kind = dbl ) :: rhobeg , rhoend logical :: verbose , mask real ( kind = sgl ) :: gammavalue real ( kind = sgl ) :: phi , phi1 , phi2 real ( kind = sgl ) :: L real ( kind = sgl ) :: thetac real ( kind = sgl ) :: delta real ( kind = sgl ) :: omega integer ( kind = irg ) :: numsx integer ( kind = irg ) :: numsy integer ( kind = irg ) :: binning real ( kind = sgl ) :: xpc real ( kind = sgl ) :: ypc real ( kind = sgl ) :: beamcurrent real ( kind = sgl ) :: dwelltime integer ( kind = irg ) :: npix real ( kind = sgl ) :: Rin real ( kind = sgl ) :: Rout real ( kind = sgl ) :: thetacone real ( kind = sgl ) :: sampletilt real ( kind = sgl ) :: workingdistance real ( kind = sgl ) :: maskradius real ( kind = sgl ) :: step_xpc real ( kind = sgl ) :: step_ypc real ( kind = sgl ) :: step_L real ( kind = sgl ) :: step_phi1 real ( kind = sgl ) :: step_phi real ( kind = sgl ) :: step_phi2 real ( kind = sgl ) :: step_thetacone integer ( kind = irg ) :: nrun integer ( kind = irg ) :: nregions character ( 2 ) :: metric namelist / DPFitdata / masterfile , modalityname , exptfile , rhobeg , rhoend , verbose , mask , & phi1 , phi , phi2 , L , thetac , delta , omega , numsx , numsy , binning , xpc , ypc , beamcurrent , & dwelltime , npix , Rin , Rout , thetacone , sampletilt , workingdistance , gammavalue , maskradius , & step_xpc , step_ypc , step_L , step_phi1 , step_phi , step_phi2 , step_thetacone , nrun , nregions , metric masterfile = 'undefined' modalityname = 'undefined' exptfile = 'undefined' rhobeg = 1.0D-2 rhoend = 1.0D-7 verbose = . TRUE . mask = . TRUE . phi1 = 0.0 phi = 0.0 phi2 = 0.0 step_phi1 = 2.0 step_phi = 2.0 step_phi2 = 2.0 L = 1500 0.0 thetac = 1 0.0 delta = 5 0.0 omega = 0.0 numsx = 640 numsy = 480 binning = 1 xpc = 0.0 ypc = 0.0 beamcurrent = 100 0.0 dwelltime = 100 0.0 npix = 512 Rin = 2.0 Rout = 5.0 thetacone = 5.0 sampletilt = 0.0 workingdistance = 7.0 gammavalue = 1.0 maskradius = 25 6.0 step_xpc = 5.0 step_ypc = 5.0 step_L = 5.0 step_thetacone = 1.0 nrun = 2 nregions = 8 metric = 'DP' if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( nmlfile ), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = DPFitdata ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( masterfile ). eq . 'undefined' ) then call FatalError ( 'EMDPFit:' , ' master pattern file name is undefined in ' // nmlfile ) end if if ( trim ( modalityname ). eq . 'undefined' ) then call FatalError ( 'EMDPFit:' , ' modality name is undefined in ' // nmlfile ) end if if ( trim ( exptfile ). eq . 'undefined' ) then call FatalError ( 'EMDPFit:' , ' experimental file name is undefined in ' // nmlfile ) end if end if enl % masterfile = masterfile enl % modalityname = modalityname enl % metric = metric enl % nregions = nregions enl % exptfile = exptfile enl % rhobeg = rhobeg enl % rhoend = rhoend enl % verbose = verbose enl % mask = mask enl % phi1 = phi1 enl % phi = phi enl % phi2 = phi2 enl % L = L enl % thetac = thetac enl % omega = omega enl % numsx = numsx enl % numsy = numsy enl % binning = binning enl % xpc = xpc enl % ypc = ypc enl % beamcurrent = beamcurrent enl % dwelltime = dwelltime enl % npix = npix enl % Rin = Rin enl % Rout = Rout enl % thetacone = thetacone enl % sampletilt = sampletilt enl % workingdistance = workingdistance enl % gammavalue = gammavalue enl % maskradius = maskradius enl % delta = delta enl % step_xpc = step_xpc enl % step_ypc = step_ypc enl % step_L = step_L enl % step_phi1 = step_phi1 enl % step_phi = step_phi enl % step_phi2 = step_phi2 enl % step_thetacone = step_thetacone enl % nrun = nrun end subroutine GetEMDPFitNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetECPSingleNameList ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief read namelist file and fill enl structure (used by EMDPFit.f90) ! !> @param nmlfile namelist file name !> @param enl ECP single name list structure ! !> @date 02/22/16  SS 1.0 original !-------------------------------------------------------------------------- recursive subroutine GetECPSingleNameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetECPSingleNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( ECPSingleNameListType ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: npix real ( kind = sgl ) :: thetac character ( 1 ) :: maskpattern character ( fnlen ) :: energyfile character ( fnlen ) :: datafile character ( 3 ) :: eulerconvention real ( kind = sgl ) :: gammavalue real ( kind = dbl ) :: sampletilt real ( kind = sgl ) :: workingdistance real ( kind = sgl ) :: Rin real ( kind = sgl ) :: Rout real ( kind = dbl ) :: phi1 , phi , phi2 real ( kind = sgl ) :: dmin namelist / ECPSinglelist / nthreads , npix , thetac , maskpattern , energyfile , datafile , eulerconvention , & gammavalue , sampletilt , workingdistance , Rin , Rout , phi1 , phi , phi2 , dmin nthreads = 1 npix = 512 thetac = 5.0 maskpattern = 'n' energyfile = 'undefined' datafile = 'undefined' eulerconvention = 'tsl' gammavalue = 1.0 sampletilt = 0.D0 workingdistance = 7.0 Rin = 2.0 Rout = 5.0 phi1 = 0.D0 phi = 0.D0 phi2 = 0.D0 dmin = 0.03 if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( nmlfile ), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = ECPSinglelist ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( energyfile ). eq . 'undefined' ) then call FatalError ( 'EMDPFit:' , ' energy file name is undefined in ' // nmlfile ) end if end if enl % nthreads = nthreads enl % npix = npix enl % thetac = thetac enl % maskpattern = maskpattern enl % energyfile = energyfile enl % datafile = datafile enl % eulerconvention = eulerconvention enl % gammavalue = gammavalue enl % sampletilt = sampletilt enl % workingdistance = workingdistance enl % Rin = Rin enl % Rout = Rout enl % phi1 = phi1 enl % phi = phi enl % phi2 = phi2 enl % dmin = dmin end subroutine GetECPSingleNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetEMSTEMDCINameList ! !> @author Patrick Callahan ! !> @brief read namelist file for EMSTEMDCI ! !> @param nmlfile namelist file name ! !> @date 11/01/16  PGC 1.0 new routine !-------------------------------------------------------------------------- recursive SUBROUTINE GetSTEMDCINameList ( nmlfile , dcinl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetSTEMDCINameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( STEMDCINameListType ), INTENT ( INOUT ) :: dcinl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: voltage character ( 4 ) :: progmode character ( fnlen ) :: xtalname integer ( kind = irg ) :: kk ( 3 ) real ( kind = sgl ) :: lauec ( 2 ) character ( fnlen ) :: STEMnmlfile character ( fnlen ) :: dataname character ( fnlen ) :: defectfilename character ( 3 ) :: dispmode character ( fnlen ) :: dispfile integer ( kind = irg ) :: output integer ( kind = irg ) :: dinfo integer ( kind = irg ) :: t_interval real ( kind = sgl ) :: DF_L integer ( kind = irg ) :: DF_npix integer ( kind = irg ) :: DF_npiy real ( kind = sgl ) :: DF_slice real ( kind = sgl ) :: dmin ! DEFINE THE IO NAMELIST FOR VARIABLE PASSING namelist / STEMDCIdata / nthreads , voltage , progmode , xtalname , kk , lauec , STEMnmlfile , & dataname , defectfilename , dispmode , dispfile , output , dinfo , t_interval , DF_L , & DF_npix , DF_npiy , DF_slice , dmin ! SET INPUT PARAMETERS TO DEFAULT VALUES (EXCEPT XTALNAME, WHICH MUST BE PRESENT) nthreads = 6 voltage = 200000 progmode = 'STEM' xtalname = 'undefined' kk = ( / 0.0 , 0.0 , 1.0 / ) lauec = ( / 0.0 , 0.0 / ) STEMnmlfile = 'STEM_rundata.nml' defectfilename = 'EMdefec/dispt.json' dataname = '/folder/to/trialbinary.data' dispmode = 'not' dispfile = 'test_ZA.data' output = 6 ! screen output dinfo = 0 ! 1 is verbose t_interval = 5 ! update every x steps DF_L = 1.0 DF_npix = 256 DF_npiy = 256 DF_slice = 1.0 ! slice thickness for scattering matrix approach (nmu) dmin = 0.03 if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = STEMDCIdata ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'STEMDCI:' , ' crystal structure file name is undefined in ' // nmlfile ) end if end if dcinl % nthreads = nthreads dcinl % voltage = voltage dcinl % progmode = progmode dcinl % xtalname = xtalname dcinl % kk = kk dcinl % lauec = lauec dcinl % STEMnmlfile = STEMnmlfile dcinl % dataname = dataname dcinl % defectfilename = defectfilename dcinl % dispmode = dispmode dcinl % dispfile = dispfile dcinl % output = output dcinl % dinfo = dinfo dcinl % t_interval = t_interval dcinl % DF_L = DF_L dcinl % DF_npix = DF_npix dcinl % DF_npiy = DF_npiy dcinl % DF_slice = DF_slice dcinl % dmin = dmin END SUBROUTINE GetSTEMDCINameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetRefineOrientationNameList ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief read namelist file and fill enl structure (used by EMRefineOrientation.f90) ! !> @param nmlfile namelist file name !> @param enl single name list structure ! !> @date 02/22/16  SS 1.0 original !-------------------------------------------------------------------------- recursive subroutine GetRefineOrientationNameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetRefineOrientationNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( RefineOrientationtype ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: nthreads character ( fnlen ) :: dotproductfile character ( fnlen ) :: ctffile integer ( kind = irg ) :: nmis integer ( kind = irg ) :: niter real ( kind = sgl ) :: step namelist / RefineOrientations / nthreads , dotproductfile , ctffile , nmis , niter , step nthreads = 1 dotproductfile = 'undefined' ctffile = 'undefined' nmis = 1 niter = 1 step = 1.0 if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( nmlfile ), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = RefineOrientations ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( dotproductfile ). eq . 'undefined' ) then call FatalError ( 'EMRefineOrientation:' , ' dotproduct file name is undefined in ' // nmlfile ) end if if ( trim ( dotproductfile ). eq . 'undefined' ) then call FatalError ( 'EMRefineOrientation:' , ' ctf file name is undefined in ' // nmlfile ) end if end if enl % nthreads = nthreads enl % dotproductfile = dotproductfile enl % ctffile = ctffile enl % nmis = nmis enl % niter = niter enl % step = step end subroutine GetRefineOrientationNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetFitOrientationPSNameList ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief read namelist file and fill enl structure (used by EMFitOrientationPS.f90) ! !> @param nmlfile namelist file name !> @param enl single name list structure ! !> @date 02/22/16  SS 1.0 original !-------------------------------------------------------------------------- recursive subroutine GetFitOrientationPSNameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetFitOrientationPSNameList use error use constants IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( FitOrientationPStype ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: nthreads character ( fnlen ) :: dotproductfile character ( fnlen ) :: ctffile real ( kind = sgl ) :: step real ( kind = sgl ) :: angleaxis ( 4 ) namelist / FitOrientationPS / nthreads , dotproductfile , ctffile , step , angleaxis nthreads = 1 dotproductfile = 'undefined' ctffile = 'undefined' step = 1.0 angleaxis = ( / 1.0 , 1.0 , 1.0 , 12 0.0 / ) if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( nmlfile ), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = FitOrientationPS ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( dotproductfile ). eq . 'undefined' ) then call FatalError ( 'EMRefineOrientation:' , ' dotproduct file name is undefined in ' // nmlfile ) end if if ( trim ( dotproductfile ). eq . 'undefined' ) then call FatalError ( 'EMRefineOrientation:' , ' ctf file name is undefined in ' // nmlfile ) end if if ( NORM2 ( angleaxis ( 1 : 3 )) . eq . 0.0 ) then call FatalError ( 'GetFitOrientationPSNameList:' , 'The angle axis for pseudosymmetric variant has norm 0' ) end if end if enl % nthreads = nthreads enl % dotproductfile = dotproductfile enl % ctffile = ctffile enl % step = step enl % angleaxis = angleaxis end subroutine GetFitOrientationPSNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetMCCLsphereNameList ! !> @author Saransh Singh/Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill mcnl structure (used by EMMCCL.f90) ! !> @param nmlfile namelist file name !> @param mcnl Monte Carloname list structure ! !> @date 10/20/16  SS 1.0 new routine; adapted from GetMCCLNameList !-------------------------------------------------------------------------- recursive subroutine GetMCCLsphereNameList ( nmlfile , mcnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetMCCLsphereNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( MCCLNameListType ), INTENT ( INOUT ) :: mcnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numsx integer ( kind = irg ) :: globalworkgrpsz integer ( kind = irg ) :: num_el integer ( kind = irg ) :: totnum_el integer ( kind = irg ) :: multiplier integer ( kind = irg ) :: devid integer ( kind = irg ) :: platid real ( kind = dbl ) :: sig real ( kind = dbl ) :: sigstart real ( kind = dbl ) :: sigend real ( kind = dbl ) :: sigstep real ( kind = dbl ) :: omega real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep character ( 4 ) :: MCmode character ( fnlen ) :: xtalname character ( fnlen ) :: dataname character ( fnlen ) :: mode real ( kind = dbl ) :: incloc real ( kind = dbl ) :: radius ! define the IO namelist to facilitate passing variables to the program. namelist / MCCLdata / stdout , xtalname , sigstart , numsx , num_el , globalworkgrpsz , EkeV , multiplier , & dataname , totnum_el , Ehistmin , Ebinsize , depthstep , omega , MCmode , mode , devid , platid , & sigend , sigstep , sig , radius , incloc ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 numsx = 1501 globalworkgrpsz = 100 num_el = 10 totnum_el = 2000000000 multiplier = 1 devid = 1 platid = 1 sig = 7 0.D0 sigstart = 7 0.D0 sigend = 7 0.D0 sigstep = 1.D0 omega = 0.D0 EkeV = 3 0.D0 Ehistmin = 5.D0 Ebinsize = 0.5D0 depthstep = 1.0D0 MCmode = 'CSDA' xtalname = 'undefined' dataname = 'MCoutput.data' mode = 'full' radius = 10 0.D0 incloc = 0.D0 if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = MCCLdata ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'EMMC:' , ' structure file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the mcnl fields mcnl % stdout = stdout mcnl % numsx = numsx mcnl % globalworkgrpsz = globalworkgrpsz mcnl % num_el = num_el mcnl % totnum_el = totnum_el mcnl % multiplier = multiplier mcnl % devid = devid mcnl % platid = platid mcnl % sigstart = sigstart mcnl % sigend = sigend mcnl % sigstep = sigstep mcnl % sig = sig mcnl % omega = omega mcnl % EkeV = EkeV mcnl % Ehistmin = Ehistmin mcnl % Ebinsize = Ebinsize mcnl % depthstep = depthstep mcnl % MCmode = MCmode mcnl % xtalname = xtalname mcnl % dataname = dataname mcnl % mode = mode mcnl % radius = radius mcnl % incloc = incloc end subroutine GetMCCLsphereNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetMCCLfoilNameList ! !> @author Saransh Singh/Marc De Graef, Carnegie Mellon University ! !> @brief read namelist file and fill mcnl structure (used by EMMCfoil.f90) ! !> @param nmlfile namelist file name !> @param mcnl Monte Carloname list structure ! !> @date 01/15/17 MDG 1.0 new routine; adapted from GetMCCLNameList !-------------------------------------------------------------------------- recursive subroutine GetMCCLfoilNameList ( nmlfile , mcnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetMCCLfoilNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( MCCLNameListType ), INTENT ( INOUT ) :: mcnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numsx integer ( kind = irg ) :: globalworkgrpsz integer ( kind = irg ) :: num_el integer ( kind = irg ) :: totnum_el integer ( kind = irg ) :: multiplier integer ( kind = irg ) :: devid integer ( kind = irg ) :: platid real ( kind = dbl ) :: sig real ( kind = dbl ) :: omega real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep real ( kind = dbl ) :: thickness character ( 4 ) :: MCmode character ( fnlen ) :: xtalname character ( fnlen ) :: dataname ! define the IO namelist to facilitate passing variables to the program. namelist / MCCLfoildata / stdout , xtalname , numsx , num_el , globalworkgrpsz , EkeV , multiplier , & dataname , totnum_el , Ehistmin , Ebinsize , depthstep , depthmax , omega , MCmode , devid , platid , & sig , thickness ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 numsx = 501 globalworkgrpsz = 100 num_el = 10 totnum_el = 2000000000 multiplier = 1 devid = 1 platid = 1 sig = 2 0.D0 omega = 0.D0 EkeV = 3 0.D0 Ehistmin = 1 0.D0 Ebinsize = 1.0D0 depthmax = 10 0.0D0 depthstep = 1.0D0 MCmode = 'CSDA' xtalname = 'undefined' dataname = 'MCoutput.data' thickness = 20 0.0 if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = MCCLfoildata ) close ( UNIT = dataunit , STATUS = 'keep' ) write ( * , NML = MCCLfoildata ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'EMMC:' , ' structure file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the mcnl fields mcnl % stdout = stdout mcnl % numsx = numsx mcnl % globalworkgrpsz = globalworkgrpsz mcnl % num_el = num_el mcnl % totnum_el = totnum_el mcnl % multiplier = multiplier mcnl % devid = devid mcnl % platid = platid mcnl % sig = sig mcnl % omega = omega mcnl % EkeV = EkeV mcnl % Ehistmin = Ehistmin mcnl % Ebinsize = Ebinsize mcnl % depthmax = depthmax mcnl % depthstep = depthstep mcnl % MCmode = MCmode mcnl % xtalname = xtalname mcnl % dataname = dataname mcnl % thickness = thickness end subroutine GetMCCLfoilNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetEBSDFullNameList ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief read namelist file and fill enl structure (used by EMEBSDFull.f90) ! !> @param nmlfile namelist file name !> @param enl EBSD name list structure ! !> @date 01/24/17  SS 1.0 new routine !-------------------------------------------------------------------------- recursive subroutine GetEBSDFullNameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetEBSDFullNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( EBSDNameListType ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . character ( fnlen ) :: xtalname real ( kind = dbl ) :: dmin integer ( kind = irg ) :: totnum_el real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep real ( kind = dbl ) :: beamcurrent real ( kind = dbl ) :: dwelltime real ( kind = dbl ) :: sig real ( kind = dbl ) :: omega real ( kind = sgl ) :: L real ( kind = sgl ) :: xpc real ( kind = sgl ) :: ypc real ( kind = sgl ) :: thetac real ( kind = sgl ) :: delta integer ( kind = irg ) :: numsx integer ( kind = irg ) :: numsy integer ( kind = irg ) :: binning character ( 3 ) :: scalingmode real ( kind = sgl ) :: gammavalue character ( 1 ) :: maskpattern integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: platid integer ( kind = irg ) :: devid integer ( kind = irg ) :: globalworkgrpsz character ( 3 ) :: eulerconvention character ( fnlen ) :: anglefile character ( fnlen ) :: datafile integer ( kind = irg ) :: multiplier ! define the IO namelist to facilitate passing variables to the program. namelist / EBSDFulldata / xtalname , dmin , totnum_el , EkeV , Ehistmin , Ebinsize , depthmax , depthstep , beamcurrent ,& dwelltime , sig , omega , L , xpc , ypc , thetac , delta , numsx , numsy , binning , scalingmode , gammavalue , maskpattern ,& nthreads , platid , devid , globalworkgrpsz , eulerconvention , anglefile , datafile , multiplier ! set the input parameters to default values (except for xtalname, anglefile and datafile, which must be present) xtalname = 'undefined' ! name of xtal dmin = 0.04D0 ! maximum g vector used in computation totnum_el = 2000000000 ! number of electrons for MC run EkeV = 2 0.D0 ! incident electron energy [kV] Ehistmin = 1 0.D0 ! cutoff energy [kV] Ebinsize = 1.D0 ! energy step size [kV] depthmax = 10 0.D0 ! depth cutoff [nm] depthstep = 1.D0 ! depth bin size [nm] beamcurrent = 100 0.D0 ! [nA] dwelltime = 100 0.D0 ! [micro seconds] sig = 7 0.D0 ! sample tilt angle [degrees] omega = 0.D0 ! tilt about RD axis [degrees] L = 1500 0.0 ! scintillator to sample distance [micro m] xpc = 0.0 ! units of pixel [dimensionless] ypc = 0.0 ! units of pixel [dimensionless] thetac = 1 0.0 ! camera elevation [degrees] delta = 5 9.2 ! physical size of detector pixel [micro m] numsx = 480 ! number of pixel is x direction of scintillator numsy = 480 ! number of pixel is y direction of scintillator binning = 1 ! detector binning scalingmode = 'not' ! intensity scaling in detector gammavalue = 0.34 ! intensity scaling factor maskpattern = 'n' ! circular mask or not nthreads = 1 ! number of CPU threads for computation platid = 2 ! platform id for GPU devid = 1 ! device id for GPU globalworkgrpsz = 256 ! work group size eulerconvention = 'tsl' ! euler angle convention anglefile = 'undefined' ! list of euler angles for which simulation is done datafile = 'undefined' ! output HDF5 file multiplier = 1 if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = EBSDFulldata ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( anglefile ). eq . 'undefined' ) then call FatalError ( 'EMEBSD:' , ' angle file name is undefined in ' // nmlfile ) end if if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'EMEBSD:' , ' xtal file is undefined in ' // nmlfile ) end if if ( trim ( datafile ). eq . 'undefined' ) then call FatalError ( 'EMEBSD:' , ' output file name is undefined in ' // nmlfile ) end if end if enl % MCxtalname = xtalname ! name of xtal enl % dmin = dmin ! maximum g vector used in computation enl % totnum_el = totnum_el ! number of electrons for MC run enl % EkeV = EkeV ! incident electron energy [kV] enl % Ehistmin = Ehistmin ! cutoff energy [kV] enl % Ebinsize = Ebinsize ! energy step size [kV] enl % depthmax = depthmax ! depth cutoff [nm] enl % depthstep = depthstep ! depth bin size [nm] enl % beamcurrent = beamcurrent ! [nA] enl % dwelltime = dwelltime ! [micro seconds] enl % MCsig = sig ! sample tilt angle [degrees] enl % MComega = omega ! tilt about RD axis [degrees] enl % L = L ! scintillator to sample distance [micro m] enl % xpc = xpc ! units of pixel [dimensionless] enl % ypc = ypc ! units of pixel [dimensionless] enl % thetac = thetac ! camera elevation [degrees] enl % delta = delta ! physical size of detector pixel [micro m] enl % numsx = numsx ! number of pixel is x direction of scintillator enl % numsy = numsy ! number of pixel is y direction of scintillator enl % binning = binning ! detector binning enl % scalingmode = scalingmode ! intensity scaling in detector enl % gammavalue = gammavalue ! intensity scaling factor enl % maskpattern = maskpattern ! circular mask or not enl % nthreads = nthreads ! number of CPU threads for computation enl % platid = platid ! platform id for GPU enl % devid = devid ! device id for GPU enl % globalworkgrpsz = globalworkgrpsz ! work group size enl % eulerconvention = eulerconvention ! euler angle convention enl % anglefile = anglefile ! list of euler angles for which simulation is done enl % datafile = datafile ! output HDF5 file enl % multiplier = multiplier ! fill other namelist variables in the ebsd namelist; will be used to write the HDF5 files etc. enl % energyaverage = 0 enl % spatialaverage = 'n' enl % alphaBD = 0.0 enl % energyfile = 'undefined' enl % masterfile = 'undefined' enl % nsx = enl % numsx enl % nsy = enl % numsy enl % num_el = 10 ! this is variable in the MCOpenCL program, here we keep it to a fixed value enl % MCnthreads = enl % nthreads enl % npx = enl % numsx enl % npy = enl % numsy enl % MCmode = 'full' enl % numEbins = int (( enl % EkeV - enl % Ehistmin ) / enl % Ebinsize ) + 1 enl % numzbins = int ( enl % depthmax / enl % depthstep ) + 1 end subroutine GetEBSDFullNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetSRdefectNameList ! !> @author Patrick Callahan ! !> @brief read namelist file for EMSRdefect ! !> @param nmlfile namelist file name ! !> @date 02/10/17  PGC 1.0 new routine !-------------------------------------------------------------------------- recursive SUBROUTINE GetSRdefectNameList ( nmlfile , srdnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetSRdefectNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( SRdefectNameListType ), INTENT ( INOUT ) :: srdnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . real ( kind = sgl ) :: DF_L integer ( kind = irg ) :: DF_npix integer ( kind = irg ) :: DF_npiy real ( kind = sgl ) :: DF_slice real ( kind = sgl ) :: dmin character ( 4 ) :: progmode integer ( kind = irg ) :: dinfo character ( 3 ) :: outputformat integer ( kind = irg ) :: output character ( fnlen ) :: dataname integer ( kind = irg ) :: t_interval character ( fnlen ) :: dispfile integer ( kind = irg ) :: nthreads character ( 3 ) :: dispmode character ( fnlen ) :: xtalname real ( kind = sgl ) :: voltage integer ( kind = irg ) :: SRG ( 3 ) integer ( kind = irg ) :: Grange real ( kind = sgl ) :: GLaue character ( fnlen ) :: STEMnmlfile character ( fnlen ) :: defectfilename ! DEFINE THE IO NAMELIST FOR VARIABLE PASSING namelist / SRdefectdata / DF_L , DF_npix , DF_npiy , DF_slice , dmin , progmode ,& dinfo , outputformat , output , dataname , t_interval , dispfile , & nthreads , dispmode , xtalname , voltage , SRG , Grange , GLaue , & STEMnmlfile , defectfilename !nthreads, voltage, progmode, xtalname, SRG, lauec, STEMnmlfile, & !                         dataname, defectfilename, dispmode, dispfile, output, dinfo, t_interval, DF_L, & !                         DF_npix, DF_npiy, DF_slice, dmin ! SET INPUT PARAMETERS TO DEFAULT VALUES (EXCEPT XTALNAME, WHICH MUST BE PRESENT) nthreads = 6 voltage = 200000 progmode = 'STEM' xtalname = 'undefined' SRG = ( / 0.0 , 0.0 , 1.0 / ) Grange = 4 GLaue = 0.5 !lauec = (/ 0.0, 0.0 /) STEMnmlfile = 'STEM_rundata.nml' defectfilename = 'EMdefec/dispt.json' dataname = '/folder/to/trialbinary.data' dispmode = 'not' dispfile = 'test_ZA.data' output = 6 ! screen output dinfo = 0 ! 1 is verbose t_interval = 5 ! update every x steps DF_L = 1.0 DF_npix = 256 DF_npiy = 256 DF_slice = 1.0 ! slice thickness for scattering matrix approach (nmu) dmin = 0.03 if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = SRdefectdata ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'SRdefect:' , ' crystal structure file name is undefined in ' // nmlfile ) end if end if srdnl % DF_L = DF_L srdnl % DF_npix = DF_npix srdnl % DF_npiy = DF_npiy srdnl % DF_slice = DF_slice srdnl % dmin = dmin srdnl % progmode = progmode srdnl % dinfo = dinfo srdnl % outputformat = outputformat srdnl % output = output srdnl % dataname = dataname srdnl % t_interval = t_interval srdnl % dispfile = dispfile srdnl % nthreads = nthreads srdnl % dispmode = dispmode srdnl % xtalname = xtalname srdnl % voltage = voltage srdnl % SRG = SRG srdnl % Grange = Grange srdnl % GLaue = GLaue srdnl % STEMnmlfile = STEMnmlfile srdnl % defectfilename = defectfilename !srdnl%nthreads = nthreads !srdnl%voltage = voltage !srdnl%progmode = progmode !srdnl%xtalname = xtalname !srdnl%SRG = SRG !srdnl%lauec = lauec !srdnl%STEMnmlfile = STEMnmlfile !srdnl%dataname = dataname !srdnl%defectfilename = defectfilename !srdnl%dispmode = dispmode !srdnl%dispfile = dispfile !srdnl%output = output !srdnl%dinfo = dinfo !srdnl%t_interval = t_interval !srdnl%DF_L = DF_L !srdnl%DF_npix = DF_npix !srdnl%DF_npiy = DF_npiy !srdnl%DF_slice = DF_slice !srdnl%dmin = dmin END SUBROUTINE GetSRdefectNameList !-------------------------------------------------------------------------- ! ! SUBROUTINE:GetPFInversionNameList ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief read namelist file and fill enl structure (used by PFInversionSIRT.f90) ! !> @param nmlfile namelist file name !> @param epf single name list structure ! !> @date 04/02/17  SS 1.0 original !-------------------------------------------------------------------------- recursive subroutine GetPFInversionNameList ( nmlfile , epf , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetPFInversionNameList use error use constants IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( PFInversionNameListType ), INTENT ( INOUT ) :: epf logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: nLam , nfiles , nSIRT , ncub character ( fnlen ) :: xtalname character ( fnlen ) :: datafile , flist ( 10 ) namelist / PFInversion / nLam , xtalname , datafile , nfiles , flist , nSIRT , ncub nLam = 20 xtalname = 'undefined' flist ( 1 : 10 ) = 'undefined' nfiles = 1 datafile = 'undefined' nSIRT = 20 ncub = 40 if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( nmlfile ), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = PFInversion ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'PFForwardTest:' , ' xtal file name is undefined in ' // nmlfile ) end if if ( trim ( datafile ). eq . 'undefined' ) then call FatalError ( 'PFForwardTest:' , ' datafile name is undefined in ' // nmlfile ) end if end if epf % xtalname = xtalname epf % nfiles = nfiles epf % flist ( 1 : nfiles ) = flist ( 1 : nfiles ) epf % nLam = nLam epf % datafile = datafile epf % nSIRT = nSIRT epf % ncub = ncub end subroutine GetPFInversionNameList end module NameListHandlers","tags":"","loc":"sourcefile/namelisthandlers.f90.html","title":"NameListHandlers.f90 – Fortran Program"},{"text":"Source Code NameListJSONwriters.f90 Source Code","tags":"","loc":"sourcefile/namelistjsonwriters.f90.html","title":"NameListJSONwriters.f90 – Fortran Program"},{"text":"Files Dependent On This One sourcefile~~namelisttypedefs.f90~~AfferentGraph sourcefile~namelisttypedefs.f90 NameListTypedefs.f90 sourcefile~namelisthandlers.f90 NameListHandlers.f90 sourcefile~namelisttypedefs.f90->sourcefile~namelisthandlers.f90 sourcefile~indexingmod.f90 Indexingmod.f90 sourcefile~namelisttypedefs.f90->sourcefile~indexingmod.f90 sourcefile~pedmod.f90 PEDmod.f90 sourcefile~namelisttypedefs.f90->sourcefile~pedmod.f90 sourcefile~jsonsupport.f90 JSONsupport.f90 sourcefile~namelisttypedefs.f90->sourcefile~jsonsupport.f90 sourcefile~emdymod.f90 EMdymod.f90 sourcefile~namelisttypedefs.f90->sourcefile~emdymod.f90 sourcefile~namelisthandlers.f90->sourcefile~jsonsupport.f90 sourcefile~indexingmod.f90->sourcefile~emdymod.f90 sourcefile~defectmodule.f90 defectmodule.f90 sourcefile~jsonsupport.f90->sourcefile~defectmodule.f90 sourcefile~simulated_annealing.f90 simulated_annealing.f90 sourcefile~emdymod.f90->sourcefile~simulated_annealing.f90 sourcefile~dispfield.f90 dispfield.f90 sourcefile~defectmodule.f90->sourcefile~dispfield.f90 var pansourcefilenamelisttypedefsf90AfferentGraph = svgPanZoom('#sourcefilenamelisttypedefsf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules NameListTypedefs Source Code NameListTypedefs.f90 Source Code ! ################################################################### ! Copyright (c) 2013-2014, Marc De Graef/Carnegie Mellon University ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without modification, are ! permitted provided that the following conditions are met: ! !     - Redistributions of source code must retain the above copyright notice, this list !        of conditions and the following disclaimer. !     - Redistributions in binary form must reproduce the above copyright notice, this !        list of conditions and the following disclaimer in the documentation and/or !        other materials provided with the distribution. !     - Neither the names of Marc De Graef, Carnegie Mellon University nor the names !        of its contributors may be used to endorse or promote products derived from !        this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE ! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ################################################################### !-------------------------------------------------------------------------- ! EMsoft:NameListTypedefs.f90 !-------------------------------------------------------------------------- ! ! PROGRAM: NameListTypedefs ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief collection of namelist type declarations ! !> @date 06/13/14 MDG 1.0 initial version !> @date 05/05/15 MDG 1.1 removed primelist variable from name list files !> @date 11/24/15 MDG 1.2 siginificant changes to ECCINameListType !-------------------------------------------------------------------------- module NameListTypedefs use local IMPLICIT NONE ! namelist for EMmultiphases program type MultiPhaseNameListType integer ( kind = irg ) :: nthreads character ( fnlen ) :: dp1file character ( fnlen ) :: dp2file character ( fnlen ) :: dp3file character ( fnlen ) :: outputfile end type MultiPhaseNameListType ! namelist for the EMKossel program type KosselNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numthick integer ( kind = irg ) :: npix integer ( kind = irg ) :: maxHOLZ integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: k ( 3 ) integer ( kind = irg ) :: fn ( 3 ) real ( kind = sgl ) :: voltage real ( kind = sgl ) :: dmin real ( kind = sgl ) :: convergence real ( kind = sgl ) :: startthick real ( kind = sgl ) :: thickinc real ( kind = sgl ) :: minten character ( fnlen ) :: xtalname character ( fnlen ) :: outname end type KosselNameListType ! namelist for the EMKosselmaster program type KosselMasterNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numthick integer ( kind = irg ) :: npx integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: voltage real ( kind = sgl ) :: dmin real ( kind = sgl ) :: startthick real ( kind = sgl ) :: thickinc real ( kind = sgl ) :: tfraction character ( 6 ) :: Kosselmode character ( fnlen ) :: xtalname character ( fnlen ) :: outname end type KosselMasterNameListType ! namelist for the EMMC program type MCNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numsx integer ( kind = irg ) :: primeseed integer ( kind = irg ) :: num_el integer ( kind = irg ) :: nthreads real ( kind = dbl ) :: sig real ( kind = dbl ) :: omega real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep character ( 4 ) :: MCmode character ( fnlen ) :: xtalname character ( fnlen ) :: dataname end type MCNameListType ! namelist for the EMMCLIPSS program ! PGC added 12/01/15 type MCLIPSSNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numsx integer ( kind = irg ) :: primeseed integer ( kind = irg ) :: num_el integer ( kind = irg ) :: nthreads real ( kind = dbl ) :: sig real ( kind = dbl ) :: omega real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep real ( kind = dbl ) :: lipssamp real ( kind = dbl ) :: lipsswave real ( kind = dbl ) :: scaled integer ( kind = irg ) :: npx integer ( kind = irg ) :: vis character ( 4 ) :: MCmode character ( fnlen ) :: xtalname character ( fnlen ) :: dataname end type MCLIPSSNameListType ! namelist for the EMreflectors program type reflectorNameListType integer ( kind = irg ) :: numphi integer ( kind = irg ) :: numtheta real ( kind = sgl ) :: dmin character ( fnlen ) :: masterfile character ( fnlen ) :: energyfile end type reflectorNameListType ! namelist for the EMreflectors program type kinematicalNameListType real ( kind = sgl ) :: dmin real ( kind = sgl ) :: thr real ( kind = sgl ) :: voltage character ( fnlen ) :: xtalname character ( fnlen ) :: datafile end type kinematicalNameListType type OrientationVizNameListType integer ( kind = irg ) :: cubochoric integer ( kind = irg ) :: homochoric integer ( kind = irg ) :: rodrigues integer ( kind = irg ) :: stereographic integer ( kind = irg ) :: eulerspace integer ( kind = irg ) :: reducetoRFZ integer ( kind = irg ) :: nx integer ( kind = irg ) :: ny integer ( kind = irg ) :: nz integer ( kind = irg ) :: overridepgnum integer ( kind = irg ) :: MacKenzieCell real ( kind = sgl ) :: rgb ( 3 ) real ( kind = sgl ) :: sphrad real ( kind = sgl ) :: distance character ( 3 ) :: scalingmode character ( fnlen ) :: df3file character ( fnlen ) :: xtalname character ( fnlen ) :: povrayfile character ( fnlen ) :: anglefile end type OrientationVizNameListType type ConvertOrientationsNameListType integer ( kind = irg ) :: reducetoRFZ character ( fnlen ) :: xtalname character ( fnlen ) :: cubochoric character ( fnlen ) :: homochoric character ( fnlen ) :: rodrigues character ( fnlen ) :: stereographic character ( fnlen ) :: eulerangles character ( fnlen ) :: axisangle character ( fnlen ) :: quaternion character ( fnlen ) :: rotationmatrix character ( fnlen ) :: anglefile end type ConvertOrientationsNameListType ! namelist for the EMMCOpenCL program type MCCLNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numsx integer ( kind = irg ) :: globalworkgrpsz integer ( kind = irg ) :: num_el integer ( kind = irg ) :: totnum_el integer ( kind = irg ) :: multiplier integer ( kind = irg ) :: devid integer ( kind = irg ) :: platid real ( kind = dbl ) :: sig real ( kind = dbl ) :: sigstart real ( kind = dbl ) :: sigend real ( kind = dbl ) :: sigstep real ( kind = dbl ) :: omega real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep real ( kind = dbl ) :: thickness real ( kind = dbl ) :: radius real ( kind = dbl ) :: incloc character ( 4 ) :: MCmode character ( fnlen ) :: xtalname character ( fnlen ) :: dataname character ( fnlen ) :: mode end type MCCLNameListType ! namelist for the MCCLMultiLayer program type MCCLMultiLayerNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numsx integer ( kind = irg ) :: globalworkgrpsz integer ( kind = irg ) :: num_el integer ( kind = irg ) :: totnum_el real ( kind = dbl ) :: sig real ( kind = dbl ) :: omega real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep real ( kind = dbl ) :: filmthickness real ( kind = dbl ) :: filmstep character ( 4 ) :: MCmode character ( fnlen ) :: xtalname_film character ( fnlen ) :: xtalname_subs character ( fnlen ) :: dataname character ( fnlen ) :: mode end type MCCLMultiLayerNameListType ! namelist for the EMEBSDmaster program type EBSDMasterNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: npx integer ( kind = irg ) :: Esel integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: dmin character ( fnlen ) :: energyfile character ( fnlen ) :: outname logical :: restart logical :: uniform end type EBSDMasterNameListType ! namelist for the EMTKDmaster program type TKDMasterNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: npx integer ( kind = irg ) :: Esel integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: dmin character ( fnlen ) :: energyfile character ( fnlen ) :: outname logical :: restart logical :: uniform end type TKDMasterNameListType ! namelist for the EMEBSDmasterOpenCL program type EBSDMasterOpenCLNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: npx integer ( kind = irg ) :: Esel integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: platid integer ( kind = irg ) :: devid integer ( kind = irg ) :: globalworkgrpsz real ( kind = sgl ) :: dmin character ( fnlen ) :: energyfile character ( fnlen ) :: outname logical :: restart logical :: uniform end type EBSDMasterOpenCLNameListType ! namelist for the EMEBSD program ! note that not all of these are actually entered via a namelist file ! some of them are used to facilitate passing of subroutine arguments in EBSDmod.f90 type EBSDNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numsx integer ( kind = irg ) :: numsy integer ( kind = irg ) :: binning integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: energyaverage real ( kind = sgl ) :: L real ( kind = sgl ) :: thetac real ( kind = sgl ) :: delta real ( kind = sgl ) :: omega real ( kind = sgl ) :: xpc real ( kind = sgl ) :: ypc real ( kind = sgl ) :: energymin real ( kind = sgl ) :: energymax real ( kind = sgl ) :: gammavalue real ( kind = sgl ) :: axisangle ( 4 ) real ( kind = sgl ) :: alphaBD real ( kind = dbl ) :: beamcurrent real ( kind = dbl ) :: dwelltime character ( 1 ) :: maskpattern character ( 3 ) :: scalingmode character ( 3 ) :: eulerconvention character ( 3 ) :: outputformat character ( 1 ) :: spatialaverage character ( fnlen ) :: anglefile character ( fnlen ) :: masterfile character ( fnlen ) :: energyfile character ( fnlen ) :: datafile ! everything below here is not part of the namelist input structure, but is used to pass arguments to subroutines integer ( kind = irg ) :: numangles integer ( kind = irg ) :: numEbins integer ( kind = irg ) :: numzbins integer ( kind = irg ) :: nsx integer ( kind = irg ) :: nsy integer ( kind = irg ) :: num_el integer ( kind = irg ) :: MCnthreads integer ( kind = irg ) :: npx integer ( kind = irg ) :: npy integer ( kind = irg ) :: nE integer ( kind = irg ) :: numset real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep real ( kind = dbl ) :: MCsig real ( kind = dbl ) :: MComega character ( 4 ) :: MCmode ! Monte Carlo mode character ( 5 ) :: anglemode ! 'quats' or 'euler' for angular input character ( 6 ) :: sqorhe ! from Master file, square or hexagonal Lambert projection character ( 8 ) :: MCscversion character ( 8 ) :: Masterscversion character ( fnlen ) :: Masterprogname character ( fnlen ) :: Masterxtalname character ( fnlen ) :: Masterenergyfile character ( fnlen ) :: MCprogname character ( fnlen ) :: MCxtalname real ( kind = dbl ) :: dmin integer ( kind = irg ) :: totnum_el integer ( kind = irg ) :: platid integer ( kind = irg ) :: devid integer ( kind = irg ) :: globalworkgrpsz integer ( kind = irg ) :: multiplier end type EBSDNameListType ! namelist for the EMTKD program ! note that not all of these are actually entered via a namelist file ! some of them are used to facilitate passing of subroutine arguments in EBSDmod.f90 type TKDNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numsx integer ( kind = irg ) :: numsy integer ( kind = irg ) :: binning integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: energyaverage real ( kind = sgl ) :: L real ( kind = sgl ) :: thetac real ( kind = sgl ) :: delta real ( kind = sgl ) :: omega real ( kind = sgl ) :: xpc real ( kind = sgl ) :: ypc real ( kind = sgl ) :: energymin real ( kind = sgl ) :: energymax real ( kind = sgl ) :: gammavalue real ( kind = sgl ) :: axisangle ( 4 ) real ( kind = sgl ) :: alphaBD real ( kind = dbl ) :: beamcurrent real ( kind = dbl ) :: dwelltime character ( 1 ) :: maskpattern character ( 3 ) :: scalingmode character ( 3 ) :: eulerconvention character ( 3 ) :: outputformat character ( 1 ) :: spatialaverage character ( fnlen ) :: anglefile character ( fnlen ) :: masterfile character ( fnlen ) :: energyfile character ( fnlen ) :: datafile ! everything below here is not part of the namelist input structure, but is used to pass arguments to subroutines integer ( kind = irg ) :: numangles integer ( kind = irg ) :: numEbins integer ( kind = irg ) :: numzbins integer ( kind = irg ) :: nsx integer ( kind = irg ) :: nsy integer ( kind = irg ) :: num_el integer ( kind = irg ) :: MCnthreads integer ( kind = irg ) :: npx integer ( kind = irg ) :: npy integer ( kind = irg ) :: nE integer ( kind = irg ) :: numset real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep real ( kind = dbl ) :: MCsig real ( kind = dbl ) :: MComega character ( 4 ) :: MCmode ! Monte Carlo mode character ( 5 ) :: anglemode ! 'quats' or 'euler' for angular input character ( 6 ) :: sqorhe ! from Master file, square or hexagonal Lambert projection character ( 8 ) :: MCscversion character ( 8 ) :: Masterscversion character ( fnlen ) :: Masterprogname character ( fnlen ) :: Masterxtalname character ( fnlen ) :: Masterenergyfile character ( fnlen ) :: MCprogname character ( fnlen ) :: MCxtalname real ( kind = dbl ) :: dmin integer ( kind = irg ) :: totnum_el integer ( kind = irg ) :: platid integer ( kind = irg ) :: devid integer ( kind = irg ) :: globalworkgrpsz integer ( kind = irg ) :: multiplier end type TKDNameListType ! namelist for the EMEBSD program ! note that not all of these are actually entered via a namelist file ! some of them are used to facilitate passing of subroutine arguments in EBSDmod.f90 type EBSDdetparmscanNameListType integer ( kind = irg ) :: numdetparm integer ( kind = irg ) :: numeuler real ( kind = sgl ) :: DetParms ( 3 ) real ( kind = sgl ) :: Eulertriplet ( 3 ) real ( kind = sgl ) :: DetParmstepsize ( 3 ) real ( kind = sgl ) :: Cubochoricstepsize ( 3 ) end type EBSDdetparmscanNameListType ! namelist for the EMEBSDoverlap program ! note that not all of these are actually entered via a namelist file ! some of them are used to facilitate passing of subroutine arguments in EBSDmod.f90 type EBSDoverlapNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: PatternAxisA ( 3 ) integer ( kind = irg ) :: HorizontalAxisA ( 3 ) real ( kind = sgl ) :: tA ( 3 ) real ( kind = sgl ) :: tB ( 3 ) real ( kind = sgl ) :: gA ( 3 ) real ( kind = sgl ) :: gB ( 3 ) real ( kind = sgl ) :: fracA character ( fnlen ) :: masterfileA character ( fnlen ) :: masterfileB character ( fnlen ) :: datafile ! everything below here is not part of the namelist input structure, but is used to pass arguments to subroutines integer ( kind = irg ) :: numset integer ( kind = irg ) :: npx integer ( kind = irg ) :: npy integer ( kind = irg ) :: nE character ( 6 ) :: sqorhe ! from Master file, square or hexagonal Lambert projection character ( 8 ) :: Masterscversion character ( fnlen ) :: Masterprogname character ( fnlen ) :: masterfile character ( fnlen ) :: Masterxtalname character ( fnlen ) :: xtalnameA character ( fnlen ) :: xtalnameB character ( fnlen ) :: Masterenergyfile end type EBSDoverlapNameListType ! EMEBSDcluster name list type EBSDclusterNameListType integer ( kind = irg ) :: NClusters integer ( kind = irg ) :: NIterations integer ( kind = irg ) :: NScanColumns integer ( kind = irg ) :: NScanRows integer ( kind = irg ) :: binfactor character ( fnlen ) :: inputfilename character ( fnlen ) :: groupname character ( fnlen ) :: datasetname end type EBSDclusterNameListType ! ECP structure; note that cell distortions are disabled for now type ECPNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: fn_f ( 3 ) integer ( kind = irg ) :: fn_s ( 3 ) integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: npix integer ( kind = irg ) :: gF ( 3 ) integer ( kind = irg ) :: gS ( 3 ) integer ( kind = irg ) :: tF ( 3 ) integer ( kind = irg ) :: tS ( 3 ) real ( kind = sgl ) :: thetac real ( kind = sgl ) :: filmthickness character ( 1 ) :: maskpattern character ( fnlen ) :: xtalname character ( fnlen ) :: xtalname2 character ( fnlen ) :: energyfile character ( fnlen ) :: filmfile character ( fnlen ) :: subsfile character ( fnlen ) :: masterfile character ( fnlen ) :: datafile character ( fnlen ) :: anglefile character ( 3 ) :: eulerconvention real ( kind = sgl ) :: gammavalue character ( 3 ) :: outputformat real ( kind = dbl ) :: sampletilt real ( kind = sgl ) :: workingdistance real ( kind = sgl ) :: Rin real ( kind = sgl ) :: Rout ! everything below here is not part of the namelist input structure, but is used to pass arguments to subroutines integer ( kind = irg ) :: numangle integer ( kind = irg ) :: numangle_anglefile integer ( kind = irg ) :: numEbins integer ( kind = irg ) :: numzbins integer ( kind = irg ) :: nsx integer ( kind = irg ) :: nsy integer ( kind = irg ) :: num_el integer ( kind = irg ) :: MCnthreads integer ( kind = irg ) :: npx integer ( kind = irg ) :: npy integer ( kind = irg ) :: nE integer ( kind = irg ) :: numset integer ( kind = irg ) :: npolar integer ( kind = irg ) :: nazimuth real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep real ( kind = sgl ) :: dmin real ( kind = dbl ) :: MCsigstart real ( kind = dbl ) :: MCsigend real ( kind = dbl ) :: MCsigstep real ( kind = dbl ) :: MComega character ( 4 ) :: MCmode ! Monte Carlo mode character ( 5 ) :: anglemode ! 'quats' or 'euler' for angular input character ( 6 ) :: sqorhe ! from Master file, square or hexagonal Lambert projection character ( 8 ) :: MCscversion character ( 8 ) :: Masterscversion character ( fnlen ) :: Masterprogname character ( fnlen ) :: Masterxtalname character ( fnlen ) :: Masterenergyfile character ( fnlen ) :: MCprogname character ( fnlen ) :: MCxtalname end type ECPNameListType ! LACBED structure type LACBEDNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: k ( 3 ) integer ( kind = irg ) :: fn ( 3 ) integer ( kind = irg ) :: maxHOLZ integer ( kind = irg ) :: numthick integer ( kind = irg ) :: npix integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: voltage real ( kind = sgl ) :: dmin real ( kind = sgl ) :: convergence real ( kind = sgl ) :: startthick real ( kind = sgl ) :: thickinc real ( kind = sgl ) :: minten character ( fnlen ) :: xtalname character ( fnlen ) :: outname end type LACBEDNameListType ! namelist for the EMECPmaster program type ECPMasterNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: npx integer ( kind = irg ) :: Esel integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: dmin character ( fnlen ) :: compmode character ( fnlen ) :: energyfile character ( fnlen ) :: outname end type ECPMasterNameListType !namelist for the EMECP program type ECPpatternNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: npix real ( kind = sgl ) :: thetac real ( kind = sgl ) :: k ( 3 ) character ( fnlen ) :: masterfile character ( fnlen ) :: outname end type ECPpatternNameListType !namelist for the EMECPZA program type ECPZANameListType integer ( kind = irg ) :: fn ( 3 ) integer ( kind = irg ) :: k ( 3 ) integer ( kind = irg ) :: npix integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: dmin real ( kind = sgl ) :: ktmax character ( 1 ) :: maskpattern character ( fnlen ) :: energyfile character ( fnlen ) :: outname end type ECPZANameListType !namelist for the EMPED program type PEDZANameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: k ( 3 ) integer ( kind = irg ) :: fn ( 3 ) integer ( kind = irg ) :: precsample integer ( kind = irg ) :: precazimuthal integer ( kind = irg ) :: npix integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: voltage real ( kind = sgl ) :: dmin real ( kind = sgl ) :: precangle real ( kind = sgl ) :: prechalfwidth real ( kind = sgl ) :: thickness real ( kind = sgl ) :: camlen character ( 5 ) :: filemode character ( fnlen ) :: xtalname character ( fnlen ) :: outname end type PEDZANameListType !namelist for the EMPEDkin program type PEDkinNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: npix integer ( kind = irg ) :: ncubochoric integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: voltage real ( kind = sgl ) :: dmin real ( kind = sgl ) :: thickness real ( kind = sgl ) :: rnmpp character ( fnlen ) :: xtalname character ( fnlen ) :: outname end type PEDkinNameListType ! namelist for the EMECCI program type ECCINameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: k ( 3 ) integer ( kind = irg ) :: nktstep integer ( kind = irg ) :: DF_npix integer ( kind = irg ) :: DF_npiy real ( kind = sgl ) :: voltage real ( kind = sgl ) :: dkt real ( kind = sgl ) :: ktmax real ( kind = sgl ) :: lauec ( 2 ) real ( kind = sgl ) :: lauec2 ( 2 ) real ( kind = sgl ) :: dmin real ( kind = sgl ) :: DF_L real ( kind = sgl ) :: DF_slice character ( 4 ) :: dispmode character ( 4 ) :: summode character ( 5 ) :: progmode character ( fnlen ) :: xtalname character ( fnlen ) :: defectfilename character ( fnlen ) :: dispfile character ( fnlen ) :: dataname character ( fnlen ) :: ECPname character ( fnlen ) :: sgname end type ECCINameListType ! namelist for the EMsampleRFZ program type RFZNameListType integer ( kind = irg ) :: pgnum integer ( kind = irg ) :: nsteps integer ( kind = irg ) :: gridtype real ( kind = dbl ) :: rodrigues ( 4 ) real ( kind = dbl ) :: maxmisor real ( kind = dbl ) :: conevector ( 3 ) real ( kind = dbl ) :: semiconeangle character ( fnlen ) :: samplemode character ( fnlen ) :: euoutname character ( fnlen ) :: cuoutname character ( fnlen ) :: hooutname character ( fnlen ) :: rooutname character ( fnlen ) :: quoutname character ( fnlen ) :: omoutname character ( fnlen ) :: axoutname end type RFZNameListType type DictIndxOpenCLListType integer ( kind = irg ) :: numexptsingle integer ( kind = irg ) :: numdictsingle integer ( kind = irg ) :: totnumexpt integer ( kind = irg ) :: totnumdict integer ( kind = irg ) :: imght integer ( kind = irg ) :: imgwd integer ( kind = irg ) :: nnk character ( fnlen ) :: exptfile character ( fnlen ) :: dictfile character ( fnlen ) :: eulerfile logical :: MeanSubtraction logical :: patternflip end type DictIndxOpenCLListType type PEDKINIndxListType integer ( kind = irg ) :: npix integer ( kind = irg ) :: ncubochoric real ( kind = sgl ) :: voltage real ( kind = sgl ) :: dmin real ( kind = sgl ) :: thickness real ( kind = sgl ) :: rnmpp ! reciprocal nanometers per pixel character ( fnlen ) :: xtalname integer ( kind = irg ) :: numexptsingle integer ( kind = irg ) :: numdictsingle integer ( kind = irg ) :: ipf_ht integer ( kind = irg ) :: ipf_wd integer ( kind = irg ) :: nnk real ( kind = sgl ) :: sgmax ! maximum sg value for a beam to be considered real ( kind = sgl ) :: ww ! 2*ww+1 is the size of the spot real ( kind = sgl ) :: var ! variance of gaussian peak character ( fnlen ) :: exptfile character ( fnlen ) :: datafile character ( fnlen ) :: ctffile integer ( kind = irg ) :: devid integer ( kind = irg ) :: platid integer ( kind = irg ) :: nthreads ! all variables below are used to pass values to the subroutine and not read from the namelist file real ( kind = sgl ) :: Igmax end type PEDKINIndxListType type DisorientationsNameListType integer ( kind = irg ) :: pgnum integer ( kind = irg ) :: pgnum2 character ( fnlen ) :: inputfile character ( fnlen ) :: outputfile end type DisorientationsNameListType type AverageOrientationNameListType integer ( kind = irg ) :: nmuse integer ( kind = irg ) :: reldisx integer ( kind = irg ) :: reldisy logical :: oldformat character ( fnlen ) :: dotproductfile character ( fnlen ) :: averagectffile character ( fnlen ) :: averagetxtfile character ( fnlen ) :: disorientationmap end type AverageOrientationNameListType type OrientationSimilarityNameListType integer ( kind = irg ) :: nmuse character ( fnlen ) :: dotproductfile character ( fnlen ) :: osmtiff end type OrientationSimilarityNameListType type KAMNameListType real ( kind = sgl ) :: kamcutoff integer ( kind = irg ) :: orav character ( fnlen ) :: dotproductfile character ( fnlen ) :: kamtiff end type KAMNameListType type DvsDNameListType integer ( kind = irg ) :: nmuse real ( kind = sgl ) :: maxdis real ( kind = sgl ) :: minang real ( kind = sgl ) :: maxang character ( fnlen ) :: dotproductfile character ( fnlen ) :: outfile character ( fnlen ) :: povfile character ( fnlen ) :: xtalfile end type DvsDNameListType type EBSDIndexingNameListType integer ( kind = irg ) :: ncubochoric integer ( kind = irg ) :: numexptsingle integer ( kind = irg ) :: numdictsingle integer ( kind = irg ) :: ipf_ht integer ( kind = irg ) :: ipf_wd integer ( kind = irg ) :: nnk integer ( kind = irg ) :: nnav integer ( kind = irg ) :: nosm integer ( kind = irg ) :: maskradius character ( fnlen ) :: exptfile integer ( kind = irg ) :: numsx integer ( kind = irg ) :: numsy integer ( kind = irg ) :: binning integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: energyaverage integer ( kind = irg ) :: devid integer ( kind = irg ) :: platid integer ( kind = irg ) :: nregions real ( kind = sgl ) :: L real ( kind = sgl ) :: thetac real ( kind = sgl ) :: delta real ( kind = sgl ) :: omega real ( kind = sgl ) :: xpc real ( kind = sgl ) :: ypc real ( kind = sgl ) :: energymin real ( kind = sgl ) :: energymax real ( kind = sgl ) :: gammavalue real ( kind = sgl ) :: axisangle ( 4 ) real ( kind = dbl ) :: beamcurrent real ( kind = dbl ) :: dwelltime real ( kind = dbl ) :: hipassw character ( 1 ) :: maskpattern character ( 3 ) :: scalingmode !character(3)            :: eulerconvention !character(3)            :: outputformat character ( 1 ) :: spatialaverage character ( fnlen ) :: anglefile !character(fnlen)        :: dotproductfile character ( fnlen ) :: masterfile character ( fnlen ) :: energyfile character ( fnlen ) :: datafile character ( fnlen ) :: tmpfile character ( fnlen ) :: ctffile character ( fnlen ) :: avctffile character ( fnlen ) :: angfile character ( fnlen ) :: eulerfile character ( fnlen ) :: dictfile character ( fnlen ) :: indexingmode ! everything below here is not part of the namelist input structure, but is used to pass arguments to subroutines integer ( kind = irg ) :: numangles integer ( kind = irg ) :: numEbins integer ( kind = irg ) :: numzbins integer ( kind = irg ) :: nsx integer ( kind = irg ) :: nsy integer ( kind = irg ) :: num_el integer ( kind = irg ) :: MCnthreads integer ( kind = irg ) :: npx integer ( kind = irg ) :: npy integer ( kind = irg ) :: nE integer ( kind = irg ) :: numset real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep real ( kind = dbl ) :: MCsig real ( kind = dbl ) :: MComega real ( kind = sgl ) :: dmin real ( kind = sgl ) :: StepX real ( kind = sgl ) :: StepY real ( kind = sgl ) :: WD character ( 4 ) :: MCmode ! Monte Carlo mode character ( 5 ) :: anglemode ! 'quats' or 'euler' for angular input character ( 6 ) :: sqorhe ! from Master file, square or hexagonal Lambert projection character ( 8 ) :: MCscversion character ( 8 ) :: Masterscversion character ( fnlen ) :: Masterprogname character ( fnlen ) :: Masterxtalname character ( fnlen ) :: Masterenergyfile character ( fnlen ) :: MCprogname character ( fnlen ) :: MCxtalname end type EBSDIndexingNameListType type TKDIndexingNameListType integer ( kind = irg ) :: ncubochoric integer ( kind = irg ) :: numexptsingle integer ( kind = irg ) :: numdictsingle integer ( kind = irg ) :: ipf_ht integer ( kind = irg ) :: ipf_wd integer ( kind = irg ) :: nnk integer ( kind = irg ) :: nnav integer ( kind = irg ) :: nosm integer ( kind = irg ) :: maskradius character ( fnlen ) :: exptfile integer ( kind = irg ) :: numsx integer ( kind = irg ) :: numsy integer ( kind = irg ) :: binning integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: energyaverage integer ( kind = irg ) :: devid integer ( kind = irg ) :: platid integer ( kind = irg ) :: nregions real ( kind = sgl ) :: L real ( kind = sgl ) :: thetac real ( kind = sgl ) :: delta real ( kind = sgl ) :: omega real ( kind = sgl ) :: xpc real ( kind = sgl ) :: ypc real ( kind = sgl ) :: energymin real ( kind = sgl ) :: energymax real ( kind = sgl ) :: gammavalue real ( kind = sgl ) :: axisangle ( 4 ) real ( kind = dbl ) :: beamcurrent real ( kind = dbl ) :: dwelltime real ( kind = dbl ) :: hipassw character ( 1 ) :: maskpattern character ( 3 ) :: scalingmode !character(3)            :: eulerconvention !character(3)            :: outputformat character ( 1 ) :: spatialaverage character ( fnlen ) :: anglefile !character(fnlen)        :: dotproductfile character ( fnlen ) :: masterfile character ( fnlen ) :: energyfile character ( fnlen ) :: datafile character ( fnlen ) :: tmpfile character ( fnlen ) :: ctffile character ( fnlen ) :: avctffile character ( fnlen ) :: angfile character ( fnlen ) :: eulerfile character ( fnlen ) :: dictfile character ( fnlen ) :: indexingmode ! everything below here is not part of the namelist input structure, but is used to pass arguments to subroutines integer ( kind = irg ) :: numangles integer ( kind = irg ) :: numEbins integer ( kind = irg ) :: numzbins integer ( kind = irg ) :: nsx integer ( kind = irg ) :: nsy integer ( kind = irg ) :: num_el integer ( kind = irg ) :: MCnthreads integer ( kind = irg ) :: npx integer ( kind = irg ) :: npy integer ( kind = irg ) :: nE integer ( kind = irg ) :: numset real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep real ( kind = dbl ) :: MCsig real ( kind = dbl ) :: MComega real ( kind = sgl ) :: dmin real ( kind = sgl ) :: StepX real ( kind = sgl ) :: StepY real ( kind = sgl ) :: WD character ( 4 ) :: MCmode ! Monte Carlo mode character ( 5 ) :: anglemode ! 'quats' or 'euler' for angular input character ( 6 ) :: sqorhe ! from Master file, square or hexagonal Lambert projection character ( 8 ) :: MCscversion character ( 8 ) :: Masterscversion character ( fnlen ) :: Masterprogname character ( fnlen ) :: Masterxtalname character ( fnlen ) :: Masterenergyfile character ( fnlen ) :: MCprogname character ( fnlen ) :: MCxtalname end type TKDIndexingNameListType type ECPIndexingNameListType integer ( kind = irg ) :: ncubochoric integer ( kind = irg ) :: numexptsingle integer ( kind = irg ) :: numdictsingle integer ( kind = irg ) :: totnumexpt integer ( kind = irg ) :: maskradius integer ( kind = irg ) :: nnk integer ( kind = irg ) :: platid integer ( kind = irg ) :: devid integer ( kind = irg ) :: nregions character ( fnlen ) :: exptfile integer ( kind = irg ) :: fn_f ( 3 ) integer ( kind = irg ) :: fn_s ( 3 ) integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: npix integer ( kind = irg ) :: gF ( 3 ) integer ( kind = irg ) :: gS ( 3 ) integer ( kind = irg ) :: tF ( 3 ) integer ( kind = irg ) :: tS ( 3 ) real ( kind = sgl ) :: thetac real ( kind = sgl ) :: filmthickness character ( 1 ) :: maskpattern character ( fnlen ) :: xtalname character ( fnlen ) :: xtalname2 character ( fnlen ) :: energyfile character ( fnlen ) :: filmfile character ( fnlen ) :: subsfile character ( fnlen ) :: masterfile character ( fnlen ) :: datafile character ( fnlen ) :: tmpfile character ( fnlen ) :: ctffile character ( fnlen ) :: anglefile character ( 3 ) :: eulerconvention real ( kind = sgl ) :: gammavalue character ( 3 ) :: outputformat real ( kind = dbl ) :: sampletilt real ( kind = sgl ) :: workingdistance real ( kind = sgl ) :: Rin real ( kind = sgl ) :: Rout ! everything below here is not part of the namelist input structure, but is used to pass arguments to subroutines integer ( kind = irg ) :: numangle integer ( kind = irg ) :: numangle_anglefile integer ( kind = irg ) :: numEbins integer ( kind = irg ) :: numzbins integer ( kind = irg ) :: nsx integer ( kind = irg ) :: nsy integer ( kind = irg ) :: num_el integer ( kind = irg ) :: MCnthreads integer ( kind = irg ) :: npx integer ( kind = irg ) :: npy integer ( kind = irg ) :: nE integer ( kind = irg ) :: numset integer ( kind = irg ) :: npolar integer ( kind = irg ) :: nazimuth real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep real ( kind = sgl ) :: dmin real ( kind = dbl ) :: MCsigstart real ( kind = dbl ) :: MCsigend real ( kind = dbl ) :: MCsigstep real ( kind = dbl ) :: MComega character ( 4 ) :: MCmode ! Monte Carlo mode character ( 5 ) :: anglemode ! 'quats' or 'euler' for angular input character ( 6 ) :: sqorhe ! from Master file, square or hexagonal Lambert projection character ( 8 ) :: MCscversion character ( 8 ) :: Masterscversion character ( fnlen ) :: Masterprogname character ( fnlen ) :: Masterxtalname character ( fnlen ) :: Masterenergyfile character ( fnlen ) :: MCprogname character ( fnlen ) :: MCxtalname end type ECPIndexingNameListType type ZAdefectnameListType character ( fnlen ) :: xtalname real ( kind = sgl ) :: voltage integer ( kind = irg ) :: kk ( 3 ) real ( kind = sgl ) :: lauec ( 2 ) real ( kind = sgl ) :: dmin ! EM or STEM ? character ( fnlen ) :: progmode character ( fnlen ) :: STEMnmlfile character ( fnlen ) :: foilnmlfile ! column approximation parameters and image parameters real ( kind = sgl ) :: DF_L real ( kind = sgl ) :: DF_npix real ( kind = sgl ) :: DF_npiy real ( kind = sgl ) :: DF_slice integer ( kind = irg ) :: dinfo character ( fnlen ) :: sgname ! defect parameters integer ( kind = irg ) :: numdisl integer ( kind = irg ) :: numsf integer ( kind = irg ) :: numinc integer ( kind = irg ) :: numvoids character ( fnlen ) :: voidname character ( fnlen ) :: dislname character ( fnlen ) :: sfname character ( fnlen ) :: incname character ( fnlen ) :: dispfile character ( fnlen ) :: dispmode ! output parameters character ( fnlen ) :: dataname integer ( kind = irg ) :: t_interval end type ZAdefectnameListType type EMDPFitListType character ( fnlen ) :: modalityname character ( fnlen ) :: masterfile character ( fnlen ) :: exptfile real ( kind = dbl ) :: rhobeg real ( kind = dbl ) :: rhoend logical :: verbose logical :: mask real ( kind = irg ) :: maskradius real ( kind = sgl ) :: gammavalue real ( kind = sgl ) :: phi , phi1 , phi2 real ( kind = sgl ) :: L real ( kind = sgl ) :: thetac real ( kind = sgl ) :: delta real ( kind = sgl ) :: omega integer ( kind = irg ) :: numsx integer ( kind = irg ) :: numsy integer ( kind = irg ) :: binning real ( kind = sgl ) :: xpc real ( kind = sgl ) :: ypc real ( kind = sgl ) :: beamcurrent real ( kind = sgl ) :: dwelltime integer ( kind = irg ) :: npix real ( kind = sgl ) :: Rin real ( kind = sgl ) :: Rout real ( kind = sgl ) :: thetacone real ( kind = sgl ) :: sampletilt real ( kind = sgl ) :: workingdistance real ( kind = sgl ) :: step_xpc real ( kind = sgl ) :: step_ypc real ( kind = sgl ) :: step_L real ( kind = sgl ) :: step_phi1 real ( kind = sgl ) :: step_phi real ( kind = sgl ) :: step_phi2 real ( kind = sgl ) :: step_thetacone integer ( kind = irg ) :: nrun integer ( kind = irg ) :: nregions character ( 2 ) :: metric end type EMDPFitListType type EMDPFit4ListType character ( fnlen ) :: modalityname character ( fnlen ) :: masterfile character ( fnlen ) :: exptfile_pat1 character ( fnlen ) :: exptfile_pat2 character ( fnlen ) :: exptfile_pat3 character ( fnlen ) :: exptfile_pat4 real ( kind = dbl ) :: rhobeg real ( kind = dbl ) :: rhoend logical :: verbose logical :: mask real ( kind = irg ) :: maskradius real ( kind = sgl ) :: gammavalue real ( kind = sgl ) :: phi_pat1 , phi1_pat1 , phi2_pat1 real ( kind = sgl ) :: phi_pat2 , phi1_pat2 , phi2_pat2 real ( kind = sgl ) :: phi_pat3 , phi1_pat3 , phi2_pat3 real ( kind = sgl ) :: phi_pat4 , phi1_pat4 , phi2_pat4 real ( kind = sgl ) :: L real ( kind = sgl ) :: thetac real ( kind = sgl ) :: delta real ( kind = sgl ) :: omega integer ( kind = irg ) :: numsx integer ( kind = irg ) :: numsy integer ( kind = irg ) :: binning real ( kind = sgl ) :: xpc real ( kind = sgl ) :: ypc real ( kind = sgl ) :: beamcurrent real ( kind = sgl ) :: dwelltime integer ( kind = irg ) :: npix real ( kind = sgl ) :: Rin real ( kind = sgl ) :: Rout real ( kind = sgl ) :: thetacone real ( kind = sgl ) :: sampletilt real ( kind = sgl ) :: workingdistance real ( kind = sgl ) :: step_xpc real ( kind = sgl ) :: step_ypc real ( kind = sgl ) :: step_L real ( kind = sgl ) :: step_phi1 real ( kind = sgl ) :: step_phi real ( kind = sgl ) :: step_phi2 real ( kind = sgl ) :: step_thetacone integer ( kind = irg ) :: nrun integer ( kind = irg ) :: pixx_pat1 integer ( kind = irg ) :: pixy_pat1 integer ( kind = irg ) :: pixx_pat2 integer ( kind = irg ) :: pixy_pat2 integer ( kind = irg ) :: pixx_pat3 integer ( kind = irg ) :: pixy_pat3 integer ( kind = irg ) :: pixx_pat4 integer ( kind = irg ) :: pixy_pat4 real ( kind = sgl ) :: stepx real ( kind = sgl ) :: stepy integer ( kind = irg ) :: nregions character ( 2 ) :: metric end type EMDPFit4ListType ! ECP structure; note that cell distortions are disabled for now type ECPSingleNameListType integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: npix real ( kind = sgl ) :: thetac character ( 1 ) :: maskpattern character ( fnlen ) :: xtalname character ( fnlen ) :: energyfile character ( fnlen ) :: datafile character ( 3 ) :: eulerconvention real ( kind = sgl ) :: gammavalue real ( kind = dbl ) :: sampletilt real ( kind = sgl ) :: workingdistance real ( kind = sgl ) :: Rin real ( kind = sgl ) :: Rout real ( kind = dbl ) :: phi1 , phi , phi2 real ( kind = sgl ) :: dmin end type ECPSingleNameListType ! STEM DCI type !PGC 11/02/16 type STEMDCINameListType integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: voltage character ( 4 ) :: progmode character ( fnlen ) :: xtalname integer ( kind = irg ) :: kk ( 3 ) real ( kind = sgl ) :: lauec ( 2 ) character ( fnlen ) :: STEMnmlfile character ( fnlen ) :: dataname character ( fnlen ) :: defectfilename character ( 3 ) :: dispmode character ( fnlen ) :: dispfile integer ( kind = irg ) :: output integer ( kind = irg ) :: dinfo integer ( kind = irg ) :: t_interval real ( kind = sgl ) :: DF_L integer ( kind = irg ) :: DF_npix integer ( kind = irg ) :: DF_npiy real ( kind = sgl ) :: DF_slice real ( kind = sgl ) :: dmin end type STEMDCINameListType ! SRdefect type PGC 02/09/2017 type SRdefectNameListType real ( kind = sgl ) :: DF_L integer ( kind = irg ) :: DF_npix integer ( kind = irg ) :: DF_npiy real ( kind = sgl ) :: DF_slice real ( kind = sgl ) :: dmin character ( 4 ) :: progmode integer ( kind = irg ) :: dinfo character ( 3 ) :: outputformat integer ( kind = irg ) :: output character ( fnlen ) :: dataname integer ( kind = irg ) :: t_interval character ( fnlen ) :: dispfile integer ( kind = irg ) :: nthreads character ( 3 ) :: dispmode character ( fnlen ) :: xtalname real ( kind = sgl ) :: voltage integer ( kind = irg ) :: SRG ( 3 ) integer ( kind = irg ) :: Grange real ( kind = sgl ) :: GLaue character ( fnlen ) :: STEMnmlfile character ( fnlen ) :: defectfilename !! The following are now in ZAdefectnameListType ! :: foilnmlfile ! moved to ZAdefect type ! :: numvoids ! :: incname ! :: voidname ! :: numdisl ! :: dislname ! :: numsf ! :: sfname end type SRdefectNameListType type RefineOrientationtype integer ( kind = irg ) :: nthreads character ( fnlen ) :: dotproductfile character ( fnlen ) :: ctffile real ( kind = sgl ) :: step integer ( kind = irg ) :: nmis integer ( kind = irg ) :: niter end type RefineOrientationtype type FitOrientationPStype integer ( kind = irg ) :: nthreads character ( fnlen ) :: dotproductfile character ( fnlen ) :: ctffile real ( kind = sgl ) :: step real ( kind = sgl ) :: angleaxis ( 4 ) end type FitOrientationPStype type PFInversionNameListType integer ( kind = irg ) :: nLam integer ( kind = irg ) :: nSIRT integer ( kind = irg ) :: ncub integer ( kind = irg ) :: nfiles character ( fnlen ) :: xtalname character ( fnlen ) :: flist ( 10 ) character ( fnlen ) :: datafile end type PFInversionNameListType end module NameListTypedefs","tags":"","loc":"sourcefile/namelisttypedefs.f90.html","title":"NameListTypedefs.f90 – Fortran Program"},{"text":"Modules noise Source Code noise.f90 Source Code ! ################################################################### ! Copyright (c) 2013, Marc De Graef/Carnegie Mellon University ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without modification, are ! permitted provided that the following conditions are met: ! !     - Redistributions of source code must retain the above copyright notice, this list !        of conditions and the following disclaimer. !     - Redistributions in binary form must reproduce the above copyright notice, this !        list of conditions and the following disclaimer in the documentation and/or !        other materials provided with the distribution. !     - Neither the names of Marc De Graef, Carnegie Mellon University nor the names !        of its contributors may be used to endorse or promote products derived from !        this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE ! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ################################################################### !-------------------------------------------------------------------------- ! EMsoft:noise.f90 !-------------------------------------------------------------------------- ! ! MODULE: noise ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief Poisson noise routine ! !> @date 03/26/14 MDG 1.0 added to EMsoft from earlier EBSD version !-------------------------------------------------------------------------- module noise use local IMPLICIT NONE contains recursive function alogam ( x , ifault ) !DEC$ ATTRIBUTES DLLEXPORT :: alogam ! this function can be used to compute the volume of a super ellipsoid. !*****************************************************************************80 ! !! ALOGAM computes the logarithm of the Gamma function. ! !  Modified: ! !    28 March 1999 ! !  Author: ! !    Malcolm Pike, David Hill !    FORTRAN90 version by John Burkardt ! !  Reference: ! !    Malcolm Pike, David Hill, !    Algorithm 291: !    Logarithm of Gamma Function, !    Communications of the ACM, !    Volume 9, Number 9, September 1966, page 684. ! !  Parameters: ! !    Input, real ( kind = 8 ) X, the argument of the Gamma function. !    X should be greater than 0. ! !    Output, integer ( kind = 4 ) IFAULT, error flag. !    0, no error. !    1, X <= 0. ! !    Output, real ( kind = 8 ) ALOGAM, the logarithm of the Gamma !    function of X. ! implicit none real ( kind = 8 ) alogam real ( kind = 8 ) f integer ( kind = 4 ) ifault real ( kind = 8 ) x real ( kind = 8 ) y real ( kind = 8 ) z if ( x <= 0.0D+00 ) then ifault = 1 alogam = 0.0D+00 return end if ifault = 0 y = x if ( x < 7.0D+00 ) then f = 1.0D+00 z = y do while ( z < 7.0D+00 ) f = f * z z = z + 1.0D+00 end do y = z f = - log ( f ) else f = 0.0D+00 end if z = 1.0D+00 / y / y alogam = f + ( y - 0.5D+00 ) * log ( y ) - y & + 0.918938533204673D+00 + & ((( & - 0.000595238095238D+00 * z & + 0.000793650793651D+00 ) * z & - 0.002777777777778D+00 ) * z & + 0.083333333333333D+00 ) / y return end function alogam !***************************************************************************** real ( kind = sgl ) FUNCTION ran ( idum ) !DEC$ ATTRIBUTES DLLEXPORT :: ran ! ! copied from Numerical Recipes ! IMPLICIT NONE INTEGER , PARAMETER :: K4B = selected_int_kind ( 9 ) INTEGER ( K4B ), INTENT ( INOUT ) :: idum ! “Minimal” random number generator of Park and Miller combined with a Marsaglia shift sequence. ! Returns a uniform random deviate between 0.0 and 1.0 (exclusive of the endpoint values). ! This fully portable, scalar generator has the “traditional” (not Fortran 90) calling ! sequence with a random deviate as the returned function value: call with idum a negative ! integer to initialize; thereafter, do not alter idum except to reinitialize. The period ! of this generator is about 3.1 × 10&#94;18. INTEGER ( K4B ), PARAMETER :: IA = 16807 , IM = 2147483647 , IQ = 127773 , IR = 2836 REAL , SAVE :: am INTEGER ( K4B ), SAVE :: ix =- 1 , iy =- 1 , k if ( idum <= 0 . or . iy < 0 ) then am = nearest ( 1.0 , - 1.0 ) / IM iy = ior ( ieor ( 888889999 , abs ( idum )), 1 ) ix = ieor ( 777755555 , abs ( idum )) idum = abs ( idum ) + 1 end if ix = ieor ( ix , ishft ( ix , 13 )) ix = ieor ( ix , ishft ( ix , - 17 )) ix = ieor ( ix , ishft ( ix , 5 )) k = iy / IQ iy = IA * ( iy - k * IQ ) - IR * k if ( iy < 0 ) iy = iy + IM ran = am * ior ( iand ( IM , ieor ( ix , iy )), 1 ) END FUNCTION ran !***************************************************************************** real ( kind = sgl ) FUNCTION POIDEV ( XM , IDUM ) !DEC$ ATTRIBUTES DLLEXPORT :: POIDEV ! ! this is essentially the poidev routine from Numerical Recipes, ! but converted to Fortran-90 ! use local IMPLICIT NONE real ( kind = sgl ), INTENT ( IN ) :: XM real ( kind = sgl ), PARAMETER :: PI = 3.141592654 real ( kind = sgl ) :: OLDM =- 1.0 , T , G , EM , SQ , ALXM , Y integer ( kind = irg ) :: ifault INTEGER , PARAMETER :: K4B = selected_int_kind ( 9 ) INTEGER ( K4B ), INTENT ( INOUT ) :: IDUM ! start here: if ( XM . lt . 2 0. ) then ! use 20 instead of original 12 if ( XM . ne . OLDM ) then OLDM = XM G = exp ( - XM ) end if EM =- 1. T = 1. do EM = EM + 1. T = T * ran ( IDUM ) if ( T . le . G ) exit end do else if ( XM . ne . OLDM ) THEN OLDM = XM SQ = sqrt ( 2. * XM ) ALXM = alog ( XM ) G = XM * ALXM - alogam ( dble ( XM + 1. ), ifault ) end if do innerdo : do Y = TAN ( PI * ran ( IDUM )) EM = SQ * Y + XM if ( EM . ge . 0. ) exit innerdo end do innerdo EM = INT ( EM ) T = 0.9 * ( 1. + Y ** 2 ) * EXP ( EM * ALXM - alogam ( dble ( EM + 1. ), ifault ) - G ) if ( ran ( IDUM ). le . T ) exit end do end if POIDEV = EM end function end module noise","tags":"","loc":"sourcefile/noise.f90.html","title":"noise.f90 – Fortran Program"},{"text":"Files Dependent On This One sourcefile~~others.f90~~AfferentGraph sourcefile~others.f90 others.f90 sourcefile~simulated_annealing.f90 simulated_annealing.f90 sourcefile~others.f90->sourcefile~simulated_annealing.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules others Source Code others.f90 Source Code ! ################################################################### ! Copyright (c) 2014, Marc De Graef/Carnegie Mellon University ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without modification, are ! permitted provided that the following conditions are met: ! !     - Redistributions of source code must retain the above copyright notice, this list !        of conditions and the following disclaimer. !     - Redistributions in binary form must reproduce the above copyright notice, this !        list of conditions and the following disclaimer in the documentation and/or !        other materials provided with the distribution. !     - Neither the names of Marc De Graef, Carnegie Mellon University nor the names !        of its contributors may be used to endorse or promote products derived from !        this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE ! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ################################################################### !-------------------------------------------------------------------------- ! EMsoft:others.f90 !-------------------------------------------------------------------------- ! ! MODULE: others ! !> @author Marc De Graef, Carnegie Mellon University / and others ! !> @brief routines written by other people, included with permission, and adapted by MDG ! !> @details  This is the Weickenmeier-Kohl implementation of their scattering factors !>  and absorptive form factors; it is included with permission from H. Kohl. ! !> @note This code was originally f77, and was converted to f90 by MDG [5/22/01]; !> core functionality is unchanged from the f77 version, but the output statements !> were adapted to the current EMsoft package standard. ! !> @date   10/13/98 MDG 1.0 original !> @date    5/22/01 MDG 2.0 f90 !> @date   11/27/01 MDG 2.1 added kind support !-------------------------------------------------------------------------- module others use local contains !-------------------------------------------------------------------------- ! ! SUBROUTINE: fscatt ! !> @author Marc De Graef, Carnegie Mellon University !> @author A. Weickenmeier, original f77 code ! !> @brief computes the complex scattering amplitude ! !> @details 'use's error and local modules; Weickenmeier's original comments !> and notes are left unchanged in the source code. ! !> @date 5/21/01 MDG 1.0 original f90 translation !> @date 3/21/13 MDG 2.0 updated IO statements !-------------------------------------------------------------------------- complex recursive FUNCTION FSCATT ( G , UL , Z , SYMBOL , ACCVLT , ABSFLG , ACCFLG , DWFLG ) !DEC$ ATTRIBUTES DLLEXPORT :: FSCATT ! modified: 08.07.93  ! more precise fit to doyle turner table ! modified: 04.03.93  ! expansion in phonon abs. for small g ! ! Author: ! A.Weickenmeier ! Technische Hochschule Darmstadt ! Hochschulstr. 6 ! D-6100 Darmstadt ! Germany ! bitnet: XLTODA6L@DDATHD21.BITNET ! Tel.: 06151/16-3381 ! ! CALCULATES THE COMPLEX SCATTERING AMPLITUDE ! ! ! INPUT: ! ====== ! ! G     :   SCATTERING VECTOR G/(4*PI) = S = SIN(THETA)/LAMBDA ! UL    : THE RMS THERMAL DISPLACEMENT OF THE ATOM ! Z     : ATOM ! ACCVLT: ACCELERATION VOLTAGE IN KV !   NOT REQUIRED IF ACCFLG = .FALSE. ! ABSFLG: =0 NO ABSORPTION !         =1 ONLY PHONON !         =2 ONLY CORE !         =3 PHONON + CORE ! ACCFLG: IF TRUE THEN F DEPENDS ON THE ACCELERATION VOLTAGE !         IF FALSE REAL(F) MUST BE MULTIPLIED BY GAMMA, !         IMAG(F) BY GAMMA&#94;2/K0 !  NOTICE: CORE-CONTRIBUTION TO ABSORPTION DEPENDS ON !          ACCELERATION VOLTAGE !          THEREFORE IF ABSFLG >=1 !          THEN ACCFLG SHOULD BE .TRUE. ! DWFLG : IF TRUE REAL(F) WILL BE MULTIPLIED WITH THE !         DEBYE-WALLER FACTOR ! ! OUTPUT: ! ======= ! ! FSCATT: COMPLEX SCATTERING AMPLITUDE ! SYMBOL: SYMBOL OF THE ELEMENT Z ! ! UNITS: ! ====== ! ! UNIT OF LENGTH IS ANGSTROEM ! ! NOTE: ! ===== ! ! THE SCATTERING AMPLITUDES ARE MULTIPLIED BY AN ADDITIONAL ! FACTOR 4PI. ! !************************************************************************** use error real ( kind = sgl ), parameter :: FOURPI = 1 2.56637062 real ( kind = sgl ) :: K0 , A ( 4 ), B ( 4 ) integer ( kind = irg ) :: ABSFLG , Z CHARACTER ( 2 ) :: SYMBOL logical :: ACCFLG , DWFLG ! CHECK INPUT IF ( Z . LT . 1 . OR . Z . GT . 98 ) call FatalError ( 'fscatt' , ' Z is out of range' ) IF ( UL . LT . 0. ) call FatalError ( 'fscatt' , ' UL must be positive' ) IF ( G . LT . 0. ) call FatalError ( 'fscatt' , ' G must be positive' ) IF ( ACCVLT . LT . 0. ) call FatalError ( 'fscatt' , ' ACCVLT must be positive' ) IF ( DWFLG ) THEN !    CALCULATE DEBYE-WALLER FACTOR DEWA = EXP ( - . 5 * UL * UL * G * G ) ELSE DEWA = 1. END IF ! GET FITTING COEFFICIENTS CALL GETWK ( Z , SYMBOL , A , B ) S = G / FOURPI FREAL = FOURPI * DEWA * WEKO ( A , B , S ) IF ( ABSFLG . EQ . 0 ) THEN FIMA = 0. ELSE IF ( ABSFLG . EQ . 1 ) THEN FIMA = FPHON ( G , UL , A , B ) ELSE IF ( ABSFLG . EQ . 2 ) THEN FIMA = FCORE ( G , Z , ACCVLT ) * DEWA ELSE IF ( ABSFLG . EQ . 3 ) THEN FIMA = FCORE ( G , Z , ACCVLT ) * DEWA + FPHON ( G , UL , A , B ) END IF IF ( ACCFLG . EQV .. TRUE .) THEN !    CALCULATE WAVENUMBER AND GAMMA K0 = . 5068 * SQRT ( 102 2. * ACCVLT + ACCVLT * ACCVLT ) GAMMA = ( ACCVLT + 51 1. ) / 51 1. FREAL = FREAL * GAMMA FIMA = FIMA * GAMMA * GAMMA / K0 END IF FSCATT = CMPLX ( FREAL , FIMA ) END FUNCTION !******************************************************************* FUNCTION WEKO ( A , B , S ) !DEC$ ATTRIBUTES DLLEXPORT :: WEKO ! ELECTRON SCATTERING AMPLITUDE F(S) ! UPDATE 07.07.93 ! NOW 4 A AND 4 B REAL ( kind = sgl ) :: A ( 4 ), B ( 4 ) WEKO = 0. IF ( S . GT . 0. ) THEN S2 = 1. / ( S * S ) END IF DO I = 1 , 4 ARGU = B ( I ) * S * S IF ( ARGU . LT . . 1 ) THEN WEKO = WEKO + A ( I ) * B ( I ) * ( 1. - . 5 * ARGU ) ELSE IF ( ARGU . GT . 2 0. ) THEN WEKO = WEKO + A ( I ) * S2 ELSE WEKO = WEKO + A ( I ) * ( 1. - EXP ( - ARGU )) * S2 END IF END DO END FUNCTION ! *************************************************************** real FUNCTION FPHON ( G , UL , A , B ) !DEC$ ATTRIBUTES DLLEXPORT :: FPHON real ( kind = sgl ), parameter :: FOURPI = 1 2.56636 , FP2 = FOURPI * FOURPI real ( kind = sgl ) :: A ( 4 ), B ( 4 ), A1 ( 4 ), B1 ( 4 ) U2 = UL * UL DO I = 1 , 4 A1 ( I ) = A ( I ) * FP2 END DO DO I = 1 , 4 B1 ( I ) = B ( I ) / FP2 END DO FPHON = 0. G2 = G * G DEWA = EXP ( - . 5 * U2 * G2 ) DO J = 1 , 4 FPHON = FPHON + A1 ( J ) * A1 ( J ) * ( DEWA * RI1 ( B1 ( J ), B1 ( J ), G ) - RI2 ( B1 ( J ), B1 ( J ), G , UL )) DO I = 1 , J - 1 FPHON = FPHON + 2. * A1 ( J ) * A1 ( I ) * ( DEWA * RI1 ( B1 ( I ), B1 ( J ), G ) - RI2 ( B1 ( I ), B1 ( J ), G , UL )) END DO END DO END FUNCTION !***************************************************************** real FUNCTION RI1 ( BI , BJ , G ) !DEC$ ATTRIBUTES DLLEXPORT :: RI1 ! ERSTES INTEGRAL FUER DIE ABSORPTIONSPOTENTIALE real ( kind = sgl ), parameter :: PI = 3.1415927 , C = 0.5772157 G2 = G * G ! IST DIE ASYMPTOTISCHE ENTWICKLUNG ANWENDBAR? EPS = MAX ( BI , BJ ) EPS = EPS * G2 IF ( EPS . LE . 0.1 ) THEN RI1 = BI * LOG ( ( BI + BJ ) / BI ) + BJ * LOG ( ( BI + BJ ) / BJ ) RI1 = RI1 * PI IF ( G . EQ . 0. ) RETURN BI2 = BI * BI BJ2 = BJ * BJ TEMP = . 5 * BI2 * LOG ( BI / ( BI + BJ ) ) + . 5 * BJ2 * LOG ( BJ / ( BI + BJ ) ) TEMP = TEMP + . 75 * ( BI2 + BJ2 ) - . 25 * ( BI + BJ ) * ( BI + BJ ) TEMP = TEMP - . 5 * ( BI - BJ ) * ( BI - BJ ) RI1 = RI1 + PI * G2 * TEMP RETURN END IF BIG2 = BI * G2 BJG2 = BJ * G2 RI1 = 2. * C + LOG ( BIG2 ) + LOG ( BJG2 ) - 2. * EI ( - BI * BJ * G2 / ( BI + BJ )) X1 = BIG2 X2 = BIG2 * BI / ( BI + BJ ) X3 = BIG2 RI1 = RI1 + RIH1 ( X1 , X2 , X3 ) X1 = BJG2 X2 = BJG2 * BJ / ( BI + BJ ) X3 = BJG2 RI1 = RI1 + RIH1 ( X1 , X2 , X3 ) RI1 = RI1 * PI / G2 END FUNCTION !************************************************************************** real FUNCTION RI2 ( BI , BJ , G , U ) !DEC$ ATTRIBUTES DLLEXPORT :: RI2 ! ZWEITES INTEGRAL FUER DIE ABSORPTIONSPOTENTIALE real ( kind = sgl ), parameter :: PI = 3.1415927 U2 = U * U U22 = . 5 * U2 G2 = G * G BIUH = BI + . 5 * U2 BJUH = BJ + . 5 * U2 BIU = BI + U2 BJU = BJ + U2 ! IST DIE ASYMPTOTISCHE ENTWICKLUNG ANWENDBAR? EPS = MAX ( BI , BJ , U2 ) EPS = EPS * G2 IF ( EPS . LE . 0.1 ) THEN RI2 = ( BI + U2 ) * LOG ( ( BI + BJ + U2 ) / ( BI + U2 ) ) RI2 = RI2 + BJ * LOG ( ( BI + BJ + U2 ) / ( BJ + U2 ) ) RI2 = RI2 + U2 * LOG ( U2 / ( BJ + U2 ) ) RI2 = RI2 * PI IF ( G . EQ . 0. ) RETURN TEMP = . 5 * U22 * U22 * LOG ( BIU * BJU / ( U2 * U2 ) ) TEMP = TEMP + . 5 * BIUH * BIUH * LOG ( BIU / ( BIUH + BJUH ) ) TEMP = TEMP + . 5 * BJUH * BJUH * LOG ( BJU / ( BIUH + BJUH ) ) TEMP = TEMP + . 25 * BIU * BIU + . 5 * BI * BI TEMP = TEMP + . 25 * BJU * BJU + . 5 * BJ * BJ TEMP = TEMP - . 25 * ( BIUH + BJUH ) * ( BIUH + BJUH ) TEMP = TEMP - . 5 * ( ( BI * BIU - BJ * BJU ) / ( BIUH + BJUH ) ) ** 2 TEMP = TEMP - U22 * U22 RI2 = RI2 + PI * G2 * TEMP RETURN END IF RI2 = EI ( - . 5 * U2 * G2 * BIUH / BIU ) + EI ( - . 5 * U2 * G2 * BJUH / BJU ) RI2 = RI2 - EI ( - BIUH * BJUH * G2 / ( BIUH + BJUH ) ) - EI ( - . 25 * U2 * G2 ) RI2 = 2. * RI2 X1 = . 5 * U2 * G2 X2 = . 25 * U2 * G2 X3 = . 25 * U2 * U2 * G2 / BIU RI2 = RI2 + RIH1 ( X1 , X2 , X3 ) X1 = . 5 * U2 * G2 X2 = . 25 * U2 * G2 X3 = . 25 * U2 * U2 * G2 / BJU RI2 = RI2 + RIH1 ( X1 , X2 , X3 ) X1 = BIUH * G2 X2 = BIUH * BIUH * G2 / ( BIUH + BJUH ) X3 = BIUH * BIUH * G2 / BIU RI2 = RI2 + RIH1 ( X1 , X2 , X3 ) X1 = BJUH * G2 X2 = BJUH * BJUH * G2 / ( BIUH + BJUH ) X3 = BJUH * BJUH * G2 / BJU RI2 = RI2 + RIH1 ( X1 , X2 , X3 ) RI2 = RI2 * PI / G2 END FUNCTION !************************************************************************** real FUNCTION RIH1 ( X1 , X2 , X3 ) !DEC$ ATTRIBUTES DLLEXPORT :: RIH1 ! WERTET DEN AUSDRUCK EXP(-X1) * ( EI(X2)-EI(X3) ) AUS IF ( X2 . LE . 2 0. . AND . X3 . LE . 2 0. ) THEN RIH1 = EXP ( - X1 ) * ( EI ( X2 ) - EI ( X3 ) ) RETURN END IF IF ( X2 . GT . 20 ) THEN RIH1 = EXP ( X2 - X1 ) * RIH2 ( X2 ) / X2 ELSE RIH1 = EXP ( - X1 ) * EI ( X2 ) END IF IF ( X3 . GT . 20 ) THEN RIH1 = RIH1 - EXP ( X3 - X1 ) * RIH2 ( X3 ) / X3 ELSE RIH1 = RIH1 - EXP ( - X1 ) * EI ( X3 ) END IF END FUNCTION !************************************************************************** real FUNCTION RIH2 ( X ) !DEC$ ATTRIBUTES DLLEXPORT :: RIH2 ! WERTET X*EXP(-X)*EI(X) AUS FUER GROSSE X ! DURCH INTERPOLATION DER TABELLE ... AUS ABRAMOWITZ real ( kind = sgl ), parameter :: F ( 0 : 20 ) = ( / 1.000000 , 1.005051 , 1.010206 , 1.015472 , 1.020852 , & 1.026355 , 1.031985 , 1.037751 , 1.043662 , 1.049726 , & 1.055956 , 1.062364 , 1.068965 , 1.075780 , 1.082830 , & 1.090140 , 1.097737 , 1.105647 , 1.113894 , 1.122497 , & 1.131470 / ) X1 = 1. / X I = INT ( 20 0. * X1 ) I1 = I + 1 RIH2 = F ( I ) + 20 0. * ( F ( I1 ) - F ( I ) ) * ( X1 - . 5 E - 3 * REAL ( I ) ) END FUNCTION !************************************************************************** real FUNCTION RIH3 ( X ) !DEC$ ATTRIBUTES DLLEXPORT :: RIH3 ! WERTET DEN AUSDRUCK EXP(-X) * EI(X) AUS IF ( X . LE . 2 0. ) THEN RIH3 = EXP ( - X ) * EI ( X ) RETURN ELSE RIH3 = RIH2 ( X ) / X END IF END FUNCTION ! *********************************************************** real FUNCTION EI ( X ) !DEC$ ATTRIBUTES DLLEXPORT :: EI ! EXPONENTIALINTEGRAL !   GETESTET -60 < X < 60 use io use error real ( kind = sgl ), parameter :: A1 = 8.57332 , A2 = 1 8.05901 , A3 = 8.63476 , A4 = . 26777 , & B1 = 9.57332 , B2 = 2 5.63295 , B3 = 2 1.09965 , B4 = 3.95849 IF ( X . GT . 6 0. ) call FatalError ( 'EI (in others.f90)' , '>>> EI UNTESTED FOR X>60 ' ) IF ( X . LT . - 6 0. ) THEN EI = 0. RETURN END IF IF ( X . LT . - 1. ) THEN !    ABRAMOWITZ (5.1.56) XP = ABS ( X ) EI = - ( A4 + XP * ( A3 + XP * ( A2 + XP * ( A1 + XP ))) ) / ( B4 + XP * ( B3 + XP * ( B2 + XP * ( B1 + XP ))) ) * EXP ( - XP ) / XP RETURN END IF EI = . 577216 + LOG ( ABS ( X ) ) I = 1 SI = X SUMM = SI do while ( ABS ( SI / X ) . GT . 1.E-6 ) RI = REAL ( I ) RII = RI + 1. SI = SI * X * RI / ( RII * RII ) SUMM = SUMM + SI I = I + 1 end do EI = EI + SUMM END FUNCTION !************************************************************************** SUBROUTINE GETWK ( Z , SYMBOL , A , B ) !DEC$ ATTRIBUTES DLLEXPORT :: GETWK ! UPDATE 07.07.93 ! NOW 4 A AND 4 B ! DATEN VON UND FUER DIE AUFRUFENDE ROUTINE integer :: Z real ( kind = sgl ) :: A ( 4 ), B ( 4 ) character ( 2 ) :: SYMBOL ! DATEN, DIE NUR INTERN BENOETIGT WERDEN character ( 2 ), parameter :: SY ( 98 ) = ( / 'H ' , 'He' , 'Li' , 'Be' , 'B ' , 'C ' , 'N ' , 'O ' , 'F ' , 'Ne' , & 'Na' , 'Mg' , 'Al' , 'Si' , 'P ' , 'S ' , 'Cl' , 'Ar' , 'K ' , 'Ca' , & 'Sc' , 'Ti' , 'V ' , 'Cr' , 'Mn' , 'Fe' , 'Co' , 'Ni' , 'Cu' , 'Zn' , & 'Ga' , 'Ge' , 'As' , 'Se' , 'Br' , 'Kr' , 'Rb' , 'Sr' , 'Y ' , 'Zr' , & 'Nb' , 'Mo' , 'Tc' , 'Ru' , 'Rh' , 'Pd' , 'Ag' , 'Cd' , 'In' , 'Sn' , & 'Sb' , 'Te' , 'I ' , 'Xe' , 'Cs' , 'Ba' , 'La' , 'Ce' , 'Pr' , 'Nd' , & 'Pm' , 'Sm' , 'Eu' , 'Gd' , 'Tb' , 'Dy' , 'Ho' , 'Er' , 'Tm' , 'Yb' , & 'Lu' , 'Hf' , 'Ta' , 'W ' , 'Re' , 'Os' , 'Ir' , 'Pt' , 'Au' , 'Hg' , & 'Tl' , 'Pb' , 'Bi' , 'Po' , 'At' , 'Rn' , 'Fr' , 'Ra' , 'Ac' , 'Th' , & 'Pa' , 'U ' , 'Np' , 'Pu' , 'Am' , 'Cm' , 'Bk' , 'Cf' / ) REAL ( kind = sgl ), parameter :: AA ( 4 , 98 ) = reshape (( / 0.00427 , 0.00957 , 0.00802 , 0.00209 , & 0.01217 , 0.02616 , - 0.00884 , 0.01841 , & 0.00251 , 0.03576 , 0.00988 , 0.02370 , & 0.01596 , 0.02959 , 0.04024 , 0.01001 , & 0.03652 , 0.01140 , 0.05677 , 0.01506 , & 0.04102 , 0.04911 , 0.05296 , 0.00061 , & 0.04123 , 0.05740 , 0.06529 , 0.00373 , & 0.03547 , 0.03133 , 0.10865 , 0.01615 , & 0.03957 , 0.07225 , 0.09581 , 0.00792 , & 0.02597 , 0.02197 , 0.13762 , 0.05394 , & 0.03283 , 0.08858 , 0.11688 , 0.02516 , & 0.03833 , 0.17124 , 0.03649 , 0.04134 , & 0.04388 , 0.17743 , 0.05047 , 0.03957 , & 0.03812 , 0.17833 , 0.06280 , 0.05605 , & 0.04166 , 0.17817 , 0.09479 , 0.04463 , & 0.04003 , 0.18346 , 0.12218 , 0.03753 , & 0.04245 , 0.17645 , 0.15814 , 0.03011 , & 0.05011 , 0.16667 , 0.17074 , 0.04358 , & 0.04058 , 0.17582 , 0.20943 , 0.02922 , & 0.04001 , 0.17416 , 0.20986 , 0.05497 , & 0.09685 , 0.14777 , 0.20981 , 0.04852 , & 0.06667 , 0.17356 , 0.22710 , 0.05957 , & 0.05118 , 0.16791 , 0.26700 , 0.06476 , & 0.03204 , 0.18460 , 0.30764 , 0.05052 , & 0.03866 , 0.17782 , 0.31329 , 0.06898 , & 0.05455 , 0.16660 , 0.33208 , 0.06947 , & 0.05942 , 0.17472 , 0.34423 , 0.06828 , & 0.06049 , 0.16600 , 0.37302 , 0.07109 , & 0.08034 , 0.15838 , 0.40116 , 0.05467 , & 0.02948 , 0.19200 , 0.42222 , 0.07480 , & 0.16157 , 0.32976 , 0.18964 , 0.06148 , & 0.16184 , 0.35705 , 0.17618 , 0.07133 , & 0.06190 , 0.18452 , 0.41600 , 0.12793 , & 0.15913 , 0.41583 , 0.13385 , 0.10549 , & 0.16514 , 0.41202 , 0.12900 , 0.13209 , & 0.15798 , 0.41181 , 0.14254 , 0.14987 , & 0.16535 , 0.44674 , 0.24245 , 0.03161 , & 0.16039 , 0.44470 , 0.24661 , 0.05840 , & 0.16619 , 0.44376 , 0.25613 , 0.06797 , & 0.16794 , 0.44505 , 0.27188 , 0.07313 , & 0.16552 , 0.45008 , 0.30474 , 0.06161 , & 0.17327 , 0.44679 , 0.32441 , 0.06143 , & 0.16424 , 0.45046 , 0.33749 , 0.07766 , & 0.18750 , 0.44919 , 0.36323 , 0.05388 , & 0.16081 , 0.45211 , 0.40343 , 0.06140 , & 0.16599 , 0.43951 , 0.41478 , 0.08142 , & 0.16547 , 0.44658 , 0.45401 , 0.05959 , & 0.17154 , 0.43689 , 0.46392 , 0.07725 , & 0.15752 , 0.44821 , 0.48186 , 0.08596 , & 0.15732 , 0.44563 , 0.48507 , 0.10948 , & 0.16971 , 0.42742 , 0.48779 , 0.13653 , & 0.14927 , 0.43729 , 0.49444 , 0.16440 , & 0.18053 , 0.44724 , 0.48163 , 0.15995 , & 0.13141 , 0.43855 , 0.50035 , 0.22299 , & 0.31397 , 0.55648 , 0.39828 , 0.04852 , & 0.32756 , 0.53927 , 0.39830 , 0.07607 , & 0.30887 , 0.53804 , 0.42265 , 0.09559 , & 0.28398 , 0.53568 , 0.46662 , 0.10282 , & 0.35160 , 0.56889 , 0.42010 , 0.07246 , & 0.33810 , 0.58035 , 0.44442 , 0.07413 , & 0.35449 , 0.59626 , 0.43868 , 0.07152 , & 0.35559 , 0.60598 , 0.45165 , 0.07168 , & 0.38379 , 0.64088 , 0.41710 , 0.06708 , & 0.40352 , 0.64303 , 0.40488 , 0.08137 , & 0.36838 , 0.64761 , 0.47222 , 0.06854 , & 0.38514 , 0.68422 , 0.44359 , 0.06775 , & 0.37280 , 0.67528 , 0.47337 , 0.08320 , & 0.39335 , 0.70093 , 0.46774 , 0.06658 , & 0.40587 , 0.71223 , 0.46598 , 0.06847 , & 0.39728 , 0.73368 , 0.47795 , 0.06759 , & 0.40697 , 0.73576 , 0.47481 , 0.08291 , & 0.40122 , 0.78861 , 0.44658 , 0.08799 , & 0.41127 , 0.76965 , 0.46563 , 0.10180 , & 0.39978 , 0.77171 , 0.48541 , 0.11540 , & 0.39130 , 0.80752 , 0.48702 , 0.11041 , & 0.40436 , 0.80701 , 0.48445 , 0.12438 , & 0.38816 , 0.80163 , 0.51922 , 0.13514 , & 0.39551 , 0.80409 , 0.53365 , 0.13485 , & 0.40850 , 0.83052 , 0.53325 , 0.11978 , & 0.40092 , 0.85415 , 0.53346 , 0.12747 , & 0.41872 , 0.88168 , 0.54551 , 0.09404 , & 0.43358 , 0.88007 , 0.52966 , 0.12059 , & 0.40858 , 0.87837 , 0.56392 , 0.13698 , & 0.41637 , 0.85094 , 0.57749 , 0.16700 , & 0.38951 , 0.83297 , 0.60557 , 0.20770 , & 0.41677 , 0.88094 , 0.55170 , 0.21029 , & 0.50089 , 1.00860 , 0.51420 , 0.05996 , & 0.47470 , 0.99363 , 0.54721 , 0.09206 , & 0.47810 , 0.98385 , 0.54905 , 0.12055 , & 0.47903 , 0.97455 , 0.55883 , 0.14309 , & 0.48351 , 0.98292 , 0.58877 , 0.12425 , & 0.48664 , 0.98057 , 0.61483 , 0.12136 , & 0.46078 , 0.97139 , 0.66506 , 0.13012 , & 0.49148 , 0.98583 , 0.67674 , 0.09725 , & 0.50865 , 0.98574 , 0.68109 , 0.09977 , & 0.46259 , 0.97882 , 0.73056 , 0.12723 , & 0.46221 , 0.95749 , 0.76259 , 0.14086 , & 0.48500 , 0.95602 , 0.77234 , 0.13374 / ),( / 4 , 98 / )) REAL ( kind = sgl ), parameter :: BB ( 4 , 98 ) = reshape (( / 4.17218 , 1 6.05892 , 2 6.78365 , 6 9.45643 , & 1.83008 , 7.20225 , 1 6.13585 , 1 8.75551 , & 0.02620 , 2.00907 , 1 0.80597 , 13 0.49226 , & 0.38968 , 1.99268 , 4 6.86913 , 10 8.84167 , & 0.50627 , 3.68297 , 2 7.90586 , 7 4.98296 , & 0.41335 , 1 0.98289 , 3 4.80286 , 17 7.19113 , & 0.29792 , 7.84094 , 2 2.58809 , 7 2.59254 , & 0.17964 , 2.60856 , 1 1.79972 , 3 8.02912 , & 0.16403 , 3.96612 , 1 2.43903 , 4 0.05053 , & 0.09101 , 0.41253 , 5.02463 , 1 7.52954 , & 0.06008 , 2.07182 , 7.64444 , 14 6.00952 , & 0.07424 , 2.87177 , 1 8.06729 , 9 7.00854 , & 0.09086 , 2.53252 , 3 0.43883 , 9 8.26737 , & 0.05396 , 1.86461 , 2 2.54263 , 7 2.43144 , & 0.05564 , 1.62500 , 2 4.45354 , 6 4.38264 , & 0.05214 , 1.40793 , 2 3.35691 , 5 3.59676 , & 0.04643 , 1.15677 , 1 9.34091 , 5 2.88785 , & 0.07991 , 1.01436 , 1 5.67109 , 3 9.60819 , & 0.03352 , 0.82984 , 1 4.13679 , 20 0.97722 , & 0.02289 , 0.71288 , 1 1.18914 , 13 5.02390 , & 0.12527 , 1.34248 , 1 2.43524 , 13 1.71112 , & 0.05198 , 0.86467 , 1 0.59984 , 10 3.56776 , & 0.03786 , 0.57160 , 8.30305 , 9 1.78068 , & 0.00240 , 0.44931 , 7.92251 , 8 6.64058 , & 0.01836 , 0.41203 , 6.73736 , 7 6.30466 , & 0.03947 , 0.43294 , 6.26864 , 7 1.29470 , & 0.03962 , 0.43253 , 6.05175 , 6 8.72437 , & 0.03558 , 0.39976 , 5.36660 , 6 2.46894 , & 0.05475 , 0.45736 , 5.38252 , 6 0.43276 , & 0.00137 , 0.26535 , 4.48040 , 5 4.26088 , & 0.10455 , 2.18391 , 9.04125 , 7 5.16958 , & 0.09890 , 2.06856 , 9.89926 , 6 8.13783 , & 0.01642 , 0.32542 , 3.51888 , 4 4.50604 , & 0.07669 , 1.89297 , 1 1.31554 , 4 6.32082 , & 0.08199 , 1.76568 , 9.87254 , 3 8.10640 , & 0.06939 , 1.53446 , 8.98025 , 3 3.04365 , & 0.07044 , 1.59236 , 1 7.53592 , 21 5.26198 , & 0.06199 , 1.41265 , 1 4.33812 , 15 2.80257 , & 0.06364 , 1.34205 , 1 3.66551 , 12 5.72522 , & 0.06565 , 1.25292 , 1 3.09355 , 10 9.50252 , & 0.05921 , 1.15624 , 1 3.24924 , 9 8.69958 , & 0.06162 , 1.11236 , 1 2.76149 , 9 0.92026 , & 0.05081 , 0.99771 , 1 1.28925 , 8 4.28943 , & 0.05120 , 1.08672 , 1 2.23172 , 8 5.27316 , & 0.04662 , 0.85252 , 1 0.51121 , 7 4.53949 , & 0.04933 , 0.79381 , 9.30944 , 4 1.17414 , & 0.04481 , 0.75608 , 9.34354 , 6 7.91975 , & 0.04867 , 0.71518 , 8.40595 , 6 4.24400 , & 0.03672 , 0.64379 , 7.83687 , 7 3.37281 , & 0.03308 , 0.60931 , 7.04977 , 6 4.83582 , & 0.04023 , 0.58192 , 6.29247 , 5 5.57061 , & 0.02842 , 0.50687 , 5.60835 , 4 8.28004 , & 0.03830 , 0.58340 , 6.47550 , 4 7.08820 , & 0.02097 , 0.41007 , 4.52105 , 3 7.18178 , & 0.07813 , 1.45053 , 1 5.05933 , 19 9.48830 , & 0.08444 , 1.40227 , 1 3.12939 , 16 0.56676 , & 0.07206 , 1.19585 , 1 1.55866 , 12 7.31371 , & 0.05717 , 0.98756 , 9.95556 , 11 7.31874 , & 0.08249 , 1.43427 , 1 2.37363 , 15 0.55968 , & 0.07081 , 1.31033 , 1 1.44403 , 14 4.17706 , & 0.07442 , 1.38680 , 1 1.54391 , 14 3.72185 , & 0.07155 , 1.34703 , 1 1.00432 , 14 0.09138 , & 0.07794 , 1.55042 , 1 1.89283 , 14 2.79585 , & 0.08508 , 1.60712 , 1 1.45367 , 11 6.64063 , & 0.06520 , 1.32571 , 1 0.16884 , 13 4.69034 , & 0.06850 , 1.43566 , 1 0.57719 , 13 1.88972 , & 0.06264 , 1.26756 , 9.46411 , 10 7.50194 , & 0.06750 , 1.35829 , 9.76480 , 12 7.40374 , & 0.06958 , 1.38750 , 9.41888 , 12 2.10940 , & 0.06574 , 1.31578 , 9.13448 , 12 0.98209 , & 0.06517 , 1.29452 , 8.67569 , 10 0.34878 , & 0.06213 , 1.30860 , 9.18871 , 9 1.20213 , & 0.06292 , 1.23499 , 8.42904 , 7 7.59815 , & 0.05693 , 1.15762 , 7.83077 , 6 7.14066 , & 0.05145 , 1.11240 , 8.33441 , 6 5.71782 , & 0.05573 , 1.11159 , 8.00221 , 5 7.35021 , & 0.04855 , 0.99356 , 7.38693 , 5 1.75829 , & 0.04981 , 0.97669 , 7.38024 , 4 4.52068 , & 0.05151 , 1.00803 , 8.03707 , 4 5.01758 , & 0.04693 , 0.98398 , 7.83562 , 4 6.51474 , & 0.05161 , 1.02127 , 9.18455 , 6 4.88177 , & 0.05154 , 1.03252 , 8.49678 , 5 8.79463 , & 0.04200 , 0.90939 , 7.71158 , 5 7.79178 , & 0.04661 , 0.87289 , 6.84038 , 5 1.36000 , & 0.04168 , 0.73697 , 5.86112 , 4 3.78613 , & 0.04488 , 0.83871 , 6.44020 , 4 3.51940 , & 0.05786 , 1.20028 , 1 3.85073 , 17 2.15909 , & 0.05239 , 1.03225 , 1 1.49796 , 14 3.12303 , & 0.05167 , 0.98867 , 1 0.52682 , 11 2.18267 , & 0.04931 , 0.95698 , 9.61135 , 9 5.44649 , & 0.04748 , 0.93369 , 9.89867 , 10 2.06961 , & 0.04660 , 0.89912 , 9.69785 , 10 0.23434 , & 0.04323 , 0.78798 , 8.71624 , 9 2.30811 , & 0.04641 , 0.85867 , 9.51157 , 11 1.02754 , & 0.04918 , 0.87026 , 9.41105 , 10 4.98576 , & 0.03904 , 0.72797 , 8.00506 , 8 6.41747 , & 0.03969 , 0.68167 , 7.29607 , 7 5.72682 , & 0.04291 , 0.69956 , 7.38554 , 7 7.18528 / ),( / 4 , 98 / )) SYMBOL = SY ( Z ) DO K = 1 , 4 A ( K ) = AA ( K , Z ) B ( K ) = BB ( K , Z ) END DO END SUBROUTINE !******************************************************************* real FUNCTION FCORE ( G , Z , ACCVLT ) !DEC$ ATTRIBUTES DLLEXPORT :: FCORE ! modified: 13.01.1992 ! ! Author: ! A.Weickenmeier ! Technische Hochschule Darmstadt ! Hochschulstr. 6 ! D-6100 Darmstadt ! Germany ! bitnet: XLTODA6L@DDATHD21.BITNET ! Tel.: 06151/16-3381 ! ! CALCULATES APPROXIMATELY THE CORE PART OF THE APSORTION ! USING THE APROXIMATION FOR THE MIXED DYNAMIC FORM FACTOR ! AND THE X-RAY SCATTERING AMPLITUDE DUE TO ! H. ROSE, OPTIK 45  NO.2  (1976) P. 139-158. ! ! ! INPUT: ! ====== ! ! G:   SCATTERING VECTOR 4*PI*G = S = SIN(THETA)/LAMBDA ! ACCVLT: ACCELERATION VOLTAGE IN KV ! Z: ATOM ! ! OUTPUT: ! ======= ! ! FCORE : CORE PART OF ABSORPTION POTENTIAL ! ! UNITS: ! ====== ! ! UNIT OF LENGTH IS ANGSTROEM ! !************************************************************************** use io use error real ( kind = sgl ), parameter :: PI = 3.1415927 , A0 = . 5289 integer :: Z real ( kind = sgl ) :: K0 , K2 , KAPPA ! CHECK INPUT IF ( Z . LT . 1 ) call FatalError ( 'FCORE' , ' Z must be positive' ) IF ( G . LT . 0 ) call FatalError ( 'FCORE' , ' G must be positive' ) IF ( ACCVLT . LT . 0 ) call FatalError ( 'FCORE' , ' ACCVLT must be positive' ) ! CALCULATE WAVENUMBER K0 = . 5068 * SQRT ( 102 2. * ACCVLT + ACCVLT * ACCVLT ) ! CALCULATE CHARACTERISTIC ENERGY LOSS AND ANGLE DE = REAL ( 6 * Z ) * 1.E-3 THETAE = DE / ( 2. * ACCVLT ) * ( 2. * ACCVLT + 102 2. ) / ( ACCVLT + 102 2. ) ! SCREENING PARAMETER OF YUKAWA-POTENTIAL R = 0.885 * A0 / REAL ( Z ) ** . 333333 ! CALCULATE NORMALISING ANGLE TA = 1. / ( K0 * R ) ! CALCULATE BRAGG ANGLE TB = G / ( 2. * K0 ) ! NORMALIZE OMEGA = 2. * TB / TA KAPPA = THETAE / TA K2 = KAPPA * KAPPA O2 = OMEGA * OMEGA X1 = OMEGA / (( 1. + O2 ) * SQRT ( O2 + 4. * K2 )) * LOG (( OMEGA + SQRT ( O2 + 4. * K2 )) / ( 2. * KAPPA )) X2 = 1. / SQRT (( 1. + O2 ) * ( 1. + O2 ) + 4. * K2 * O2 ) * LOG (( 1. + 2. * K2 + O2 + SQRT (( 1. + O2 ) * ( 1. + O2 ) + 4. * K2 * O2 )) / ( 2. * KAPPA * SQRT ( 1. + K2 ))) IF ( OMEGA . GT . 1 E - 2 ) THEN X3 = 1. / ( OMEGA * SQRT ( O2 + 4. * ( 1. + K2 ))) * LOG (( OMEGA + SQRT ( O2 + 4. * ( 1. + K2 ))) / ( 2. * SQRT ( 1. + K2 ))) ELSE X3 = 1. / ( 4. * ( 1. + K2 )) END IF HI = REAL ( 2 * Z ) / ( TA * TA ) * ( - X1 + X2 - X3 ) FCORE = 4. / ( A0 * A0 ) * 2. * PI / ( K0 * K0 ) * HI END FUNCTION ! ! END OF WEICKENMEIER-KOHL SOURCE CODE ! !-------------------------------------------------------------------------- ! ! SUBROUTINE:Sort ! !> @author Taken from http://www.personal.psu.edu/jhm/f90/examples/sort/sorthalf.f !> @brief sort the array ! !> Parameters described in the program ! !-------------------------------------------------------------------------- RECURSIVE SUBROUTINE SSORT ( X , Y , N , KFLAG ) !DEC$ ATTRIBUTES DLLEXPORT :: SSORT !***BEGIN PROLOGUE  SSORT !***PURPOSE  Sort an array and optionally make the same interchanges in !            an auxiliary array.  The array may be sorted in increasing !            or decreasing order.  A slightly modified QUICKSORT !            algorithm is used. !***LIBRARY   SLATEC !***CATEGORY  N6A2B !***TYPE      SINGLE PRECISION (SSORT-S, DSORT-D, ISORT-I) !***KEYWORDS  SINGLETON QUICKSORT, SORT, SORTING !***AUTHOR  Jones, R. E., (SNLA) !           Wisniewski, J. A., (SNLA) !***DESCRIPTION ! !   SSORT sorts array X and optionally makes the same interchanges in !   array Y.  The array X may be sorted in increasing order or !   decreasing order.  A slightly modified quicksort algorithm is used. ! !   Description of Parameters !      X - array of values to be sorted   (usually abscissas) !      Y - array to be (optionally) carried along !      N - number of values in array X to be sorted !      KFLAG - control parameter !            =  2  means sort X in increasing order and carry Y along. !            =  1  means sort X in increasing order (ignoring Y) !            = -1  means sort X in decreasing order (ignoring Y) !            = -2  means sort X in decreasing order and carry Y along. ! !***REFERENCES  R. C. Singleton, Algorithm 347, An efficient algorithm !                 for sorting with minimal storage, Communications of !                 the ACM, 12, 3 (1969), pp. 185-187. !***REVISION HISTORY  (YYMMDD) !   761101  DATE WRITTEN !   761118  Modified to use the Singleton quicksort algorithm.  (JAW) !   890531  Changed all specific intrinsics to generic.  (WRB) !   890831  Modified array declarations.  (WRB) !   891009  Removed unreferenced statement labels.  (WRB) !   891024  Changed category.  (WRB) !   891024  REVISION DATE from Version 3.2 !   891214  Prologue converted to Version 4.0 format.  (BAB) !   900315  CALLs to XERROR changed to CALLs to XERMSG.  (THJ) !   901012  Declared all variables; changed X,Y to SX,SY. (M. McClain) !   920501  Reformatted the REFERENCES section.  (DWL, WRB) !   920519  Clarified error messages.  (DWL) !   920801  Declarations section rebuilt and code restructured to use !           IF-THEN-ELSE-ENDIF.  (RWC, WRB) !***END PROLOGUE  SSORT !     .. Scalar Arguments .. INTEGER KFLAG , N !     .. Array Arguments .. REAL X ( * ) INTEGER Y ( * ) !     .. Local Scalars .. REAL R , T , TT , TTY , TY INTEGER I , IJ , J , K , KK , L , M , NN !     .. Local Arrays .. INTEGER IL ( 21 ), IU ( 21 ) !     .. External Subroutines .. !     None !     .. Intrinsic Functions .. INTRINSIC ABS , INT !***FIRST EXECUTABLE STATEMENT  SSORT NN = N IF ( NN . LT . 1 ) THEN PRINT * , 'The number of values to be sorted is not positive.' RETURN ENDIF ! KK = ABS ( KFLAG ) IF ( KK . NE . 1 . AND . KK . NE . 2 ) THEN PRINT * , 'The sort control parameter, K, is not 2, 1, -1, or -2.' RETURN ENDIF ! !     Alter array X to get decreasing order if needed ! IF ( KFLAG . LE . - 1 ) THEN DO 10 I = 1 , NN X ( I ) = - X ( I ) 10 CONTINUE ENDIF ! IF ( KK . EQ . 2 ) GO TO 100 ! !     Sort X only ! M = 1 I = 1 J = NN R = 0.375E0 ! 20 IF ( I . EQ . J ) GO TO 60 IF ( R . LE . 0.5898437E0 ) THEN R = R + 3.90625E-2 ELSE R = R - 0.21875E0 ENDIF ! 30 K = I ! !     Select a central element of the array and save it in location T ! IJ = I + INT (( J - I ) * R ) T = X ( IJ ) ! !     If first element of array is greater than T, interchange with T ! IF ( X ( I ) . GT . T ) THEN X ( IJ ) = X ( I ) X ( I ) = T T = X ( IJ ) ENDIF L = J ! !     If last element of array is less than than T, interchange with T ! IF ( X ( J ) . LT . T ) THEN X ( IJ ) = X ( J ) X ( J ) = T T = X ( IJ ) ! !        If first element of array is greater than T, interchange with T ! IF ( X ( I ) . GT . T ) THEN X ( IJ ) = X ( I ) X ( I ) = T T = X ( IJ ) ENDIF ENDIF ! !     Find an element in the second half of the array which is smaller !     than T ! 40 L = L - 1 IF ( X ( L ) . GT . T ) GO TO 40 ! !     Find an element in the first half of the array which is greater !     than T ! 50 K = K + 1 IF ( X ( K ) . LT . T ) GO TO 50 ! !     Interchange these elements ! IF ( K . LE . L ) THEN TT = X ( L ) X ( L ) = X ( K ) X ( K ) = TT GO TO 40 ENDIF ! !     Save upper and lower subscripts of the array yet to be sorted ! IF ( L - I . GT . J - K ) THEN IL ( M ) = I IU ( M ) = L I = K M = M + 1 ELSE IL ( M ) = K IU ( M ) = J J = L M = M + 1 ENDIF GO TO 70 ! !     Begin again on another portion of the unsorted array ! 60 M = M - 1 IF ( M . EQ . 0 ) GO TO 190 I = IL ( M ) J = IU ( M ) ! 70 IF ( J - I . GE . 1 ) GO TO 30 IF ( I . EQ . 1 ) GO TO 20 I = I - 1 ! 80 I = I + 1 IF ( I . EQ . J ) GO TO 60 T = X ( I + 1 ) IF ( X ( I ) . LE . T ) GO TO 80 K = I ! 90 X ( K + 1 ) = X ( K ) K = K - 1 IF ( T . LT . X ( K )) GO TO 90 X ( K + 1 ) = T GO TO 80 ! !     Sort X and carry Y along ! 100 M = 1 I = 1 J = NN R = 0.375E0 ! 110 IF ( I . EQ . J ) GO TO 150 IF ( R . LE . 0.5898437E0 ) THEN R = R + 3.90625E-2 ELSE R = R - 0.21875E0 ENDIF ! 120 K = I ! !     Select a central element of the array and save it in location T ! IJ = I + INT (( J - I ) * R ) T = X ( IJ ) TY = Y ( IJ ) ! !     If first element of array is greater than T, interchange with T ! IF ( X ( I ) . GT . T ) THEN X ( IJ ) = X ( I ) X ( I ) = T T = X ( IJ ) Y ( IJ ) = Y ( I ) Y ( I ) = TY TY = Y ( IJ ) ENDIF L = J ! !     If last element of array is less than T, interchange with T ! IF ( X ( J ) . LT . T ) THEN X ( IJ ) = X ( J ) X ( J ) = T T = X ( IJ ) Y ( IJ ) = Y ( J ) Y ( J ) = TY TY = Y ( IJ ) ! !        If first element of array is greater than T, interchange with T ! IF ( X ( I ) . GT . T ) THEN X ( IJ ) = X ( I ) X ( I ) = T T = X ( IJ ) Y ( IJ ) = Y ( I ) Y ( I ) = TY TY = Y ( IJ ) ENDIF ENDIF ! !     Find an element in the second half of the array which is smaller !     than T ! 130 L = L - 1 IF ( X ( L ) . GT . T ) GO TO 130 ! !     Find an element in the first half of the array which is greater !     than T ! 140 K = K + 1 IF ( X ( K ) . LT . T ) GO TO 140 ! !     Interchange these elements ! IF ( K . LE . L ) THEN TT = X ( L ) X ( L ) = X ( K ) X ( K ) = TT TTY = Y ( L ) Y ( L ) = Y ( K ) Y ( K ) = TTY GO TO 130 ENDIF ! !     Save upper and lower subscripts of the array yet to be sorted ! IF ( L - I . GT . J - K ) THEN IL ( M ) = I IU ( M ) = L I = K M = M + 1 ELSE IL ( M ) = K IU ( M ) = J J = L M = M + 1 ENDIF GO TO 160 ! !     Begin again on another portion of the unsorted array ! 150 M = M - 1 IF ( M . EQ . 0 ) GO TO 190 I = IL ( M ) J = IU ( M ) ! 160 IF ( J - I . GE . 1 ) GO TO 120 IF ( I . EQ . 1 ) GO TO 110 I = I - 1 ! 170 I = I + 1 IF ( I . EQ . J ) GO TO 150 T = X ( I + 1 ) TY = Y ( I + 1 ) IF ( X ( I ) . LE . T ) GO TO 170 K = I ! 180 X ( K + 1 ) = X ( K ) Y ( K + 1 ) = Y ( K ) K = K - 1 IF ( T . LT . X ( K )) GO TO 180 X ( K + 1 ) = T Y ( K + 1 ) = TY GO TO 170 ! !     Clean up ! 190 IF ( KFLAG . LE . - 1 ) THEN DO 200 I = 1 , NN X ( I ) = - X ( I ) 200 CONTINUE ENDIF RETURN END SUBROUTINE qsortd ( x , ind , n ) ! Code converted using TO_F90 by Alan Miller ! Date: 2002-12-18  Time: 11:55:47 IMPLICIT NONE INTEGER , INTENT ( IN ) :: n REAL * 8 , INTENT ( IN ) :: x ( n ) INTEGER , INTENT ( OUT ) :: ind ( n ) !*************************************************************************** !                                                         ROBERT RENKA !                                                 OAK RIDGE NATL. LAB. !   THIS SUBROUTINE USES AN ORDER N*LOG(N) QUICK SORT TO SORT A REAL (dp) ! ARRAY X INTO INCREASING ORDER.  THE ALGORITHM IS AS FOLLOWS.  IND IS ! INITIALIZED TO THE ORDERED SEQUENCE OF INDICES 1,...,N, AND ALL INTERCHANGES ! ARE APPLIED TO IND.  X IS DIVIDED INTO TWO PORTIONS BY PICKING A CENTRAL ! ELEMENT T.  THE FIRST AND LAST ELEMENTS ARE COMPARED WITH T, AND ! INTERCHANGES ARE APPLIED AS NECESSARY SO THAT THE THREE VALUES ARE IN ! ASCENDING ORDER.  INTERCHANGES ARE THEN APPLIED SO THAT ALL ELEMENTS ! GREATER THAN T ARE IN THE UPPER PORTION OF THE ARRAY AND ALL ELEMENTS ! LESS THAN T ARE IN THE LOWER PORTION.  THE UPPER AND LOWER INDICES OF ONE ! OF THE PORTIONS ARE SAVED IN LOCAL ARRAYS, AND THE PROCESS IS REPEATED ! ITERATIVELY ON THE OTHER PORTION.  WHEN A PORTION IS COMPLETELY SORTED, ! THE PROCESS BEGINS AGAIN BY RETRIEVING THE INDICES BOUNDING ANOTHER ! UNSORTED PORTION. ! INPUT PARAMETERS -   N - LENGTH OF THE ARRAY X. !                      X - VECTOR OF LENGTH N TO BE SORTED. !                    IND - VECTOR OF LENGTH >= N. ! N AND X ARE NOT ALTERED BY THIS ROUTINE. ! OUTPUT PARAMETER - IND - SEQUENCE OF INDICES 1,...,N PERMUTED IN THE SAME !                          FASHION AS X WOULD BE.  THUS, THE ORDERING ON !                          X IS DEFINED BY Y(I) = X(IND(I)). !********************************************************************* ! NOTE -- IU AND IL MUST BE DIMENSIONED >= LOG(N) WHERE LOG HAS BASE 2. !********************************************************************* INTEGER :: iu ( 21 ), il ( 21 ) INTEGER :: m , i , j , k , l , ij , it , itt , indx REAL :: r REAL * 8 :: t ! LOCAL PARAMETERS - ! IU,IL =  TEMPORARY STORAGE FOR THE UPPER AND LOWER !            INDICES OF PORTIONS OF THE ARRAY X ! M =      INDEX FOR IU AND IL ! I,J =    LOWER AND UPPER INDICES OF A PORTION OF X ! K,L =    INDICES IN THE RANGE I,...,J ! IJ =     RANDOMLY CHOSEN INDEX BETWEEN I AND J ! IT,ITT = TEMPORARY STORAGE FOR INTERCHANGES IN IND ! INDX =   TEMPORARY INDEX FOR X ! R =      PSEUDO RANDOM NUMBER FOR GENERATING IJ ! T =      CENTRAL ELEMENT OF X IF ( n <= 0 ) RETURN ! INITIALIZE IND, M, I, J, AND R DO i = 1 , n ind ( i ) = i END DO m = 1 i = 1 j = n r = . 375 ! TOP OF LOOP 20 IF ( i >= j ) GO TO 70 IF ( r <= . 5898437 ) THEN r = r + . 0390625 ELSE r = r - . 21875 END IF ! INITIALIZE K 30 k = i ! SELECT A CENTRAL ELEMENT OF X AND SAVE IT IN T ij = i + r * ( j - i ) it = ind ( ij ) t = x ( it ) ! IF THE FIRST ELEMENT OF THE ARRAY IS GREATER THAN T, !   INTERCHANGE IT WITH T indx = ind ( i ) IF ( x ( indx ) > t ) THEN ind ( ij ) = indx ind ( i ) = it it = indx t = x ( it ) END IF ! INITIALIZE L l = j ! IF THE LAST ELEMENT OF THE ARRAY IS LESS THAN T, !   INTERCHANGE IT WITH T indx = ind ( j ) IF ( x ( indx ) >= t ) GO TO 50 ind ( ij ) = indx ind ( j ) = it it = indx t = x ( it ) ! IF THE FIRST ELEMENT OF THE ARRAY IS GREATER THAN T, !   INTERCHANGE IT WITH T indx = ind ( i ) IF ( x ( indx ) <= t ) GO TO 50 ind ( ij ) = indx ind ( i ) = it it = indx t = x ( it ) GO TO 50 ! INTERCHANGE ELEMENTS K AND L 40 itt = ind ( l ) ind ( l ) = ind ( k ) ind ( k ) = itt ! FIND AN ELEMENT IN THE UPPER PART OF THE ARRAY WHICH IS !   NOT LARGER THAN T 50 l = l - 1 indx = ind ( l ) IF ( x ( indx ) > t ) GO TO 50 ! FIND AN ELEMENT IN THE LOWER PART OF THE ARRAY WHCIH IS NOT SMALLER THAN T 60 k = k + 1 indx = ind ( k ) IF ( x ( indx ) < t ) GO TO 60 ! IF K <= L, INTERCHANGE ELEMENTS K AND L IF ( k <= l ) GO TO 40 ! SAVE THE UPPER AND LOWER SUBSCRIPTS OF THE PORTION OF THE !   ARRAY YET TO BE SORTED IF ( l - i > j - k ) THEN il ( m ) = i iu ( m ) = l i = k m = m + 1 GO TO 80 END IF il ( m ) = k iu ( m ) = j j = l m = m + 1 GO TO 80 ! BEGIN AGAIN ON ANOTHER UNSORTED PORTION OF THE ARRAY 70 m = m - 1 IF ( m == 0 ) RETURN i = il ( m ) j = iu ( m ) 80 IF ( j - i >= 11 ) GO TO 30 IF ( i == 1 ) GO TO 20 i = i - 1 ! SORT ELEMENTS I+1,...,J.  NOTE THAT 1 <= I < J AND J-I < 11. 90 i = i + 1 IF ( i == j ) GO TO 70 indx = ind ( i + 1 ) t = x ( indx ) it = indx indx = ind ( i ) IF ( x ( indx ) <= t ) GO TO 90 k = i 100 ind ( k + 1 ) = ind ( k ) k = k - 1 indx = ind ( k ) IF ( t < x ( indx )) GO TO 100 ind ( k + 1 ) = it GO TO 90 END SUBROUTINE qsortd end module others","tags":"","loc":"sourcefile/others.f90.html","title":"others.f90 – Fortran Program"},{"text":"This File Depends On sourcefile~~pedmod.f90~~EfferentGraph sourcefile~pedmod.f90 PEDmod.f90 sourcefile~namelisttypedefs.f90 NameListTypedefs.f90 sourcefile~namelisttypedefs.f90->sourcefile~pedmod.f90 sourcefile~constants.f90 constants.f90 sourcefile~constants.f90->sourcefile~pedmod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules PEDmod Source Code PEDmod.f90 Source Code ! ################################################################### ! Copyright (c) 2013-2014, Marc De Graef/Carnegie Mellon University ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without modification, are ! permitted provided that the following conditions are met: ! !     - Redistributions of source code must retain the above copyright notice, this list !        of conditions and the following disclaimer. !     - Redistributions in binary form must reproduce the above copyright notice, this !        list of conditions and the following disclaimer in the documentation and/or !        other materials provided with the distribution. !     - Neither the names of Marc De Graef, Carnegie Mellon University nor the names !        of its contributors may be used to endorse or promote products derived from !        this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE ! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ################################################################### !-------------------------------------------------------------------------- ! EMsoft:PEDmod.f90 !-------------------------------------------------------------------------- ! ! MODULE: PEDmod ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief all things related to precession electron diffraction ! !> @date 04/18/16 SS 1.0 original !-------------------------------------------------------------------------- module PEDmod use local use typedefs contains !-------------------------------------------------------------------------- ! ! SUBROUTINE:CalcKINPEDPatternSingle ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief calculate single PED pattern; used in the EMPEDDI program ! !> @param pednl PED name list structure !> @param cell cell structure !> @param reflist list of possible reflections !> @param nref number of reflections in master list !> @param qu orientation of xtal !> @param pedpattern calculated kinematic ped pattern ! !> @date 06/24/14  SS 1.0 original !> @date 04/28/16  SS 1.1 corrected array bound error !-------------------------------------------------------------------------- recursive subroutine CalcKINPEDPatternSingle ( pednl , cell , reflistarray , sanglearray , nref , qu , pedpattern ) !DEC$ ATTRIBUTES DLLEXPORT :: CalcKINPEDPatternSingle use NameListTypedefs use typedefs use quaternions use constants use diffraction IMPLICIT NONE type ( PEDKINIndxListType ), INTENT ( IN ) :: pednl type ( unitcell ), pointer :: cell integer ( kind = irg ), INTENT ( IN ) :: reflistarray ( 3 , nref ) real ( kind = sgl ), INTENT ( IN ) :: sanglearray ( nref ) !type(reflisttype), pointer                   :: reflist, rltmpa, nexts integer ( kind = irg ), INTENT ( IN ) :: nref real ( kind = sgl ), INTENT ( IN ) :: qu ( 4 ) real ( kind = sgl ), INTENT ( OUT ) :: pedpattern ( 1 : pednl % npix , 1 : pednl % npix ) integer ( kind = irg ) :: io_int ( 6 ), i , j , sx , sy , ww , tdp , nsize , gg ( 3 ), nns , counter real ( kind = sgl ) :: sgmax , k ( 3 ), ku ( 3 ), FN ( 3 ), kp ( 3 ), w , x , y real ( kind = sgl ) :: dx , dy , rnmpp , Ig , Igmax real ( kind = sgl ), allocatable :: xx (:,:), yy (:,:), line (:), dot (:,:), image (:,:) real ( kind = sgl ), allocatable :: sgarray (:), sanglearraystrong (:), sgarraystrong (:) integer ( kind = irg ), allocatable :: reflistarraystrong (:,:) sgmax = pednl % sgmax Igmax = pednl % Igmax rnmpp = 1.0 / pednl % rnmpp ww = pednl % ww tdp = 2 * ww + 1 nsize = pednl % npix / 2 + ww allocate ( image ( - nsize : nsize , - nsize : nsize ), xx ( - ww : ww , - ww : ww ), yy ( - ww : ww , - ww : ww ), line ( - ww : ww ), dot ( - ww : ww , - ww : ww )) line = ( / ( float ( i ), i =- ww , ww ) / ) * rnmpp xx = spread ( line , dim = 1 , ncopies = 2 * ww + 1 ) yy = transpose ( xx ) image = 0.0 ! multiplication with (0,0,1) produces the normalized beam direction in a ! cartesian reference frame; so now we can compute the excitation errors ! for every reflection and keep only the ones that are sufficiently small k = ( / 0.0 , 0.0 , 1.0 / ) ku = quat_LP ( qu , k ) FN = ku k = ku / sngl ( cell % mLambda ) ! first we go through the entire reflection list and compute the excitation errors ! those points that satisfy the cutoff are linked via the nexts pointers allocate ( sgarray ( nref )) sgarray = 0.0 ! counter for number of strong beams nns = 0 do j = 1 , nref gg = reflistarray ( 1 : 3 , j ) sgarray ( j ) = Calcsg ( cell , float ( gg ), k , FN ) ! should we consider this point any further ? If so, increase strong reflection list counter if ( abs ( sgarray ( j )). le . sgmax ) then nns = nns + 1 end if end do allocate ( sgarraystrong ( nns ), sanglearraystrong ( nns ), reflistarraystrong ( 3 , nns )) counter = 1 do j = 1 , nref if ( abs ( sgarray ( j )) . le . sgmax ) then reflistarraystrong ( 1 : 3 , counter ) = reflistarray ( 1 : 3 , j ) sgarraystrong ( counter ) = sgarray ( j ) sanglearraystrong ( counter ) = sanglearray ( j ) counter = counter + 1 end if end do ! then, for each point in the nexts list, we compute the components of k' = k+g+s ! and place them in the proper reference frame; we skip the incident beam since it is ! meaningless in the kinematical approximation ! strat from 2 to exclude the transmitted beam do j = 2 , nns ! determine the vector k' kp = k + reflistarraystrong ( 1 : 3 , j ) + sgarraystrong ( j ) * ku kp = quat_LP ( conjg ( qu ), kp ) ! get the intensity for each point w = sngl ( cPi ) * sgarraystrong ( j ) * pednl % thickness if ( abs ( w ). lt . 1.0e-6 ) then Ig = sanglearraystrong ( j ) ! * (sngl(cPi)*pednl%thickness/nexts%xg)**2 else Ig = sanglearraystrong ( j ) * ( sin ( w ) / w ) ** 2 ! * (sngl(cPi)*pednl%thickness/nexts%xg)**2 end if ! determine the spot coordinates on the detector x = rnmpp * kp ( 1 ) y = rnmpp * kp ( 2 ) ! and plot that spot as a small Gaussian in the pedpattern array, assuming it falls on the detector. if (( abs ( x ). le . nsize - ww ). and .( abs ( y ). le . nsize - ww )) then sx = nint ( x ) sy = nint ( y ) dx = x - sx dy = y - sy dot = ( Ig / Igmax ) ** 0.2 * exp ( - (( xx - dx ) ** 2 + ( yy - dy ) ** 2 ) * 0.0022 ) image ( sx - ww : sx + ww , sy - ww : sy + ww ) = image ( sx - ww : sx + ww , sy - ww : sy + ww ) + dot ( - ww : ww , - ww : ww ) end if end do pedpattern ( 1 : pednl % npix , 1 : pednl % npix ) = image ( - nsize + ww : nsize - ww - 1 , - nsize + ww : nsize - ww - 1 ) deallocate ( image , xx , yy , line , dot ) deallocate ( sgarray , sgarraystrong , sanglearraystrong , reflistarraystrong ) end subroutine CalcKINPEDPatternSingle !-------------------------------------------------------------------------- ! ! SUBROUTINE:Denoise_PED ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief Denoise a kinematical PED pattern ! !> @param pednl namelist file for PED ! !> @date 11/23/15  SS 1.0 original !-------------------------------------------------------------------------- recursive subroutine Denoise_PED ( pednl , img_in , img_out ) !DEC$ ATTRIBUTES DLLEXPORT :: Denoise_PED use local use ISO_C_BINDING use NameListTypedefs interface type ( C_PTR ) recursive function denoise ( lx , ly , pf , powp , sigma_w , prinf , noisinf , & icd , mbike ) bind ( C , name = 'denoise' ) use ISO_C_BINDING IMPLICIT NONE integer ( C_INT ) :: lx integer ( C_INT ) :: ly real ( C_FLOAT ) :: pf real ( C_FLOAT ) :: powp real ( C_FLOAT ) :: sigma_w real ( C_FLOAT ) :: prinf real ( C_FLOAT ) :: noisinf integer ( C_INT ) :: icd real ( C_DOUBLE ) :: mbike end function denoise end interface type ( PEDKINIndxListType ), INTENT ( IN ) :: pednl real ( kind = sgl ), INTENT ( IN ), target :: img_in ( 1 : pednl % npix ** 2 ) real ( kind = sgl ), INTENT ( OUT ) :: img_out ( 1 : pednl % npix ** 2 ) integer ( C_INT ) :: retval real ( C_FLOAT ), target :: pf , powp , sigma_w , prinf , noisinf integer ( C_INT ), target :: lx , ly , icd , length integer ( kind = irg ) :: istat real ( C_DOUBLE ), pointer :: output (:) type ( C_PTR ) :: out_ptr real ( C_DOUBLE ), allocatable , target :: aux_img (:) lx = pednl % npix ly = pednl % npix ! these values will remain fixed pf = 1.0 powp = 1.2 sigma_w = 1 5.0 prinf = 1.0 noisinf = 0.2 icd = 15 allocate ( aux_img ( 1 : lx * ly ), stat = istat ) aux_img ( 1 : lx * ly ) = img_in ( 1 : lx * ly ) out_ptr = denoise ( lx , ly , pf , powp , sigma_w , prinf , noisinf , icd , aux_img ( 1 )) call C_F_POINTER ( out_ptr , output , ( / lx * ly / )) img_out ( 1 : lx * ly ) = output ( 1 : lx * ly ) deallocate ( aux_img ) deallocate ( output ) end subroutine Denoise_PED !-------------------------------------------------------------------------- ! ! SUBROUTINE:Denoise_Pattern ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief Denoise an arbitrary pattern ! !> @param pednl namelist file for PED ! !> @date 11/23/15  SS 1.0 original !-------------------------------------------------------------------------- recursive subroutine Denoise_Pattern ( flx , fly , fpf , fpowp , fsigma_w , fprinf , fnoisinf , ficd , img_in , & img_out ) bind ( C , name = 'Denoise_Pattern' ) !DEC$ ATTRIBUTES DLLEXPORT :: Denoise_Pattern use local use , INTRINSIC :: ISO_C_BINDING interface type ( C_PTR ) recursive function denoise ( lx , ly , pf , powp , sigma_w , prinf , noisinf , & icd , mbike ) bind ( C , name = 'denoise' ) use ISO_C_BINDING IMPLICIT NONE integer ( C_INT ) :: lx integer ( C_INT ) :: ly real ( C_FLOAT ) :: pf real ( C_FLOAT ) :: powp real ( C_FLOAT ) :: sigma_w real ( C_FLOAT ) :: prinf real ( C_FLOAT ) :: noisinf integer ( C_INT ) :: icd real ( C_DOUBLE ) :: mbike end function denoise end interface integer ( kind = irg ), INTENT ( IN ) :: flx integer ( kind = irg ), INTENT ( IN ) :: fly real ( kind = sgl ), INTENT ( IN ) :: fpf , fpowp , fsigma_w , fprinf , fnoisinf integer ( kind = irg ), INTENT ( IN ) :: ficd real ( kind = sgl ), INTENT ( IN ), target :: img_in ( 1 : flx * fly ) real ( kind = sgl ), INTENT ( OUT ) :: img_out ( 1 : flx * fly ) integer ( C_INT ) :: retval real ( C_FLOAT ), target :: pf , powp , sigma_w , prinf , noisinf integer ( C_INT ), target :: lx , ly , icd , length integer ( kind = irg ) :: istat real ( C_DOUBLE ), pointer :: output (:) type ( C_PTR ) :: out_ptr real ( C_DOUBLE ), allocatable , target :: aux_img (:) lx = flx ly = fly ! these values will remain fixed pf = fpf ! = 1.0 powp = fpowp ! = 1.2 sigma_w = fsigma_w ! = 15.0 prinf = fprinf ! = 1.0 noisinf = fnoisinf ! = 0.2 icd = ficd ! = 15 allocate ( aux_img ( 1 : lx * ly ), stat = istat ) aux_img ( 1 : lx * ly ) = img_in ( 1 : lx * ly ) out_ptr = denoise ( lx , ly , pf , powp , sigma_w , prinf , noisinf , icd , aux_img ( 1 )) call C_F_POINTER ( out_ptr , output , ( / lx * ly / )) img_out ( 1 : lx * ly ) = output ( 1 : lx * ly ) deallocate ( aux_img ) deallocate ( output ) end subroutine Denoise_Pattern !-------------------------------------------------------------------------- ! ! SUBROUTINE:ctfped_writeFile ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief subroutine to write ctf file for ped indexing program ! !> @param pednl namelist file for PED !> @param ipar  some integer parameters passed to the subroutine !> @param indexmain indices for top nnk match !> @param eulerarray main euler angle list for the RFZ sampling !> @param resultmain list of dot products for all nnk matches ! !> @date 04/27/16  SS 1.0 original !-------------------------------------------------------------------------- recursive subroutine ctfped_writeFile ( pednl , ipar , indexmain , eulerarray , resultmain ) !DEC$ ATTRIBUTES DLLEXPORT :: ctfped_writeFile use local use NameListTypedefs IMPLICIT NONE type ( PEDKINIndxListType ), INTENT ( INOUT ) :: pednl integer ( kind = irg ), INTENT ( IN ) :: ipar ( 10 ) integer ( kind = irg ), INTENT ( IN ) :: indexmain ( ipar ( 1 ), ipar ( 2 )) real ( kind = sgl ), INTENT ( IN ) :: eulerarray ( 3 , ipar ( 4 )) real ( kind = sgl ), INTENT ( IN ) :: resultmain ( ipar ( 1 ), ipar ( 2 )) integer ( kind = irg ) :: ierr , ii , indx character ( fnlen ) :: ctfname character :: TAB = CHAR ( 9 ) character ( fnlen ) :: str1 , str2 , str3 , str4 , str5 , str6 , str7 , str8 , str9 , str10 real ( kind = sgl ) :: euler ( 3 ) ! open the file (overwrite old one if it exists) ctfname = trim ( EMsoft_getEMdatapathname ()) // trim ( pednl % ctffile ) ctfname = EMsoft_toNativePath ( ctfname ) open ( unit = dataunit2 , file = trim ( ctfname ), status = 'unknown' , action = 'write' , iostat = ierr ) write ( dataunit2 , '(A)' ), 'Channel Text File' write ( dataunit2 , '(A)' ), 'Prj Test' write ( dataunit2 , '(A)' ), 'Author\t' // trim ( EMsoft_getUsername ()) write ( dataunit2 , '(A)' ), 'JobMode\tGrid' write ( dataunit2 , '(2A,I5)' ), 'XCells' , TAB , pednl % ipf_wd write ( dataunit2 , '(2A,I5)' ), 'YCells' , TAB , pednl % ipf_ht write ( dataunit2 , '(3A)' ), 'XStep' , TAB , '1.0' write ( dataunit2 , '(3A)' ), 'YStep' , TAB , '1.0' write ( dataunit2 , '(A)' ), 'AcqE1\t0' write ( dataunit2 , '(A)' ), 'AcqE2\t0' write ( dataunit2 , '(A)' ), 'AcqE3\t0' write ( dataunit2 , '(A,A,$)' ), 'Euler angles refer to Sample Coordinate system (CS0)!' , TAB ! the following line would need some work to do it properly... write ( dataunit2 , '(A)' ) 'Mag\t30\tCoverage\t100\tDevice\t0\tKV\t288.9\tTiltAngle\t-1\tTiltAxis\t0' write ( dataunit2 , '(A)' ), 'Phases\t1' ! here we need to read the .xtal file and extract the lattice parameters, Laue group and space group numbers write ( dataunit2 , '(A)' ), '3.524;3.524;3.524\t90;90;90\tNickel\t11\t225' ! this is the table header write ( dataunit2 , '(A)' ), 'Phase\tX\tY\tBands\tError\tEuler1\tEuler2\tEuler3\tMAD\tBC\tBS' ! go through the entire array and write one line per sampling point do ii = 1 , ipar ( 3 ) indx = indexmain ( 1 , ii ) euler = eulerarray ( 1 : 3 , indx ) write ( str1 , '(F12.3)' ) float ( MODULO ( ii - 1 , pednl % ipf_wd )) write ( str2 , '(F12.3)' ) float ( floor ( float ( ii - 1 ) / float ( pednl % ipf_wd ))) write ( str3 , '(I2)' ) 10 write ( str4 , '(F12.6)' ) resultmain ( 1 , ii ) write ( str5 , '(F12.3)' ) euler ( 1 ) write ( str6 , '(F12.3)' ) euler ( 2 ) write ( str7 , '(F12.3)' ) euler ( 3 ) write ( str8 , '(I8)' ) indx write ( str9 , '(I3)' ) 255 write ( str10 , '(I3)' ) 255 write ( dataunit2 , '(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)' ) '1' , TAB , trim ( adjustl ( str1 )), TAB ,& trim ( adjustl ( str2 )), TAB , trim ( adjustl ( str3 )), TAB , trim ( adjustl ( str4 )), TAB , trim ( adjustl ( str5 )),& TAB , trim ( adjustl ( str6 )), TAB , trim ( adjustl ( str7 )), TAB , trim ( adjustl ( str8 )), TAB , trim ( adjustl ( str9 )),& TAB , trim ( adjustl ( str10 )) end do close ( dataunit2 , status = 'keep' ) end subroutine ctfped_writeFile end module PEDmod","tags":"","loc":"sourcefile/pedmod.f90.html","title":"PEDmod.f90 – Fortran Program"},{"text":"This File Depends On sourcefile~~pfinversion.f90~~EfferentGraph sourcefile~pfinversion.f90 PFInversion.f90 sourcefile~constants.f90 constants.f90 sourcefile~constants.f90->sourcefile~pfinversion.f90 sourcefile~dictmod.f90 dictmod.f90 sourcefile~constants.f90->sourcefile~dictmod.f90 sourcefile~so3.f90 so3.f90 sourcefile~constants.f90->sourcefile~so3.f90 sourcefile~dictmod.f90->sourcefile~pfinversion.f90 sourcefile~so3.f90->sourcefile~dictmod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules PFInversion Source Code PFInversion.f90 Source Code ! ################################################################### ! Copyright (c) 2013-2014, Marc De Graef/Carnegie Mellon University ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without modification, are ! permitted provided that the following conditions are met: ! !     - Redistributions of source code must retain the above copyright notice, this list !        of conditions and the following disclaimer. !     - Redistributions in binary form must reproduce the above copyright notice, this !        list of conditions and the following disclaimer in the documentation and/or !        other materials provided with the distribution. !     - Neither the names of Marc De Graef, Carnegie Mellon University nor the names !        of its contributors may be used to endorse or promote products derived from !        this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE ! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ################################################################### module PFInversion contains !-------------------------------------------------------------------------- ! ! SUBROUTINE: ForwardProjection ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief forward projection from ODF in cubochoric space to IPF in Lambert space ! !> @param ODF         orientation distribution function !> @param ncub        number of bins in semi-edge in x,y and z directions !> @param PFhkl       hkl indices of the specific pole figure !> @param nLam        bins in the output along semi-edge in Lambert projection ! !> @out PFLam         Pole figure in Lambert projection ! !> @date 11/07/16     SS 1.0 original !> @date 11/10/16     SS 1.1 added symmetry; all integration done in FZ !> @date 12/08/16     SS 1.2 all computations in quaternions to avoid infinity problem !-------------------------------------------------------------------------- recursive subroutine ForwardProjection ( ncub , ODF , PFhkl , nLam , PFLam , pgnum ) & bind ( c , name = 'ForwardProjection' ) !DEC$ ATTRIBUTES DLLEXPORT :: ForwardProjection use local use constants use Lambert use rotations use error use io use dictmod use typedefs , only : dicttype use quaternions use symmetry , only : CalcFamily use ISO_C_BINDING IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: ncub real ( kind = dbl ), INTENT ( IN ) :: ODF ( - ncub : ncub , - ncub : ncub , - ncub : ncub ) integer ( kind = irg ), INTENT ( IN ) :: PFhkl ( 3 ) integer ( kind = irg ), INTENT ( IN ) :: nLam real ( kind = dbl ), INTENT ( OUT ) :: PFLam ( - nLam : nLam , - nLam : nLam ) integer ( kind = irg ), INTENT ( IN ) :: pgnum real ( kind = dbl ) :: lamx ( - nlam : nlam ), lamy ( - nlam : nlam ) real ( kind = dbl ) :: lam ( 2 ), xyz ( 3 ), hcrossy ( 3 ), PFhkl_f ( 3 ) integer ( kind = irg ) :: ii , jj , kk , ierr , nth real ( kind = dbl ) :: cth , sth , rod ( 4 ), rod2 ( 4 ), r ( 3 ), r2 ( 4 ), cu ( 3 ), eu ( 3 ), eu2 ( 3 ) real ( kind = dbl ) :: qu ( 4 ), qu2 ( 4 ), qures ( 4 ) real ( kind = dbl ), allocatable :: dth (:) integer ( kind = irg ) :: nix , niy , niz , nixp , niyp , nizp real ( kind = dbl ) :: nbx , nby , nbz , dx , dy , dz , dxm , dym , dzm type ( dicttype ), pointer :: dict integer ( kind = irg ) :: Pmdims , FZtype , FZorder !integer(kind=irg),INTENT(OUT)       :: itmp(48,3) ! allocate the dict structure allocate ( dict ) dict % Num_of_init = 3 dict % Num_of_iterations = 30 dict % pgnum = pgnum ! initialize the symmetry matrices call DI_Init ( dict , 'nil' ) Pmdims = dict % Nqsym FZtype = FZtarray ( dict % pgnum ) FZorder = FZoarray ( dict % pgnum ) lamx = ( / ( dble ( ii ) / dble ( nLam ), ii = - nLam , nLam ) / ) lamy = ( / ( dble ( ii ) / dble ( nLam ), ii = - nLam , nLam ) / ) ! only valid for cubic/tetragonal/orthorhombic symmetry ! normalize the input pole figure PFhkl_f = dble ( PFhkl ) PFhkl_f = PFhkl_f / NORM2 ( PFhkl_f ) nth = 101 allocate ( dth ( 1 : nth )) dth = 0.D0 dth = ( / ( 2.D0 * cPi * float ( ii - 1 ) / ( float ( nth - 1 )), ii = 1 , nth ) / ) do ii = - nLam , nLam do jj = - nLam , nLam lam = ( / lamx ( ii ), lamy ( jj ) / ) xyz = LambertSquareToSphere ( lam , ierr ) if ( ierr . eq . 0 ) then xyz = xyz / NORM2 ( xyz ) else call FatalError ( 'LambertSquareToSphere:' , 'Coulnd not convert lambert square to sphere' ) end if !       hcrossy =  PFhkl_f x xyz; !       only valid for cubic/tetragonal/orthorhombic symmetry !       general case will be dealt with later hcrossy = ( / PFhkl_f ( 2 ) * xyz ( 3 ) - PFhkl_f ( 3 ) * xyz ( 2 ),& PFhkl_f ( 3 ) * xyz ( 1 ) - PFhkl_f ( 1 ) * xyz ( 3 ),& PFhkl_f ( 1 ) * xyz ( 2 ) - PFhkl_f ( 2 ) * xyz ( 1 ) / ) if ( sum ( abs ( hcrossy )) . ne . 0 ) hcrossy = hcrossy / NORM2 ( hcrossy ) cth = sum ( PFhkl_f * xyz ) qu = ax2qu (( / hcrossy ( 1 ), hcrossy ( 2 ), hcrossy ( 3 ), acos ( cth ) / )) do kk = 1 , nth qu2 = ax2qu (( / xyz ( 1 ), xyz ( 2 ), xyz ( 3 ), dth ( kk ) / )) qures = quat_mult ( qu2 , qu ) eu = qu2eu ( qures ) call ReduceOrientationtoRFZ ( eu , dict , FZtype , FZorder , eu2 ) cu = eu2cu ( eu2 ) nbx = cu ( 1 ) / LPs % ap * ncub nby = cu ( 2 ) / LPs % ap * ncub nbz = cu ( 3 ) / LPs % ap * ncub nix = floor ( nbx ) niy = floor ( nby ) niz = floor ( nbz ) if ( nix < - ncub ) nix = - ncub if ( niy < - ncub ) niy = - ncub if ( niz < - ncub ) niz = - ncub nixp = nix + 1 niyp = niy + 1 nizp = niz + 1 if ( nixp > ncub ) nixp = ncub if ( niyp > ncub ) niyp = ncub if ( nizp > ncub ) nizp = ncub dx = nbx - nix dy = nby - niy dz = nbz - niz dxm = 1.D0 - dx dym = 1.D0 - dy dzm = 1.D0 - dz ! trilinear interpolation of the ODF PFLam ( ii , jj ) = PFLam ( ii , jj ) + & ( ODF ( nix , niy , niz ) * dxm * dym + ODF ( nixp , niy , niz ) * dx * dym + & ODF ( nix , niyp , niz ) * dxm * dy + ODF ( nixp , niyp , niz ) * dx * dy ) * dzm + & ( ODF ( nix , niy , nizp ) * dxm * dym + ODF ( nixp , niy , nizp ) * dx * dym + & ODF ( nix , niyp , nizp ) * dxm * dy + ODF ( nixp , niyp , nizp ) * dx * dy ) * dz end do end do end do end subroutine ForwardProjection !-------------------------------------------------------------------------- ! ! SUBROUTINE: BackProjection ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief back projection from PF in Lambert space to ODF in cubochoric space ! !> @param ncub     number of bins in semi-edge in x,y and z directions !> @param PFhkl    hkl indices of the specific pole figure !> @param nLam     bins in the output along semi-edge in Lambert projection !> @param PFLam    Pole figure in Lambert projection ! !> @out ODF        orientation distribution function ! !> @date 11/07/16  SS 1.0 original !> @date 11/10/16  SS 1.1 added symmetry; all integration done in FZ !> @date 12/08/16  SS 1.2 all computations in quaternion to avoid infinity problem !-------------------------------------------------------------------------- recursive subroutine BackProjection ( ncub , ODF , PFhkl , nLam , PFLam , pgnum ) & bind ( c , name = 'BackProjection' ) !DEC$ ATTRIBUTES DLLEXPORT :: BackProjection use local use constants use Lambert use rotations use error use dictmod use typedefs , only : dicttype use symmetry , only : CalcFamily use ISO_C_BINDING IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: ncub real ( kind = dbl ), INTENT ( OUT ) :: ODF ( - ncub : ncub , - ncub : ncub , - ncub : ncub ) integer ( kind = irg ), INTENT ( IN ) :: PFhkl ( 3 ) integer ( kind = irg ), INTENT ( IN ) :: nLam real ( kind = dbl ), INTENT ( IN ) :: PFLam ( - nLam : nLam , - nLam : nLam ) integer ( kind = irg ), INTENT ( IN ) :: pgnum real ( kind = dbl ) :: xy ( 2 ), PFhkl_f ( 3 ), xyz ( 3 ), hcrossy ( 3 ) integer ( kind = irg ) :: ii , jj , kk , ll , ierr , nth real ( kind = dbl ) :: cth , sth , rod ( 4 ), rod2 ( 4 ), r ( 3 ), r2 ( 4 ), cu ( 3 ), qu ( 4 ), qu2 ( 4 ), & eu ( 3 ), eu2 ( 3 ), qures ( 4 ) real ( kind = dbl ), allocatable :: dth (:) integer ( kind = irg ) :: nix , niy , niz , nixp , niyp , nizp real ( kind = dbl ) :: nbx , nby , nbz , dx , dy , dz , dxm , dym , dzm , dconst type ( dicttype ), pointer :: dict integer ( kind = irg ) :: Pmdims , FZtype , FZorder ! allocate the dict structure allocate ( dict ) dict % Num_of_init = 3 dict % Num_of_iterations = 30 dict % pgnum = pgnum ! initialize the symmetry matrices call DI_Init ( dict , 'nil' ) Pmdims = dict % Nqsym FZtype = FZtarray ( dict % pgnum ) FZorder = FZoarray ( dict % pgnum ) ! only valid for cubic/tetragonal/orthorhombic symmetry ! normalize the input pole figure PFhkl_f = dble ( PFhkl ) PFhkl_f = PFhkl_f / NORM2 ( PFhkl_f ) nth = 101 allocate ( dth ( 1 : nth )) dth = 0.D0 dth = ( / ( 2.D0 * cPi * float ( ii - 1 ) / ( float ( nth - 1 )), ii = 1 , nth ) / ) dconst = 1.D0 / dble ( nth ) do ii = - nLam , nLam do jj = - nLam , nLam xy = ( / dble ( ii ) / dble ( nLam ), dble ( jj ) / dble ( nLam ) / ) xyz = LambertSquareToSphere ( xy , ierr ) if ( ierr . eq . 0 ) then xyz = xyz / NORM2 ( xyz ) else call FatalError ( 'LambertSquareToSphere:' , 'Coulnd not convert lambert square to sphere' ) end if !       hcrossy =  PFhkl_f x xyz; !       only valid for cubic/tetragonal/orthorhombic symmetry !       general case will be dealt with later hcrossy = ( / PFhkl_f ( 2 ) * xyz ( 3 ) - PFhkl_f ( 3 ) * xyz ( 2 ),& PFhkl_f ( 3 ) * xyz ( 1 ) - PFhkl_f ( 1 ) * xyz ( 3 ),& PFhkl_f ( 1 ) * xyz ( 2 ) - PFhkl_f ( 2 ) * xyz ( 1 ) / ) if ( sum ( abs ( hcrossy )) . ne . 0 ) hcrossy = hcrossy / NORM2 ( hcrossy ) ! rotation by -omega about cross(h,y) cth = sum ( PFhkl_f * xyz ) qu = ax2qu (( / hcrossy ( 1 ), hcrossy ( 2 ), hcrossy ( 3 ), acos ( cth ) / )) do kk = 1 , nth qu2 = ax2qu (( / xyz ( 1 ), xyz ( 2 ), xyz ( 3 ), dth ( kk ) / )) qures = quat_mult ( qu2 , qu ) eu = qu2eu ( qures ) call ReduceOrientationtoRFZ ( eu , dict , FZtype , FZorder , eu2 ) cu = eu2cu ( eu2 ) nbx = cu ( 1 ) / LPs % ap * ncub nby = cu ( 2 ) / LPs % ap * ncub nbz = cu ( 3 ) / LPs % ap * ncub nix = floor ( nbx ) niy = floor ( nby ) niz = floor ( nbz ) if ( nix < - ncub ) nix = - ncub if ( niy < - ncub ) niy = - ncub if ( niz < - ncub ) niz = - ncub nixp = nix + 1 niyp = niy + 1 nizp = niz + 1 if ( nixp > ncub ) nixp = ncub if ( niyp > ncub ) niyp = ncub if ( nizp > ncub ) nizp = ncub dx = nbx - nix dy = nby - niy dz = nbz - niz dxm = 1.D0 - dx dym = 1.D0 - dy dzm = 1.D0 - dz ! assign intensity in ODF according to how close to each cell the resultant orientation is ! sort of like tri-linear interpolation ODF ( nix , niy , niz ) = ODF ( nix , niy , niz ) + PFLam ( ii , jj ) * dxm * dym * dzm * dconst ODF ( nixp , niy , niz ) = ODF ( nixp , niy , niz ) + PFLam ( ii , jj ) * dx * dym * dzm * dconst ODF ( nix , niyp , niz ) = ODF ( nix , niyp , niz ) + PFLam ( ii , jj ) * dxm * dy * dzm * dconst ODF ( nix , niy , nizp ) = ODF ( nix , niy , nizp ) + PFLam ( ii , jj ) * dxm * dym * dz * dconst ODF ( nixp , niyp , niz ) = ODF ( nixp , niyp , niz ) + PFLam ( ii , jj ) * dx * dy * dzm * dconst ODF ( nixp , niy , nizp ) = ODF ( nixp , niy , nizp ) + PFLam ( ii , jj ) * dx * dym * dz * dconst ODF ( nix , niyp , nizp ) = ODF ( nix , niyp , nizp ) + PFLam ( ii , jj ) * dxm * dy * dz * dconst ODF ( nixp , niyp , nizp ) = ODF ( nixp , niyp , nizp ) + PFLam ( ii , jj ) * dx * dy * dz * dconst end do end do end do end subroutine BackProjection end module PFInversion","tags":"","loc":"sourcefile/pfinversion.f90.html","title":"PFInversion.f90 – Fortran Program"},{"text":"Files Dependent On This One sourcefile~~pgm.f90~~AfferentGraph sourcefile~pgm.f90 pgm.f90 sourcefile~dispfield.f90 dispfield.f90 sourcefile~pgm.f90->sourcefile~dispfield.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules pgm Source Code pgm.f90 Source Code ! ################################################################### ! Copyright (c) 2013-2014, Marc De Graef/Carnegie Mellon University ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without modification, are ! permitted provided that the following conditions are met: ! !     - Redistributions of source code must retain the above copyright notice, this list !        of conditions and the following disclaimer. !     - Redistributions in binary form must reproduce the above copyright notice, this !        list of conditions and the following disclaimer in the documentation and/or !        other materials provided with the distribution. !     - Neither the names of Marc De Graef, Carnegie Mellon University nor the names !        of its contributors may be used to endorse or promote products derived from !        this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE ! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ################################################################### !-------------------------------------------------------------------------- ! EMsoft:pgm.f90 !-------------------------------------------------------------------------- ! ! MODULE: pgm ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief routine to write an image to a pgm file ! ! !> @date 1/5/99   MDG 1.0 original !> @date 6/9/14   MDG 2.0 removed global variables !-------------------------------------------------------------------------- module pgm use local use files use io IMPLICIT NONE contains recursive subroutine PGM_Write_File ( fname , nx , ny , image ) !DEC$ ATTRIBUTES DLLEXPORT :: PGM_Write_File character ( fnlen ), INTENT ( IN ) :: fname integer ( kind = irg ), INTENT ( IN ) :: image ( nx , ny ) integer ( kind = irg ), INTENT ( IN ) :: nx , ny integer ( kind = irg ) :: j , stl stl = len ( trim ( fname )) call Message ( 'Creating PGM file : ' // fname ( 1 : stl ), frm = \"(A)\" ) open ( unit = dataunit , file = trim ( EMsoft_toNativePath ( fname )), status = 'unknown' , action = 'write' , form = 'formatted' ) write ( unit = dataunit , fmt = \"(A3)\" ) 'P2 ' write ( unit = dataunit , fmt = \"(A)\" ) '# PGM file generated by EMsoft' write ( unit = dataunit , fmt = \"(I5,I5)\" ) nx , ny write ( unit = dataunit , fmt = \"(I5)\" ) maxval ( image ) do j = ny , 1 , - 1 write ( unit = dataunit , fmt = \"(I3)\" ) image ( 1 : nx , j ) end do close ( unit = dataunit , status = 'keep' ) end subroutine PGM_Write_File end module pgm","tags":"","loc":"sourcefile/pgm.f90.html","title":"pgm.f90 – Fortran Program"},{"text":"This File Depends On sourcefile~~povray.f90~~EfferentGraph sourcefile~povray.f90 povray.f90 sourcefile~constants.f90 constants.f90 sourcefile~constants.f90->sourcefile~povray.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules povray Source Code povray.f90 Source Code ! ################################################################### ! Copyright (c) 2016, Marc De Graef/Carnegie Mellon University ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without modification, are ! permitted provided that the following conditions are met: ! !     - Redistributions of source code must retain the above copyright notice, this list !        of conditions and the following disclaimer. !     - Redistributions in binary form must reproduce the above copyright notice, this !        list of conditions and the following disclaimer in the documentation and/or !        other materials provided with the distribution. !     - Neither the names of Marc De Graef, Carnegie Mellon University nor the names !        of its contributors may be used to endorse or promote products derived from !        this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE ! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ################################################################### !-------------------------------------------------------------------------- ! EMsoft:povray.f90 !-------------------------------------------------------------------------- ! ! MODULE: povray ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief all povray-related routines ! !> @details routines to generate output for PoVray file creation; this is mostly !> used for the visualization of orientation data sets in one of the many !> representations and fundamental zones... ! !> @date  09/08/16 MDG 1.0 original !-------------------------------------------------------------------------- module povray use io use local use files use rotations use constants use Lambert use quaternions contains !-------------------------------------------------------------------------- ! ! SUBROUTINE: PoVRay_openFile ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief  add the camera command to the current PoVRay file ! !> @param dunit output unit number !> @param locationline string that defines the camera position ! !> @date    09/08/16 MDG 1.0 original !> @date    01/30/17 MDG 1.1 added optional name list file variable !-------------------------------------------------------------------------- recursive subroutine PoVRay_openFile ( dunit , povray_filename , nmlfile ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_openFile IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit character ( fnlen ), INTENT ( IN ) :: povray_filename character ( fnlen ), INTENT ( IN ), OPTIONAL :: nmlfile character ( fnlen ) :: fname , line , cwd integer ( kind = irg ) :: io open ( unit = dunit , file = trim ( povray_filename ), form = 'formatted' , status = 'unknown' ) write ( dunit , \"(A)\" ) \"//Persistence of Vision Ray Tracer Scene Description File\" write ( dunit , \"(A)\" ) \"//Created by EMsoft package\" ! should we copy the complete namelist file as a comment at this point ? if ( PRESENT ( nmlfile )) then call getcwd ( cwd ) fname = trim ( cwd ) // '/' // trim ( nmlfile ) fname = EMsoft_toNativePath ( fname ) write ( dunit , \"(A)\" ) \"// \" write ( dunit , \"(A)\" ) \"// contents of the namelist used to create this file \" // trim ( fname ) open ( unit = 88 , file = trim ( fname ), status = 'unknown' , form = 'formatted' ) do read ( 88 , \"(A)\" , iostat = io ) line if ( io . eq . 0 ) then write ( dunit , \"(A)\" ) \"// \" // trim ( line ) else EXIT end if end do close ( unit = 88 , status = 'keep' ) write ( dunit , \"(A)\" ) \"// \" end if ! and write the include statements to the file write ( dunit , \"(A)\" ) \"#include \"\"colors.inc\"\"\" write ( dunit , \"(A)\" ) \"#include \"\"textures.inc\"\"\" write ( dunit , \"(A)\" ) \"#include \"\"glass.inc\"\"\" write ( dunit , \"(A)\" ) \"// \" write ( dunit , \"(A)\" ) \"global_settings\" write ( dunit , \"(A)\" ) \"{  ambient_light <1,1,1>\" write ( dunit , \"(A)\" ) \"   assumed_gamma 1\" write ( dunit , \"(A)\" ) \"}\" end subroutine PoVRay_openFile !-------------------------------------------------------------------------- ! ! SUBROUTINE: PoVRay_setCamera ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief  add the camera command to the current PoVRay file ! !> @param dunit output unit number !> @param locationline string that defines the camera position ! !> @date    09/08/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine PoVRay_setCamera ( dunit , locationline , skyline ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_setCamera IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit character ( fnlen ), INTENT ( IN ) :: locationline character ( fnlen ), INTENT ( IN ), OPTIONAL :: skyline write ( dunit , \"(A)\" ) \" \" write ( dunit , \"(A)\" ) \"camera {\" write ( dunit , \"(A)\" ) \"perspective \" write ( dunit , \"(A)\" ) trim ( locationline ) if ( PRESENT ( skyline )) then write ( dunit , \"(A)\" ) trim ( skyline ) else write ( dunit , \"(A)\" ) \"sky < 0.0, 0.0, 1.0>\" end if write ( dunit , \"(A)\" ) \"right y * 1\" write ( dunit , \"(A)\" ) \"up z\" write ( dunit , \"(A)\" ) \"angle 50\" write ( dunit , \"(A)\" ) \"look_at < 0.0, 0.0, 0.0>\" write ( dunit , \"(A)\" ) \"}\" end subroutine PoVRay_setCamera !-------------------------------------------------------------------------- ! ! SUBROUTINE: PoVRay_setLightSource ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief  add a light command to the current PoVRay file ! !> @param dunit output unit number !> @param lightline string that defines the camera position ! !> @date    09/08/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine PoVRay_setLightSource ( dunit , lightline , nobackground ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_setLightSource IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit character ( fnlen ), INTENT ( IN ) :: lightline logical , OPTIONAL , INTENT ( IN ) :: nobackground write ( dunit , \"(A)\" ) \" \" write ( dunit , \"(A)\" ) \"light_source {\" write ( dunit , \"(A)\" ) trim ( lightline ) write ( dunit , \"(A)\" ) \"color White\" write ( dunit , \"(A)\" ) \"media_interaction on\" write ( dunit , \"(A)\" ) \"media_attenuation on\" write ( dunit , \"(A)\" ) \"shadowless\" write ( dunit , \"(A)\" ) \"}\" if (. not . PRESENT ( nobackground )) then write ( dunit , \"(A)\" ) \"background { color White }\" write ( dunit , \"(A)\" ) \" \" end if end subroutine PoVRay_setLightSource !-------------------------------------------------------------------------- ! ! SUBROUTINE: PoVRay_addEulerBox ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief  add a wireframe Euler Box to the current PoVRay file ! !> @param dunit output unit number !> @param sphereRadius radius of sphere ! !> @date    11/23/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine PoVRay_addEulerBox ( dunit ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_addEulerBox IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit write ( dunit , \"(A)\" ) \"cylinder {<-3.141593,-1.570796,-3.141593>,<-3.141593, 1.570796,-3.141593>, 0.005 pigment {color Green*0.7}}\" write ( dunit , \"(A)\" ) \"cylinder {<-3.141593,-1.570796, 3.141593>,<-3.141593, 1.570796, 3.141593>, 0.005 pigment {color Green*0.7}}\" write ( dunit , \"(A)\" ) \"cylinder {< 3.141593,-1.570796,-3.141593>,< 3.141593, 1.570796,-3.141593>, 0.005 pigment {color Green*0.7}}\" write ( dunit , \"(A)\" ) \"cylinder {< 3.141593,-1.570796, 3.141593>,< 3.141593, 1.570796, 3.141593>, 0.005 pigment {color Green*0.7}}\" write ( dunit , \"(A)\" ) \"cylinder {<-3.141593,-1.570796,-3.141593>,<-3.141593,-1.570796, 3.141593>, 0.005 pigment {color Green*0.7}}\" write ( dunit , \"(A)\" ) \"cylinder {<-3.141593,-1.570796, 3.141593>,< 3.141593,-1.570796, 3.141593>, 0.005 pigment {color Green*0.7}}\" write ( dunit , \"(A)\" ) \"cylinder {< 3.141593,-1.570796, 3.141593>,< 3.141593,-1.570796,-3.141593>, 0.005 pigment {color Green*0.7}}\" write ( dunit , \"(A)\" ) \"cylinder {< 3.141593,-1.570796,-3.141593>,<-3.141593,-1.570796,-3.141593>, 0.005 pigment {color Green*0.7}}\" write ( dunit , \"(A)\" ) \"cylinder {<-3.141593, 1.570796,-3.141593>,<-3.141593, 1.570796, 3.141593>, 0.005 pigment {color Green*0.7}}\" write ( dunit , \"(A)\" ) \"cylinder {<-3.141593, 1.570796, 3.141593>,< 3.141593, 1.570796, 3.141593>, 0.005 pigment {color Green*0.7}}\" write ( dunit , \"(A)\" ) \"cylinder {< 3.141593, 1.570796, 3.141593>,< 3.141593, 1.570796,-3.141593>, 0.005 pigment {color Green*0.7}}\" write ( dunit , \"(A)\" ) \"cylinder {< 3.141593, 1.570796,-3.141593>,<-3.141593, 1.570796,-3.141593>, 0.005 pigment {color Green*0.7}}\" end subroutine PoVRay_addEulerBox !-------------------------------------------------------------------------- ! ! SUBROUTINE: PoVRay_declare_DF3file ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief set up the code to include a 3D density field (df3) file ! !> @param dunit output unit number !> @param df3 file name !> @param levelset if TRUE, then different colors are used for level contours ! !> @date    11/23/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine PoVRay_declare_DF3file ( dunit , df3name , levelset ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_declare_DF3file IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit character ( fnlen ), INTENT ( IN ) :: df3name logical , OPTIONAL , INTENT ( IN ) :: levelset logical :: levels write ( dunit , \"(A)\" ) '' write ( dunit , \"(A)\" ) '#declare DENS = interior' write ( dunit , \"(A)\" ) '  {  media' write ( dunit , \"(A)\" ) '    {  intervals 100                   // number of ray-intervals' write ( dunit , \"(A)\" ) '      ratio 0.5' write ( dunit , \"(A)\" ) '      samples 4,4                     // maximum,minimum of samples per voxel' write ( dunit , \"(A)\" ) '      method 2                        // 1, 2 or 3 (3 requires samples 3,3)' write ( dunit , \"(A)\" ) '      emission 20*<1,1,1>' write ( dunit , \"(A)\" ) '      absorption <1,1,1>' write ( dunit , \"(A)\" ) '      scattering { 1, <0,0,0> }' write ( dunit , \"(A)\" ) '      confidence 0.9                // default: 0.9' write ( dunit , \"(A)\" ) '      variance 1/100                // default: 1/128' write ( dunit , \"(A)\" ) '      density' write ( dunit , \"('      {  density_file df3 \"\"',A,'\"\"')\" ) trim ( df3name ) write ( dunit , \"(A)\" ) '        interpolate 1' write ( dunit , \"(A)\" ) '        color_map                    // colour map with (smooth) linear transition(s)' levels = . FALSE . if ( PRESENT ( levelset )) then if ( levelset . eqv .. TRUE .) then levels = . TRUE . end if end if if ( levels . eqv .. TRUE .) then write ( dunit , \"(A)\" ) '        {  [0.0 rgb <0.0,0.0,0.0>] ' write ( dunit , \"(A)\" ) '           [0.1 rgb <0.6,0.0,0.0>]' write ( dunit , \"(A)\" ) '           [0.2 rgb <0.0,0.6,0.0>]' write ( dunit , \"(A)\" ) '           [0.4 rgb <0.2,0.3,0.8>]' write ( dunit , \"(A)\" ) '           [0.6 rgb <0.6,0.5,0.8>]' write ( dunit , \"(A)\" ) '           [1.0 rgb <1.0,1.0,1.0>]' else write ( dunit , \"(A)\" ) '        {  [0.1 rgb <0.0,0.0,0.0>] ' write ( dunit , \"(A)\" ) '           [0.2 rgb <0.5,0.0,0.0>]' write ( dunit , \"(A)\" ) '           [0.3 rgb <1.0,0.0,0.0>]' write ( dunit , \"(A)\" ) '           [0.4 rgb <1.0,0.3,0.0>]' write ( dunit , \"(A)\" ) '           [0.5 rgb <1.0,0.6,0.0>]' write ( dunit , \"(A)\" ) '           [0.6 rgb <1.0,1.0,0.0>]' write ( dunit , \"(A)\" ) '           [0.7 rgb <1.0,1.0,0.3>]' write ( dunit , \"(A)\" ) '           [0.8 rgb <1.0,1.0,0.6>]' write ( dunit , \"(A)\" ) '           [0.9 rgb <1.0,1.0,1.0>]' end if write ( dunit , \"(A)\" ) '        }' write ( dunit , \"(A)\" ) '      }' write ( dunit , \"(A)\" ) '    }' write ( dunit , \"(A)\" ) '  }' write ( dunit , \"(A)\" ) '' write ( dunit , \"(A)\" ) '#declare renderbox = box' write ( dunit , \"(A)\" ) '  {  <0,0,0>, <1,1,1>' write ( dunit , \"(A)\" ) '     pigment { rgbt <0,0,0,1> }' write ( dunit , \"(A)\" ) '     hollow' write ( dunit , \"(A)\" ) '     interior { DENS }' write ( dunit , \"(A)\" ) '  }' end subroutine PoVRay_declare_DF3file !-------------------------------------------------------------------------- ! ! SUBROUTINE: PoVRay_write_DF3file ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief set up the code to include a 3D density field (df3) file ! !> @param dunit output unit number !> @param df3 file name !> @param volume the volume array to be written to the file !> @param ndims dimensions of the volume array !> @param scalingmode  'lin' or 'log' or 'lev' ! !> @date    11/23/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine PoVRay_write_DF3file ( dunit , df3name , volume , ndims , scalingmode ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_write_DF3file IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit character ( fnlen ), INTENT ( IN ) :: df3name integer ( kind = irg ), INTENT ( IN ) :: ndims ( 3 ) real ( kind = sgl ), INTENT ( INOUT ) :: volume ( - ndims ( 1 ): ndims ( 1 ), - ndims ( 2 ): ndims ( 2 ), - ndims ( 3 ): ndims ( 3 )) character ( 3 ), INTENT ( IN ) :: scalingmode integer ( kind = ish ) :: ivol ( - ndims ( 1 ): ndims ( 1 ), - ndims ( 2 ): ndims ( 2 ), - ndims ( 3 ): ndims ( 3 )) integer ( kind = ish ) :: idims ( 3 ), mval real ( kind = sgl ) :: mi , ma , levels ( 6 ) integer ( kind = irg ) :: recno , i , j , k ! This format is described on the following web pages: ! http://wwwmpa.mpa-garching.mpg.de/~mselig/povray/povray.html ! http://www.povray.org/documentation/view/3.6.1/374/ ! ! Essentially, this is a binary file with first 3 2-byte integers ! with the array dimensions, and then the array itself as 4-byte integers. ! Note that this file *must* be written in big-endian format (most significant ! byte first).  This can be achieved by using the CONVERT='BIG_ENDIAN' qualifier ! when the file is opened. ! we will write this as a file of 16 bit integers, so we need to rescale them all ! to the correct range mval = int ( 2 ** 15 - 1 , kind = ish ) if (( scalingmode . eq . 'log' ). or .( scalingmode . eq . 'lev' )) volume = alog10 ( volume + 1.0 ) mi = minval ( volume ) ma = maxval ( volume ) volume = ( volume - mi ) / ( ma - mi ) write ( * , * ) 'volume range ' , mi , ma if ( scalingmode . eq . 'lev' ) then ! we discretize the logarithmic values into bins (levels) which are then displayed ! as nested contour surfaces (ideally) by PoVRay's Density_field routine... ! Since we are testing this capability, we'll only include 5 different contour levels ! for now; this can be modified later on... levels = ( / 0.0 , 0.4 , 0.6 , 0.8 , 0.9 , 1.0 / ) ! levels = (/ 0.1, 0.2, 0.4, 0.6, 0.8, 1.0 /) do i = 2 , 6 where (( volume . ge . levels ( i - 1 )). and .( volume . lt . levels ( i ))) volume = levels ( i - 1 ) end do endif volume = volume * mval ivol = int ( volume , kind = ish ) ! open the file and write the rescaled integer data open ( unit = dunit , file = trim ( df3name ), status = 'unknown' , access = \"DIRECT\" , action = \"WRITE\" , & recl = 2 , form = 'unformatted' , convert = 'big_endian' ) idims = 2 * ndims + 1 recno = 1 do i = 1 , 3 write ( dunit , rec = recno ) idims ( i ) recno = recno + 1 end do do k =- ndims ( 3 ), ndims ( 3 ) do j =- ndims ( 2 ), ndims ( 2 ) do i =- ndims ( 1 ), ndims ( 1 ) write ( dunit , rec = recno ) ivol ( i , j , k ) recno = recno + 1 end do end do end do close ( dunit , status = 'keep' ) end subroutine PoVRay_write_DF3file !-------------------------------------------------------------------------- ! ! SUBROUTINE: PoVRay_addWireFrameSphere ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief  add a wireframe sphere to the current PoVRay file ! !> @param dunit output unit number !> @param sphereRadius radius of sphere ! !> @date    09/08/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine PoVRay_addWireFrameSphere ( dunit , sphereRadius ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_addWireFrameSphere IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit real ( kind = dbl ), INTENT ( IN ) :: sphereRadius character ( 12 ) :: px write ( dunit , \"(A)\" ) \"#macro WireFrameSphere(NrLongitudes, NrLatitudes, Rmaj, Rmin)\" write ( dunit , \"(A)\" ) \"\" write ( dunit , \"(A)\" ) \"  #local dLongitude = 360/NrLongitudes;\" write ( dunit , \"(A)\" ) \"  #local dLatitude = 180/NrLatitudes;\" write ( dunit , \"(A)\" ) \"  #local Cnt = 0;\" write ( dunit , \"(A)\" ) \"  #while (Cnt < NrLongitudes)\" write ( dunit , \"(A)\" ) \"    #local Longitude = Cnt*dLongitude;\" write ( dunit , \"(A)\" ) \"    difference {\" write ( dunit , \"(A)\" ) \"      torus { Rmaj, Rmin }\" write ( dunit , \"(A)\" ) \"      plane { -z, 0 }\" write ( dunit , \"(A)\" ) \"      rotate -90*z\" write ( dunit , \"(A)\" ) \"      rotate Longitude*y\" write ( dunit , \"(A)\" ) \"    }\" write ( dunit , \"(A)\" ) \"    #local Cnt = Cnt + 1;\" write ( dunit , \"(A)\" ) \"  #end // while\" write ( dunit , \"(A)\" ) \"\" write ( dunit , \"(A)\" ) \"  #local Cnt = 1;\" write ( dunit , \"(A)\" ) \"  #while (Cnt < NrLatitudes)\" write ( dunit , \"(A)\" ) \"    #local Latitude = radians(Cnt*dLatitude - 90);\" write ( dunit , \"(A)\" ) \"    torus {\" write ( dunit , \"(A)\" ) \"      Rmaj*cos(Latitude), Rmin\" write ( dunit , \"(A)\" ) \"      translate Rmaj*sin(Latitude)*y\" write ( dunit , \"(A)\" ) \"    }\" write ( dunit , \"(A)\" ) \"    #local Cnt = Cnt + 1;\" write ( dunit , \"(A)\" ) \"  #end // while\" write ( dunit , \"(A)\" ) \"\" write ( dunit , \"(A)\" ) \"#end // macro WireFrameSphere\" write ( dunit , \"(A)\" ) \"\" write ( px , \"(F12.6)\" ) sphereRadius write ( dunit , \"(A)\" ) \"#declare Rglobe = \" // px // \";\" write ( dunit , \"(A)\" ) \"#declare Rwireframe = 0.0033;\" write ( dunit , \"(A)\" ) \"#declare Rspheres = Rwireframe*2;\" write ( dunit , \"(A)\" ) \"\" write ( dunit , \"(A)\" ) \"// Number of longitude intervals\" write ( dunit , \"(A)\" ) \"#declare Longitudes = 12;\" write ( dunit , \"(A)\" ) \"\" write ( dunit , \"(A)\" ) \"// Number of latitude intervals\" write ( dunit , \"(A)\" ) \"#declare Latitudes = 6;\" write ( dunit , \"(A)\" ) \"\" write ( dunit , \"(A)\" ) \"\" write ( dunit , \"(A)\" ) \"union {\" write ( dunit , \"(A)\" ) \"  WireFrameSphere(Longitudes, Latitudes, Rglobe, Rwireframe)\" write ( dunit , \"(A)\" ) \"  rotate 90.0*x\" write ( dunit , \"(A)\" ) \"  pigment { color Black*0.7 }\" write ( dunit , \"(A)\" ) \"}\" end subroutine PoVRay_addWireFrameSphere !-------------------------------------------------------------------------- ! ! SUBROUTINE: PoVRay_addReferenceFrame ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief  add a reference frame to the current PoVRay file ! !> @param dunit output unit number !> @param ac maximum semi-length of axis ! !> @date    09/08/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine PoVRay_addReferenceFrame ( dunit , ac , cylr ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_addReferenceFrame IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit real ( kind = dbl ), INTENT ( IN ) :: ac real ( kind = dbl ), OPTIONAL , INTENT ( IN ) :: cylr real ( kind = dbl ) :: cc if ( present ( cylr ). eqv .. TRUE .) then cc = cylr else cc = 0.005D0 end if write ( dunit , \"('cylinder { <',2(F9.6,','),F9.6,'>,<',2(F9.6,','),F9.6,'>,',F9.6,' pigment { color Red*0.7 } }')\" ) & - ac , 0.0 , 0.0 , ac , 0.0 , 0.0 , cc write ( dunit , \"('cylinder { <',2(F9.6,','),F9.6,'>,<',2(F9.6,','),F9.6,'>,',F9.6,' pigment { color Green*0.7 } }')\" ) & 0.0 , - ac , 0.0 , 0.0 , ac , 0.0 , cc write ( dunit , \"('cylinder { <',2(F9.6,','),F9.6,'>,<',2(F9.6,','),F9.6,'>,',F9.6,' pigment { color Blue*0.7 } }')\" ) & 0.0 , 0.0 , - ac , 0.0 , 0.0 , ac , cc end subroutine PoVRay_addReferenceFrame !-------------------------------------------------------------------------- ! ! SUBROUTINE: PoVRay_addSphere ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief  add a sphere to the current PoVRay file ! !> @param dunit output unit number !> @param ctr center coordinates of the sphere !> @param radius sphere radius !> @param rgb color triplet (RGB) ! !> @date    09/08/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine PoVRay_addSphere ( dunit , ctr , radius , rgb ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_addSphere IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit real ( kind = dbl ), INTENT ( IN ) :: ctr ( 3 ) real ( kind = dbl ), INTENT ( IN ) :: radius real ( kind = sgl ), INTENT ( IN ) :: rgb ( 3 ) write ( dataunit , \"('sphere { <',2(F9.6,','),F9.6,'>,',F9.6,'  pigment { rgb <', & 2(F9.6,','),F9.6,'>}}')\" ), ctr ( 1 : 3 ), radius , rgb ( 1 : 3 ) end subroutine PoVRay_addSphere !-------------------------------------------------------------------------- ! ! SUBROUTINE: PoVRay_addCylinder ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief  add a cylinder to the current PoVRay file ! !> @param dunit output unit number !> @param p1 starting point of cylinder (on axis) !> @param p2 end point of cylinder (on axis) !> @param radius cylinder radius !> @param rgb color triplet (RGB) ! !> @date    09/08/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine PoVRay_addCylinder ( dunit , p1 , p2 , radius , rgb ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_addCylinder IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit real ( kind = dbl ), INTENT ( IN ) :: p1 ( 3 ), p2 ( 3 ) real ( kind = dbl ), INTENT ( IN ) :: radius real ( kind = sgl ), INTENT ( IN ) :: rgb ( 3 ) write ( dunit , \"('cylinder { <',2(F9.6,','),F9.6,'>,<',2(F9.6,','),F9.6,'>,', F9.6,' pigment { ', & 'rgb <',2(F9.6,','),F9.6,'>}}')\" ), p1 ( 1 : 3 ), p2 ( 1 : 3 ), radius , rgb ( 1 : 3 ) end subroutine PoVRay_addCylinder !-------------------------------------------------------------------------- ! ! SUBROUTINE: PoVRay_addCubochoricCube ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief  add a reference frame to the current PoVRay file ! !> @param dunit output unit number ! !> @date    09/08/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine PoVRay_addCubochoricCube ( dunit ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_addCubochoricCube IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit real ( kind = dbl ) :: ac ! create the cubochoric cube ac = 0.5 * LPs % ap call PoVRay_addCylinder ( dunit ,( / - ac , ac , ac / ), ( / ac , ac , ac / ), 0.005D0 , ( / 0.7 , 0.7 , 0.7 / )) call PoVRay_addCylinder ( dunit ,( / - ac , ac , - ac / ), ( / ac , ac , - ac / ), 0.005D0 , ( / 0.7 , 0.7 , 0.7 / )) call PoVRay_addCylinder ( dunit ,( / - ac , - ac , ac / ), ( / ac , - ac , ac / ), 0.005D0 , ( / 0.7 , 0.7 , 0.7 / )) call PoVRay_addCylinder ( dunit ,( / - ac , - ac , - ac / ), ( / ac , - ac , - ac / ), 0.005D0 , ( / 0.7 , 0.7 , 0.7 / )) call PoVRay_addCylinder ( dunit ,( / ac , - ac , ac / ), ( / ac , ac , ac / ), 0.005D0 , ( / 0.7 , 0.7 , 0.7 / )) call PoVRay_addCylinder ( dunit ,( / - ac , - ac , ac / ), ( /- ac , ac , ac / ), 0.005D0 , ( / 0.7 , 0.7 , 0.7 / )) call PoVRay_addCylinder ( dunit ,( / ac , - ac , - ac / ), ( / ac , ac , - ac / ), 0.005D0 , ( / 0.7 , 0.7 , 0.7 / )) call PoVRay_addCylinder ( dunit ,( / - ac , - ac , - ac / ), ( /- ac , ac , - ac / ), 0.005D0 , ( / 0.7 , 0.7 , 0.7 / )) call PoVRay_addCylinder ( dunit ,( / ac , ac , - ac / ), ( / ac , ac , ac / ), 0.005D0 , ( / 0.7 , 0.7 , 0.7 / )) call PoVRay_addCylinder ( dunit ,( / - ac , ac , - ac / ), ( /- ac , ac , ac / ), 0.005D0 , ( / 0.7 , 0.7 , 0.7 / )) call PoVRay_addCylinder ( dunit ,( / ac , - ac , - ac / ), ( / ac , - ac , ac / ), 0.005D0 , ( / 0.7 , 0.7 , 0.7 / )) call PoVRay_addCylinder ( dunit ,( / - ac , - ac , - ac / ), ( /- ac , - ac , ac / ), 0.005D0 , ( / 0.7 , 0.7 , 0.7 / )) end subroutine PoVRay_addCubochoricCube !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- ! below this line are a number of routines for different rotation representations ! and different crystallographic fundamental zones... below this line, there ! should be no direct writing to the dunit file; all writes should pass ! through the routines above. !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- ! ! SUBROUTINE: PoVRay_getpos_FZ432 ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief initialize the PoVRay output for rotational group 432 ! !> @param dims dimensions for subsequent arrays !> @param cpos vertex coordinates !> @param s_edge first set of edge connectivities !> @param t_edge second set of edge connectivities !> @param ns, d, nt  auxiliary parameters !> @param MFZ (optional) return coordinates for Mackenzie FZ instead of regular FZ ! !> @date    09/10/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine PoVRay_getpos_FZ432 ( dims , cpos , s_edge , t_edge , ns , d , nt , MFZ ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_getpos_FZ432 IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dims ( 3 ) real ( kind = dbl ), INTENT ( INOUT ) :: cpos ( 3 , dims ( 1 )) integer ( kind = irg ), INTENT ( INOUT ) :: s_edge ( 2 , dims ( 2 )) integer ( kind = irg ), INTENT ( INOUT ) :: t_edge ( 2 , dims ( 3 )) integer ( kind = irg ), INTENT ( OUT ) :: ns real ( kind = dbl ), INTENT ( OUT ) :: d integer ( kind = irg ), INTENT ( OUT ) :: nt logical , OPTIONAL , INTENT ( IN ) :: MFZ real ( kind = dbl ) :: a = 0.41421356237D0 , c = 0.17157287525D0 , dt = 0.34314575050D0 , ds = 0.6340506711D0 , & dd , e = 0.29289323D0 , f = 0.333333333D0 d = 0.610395774912 if ( present ( MFZ )) then if ( MFZ ) then ! define the coordinates of the cubic Mackenzie FZ in Rodrigues Space cpos ( 1 : 3 , 1 ) = ( / 0.D0 , 0.D0 , 0.D0 / ) cpos ( 1 : 3 , 2 ) = ( / a , 0.D0 , 0.D0 / ) cpos ( 1 : 3 , 3 ) = ( / a , a , 0.D0 / ) cpos ( 1 : 3 , 4 ) = ( / a , a , c / ) cpos ( 1 : 3 , 5 ) = ( / f , f , f / ) cpos ( 1 : 3 , 6 ) = ( / a , e , e / ) cpos = cpos / d ns = 200 nt = nint ( ns * dt / ds ) ! define the connectivity of all the edges s_edge ( 1 : 2 , 1 ) = ( / 1 , 2 / ) s_edge ( 1 : 2 , 2 ) = ( / 1 , 3 / ) s_edge ( 1 : 2 , 3 ) = ( / 1 , 5 / ) s_edge ( 1 : 2 , 4 ) = ( / 2 , 3 / ) s_edge ( 1 : 2 , 5 ) = ( / 2 , 6 / ) s_edge ( 1 : 2 , 6 ) = ( / 3 , 4 / ) s_edge ( 1 : 2 , 7 ) = ( / 4 , 5 / ) s_edge ( 1 : 2 , 8 ) = ( / 4 , 6 / ) s_edge ( 1 : 2 , 9 ) = ( / 5 , 6 / ) end if ! define the coordinates of the cubic FZ in Rodrigues Space else cpos ( 1 : 3 , 1 ) = ( / a , a , c / ) cpos ( 1 : 3 , 2 ) = ( / c , a , a / ) cpos ( 1 : 3 , 3 ) = ( / a , c , a / ) cpos ( 1 : 3 , 4 ) = ( / - a , a , c / ) cpos ( 1 : 3 , 5 ) = ( / - c , a , a / ) cpos ( 1 : 3 , 6 ) = ( / - a , c , a / ) cpos ( 1 : 3 , 7 ) = ( / - a , - a , c / ) cpos ( 1 : 3 , 8 ) = ( / - c , - a , a / ) cpos ( 1 : 3 , 9 ) = ( / - a , - c , a / ) cpos ( 1 : 3 , 10 ) = ( / a , - a , c / ) cpos ( 1 : 3 , 11 ) = ( / c , - a , a / ) cpos ( 1 : 3 , 12 ) = ( / a , - c , a / ) cpos ( 1 : 3 , 13 ) = ( / a , a , - c / ) cpos ( 1 : 3 , 14 ) = ( / a , c , - a / ) cpos ( 1 : 3 , 15 ) = ( / c , a , - a / ) cpos ( 1 : 3 , 16 ) = ( / - a , a , - c / ) cpos ( 1 : 3 , 17 ) = ( / - a , c , - a / ) cpos ( 1 : 3 , 18 ) = ( / - c , a , - a / ) cpos ( 1 : 3 , 19 ) = ( / - a , - a , - c / ) cpos ( 1 : 3 , 20 ) = ( / - a , - c , - a / ) cpos ( 1 : 3 , 21 ) = ( / - c , - a , - a / ) cpos ( 1 : 3 , 22 ) = ( / a , - a , - c / ) cpos ( 1 : 3 , 23 ) = ( / a , - c , - a / ) cpos ( 1 : 3 , 24 ) = ( / c , - a , - a / ) cpos = cpos / d ns = 200 nt = nint ( ns * dt / ds ) ! define the connectivity of all the edges s_edge ( 1 : 2 , 1 ) = ( / 3 , 12 / ) s_edge ( 1 : 2 , 2 ) = ( / 10 , 22 / ) s_edge ( 1 : 2 , 3 ) = ( / 14 , 23 / ) s_edge ( 1 : 2 , 4 ) = ( / 1 , 13 / ) s_edge ( 1 : 2 , 5 ) = ( / 2 , 5 / ) s_edge ( 1 : 2 , 6 ) = ( / 8 , 11 / ) s_edge ( 1 : 2 , 7 ) = ( / 21 , 24 / ) s_edge ( 1 : 2 , 8 ) = ( / 15 , 18 / ) s_edge ( 1 : 2 , 9 ) = ( / 6 , 9 / ) s_edge ( 1 : 2 , 10 ) = ( / 7 , 19 / ) s_edge ( 1 : 2 , 11 ) = ( / 17 , 20 / ) s_edge ( 1 : 2 , 12 ) = ( / 4 , 16 / ) t_edge ( 1 : 2 , 1 ) = ( / 1 , 2 / ) t_edge ( 1 : 2 , 2 ) = ( / 2 , 3 / ) t_edge ( 1 : 2 , 3 ) = ( / 3 , 1 / ) t_edge ( 1 : 2 , 4 ) = ( / 4 , 5 / ) t_edge ( 1 : 2 , 5 ) = ( / 5 , 6 / ) t_edge ( 1 : 2 , 6 ) = ( / 6 , 4 / ) t_edge ( 1 : 2 , 7 ) = ( / 7 , 8 / ) t_edge ( 1 : 2 , 8 ) = ( / 8 , 9 / ) t_edge ( 1 : 2 , 9 ) = ( / 9 , 7 / ) t_edge ( 1 : 2 , 10 ) = ( / 10 , 11 / ) t_edge ( 1 : 2 , 11 ) = ( / 11 , 12 / ) t_edge ( 1 : 2 , 12 ) = ( / 12 , 10 / ) t_edge ( 1 : 2 , 13 ) = ( / 13 , 14 / ) t_edge ( 1 : 2 , 14 ) = ( / 14 , 15 / ) t_edge ( 1 : 2 , 15 ) = ( / 15 , 13 / ) t_edge ( 1 : 2 , 16 ) = ( / 16 , 17 / ) t_edge ( 1 : 2 , 17 ) = ( / 17 , 18 / ) t_edge ( 1 : 2 , 18 ) = ( / 18 , 16 / ) t_edge ( 1 : 2 , 19 ) = ( / 19 , 20 / ) t_edge ( 1 : 2 , 20 ) = ( / 20 , 21 / ) t_edge ( 1 : 2 , 21 ) = ( / 21 , 19 / ) t_edge ( 1 : 2 , 22 ) = ( / 22 , 23 / ) t_edge ( 1 : 2 , 23 ) = ( / 23 , 24 / ) t_edge ( 1 : 2 , 24 ) = ( / 24 , 22 / ) end if end subroutine PoVRay_getpos_FZ432 !-------------------------------------------------------------------------- ! ! SUBROUTINE: PoVRay_getpos_FZ23 ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief initialize the PoVRay output for rotational group 23 ! !> @param dims dimensions for subsequent arrays !> @param cpos vertex coordinates !> @param s_edge first set of edge connectivities !> @param t_edge second set of edge connectivities !> @param ns, d, nt  auxiliary parameters !> @param MFZ (optional) return coordinates for Mackenzie FZ instead of regular FZ ! !> @date    09/10/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine PoVRay_getpos_FZ23 ( dims , cpos , s_edge , t_edge , ns , d , nt , MFZ ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_getpos_FZ23 IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dims ( 3 ) real ( kind = dbl ), INTENT ( INOUT ) :: cpos ( 3 , dims ( 1 )) integer ( kind = irg ), INTENT ( INOUT ) :: s_edge ( 2 , dims ( 2 )) integer ( kind = irg ), INTENT ( INOUT ) :: t_edge ( 2 , dims ( 3 )) integer ( kind = irg ), INTENT ( OUT ) :: ns real ( kind = dbl ), INTENT ( OUT ) :: d integer ( kind = irg ), INTENT ( OUT ) :: nt logical , OPTIONAL , INTENT ( IN ) :: MFZ real ( kind = dbl ) :: a = 1.D0 , b = 0.0D0 , c = 0.5773502692D0 , e = 0.333333333D0 , & ds = 0.6340506711D0 , dt = 1.4142135623730D0 , dd , zz = 0.D0 , oo = 1.D0 d = 1.0 if ( present ( MFZ )) then if ( MFZ ) then ! define the coordinates of the cubic Mackenzie FZ in Rodrigues Space cpos ( 1 : 3 , 1 ) = ( / b , b , b / ) cpos ( 1 : 3 , 2 ) = ( / a , b , b / ) cpos ( 1 : 3 , 3 ) = ( / b , a , b / ) cpos ( 1 : 3 , 4 ) = ( / e , e , e / ) cpos = cpos / d ns = 200 nt = nint ( ns * dt / ds ) ! define the connectivity of all the edges s_edge ( 1 : 2 , 1 ) = ( / 1 , 2 / ) s_edge ( 1 : 2 , 2 ) = ( / 1 , 3 / ) s_edge ( 1 : 2 , 3 ) = ( / 1 , 4 / ) s_edge ( 1 : 2 , 4 ) = ( / 2 , 3 / ) s_edge ( 1 : 2 , 5 ) = ( / 2 , 4 / ) s_edge ( 1 : 2 , 6 ) = ( / 3 , 4 / ) end if ! define the coordinates of the cubic FZ in Rodrigues Space else ! define the coordinates of the cubic D3 FZ in Rodrigues Space cpos ( 1 : 3 , 1 ) = ( / a , b , b / ) cpos ( 1 : 3 , 2 ) = ( / b , a , b / ) cpos ( 1 : 3 , 3 ) = ( / - a , b , b / ) cpos ( 1 : 3 , 4 ) = ( / b , - a , b / ) cpos ( 1 : 3 , 5 ) = ( / b , b , a / ) cpos ( 1 : 3 , 6 ) = ( / b , b , - a / ) cpos = cpos / d ns = 200 nt = nint ( ns * dt / ds ) ! define the connectivity of all the edges s_edge ( 1 : 2 , 1 ) = ( / 1 , 2 / ) s_edge ( 1 : 2 , 2 ) = ( / 2 , 3 / ) s_edge ( 1 : 2 , 3 ) = ( / 3 , 4 / ) s_edge ( 1 : 2 , 4 ) = ( / 4 , 1 / ) s_edge ( 1 : 2 , 5 ) = ( / 1 , 5 / ) s_edge ( 1 : 2 , 6 ) = ( / 2 , 5 / ) s_edge ( 1 : 2 , 7 ) = ( / 3 , 5 / ) s_edge ( 1 : 2 , 8 ) = ( / 4 , 5 / ) s_edge ( 1 : 2 , 9 ) = ( / 1 , 6 / ) s_edge ( 1 : 2 , 10 ) = ( / 2 , 6 / ) s_edge ( 1 : 2 , 11 ) = ( / 3 , 6 / ) s_edge ( 1 : 2 , 12 ) = ( / 4 , 6 / ) end if end subroutine PoVRay_getpos_FZ23 !-------------------------------------------------------------------------- ! ! SUBROUTINE: PoVRay_getpos_FZ622 ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief initialize the PoVRay output for rotational group 622 ! !> @param dims dimensions for subsequent arrays !> @param cpos vertex coordinates !> @param s_edge first set of edge connectivities !> @param t_edge second set of edge connectivities !> @param ns, d, nt  auxiliary parameters !> @param MFZ (optional) return coordinates for Mackenzie FZ instead of regular FZ ! !> @date    09/10/16 MDG 1.0 original !> @date    02/05/17 MDG 1.1 correction of d parameter !-------------------------------------------------------------------------- recursive subroutine PoVRay_getpos_FZ622 ( dims , cpos , s_edge , t_edge , ns , d , nt , MFZ ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_getpos_FZ622 IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dims ( 3 ) real ( kind = dbl ), INTENT ( INOUT ) :: cpos ( 3 , dims ( 1 )) integer ( kind = irg ), INTENT ( INOUT ) :: s_edge ( 2 , dims ( 2 )) integer ( kind = irg ), INTENT ( INOUT ) :: t_edge ( 2 , dims ( 3 )) integer ( kind = irg ), INTENT ( OUT ) :: ns real ( kind = dbl ), INTENT ( OUT ) :: d integer ( kind = irg ), INTENT ( OUT ) :: nt logical , OPTIONAL , INTENT ( IN ) :: MFZ real ( kind = dbl ) :: a = 1.0D0 , b = 0.267949192431D0 , c = 0.732050807569D0 , & dt = 0.5358983848622454D0 , ds = 0.5358983848622454D0 , di = 1.069389330154823D0 , dd , & z = 0.D0 , o = 0.86602540378443D0 , p = 0.5D0 d = 1.0693893290743279D0 if ( present ( MFZ )) then if ( MFZ ) then ! define the coordinates of the hexagonal Mackenzie FZ in Rodrigues Space cpos ( 1 : 3 , 1 ) = ( / z , z , z / ) cpos ( 1 : 3 , 2 ) = ( / z , z , b / ) cpos ( 1 : 3 , 3 ) = ( / a , z , z / ) cpos ( 1 : 3 , 4 ) = ( / a , z , b / ) cpos ( 1 : 3 , 5 ) = ( / a , b , z / ) cpos ( 1 : 3 , 6 ) = ( / a , b , b / ) cpos ( 1 : 3 , 7 ) = ( / o , p , z / ) cpos ( 1 : 3 , 8 ) = ( / o , p , b / ) cpos = cpos / d ns = 200 nt = nint ( ns * dt / ds ) ! define the connectivity of all the edges s_edge ( 1 : 2 , 1 ) = ( / 1 , 2 / ) s_edge ( 1 : 2 , 2 ) = ( / 1 , 3 / ) s_edge ( 1 : 2 , 3 ) = ( / 1 , 7 / ) s_edge ( 1 : 2 , 4 ) = ( / 2 , 4 / ) s_edge ( 1 : 2 , 5 ) = ( / 2 , 8 / ) s_edge ( 1 : 2 , 6 ) = ( / 3 , 4 / ) s_edge ( 1 : 2 , 7 ) = ( / 3 , 5 / ) s_edge ( 1 : 2 , 8 ) = ( / 4 , 6 / ) s_edge ( 1 : 2 , 9 ) = ( / 5 , 6 / ) s_edge ( 1 : 2 , 10 ) = ( / 5 , 7 / ) s_edge ( 1 : 2 , 11 ) = ( / 6 , 8 / ) s_edge ( 1 : 2 , 12 ) = ( / 7 , 8 / ) end if else ! define the coordinates of the hexagonal FZ in Rodrigues Space cpos ( 1 : 3 , 1 ) = ( / a , b , b / ) cpos ( 1 : 3 , 2 ) = ( / c , c , b / ) cpos ( 1 : 3 , 3 ) = ( / b , a , b / ) cpos ( 1 : 3 , 4 ) = ( / - b , a , b / ) cpos ( 1 : 3 , 5 ) = ( / - c , c , b / ) cpos ( 1 : 3 , 6 ) = ( / - a , b , b / ) cpos ( 1 : 3 , 7 ) = ( / - a , - b , b / ) cpos ( 1 : 3 , 8 ) = ( / - c , - c , b / ) cpos ( 1 : 3 , 9 ) = ( / - b , - a , b / ) cpos ( 1 : 3 , 10 ) = ( / b , - a , b / ) cpos ( 1 : 3 , 11 ) = ( / c , - c , b / ) cpos ( 1 : 3 , 12 ) = ( / a , - b , b / ) cpos ( 1 : 3 , 13 ) = ( / a , b , - b / ) cpos ( 1 : 3 , 14 ) = ( / c , c , - b / ) cpos ( 1 : 3 , 15 ) = ( / b , a , - b / ) cpos ( 1 : 3 , 16 ) = ( / - b , a , - b / ) cpos ( 1 : 3 , 17 ) = ( / - c , c , - b / ) cpos ( 1 : 3 , 18 ) = ( / - a , b , - b / ) cpos ( 1 : 3 , 19 ) = ( / - a , - b , - b / ) cpos ( 1 : 3 , 20 ) = ( / - c , - c , - b / ) cpos ( 1 : 3 , 21 ) = ( / - b , - a , - b / ) cpos ( 1 : 3 , 22 ) = ( / b , - a , - b / ) cpos ( 1 : 3 , 23 ) = ( / c , - c , - b / ) cpos ( 1 : 3 , 24 ) = ( / a , - b , - b / ) cpos = cpos / d ns = 200 nt = nint ( ns * dt / ds ) ! define the connectivity of all the edges s_edge ( 1 : 2 , 1 ) = ( / 1 , 2 / ) s_edge ( 1 : 2 , 2 ) = ( / 2 , 3 / ) s_edge ( 1 : 2 , 3 ) = ( / 3 , 4 / ) s_edge ( 1 : 2 , 4 ) = ( / 4 , 5 / ) s_edge ( 1 : 2 , 5 ) = ( / 5 , 6 / ) s_edge ( 1 : 2 , 6 ) = ( / 6 , 7 / ) s_edge ( 1 : 2 , 7 ) = ( / 7 , 8 / ) s_edge ( 1 : 2 , 8 ) = ( / 8 , 9 / ) s_edge ( 1 : 2 , 9 ) = ( / 9 , 10 / ) s_edge ( 1 : 2 , 10 ) = ( / 10 , 11 / ) s_edge ( 1 : 2 , 11 ) = ( / 11 , 12 / ) s_edge ( 1 : 2 , 12 ) = ( / 12 , 1 / ) s_edge ( 1 : 2 , 13 ) = ( / 13 , 14 / ) s_edge ( 1 : 2 , 14 ) = ( / 14 , 15 / ) s_edge ( 1 : 2 , 15 ) = ( / 15 , 16 / ) s_edge ( 1 : 2 , 16 ) = ( / 16 , 17 / ) s_edge ( 1 : 2 , 17 ) = ( / 17 , 18 / ) s_edge ( 1 : 2 , 18 ) = ( / 18 , 19 / ) s_edge ( 1 : 2 , 19 ) = ( / 19 , 20 / ) s_edge ( 1 : 2 , 20 ) = ( / 20 , 21 / ) s_edge ( 1 : 2 , 21 ) = ( / 21 , 22 / ) s_edge ( 1 : 2 , 22 ) = ( / 22 , 23 / ) s_edge ( 1 : 2 , 23 ) = ( / 23 , 24 / ) s_edge ( 1 : 2 , 24 ) = ( / 24 , 13 / ) t_edge ( 1 : 2 , 1 ) = ( / 1 , 13 / ) t_edge ( 1 : 2 , 2 ) = ( / 2 , 14 / ) t_edge ( 1 : 2 , 3 ) = ( / 3 , 15 / ) t_edge ( 1 : 2 , 4 ) = ( / 4 , 16 / ) t_edge ( 1 : 2 , 5 ) = ( / 5 , 17 / ) t_edge ( 1 : 2 , 6 ) = ( / 6 , 18 / ) t_edge ( 1 : 2 , 7 ) = ( / 7 , 19 / ) t_edge ( 1 : 2 , 8 ) = ( / 8 , 20 / ) t_edge ( 1 : 2 , 9 ) = ( / 9 , 21 / ) t_edge ( 1 : 2 , 10 ) = ( / 10 , 22 / ) t_edge ( 1 : 2 , 11 ) = ( / 11 , 23 / ) t_edge ( 1 : 2 , 12 ) = ( / 12 , 24 / ) end if end subroutine PoVRay_getpos_FZ622 !-------------------------------------------------------------------------- ! ! SUBROUTINE: PoVRay_getpos_FZ422 ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief initialize the PoVRay output for rotational group 422 ! !> @param dims dimensions for subsequent arrays !> @param cpos vertex coordinates !> @param s_edge first set of edge connectivities !> @param t_edge second set of edge connectivities !> @param ns, d, nt  auxiliary parameters !> @param MFZ (optional) return coordinates for Mackenzie FZ instead of regular FZ ! !> @date    09/10/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine PoVRay_getpos_FZ422 ( dims , cpos , s_edge , t_edge , ns , d , nt , MFZ ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_getpos_FZ422 IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dims ( 3 ) real ( kind = dbl ), INTENT ( INOUT ) :: cpos ( 3 , dims ( 1 )) integer ( kind = irg ), INTENT ( INOUT ) :: s_edge ( 2 , dims ( 2 )) integer ( kind = irg ), INTENT ( INOUT ) :: t_edge ( 2 , dims ( 3 )) integer ( kind = irg ), INTENT ( OUT ) :: ns real ( kind = dbl ), INTENT ( OUT ) :: d integer ( kind = irg ), INTENT ( OUT ) :: nt logical , OPTIONAL , INTENT ( IN ) :: MFZ real ( kind = dbl ) :: a = 1.0D0 , b = 0.41421354D0 , c = 0.41421354D0 , dt = 0.8284270763397216D0 , & ds = 0.8284270763397216D0 , dd , z = 0.D0 , o = 0.70710678118654746D0 d = 1.158941651036677D0 if ( present ( MFZ )) then if ( MFZ ) then ! define the coordinates of the tetragonal Mackenzie FZ in Rodrigues Space cpos ( 1 : 3 , 1 ) = ( / z , z , z / ) cpos ( 1 : 3 , 2 ) = ( / z , z , c / ) cpos ( 1 : 3 , 3 ) = ( / a , z , z / ) cpos ( 1 : 3 , 4 ) = ( / a , z , c / ) cpos ( 1 : 3 , 5 ) = ( / a , b , z / ) cpos ( 1 : 3 , 6 ) = ( / a , b , c / ) cpos ( 1 : 3 , 7 ) = ( / o , o , z / ) cpos ( 1 : 3 , 8 ) = ( / o , o , c / ) cpos = cpos / d ns = 200 nt = nint ( ns * dt / ds ) ! define the connectivity of all the edges s_edge ( 1 : 2 , 1 ) = ( / 1 , 2 / ) s_edge ( 1 : 2 , 2 ) = ( / 1 , 3 / ) s_edge ( 1 : 2 , 3 ) = ( / 1 , 7 / ) s_edge ( 1 : 2 , 4 ) = ( / 2 , 4 / ) s_edge ( 1 : 2 , 5 ) = ( / 2 , 8 / ) s_edge ( 1 : 2 , 6 ) = ( / 3 , 4 / ) s_edge ( 1 : 2 , 7 ) = ( / 3 , 5 / ) s_edge ( 1 : 2 , 8 ) = ( / 4 , 6 / ) s_edge ( 1 : 2 , 9 ) = ( / 5 , 6 / ) s_edge ( 1 : 2 , 10 ) = ( / 5 , 7 / ) s_edge ( 1 : 2 , 11 ) = ( / 6 , 8 / ) s_edge ( 1 : 2 , 12 ) = ( / 7 , 8 / ) end if ! define the coordinates of the cubic FZ in Rodrigues Space else ! define the coordinates of the tetragonal 422 FZ in Rodrigues Space cpos ( 1 : 3 , 1 ) = ( / a , b , c / ) cpos ( 1 : 3 , 2 ) = ( / b , a , c / ) cpos ( 1 : 3 , 3 ) = ( / - b , a , c / ) cpos ( 1 : 3 , 4 ) = ( / - a , b , c / ) cpos ( 1 : 3 , 5 ) = ( / - a , - b , c / ) cpos ( 1 : 3 , 6 ) = ( / - b , - a , c / ) cpos ( 1 : 3 , 7 ) = ( / b , - a , c / ) cpos ( 1 : 3 , 8 ) = ( / a , - b , c / ) cpos ( 1 : 3 , 9 ) = ( / a , b , - c / ) cpos ( 1 : 3 , 10 ) = ( / b , a , - c / ) cpos ( 1 : 3 , 11 ) = ( / - b , a , - c / ) cpos ( 1 : 3 , 12 ) = ( / - a , b , - c / ) cpos ( 1 : 3 , 13 ) = ( / - a , - b , - c / ) cpos ( 1 : 3 , 14 ) = ( / - b , - a , - c / ) cpos ( 1 : 3 , 15 ) = ( / b , - a , - c / ) cpos ( 1 : 3 , 16 ) = ( / a , - b , - c / ) cpos = cpos / d ns = 200 nt = nint ( ns * dt / ds ) ! define the connectivity of all the edges s_edge ( 1 : 2 , 1 ) = ( / 1 , 2 / ) s_edge ( 1 : 2 , 2 ) = ( / 2 , 3 / ) s_edge ( 1 : 2 , 3 ) = ( / 3 , 4 / ) s_edge ( 1 : 2 , 4 ) = ( / 4 , 5 / ) s_edge ( 1 : 2 , 5 ) = ( / 5 , 6 / ) s_edge ( 1 : 2 , 6 ) = ( / 6 , 7 / ) s_edge ( 1 : 2 , 7 ) = ( / 7 , 8 / ) s_edge ( 1 : 2 , 8 ) = ( / 8 , 1 / ) s_edge ( 1 : 2 , 9 ) = ( / 9 , 10 / ) s_edge ( 1 : 2 , 10 ) = ( / 10 , 11 / ) s_edge ( 1 : 2 , 11 ) = ( / 11 , 12 / ) s_edge ( 1 : 2 , 12 ) = ( / 12 , 13 / ) s_edge ( 1 : 2 , 13 ) = ( / 13 , 14 / ) s_edge ( 1 : 2 , 14 ) = ( / 14 , 15 / ) s_edge ( 1 : 2 , 15 ) = ( / 15 , 16 / ) s_edge ( 1 : 2 , 16 ) = ( / 16 , 9 / ) t_edge ( 1 : 2 , 1 ) = ( / 1 , 9 / ) t_edge ( 1 : 2 , 2 ) = ( / 2 , 10 / ) t_edge ( 1 : 2 , 3 ) = ( / 3 , 11 / ) t_edge ( 1 : 2 , 4 ) = ( / 4 , 12 / ) t_edge ( 1 : 2 , 5 ) = ( / 5 , 13 / ) t_edge ( 1 : 2 , 6 ) = ( / 6 , 14 / ) t_edge ( 1 : 2 , 7 ) = ( / 7 , 15 / ) t_edge ( 1 : 2 , 8 ) = ( / 8 , 16 / ) end if end subroutine PoVRay_getpos_FZ422 !-------------------------------------------------------------------------- ! ! SUBROUTINE: PoVRay_getpos_FZ32 ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief initialize the PoVRay output for rotational group 32 ! !> @param dims dimensions for subsequent arrays !> @param cpos vertex coordinates !> @param s_edge first set of edge connectivities !> @param t_edge second set of edge connectivities !> @param ns, d, nt  auxiliary parameters !> @param MFZ (optional) return coordinates for Mackenzie FZ instead of regular FZ ! !> @date    09/10/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine PoVRay_getpos_FZ32 ( dims , cpos , s_edge , t_edge , ns , d , nt , MFZ ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_getpos_FZ32 IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dims ( 3 ) real ( kind = dbl ), INTENT ( INOUT ) :: cpos ( 3 , dims ( 1 )) integer ( kind = irg ), INTENT ( INOUT ) :: s_edge ( 2 , dims ( 2 )) integer ( kind = irg ), INTENT ( INOUT ) :: t_edge ( 2 , dims ( 3 )) integer ( kind = irg ), INTENT ( OUT ) :: ns real ( kind = dbl ), INTENT ( OUT ) :: d integer ( kind = irg ), INTENT ( OUT ) :: nt logical , OPTIONAL , INTENT ( IN ) :: MFZ real ( kind = dbl ) :: a = 0.8660254038D0 , b = 0.5D0 , c = 0.5773502692D0 , dt = 0.34314575050D0 , & ds = 0.6340506711D0 , dd , z = 0.D0 , oo = 1.D0 , o = 0.86602540378443D0 , p = 0.5D0 d = 1.1547005384D0 if ( present ( MFZ )) then if ( MFZ ) then ! define the coordinates of the tetragonal Mackenzie FZ in Rodrigues Space cpos ( 1 : 3 , 1 ) = ( / z , z , z / ) cpos ( 1 : 3 , 2 ) = ( / z , z , c / ) cpos ( 1 : 3 , 3 ) = ( / a , - p , z / ) cpos ( 1 : 3 , 4 ) = ( / a , - p , c / ) cpos ( 1 : 3 , 5 ) = ( / a , p , z / ) cpos ( 1 : 3 , 6 ) = ( / a , p , c / ) cpos = cpos / d ns = 200 nt = nint ( ns * dt / ds ) ! define the connectivity of all the edges s_edge ( 1 : 2 , 1 ) = ( / 1 , 2 / ) s_edge ( 1 : 2 , 2 ) = ( / 1 , 3 / ) s_edge ( 1 : 2 , 3 ) = ( / 1 , 5 / ) s_edge ( 1 : 2 , 4 ) = ( / 2 , 4 / ) s_edge ( 1 : 2 , 5 ) = ( / 2 , 6 / ) s_edge ( 1 : 2 , 6 ) = ( / 3 , 4 / ) s_edge ( 1 : 2 , 7 ) = ( / 3 , 5 / ) s_edge ( 1 : 2 , 8 ) = ( / 4 , 6 / ) s_edge ( 1 : 2 , 9 ) = ( / 5 , 6 / ) end if else ! define the coordinates of the cubic FZ in Rodrigues Space cpos ( 1 : 3 , 1 ) = ( / a , b , c / ) cpos ( 1 : 3 , 2 ) = ( / z , oo , c / ) cpos ( 1 : 3 , 3 ) = ( / - a , b , c / ) cpos ( 1 : 3 , 4 ) = ( / - a , - b , c / ) cpos ( 1 : 3 , 5 ) = ( / z , - oo , c / ) cpos ( 1 : 3 , 6 ) = ( / a , - b , c / ) cpos ( 1 : 3 , 7 ) = ( / a , b , - c / ) cpos ( 1 : 3 , 8 ) = ( / z , oo , - c / ) cpos ( 1 : 3 , 9 ) = ( / - a , b , - c / ) cpos ( 1 : 3 , 10 ) = ( / - a , - b , - c / ) cpos ( 1 : 3 , 11 ) = ( / z , - oo , - c / ) cpos ( 1 : 3 , 12 ) = ( / a , - b , - c / ) cpos = cpos / d ns = 200 nt = nint ( ns * dt / ds ) ! define the connectivity of all the edges s_edge ( 1 : 2 , 1 ) = ( / 1 , 2 / ) s_edge ( 1 : 2 , 2 ) = ( / 2 , 3 / ) s_edge ( 1 : 2 , 3 ) = ( / 3 , 4 / ) s_edge ( 1 : 2 , 4 ) = ( / 4 , 5 / ) s_edge ( 1 : 2 , 5 ) = ( / 5 , 6 / ) s_edge ( 1 : 2 , 6 ) = ( / 6 , 1 / ) s_edge ( 1 : 2 , 7 ) = ( / 7 , 8 / ) s_edge ( 1 : 2 , 8 ) = ( / 8 , 9 / ) s_edge ( 1 : 2 , 9 ) = ( / 9 , 10 / ) s_edge ( 1 : 2 , 10 ) = ( / 10 , 11 / ) s_edge ( 1 : 2 , 11 ) = ( / 11 , 12 / ) s_edge ( 1 : 2 , 12 ) = ( / 12 , 7 / ) t_edge ( 1 : 2 , 1 ) = ( / 1 , 7 / ) t_edge ( 1 : 2 , 2 ) = ( / 2 , 8 / ) t_edge ( 1 : 2 , 3 ) = ( / 3 , 9 / ) t_edge ( 1 : 2 , 4 ) = ( / 4 , 10 / ) t_edge ( 1 : 2 , 5 ) = ( / 5 , 11 / ) t_edge ( 1 : 2 , 6 ) = ( / 6 , 12 / ) end if end subroutine PoVRay_getpos_FZ32 !-------------------------------------------------------------------------- ! ! SUBROUTINE: PoVRay_getpos_FZ222 ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief initialize the PoVRay output for rotational group 222 ! !> @param dims dimensions for subsequent arrays !> @param cpos vertex coordinates !> @param s_edge first set of edge connectivities !> @param t_edge second set of edge connectivities !> @param ns, d, nt  auxiliary parameters !> @param MFZ (optional) return coordinates for Mackenzie FZ instead of regular FZ ! !> @date    09/10/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine PoVRay_getpos_FZ222 ( dims , cpos , s_edge , t_edge , ns , d , nt , MFZ ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_getpos_FZ222 IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dims ( 3 ) real ( kind = dbl ), INTENT ( INOUT ) :: cpos ( 3 , dims ( 1 )) integer ( kind = irg ), INTENT ( INOUT ) :: s_edge ( 2 , dims ( 2 )) integer ( kind = irg ), INTENT ( INOUT ) :: t_edge ( 2 , dims ( 3 )) integer ( kind = irg ), INTENT ( OUT ) :: ns real ( kind = dbl ), INTENT ( OUT ) :: d integer ( kind = irg ), INTENT ( OUT ) :: nt logical , OPTIONAL , INTENT ( IN ) :: MFZ real ( kind = dbl ) :: a = 1.0D0 , b = 1.0D0 , c = 1 D0 , dt = 2.0D0 , & ds = 2.0D0 , dd , z = 0.D0 , oo = 1.D0 d = 1.7320508075688772D0 if ( present ( MFZ )) then if ( MFZ ) then ! define the coordinates of the tetragonal Mackenzie FZ in Rodrigues Space cpos ( 1 : 3 , 1 ) = ( / z , - a , z / ) cpos ( 1 : 3 , 2 ) = ( / z , - a , c / ) cpos ( 1 : 3 , 3 ) = ( / a , - a , z / ) cpos ( 1 : 3 , 4 ) = ( / a , - a , c / ) cpos ( 1 : 3 , 5 ) = ( / a , a , z / ) cpos ( 1 : 3 , 6 ) = ( / a , a , c / ) cpos ( 1 : 3 , 7 ) = ( / z , a , z / ) cpos ( 1 : 3 , 8 ) = ( / z , a , c / ) cpos = cpos / d ns = 200 nt = nint ( ns * dt / ds ) ! define the connectivity of all the edges s_edge ( 1 : 2 , 1 ) = ( / 1 , 2 / ) s_edge ( 1 : 2 , 2 ) = ( / 1 , 3 / ) s_edge ( 1 : 2 , 3 ) = ( / 1 , 7 / ) s_edge ( 1 : 2 , 4 ) = ( / 2 , 4 / ) s_edge ( 1 : 2 , 5 ) = ( / 2 , 8 / ) s_edge ( 1 : 2 , 6 ) = ( / 3 , 4 / ) s_edge ( 1 : 2 , 7 ) = ( / 3 , 5 / ) s_edge ( 1 : 2 , 8 ) = ( / 4 , 6 / ) s_edge ( 1 : 2 , 9 ) = ( / 5 , 6 / ) s_edge ( 1 : 2 , 10 ) = ( / 5 , 7 / ) s_edge ( 1 : 2 , 11 ) = ( / 6 , 8 / ) s_edge ( 1 : 2 , 12 ) = ( / 7 , 8 / ) end if ! define the coordinates of the cubic FZ in Rodrigues Space else ! define the coordinates of the FZ in Rodrigues Space cpos ( 1 : 3 , 1 ) = ( / a , b , c / ) cpos ( 1 : 3 , 2 ) = ( / - a , b , c / ) cpos ( 1 : 3 , 3 ) = ( / - a , - b , c / ) cpos ( 1 : 3 , 4 ) = ( / a , - b , c / ) cpos ( 1 : 3 , 5 ) = ( / a , b , - c / ) cpos ( 1 : 3 , 6 ) = ( / - a , b , - c / ) cpos ( 1 : 3 , 7 ) = ( / - a , - b , - c / ) cpos ( 1 : 3 , 8 ) = ( / a , - b , - c / ) cpos = cpos / d ns = 200 nt = nint ( ns * dt / ds ) ! define the connectivity of all the edges s_edge ( 1 : 2 , 1 ) = ( / 1 , 2 / ) s_edge ( 1 : 2 , 2 ) = ( / 2 , 3 / ) s_edge ( 1 : 2 , 3 ) = ( / 3 , 4 / ) s_edge ( 1 : 2 , 4 ) = ( / 4 , 1 / ) s_edge ( 1 : 2 , 5 ) = ( / 5 , 6 / ) s_edge ( 1 : 2 , 6 ) = ( / 6 , 7 / ) s_edge ( 1 : 2 , 7 ) = ( / 7 , 8 / ) s_edge ( 1 : 2 , 8 ) = ( / 8 , 5 / ) t_edge ( 1 : 2 , 1 ) = ( / 1 , 5 / ) t_edge ( 1 : 2 , 2 ) = ( / 2 , 6 / ) t_edge ( 1 : 2 , 3 ) = ( / 3 , 7 / ) t_edge ( 1 : 2 , 4 ) = ( / 4 , 8 / ) end if end subroutine PoVRay_getpos_FZ222 !-------------------------------------------------------------------------- ! ! SUBROUTINE: PoVRay_drawFZ ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief initialize the PoVRay output for any rotation group ! !> @details This routine draws the outline of either the Rodrigues Fundamental !> zone, or the Mackenzie Fundamental Zone (if MFZ is set and true). ! !> @param dunit output unit number !> @param rmode  1(cubochoric)|2(homochoric)|3(stereographic)|4(Rodrigues)|5(Euler) !> @param cylr cylinder radius !> @param FZtype  Fundamental zone type !> @param FZorder order of the FZ point group !> @param MFZ (optional) Mackenzie FZ instead of regular FZ ! !> @date    09/10/16 MDG 1.0 original !> @date    11/23/16 MDG 1.1 added Euler representation !-------------------------------------------------------------------------- recursive subroutine PoVRay_drawFZ ( dunit , rmode , cylr , FZtype , FZorder , MFZ ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_drawFZ IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit integer ( kind = irg ), INTENT ( IN ) :: rmode real ( kind = dbl ), INTENT ( IN ) :: cylr integer ( kind = irg ), INTENT ( IN ) :: FZtype integer ( kind = irg ), INTENT ( IN ) :: FZorder logical , OPTIONAL , INTENT ( IN ) :: MFZ real ( kind = dbl ) :: eul ( 3 ), axang ( 4 ), rv ( 3 ), qu ( 4 ), h ( 3 ), rmax , dx , r , xmax , x , y , z , ho ( 3 ), cu ( 3 ), zsmall , & eyepos ( 3 ), ac , sh ( 3 ), ron ( 4 ) real ( kind = dbl ) :: euld ( 3 ), om ( 3 , 3 ), ro1 ( 4 ), ro2 ( 4 ), culast ( 3 ), holast ( 3 ), ro ( 4 ), rolast ( 4 ), splast ( 3 ), sp ( 3 ), & eu ( 3 ), eulast ( 3 ), xx type ( orientationtype ) :: ot type ( orientationtyped ) :: otd integer ( kind = irg ), allocatable :: s_edge (:,:), t_edge (:,:) real ( kind = dbl ), allocatable :: cpos (:,:) logical :: doMFZ , twostep integer ( kind = irg ) :: i , j , k , icnt , imax , nt , ns , dims ( 3 ) real ( kind = dbl ) :: d , dd , tpi , hpi tpi = 2.D0 * cPi hpi = 0.5D0 * cPi doMFZ = . FALSE . if ( present ( MFZ )) doMFZ = . TRUE . write ( * , * ) 'inside PoVRay_drawFZ; MFZ = ' , doMFZ , dunit , rmode , cylr , FZtype , FZorder if ( FZtype . eq . 2 ) then if ( FZorder . eq . 6 ) then if ( doMFZ ) then twostep = . FALSE . dims = ( / 8 , 12 , 1 / ) allocate ( cpos ( 3 , dims ( 1 )), s_edge ( 2 , dims ( 2 )), t_edge ( 2 , dims ( 3 ))) call PoVRay_getpos_FZ622 ( dims , cpos , s_edge , t_edge , ns , d , nt , MFZ ) else twostep = . TRUE . dims = ( / 24 , 24 , 12 / ) allocate ( cpos ( 3 , dims ( 1 )), s_edge ( 2 , dims ( 2 )), t_edge ( 2 , dims ( 3 ))) call PoVRay_getpos_FZ622 ( dims , cpos , s_edge , t_edge , ns , d , nt ) end if end if if ( FZorder . eq . 4 ) then if ( doMFZ ) then twostep = . FALSE . dims = ( / 8 , 12 , 1 / ) allocate ( cpos ( 3 , dims ( 1 )), s_edge ( 2 , dims ( 2 )), t_edge ( 2 , dims ( 3 ))) call PoVRay_getpos_FZ422 ( dims , cpos , s_edge , t_edge , ns , d , nt , MFZ ) else twostep = . TRUE . dims = ( / 16 , 16 , 8 / ) allocate ( cpos ( 3 , dims ( 1 )), s_edge ( 2 , dims ( 2 )), t_edge ( 2 , dims ( 3 ))) call PoVRay_getpos_FZ422 ( dims , cpos , s_edge , t_edge , ns , d , nt ) end if end if if ( FZorder . eq . 3 ) then if ( doMFZ ) then twostep = . FALSE . dims = ( / 6 , 9 , 1 / ) allocate ( cpos ( 3 , dims ( 1 )), s_edge ( 2 , dims ( 2 )), t_edge ( 2 , dims ( 3 ))) call PoVRay_getpos_FZ32 ( dims , cpos , s_edge , t_edge , ns , d , nt , MFZ ) else twostep = . TRUE . dims = ( / 12 , 12 , 6 / ) allocate ( cpos ( 3 , dims ( 1 )), s_edge ( 2 , dims ( 2 )), t_edge ( 2 , dims ( 3 ))) call PoVRay_getpos_FZ32 ( dims , cpos , s_edge , t_edge , ns , d , nt ) end if end if if ( FZorder . eq . 2 ) then if ( doMFZ ) then twostep = . FALSE . dims = ( / 8 , 12 , 1 / ) allocate ( cpos ( 3 , dims ( 1 )), s_edge ( 2 , dims ( 2 )), t_edge ( 2 , dims ( 3 ))) call PoVRay_getpos_FZ222 ( dims , cpos , s_edge , t_edge , ns , d , nt , MFZ ) else twostep = . TRUE . dims = ( / 8 , 8 , 4 / ) allocate ( cpos ( 3 , dims ( 1 )), s_edge ( 2 , dims ( 2 )), t_edge ( 2 , dims ( 3 ))) call PoVRay_getpos_FZ222 ( dims , cpos , s_edge , t_edge , ns , d , nt ) end if end if end if if ( FZtype . eq . 3 ) then ! rotational group 23 if ( doMFZ ) then twostep = . FALSE . dims = ( / 4 , 6 , 1 / ) allocate ( cpos ( 3 , dims ( 1 )), s_edge ( 2 , dims ( 2 )), t_edge ( 2 , dims ( 3 ))) call PoVRay_getpos_FZ23 ( dims , cpos , s_edge , t_edge , ns , d , nt , MFZ ) else twostep = . FALSE . dims = ( / 6 , 12 , 1 / ) allocate ( cpos ( 3 , dims ( 1 )), s_edge ( 2 , dims ( 2 )), t_edge ( 2 , dims ( 3 ))) call PoVRay_getpos_FZ23 ( dims , cpos , s_edge , t_edge , ns , d , nt ) end if end if if ( FZtype . eq . 4 ) then ! rotational group 432 if ( doMFZ ) then twostep = . FALSE . dims = ( / 6 , 9 , 1 / ) allocate ( cpos ( 3 , dims ( 1 )), s_edge ( 2 , dims ( 2 )), t_edge ( 2 , dims ( 3 ))) call PoVRay_getpos_FZ432 ( dims , cpos , s_edge , t_edge , ns , d , nt , MFZ ) else twostep = . TRUE . dims = ( / 24 , 12 , 24 / ) allocate ( cpos ( 3 , dims ( 1 )), s_edge ( 2 , dims ( 2 )), t_edge ( 2 , dims ( 3 ))) call PoVRay_getpos_FZ432 ( dims , cpos , s_edge , t_edge , ns , d , nt ) end if end if ! add the reference frame and any necessary wireframes if ( rmode . eq . 1 ) then ac = 0.5D0 * LPs % ap call PoVRay_addReferenceFrame ( dunit , ac , cylr ) call PoVRay_addCubochoricCube ( dunit ) end if if ( rmode . eq . 2 ) then ac = 1.33067D0 call PoVRay_addReferenceFrame ( dunit , ac , cylr ) call PoVRay_addWireFrameSphere ( dunit , ac ) end if if ( rmode . eq . 3 ) then ac = 1.0D0 call PoVRay_addReferenceFrame ( dunit , ac , cylr ) call PoVRay_addWireFrameSphere ( dunit , ac ) end if if ( rmode . eq . 4 ) then ac = 1.0D0 call PoVRay_addReferenceFrame ( dunit , ac , cylr ) end if if ( rmode . eq . 5 ) then call PoVRay_addEulerBox ( dunit ) end if ! and next, draw the outline of the FZ or MFZ if (( rmode . eq . 1 ). or .( rmode . eq . 2 )) then ! create the square edges first dx = 1.D0 / dble ( ns ) do i = 1 , dims ( 2 ) ro1 ( 1 : 3 ) = cpos ( 1 : 3 , s_edge ( 1 , i )) ro1 ( 4 ) = d ro2 ( 1 : 3 ) = cpos ( 1 : 3 , s_edge ( 2 , i )) ro2 ( 4 ) = d culast = ro2cu ( ro1 ) holast = ro2ho ( ro1 ) do j = 1 , ns + 1 ro ( 1 : 3 ) = d * ro1 ( 1 : 3 ) + d * ( ro2 ( 1 : 3 ) - ro1 ( 1 : 3 )) * j * dx xx = dsqrt ( sum ( ro ( 1 : 3 ) ** 2 ) ) ro ( 1 : 3 ) = ro ( 1 : 3 ) / xx ro ( 4 ) = xx cu = ro2cu ( ro ) ho = ro2ho ( ro ) ! and create a cylinder with these points if ( rmode . eq . 1 ) then call PoVRay_addCylinder ( dunit , culast ( 1 : 3 ), cu ( 1 : 3 ), cylr ,( / 0.0 , 0.0 , 1.0 / )) else call PoVRay_addCylinder ( dunit , holast ( 1 : 3 ), ho ( 1 : 3 ), cylr ,( / 0.0 , 0.0 , 1.0 / )) end if culast = cu holast = ho end do end do if ( twostep ) then dx = 1.D0 / dble ( nt ) do i = 1 , dims ( 3 ) ro1 ( 1 : 3 ) = cpos ( 1 : 3 , t_edge ( 1 , i )) ro1 ( 4 ) = d ro2 ( 1 : 3 ) = cpos ( 1 : 3 , t_edge ( 2 , i )) ro2 ( 4 ) = d culast = ro2cu ( ro1 ) holast = ro2ho ( ro1 ) do j = 1 , nt + 1 ro ( 1 : 3 ) = d * ro1 ( 1 : 3 ) + d * ( ro2 ( 1 : 3 ) - ro1 ( 1 : 3 )) * j * dx xx = dsqrt ( sum ( ro ( 1 : 3 ) ** 2 ) ) ro ( 1 : 3 ) = ro ( 1 : 3 ) / xx ro ( 4 ) = xx cu = ro2cu ( ro ) ho = ro2ho ( ro ) ! and create a cylinder with these points if ( rmode . eq . 1 ) then call PoVRay_addCylinder ( dunit , culast ( 1 : 3 ), cu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) else call PoVRay_addCylinder ( dunit , holast ( 1 : 3 ), ho ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) end if culast = cu holast = ho end do end do end if end if if (( rmode . eq . 3 ). or .( rmode . eq . 4 )) then dx = 1.D0 / dble ( ns ) do i = 1 , dims ( 2 ) ro1 ( 1 : 3 ) = cpos ( 1 : 3 , s_edge ( 1 , i )) ro1 ( 4 ) = d ro2 ( 1 : 3 ) = cpos ( 1 : 3 , s_edge ( 2 , i )) ro2 ( 4 ) = d rolast = ro1 qu = ro2qu ( ro1 ) splast ( 1 : 3 ) = qu ( 2 : 4 ) / ( 1.D0 + qu ( 1 )) do j = 1 , ns + 1 ro ( 1 : 3 ) = d * ro1 ( 1 : 3 ) + d * ( ro2 ( 1 : 3 ) - ro1 ( 1 : 3 )) * j * dx xx = dsqrt ( sum ( ro ( 1 : 3 ) ** 2 ) ) ro ( 1 : 3 ) = ro ( 1 : 3 ) / xx ro ( 4 ) = xx qu = ro2qu ( ro ) sp ( 1 : 3 ) = qu ( 2 : 4 ) / ( 1.D0 + qu ( 1 )) ! and create a cylinder with these points if ( rmode . eq . 3 ) then call PoVRay_addCylinder ( dunit , splast ( 1 : 3 ), sp ( 1 : 3 ), cylr ,( / 0.0 , 0.0 , 1.0 / )) else call PoVRay_addCylinder ( dunit , rolast ( 1 : 3 ) * rolast ( 4 ), ro ( 1 : 3 ) * ro ( 4 ), cylr ,( / 0.0 , 0.0 , 1.0 / )) end if rolast = ro splast = sp end do end do if ( twostep ) then dx = 1.D0 / dble ( nt ) do i = 1 , dims ( 3 ) ro1 ( 1 : 3 ) = cpos ( 1 : 3 , t_edge ( 1 , i )) ro1 ( 4 ) = d ro2 ( 1 : 3 ) = cpos ( 1 : 3 , t_edge ( 2 , i )) ro2 ( 4 ) = d rolast = ro1 qu = ro2qu ( ro1 ) splast ( 1 : 3 ) = qu ( 2 : 4 ) / ( 1.D0 + qu ( 1 )) do j = 1 , nt + 1 ro ( 1 : 3 ) = d * ro1 ( 1 : 3 ) + d * ( ro2 ( 1 : 3 ) - ro1 ( 1 : 3 )) * j * dx xx = dsqrt ( sum ( ro ( 1 : 3 ) ** 2 ) ) ro ( 1 : 3 ) = ro ( 1 : 3 ) / xx ro ( 4 ) = xx qu = ro2qu ( ro ) sp ( 1 : 3 ) = qu ( 2 : 4 ) / ( 1.D0 + qu ( 1 )) ! and create a cylinder with these points if ( rmode . eq . 3 ) then call PoVRay_addCylinder ( dunit , splast ( 1 : 3 ), sp ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) else call PoVRay_addCylinder ( dunit , rolast ( 1 : 3 ) * rolast ( 4 ), ro ( 1 : 3 ) * ro ( 4 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) end if rolast = ro splast = sp end do end do end if end if ! and next, draw the outline of the FZ or MFZ if ( rmode . eq . 5 ) then sh = ( / cPi , cPi / 2.D0 , cPi / ) ! create the square edges first dx = 1.D0 / dble ( ns ) do i = 1 , dims ( 2 ) ro1 ( 1 : 3 ) = cpos ( 1 : 3 , s_edge ( 1 , i )) ro1 ( 4 ) = d ro2 ( 1 : 3 ) = cpos ( 1 : 3 , s_edge ( 2 , i )) ro2 ( 4 ) = d eulast = ro2eu ( ro1 ) eulast ( 1 ) = mod ( eulast ( 1 ) + 1 0.D0 * cPi , 2.D0 * cPi ) eulast ( 2 ) = mod ( eulast ( 2 ) + 1 0.D0 * cPi , cPi ) eulast ( 3 ) = mod ( eulast ( 3 ) + 1 0.D0 * cPi , 2.D0 * cPi ) eulast = eulast - sh do j = 1 , ns + 1 ro ( 1 : 3 ) = d * ro1 ( 1 : 3 ) + d * ( ro2 ( 1 : 3 ) - ro1 ( 1 : 3 )) * j * dx xx = dsqrt ( sum ( ro ( 1 : 3 ) ** 2 ) ) ro ( 1 : 3 ) = ro ( 1 : 3 ) / xx ro ( 4 ) = xx eu = ro2eu ( ro ) eu ( 1 ) = mod ( eu ( 1 ) + 1 0.D0 * cPi , 2.D0 * cPi ) eu ( 2 ) = mod ( eu ( 2 ) + 1 0.D0 * cPi , cPi ) eu ( 3 ) = mod ( eu ( 3 ) + 1 0.D0 * cPi , 2.D0 * cPi ) eu = eu - sh ! and create a cylinder with these points if ( maxval ( abs ( eulast - eu )). lt . cPi ) then call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 0.0 , 0.0 , 1.0 / )) end if eulast = eu end do end do if ( twostep ) then dx = 1.D0 / dble ( nt ) do i = 1 , dims ( 3 ) ro1 ( 1 : 3 ) = cpos ( 1 : 3 , t_edge ( 1 , i )) ro1 ( 4 ) = d ro2 ( 1 : 3 ) = cpos ( 1 : 3 , t_edge ( 2 , i )) ro2 ( 4 ) = d eulast = ro2eu ( ro1 ) eulast ( 1 ) = mod ( eulast ( 1 ) + 1 0.D0 * cPi , 2.D0 * cPi ) eulast ( 2 ) = mod ( eulast ( 2 ) + 1 0.D0 * cPi , cPi ) eulast ( 3 ) = mod ( eulast ( 3 ) + 1 0.D0 * cPi , 2.D0 * cPi ) eulast = eulast - sh do j = 1 , nt + 1 ro ( 1 : 3 ) = d * ro1 ( 1 : 3 ) + d * ( ro2 ( 1 : 3 ) - ro1 ( 1 : 3 )) * j * dx xx = dsqrt ( sum ( ro ( 1 : 3 ) ** 2 ) ) ro ( 1 : 3 ) = ro ( 1 : 3 ) / xx ro ( 4 ) = xx eu = ro2eu ( ro ) eu ( 1 ) = mod ( eu ( 1 ) + 1 0.D0 * cPi , 2.D0 * cPi ) eu ( 2 ) = mod ( eu ( 2 ) + 1 0.D0 * cPi , cPi ) eu ( 3 ) = mod ( eu ( 3 ) + 1 0.D0 * cPi , 2.D0 * cPi ) eu = eu - sh ! and create a cylinder with these points if ( maxval ( abs ( eulast - eu )). lt . cPi ) then call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) end if eulast = eu end do end do end if ! for the Euler representation of the Rodrigues fundamental zones we also need to draw ! a few additional lines to complete the volume appearance of the FZ; this depends on ! the order of the FZ, naturally, so we have a couple of possible cases... ! the diagonal lines in the Phi=0 plane are the most important lines; they should be drawn ! for all the rotation groups except for the identity if (( FZtype . ge . 1 ). and .( FZtype . le . 2 )) then if ( FZorder . ne . 0 ) then ! we have cyclic or dihedral xx = cPi / dble ( FZorder ) ! draw four diagonal lines eu ( 1 : 3 ) = ( / xx , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , 0.D0 , xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi - xx , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , 0.D0 , tpi - xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , xx / ) - sh eulast ( 1 : 3 ) = ( / xx , 0.D0 , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , tpi - xx / ) - sh eulast ( 1 : 3 ) = ( / tpi - xx , 0.D0 , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) ! for cyclic groups we also need to draw the diagonals in the top surface ! and the vertical lines connecting bottom and top planes if ( FZtype . eq . 1 ) then ! top plane eu ( 1 : 3 ) = ( / xx , cPi , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , cPi , xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi - xx , cPi , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , cPi , tpi - xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , cPi , xx / ) - sh eulast ( 1 : 3 ) = ( / xx , cPi , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , cPi , tpi - xx / ) - sh eulast ( 1 : 3 ) = ( / tpi - xx , cPi , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) ! verticals eu ( 1 : 3 ) = ( / xx , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / xx , cPi , 0.D0 / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / 0.D0 , 0.D0 , xx / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , cPi , xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi - xx , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / tpi - xx , cPi , 0.D0 / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / 0.D0 , 0.D0 , tpi - xx / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , cPi , tpi - xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , xx / ) - sh eulast ( 1 : 3 ) = ( / tpi , cPi , xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / xx , 0.D0 , tpi / ) - sh eulast ( 1 : 3 ) = ( / xx , cPi , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , tpi - xx / ) - sh eulast ( 1 : 3 ) = ( / tpi , cPi , tpi - xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi - xx , 0.D0 , tpi / ) - sh eulast ( 1 : 3 ) = ( / tpi - xx , cPi , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) end if if ( FZtype . eq . 2 ) then ! in this case, the verticals need to be drawn but only up to the level of the FZ surface eu ( 1 : 3 ) = ( / xx , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / xx , hPi , 0.D0 / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / 0.D0 , 0.D0 , xx / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , hPi , xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi - xx , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / tpi - xx , hPi , 0.D0 / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / 0.D0 , 0.D0 , tpi - xx / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , hPi , tpi - xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , xx / ) - sh eulast ( 1 : 3 ) = ( / tpi , hPi , xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / xx , 0.D0 , tpi / ) - sh eulast ( 1 : 3 ) = ( / xx , hPi , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , tpi - xx / ) - sh eulast ( 1 : 3 ) = ( / tpi , hPi , tpi - xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi - xx , 0.D0 , tpi / ) - sh eulast ( 1 : 3 ) = ( / tpi - xx , hPi , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) end if end if end if if ( FZtype . eq . 4 ) then xx = cPi / dble ( 4 ) ! draw four diagonal lines eu ( 1 : 3 ) = ( / xx , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , 0.D0 , xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi - xx , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , 0.D0 , tpi - xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , xx / ) - sh eulast ( 1 : 3 ) = ( / xx , 0.D0 , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , tpi - xx / ) - sh eulast ( 1 : 3 ) = ( / tpi - xx , 0.D0 , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) ! and verticals hPi = hPi * 0.5D0 eu ( 1 : 3 ) = ( / xx , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / xx , hPi , 0.D0 / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / 0.D0 , 0.D0 , xx / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , hPi , xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi - xx , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / tpi - xx , hPi , 0.D0 / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / 0.D0 , 0.D0 , tpi - xx / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , hPi , tpi - xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , xx / ) - sh eulast ( 1 : 3 ) = ( / tpi , hPi , xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / xx , 0.D0 , tpi / ) - sh eulast ( 1 : 3 ) = ( / xx , hPi , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , tpi - xx / ) - sh eulast ( 1 : 3 ) = ( / tpi , hPi , tpi - xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi - xx , 0.D0 , tpi / ) - sh eulast ( 1 : 3 ) = ( / tpi - xx , hPi , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) ! and the closing segments eu ( 1 : 3 ) = ( / xx , hPi , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , hPi , 0.D0 / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / 0.D0 , hPi , xx / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , hPi , 0.D0 / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi - xx , hPi , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / tpi , hPi , 0.D0 / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / 0.D0 , hPi , tpi - xx / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , hPi , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , hPi , xx / ) - sh eulast ( 1 : 3 ) = ( / tpi , hPi , 0.D0 / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / xx , hPi , tpi / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , hPi , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , hPi , tpi - xx / ) - sh eulast ( 1 : 3 ) = ( / tpi , hPi , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi - xx , hPi , tpi / ) - sh eulast ( 1 : 3 ) = ( / tpi , hPi , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) ! and finally the corner posts eu ( 1 : 3 ) = ( / 0.D0 , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / hPi , 0.D0 , 0.D0 / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / 0.D0 , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , hPi , 0.D0 / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / 0.D0 , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , 0.D0 , hPi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / tpi - hPi , 0.D0 , 0.D0 / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / tpi , hPi , 0.D0 / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / tpi , 0.D0 , hPi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , tpi / ) - sh eulast ( 1 : 3 ) = ( / tpi - hPi , 0.D0 , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , tpi / ) - sh eulast ( 1 : 3 ) = ( / tpi , hPi , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , tpi / ) - sh eulast ( 1 : 3 ) = ( / tpi , 0.D0 , tpi - hPi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / 0.D0 , 0.D0 , tpi / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 + hPi , 0.D0 , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / 0.D0 , 0.D0 , tpi / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , hPi , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / 0.D0 , 0.D0 , tpi / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , 0.D0 , tpi - hPi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) end if end if end subroutine PoVRay_drawFZ !-------------------------------------------------------------------------- ! ! SUBROUTINE: PoVRay_initFZ2 ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief initialize the PoVRay output for rotational group 2 ! !> @param dunit output unit number !> @param rmode  1(cubochoric)|2(homochoric)|3(stereographic)|4(Rodrigues) ! !> @date    09/09/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine PoVRay_initFZ2 ( dunit , rmode ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_initFZ2 IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit integer ( kind = irg ), INTENT ( IN ) :: rmode real ( kind = dbl ) :: eul ( 3 ), axang ( 4 ), rv ( 3 ), qu ( 4 ), h ( 3 ), rmax , dx , r , xmax , x , y , z , ho ( 3 ), cu ( 3 ), zsmall , & eyepos ( 3 ), ac , dpos ( 200 ), tmp real ( kind = dbl ) :: euld ( 3 ), om ( 3 , 3 ), ro1 ( 4 ), ro2 ( 4 ), culast ( 3 ), holast ( 3 ), ro ( 4 ), rolast ( 4 ), splast ( 3 ), sp ( 3 ), xx type ( orientationtype ) :: ot type ( orientationtyped ) :: otd integer ( kind = irg ) :: i , j , k , icnt , imax , nt , ns , h_edge ( 2 , 100 ) ! the parameter a represents infinity as tan(178°/2) real ( kind = dbl ) :: a = 57 0.289922125538D0 , b = 1.0D0 , c = 1.0D0 , cpos ( 3 , 200 ), dt = 11 4.57984425107713D0 , & ds = 2.0D0 , d = 1.7320508075688772D0 , dd , zz = 0.D0 , oo = 1.D0 , dtor = 0.017453292D0 ! define the coordinates of the monoclinic C2 (2) FZ in Rodrigues Space do i =- 12 , 12 if ( abs ( i ). ne . 12 ) then cpos ( 1 : 3 , 13 + i ) = ( / - a , dtan ( dble ( i ) * 1 5.D0 * dtor * 0.5D0 ) , c / ) else cpos ( 1 : 3 , 13 + i ) = ( / - a , a , c / ) if ( i . lt . 0 ) cpos ( 2 , 13 + i ) = - cpos ( 2 , 13 + i ) end if end do do i = 1 , 25 cpos ( 1 : 3 , 25 + i ) = cpos ( 1 : 3 , i ) cpos ( 1 , 25 + i ) = - cpos ( 1 , 25 + i ) end do do i = 1 , 50 cpos ( 1 : 3 , 50 + i ) = cpos ( 1 : 3 , i ) tmp = cpos ( 1 , 50 + i ) cpos ( 1 , 50 + i ) = cpos ( 2 , 50 + i ) cpos ( 2 , 50 + i ) = tmp end do do i = 1 , 100 cpos ( 1 : 3 , 100 + i ) = cpos ( 1 : 3 , i ) cpos ( 3 , 100 + i ) = - cpos ( 3 , 100 + i ) end do ! and normalize do i = 1 , 200 dpos ( i ) = dsqrt ( sum ( cpos ( 1 : 3 , i ) * cpos ( 1 : 3 , i ))) end do ns = 2000 dx = dt / float ( ns - 1 ) ! define the connectivity of all the edges do i = 1 , 25 h_edge ( 1 : 2 , i ) = ( / i , 25 + i / ) h_edge ( 1 : 2 , 25 + i ) = ( / 50 + i , 75 + i / ) h_edge ( 1 : 2 , 50 + i ) = ( / 100 + i , 125 + i / ) h_edge ( 1 : 2 , 75 + i ) = ( / 150 + i , 175 + i / ) end do ! first add the reference frame and any necessary wireframe diagrams if ( rmode . eq . 1 ) then ac = 0.5D0 * LPs % ap call PoVRay_addReferenceFrame ( dunit , ac ) call PoVRay_addCubochoricCube ( dunit ) end if if ( rmode . eq . 2 ) then ac = 1.33067D0 call PoVRay_addReferenceFrame ( dunit , ac ) call PoVRay_addWireFrameSphere ( dunit , ac ) end if if ( rmode . eq . 3 ) then ac = 1.0D0 call PoVRay_addReferenceFrame ( dunit , ac ) call PoVRay_addWireFrameSphere ( dunit , ac ) end if if ( rmode . eq . 4 ) then ac = 1.0D0 call PoVRay_addReferenceFrame ( dunit , ac ) end if if (( rmode . eq . 1 ). or .( rmode . eq . 2 )) then ! create the top and bottom planes first dx = 1.D0 / dble ( ns ) do i = 1 , 100 ro1 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 1 , i )) / dpos ( i ) ro1 ( 4 ) = dpos ( i ) ro2 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 2 , i )) / dpos ( i ) ro2 ( 4 ) = dpos ( i ) culast = ro2cu ( ro1 ) holast = ro2ho ( ro1 ) do j = 1 , ns + 1 ro ( 1 : 3 ) = dpos ( i ) * ro1 ( 1 : 3 ) + dpos ( i ) * ( ro2 ( 1 : 3 ) - ro1 ( 1 : 3 )) * j * dx xx = dsqrt ( sum ( ro ( 1 : 3 ) ** 2 ) ) ro ( 1 : 3 ) = ro ( 1 : 3 ) / xx ro ( 4 ) = xx cu = ro2cu ( ro ) ho = ro2ho ( ro ) ! and create a cylinder with these points if ( rmode . eq . 1 ) then call PoVRay_addCylinder ( dunit , culast ( 1 : 3 ), cu ( 1 : 3 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) else call PoVRay_addCylinder ( dunit , holast ( 1 : 3 ), ho ( 1 : 3 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) end if culast = cu holast = ho end do end do end if if (( rmode . eq . 3 ). or .( rmode . eq . 4 )) then ! create the square edges first dx = 1.D0 / dble ( ns ) do i = 1 , 100 ro1 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 1 , i )) / dpos ( i ) ro1 ( 4 ) = dpos ( i ) ro2 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 2 , i )) / dpos ( i ) ro2 ( 4 ) = dpos ( i ) rolast = ro1 qu = ro2qu ( ro1 ) splast ( 1 : 3 ) = qu ( 2 : 4 ) / ( 1.D0 + qu ( 1 )) do j = 1 , ns + 1 ro ( 1 : 3 ) = dpos ( i ) * ro1 ( 1 : 3 ) + dpos ( i ) * ( ro2 ( 1 : 3 ) - ro1 ( 1 : 3 )) * j * dx xx = dsqrt ( sum ( ro ( 1 : 3 ) ** 2 ) ) ro ( 1 : 3 ) = ro ( 1 : 3 ) / xx ro ( 4 ) = xx qu = ro2qu ( ro ) sp ( 1 : 3 ) = qu ( 2 : 4 ) / ( 1.D0 + qu ( 1 )) ! and create a cylinder with these points if ( rmode . eq . 3 ) then call PoVRay_addCylinder ( dunit , splast ( 1 : 3 ), sp ( 1 : 3 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) else call PoVRay_addCylinder ( dunit , rolast ( 1 : 3 ) * rolast ( 4 ), ro ( 1 : 3 ) * ro ( 4 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) end if rolast = ro splast = sp end do end do end if end subroutine PoVRay_initFZ2 !-------------------------------------------------------------------------- ! ! SUBROUTINE: PoVRay_initFZ3 ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief initialize the PoVRay output for rotational group 3 ! !> @param dunit output unit number !> @param rmode  1(cubochoric)|2(homochoric)|3(stereographic)|4(Rodrigues) ! !> @date    09/09/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine PoVRay_initFZ3 ( dunit , rmode ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_initFZ3 IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit integer ( kind = irg ), INTENT ( IN ) :: rmode real ( kind = dbl ) :: eul ( 3 ), axang ( 4 ), rv ( 3 ), qu ( 4 ), h ( 3 ), rmax , dx , r , xmax , x , y , z , ho ( 3 ), cu ( 3 ), zsmall , & eyepos ( 3 ), ac , dpos ( 208 ), tmp real ( kind = dbl ) :: euld ( 3 ), om ( 3 , 3 ), ro1 ( 4 ), ro2 ( 4 ), culast ( 3 ), holast ( 3 ), ro ( 4 ), rolast ( 4 ), splast ( 3 ), sp ( 3 ), xx type ( orientationtype ) :: ot type ( orientationtyped ) :: otd integer ( kind = irg ) :: i , j , k , icnt , imax , nt , ns , h_edge ( 2 , 104 ) ! the parameter a represents infinity as tan(178°/2) real ( kind = dbl ) :: a = 5 7.289922125538D0 , b = 1.0D0 , c = 0.577350269120D0 , cpos ( 3 , 208 ), dt = 11 4.57984425107713D0 , & ds = 2.0D0 , d = 1.7320508075688772D0 , dd , zz = 0.D0 , oo = 1.D0 , dtor = 0.017453292D0 , & c2 = 1.7320508075688767D0 ! define the coordinates of the trigonal C3 (3) FZ in Rodrigues Space do i =- 6 , 6 if ( abs ( i ). ne . 6 ) then cpos ( 1 : 3 , 7 + i ) = ( / - a , dtan ( dble ( i ) * 3 0.D0 * dtor * 0.5D0 ) , c / ) else cpos ( 1 : 3 , 7 + i ) = ( / - a , a , c / ) if ( i . lt . 0 ) cpos ( 2 , 7 + i ) = - cpos ( 2 , 7 + i ) end if end do do i = 1 , 13 cpos ( 1 : 3 , 13 + i ) = cpos ( 1 : 3 , i ) cpos ( 1 , 13 + i ) = - cpos ( 1 , 13 + i ) end do do i = 1 , 26 cpos ( 1 : 3 , 26 + i ) = cpos ( 1 : 3 , i ) tmp = cpos ( 1 , 26 + i ) cpos ( 1 , 26 + i ) = cpos ( 2 , 26 + i ) cpos ( 2 , 26 + i ) = tmp end do do i = 1 , 52 cpos ( 1 : 3 , 52 + i ) = cpos ( 1 : 3 , i ) cpos ( 3 , 52 + i ) = - cpos ( 3 , 52 + i ) end do do i = 1 , 104 cpos ( 1 : 3 , 104 + i ) = cpos ( 1 : 3 , i ) if ( cpos ( 3 , 104 + i ). lt . 0.D0 ) then cpos ( 3 , 104 + i ) = - c2 else cpos ( 3 , 104 + i ) = c2 end if end do ! and normalize do i = 1 , 208 dpos ( i ) = dsqrt ( sum ( cpos ( 1 : 3 , i ) * cpos ( 1 : 3 , i ))) end do ns = 200 dx = dt / float ( ns - 1 ) ! define the connectivity of all the edges do i = 1 , 13 h_edge ( 1 : 2 , i ) = ( / i , 13 + i / ) h_edge ( 1 : 2 , 13 + i ) = ( / 26 + i , 39 + i / ) h_edge ( 1 : 2 , 26 + i ) = ( / 52 + i , 65 + i / ) h_edge ( 1 : 2 , 39 + i ) = ( / 78 + i , 91 + i / ) h_edge ( 1 : 2 , 52 + i ) = ( / 104 + i , 117 + i / ) h_edge ( 1 : 2 , 65 + i ) = ( / 130 + i , 143 + i / ) h_edge ( 1 : 2 , 78 + i ) = ( / 156 + i , 169 + i / ) h_edge ( 1 : 2 , 91 + i ) = ( / 182 + i , 195 + i / ) end do ! first add the reference frame and any necessary wireframe diagrams if ( rmode . eq . 1 ) then ac = 0.5D0 * LPs % ap call PoVRay_addReferenceFrame ( dunit , ac ) call PoVRay_addCubochoricCube ( dunit ) end if if ( rmode . eq . 2 ) then ac = 1.33067D0 call PoVRay_addReferenceFrame ( dunit , ac ) call PoVRay_addWireFrameSphere ( dunit , ac ) end if if ( rmode . eq . 3 ) then ac = 1.0D0 call PoVRay_addReferenceFrame ( dunit , ac ) call PoVRay_addWireFrameSphere ( dunit , ac ) end if if ( rmode . eq . 4 ) then ac = 1.0D0 call PoVRay_addReferenceFrame ( dunit , ac ) end if if (( rmode . eq . 1 ). or .( rmode . eq . 2 )) then ! create the top and bottom planes first dx = 1.D0 / dble ( ns ) do i = 1 , 104 ro1 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 1 , i )) / dpos ( i ) ro1 ( 4 ) = dpos ( i ) ro2 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 2 , i )) / dpos ( i ) ro2 ( 4 ) = dpos ( i ) culast = ro2cu ( ro1 ) holast = ro2ho ( ro1 ) do j = 1 , ns + 1 ro ( 1 : 3 ) = dpos ( i ) * ro1 ( 1 : 3 ) + dpos ( i ) * ( ro2 ( 1 : 3 ) - ro1 ( 1 : 3 )) * j * dx xx = dsqrt ( sum ( ro ( 1 : 3 ) ** 2 ) ) ro ( 1 : 3 ) = ro ( 1 : 3 ) / xx ro ( 4 ) = xx cu = ro2cu ( ro ) ho = ro2ho ( ro ) ! and create a cylinder with these points if ( rmode . eq . 1 ) then call PoVRay_addCylinder ( dunit , culast ( 1 : 3 ), cu ( 1 : 3 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) else call PoVRay_addCylinder ( dunit , holast ( 1 : 3 ), ho ( 1 : 3 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) end if culast = cu holast = ho end do end do end if if (( rmode . eq . 3 ). or .( rmode . eq . 4 )) then ! create the square edges first dx = 1.D0 / dble ( ns ) do i = 1 , 104 ro1 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 1 , i )) / dpos ( i ) ro1 ( 4 ) = dpos ( i ) ro2 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 2 , i )) / dpos ( i ) ro2 ( 4 ) = dpos ( i ) rolast = ro1 qu = ro2qu ( ro1 ) splast ( 1 : 3 ) = qu ( 2 : 4 ) / ( 1.D0 + qu ( 1 )) do j = 1 , ns + 1 ro ( 1 : 3 ) = dpos ( i ) * ro1 ( 1 : 3 ) + dpos ( i ) * ( ro2 ( 1 : 3 ) - ro1 ( 1 : 3 )) * j * dx xx = dsqrt ( sum ( ro ( 1 : 3 ) ** 2 ) ) ro ( 1 : 3 ) = ro ( 1 : 3 ) / xx ro ( 4 ) = xx qu = ro2qu ( ro ) sp ( 1 : 3 ) = qu ( 2 : 4 ) / ( 1.D0 + qu ( 1 )) ! and create a cylinder with these points if ( rmode . eq . 3 ) then call PoVRay_addCylinder ( dunit , splast ( 1 : 3 ), sp ( 1 : 3 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) else call PoVRay_addCylinder ( dunit , rolast ( 1 : 3 ) * rolast ( 4 ), ro ( 1 : 3 ) * ro ( 4 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) end if rolast = ro splast = sp end do end do end if end subroutine PoVRay_initFZ3 !-------------------------------------------------------------------------- ! ! SUBROUTINE: PoVRay_initFZ4 ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief initialize the PoVRay output for rotational group 4 ! !> @param dunit output unit number !> @param rmode  1(cubochoric)|2(homochoric)|3(stereographic)|4(Rodrigues) ! !> @date    09/09/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine PoVRay_initFZ4 ( dunit , rmode ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_initFZ4 IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit integer ( kind = irg ), INTENT ( IN ) :: rmode real ( kind = dbl ) :: eul ( 3 ), axang ( 4 ), rv ( 3 ), qu ( 4 ), h ( 3 ), rmax , dx , r , xmax , x , y , z , ho ( 3 ), cu ( 3 ), zsmall , & eyepos ( 3 ), ac , dpos ( 104 ), tmp real ( kind = dbl ) :: euld ( 3 ), om ( 3 , 3 ), ro1 ( 4 ), ro2 ( 4 ), culast ( 3 ), holast ( 3 ), ro ( 4 ), rolast ( 4 ), splast ( 3 ), sp ( 3 ), xx type ( orientationtype ) :: ot type ( orientationtyped ) :: otd integer ( kind = irg ) :: i , j , k , icnt , imax , nt , ns , h_edge ( 2 , 52 ) ! the parameter a represents infinity as tan(178°/2) real ( kind = dbl ) :: a = 5 7.289922125538D0 , b = 1.0D0 , c = 1.0D0 , cpos ( 3 , 104 ), dt = 11 4.57984425107713D0 , & ds = 2.0D0 , d = 1.7320508075688772D0 , dd , zz = 0.D0 , oo = 1.D0 , dtor = 0.017453292D0 ! define the coordinates of the tetragonal C4 (4) FZ in Rodrigues Space do i =- 6 , 6 if ( abs ( i ). ne . 6 ) then cpos ( 1 : 3 , 7 + i ) = ( / - a , dtan ( dble ( i ) * 3 0.D0 * dtor * 0.5D0 ) , c / ) else cpos ( 1 : 3 , 7 + i ) = ( / - a , a , c / ) if ( i . lt . 0 ) cpos ( 2 , 7 + i ) = - cpos ( 2 , 7 + i ) end if end do do i = 1 , 13 cpos ( 1 : 3 , 13 + i ) = cpos ( 1 : 3 , i ) cpos ( 1 , 13 + i ) = - cpos ( 1 , 13 + i ) end do do i = 1 , 26 cpos ( 1 : 3 , 26 + i ) = cpos ( 1 : 3 , i ) tmp = cpos ( 1 , 26 + i ) cpos ( 1 , 26 + i ) = cpos ( 2 , 26 + i ) cpos ( 2 , 26 + i ) = tmp end do do i = 1 , 52 cpos ( 1 : 3 , 52 + i ) = cpos ( 1 : 3 , i ) cpos ( 3 , 52 + i ) = - cpos ( 3 , 52 + i ) end do ! and normalize do i = 1 , 104 dpos ( i ) = dsqrt ( sum ( cpos ( 1 : 3 , i ) * cpos ( 1 : 3 , i ))) end do ns = 200 dx = dt / float ( ns - 1 ) ! define the connectivity of all the edges do i = 1 , 13 h_edge ( 1 : 2 , i ) = ( / i , 13 + i / ) h_edge ( 1 : 2 , 13 + i ) = ( / 26 + i , 39 + i / ) h_edge ( 1 : 2 , 26 + i ) = ( / 52 + i , 65 + i / ) h_edge ( 1 : 2 , 39 + i ) = ( / 78 + i , 91 + i / ) end do ! first add the reference frame and any necessary wireframe diagrams if ( rmode . eq . 1 ) then ac = 0.5D0 * LPs % ap call PoVRay_addReferenceFrame ( dunit , ac ) call PoVRay_addCubochoricCube ( dunit ) end if if ( rmode . eq . 2 ) then ac = 1.33067D0 call PoVRay_addReferenceFrame ( dunit , ac ) call PoVRay_addWireFrameSphere ( dunit , ac ) end if if ( rmode . eq . 3 ) then ac = 1.0D0 call PoVRay_addReferenceFrame ( dunit , ac ) call PoVRay_addWireFrameSphere ( dunit , ac ) end if if ( rmode . eq . 4 ) then ac = 1.0D0 call PoVRay_addReferenceFrame ( dunit , ac ) end if if (( rmode . eq . 1 ). or .( rmode . eq . 2 )) then ! create the top and bottom planes first dx = 1.D0 / dble ( ns ) do i = 1 , 52 ro1 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 1 , i )) / dpos ( i ) ro1 ( 4 ) = dpos ( i ) ro2 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 2 , i )) / dpos ( i ) ro2 ( 4 ) = dpos ( i ) culast = ro2cu ( ro1 ) holast = ro2ho ( ro1 ) do j = 1 , ns + 1 ro ( 1 : 3 ) = dpos ( i ) * ro1 ( 1 : 3 ) + dpos ( i ) * ( ro2 ( 1 : 3 ) - ro1 ( 1 : 3 )) * j * dx xx = dsqrt ( sum ( ro ( 1 : 3 ) ** 2 ) ) ro ( 1 : 3 ) = ro ( 1 : 3 ) / xx ro ( 4 ) = xx cu = ro2cu ( ro ) ho = ro2ho ( ro ) ! and create a cylinder with these points if ( rmode . eq . 1 ) then call PoVRay_addCylinder ( dunit , culast ( 1 : 3 ), cu ( 1 : 3 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) else call PoVRay_addCylinder ( dunit , holast ( 1 : 3 ), ho ( 1 : 3 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) end if culast = cu holast = ho end do end do end if if (( rmode . eq . 3 ). or .( rmode . eq . 4 )) then ! create the square edges first dx = 1.D0 / dble ( ns ) do i = 1 , 52 ro1 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 1 , i )) / dpos ( i ) ro1 ( 4 ) = dpos ( i ) ro2 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 2 , i )) / dpos ( i ) ro2 ( 4 ) = dpos ( i ) rolast = ro1 qu = ro2qu ( ro1 ) splast ( 1 : 3 ) = qu ( 2 : 4 ) / ( 1.D0 + qu ( 1 )) do j = 1 , ns + 1 ro ( 1 : 3 ) = dpos ( i ) * ro1 ( 1 : 3 ) + dpos ( i ) * ( ro2 ( 1 : 3 ) - ro1 ( 1 : 3 )) * j * dx xx = dsqrt ( sum ( ro ( 1 : 3 ) ** 2 ) ) ro ( 1 : 3 ) = ro ( 1 : 3 ) / xx ro ( 4 ) = xx qu = ro2qu ( ro ) sp ( 1 : 3 ) = qu ( 2 : 4 ) / ( 1.D0 + qu ( 1 )) ! and create a cylinder with these points if ( rmode . eq . 3 ) then call PoVRay_addCylinder ( dunit , splast ( 1 : 3 ), sp ( 1 : 3 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) else call PoVRay_addCylinder ( dunit , rolast ( 1 : 3 ) * rolast ( 4 ), ro ( 1 : 3 ) * ro ( 4 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) end if rolast = ro splast = sp end do end do end if end subroutine PoVRay_initFZ4 !-------------------------------------------------------------------------- ! ! SUBROUTINE: PoVRay_initFZ6 ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief initialize the PoVRay output for rotational group 6 ! !> @param dunit output unit number !> @param rmode  1(cubochoric)|2(homochoric)|3(stereographic)|4(Rodrigues) ! !> @date    09/09/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine PoVRay_initFZ6 ( dunit , rmode ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_initFZ6 IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit integer ( kind = irg ), INTENT ( IN ) :: rmode real ( kind = dbl ) :: eul ( 3 ), axang ( 4 ), rv ( 3 ), qu ( 4 ), h ( 3 ), rmax , dx , r , xmax , x , y , z , ho ( 3 ), cu ( 3 ), zsmall , & eyepos ( 3 ), ac , dpos ( 104 ), tmp real ( kind = dbl ) :: euld ( 3 ), om ( 3 , 3 ), ro1 ( 4 ), ro2 ( 4 ), culast ( 3 ), holast ( 3 ), ro ( 4 ), rolast ( 4 ), splast ( 3 ), sp ( 3 ), xx type ( orientationtype ) :: ot type ( orientationtyped ) :: otd integer ( kind = irg ) :: i , j , k , icnt , imax , nt , ns , h_edge ( 2 , 52 ) ! the parameter a represents infinity as tan(178°/2) real ( kind = dbl ) :: a = 5 7.289922125538D0 , b = 1.0D0 , c = 1.0D0 , cpos ( 3 , 104 ), dt = 11 4.57984425107713D0 , & ds = 2.0D0 , d = 1.7320508075688772D0 , dd , zz = 0.D0 , oo = 1.D0 , dtor = 0.017453292D0 ! define the coordinates of the hexagonal C6 (6) FZ in Rodrigues Space do i =- 6 , 6 if ( abs ( i ). ne . 6 ) then cpos ( 1 : 3 , 7 + i ) = ( / - a , dtan ( dble ( i ) * 3 0.D0 * dtor * 0.5D0 ) , c / ) else cpos ( 1 : 3 , 7 + i ) = ( / - a , a , c / ) if ( i . lt . 0 ) cpos ( 2 , 7 + i ) = - cpos ( 2 , 7 + i ) end if end do do i = 1 , 13 cpos ( 1 : 3 , 13 + i ) = cpos ( 1 : 3 , i ) cpos ( 1 , 13 + i ) = - cpos ( 1 , 13 + i ) end do do i = 1 , 26 cpos ( 1 : 3 , 26 + i ) = cpos ( 1 : 3 , i ) tmp = cpos ( 1 , 26 + i ) cpos ( 1 , 26 + i ) = cpos ( 2 , 26 + i ) cpos ( 2 , 26 + i ) = tmp end do do i = 1 , 52 cpos ( 1 : 3 , 52 + i ) = cpos ( 1 : 3 , i ) cpos ( 3 , 52 + i ) = - cpos ( 3 , 52 + i ) end do ! and normalize do i = 1 , 104 dpos ( i ) = dsqrt ( sum ( cpos ( 1 : 3 , i ) * cpos ( 1 : 3 , i ))) end do ns = 200 dx = dt / float ( ns - 1 ) ! define the connectivity of all the edges do i = 1 , 13 h_edge ( 1 : 2 , i ) = ( / i , 13 + i / ) h_edge ( 1 : 2 , 13 + i ) = ( / 26 + i , 39 + i / ) h_edge ( 1 : 2 , 26 + i ) = ( / 52 + i , 65 + i / ) h_edge ( 1 : 2 , 39 + i ) = ( / 78 + i , 91 + i / ) end do ! first add the reference frame and any necessary wireframe diagrams if ( rmode . eq . 1 ) then ac = 0.5D0 * LPs % ap call PoVRay_addReferenceFrame ( dunit , ac ) call PoVRay_addCubochoricCube ( dunit ) end if if ( rmode . eq . 2 ) then ac = 1.33067D0 call PoVRay_addReferenceFrame ( dunit , ac ) call PoVRay_addWireFrameSphere ( dunit , ac ) end if if ( rmode . eq . 3 ) then ac = 1.0D0 call PoVRay_addReferenceFrame ( dunit , ac ) call PoVRay_addWireFrameSphere ( dunit , ac ) end if if ( rmode . eq . 4 ) then ac = 1.0D0 call PoVRay_addReferenceFrame ( dunit , ac ) end if if (( rmode . eq . 1 ). or .( rmode . eq . 2 )) then ! create the top and bottom planes first dx = 1.D0 / dble ( ns ) do i = 1 , 52 ro1 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 1 , i )) / dpos ( i ) ro1 ( 4 ) = dpos ( i ) ro2 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 2 , i )) / dpos ( i ) ro2 ( 4 ) = dpos ( i ) culast = ro2cu ( ro1 ) holast = ro2ho ( ro1 ) do j = 1 , ns + 1 ro ( 1 : 3 ) = dpos ( i ) * ro1 ( 1 : 3 ) + dpos ( i ) * ( ro2 ( 1 : 3 ) - ro1 ( 1 : 3 )) * j * dx xx = dsqrt ( sum ( ro ( 1 : 3 ) ** 2 ) ) ro ( 1 : 3 ) = ro ( 1 : 3 ) / xx ro ( 4 ) = xx cu = ro2cu ( ro ) ho = ro2ho ( ro ) ! and create a cylinder with these points if ( rmode . eq . 1 ) then call PoVRay_addCylinder ( dunit , culast ( 1 : 3 ), cu ( 1 : 3 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) else call PoVRay_addCylinder ( dunit , holast ( 1 : 3 ), ho ( 1 : 3 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) end if culast = cu holast = ho end do end do end if if (( rmode . eq . 3 ). or .( rmode . eq . 4 )) then ! create the square edges first dx = 1.D0 / dble ( ns ) do i = 1 , 52 ro1 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 1 , i )) / dpos ( i ) ro1 ( 4 ) = dpos ( i ) ro2 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 2 , i )) / dpos ( i ) ro2 ( 4 ) = dpos ( i ) rolast = ro1 qu = ro2qu ( ro1 ) splast ( 1 : 3 ) = qu ( 2 : 4 ) / ( 1.D0 + qu ( 1 )) do j = 1 , ns + 1 ro ( 1 : 3 ) = dpos ( i ) * ro1 ( 1 : 3 ) + dpos ( i ) * ( ro2 ( 1 : 3 ) - ro1 ( 1 : 3 )) * j * dx xx = dsqrt ( sum ( ro ( 1 : 3 ) ** 2 ) ) ro ( 1 : 3 ) = ro ( 1 : 3 ) / xx ro ( 4 ) = xx qu = ro2qu ( ro ) sp ( 1 : 3 ) = qu ( 2 : 4 ) / ( 1.D0 + qu ( 1 )) ! and create a cylinder with these points if ( rmode . eq . 3 ) then call PoVRay_addCylinder ( dunit , splast ( 1 : 3 ), sp ( 1 : 3 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) else call PoVRay_addCylinder ( dunit , rolast ( 1 : 3 ) * rolast ( 4 ), ro ( 1 : 3 ) * ro ( 4 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) end if rolast = ro splast = sp end do end do end if end subroutine PoVRay_initFZ6 end module povray","tags":"","loc":"sourcefile/povray.f90.html","title":"povray.f90 – Fortran Program"},{"text":"Modules rng Source Code rng.f90 Source Code module rng implicit none private public :: rng_t , rng_seed , rng_uniform ! Dimension of the state integer , parameter :: ns = 4 !DEC$ ATTRIBUTES DLLEXPORT :: ns ! Default seed vector integer , parameter , dimension ( ns ) :: default_seed = ( / 521288629 , 362436069 , 16163801 , 1131199299 / ) !DEC$ ATTRIBUTES DLLEXPORT :: default_seed ! A data type for storing the state of the RNG type :: rng_t integer , dimension ( ns ) :: state = default_seed end type rng_t contains ! Seeds the RNG using a single integer and a default seed vector. recursive subroutine rng_seed ( self , seed ) !DEC$ ATTRIBUTES DLLEXPORT :: rng_seed type ( rng_t ), intent ( inout ) :: self integer , intent ( in ) :: seed self % state ( 1 ) = seed self % state ( 2 : ns ) = default_seed ( 2 : ns ) end subroutine rng_seed ! Draws a uniform real number on [0,1]. recursive function rng_uniform ( self ) result ( u ) !DEC$ ATTRIBUTES DLLEXPORT :: rng_uniform type ( rng_t ), intent ( inout ) :: self real :: u integer :: imz imz = self % state ( 1 ) - self % state ( 3 ) if ( imz < 0 ) imz = imz + 2147483579 self % state ( 1 ) = self % state ( 2 ) self % state ( 2 ) = self % state ( 3 ) self % state ( 3 ) = imz self % state ( 4 ) = 69069 * self % state ( 4 ) + 1013904243 imz = imz + self % state ( 4 ) u = 0.5d0 + 0.23283064d-9 * imz end function rng_uniform end module rng","tags":"","loc":"sourcefile/rng.f90.html","title":"rng.f90 – Fortran Program"},{"text":"This File Depends On sourcefile~~simulated_annealing.f90~~EfferentGraph sourcefile~simulated_annealing.f90 simulated_annealing.f90 sourcefile~others.f90 others.f90 sourcefile~others.f90->sourcefile~simulated_annealing.f90 sourcefile~emdymod.f90 EMdymod.f90 sourcefile~emdymod.f90->sourcefile~simulated_annealing.f90 sourcefile~indexingmod.f90 Indexingmod.f90 sourcefile~indexingmod.f90->sourcefile~emdymod.f90 sourcefile~timing.f90 timing.f90 sourcefile~timing.f90->sourcefile~emdymod.f90 sourcefile~filters.f90 filters.f90 sourcefile~filters.f90->sourcefile~emdymod.f90 sourcefile~initializers.f90 initializers.f90 sourcefile~initializers.f90->sourcefile~emdymod.f90 sourcefile~multibeams.f90 multibeams.f90 sourcefile~multibeams.f90->sourcefile~emdymod.f90 sourcefile~clsupport.f90 CLsupport.f90 sourcefile~clsupport.f90->sourcefile~emdymod.f90 sourcefile~clsupport.f90->sourcefile~indexingmod.f90 sourcefile~namelisttypedefs.f90 NameListTypedefs.f90 sourcefile~namelisttypedefs.f90->sourcefile~emdymod.f90 sourcefile~namelisttypedefs.f90->sourcefile~indexingmod.f90 sourcefile~distortion.f90 distortion.f90 sourcefile~distortion.f90->sourcefile~emdymod.f90 sourcefile~constants.f90 constants.f90 sourcefile~constants.f90->sourcefile~emdymod.f90 sourcefile~constants.f90->sourcefile~filters.f90 sourcefile~constants.f90->sourcefile~initializers.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules SimAnn Source Code simulated_annealing.f90 Source Code !============================================================================================ !    DDFSA - A Distributed Derivative-free Simulated Annealing Method for !    bound constrained global optimization !    Copyright (C) 2011  G.Liuzzi, S.Lucidi, V.Piccialli ! !    This program is free software: you can redistribute it and/or modify !    it under the terms of the GNU General Public License as published by !    the Free Software Foundation, either version 3 of the License, or !    (at your option) any later version. ! !    This program is distributed in the hope that it will be useful, !    but WITHOUT ANY WARRANTY; without even the implied warranty of !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !    GNU General Public License for more details. ! !    You should have received a copy of the GNU General Public License !    along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !    G. Liuzzi, S. Lucidi, V. Piccialli, A. Sotgiu. A magnetic resonance device designed via !    global optimization techniques, Mathematical Programming, 101: 339-364 (2004) ! !============================================================================================ module SimAnn use local use others use EMdymod abstract interface recursive subroutine func ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt , accum_e , & mLPNH , mLPSH , n , x , f , verbose ) !! calfun interface use local implicit none integer ( 8 ), intent ( in ) :: ipar ( nipar ) real ( sgl ), intent ( inout ) :: fpar ( nfpar ) real ( sgl ), intent ( in ) :: initmeanval ( ninit ) integer ( irg ), intent ( in ) :: ninit integer ( irg ), intent ( in ) :: nipar integer ( irg ), intent ( in ) :: nfpar real ( sgl ), intent ( in ) :: expt ( ipar ( 2 ) * ipar ( 3 )) real ( sgl ), intent ( in ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( sgl ), intent ( in ) :: mLPNH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) real ( sgl ), intent ( in ) :: mLPSH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) integer ( irg ), intent ( in ) :: n real ( dbl ), dimension (:), intent ( in ) :: x real ( dbl ), intent ( out ) :: f logical , intent ( in ), optional :: verbose end subroutine func end interface contains recursive subroutine linesearchbox_cont ( n , x , f , d , alfa , alfa_d , z , fz , i_corr , num_fal ,& alfa_max , iprint , bl , bu , ipar , fparebsd , initmeanval , ninit ,& nipar , nfpar , expt , accum_e , mLPNH , mLPSH , verbose , calfun ) !      SUBROUTINE LINESEARCH_INVERTI(N,X,F,D,ALFA,DOLDALFA,Z,FZ, !     *I_CORR,NUM_FAL,DALFAMAX,IPRINT) implicit none integer :: n , i_corr , nf integer :: i , j integer :: ni , num_fal integer :: iprint , i_corr_fall integer :: ifront , ielle real * 8 :: x ( n ), d ( n ), alfa_d ( n ), z ( n ), bl ( n ), bu ( n ) real * 8 :: f , alfa , alfa_max , alfaex , fz , gamma , gamma_int real * 8 :: delta , delta1 , fpar , fzdelta integer ( 8 ), intent ( in ) :: ipar ( nipar ) real ( sgl ), intent ( inout ) :: fparebsd ( nfpar ) real ( sgl ), intent ( in ) :: initmeanval ( ninit ) integer ( irg ), intent ( in ) :: ninit integer ( irg ), intent ( in ) :: nipar integer ( irg ), intent ( in ) :: nfpar real ( sgl ), intent ( in ) :: expt ( ipar ( 2 ) * ipar ( 3 )) real ( sgl ), intent ( in ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( sgl ), intent ( in ) :: mLPNH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) real ( sgl ), intent ( in ) :: mLPSH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) logical , intent ( in ), optional :: verbose procedure ( func ) :: calfun COMMON / NUMNEW / NF gamma = 1.d-6 delta = 0.5d0 delta1 = 0.5d0 i_corr_fall = 0 ifront = 0 j = i_corr if ( iprint . ge . 1 ) then write ( * , * ) 'variabile continua  j =' , j , '    d(j) =' , d ( j ), ' alfa=' , alfa_d ( j ) write ( 1 , * ) 'variabile continua  j =' , j , '    d(j) =' , d ( j ), ' alfa=' , alfa_d ( j ) endif if ( dabs ( alfa_d ( j )). le . 1.d-3 * dmin1 ( 1.d0 , alfa_max )) then alfa = 0.d0 if ( iprint . ge . 1 ) then write ( * , * ) '  alfa piccolo' write ( 1 , * ) '  alfa piccolo' write ( * , * ) ' alfa_d(j)=' , alfa_d ( j ), '    alfamax=' , alfa_max write ( 1 , * ) ' alfa_d(j)=' , alfa_d ( j ), '    alfamax=' , alfa_max endif return endif do ielle = 1 , 2 if ( d ( j ). gt . 0.d0 ) then if (( alfa_d ( j ) - ( bu ( j ) - x ( j ))). lt .( - 1.d-6 )) then alfa = dmax1 ( 1.d-24 , alfa_d ( j )) else alfa = bu ( j ) - x ( j ) ifront = 1 if ( iprint . ge . 1 ) then write ( * , * ) ' punto espan. sulla front. *' write ( 1 , * ) ' punto espan. sulla front. *' endif endif else if (( alfa_d ( j ) - ( x ( j ) - bl ( j ))). lt .( - 1.d-6 )) then alfa = dmax1 ( 1.d-24 , alfa_d ( j )) else alfa = x ( j ) - bl ( j ) ifront = 1 if ( iprint . ge . 1 ) then write ( * , * ) ' punto espan. sulla front. *' write ( 1 , * ) ' punto espan. sulla front. *' endif endif endif if ( dabs ( alfa ). le . 1.d-3 * dmin1 ( 1.d0 , alfa_max )) then d ( j ) =- d ( j ) i_corr_fall = i_corr_fall + 1 ifront = 0 if ( iprint . ge . 1 ) then write ( * , * ) ' direzione opposta per alfa piccolo' write ( 1 , * ) ' direzione opposta per alfa piccolo' write ( * , * ) ' j =' , j , '    d(j) =' , d ( j ) write ( 1 , * ) ' j =' , j , '    d(j) =' , d ( j ) write ( * , * ) ' alfa=' , alfa , '    alfamax=' , alfa_max write ( 1 , * ) ' alfa=' , alfa , '    alfamax=' , alfa_max endif alfa = 0.d0 cycle endif alfaex = alfa z ( j ) = x ( j ) + alfa * d ( j ) !call funct(z,n,fz) call calfun ( nipar , nfpar , ninit , ipar , fparebsd , initmeanval , expt , accum_e , mLPNH , mLPSH , & n , z , fz , verbose ) nf = nf + 1 if ( iprint . ge . 1 ) then write ( * , * ) ' fz =' , fz , '   alfa =' , alfa write ( 1 , * ) ' fz =' , fz , '   alfa =' , alfa endif if ( iprint . ge . 2 ) then do i = 1 , n write ( * , * ) ' z(' , i , ')=' , z ( i ) write ( 1 , * ) ' z(' , i , ')=' , z ( i ) enddo endif fpar = f - gamma * alfa * alfa if ( fz . lt . fpar ) then do if (( ifront . eq . 1 )) then if ( iprint . ge . 1 ) then write ( * , * ) ' accetta punto sulla frontiera fz =' , fz , '   alfa =' , alfa write ( 1 , * ) ' accetta punto sulla frontiera fz =' , fz , '   alfa =' , alfa endif alfa_d ( j ) = delta * alfa return end if if ( d ( j ). gt . 0.d0 ) then if (( alfa / delta1 - ( bu ( j ) - x ( j ))). lt .( - 1.d-6 )) then alfaex = alfa / delta1 else alfaex = bu ( j ) - x ( j ) ifront = 1 if ( iprint . ge . 1 ) then write ( * , * ) ' punto espan. sulla front.' write ( 1 , * ) ' punto espan. sulla front.' endif end if else if (( alfa / delta1 - ( x ( j ) - bl ( j ))). lt .( - 1.d-6 )) then alfaex = alfa / delta1 else alfaex = x ( j ) - bl ( j ) ifront = 1 if ( iprint . ge . 1 ) then write ( * , * ) ' punto espan. sulla front.' write ( 1 , * ) ' punto espan. sulla front.' endif end if endif z ( j ) = x ( j ) + alfaex * d ( j ) !call funct(z,n,fzdelta) call calfun ( nipar , nfpar , ninit , ipar , fparebsd , initmeanval , expt , accum_e , mLPNH , mLPSH , & n , z , fzdelta , verbose ) nf = nf + 1 if ( iprint . ge . 1 ) then write ( * , * ) ' fzex=' , fzdelta , '  alfaex=' , alfaex write ( 1 , * ) ' fzex=' , fzdelta , '  alfaex=' , alfaex endif if ( iprint . ge . 2 ) then do i = 1 , n write ( * , * ) ' z(' , i , ')=' , z ( i ) write ( 1 , * ) ' z(' , i , ')=' , z ( i ) enddo endif fpar = f - gamma * alfaex * alfaex if ( fzdelta . lt . fpar ) then fz = fzdelta alfa = alfaex else alfa_d ( j ) = delta * alfa !\t\t\t\t\t alfa_d(j)=alfa if ( iprint . ge . 1 ) then write ( * , * ) ' accetta punto fz =' , fz , '   alfa =' , alfa write ( 1 , * ) ' accetta punto fz =' , fz , '   alfa =' , alfa endif return end if enddo else d ( j ) =- d ( j ) ifront = 0 if ( iprint . ge . 1 ) then write ( * , * ) ' direzione opposta' write ( 1 , * ) ' direzione opposta' write ( * , * ) ' j =' , j , '    d(j) =' , d ( j ) write ( 1 , * ) ' j =' , j , '    d(j) =' , d ( j ) endif endif enddo if ( i_corr_fall . eq . 2 ) then alfa_d ( j ) = alfa_d ( j ) else alfa_d ( j ) = delta * alfa_d ( j ) end if alfa = 0.d0 if ( iprint . ge . 1 ) then write ( * , * ) ' fallimento direzione' write ( 1 , * ) ' fallimento direzione' endif return end !PROGRAM MAIN_GLOB !\tINTEGER, PARAMETER\t:: TABELLA = 14 !\tINTEGER\t\t\t:: iok !\tINTEGER\t\t\t:: I, MYDATE(8) !\tINTEGER\t\t\t:: NF, NFAL, NFTOT, NFALTOT !\tINTEGER\t\t\t:: ICHECK !\tOPEN (TABELLA,FILE='risultato.tex',STATUS='REPLACE') !\tCALL DATE_AND_TIME(VALUES = MYDATE) !\tWRITE(TABELLA,1000) MYDATE(3),MYDATE(2),MYDATE(1) !\tCALL SENZADERGLOB(TABELLA,iok) ! !\tWRITE(TABELLA,1010) !\tCLOSE(TABELLA) !1020 FORMAT(I6,'  ',I3) !1010 FORMAT(//,'\\end{tabular}\t\t\t\t',/,& !'\\end{center}\t\t\t\t') !1000 FORMAT('\\begin{center}\\par\t\t\t\t\t\t\t',/,& !'{\\bf (',I2,'/',I2,'/',I4,')}\\par\t\t\t',/,& !'\\begin{tabular}{l|c||c|c|c|c|c|c}\t\t\t',/,& !'PROBLEM & n & nF & nFott & F. min & F. medio & F. min & F. medio\\\\ \\hline',///) !END PROGRAM SUBROUTINE SENZADERGLOB ( ipar , fparebsd , initmeanval , ninit , nipar , nfpar ,& expt , accum_e , mLPNH , mLPSH , verbose , calfun , N , XSUP , XINF ) !USE IMSLF90 use typedefs IMPLICIT NONE INTEGER , PARAMETER :: IRUNS = 10 PROCEDURE ( func ) :: calfun integer ( 8 ), intent ( in ) :: ipar ( nipar ) real ( sgl ), intent ( inout ) :: fparebsd ( nfpar ) real ( sgl ), intent ( in ) :: initmeanval ( ninit ) integer ( irg ), intent ( in ) :: ninit integer ( irg ), intent ( in ) :: nipar integer ( irg ), intent ( in ) :: nfpar real ( sgl ), intent ( in ) :: expt ( ipar ( 2 ) * ipar ( 3 )) real ( sgl ), intent ( in ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( sgl ), intent ( in ) :: mLPNH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) real ( sgl ), intent ( in ) :: mLPSH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) logical , intent ( in ), optional :: verbose DOUBLE PRECISION , INTENT ( IN ) :: XINF ( N ), XSUP ( N ) !\tINCLUDE 'TYPEDECL.FI' INTEGER :: N , NF , NFAILS , IDIMWKS , NUMFAL , IOTT , ISTOP INTEGER :: VECTNF ( IRUNS ), VECTNFOTT ( IRUNS ) INTEGER :: LSTOT , NFTOT , NPCTOT , NLMTOT , IT , IMAX INTEGER :: LS , NPC , NLM , ICONTFAL , IDFAL , NUMITER INTEGER :: NUMCAS , K , I , J , MAXLS , MODLS INTEGER :: MAXITER , MAXNF , PRINT_LEVEL , nfott , SUMNF INTEGER * 4 :: IVAR , IVAR2 TYPE ( COMP_WKS_TYP ), ALLOCATABLE :: WKS (:) DOUBLE PRECISION , ALLOCATABLE :: X (:), XOTT (:), DOLDALFA (:) DOUBLE PRECISION , ALLOCATABLE :: Z (:), VETT (:), XPROP (:), D (:) DOUBLE PRECISION , ALLOCATABLE :: RA (:), RB (:) INTEGER , ALLOCATABLE :: IPERM (:) DOUBLE PRECISION :: VECTFVAL ( IRUNS ), VECTF_OTT ( IRUNS ) DOUBLE PRECISION :: TOL , FMAX_EFF , fglob DOUBLE PRECISION :: RFAL , RNUMFAL , RMED , RMED2 , f_ott , FOTT , F , ALFAMAX , ALFAOTT DOUBLE PRECISION :: FPROP , VAR2 , VAR1 , ALFA , ZETA , TRES , DIFF DOUBLE PRECISION :: FSTOP , FSTOPTOL , FFSTOP DOUBLE PRECISION :: TEMPERATURA , SUMITER , SUMTIME DOUBLE PRECISION :: F_MIN , F_MIN1 , F_MAX , F_MINTOT , F_MINOTT , TCOEFF , FMIN , FMAX REAL :: RRAND LOGICAL :: L_F_DISTANTI , L_F_VICINI , NON_MINIMIZZ , SOLOSULPEGG , NORMADUE LOGICAL , ALLOCATABLE :: MASCH (:) CHARACTER ( LEN = 40 ) :: nomefun CHARACTER ( LEN = 2 ) :: CSTEP COMMON / NUMNEW2 / NF COMMON / CALFANR2 / NORMADUE NFOTT = 0 !\tCALL     NINIT(N) !\tCALL FUNCTINIT(N,XINF,XSUP,nomefun,fglob) fglob = 0.D0 !----------------------------------------------- !\tSETTA LE TOLLERANZE E I MASSIMI !----------------------------------------------- TOL = 1.0D-4 FSTOPTOL = 1.0D-15 MAXITER = 100000000 MAXNF = 1000 * n NUMFAL = 0 PRINT_LEVEL = 0 TCOEFF = 1.0D0 !-------------------------------------------------------- !\tmodificato il 23/9/2003 !-------------------------------------------------------- !\tIDIMWKS     = 20 !MIN(10*N,10) !\tIDIMWKS     = MAX(10,N) IDIMWKS = MIN ( 20 , MAX ( 10 , N )) !-------------------------------------------------------- SOLOSULPEGG = . FALSE . NORMADUE = . FALSE . !----------------------------------------------- ALLOCATE ( X ( N ), XOTT ( N ), Z ( N ), VETT ( N ), XPROP ( N )) ALLOCATE ( DOLDALFA ( N ), D ( N )) ALLOCATE ( RA ( IDIMWKS ), RB ( IDIMWKS ), IPERM ( IDIMWKS )) ! !\t------- !\t Iniz. !\t------- ! LSTOT = 0 NFTOT = 0 NFOTT = 0 NPCTOT = 0 NLMTOT = 0 CALL RANDOM_SEED () DO 171 IT = 1 , IRUNS ALLOCATE ( WKS ( IDIMWKS ), MASCH ( IDIMWKS )) DO I = 1 , IDIMWKS ALLOCATE ( WKS ( I )% X ( N )) ALLOCATE ( WKS ( I )% D ( N )) ALLOCATE ( WKS ( I )% DOLDALFA ( N )) ENDDO MASCH = . FALSE . LS = 0 NF = 0 NFOTT = 0 NPC = 0 NLM = 0 RFAL = 0.0D0 RNUMFAL = 0.0D0 ICONTFAL = 0 IDFAL = 0 NUMITER = 0 ivar = 2 * it + 3 * ( it + 7 ) ivar2 = 3 * it + 2 * ( it + 9 ) - 5 RMED = 0.D0 RMED2 = 0.D0 !\t------------------------------------- !\t  Generazione del campione originale !\t------------------------------------- FOTT = 1.D+32 !-------------------------------------------------------- !\tmodificato il 23/9/2003 !-------------------------------------------------------- NUMCAS = 30 !\t\tNUMCAS   = 1 !-------------------------------------------------------- IF ( PRINT_LEVEL >= 0 ) THEN WRITE ( * , 2070 ) WRITE ( * , 2080 ) WRITE ( 1 , 2070 ) WRITE ( 1 , 2080 ) ENDIF DO K = 1 , NUMCAS 3000 CONTINUE DO I = 1 , N CALL RANDOM_NUMBER ( RRAND ) VETT ( I ) = DBLE ( RRAND ) !RAN(IVAR2) !VETT(I)=RAN(IVAR2) XPROP ( I ) = XINF ( I ) + VETT ( I ) * ( XSUP ( I ) - XINF ( I )) ENDDO if ( K . eq . 1 ) then XPROP = 0.5D0 end if !CALL FUNCT(XPROP,N,FPROP) call calfun ( nipar , nfpar , ninit , ipar , fparebsd , initmeanval , expt , accum_e , mLPNH , mLPSH , & N , XPROP , FPROP , verbose ) NPC = NPC + 1 NF = NF + 1 RMED = (( NPC - 1.0D0 ) * RMED + FPROP ) / NPC IF ( NPC . LE . 2 ) THEN RMED2 = RMED2 + FPROP ** 2 ELSE RMED2 = (( NPC - 2. ) * RMED2 + FPROP ** 2 ) / ( NPC - 1.0D0 ) ENDIF IF ( FPROP . LT . FOTT ) THEN CALL AGGIORNO_OTTIMO ( N , XPROP , FPROP , XOTT , FOTT ) ENDIF IF ( PRINT_LEVEL >= 0 ) THEN WRITE ( * , 2130 ) NUMITER , NF , FPROP , '--' WRITE ( 1 , 2130 ) NUMITER , NF , FPROP , '--' ENDIF ENDDO IF ( PRINT_LEVEL >= 2 ) THEN write ( * , * ) 'fine generazione random iniziale nf = ' , nf write ( 1 , * ) 'fine generazione random iniziale nf = ' , nf ENDIF VAR2 = RMED2 - ( RMED ** 2 ) * ( NPC / ( NPC - 1. )) !--------------------------------------------------------- !\tRIEMPIO IL WKS DI IDIMWKS PUNTI !\tCHE SODDISFANO IL TEST DEL S.A. !--------------------------------------------------------- !\talfa     = 1.0d0 !\tDOLDALFA = ALFA DO I = 1 , N DOLDALFA ( I ) = 1.0D0 * DMAX1 ( 1.D-3 , DMIN1 ( 1.D+3 ,. 5 D0 * DABS ( XPROP ( I )))) !\t\tDOLDALFA(I)=1.D0 END DO D = 1.0D0 xprop = xott fprop = fott !\tfmax_eff = fott if ( print_level >= 2 ) then write ( * , * ) 'ricerca lungo assi' endif CALL RICERCA_LUNGO_ASSI ( N , XPROP , FPROP , ALFA , DOLDALFA , D , FSTOP , XINF , XSUP , Fmax_eff ,& ipar , fparebsd , initmeanval , ninit , nipar , nfpar , expt , accum_e , mLPNH , mLPSH , verbose , calfun ) if ( print_level >= 2 ) then write ( * , * ) 'fine ricerca lungo assi' endif WKS ( 1 )% X = XPROP WKS ( 1 )% FOB = FPROP WKS ( 1 )% ALFAMAX = ALFA WKS ( 1 )% DOLDALFA = DOLDALFA if ( DOT_PRODUCT ( DOLDALFA , DOLDALFA ) < 0.0d0 ) then write ( * , * ) '---- 1 ----' endif WKS ( 1 )% ALFANR2 = DSQRT ( DOT_PRODUCT ( DOLDALFA , DOLDALFA )) WKS ( 1 )% D = D WKS ( 1 )% FSTOP = FSTOP WKS ( 1 )% NUMCOST = 0 IF ( FPROP . LT . FOTT ) THEN CALL AGGIORNO_OTTIMO ( N , XPROP , FPROP , XOTT , FOTT ) ENDIF IF ( PRINT_LEVEL >= 0 ) THEN WRITE ( * , 2130 ) NUMITER , NF , FOTT , 'IN' WRITE ( 1 , 2130 ) NUMITER , NF , FOTT , 'IN' ENDIF DO I = 2 , IDIMWKS ZETA = 1.0D0 TRES = 0.0D0 DO WHILE ( ZETA . GT . TRES ) CALL RANDOM_NUMBER ( RRAND ) ZETA = DBLE ( RRAND ) !RAN(IVAR) !ZETA=RAN(IVAR) 3010 CONTINUE DO J = 1 , N CALL RANDOM_NUMBER ( RRAND ) VETT ( J ) = DBLE ( RRAND ) !RAN(IVAR2) !VETT(J)=RAN(IVAR2) XPROP ( J ) = XINF ( J ) + VETT ( J ) * ( XSUP ( J ) - XINF ( J )) ENDDO !CALL FUNCT(XPROP,N,FPROP) call calfun ( nipar , nfpar , ninit , ipar , fparebsd , initmeanval , expt , accum_e , mLPNH , mLPSH , & N , XPROP , FPROP , verbose ) NPC = NPC + 1 NF = NF + 1 RMED = (( NPC - 1. ) * RMED + FPROP ) / NPC RMED2 = (( NPC - 2. ) * RMED2 + FPROP ** 2 ) / ( NPC - 1. ) VAR2 = RMED2 - ( RMED ** 2 ) * ( NPC / ( NPC - 1. )) DIFF = RMED - FOTT TRES = DEXP ( - TCOEFF * ( RFAL / DIFF ) * ( FPROP - FOTT )) !-------------------------------------------------------- !\tmodificato il 23/9/2003 !-------------------------------------------------------- IF ( FPROP . LE . FOTT ) THEN TRES = 1.0D0 ENDIF !\t\t\tTRES = 1.0D0 !-------------------------------------------------------- ENDDO !\t\tDO J=1,N !\t\t\tDOLDALFA(J)=1.0D0*DMAX1(1.D-3,DMIN1(1.D+3,.5D0*DABS(XPROP(J)))) !\t\t\tDOLDALFA(J)=1.0D0 !\t\tEND DO ALFA = WKS ( 1 )% ALFAMAX DOLDALFA = WKS ( 1 )% DOLDALFA DO J = 2 , I - 1 IF ( ALFA . LT . WKS ( J )% ALFAMAX ) THEN ALFA = WKS ( J )% ALFAMAX DOLDALFA = WKS ( J )% DOLDALFA ENDIF ENDDO !\t\tDO K = 1,N !\t\t\tALFA=WKS(1)%DOLDALFA(K) !\t\t\tDO J = 2,I-1 !\t\t\t   IF(ALFA.LT.WKS(J)%DOLDALFA(K)) THEN !\t\t\t\t   ALFA      =  WKS(J)%DOLDALFA(K) !\t\t\t   ENDIF !\t\t\tENDDO !\t\t\tDOLDALFA(K) = ALFA !\t\tENDDO D = 1.0D0 !\t\tfmax_eff = fprop CALL RICERCA_LUNGO_ASSI ( N , Xprop , Fprop , ALFA , DOLDALFA , D , FSTOP , XINF , XSUP , Fmax_eff ,& ipar , fparebsd , initmeanval , ninit , nipar , nfpar , expt , accum_e , mLPNH , mLPSH , verbose , calfun ) WKS ( I )% X = XPROP WKS ( I )% FOB = FPROP WKS ( I )% ALFAMAX = ALFA WKS ( I )% DOLDALFA = DOLDALFA if ( DOT_PRODUCT ( DOLDALFA , DOLDALFA ) < 0.0d0 ) then write ( * , * ) '---- 2 ----' endif WKS ( I )% ALFANR2 = DSQRT ( DOT_PRODUCT ( DOLDALFA , DOLDALFA )) WKS ( I )% D = D WKS ( I )% FSTOP = FSTOP WKS ( I )% NUMCOST = 0 IF ( FPROP . LT . FOTT ) THEN CALL AGGIORNO_OTTIMO ( N , XPROP , FPROP , XOTT , FOTT ) ENDIF IF ( PRINT_LEVEL >= 0 ) THEN WRITE ( * , 2130 ) NUMITER , NF , FOTT , 'IN' WRITE ( 1 , 2130 ) NUMITER , NF , FOTT , 'IN' ENDIF ENDDO !-------------------------------------------------------- !\tmodificato il 23/9/2003 !-------------------------------------------------------- !\tOPEN(99,FILE='MIN_LOCALI.txt',STATUS='REPLACE') !\tDO I = 1,IDIMWKS !\t\tWRITE(99,*) WKS(I)%X !\t\tWRITE(99,*) 'FOB = ',WKS(I)%FOB !\t\tWRITE(99,*) '--------------------------------' !\tENDDO !\tCLOSE(99) !\tSTOP !-------------------------------------------------------- DO I = 1 , N X ( I ) = XOTT ( I ) ENDDO MAXLS = 100000000 MODLS = 1 !\t-------------------- !\t  Ciclo principale !\t-------------------- IF ( PRINT_LEVEL >= 0 ) THEN WRITE ( * , 2070 ) WRITE ( * , 2080 ) WRITE ( 1 , 2070 ) WRITE ( 1 , 2080 ) ENDIF 2070 FORMAT ( '    ITER      NFTOT       FOTT      SALTO       ALFA       FMIN        FMAX' ) 2080 FORMAT ( '-----------------------------------------------------------------------------' ) !              123456  123456789012  +1.2345E-02    OK     +1.2345E-02 +1.2345E-02 +1.2345E-02 2090 FORMAT ( 1 X , I6 , 2 X , I12 , 2 X , ES11 . 4 , 4 X , A2 , 5 X , ES11 . 4 , 1 X , ES11 . 4 , 1 X , ES11 . 4 ) 2130 FORMAT ( 1 X , I6 , 2 X , I12 , 2 X , ES11 . 4 , 4 X , A2 ) 100 FORMAT ( / , 1 X , ' GENERAZ.  N = ' , I9 , / ) 101 FORMAT ( / , 1 X , '  Attuale valore ottimo = ' , D13 . 6 , / ) 102 FORMAT ( 3 (:, 1 X , 'XOTT(' , I1 , ') =' , D13 . 6 , 1 X )) 109 FORMAT ( 3 (:, 1 X , 'XOTT(' , I2 , ') =' , D13 . 6 , 1 X )) 6 FORMAT ( / , 1 X , ' NF=' , I15 , 4 X , ' NPC=' , I7 , 4 X , ' NLM=' , I7 , 4 X , ' LS=' , I7 , / ) 96 FORMAT ( / , 1 X , '   MED = ' , D13 . 6 , '    VAR = ' , D13 . 6 , / ) CSTEP = '  ' 7 CONTINUE 8 CONTINUE !-------------------------------------- !\tstopping criterion !-------------------------------------- !\tcalcola il max tra gli alfamax !   o alfanr2 a seconda che normadue !\tsia falso o veroo !-------------------------------------- ALFA = 0.0D0 FSTOP = 0.0D0 FMIN = 1.0D+30 FMAX =- 1.0D+30 DO I = 1 , IDIMWKS IF (. NOT . MASCH ( I )) THEN IF ( WKS ( I )% FSTOP > FSTOP ) FSTOP = WKS ( I )% FSTOP IF ( NORMADUE ) THEN IF ( ALFA . LT . WKS ( I )% ALFANR2 ) THEN ALFA = WKS ( I )% ALFANR2 ENDIF ELSE IF ( ALFA . LT . WKS ( I )% ALFAMAX ) THEN ALFA = WKS ( I )% ALFAMAX ENDIF ENDIF !\t\t\tIF(WKS(I)%FOB > FMAX) FMAX = WKS(I)%FOB ENDIF IF ( WKS ( I )% FOB > FMAX ) FMAX = WKS ( I )% FOB IF ( WKS ( I )% FOB < FMIN ) THEN FMIN = WKS ( I )% FOB IF ( NORMADUE ) THEN ALFAOTT = WKS ( I )% ALFANR2 ELSE ALFAOTT = WKS ( I )% ALFAMAX ENDIF ENDIF ENDDO ALFAMAX = ALFA IF ( PRINT_LEVEL >= 1 ) THEN WRITE ( * , 2070 ) WRITE ( * , 2080 ) WRITE ( 1 , 2070 ) WRITE ( 1 , 2080 ) ENDIF IF ( PRINT_LEVEL >= 0 ) THEN WRITE ( * , 2090 ) NUMITER , NF , FOTT , CSTEP , ALFA , FMIN , FMAX WRITE ( 1 , 2090 ) NUMITER , NF , FOTT , CSTEP , ALFA , FMIN , FMAX ENDIF IF (( ALFAMAX <= TOL ). OR .( FSTOP <= FSTOPTOL ). OR . & (( FOTT - FGLOB ) / max ( 1.0d0 , abs ( fglob )) < tol )) THEN IF ( NFOTT == 0 ) THEN NFOTT = NF F_OTT = FOTT ENDIF ENDIF !IF(NF >= MAXNF) THEN IF (( ALFAMAX <= TOL ). OR .( FSTOP <= FSTOPTOL ). OR .( NUMITER >= MAXITER ). OR .( NF >= MAXNF )) THEN IF ( PRINT_LEVEL >= 0 ) THEN write ( * , * ) 'alfamax = ' , alfamax write ( 1 , * ) 'alfamax = ' , alfamax write ( * , * ) '  fstop = ' , fstop write ( 1 , * ) '  fstop = ' , fstop WRITE ( 1 , 100 ) NUMITER WRITE ( * , 100 ) NUMITER WRITE ( 1 , * ) FOTT WRITE ( * , * ) FOTT WRITE ( 1 , 101 ) FOTT WRITE ( * , 101 ) FOTT IF ( N . LT . 10 ) WRITE ( 1 , 102 ) ( J , XOTT ( J ), J = 1 , N ) IF ( N . LT . 10 ) WRITE ( * , 102 ) ( J , XOTT ( J ), J = 1 , N ) IF (( N . GT . 9 ). AND .( N . LT . 100 )) WRITE ( 1 , 109 ) ( J , XOTT ( J ), J = 1 , N ) IF (( N . GT . 9 ). AND .( N . LT . 100 )) WRITE ( * , 109 ) ( J , XOTT ( J ), J = 1 , N ) WRITE ( 1 , 6 ) NF , NPC , NLM , LS WRITE ( 6 , 6 ) NF , NPC , NLM , LS if ( var2 < 0.0d0 ) then write ( * , * ) '---- 3 ----' endif VAR1 = DSQRT ( VAR2 ) WRITE ( 6 , 96 ) RMED , VAR1 WRITE ( 1 , 96 ) RMED , VAR1 ENDIF GO TO 170 ENDIF !IF (FMIN /= FOTT) PAUSE IF ( PRINT_LEVEL >= 1 ) THEN WRITE ( * , * ) '/---------------------------------\\' WRITE(1,*)' /--------------------------------- \\ ' WRITE(*,*)' ALFAOTT = ',ALFAOTT,' FOTT = ',FOTT WRITE(1,*)' ALFAOTT = ',ALFAOTT,' FOTT = ',FOTT !\t\tWRITE(*,*) XOTT !\t\tWRITE(1,*) XOTT WRITE(*,*)' \\ ---------------------------------/ ' WRITE(1,*)' \\ ---------------------------------/ ' WRITE(*,*) WRITE(1,*) ENDIF !-------------------------------------- NUMITER = NUMITER + 1 IF(PRINT_LEVEL >= 0) THEN IF(MOD(NUMITER,30)==0) THEN WRITE(*,2070) WRITE(*,2080) WRITE(1,2070) WRITE(1,2080) ENDIF ENDIF !-------------------------------------- !\tgenera zeta random tra 0 e 1 !\te un punto xprop su cui calcolare !\tla f.ob. !-------------------------------------- CALL RANDOM_NUMBER(RRAND) ZETA=DBLE(RRAND) !RAN(IVAR) !ZETA=RAN(IVAR) 3020 CONTINUE DO I=1,N CALL RANDOM_NUMBER(RRAND) VETT(I)=DBLE(RRAND) !RAN(IVAR2) !VETT(I)=RAN(IVAR2) XPROP(I)=XINF(I)+VETT(I)*(XSUP(I)-XINF(I)) ENDDO !CALL FUNCT(XPROP,N,FPROP) call  calfun(nipar, nfpar, ninit, ipar, fparebsd, initmeanval, expt, accum_e, mLPNH, mLPSH, & N, XPROP, FPROP, verbose) NPC=NPC+1 NF=NF+1 103\tFORMAT(/,1X,' Proposta di salto ') 105\tFORMAT(/,1X,' Zeta = ',D13.6,' Tres = ',D13.6,/) !\t---------------------------- !\t  Calcolo media, varianza e !\t  la temperatura del SA !\t---------------------------- RMED  = ((NPC-1.)*RMED+FPROP)/NPC RMED2 = ((NPC-2.)*RMED2+FPROP**2)/(NPC-1.) VAR2  = RMED2-(RMED**2)*(NPC/(NPC-1.)) DIFF  = RMED-FOTT TRES  = DEXP(-TCOEFF*(RFAL/DIFF)*(FPROP-FOTT)) temperatura = diff/rfal IF(FPROP.LE.FOTT) TRES=1.0D0 !-------------------------------------- !\tse zeta e' minore o uguale a tres !\tallora accetta il punto e fa !\tpartire una min. locale !-------------------------------------- !\tIF(.FALSE.) THEN IF ( ZETA . LE . TRES ) THEN NUMFAL = 0 IF ( PRINT_LEVEL >= 2 ) THEN WRITE ( 1 , 405 ) WRITE ( * , 405 ) ENDIF 405 FORMAT ( 1 X , '    Proposta di salto accettata ' , / ) DO I = 1 , N X ( I ) = XPROP ( I ) ENDDO NLM = NLM + 1 !-------------------------------------- !\t\tcalcola l'indice imax della !\t\tcomponente di wks contenente !\t\til valore di fob piu' alto !-------------------------------------- FMAX =- 1.0D+30 DO I = 1 , IDIMWKS !\t\t\tIF((WKS(I)%FOB > FMAX)) THEN IF (( WKS ( I )% FOB > FMAX ) . AND . (. NOT . MASCH ( I ))) THEN FMAX = WKS ( I )% FOB IMAX = I ENDIF ENDDO ALFA = WKS ( 1 )% ALFAMAX FSTOP = WKS ( 1 )% FSTOP DO J = 2 , IDIMWKS IF ( FSTOP . LT . WKS ( J )% FSTOP ) FSTOP = WKS ( J )% FSTOP IF ( ALFA . LT . WKS ( J )% ALFAMAX ) THEN ALFA = WKS ( J )% ALFAMAX DOLDALFA = WKS ( J )% DOLDALFA ENDIF ENDDO !\t\tDO K = 1,N !\t\t\tALFA=WKS(1)%DOLDALFA(K) !\t\t\tDO J = 1,IDIMWKS !\t\t\t   IF(ALFA.LT.WKS(J)%DOLDALFA(K)) THEN !\t\t\t\t   ALFA      =  WKS(J)%DOLDALFA(K) !\t\t\t   ENDIF !\t\t\tENDDO !\t\t\tDOLDALFA(K) = ALFA !\t\tENDDO ALFA = ALFAMAX !\t\tIF(NORMADUE) THEN !\t\t\tALFA = WKS(IMAX)%ALFANR2 !\t\tELSETABELLA !\t\t\tALFA = WKS(IMAX)%ALFAMAX !\t\tENDIF CALL INTERFACCIA ( N , X , F , ALFA , DOLDALFA , D , FFSTOP , FSTOP , XINF , XSUP , FOTT , ALFAMAX , ALFAOTT , XOTT , WKS , IDIMWKS , ISTOP , MASCH , MAXNF , fglob ,& ipar , fparebsd , initmeanval , ninit , nipar , nfpar , expt , accum_e , mLPNH , mLPSH , verbose , calfun ) IF ( F . LT . FOTT ) THEN CALL AGGIORNO_OTTIMO ( N , X , F , XOTT , FOTT ) ISTOP = 1 ENDIF IF (( F . LT . WKS ( IMAX )% FOB ). AND .( ISTOP . NE . 2 )) THEN !-------------------------------------- !\t\t\tse la min. produce un punto !\t\t\tmigliore del peggiore !\t\t\tlo sostituisce !-------------------------------------- WKS ( IMAX )% X = X WKS ( IMAX )% FOB = F WKS ( IMAX )% ALFAMAX = ALFA WKS ( IMAX )% DOLDALFA = DOLDALFA WKS ( IMAX )% D = D WKS ( IMAX )% FSTOP = FFSTOP if ( DOT_PRODUCT ( DOLDALFA , DOLDALFA ) < 0.0d0 ) then write ( * , * ) '---- 4 ----' endif WKS ( IMAX )% ALFANR2 = DSQRT ( DOT_PRODUCT ( DOLDALFA , DOLDALFA )) WKS ( IMAX )% NUMCOST = 0 CSTEP = 'OK' MASCH ( IMAX ) = . FALSE . GO TO 7 ELSE !-------------------------------------- !\t\t\tnon accetta il punto !\t\t\tprodotto dalla minimizzazione !-------------------------------------- RNUMFAL = RNUMFAL + 1.0D0 ICONTFAL = ICONTFAL + 1 RFAL = RFAL + 1.0D0 / RNUMFAL IDFAL = 1 CSTEP = 'NO' ENDIF ELSE !-------------------------------------- !\taltrimenti (zeta > tres) scarta !\til punto proposto e aggiorna !\til cont. numfal !-------------------------------------- NUMFAL = NUMFAL + 1 !\t\tRNUMFAL  = RNUMFAL  + 1.0D0 !\t\tICONTFAL = ICONTFAL + 1 !\t\tRFAL     = RFAL     + 1.0D0/RNUMFAL !\t\tIDFAL    = 1 ENDIF !==================================================== !   QUI DEVO FARE UNA RICERCA LUNGO GLI ASSI !\tSU I PUNTI DEL WKS. !   SOLOSULPEGG = .TRUE.  --> LA FA SOLO SU QUELLO !\t\t\t\t\t\t \t  CON ALFA PEGGIORE !\t\t\t\t= .FALSE. --> LA FA SU TUTTI !==================================================== if (. NOT . SOLOSULPEGG ) then !fai la ricerca lungo gli assi per tutti !i punti dell'array IF ( NUMFAL >= 0 ) THEN NUMFAL = 0 FMAX_EFF =- 1.0D+30 DO J = 1 , IDIMWKS !\t\t\t\tIF(.NOT.MASCH(J)) THEN IF ( WKS ( J )% FOB > FMAX_EFF ) THEN FMAX_EFF = WKS ( J )% FOB ENDIF !\t\t\t\tENDIF IF ( WKS ( J )% FOB <= FOTT ) IOTT = J RA ( J ) = WKS ( J )% FOB IPERM ( J ) = J ENDDO !------------------------------------------------- ! ORDINO RA E RESTITUISCE RB ORDINATO ! IN IPERM CI SONO LE POSIZIONI DEGLI ELEMENTI ! DI RB IN RA !------------------------------------------------- call qsortd ( RA , IPERM , IDIMWKS ) DO I = 1 , IDIMWKS RB ( I ) = RA ( IPERM ( I )) ENDDO !CALL DSVRGP(IDIMWKS,RA,RB,IPERM) !\t\t\tMASCH = .FALSE. I = 1 J = 2 DO WHILE ( J <= IDIMWKS ) !CONFRONTO J,I --> MASCH IF (. NOT . MASCH ( IPERM ( J ))) THEN L_F_VICINI = ( DABS ( RB ( I ) - RB ( J )) / ( DMAX1 ( 1.D-8 , DABS ( RB ( J )) )) ). LE . 1.D-1 !\t\t\t\t\tL_F_VICINI = L_F_VICINI.AND.((DSQRT(\t\t\t\t\t\t\t\t\t\t\t\t\t& !\t\t\t\t\t\tDOT_PRODUCT(WKS(IPERM(I))%X-WKS(IPERM(J))%X,WKS(IPERM(I))%X-WKS(IPERM(J))%X)) <= 1.D-2)& !ERA 1.D-1 !\t\t\t\t\t\t.OR. (WKS(IPERM(J))%ALFAMAX.LE.1.D-1*WKS(IPERM(I))%ALFAMAX) ) L_F_VICINI = L_F_VICINI . AND .(( DSQRT ( & DOT_PRODUCT ( WKS ( IPERM ( I ))% X - WKS ( IPERM ( J ))% X , WKS ( IPERM ( I ))% X - WKS ( IPERM ( J ))% X )) <= 1.D-1 )) !\t\t\t\tMASCH(IPERM(J)) = MASCH(IPERM(J)).OR.L_F_VICINI IF ( L_F_VICINI ) THEN IF ( ( WKS ( IPERM ( J ))% ALFAMAX <= WKS ( IPERM ( I ))% ALFAMAX ) . OR . ( I == 1 ) ) THEN MASCH ( IPERM ( J )) = . TRUE . J = J + 1 ELSE MASCH ( IPERM ( I )) = . TRUE . I = J J = J + 1 ENDIF ELSE I = J J = J + 1 ENDIF ELSE J = J + 1 ENDIF ENDDO DO I = 1 , IDIMWKS IF ( NORMADUE ) THEN ALFA = WKS ( I )% ALFANR2 ELSE ALFA = WKS ( I )% ALFAMAX ENDIF DOLDALFA = WKS ( I )% DOLDALFA D = WKS ( I )% D X = WKS ( I )% X F = WKS ( I )% FOB IF ( I . NE . IOTT ) THEN RA ( I ) = ( F - FOTT ) / DMAX1 ( 1.D-3 , DMIN1 ( DABS ( F ), DABS ( FOTT )) ) RB ( I ) = DSQRT ( DOT_PRODUCT ( X - XOTT , X - XOTT )) L_F_DISTANTI = (( F - FOTT ) / DMAX1 ( 1.D-3 , DMIN1 ( DABS ( F ), DABS ( FOTT )) ) ). GE . 1.D+1 !\t\t\t\t\tL_F_DISTANTI = L_F_DISTANTI.AND.(ALFA <= 1.D-4) L_F_DISTANTI = L_F_DISTANTI . AND .( ALFA <= 1.D+1 * ALFAOTT ) L_F_VICINI = (( F - FOTT ) / DMAX1 ( 1.D-3 , DABS ( FOTT ) ) ). LE . 1.D-1 !\t\t\t\t\tL_F_VICINI = L_F_VICINI.AND.( (DSQRT(DOT_PRODUCT(X-XOTT,X-XOTT)) <= 1.D-1) & !\t\t\t\t\t\t\t\t.OR. (ALFA.LE.1.D-1*ALFAOTT)) L_F_VICINI = L_F_VICINI . AND .( ( DSQRT ( DOT_PRODUCT ( X - XOTT , X - XOTT )) <= 1.D-1 )) NON_MINIMIZZ = L_F_DISTANTI . OR . L_F_VICINI !\t\t\t\t\tNON_MINIMIZZ = L_F_DISTANTI.AND.(ALFA.LE.1.D-4) ELSE NON_MINIMIZZ = . FALSE . RA ( I ) = - 1.D0 RB ( I ) = - 1.D0 ENDIF MASCH ( I ) = MASCH ( I ) . OR . NON_MINIMIZZ !\t\t\tENDDO !-------------------------------------------- !\tapro il file per fare i controlli !\tsull'alfamax !-------------------------------------------- IF ( PRINT_LEVEL >= 1 ) THEN open ( 99 , FILE = 'alfamax.txt' , STATUS = 'REPLACE' ) DO J = 1 , IDIMWKS write ( 99 , 1999 ) J , wks ( J )% alfamax , wks ( J )% fob , masch ( J ), RA ( J ), RB ( J ) write ( * , 1999 ) J , wks ( J )% alfamax , wks ( J )% fob , masch ( J ), RA ( J ), RB ( J ) enddo 1999 format ( 1 x , i3 , 1 x , es18 . 10 , 1 x , es18 . 10 , 1 x , l1 , 1 x , es9 . 2 , 1 x , es9 . 2 ) !-------------------------------------------- !\tapro il file per fare i controlli !\tsull'alfamax !-------------------------------------------- close ( 99 ) !pause ENDIF !\t\t\tDO I = 1,IDIMWKS IF ( NORMADUE ) THEN ALFA = WKS ( I )% ALFANR2 ELSE ALFA = WKS ( I )% ALFAMAX ENDIF DOLDALFA = WKS ( I )% DOLDALFA D = WKS ( I )% D X = WKS ( I )% X F = WKS ( I )% FOB !\t\t\t\tIF(.TRUE.) THEN !\t\t\t\tIF(\t  (ALFA.GT.TOL).AND..NOT.MASCH(I)\t)\tTHEN !\t\t\t\tIF(\t  (ALFA.GT.TOL).AND..NOT.MASCH(I).AND. (ALFA.GT.1.D-3*ALFAMAX)\t)\tTHEN IF ( (( ALFA . GT . TOL ). AND .. NOT . MASCH ( I ). AND . ( ALFA . GT . 1.D-1 * ALFAMAX )). OR . & (( ALFA . GT . TOL ). AND .. NOT . MASCH ( I ). AND . ( I == IOTT ))) THEN MASCH ( I ) = . FALSE . !\t\t\t\t\tFMAX_EFF = F !\t\t\t\t\tWRITE(*,*)'X=',X !\t\t\t\t\tWRITE(*,*)'F=',F CALL RICERCA_LUNGO_ASSI ( N , X , F , ALFA , DOLDALFA , D , FSTOP , XINF , XSUP , FMAX_EFF ,& ipar , fparebsd , initmeanval , ninit , nipar , nfpar , expt , accum_e , mLPNH , mLPSH , verbose , calfun ) if ( f > fmax_eff ) then write ( * , * ) '---> 1 <--- diff = ' , f - fmax_eff !\t\t\t\t\t\tpause endif !\t\t\t\t\tWRITE(*,*)'X=',X !\t\t\t\t\tWRITE(*,*)'F=',F WKS ( I )% X = X WKS ( I )% FOB = F !\t\t\t\t\tPAUSE !IF(WKS(I)%ALFAMAX > ALFA) THEN !\tWRITE(*,*) '\\/\\/\\/\\/\\/ ',F,' \\/\\/\\/\\/\\/\\ ',FMAX_EFF !/\\/\\/\\/\\/', I !ENDIF IF ( ALFA >= WKS ( I )% ALFAMAX ) THEN WKS ( I )% NUMCOST = WKS ( I )% NUMCOST + 1 ELSE WKS ( I )% NUMCOST = 0 ENDIF WKS ( I )% ALFAMAX = ALFA WKS ( I )% DOLDALFA = DOLDALFA WKS ( I )% D = D WKS ( I )% FSTOP = FSTOP if ( DOT_PRODUCT ( DOLDALFA , DOLDALFA ) < 0.0d0 ) then write ( * , * ) '---- 5 ----' endif WKS ( I )% ALFANR2 = DSQRT ( DOT_PRODUCT ( DOLDALFA , DOLDALFA )) IF ( F . LT . FOTT ) THEN CALL AGGIORNO_OTTIMO ( N , X , F , XOTT , FOTT ) ENDIF IF ( WKS ( I )% NUMCOST <= - 1 ) THEN DO WHILE ( ALFA >= WKS ( I )% ALFAMAX ) CALL RICERCA_LUNGO_ASSI ( N , X , F , ALFA , DOLDALFA , D , FSTOP , XINF , XSUP , FMAX_EFF ,& ipar , fparebsd , initmeanval , ninit , nipar , nfpar , expt , accum_e , mLPNH , mLPSH , verbose , calfun ) if ( f > fmax_eff ) then write ( * , * ) '---> 2 <---' !\t\t\t\t\t\t\t\tpause endif WKS ( I )% X = X WKS ( I )% FOB = F WKS ( I )% ALFAMAX = ALFA WKS ( I )% DOLDALFA = DOLDALFA WKS ( I )% D = D WKS ( I )% FSTOP = FSTOP if ( DOT_PRODUCT ( DOLDALFA , DOLDALFA ) < 0.0d0 ) then write ( * , * ) '---- 6 ----' endif WKS ( I )% ALFANR2 = DSQRT ( DOT_PRODUCT ( DOLDALFA , DOLDALFA )) WRITE ( * , * ) ALFA , F ENDDO WKS ( I )% NUMCOST = 0 ENDIF ELSE IF (. FALSE .) THEN !\t\t\t\t\tIF(NON_MINIMIZZ) THEN IF ( PRINT_LEVEL >= 10 ) THEN WRITE ( 1 , * ) 'SOSTITUISCO IL PUNTO ' , I ENDIF CALL GENERA_PUNTO_SA ( N , XPROP , FPROP , XINF , XSUP , FOTT , TCOEFF , IVAR , IVAR2 , & VAR2 , RMED , RMED2 , NLM , NUMFAL , RFAL , RNUMFAL , ICONTFAL , IDFAL , NPC , NF ,& ipar , fparebsd , initmeanval , ninit , nipar , nfpar , expt , accum_e , mLPNH , mLPSH , verbose ,& calfun ) ALFA = 0.0D0 FSTOP = 0.0D0 DO J = 1 , IDIMWKS IF (. NOT . MASCH ( J )) THEN IF ( WKS ( J )% FSTOP > FSTOP ) FSTOP = WKS ( J )% FSTOP IF ( NORMADUE ) THEN IF ( ALFA . LT . WKS ( J )% ALFANR2 ) THEN ALFA = WKS ( J )% ALFANR2 ENDIF ELSE IF ( ALFA . LT . WKS ( J )% ALFAMAX ) THEN ALFA = WKS ( J )% ALFAMAX ENDIF ENDIF ENDIF ENDDO !\t\t\t\t\t\tALFAMAX = ALFA ALFA = ALFAMAX CALL INTERFACCIA ( N , XPROP , FPROP , ALFA , DOLDALFA , D , FFSTOP , FSTOP , XINF , & XSUP , FOTT , ALFAMAX , ALFAOTT , XOTT , WKS , IDIMWKS , ISTOP , MASCH , MAXNF , fglob ,& ipar , fparebsd , initmeanval , ninit , nipar , nfpar , expt , accum_e , mLPNH , mLPSH , verbose ,& calfun ) WKS ( I )% X = XPROP WKS ( I )% FOB = FPROP WKS ( I )% ALFAMAX = ALFA WKS ( I )% DOLDALFA = DOLDALFA WKS ( I )% D = D WKS ( I )% FSTOP = FFSTOP if ( DOT_PRODUCT ( DOLDALFA , DOLDALFA ) < 0.0d0 ) then write ( * , * ) '---- 7 ----' endif WKS ( I )% ALFANR2 = DSQRT ( DOT_PRODUCT ( DOLDALFA , DOLDALFA )) IF ( FPROP . LT . FOTT ) THEN CALL AGGIORNO_OTTIMO ( N , XPROP , FPROP , XOTT , FOTT ) ENDIF MASCH ( I ) = . FALSE . ELSE MASCH ( I ) = . TRUE . ENDIF ENDIF ENDDO ENDIF else !fai la ricerca lungo gli assi solo per !il punto con l'alfa maggiore ALFA = 0.0D0 FMIN = 1.0D+30 FMAX =- 1.0D+30 DO I = 1 , IDIMWKS IF (. NOT . MASCH ( I )) THEN IF ( NORMADUE ) THEN IF ( ALFA . LT . WKS ( I )% ALFANR2 ) THEN ALFA = WKS ( I )% ALFANR2 DOLDALFA = WKS ( I )% DOLDALFA IMAX = I ENDIF ELSE IF ( ALFA . LT . WKS ( I )% ALFAMAX ) THEN ALFA = WKS ( I )% ALFAMAX DOLDALFA = WKS ( I )% DOLDALFA IMAX = I ENDIF ENDIF IF ( WKS ( I )% FOB < FMIN ) FMIN = WKS ( I )% FOB IF ( WKS ( I )% FOB > FMAX ) FMAX = WKS ( I )% FOB ENDIF ENDDO D = WKS ( IMAX )% D X = WKS ( IMAX )% X F = WKS ( IMAX )% FOB CALL RICERCA_LUNGO_ASSI ( N , X , F , ALFA , DOLDALFA , D , FSTOP , XINF , XSUP , FMAX_EFF ,& ipar , fparebsd , initmeanval , ninit , nipar , nfpar , expt , accum_e , mLPNH , mLPSH , verbose , calfun ) if ( f > fmax_eff ) then write ( * , * ) '---> 3 <---' !\t\t\tpause endif WKS ( IMAX )% X = X WKS ( IMAX )% FOB = F WKS ( IMAX )% ALFAMAX = ALFA WKS ( IMAX )% DOLDALFA = DOLDALFA WKS ( IMAX )% D = D WKS ( IMAX )% FSTOP = FSTOP if ( DOT_PRODUCT ( DOLDALFA , DOLDALFA ) < 0.0d0 ) then write ( * , * ) '---- 8 ----' endif WKS ( IMAX )% ALFANR2 = DSQRT ( DOT_PRODUCT ( DOLDALFA , DOLDALFA )) IF ( F . LT . FOTT ) THEN CALL AGGIORNO_OTTIMO ( N , X , F , XOTT , FOTT ) ENDIF endif IF ( CSTEP . NE . 'NO' ) CSTEP = 'KO' GO TO 8 170 CONTINUE IF ( NFOTT == 0 ) THEN NFOTT = NF F_OTT = FOTT ENDIF LSTOT = LSTOT + LS NFTOT = NFTOT + NF NPCTOT = NPCTOT + NPC NLMTOT = NLMTOT + NLM VECTNF ( IT ) = NF VECTFVAL ( IT ) = FOTT VECTNFOTT ( IT ) = NFOTT VECTF_OTT ( IT ) = F_OTT DO I = 1 , IDIMWKS DEALLOCATE ( WKS ( I )% X ) DEALLOCATE ( WKS ( I )% DOLDALFA ) DEALLOCATE ( WKS ( I )% D ) ENDDO DEALLOCATE ( WKS , MASCH ) 171 CONTINUE sumiter = 0.D0 ; sumnf = 0 ; sumtime = 0.0D0 f_min1 = 1.D+30 f_minott = 0.D0 f_min = 1.D+30 f_mintot = 0.D0 f_max = - 1.D+30 DO IT = 1 , Iruns SUMNF = SUMNF + VECTNFOTT ( IT ) f_mintot = f_mintot + vectfVAL ( IT ) f_minott = f_minott + vectf_ott ( IT ) IF ( f_min . GT . vectfVAL ( IT )) f_min = vectfVAL ( IT ) IF ( f_min1 . GT . vectf_ott ( IT )) f_min1 = vectf_ott ( IT ) IF ( f_max . LT . vectfVAL ( IT )) f_max = vectfVAL ( IT ) END DO !write(TABELLA,2030) nomefun, n, NFTOT/IRUNS, SUMNF/IRUNS F_MINTOT = F_MINTOT / IRUNS F_MINOTT = F_MINOTT / IRUNS !IF (DABS(F_MIN).LT.1.D-3) THEN !\t\tWRITE(TABELLA,2110) F_MIN !\tELSE !\t\tWRITE(TABELLA,2100) F_MIN !\tENDIF !\tIF (DABS(F_MINTOT).LT.1.D-3) THEN !\t\tWRITE(TABELLA,2110) F_MINTOT !\tELSE !\t\tWRITE(TABELLA,2100) F_MINTOT !\tENDIF !\tIF (DABS(F_MIN1).LT.1.D-3) THEN !\t\tWRITE(TABELLA,2110) F_MIN1 !\tELSE !\t\tWRITE(TABELLA,2100) F_MIN1 !\tENDIF !\tIF (DABS(F_MINOTT).LT.1.D-3) THEN !\t\tWRITE(TABELLA,2110) F_MINOTT !\tELSE !\t\tWRITE(TABELLA,2100) F_MINOTT !\tENDIF !\tWRITE(TABELLA,2110) (F_MINOTT-fglob)/max(1.0d0,abs(fglob)) ! !if((F_MINOTT-fglob)/max(1.0d0,abs(fglob))<1.d-4) then !\t\tiok = 1 !\telse !\t\tiok = 0 !\tendif NFAILS = 0 DO IT = 1 , IRUNS IF ( DABS ( VECTFVAL ( IT ) - F_MIN ). GT . 1.0d-2 ) NFAILS = NFAILS + 1 ENDDO !WRITE(TABELLA,2120) NFAILS !\tWRITE(TABELLA,2180) !\tDEALLOCATE(XINF,XSUP) DEALLOCATE ( X , XOTT , Z , VETT , XPROP , DOLDALFA , D ) DEALLOCATE ( RA , RB , IPERM ) 2100 FORMAT ( ' & ' , ES12 . 5 , $ ) 2110 FORMAT ( ' & ' , D10 . 3 , $ ) 2030 FORMAT ( A40 , ' & ' , I2 , ' & ' , I6 , ' & ' , I6 , $ ) !2100 FORMAT(' & ',F13.4,$) !2110 FORMAT(' & ',D9.3,$) 2120 FORMAT ( ' & ' , I4 , '\\\\' ) 2180 FORMAT ( ' \\\\ ' ) 2140 FORMAT ( I3 , '  ' , $ ) 2150 FORMAT ( ES11 . 4 , '  ' , $ ) 2160 FORMAT ( I6 , '  ' , $ ) 2170 FORMAT ( I6 , '  ' , I3 ) 691 FORMAT ( / , 1 X , ' NFTOT=' , I7 , 4 X , ' NPCTOT=' , I7 , 4 X , ' NLMTOT=' , I7 , 4 X , ' LSTOT=' , I7 , / ) END SUBROUTINE SENZADERGLOB !============================================================================================== !============================================================================================== !============================================================================================== SUBROUTINE AGGIORNO_OTTIMO ( N , XPROP , FPROP , XOTT , FOTT ) IMPLICIT NONE INTEGER , INTENT ( IN ) :: N DOUBLE PRECISION , INTENT ( IN ) :: XPROP ( N ), FPROP DOUBLE PRECISION , INTENT ( OUT ) :: XOTT ( N ), FOTT INTEGER :: I XOTT = XPROP FOTT = FPROP RETURN OPEN ( 99 , FILE = 'OttimoCorrente.txt' , STATUS = 'REPLACE' ) DO I = 1 , N WRITE ( 99 , 1000 ) I , XOTT ( I ) ENDDO WRITE ( 99 , 1010 ) FOTT CLOSE ( 99 ) 1000 FORMAT ( 1 X , 'XOTT(' , I3 , ') = ' , ES11 . 4 ) 1010 FORMAT ( 1 X , 'FOTT      = ' , ES11 . 4 ) RETURN END SUBROUTINE AGGIORNO_OTTIMO !============================================================================================== !============================================================================================== !============================================================================================== SUBROUTINE RICERCA_LUNGO_ASSI ( N , X , FF , ALFA , DOLDALFA , D , FFSTOP , XINF , XSUP , FMAX_EFF , ipar , fparebsd ,& initmeanval , ninit , nipar , nfpar , expt , accum_e , mLPNH , mLPSH , verbose , calfun ) IMPLICIT NONE INTEGER N , NN , nf INTEGER I , J , IDIR_CORR , NUM_FUNCT , NUM_ITER , NUM_NOTFAL ( N ) INTEGER MAX_NOTFAL , NUM_FAL , ISTOP INTEGER IPUNT , NUM_PARAM INTEGER IPRINT INTEGER ENV , LINK PROCEDURE ( func ) calfun integer ( 8 ), intent ( in ) :: ipar ( nipar ) real ( sgl ), intent ( inout ) :: fparebsd ( nfpar ) real ( sgl ), intent ( in ) :: initmeanval ( ninit ) integer ( irg ), intent ( in ) :: ninit integer ( irg ), intent ( in ) :: nipar integer ( irg ), intent ( in ) :: nfpar real ( sgl ), intent ( in ) :: expt ( ipar ( 2 ) * ipar ( 3 )) real ( sgl ), intent ( in ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( sgl ), intent ( in ) :: mLPNH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) real ( sgl ), intent ( in ) :: mLPSH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) logical , intent ( in ), optional :: verbose REAL * 8 FMAX_EFF REAL * 8 X ( N ), DIREZIONI ( N ), Z ( N ), Z1 ( N ), D ( N ), XOLD ( N ) REAL * 8 GAMMA , RHO , ALFA , F , FF , FZ , FTAR , F0 , DSTOP , FFSTOP REAL * 8 DOLDALFA ( N ), DCONV ( N ), FINIT ( N , 2 ) REAL * 8 FSTOP ( N + 1 ), XFSTOP ( N , N + 1 ), XINF ( N ), XSUP ( N ), ALFA_MIN ( N ) COMMON / NUM / F COMMON / NUMNEW2 / NUM_FUNCT COMMON / NUMNEW / NF F = FF IPRINT =- 1 !call funct(x,n,ff) call calfun ( nipar , nfpar , ninit , ipar , fparebsd , initmeanval , expt , accum_e , mLPNH , mLPSH , & n , x , ff , verbose ) !\twrite(*,*) '/--------------------------------------\\' !\twrite(*,*) 'ric.assi: ff = ',ff,' f = ',f !\tCALL MAINBOX1(N,X,D,DIREZIONI,Z,Z1,XOLD,NUM_ITER,DOLDALFA,IPRINT,DCONV,FSTOP,XFSTOP,FINIT,XINF,XSUP,ALFA_MIN,FFSTOP,FMAX_EFF) CALL MAINBOX1 ( N , X , D , DIREZIONI , Z , Z1 , XOLD , NUM_ITER , DOLDALFA , IPRINT , DCONV , FSTOP , XFSTOP , FINIT , FFSTOP , XINF , XSUP ,& ipar , fparebsd , initmeanval , ninit , nipar , nfpar , expt , accum_e , mLPNH , mLPSH , verbose , calfun ) ALFA = MAXVAL ( DOLDALFA ) num_funct = num_funct + nf !\tcall funct(x,n,ff) call calfun ( nipar , nfpar , ninit , ipar , fparebsd , initmeanval , expt , accum_e , mLPNH , mLPSH , & n , x , ff , verbose ) if ( f . ne . ff ) then write ( * , * ) 'ric.assi: ff = ' , ff , ' f = ' , f write ( * , * ) x write ( * , * ) '\\--------------------------------------/' !\t\tpause endif FF = F RETURN END SUBROUTINE RICERCA_LUNGO_ASSI !============================================================================================== !============================================================================================== !============================================================================================== SUBROUTINE INTERFACCIA ( N , X , FF , ALFA , DOLDALFA , D , FFSTOP , FFSTOPTOL , XINF , XSUP , FOTT , ALFAMAX , ALFAOTT , & XOTT , WKS , IDIMWKS , ISTOP , MASCH , MAXNF , fglob , ipar , fparebsd , initmeanval , ninit ,& nipar , nfpar , expt , accum_e , mLPNH , mLPSH , verbose , calfun ) use typedefs IMPLICIT NONE !\tINCLUDE 'TYPEDECL.FI' INTEGER N , NN , nf INTEGER I , J , IDIR_CORR , NUM_FUNCT , NUM_ITER , NUM_NOTFAL ( N ), IDIMWKS , MAXNF INTEGER MAX_NOTFAL , NUM_FAL , ISTOP INTEGER IPUNT , NUM_PARAM INTEGER IPRINT INTEGER ENV , LINK integer ( 8 ), intent ( in ) :: ipar ( nipar ) real ( sgl ), intent ( inout ) :: fparebsd ( nfpar ) real ( sgl ), intent ( in ) :: initmeanval ( ninit ) integer ( irg ), intent ( in ) :: ninit integer ( irg ), intent ( in ) :: nipar integer ( irg ), intent ( in ) :: nfpar real ( sgl ), intent ( in ) :: expt ( ipar ( 2 ) * ipar ( 3 )) real ( sgl ), intent ( in ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( sgl ), intent ( in ) :: mLPNH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) real ( sgl ), intent ( in ) :: mLPSH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) logical , intent ( in ), optional :: verbose procedure ( func ) :: calfun REAL * 8 X ( N ), DIREZIONI ( N ), Z ( N ), Z1 ( N ), D ( N ), XOLD ( N ), XOTT ( N ), fglob REAL * 8 GAMMA , RHO , ALFA , F , FF , FZ , FTAR , F0 , DSTOP , ALFAOTT REAL * 8 FFSTOP , FFSTOPTOL , FOTT , ALFAMAX REAL * 8 DOLDALFA ( N ), DCONV ( N ), FINIT ( N , 2 ) REAL * 8 FSTOP ( N + 1 ), XFSTOP ( N , N + 1 ), XINF ( N ), XSUP ( N ), ALFA_MIN ( N ) TYPE ( COMP_WKS_TYP ) :: WKS ( IDIMWKS ) LOGICAL MASCH ( IDIMWKS ) COMMON / NUM / F COMMON / NUMNEW2 / NUM_FUNCT COMMON / NUMNEW / NF F = FF IPRINT =- 1 !\tCALL MAINBOX2(N,X,D,DIREZIONI,Z,Z1,XOLD,NUM_ITER,DOLDALFA,ALFA,IPRINT,DCONV,FSTOP,XFSTOP,FINIT,XINF,XSUP,ALFA_MIN,FFSTOP,FFSTOPTOL,FOTT,ALFAMAX) CALL MAINBOX2 ( N , X , D , DIREZIONI , Z , Z1 , XOLD , NUM_ITER , DOLDALFA , ALFA , IPRINT , DCONV , FSTOP , XFSTOP , FINIT , FFSTOP , FFSTOPTOL ,& FOTT , ALFAOTT , XOTT , WKS , IDIMWKS , ISTOP , MASCH , MAXNF , fglob , XINF , XSUP ,& ipar , fparebsd , initmeanval , ninit , nipar , nfpar , expt , accum_e , mLPNH , mLPSH , verbose , calfun ) ALFA = MAXVAL ( DOLDALFA ) num_funct = num_funct + nf !call funct(x,n,ff) call calfun ( nipar , nfpar , ninit , ipar , fparebsd , initmeanval , expt , accum_e , mLPNH , mLPSH , & n , x , ff , verbose ) !\twrite(*,*) 'ric.alfa: ff = ',ff,' f = ',f FF = F IPRINT =- 1 IF ( IPRINT >= 1 ) THEN WRITE ( * , * ) X ENDIF RETURN END SUBROUTINE INTERFACCIA !============================================================================================== !============================================================================================== !============================================================================================== SUBROUTINE GENERA_PUNTO_SA ( N , XPROP , FPROP , XINF , XSUP , FOTT , TCOEFF , IVAR , IVAR2 , & VAR2 , RMED , RMED2 , NLM , NUMFAL , RFAL , RNUMFAL , ICONTFAL , IDFAL , NPC , NF ,& ipar , fparebsd , initmeanval , ninit , nipar , nfpar , expt , accum_e , mLPNH ,& mLPSH , verbose , calfun ) IMPLICIT NONE INTEGER :: N , NLM , NUMFAL , ICONTFAL , IDFAL INTEGER :: NPC , NF INTEGER * 4 :: IVAR , IVAR2 DOUBLE PRECISION :: XPROP ( N ), XINF ( N ), XSUP ( N ), FPROP , FOTT , TCOEFF DOUBLE PRECISION :: VAR2 , RMED , RMED2 , RFAL , RNUMFAL DOUBLE PRECISION :: ZETA , TRES , DIFF DOUBLE PRECISION :: VETT ( N ) LOGICAL :: TROVATO INTEGER :: I REAL :: RRAND PROCEDURE ( func ) :: calfun integer ( 8 ), intent ( in ) :: ipar ( nipar ) real ( sgl ), intent ( inout ) :: fparebsd ( nfpar ) real ( sgl ), intent ( in ) :: initmeanval ( ninit ) integer ( irg ), intent ( in ) :: ninit integer ( irg ), intent ( in ) :: nipar integer ( irg ), intent ( in ) :: nfpar real ( sgl ), intent ( in ) :: expt ( ipar ( 2 ) * ipar ( 3 )) real ( sgl ), intent ( in ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( sgl ), intent ( in ) :: mLPNH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) real ( sgl ), intent ( in ) :: mLPSH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) logical , intent ( in ), optional :: verbose TROVATO = . FALSE . DO WHILE (. NOT . TROVATO ) CALL RANDOM_NUMBER ( RRAND ) ZETA = DBLE ( RRAND ) !RAN(IVAR) !ZETA=RAN(IVAR) 100 CONTINUE DO I = 1 , N CALL RANDOM_NUMBER ( RRAND ) VETT ( I ) = DBLE ( RRAND ) !RAN(IVAR2) !VETT(I)=RAN(IVAR2) XPROP ( I ) = XINF ( I ) + VETT ( I ) * ( XSUP ( I ) - XINF ( I )) ENDDO call calfun ( nipar , nfpar , ninit , ipar , fparebsd , initmeanval , expt , accum_e , mLPNH , mLPSH , & N , XPROP , FPROP , verbose ) NPC = NPC + 1 NF = NF + 1 !\t---------------------------- !\t  Calcolo media e varianza !\t---------------------------- RMED = (( NPC - 1. ) * RMED + FPROP ) / NPC RMED2 = (( NPC - 2. ) * RMED2 + FPROP ** 2 ) / ( NPC - 1. ) VAR2 = RMED2 - ( RMED ** 2 ) * ( NPC / ( NPC - 1. )) DIFF = RMED - FOTT TRES = DEXP ( - TCOEFF * ( RFAL / DIFF ) * ( FPROP - FOTT )) IF ( FPROP . LE . FOTT ) TRES = 1. IF ( ZETA . LE . TRES ) THEN NUMFAL = 0 NLM = NLM + 1 TROVATO = . TRUE . ELSE NUMFAL = NUMFAL + 1 RNUMFAL = RNUMFAL + 1. ICONTFAL = ICONTFAL + 1 RFAL = RFAL + 1. / RNUMFAL IDFAL = 1 ENDIF ENDDO RETURN END SUBROUTINE GENERA_PUNTO_SA !============================================================================================ !    DDFSA - A Distributed Derivative-free Simulated Annealing Method for !    bound constrained global optimization !    Copyright (C) 2011  G.Liuzzi, S.Lucidi, V.Piccialli ! !    This program is free software: you can redistribute it and/or modify !    it under the terms of the GNU General Public License as published by !    the Free Software Foundation, either version 3 of the License, or !    (at your option) any later version. ! !    This program is distributed in the hope that it will be useful, !    but WITHOUT ANY WARRANTY; without even the implied warranty of !    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !    GNU General Public License for more details. ! !    You should have received a copy of the GNU General Public License !    along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !    G. Liuzzi, S. Lucidi, V. Piccialli, A. Sotgiu. A magnetic resonance device designed via !    global optimization techniques, Mathematical Programming, 101: 339-364 (2004) ! !============================================================================================ !************************************************************ !* !*********************************************************** SUBROUTINE MAINBOX1 ( N , X , D , D1 , Z , Z1 , XOLD , NUM_ITER ,& DOLDALFA , IPRINT , DCONV , FSTOP , XFSTOP , FINIT , FFSTOP , BL , BU ,& ipar , fparebsd , initmeanval , ninit , nipar , nfpar , expt , accum_e ,& mLPNH , mLPSH , verbose , calfun ) IMPLICIT NONE INTEGER N , I , J , I_CORR , NUM_FUNCT , NUM_ITER INTEGER NUM_FAL , NUM_SUCC , ISTOP INTEGER IPRINT INTEGER IMIN , IMAX , IMINALFA , IMAXALFA REAL * 8 DCONV ( N ), DNR , FFM REAL * 8 X ( N ), Z ( N ), Z1 ( N ), D ( N ), D1 ( N ), XOLD ( N ) REAL * 8 DOLDALFA ( N ), ALFA , BL ( N ), BU ( N ) REAL * 8 F , FZ REAL * 8 DOLDALFAMEDIO , DALFAMAX REAL * 8 FMIN , FMAX , ALFA0 , DOLDALFAMIN , DOLDALFAMAX REAL * 8 RAPALFA , FINIT ( N , 2 ) integer ( 8 ), intent ( in ) :: ipar ( nipar ) real ( sgl ), intent ( inout ) :: fparebsd ( nfpar ) real ( sgl ), intent ( in ) :: initmeanval ( ninit ) integer ( irg ), intent ( in ) :: ninit integer ( irg ), intent ( in ) :: nipar integer ( irg ), intent ( in ) :: nfpar real ( sgl ), intent ( in ) :: expt ( ipar ( 2 ) * ipar ( 3 )) real ( sgl ), intent ( in ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( sgl ), intent ( in ) :: mLPNH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) real ( sgl ), intent ( in ) :: mLPSH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) logical , intent ( in ), optional :: verbose procedure ( func ) :: calfun !     VETTORE DEI VALORI DI F SUI PUNTI DI UN SIMPLESSO N+1 DIM. REAL * 8 FSTOP ( N + 1 ), XFSTOP ( N , N + 1 ), FFSTOP , FMM !    num_fal rappresenta il numero di fallimenti consecutivi !     i_corr rappresenta l'indice della direzione corrente COMMON / NUM / F COMMON / NUMNEW / NUM_FUNCT !     inizializzazione NUM_SUCC = 0 NUM_FUNCT = 0 NUM_ITER = 0 NUM_FAL = 0 ISTOP = 0 I_CORR = 1 ALFA0 = 1.D0 DO I = 1 , N ! IF ( IPRINT . GE . 2 ) THEN WRITE ( * , * ) ' ALFAiniz(' , I , ')=' , DOLDALFA ( I ) WRITE ( 1 , * ) ' ALFAiniz(' , I , ')=' , DOLDALFA ( I ) ENDIF ! END DO !     scelta iniziale delle direzioni !CALL FUNCT(X,N,F) call calfun ( nipar , nfpar , ninit , ipar , fparebsd , initmeanval , expt , accum_e , mLPNH , mLPSH , & N , X , F , verbose ) !\tWRITE(*,*)'MAINBOX1: ',X,F !\tWRITE(1,*)'MAINBOX1: ',X,F NUM_FUNCT = NUM_FUNCT + 1 FSTOP ( 1 ) = F DO I = 1 , N XFSTOP ( I , 1 ) = X ( I ) Z ( I ) = X ( I ) END DO IF ( IPRINT . GE . 2 ) THEN WRITE ( * , * ) ' ----------------------------------' WRITE ( 1 , * ) ' ----------------------------------' WRITE ( * , * ) ' Finiz =' , F WRITE ( 1 , * ) ' Finiz =' , F DO I = 1 , N WRITE ( * , * ) ' Xiniz(' , I , ')=' , X ( I ) WRITE ( 1 , * ) ' Xiniz(' , I , ')=' , X ( I ) ENDDO ENDIF NUM_FAL = 0 !--------------------------- !     CICLO PRINCIPALE !--------------------------- 1 CONTINUE IF ( I_CORR . EQ . 1 ) THEN DO I = 1 , N DCONV ( I ) =- D ( I ) END DO ENDIF ISTOP = 0 DALFAMAX = MAXVAL ( DOLDALFA ) IF ( IPRINT . GE . 1 ) THEN WRITE ( * , * ) '----------------------------------------------' WRITE ( 1 , * ) '----------------------------------------------' WRITE ( * , * ) 'NF=' , NUM_FUNCT , '   F=' , F , '   ALFAmax=' , DALFAMAX WRITE ( 1 , * ) 'NF=' , NUM_FUNCT , '   F=' , F , '   ALFAmax=' , DALFAMAX ENDIF IF ( ISTOP . EQ . 1 ) THEN !        WRITE(2,50)'&',N,'&',NUM_FUNCT,'&',F,'\\\\' 50 FORMAT ( 1 X , a3 , i5 , a3 , i5 , a3 , d13 . 5 , a6 ) !        WRITE(*,*) '----------------------------------------------' !        WRITE(1,*) '----------------------------------------------' !        WRITE(*,*) 'NF=',NUM_FUNCT,'   F=',F,'   ALFAmax=',DALFAMAX !        WRITE(1,*) 'NF=',NUM_FUNCT,'   F=',F,'   ALFAmax=',DALFAMAX RETURN END IF !------------------------------------- !    CAMPIONAMENTO LUNGO ASSE I_CORR !------------------------------------- !      CALL LINESEARCH_INVERTI(N,X,F,D,ALFA,DOLDALFA,Z,FZ, !     *I_CORR,NUM_FAL,DALFAMAX,IPRINT) CALL linesearchbox_cont ( n , x , f , d , alfa , doldalfa , z , fz ,& i_corr , num_fal , dalfamax , iprint , bl , bu ,& ipar , fparebsd , initmeanval , ninit , nipar , nfpar , expt , accum_e , mLPNH , mLPSH , verbose , calfun ) IF ( DABS ( ALFA ). GE . 1.D-24 ) THEN X ( I_CORR ) = X ( I_CORR ) + ALFA * D ( I_CORR ) Z ( I_CORR ) = X ( I_CORR ) F = FZ DO I = N + 1 , 2 , - 1 FSTOP ( I ) = FSTOP ( I - 1 ) DO J = 1 , N XFSTOP ( J , I ) = XFSTOP ( J , I - 1 ) END DO ENDDO FSTOP ( 1 ) = F DO J = 1 , N XFSTOP ( J , 1 ) = X ( J ) END DO NUM_FAL = 0 NUM_ITER = NUM_ITER + 1 NUM_SUCC = NUM_SUCC + 1 IF ( IPRINT . GE . 1 ) THEN WRITE ( * , * ) ' F =' , F WRITE ( 1 , * ) ' F =' , F ENDIF IF ( IPRINT . GE . 2 ) THEN DO I = 1 , N WRITE ( * , * ) ' X(' , I , ')=' , X ( I ) WRITE ( 1 , * ) ' X(' , I , ')=' , X ( I ) ENDDO ENDIF ELSE DO I = N + 1 , 2 , - 1 FSTOP ( I ) = FSTOP ( I - 1 ) DO J = 1 , N XFSTOP ( J , I ) = XFSTOP ( J , I - 1 ) END DO ENDDO FSTOP ( 1 ) = FZ DO J = 1 , N XFSTOP ( J , 1 ) = Z ( J ) END DO NUM_FAL = NUM_FAL + 1 NUM_ITER = NUM_ITER + 1 Z ( I_CORR ) = X ( I_CORR ) END IF IF ( I_CORR . LT . N ) THEN I_CORR = I_CORR + 1 ELSE I_CORR = 1 ISTOP = 1 IF ( ISTOP . EQ . 1 ) THEN !             WRITE(2,50)'&',N,'&',NUM_FUNCT,'&',F,'\\\\' !             WRITE(*,*) '----------------------------------------------' !             WRITE(1,*) '----------------------------------------------' !             WRITE(*,*) 'NF=',NUM_FUNCT,'   F=',F,'   ALFAmax=',DALFAMAX !             WRITE(1,*) 'NF=',NUM_FUNCT,'   F=',F,'   ALFAmax=',DALFAMAX FFM = 0.D0 DO I = 1 , N + 1 FFM = FFM + FSTOP ( I ) ENDDO FFM = FFM / DFLOAT (( N + 1 )) FFSTOP = 0.D0 DO I = 1 , N + 1 FFSTOP = FFSTOP + ( FSTOP ( I ) - FFM ) * ( FSTOP ( I ) - FFM ) ENDDO !\twrite(*,*) ' ffstop =',ffstop,  ' dfloat =',dfloat(n+1),' ffm =',ffm FFSTOP = DSQRT ( FFSTOP / DFLOAT ( N + 1 )) RETURN END IF END IF GO TO 1 END !************************************************************ !* !*********************************************************** SUBROUTINE MAINBOX2 ( N , X , D , D1 , Z , Z1 , XOLD , NUM_ITER , DOLDALFA ,& ALFA_STOP , IPRINT , DCONV , FSTOP , XFSTOP , FINIT , FFSTOP ,& FFSTOPTOL , FOTT , ALFAOTT , XOTT , WKS , IDIMWKS , ISTOP , MASCH , MAXNF , fglob , BL , BU ,& ipar , fparebsd , initmeanval , ninit , nipar , nfpar , expt , accum_e ,& mLPNH , mLPSH , verbose , calfun ) use typedefs IMPLICIT NONE !\tINCLUDE 'TYPEDECL.FI' INTEGER N , I , J , I_CORR , NUM_FUNCT , NUM_ITER , IDIMWKS , MAXNF INTEGER NUM_FAL , NUM_SUCC , ISTOP INTEGER IPRINT INTEGER IMIN , IMAX , IMINALFA , IMAXALFA REAL * 8 DCONV ( N ), DNR , ALFA_STOP , fglob , BL ( N ), BU ( N ) REAL * 8 X ( N ), Z ( N ), Z1 ( N ), D ( N ), D1 ( N ), XOLD ( N ), XOTT ( N ) REAL * 8 DOLDALFA ( N ), ALFA , FOTT , ALFAOTT REAL * 8 F , FZ REAL * 8 DOLDALFAMEDIO , DALFAMAX REAL * 8 FMIN , FMAX , ALFA0 , DOLDALFAMIN , DOLDALFAMAX REAL * 8 RAPALFA , FINIT ( N , 2 ) TYPE ( COMP_WKS_TYP ) :: WKS ( IDIMWKS ) integer ( 8 ), intent ( in ) :: ipar ( nipar ) real ( sgl ), intent ( inout ) :: fparebsd ( nfpar ) real ( sgl ), intent ( in ) :: initmeanval ( ninit ) integer ( irg ), intent ( in ) :: ninit integer ( irg ), intent ( in ) :: nipar integer ( irg ), intent ( in ) :: nfpar real ( sgl ), intent ( in ) :: expt ( ipar ( 2 ) * ipar ( 3 )) real ( sgl ), intent ( in ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( sgl ), intent ( in ) :: mLPNH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) real ( sgl ), intent ( in ) :: mLPSH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) logical , intent ( in ), optional :: verbose procedure ( func ) :: calfun !     VETTORE DEI VALORI DI F SUI PUNTI DI UN SIMPLESSO N+1 DIM. REAL * 8 FSTOP ( N + 1 ), XFSTOP ( N , N + 1 ), FFSTOP , FFSTOPTOL LOGICAL MASCH ( IDIMWKS ) !     num_fal rappresenta il numero di fallimenti consecutivi !     i_corr rappresenta l'indice della direzione corrente COMMON / NUM / F COMMON / NUMNEW / NUM_FUNCT !     inizializzazione NUM_SUCC = 0 NUM_FUNCT = 0 NUM_ITER = 0 NUM_FAL = 0 ISTOP = 0 I_CORR = 1 ALFA0 = 1.D0 !      DO I=1,N !        DOLDALFA(I)=1.D0 !        DOLDALFA(I)=DMAX1(5.D-1,DMIN1(2.D+0,5.D-1*DABS(X(I)))) !        DOLDALFA(I)=1.0D0*DMAX1(1.D-3,DMIN1(1.D+3,0.5D0*DABS(X(I)))) !        IF(IPRINT.GE.2) THEN !          WRITE(*,*) ' ALFAiniz(',I,')=',DOLDALFA(I) !          WRITE(1,*) ' ALFAiniz(',I,')=',DOLDALFA(I) !        ENDIF !      END DO !     scelta iniziale delle direzioni DALFAMAX = MAXVAL ( DOLDALFA ) DO I = 1 , N D ( I ) = 1.D0 END DO !CALL FUNCT(X,N,F) call calfun ( nipar , nfpar , ninit , ipar , fparebsd , initmeanval , expt , accum_e , mLPNH , mLPSH , & N , X , F , verbose ) NUM_FUNCT = NUM_FUNCT + 1 FSTOP ( 1 ) = F DO I = 1 , N XFSTOP ( I , 1 ) = X ( I ) Z ( I ) = X ( I ) END DO IF ( IPRINT . GE . 2 ) THEN WRITE ( * , * ) ' ----------------------------------' WRITE ( 1 , * ) ' ----------------------------------' WRITE ( * , * ) ' Finiz =' , F WRITE ( 1 , * ) ' Finiz =' , F DO I = 1 , N WRITE ( * , * ) ' Xiniz(' , I , ')=' , X ( I ) WRITE ( 1 , * ) ' Xiniz(' , I , ')=' , X ( I ) ENDDO ENDIF NUM_FAL = 0 !--------------------------- !     CICLO PRINCIPALE !--------------------------- 1 CONTINUE IF ( I_CORR . EQ . 1 ) THEN DO I = 1 , N DCONV ( I ) =- D ( I ) END DO ENDIF IF ( NUM_ITER . GE . N ) THEN CALL STOP ( N , DOLDALFA , ISTOP , DALFAMAX , NUM_FUNCT , FSTOP ,& ALFA_STOP , FFSTOPTOL , FFSTOP , FOTT , X , XOTT , ALFAOTT ,& WKS , IDIMWKS , MASCH , MAXNF , fglob ) ENDIF IF ( IPRINT . GE . 1 ) THEN WRITE ( * , * ) '----------------------------------------------' WRITE ( 1 , * ) '----------------------------------------------' WRITE ( * , * ) 'NF=' , NUM_FUNCT , '   F=' , F , '   ALFAmax=' , DALFAMAX WRITE ( 1 , * ) 'NF=' , NUM_FUNCT , '   F=' , F , '   ALFAmax=' , DALFAMAX ENDIF IF ( ISTOP . GE . 1 ) THEN !        WRITE(2,50)'&',N,'&',NUM_FUNCT,'&',F,'\\\\' 50 FORMAT ( 1 X , a3 , i5 , a3 , i5 , a3 , d13 . 5 , a6 ) !        WRITE(*,*) '----------------------------------------------' !        WRITE(1,*) '----------------------------------------------' !        WRITE(*,*) 'NF=',NUM_FUNCT,'   F=',F,'   ALFAmax=',DALFAMAX !        WRITE(1,*) 'NF=',NUM_FUNCT,'   F=',F,'   ALFAmax=',DALFAMAX RETURN END IF !------------------------------------- !    CAMPIONAMENTO LUNGO ASSE I_CORR !------------------------------------- !      CALL LINESEARCH_INVERTI(N,X,F,D,ALFA,DOLDALFA,Z,FZ, !     *I_CORR,NUM_FAL,DALFAMAX,IPRINT) CALL linesearchbox_cont ( n , x , f , d , alfa , doldalfa , z , fz ,& i_corr , num_fal , dalfamax , iprint , bl , bu ,& ipar , fparebsd , initmeanval , ninit , nipar , nfpar , expt , accum_e , mLPNH , mLPSH , verbose , calfun ) IF ( DABS ( ALFA ). GE . 1.D-24 ) THEN X ( I_CORR ) = X ( I_CORR ) + ALFA * D ( I_CORR ) Z ( I_CORR ) = X ( I_CORR ) F = FZ DO I = N + 1 , 2 , - 1 FSTOP ( I ) = FSTOP ( I - 1 ) DO J = 1 , N XFSTOP ( J , I ) = XFSTOP ( J , I - 1 ) END DO ENDDO FSTOP ( 1 ) = F DO J = 1 , N XFSTOP ( J , 1 ) = X ( J ) END DO NUM_FAL = 0 NUM_ITER = NUM_ITER + 1 NUM_SUCC = NUM_SUCC + 1 IF ( IPRINT . GE . 1 ) THEN WRITE ( * , * ) ' F =' , F WRITE ( 1 , * ) ' F =' , F ENDIF IF ( IPRINT . GE . 2 ) THEN DO I = 1 , N WRITE ( * , * ) ' X(' , I , ')=' , X ( I ) WRITE ( 1 , * ) ' X(' , I , ')=' , X ( I ) ENDDO ENDIF ELSE DO I = N + 1 , 2 , - 1 FSTOP ( I ) = FSTOP ( I - 1 ) DO J = 1 , N XFSTOP ( J , I ) = XFSTOP ( J , I - 1 ) END DO ENDDO FSTOP ( 1 ) = FZ DO J = 1 , N XFSTOP ( J , 1 ) = Z ( J ) END DO NUM_FAL = NUM_FAL + 1 NUM_ITER = NUM_ITER + 1 Z ( I_CORR ) = X ( I_CORR ) END IF IF ( I_CORR . LT . N ) THEN I_CORR = I_CORR + 1 ELSE I_CORR = 1 END IF GO TO 1 END !     ####################################################### SUBROUTINE STOP ( N , DOLDALFA , ISTOP , DALFAMAX , NUM_FUNCT , FSTOP ,& ALFA_STOP , FFSTOPTOL , FFSTOP , FOTT , X ,& XOTT , ALFAOTT , WKS , IDIMWKS , MASCH , MAXNF , fglob ) !\tUSE IMSLF90 use typedefs IMPLICIT NONE !\tINCLUDE 'TYPEDECL.FI' INTEGER N , ISTOP , I , NUM_FUNCT , IDIMWKS , J , IMAX , MAXNF REAL * 8 DOLDALFA ( N ), DALFAMAX , FSTOP ( N + 1 ), FFSTOP , FFM , ALFA_STOP , F & , XOTT ( N ), X ( N ) REAL * 8 FFSTOPTOL , FOTT , ALFAOTT , fglob TYPE ( COMP_WKS_TYP ) :: WKS ( IDIMWKS ) LOGICAL NORMADUE , L_F_DISTANTI , NON_MINIMIZZ , L_F_VICINI LOGICAL MASCH ( IDIMWKS ) COMMON / CALFANR2 / NORMADUE COMMON / NUM / F ISTOP = 0 NON_MINIMIZZ = . FALSE . !\tWRITE(*,*)'STO DENTRO STOP ! ALFA_STOP = ',ALFA_STOP !\tWRITE(1,*)'STO DENTRO STOP ! ALFA_STOP = ',ALFA_STOP !\tPAUSE DALFAMAX = DOLDALFA ( 1 ) DO I = 1 , N IF ( DOLDALFA ( I ). GT . DALFAMAX ) THEN DALFAMAX = DOLDALFA ( I ) END IF END DO !      FFM=1.D+30 !      DO I=1,N+1 !        IF(FSTOP(I).LT.FFM) FFM=FSTOP(I) !      ENDDO FFM = 0.D0 DO I = 1 , N + 1 FFM = FFM + FSTOP ( I ) ENDDO FFM = FFM / DFLOAT (( N + 1 )) FFSTOP = 0.D0 DO I = 1 , N + 1 FFSTOP = FFSTOP + ( FSTOP ( I ) - FFM ) * ( FSTOP ( I ) - FFM ) ENDDO !\twrite(*,*) ' ffstop =',ffstop,  ' dfloat =',dfloat(n+1),' ffm =',ffm FFSTOP = DSQRT ( FFSTOP / DFLOAT ( N + 1 )) IF ( NORMADUE ) THEN IF ( DSQRT ( DOT_PRODUCT ( DOLDALFA , DOLDALFA )). LE . ALFA_STOP ) THEN ISTOP = 1 END IF ELSE IF ( DALFAMAX . LE . ALFA_STOP ) THEN ISTOP = 1 END IF ENDIF !-------------------------------------- !\t\tcalcola l'indice imax della !\t\tcomponente di wks contenente !\t\til valore di fob piu' alto !-------------------------------------- IMAX = 1 DO I = 2 , IDIMWKS IF (( WKS ( I )% FOB > WKS ( IMAX )% FOB ). AND .(. NOT . MASCH ( I ))) THEN IMAX = I ENDIF ENDDO L_F_DISTANTI = (( F - WKS ( IMAX )% FOB ) / DMAX1 ( 1.D-8 ,& DMIN1 ( DABS ( F ), DABS ( WKS ( IMAX )% FOB ))) ). GE . 1.D-6 L_F_DISTANTI = L_F_DISTANTI . AND . & ( DALFAMAX . LE . 1.D+0 * WKS ( IMAX )% ALFAMAX ) IF ( L_F_DISTANTI ) THEN ISTOP = 1 RETURN ENDIF DO J = 1 , IDIMWKS IF ( F > FOTT ) THEN L_F_VICINI = ( DABS ( F - WKS ( J )% FOB ) / ( DMAX1 ( 1.D-8 ,& DABS ( DMAX1 ( F , WKS ( J )% FOB ) ))) ). LE . 1.D-1 L_F_VICINI = L_F_VICINI . AND .(( DSQRT (& DOT_PRODUCT ( X - WKS ( J )% X , X - WKS ( J )% X )) <= 1.D-1 )& . OR .( DALFAMAX . LE . 1.D+1 * WKS ( J )% ALFAMAX )) !\t\t\tL_F_VICINI = L_F_VICINI.AND.(DSQRT( !     *\t\t\tDOT_PRODUCT(X-WKS(J)%X,X-WKS(J)%X)) <= 1.D-1) IF ( L_F_VICINI ) THEN !\t\t\t\tISTOP=1 !\t\t\t\tRETURN ENDIF ENDIF ENDDO L_F_DISTANTI = (( F - FOTT ) / DMAX1 ( 1.D-3 , DMIN1 ( DABS ( F ), DABS ( FOTT )) & ) ). GE . 1.D+1 L_F_DISTANTI = L_F_DISTANTI . AND . & ( DALFAMAX . LE . 1.D+1 * ALFA_STOP ) L_F_VICINI = (( F - FOTT ) / DMAX1 ( 1.D-8 , DABS ( DMAX1 ( F , FOTT )) & ) ). LE . 1.D-1 !\tL_F_VICINI = L_F_VICINI.AND.((DSQRT(DOT_PRODUCT(X-XOTT,X-XOTT)) !     *\t\t\t<= 1.D-1)) L_F_VICINI = L_F_VICINI . AND .(( DSQRT ( DOT_PRODUCT ( X - XOTT , X - XOTT ))& <= 1.D-1 ) . OR . ( DALFAMAX <= 0.5D+0 * ALFAOTT )) !\tL_F_DISTANTI = ((F-FOTT)/DMAX1(1.D-16,DMAX1( DABS(FOTT), !     *\t\t\t\t\t\t\t\t\t\tDABS(F) ) ) ).GE.5.D-1 !\tNON_MINIMIZZ = L_F_DISTANTI.AND. !     *\t\t\t   (DALFAMAX.LE.DMIN1(1.0D-0,1.D+2*ALFA_STOP)) !\tNON_MINIMIZZ = L_F_DISTANTI.AND.(DALFAMAX.LE.1.D-3) NON_MINIMIZZ = L_F_DISTANTI . OR . L_F_VICINI IF ( NON_MINIMIZZ ) ISTOP = 1 !      IF(FFSTOP.LE.FFSTOPTOL) THEN !        ISTOP = 1 !      END IF IF ( NUM_FUNCT . GT . MAXNF ) THEN ISTOP = 1 END IF if (( f - fglob ) / max ( 1.0d0 , abs ( fglob )) < 1.0d-4 ) then istop = 1 endif if (( fott - fglob ) / max ( 1.0d0 , abs ( fglob )) < 1.0d-4 ) then istop = 1 endif RETURN END ! ***************************************************************** ! ***************************************************************** ! ***************************************************************** SUBROUTINE LINESEARCH_INVERTI ( N , X , F , D , ALFA , DOLDALFA , Z , FZ ,& I_CORR , NUM_FAL , DALFAMAX , IPRINT ,& ipar , fparebsd , initmeanval , ninit , nipar , nfpar , expt , accum_e ,& mLPNH , mLPSH , verbose , calfun ) IMPLICIT NONE INTEGER N , I_CORR , NUM_FUNCT INTEGER I , J , L , LL INTEGER NUM_FAL INTEGER IPRINT REAL * 8 X ( N ), D ( N ), DOLDALFA ( N ), Z ( N ), Z1 ( N ) REAL * 8 F , ALFA , FZ , GAMMA , DNR REAL * 8 DELTA , DELTA1 , FPAR , FZDELTA REAL * 8 ALFAEX , FMIN , ALFAMIN REAL * 8 DALFAMAX , FCOMMON REAL * 8 ALFAOLD , FZOLD LOGICAL PRIMA_VOLTA integer ( 8 ), intent ( in ) :: ipar ( nipar ) real ( sgl ), intent ( inout ) :: fparebsd ( nfpar ) real ( sgl ), intent ( in ) :: initmeanval ( ninit ) integer ( irg ), intent ( in ) :: ninit integer ( irg ), intent ( in ) :: nipar integer ( irg ), intent ( in ) :: nfpar real ( sgl ), intent ( in ) :: expt ( ipar ( 2 ) * ipar ( 3 )) real ( sgl ), intent ( in ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( sgl ), intent ( in ) :: mLPNH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) real ( sgl ), intent ( in ) :: mLPSH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) logical , intent ( in ), optional :: verbose procedure ( func ) :: calfun COMMON / NUM / FCOMMON COMMON / NUMNEW / NUM_FUNCT PRIMA_VOLTA = . TRUE . GAMMA = 1.d-6 DELTA = 0.5D0 DELTA1 = 0.5D0 DNR = 1.D0 !     indice della direzione corrente J = I_CORR IF ( IPRINT . GE . 1 ) THEN WRITE ( * , * ) ' J=' , J , '  D(J)=' , D ( J ), '  DOLDALFA=' , DOLDALFA ( J ) WRITE ( 1 , * ) ' J=' , J , '  D(J)=' , D ( J ), '  DOLDALFA=' , DOLDALFA ( J ) ENDIF 10 CONTINUE ALFA = DOLDALFA ( J ) IF ( DABS ( ALFA ). LE . 1.D-3 * DALFAMAX ) THEN ALFA = 0.D0 RETURN END IF 20 CONTINUE Z ( J ) = X ( J ) + ALFA * D ( J ) ALFAEX = ALFA !CALL FUNCT(Z,N,FZ) call calfun ( nipar , nfpar , ninit , ipar , fparebsd , initmeanval , expt , accum_e , mLPNH , mLPSH , & N , Z , FZ , verbose ) NUM_FUNCT = NUM_FUNCT + 1 IF ( IPRINT . GE . 1 ) THEN WRITE ( * , * ) ' FZ =' , FZ , '   ALFA =' , ALFA WRITE ( 1 , * ) ' FZ =' , FZ , '   ALFA =' , ALFA ENDIF IF ( IPRINT . GE . 2 ) THEN DO I = 1 , N WRITE ( * , * ) ' Z(' , I , ')=' , Z ( I ) WRITE ( 1 , * ) ' Z(' , I , ')=' , Z ( I ) ENDDO ENDIF FPAR = F - GAMMA * ALFA * ALFA IF ( FZ . LE . FPAR ) THEN FMIN = FZ ALFAMIN = ALFA !       controllo sull'espansione 11 CONTINUE ALFAEX = ALFA / DELTA1 Z ( J ) = X ( J ) + ALFAEX * D ( J ) !CALL FUNCT(Z,N,FZDELTA) call calfun ( nipar , nfpar , ninit , ipar , fparebsd , initmeanval , expt , accum_e , mLPNH , mLPSH , & N , Z , FZDELTA , verbose ) NUM_FUNCT = NUM_FUNCT + 1 IF ( IPRINT . GE . 1 ) THEN WRITE ( * , * ) ' FZex=' , FZDELTA , '  ALFAEX=' , ALFAEX WRITE ( 1 , * ) ' FZex=' , FZDELTA , '  ALFAEX=' , ALFAEX ENDIF IF ( IPRINT . GE . 2 ) THEN DO I = 1 , N WRITE ( * , * ) ' Z(' , I , ')=' , Z ( I ) WRITE ( 1 , * ) ' Z(' , I , ')=' , Z ( I ) ENDDO ENDIF FPAR = F - GAMMA * ALFAEX * ALFAEX IF ( FZDELTA . LE . FPAR ) THEN FZ = FZDELTA ALFA = ALFAEX GO TO 11 ELSE DOLDALFA ( J ) = DELTA * ALFA RETURN END IF ELSE D ( J ) =- D ( J ) IF ( PRIMA_VOLTA ) THEN PRIMA_VOLTA = . FALSE . GO TO 20 ENDIF DOLDALFA ( J ) = DELTA * DOLDALFA ( J ) IF ( IPRINT . GE . 1 ) THEN WRITE ( * , * ) ' direzione opposta' WRITE ( 1 , * ) ' direzione opposta' ENDIF ALFA = 0.D0 RETURN END IF END end module SimAnn","tags":"","loc":"sourcefile/simulated_annealing.f90.html","title":"simulated_annealing.f90 – Fortran Program"},{"text":"This File Depends On sourcefile~~so3.f90~~EfferentGraph sourcefile~so3.f90 so3.f90 sourcefile~constants.f90 constants.f90 sourcefile~constants.f90->sourcefile~so3.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files Dependent On This One sourcefile~~so3.f90~~AfferentGraph sourcefile~so3.f90 so3.f90 sourcefile~dictmod.f90 dictmod.f90 sourcefile~so3.f90->sourcefile~dictmod.f90 sourcefile~pfinversion.f90 PFInversion.f90 sourcefile~dictmod.f90->sourcefile~pfinversion.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules so3 Source Code so3.f90 Source Code ! ################################################################### ! Copyright (c) 2013-2014, Marc De Graef/Carnegie Mellon University ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without modification, are ! permitted provided that the following conditions are met: ! !     - Redistributions of source code must retain the above copyright notice, this list !        of conditions and the following disclaimer. !     - Redistributions in binary form must reproduce the above copyright notice, this !        list of conditions and the following disclaimer in the documentation and/or !        other materials provided with the distribution. !     - Neither the names of Marc De Graef, Carnegie Mellon University nor the names !        of its contributors may be used to endorse or promote products derived from !        this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE ! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ################################################################### !-------------------------------------------------------------------------- ! EMsoft:so3.f90 !-------------------------------------------------------------------------- ! ! MODULE: so3 ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief everything that has to do with sampling of rotation space SO(3) ! !> @todo verify that this is correct for point groups with multiple settings, eg, 3m, 32, ... ! !> @date 05/29/14 MDG 1.0 original !> @date 10/02/14 MDG 2.0 removed globals + rewrite !> @date 01/01/15 MDG 2.1 added IsinsideFZ function, also used in dictionary indexing approach !> @date 01/17/15 MDG 2.2 added gridtype option to SampleRFZ !> @date 03/03/16 MDG 2.3 added uniform sampling for constant misorientations !> @date 04/01/17 MDG 3.0 start to add FZs for two-phase systems (e.g., cubic-hexagonal, etc.) !-------------------------------------------------------------------------- module so3 use local IMPLICIT NONE ! sampler routine public :: SampleRFZ , IsinsideFZ , CubochoricNeighbors ! logical functions to determine if point is inside specific FZ !private :: insideCyclicFZ, insideDihedralFZ, insideCubicFZ public :: insideCyclicFZ , insideDihedralFZ , insideCubicFZ contains !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- ! Routine to return the FZtype and FZorder parameters for single or two-phase ! fundamental zone (FZ) computations; this includes all the FZ types from the ! following paper: ! ! \"Representation of Orientation and Disorientation data for Cubic, Hexagonal, ! Tetragonal, and Orthorhombic Crystals\", A. Heinz and P. Neumann, Acta Cryst. A47, ! 780-789 (1991) ! ! this routine also allows for icosahedral symmetry, although this is not part ! of the paper above. !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- ! ! SUBROUTINE: getFZtypeandorder ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief does Rodrigues point lie inside the relevant FZ ! !> @param pgnum1 point group number for phase 1 !> @param FZtype FZ type !> @param FZorder FZ order !> @param pgnum2 point group number for phase 2 (optional) ! !> @date 04/02/17 MDG 1.0 new routine, needed for two-phase disorientations !-------------------------------------------------------------------------- recursive subroutine getFZtypeandorder ( pgnum1 , FZtype , FZorder , pgnum2 ) !DEC$ ATTRIBUTES DLLEXPORT :: getFZtypeandorder use typedefs use constants IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: pgnum1 integer ( kind = irg ), INTENT ( OUT ) :: FZtype integer ( kind = irg ), INTENT ( OUT ) :: FZorder integer ( kind = irg ), INTENT ( IN ), OPTIONAL :: pgnum2 integer ( kind = irg ) :: thisFZType logical :: twophase ! 0 -> x  (no symmetry or unbounded FZ for the cyclic symmetries) ! 1 -> a  mixed cubic-hexagonal FZ  -> FZtype = 6 ! 2 -> b  mixed FZ -> FZtype = 7 ! 3 -> c  octahedral FZ ! 4 -> d  tetrahedral FZ ! 5 -> e  24-sided prismatic FZ -> FZtype = 8 ! 6 -> f  622 hexagonal dihedral FZ ! 7 -> g  422 octagonal dihedral FZ ! 8 -> h  32 trigonal dihedral FZ ! 9 -> i  222 dihedral FZ ! we reserve FZtype = 5 for icosahedral symmetry, which is under development on a separate code branch twophase = . FALSE . if ( present ( pgnum2 )) twophase = . TRUE . if ( twophase . eqv .. TRUE .) then thisFZtype = FZtypeTable ( pgnum1 , pgnum2 ) select case ( thisFZtype ) case ( 0 ) ! this needs some more work since we need to properly handle the cyclic groups of FZtype = 1 ... FZtype = 0 FZorder = 0 case ( 1 ) FZtype = 6 FZorder = 0 case ( 2 ) FZtype = 7 FZorder = 0 case ( 3 ) FZtype = 4 FZorder = 0 case ( 4 ) FZtype = 3 FZorder = 0 case ( 5 ) FZtype = 8 FZorder = 0 case ( 6 ) FZtype = 2 FZorder = 6 case ( 7 ) FZtype = 2 FZorder = 4 case ( 8 ) FZtype = 2 FZorder = 3 case ( 9 ) FZtype = 2 FZorder = 2 end select else ! single phase so use the old way of doing things... FZtype = FZtarray ( pgnum1 ) FZorder = FZoarray ( pgnum1 ) end if end subroutine getFZtypeandorder !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- ! We define a number of logical routines, that decide whether or not ! a point in Rodrigues representation lies inside the fundamental zone (FZ) ! for a given crystal symmetry. This follows the Morawiec@Field paper: ! ! A. Morawiec & D. P. Field (1996) Rodrigues parameterization for orientation ! and misorientation distributions, Philosophical Magazine A, 73:4, 1113-1130, ! DOI: 10.1080/01418619608243708 !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- !-------------------------------------------------------------------------- ! ! FUNCTION: IsinsideFZ ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief does Rodrigues point lie inside the relevant FZ ! !> @param rod Rodrigues coordinates  (double precision) !> @param FZtype FZ type !> @param FZorder FZ order ! !> @date 01/01/15 MDG 1.0 new routine, needed for dictionary indexing approach !> @date 06/04/15 MDG 1.1 corrected infty to inftyd (double precision infinity) !> @date 04/02/17 MDG 1.2 expanded FZ types to include misorientation FZs and icosahedral !-------------------------------------------------------------------------- recursive function IsinsideFZ ( rod , FZtype , FZorder ) result ( insideFZ ) !DEC$ ATTRIBUTES DLLEXPORT :: IsinsideFZ use constants IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: rod ( 4 ) integer ( kind = irg ), INTENT ( IN ) :: FZtype integer ( kind = irg ), INTENT ( IN ) :: FZorder logical :: insideFZ insideFZ = . FALSE . ! dealing with 180 rotations is needed only for ! FZtypes 0 and 1; the other FZs are always finite. select case ( FZtype ) case ( 0 ) insideFZ = . TRUE . ! all points are inside the FZ case ( 1 ) insideFZ = insideCyclicFZ ( rod , FZtype , FZorder ) ! infinity is checked inside this function case ( 2 ) if ( rod ( 4 ). ne . inftyd ) insideFZ = insideDihedralFZ ( rod , FZorder ) case ( 3 ) if ( rod ( 4 ). ne . inftyd ) insideFZ = insideCubicFZ ( rod , 'tet' ) case ( 4 ) if ( rod ( 4 ). ne . inftyd ) insideFZ = insideCubicFZ ( rod , 'oct' ) case ( 5 ) ! icosahedral symmetry !     if (rod(4).ne.inftyd) insideFZ = insideCubicFZ(rod,'oct') case ( 6 ) ! cubic-hexagonal misorientation FZ if ( rod ( 4 ). ne . inftyd ) insideFZ = insideCubeHexFZ ( rod ) case ( 7 ) !     if (rod(4).ne.inftyd) insideFZ = insideCubicFZ(rod,'oct') case ( 8 ) !     if (rod(4).ne.inftyd) insideFZ = insideCubicFZ(rod,'oct') end select end function IsinsideFZ !-------------------------------------------------------------------------- ! ! FUNCTION: insideCyclicFZ ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief does Rodrigues point lie inside cyclic FZ (for 2, 3, 4, and 6-fold)? ! !> @param rod Rodrigues coordinates  (double precision) !> @param FZtype symmetry type !> @param FZorder depending on main symmetry axis ! !> @date 05/12/14 MDG 1.0 original !> @date 10/02/14 MDG 2.0 rewrite !> @date 06/04/15 MDG 2.1 corrected infty to inftyd (double precision infinity) !-------------------------------------------------------------------------- recursive function insideCyclicFZ ( rod , FZtype , FZorder ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: insideCyclicFZ use constants IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: rod ( 4 ) integer ( kind = irg ), INTENT ( IN ) :: FZtype integer ( kind = irg ), INTENT ( IN ) :: FZorder logical :: res res = . FALSE . if ( rod ( 4 ). ne . inftyd ) then if (( FZtype . eq . 1. ). and .( FZorder . eq . 2 )) then ! check the y-component vs. tan(pi/2n) res = dabs ( rod ( 2 ) * rod ( 4 )). le . LPs % BP ( FZorder ) else ! check the z-component vs. tan(pi/2n) res = dabs ( rod ( 3 ) * rod ( 4 )). le . LPs % BP ( FZorder ) end if else if (( FZtype . eq . 1. ). and .( FZorder . eq . 2 )) then if ( rod ( 2 ) . eq . 0.D0 ) res = . TRUE . else if ( rod ( 3 ). eq . 0.D0 ) res = . TRUE . end if endif end function insideCyclicFZ !-------------------------------------------------------------------------- ! ! FUNCTION: insideDihedralFZ ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief does Rodrigues point lie inside dihedral FZ (for 2, 3, 4, and 6-fold)? ! !> @param rod Rodrigues coordinates (double precision) !> @param order depending on main symmetry axis ! !> @todo for now, we ignore here the fact that, among others, the 3m point group can be oriented in two ways; !> @todo this should be fixable in the future with an additional optional argument ! !> @date 05/12/14  MDG 1.0 original !> @date 10/02/14  MDG 2.0 rewrite !-------------------------------------------------------------------------- recursive function insideDihedralFZ ( rod , order ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: insideDihedralFZ use constants IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: rod ( 4 ) integer ( kind = irg ), INTENT ( IN ) :: order logical :: res , c1 , c2 real ( kind = dbl ) :: r ( 3 ) real ( kind = dbl ), parameter :: r1 = 1.00D0 if ( rod ( 4 ). gt . 1.5 ) then res = . FALSE . else r ( 1 : 3 ) = rod ( 1 : 3 ) * rod ( 4 ) ! first, check the z-component vs. tan(pi/2n)  (same as insideCyclicFZ) c1 = dabs ( r ( 3 )). le . LPs % BP ( order ) res = . FALSE . ! check the square boundary planes if c1=.TRUE. if ( c1 ) then select case ( order ) case ( 2 ) c2 = ( dabs ( r ( 1 )). le . r1 ). and .( dabs ( r ( 2 )). le . r1 ) case ( 3 ) c2 = dabs ( LPs % srt * r ( 1 ) + 0.5D0 * r ( 2 )). le . r1 c2 = c2 . and .( dabs ( LPs % srt * r ( 1 ) - 0.5D0 * r ( 2 )). le . r1 ) c2 = c2 . and .( dabs ( r ( 2 )). le . r1 ) case ( 4 ) c2 = ( dabs ( r ( 1 )). le . r1 ). and .( dabs ( r ( 2 )). le . r1 ) c2 = c2 . and .(( LPs % r22 * dabs ( r ( 1 ) + r ( 2 )). le . r1 ). and .( LPs % r22 * dabs ( r ( 1 ) - r ( 2 )). le . r1 )) case ( 6 ) c2 = dabs ( 0.5D0 * r ( 1 ) + LPs % srt * r ( 2 )). le . r1 c2 = c2 . and .( dabs ( LPs % srt * r ( 1 ) + 0.5D0 * r ( 2 )). le . r1 ) c2 = c2 . and .( dabs ( LPs % srt * r ( 1 ) - 0.5D0 * r ( 2 )). le . r1 ) c2 = c2 . and .( dabs ( 0.5D0 * r ( 1 ) - LPs % srt * r ( 2 )). le . r1 ) c2 = c2 . and .( dabs ( r ( 2 )). le . r1 ) c2 = c2 . and .( dabs ( r ( 1 )). le . r1 ) end select res = c2 end if end if end function insideDihedralFZ !-------------------------------------------------------------------------- ! ! FUNCTION: insideCubicFZ ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief does Rodrigues point lie inside cubic FZ (octahedral or tetrahedral)? ! !> @param rod Rodrigues coordinates  (double precision) !> @param ot 'oct' or 'tet', depending on symmetry ! !> @date 05/12/14 MDG 1.0 original !> @date 10/02/14 MDG 2.0 rewrite !> @date 01/03/15 MDG 2.1 correction of boundary error; simplification of octahedral planes !> @date 06/04/15 MDG 2.2 simplified handling of components of r !-------------------------------------------------------------------------- recursive function insideCubicFZ ( rod , ot ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: insideCubicFZ use constants IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: rod ( 4 ) character ( 3 ), INTENT ( IN ) :: ot logical :: res , c1 , c2 real ( kind = dbl ) :: r ( 3 ) real ( kind = dbl ), parameter :: r1 = 1.0D0 real ( kind = dbl ), parameter :: eps = 1.0D-6 r ( 1 : 3 ) = rod ( 1 : 3 ) * rod ( 4 ) res = . FALSE . ! primary cube planes (only needed for octahedral case) if ( ot . eq . 'oct' ) then c1 = ( maxval ( dabs ( r )) - LPS % BP ( 4 ) . le . eps ) else c1 = . TRUE . end if ! octahedral truncation planes, both for tetrahedral and octahedral point groups c2 = (( dabs ( r ( 1 )) + dabs ( r ( 2 )) + dabs ( r ( 3 ))) - r1 . le . eps ) ! if both c1 and c2, then the point is inside if ( c1 . and . c2 ) res = . TRUE . end function insideCubicFZ !-------------------------------------------------------------------------- ! ! FUNCTION: insideCubeHexFZ ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief does Rodrigues point lie inside combined cubic-hexagonal FZ? ! !> @note For details on this test, see section 8 in \"Representation of Orientation and !> Disorientation data for Cubic, Hexagonal, Tetragonal, and Orthorhombic Crystals\", A. Heinz !> and P. Neumann, Acta Cryst. A47, 780-789 (1991) ! !> @param rod Rodrigues coordinates  (double precision) ! !> @date 04/01/17 MDG 1.0 original !-------------------------------------------------------------------------- recursive function insideCubeHexFZ ( rod ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: insideCubeHexFZ use constants IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: rod ( 4 ) logical :: res real ( kind = dbl ) :: r ( 3 ) real ( kind = dbl ), parameter :: r1 = 0.414213562373095D0 , r2 = 0.131652497587396D0 , & alpha = 0.267949192431123D0 , beta = 0.464101615137755D0 real ( kind = dbl ), parameter :: eps = 1.0D-6 r ( 1 : 3 ) = rod ( 1 : 3 ) * rod ( 4 ) res = . FALSE . if ( ( r ( 2 ). ge . 0.D0 ). and .( r ( 3 ). ge . 0.D0 ) ) then if ( (( alpha * ( r ( 1 ) + r ( 3 )) + r ( 2 )) - beta . le . eps ). and .( ( alpha * ( r ( 2 ) - r ( 3 )) + r ( 1 )) - beta . le . eps ) ) then if ( ( r ( 1 ) - r1 . le . eps ) . and . ( r ( 2 ) - r1 . le . eps ) . and . ( r ( 3 ) - r2 . le . eps ) ) res = . TRUE . end if end if end function insideCubeHexFZ !-------------------------------------------------------------------------- ! ! FUNCTION: delete_FZlist ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief delete a linked list of rodrigues vectors ! !> @param FZlist linked list ! !> @date 02/20/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine delete_FZlist ( top ) !DEC$ ATTRIBUTES DLLEXPORT :: delete_FZlist use typedefs IMPLICIT NONE type ( FZpointd ), pointer , INTENT ( INOUT ) :: top type ( FZpointd ), pointer :: ltail , ltmp ! deallocate the entire linked list before returning, to prevent memory leaks ltail => top ltmp => ltail % next do deallocate ( ltail ) if (. not . associated ( ltmp )) EXIT ltail => ltmp ltmp => ltail % next end do end subroutine delete_FZlist !-------------------------------------------------------------------------- ! ! FUNCTION: SampleRFZ ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief Generate a uniform sampling of a Rodriguess FZ ! !> @note This routine fills in a linked list FZlist of Rodrigues points that !> are inside a specific fundamental zone determined by the sample point group; !> this list can then be further dealt with in the calling program. !> !> Here's how you would use this routine in a main program: !> !> use so3 !> !> integer(kind=irg)       :: FZcnt, nsteps, pgnum !> type(FZpointd),pointer  :: FZlist, FZtmp !> !> nullify(FZlist) !> FZcnt = 0 !> nsteps = 10 !> pgnum = 32 !> call sampleRFZ(nsteps, pgnum, FZcnt, FZlist) !> !> Then you can access all the entries in the list and, for instance, convert them to Euler angles... !> !> FZtmp => FZlist                        ! point to the top of the list !> do i = 1, FZcnt                        ! loop over all entries !>   eu = ro2eu(FZtmp%rod)                ! convert to Euler angles !>   do something with eu                 ! for instance, write eu to a file !>   FZtmp => FZtmp%next                  ! point to the next entry !> end do !> !> If you just want to look at the first 10 entries on the list and show all other orientation representations: !> !> type(orientationtyped):: ot !> !> FZtmp => FZlist !> do i = 1,10 !>   ot = init_orientation(FZtmp%rod,'ro') !>   call print_orientation(ot) !>   FZtmp => FZtmp%next !> end do ! !> @param nsteps number of steps along semi-edge in cubochoric grid !> @param pgnum point group number to determine the appropriate Rodrigues fundamental zone !> @param gridtype (input) 0 for origin-centered grid; 1 for grid with origin at box center !> @param FZcnt (output) number of points inside fundamental zone !> @param FZlist (output) linked list of points inside fundamental zone ! !> @date 05/12/14 MDG 1.0 original !> @date 10/02/14 MDG 2.0 rewrite, removed all globals, added function arguments !> @date 09/15/15 MDG 2.1 removed explicit origin allocation; changed while to do loops. !> @date 01/17/15 MDG 2.2 added gridtype option !> @date 05/22/16 MDG 2.3 correction for monoclinic symmetry with twofold axis along b, not c !!! !-------------------------------------------------------------------------- recursive subroutine SampleRFZ ( nsteps , pgnum , gridtype , FZcnt , FZlist ) !DEC$ ATTRIBUTES DLLEXPORT :: SampleRFZ use typedefs use constants use rotations IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: nsteps integer ( kind = irg ), INTENT ( IN ) :: pgnum integer ( kind = irg ), INTENT ( IN ) :: gridtype integer ( kind = irg ), INTENT ( OUT ) :: FZcnt ! counts number of entries in linked list type ( FZpointd ), pointer , INTENT ( OUT ) :: FZlist ! pointers real ( kind = dbl ) :: x , y , z , rod ( 4 ), delta , shift , sedge , ztmp type ( FZpointd ), pointer :: FZtmp , FZtmp2 integer ( kind = irg ) :: FZtype , FZorder , i , j , k logical :: b ! cube semi-edge length s = 0.5D0 * LPs%ap ! step size for sampling of grid; total number of samples = (2*nsteps+1)**3 sedge = 0.5D0 * LPs % ap delta = sedge / dble ( nsteps ) if ( gridtype . eq . 0 ) then shift = 0.0D0 else shift = 0.5D0 end if ! set the counter to zero FZcnt = 0 ! make sure the linked lists are empty if ( associated ( FZlist )) then FZtmp => FZlist % next FZtmp2 => FZlist do deallocate ( FZtmp2 ) if (. not . associated ( FZtmp ) ) EXIT FZtmp2 => FZtmp FZtmp => FZtmp % next end do nullify ( FZlist ) else nullify ( FZlist ) end if ! determine which function we should call for this point group symmetry FZtype = FZtarray ( pgnum ) FZorder = FZoarray ( pgnum ) ! note that when FZtype is cyclic (1) and FZorder is 2, then we must rotate the ! rotation axis to lie along the b (y) direction, not z !!!! ! loop over the cube of volume pi&#94;2; note that we do not want to include ! the opposite edges/facets of the cube, to avoid double counting rotations ! with a rotation angle of 180 degrees.  This only affects the cyclic groups. do i =- nsteps + 1 , nsteps x = ( dble ( i ) + shift ) * delta do j =- nsteps + 1 , nsteps y = ( dble ( j ) + shift ) * delta do k =- nsteps + 1 , nsteps z = ( dble ( k ) + shift ) * delta ! make sure that this point lies inside the cubochoric cell if ( maxval ( ( / abs ( x ), abs ( y ), abs ( z ) / ) ). le . sedge ) then ! convert to Rodrigues representation rod = cu2ro ( ( / x , y , z / ) ) ! If insideFZ=.TRUE., then add this point to the linked list FZlist and keep ! track of how many points there are on this list b = IsinsideFZ ( rod , FZtype , FZorder ) if ( b ) then if (. not . associated ( FZlist )) then allocate ( FZlist ) FZtmp => FZlist ! in DEBUG mode, there is a strange error here ... ! if gridtype = 0 then we must add the identity rotation here ! currently, the identity is not automatically recognized since the ! returns from several rotation routines also equal the identity when ! the point is actually invalid... !          if (gridtype.eq.0) then !            FZcnt = 1 !            FZtmp%rod = (/ 0.D0, 0.D0, 1.D0, 0.D0 /) !            allocate(FZtmp%next) !            FZtmp => FZtmp%next !            nullify(FZtmp%next) !          end if else allocate ( FZtmp % next ) FZtmp => FZtmp % next end if nullify ( FZtmp % next ) ! if monoclinic, then reorder the components !!! !        if ((FZtype.eq.1).and.(FZorder.eq.2)) then !          ztmp = rod(3) !          rod(3) = rod(1) !          rod(1) = rod(2) !          rod(2) = ztmp !        end if FZtmp % rod = rod FZcnt = FZcnt + 1 end if end if end do end do end do end subroutine SampleRFZ !-------------------------------------------------------------------------- ! ! SUBROUTINE: CubochoricNeighbors ! !> @author Saransh Singh, Carnegie Mellon University ! !> @brief find the nearest neighbors of a point in s03 space, given the point !> and the step size used in the previous meshing. to be used in multi resolution !> indexing programs, specifically the PED, ECP and EBSD indexing. we're not worrying !> about keeping the neighbors in the FZ. that can just be done later. ! !> @param cub cubochoric coordinates  (double precision) !> @param stepsize stepsize of last mesh. the mesh will be stepsize/2 ! !> @date 04/07/15 SS 1.0 original !-------------------------------------------------------------------------- recursive subroutine CubochoricNeighbors ( cubneighbor , nn , cub , stepsize ) !DEC$ ATTRIBUTES DLLEXPORT :: CubochoricNeighbors use constants IMPLICIT NONE real ( kind = dbl ), INTENT ( OUT ) :: cubneighbor ( 3 ,( 2 * nn + 1 ) ** 3 ) integer ( kind = irg ), INTENT ( IN ) :: nn ! number of nearest neighbor in each direction (should be an odd number for symmetric meshing) real ( kind = dbl ), INTENT ( IN ) :: cub ( 3 ) real ( kind = dbl ), INTENT ( IN ) :: stepsize integer ( kind = irg ) :: ii , jj , kk , ll , idx if ( dabs ( stepsize ) . gt . LPs % ap ) then write ( * , * ) \"ERROR in subroutine CubochoricNeighbors: Step size is larger than edge length of the cube\" stop end if do ii = - nn , nn do jj = - nn , nn do kk = - nn , nn idx = ( ii + nn ) * ( 2 * nn + 1 ) ** 2 + ( jj + nn ) * ( 2 * nn + 1 ) + ( kk + nn + 1 ) cubneighbor ( 1 : 3 , idx ) = cub + stepsize / 2.D0 * ( / ii , jj , kk / ) do ll = 1 , 3 if ( cubneighbor ( ll , idx ) . lt . - 0.5D0 * LPs % ap ) then cubneighbor ( ll , idx ) = cubneighbor ( ll , idx ) + LPs % ap else if ( cubneighbor ( ll , idx ) . gt . 0.5D0 * LPs % ap ) then cubneighbor ( ll , idx ) = cubneighbor ( ll , idx ) - LPs % ap end if end do end do end do end do end subroutine CubochoricNeighbors !-------------------------------------------------------------------------- ! ! SUBROUTINE: SamplefcctwinRFZ ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief uniformly sample the 32-based FZ for an fcc twin. ! !> @param nsteps number of steps along semi-edge in cubochoric grid !> @param FZcnt (output) number of points inside fundamental zone !> @param FZlist (output) linked list of points inside fundamental zone ! !> @date 09/17/16 MDG 1.0 fcc twin FZ for 60@[111] (also MacKenzie cell) !--------------------------------------------------------------- ----------- recursive subroutine SamplefcctwinRFZ ( nsteps , FZcnt , FZlist ) !DEC$ ATTRIBUTES DLLEXPORT :: SamplefcctwinRFZ use local use constants use typedefs use rotations use quaternions IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: nsteps integer ( kind = irg ), INTENT ( OUT ) :: FZcnt ! counts number of entries in linked list type ( FZpointd ), pointer , INTENT ( OUT ) :: FZlist ! pointers real ( kind = dbl ), allocatable :: vertex (:,:), normals (:,:) integer ( kind = irg ), allocatable :: faces (:,:) real ( kind = dbl ) :: r21 ( 3 ), r23 ( 3 ), rv ( 3 ) integer ( kind = irg ) :: i , j , nv , nf , nn real ( kind = dbl ) :: x , y , z , s , rod ( 4 ), rodt ( 4 ), delta , rval , ro ( 3 ), dp type ( FZpointd ), pointer :: FZtmp , FZtmp2 logical :: inside ! a point is inside a polyhedron if the dot product of a vector from that ! point to any vertex of each face with the face normal is positive ! this routine is specifically written for the fcc twin 60°@[111]; the FZ in ! that case has the following vertex positions with respect to the standard ! 432 rfz (determined with the EMRFZ program): nv = 14 nf = 18 nn = 18 allocate ( vertex ( 3 , nv ), faces ( 4 , nf ), normals ( 3 , nn )) vertex ( 1 : 3 , 1 ) = ( / 0.3333334 , 0.3333333 , 0.3333333 / ); vertex ( 1 : 3 , 2 ) = ( / 0.0906927 , 0.0906927 , 0.3333333 / ); vertex ( 1 : 3 , 3 ) = ( / 0.0098125 , 0.2524531 , 0.2524532 / ); vertex ( 1 : 3 , 4 ) = ( / 0.0906928 , 0.3333333 , 0.0906928 / ); vertex ( 1 : 3 , 5 ) = ( / 0.2524532 , 0.2524531 , 0.0098125 / ); vertex ( 1 : 3 , 6 ) = ( / 0.3333334 , 0.0906927 , 0.0906927 / ); vertex ( 1 : 3 , 7 ) = ( / 0.2524532 , 0.0098125 , 0.2524531 / ); vertex ( 1 : 3 , 8 ) = ( /- 0.2524531 , - 0.2524531 , - 0.0098124 / ); vertex ( 1 : 3 , 9 ) = ( /- 0.3333333 , - 0.0906927 , - 0.0906926 / ); vertex ( 1 : 3 , 10 ) = ( /- 0.2524531 , - 0.0098124 , - 0.2524531 / ); vertex ( 1 : 3 , 11 ) = ( /- 0.0906926 , - 0.0906926 , - 0.3333333 / ); vertex ( 1 : 3 , 12 ) = ( /- 0.0098124 , - 0.2524531 , - 0.2524530 / ); vertex ( 1 : 3 , 13 ) = ( /- 0.0906926 , - 0.3333333 , - 0.0906926 / ); vertex ( 1 : 3 , 14 ) = ( /- 0.3333333 , - 0.3333333 , - 0.3333333 / ); ! next, get the face vertex numbers (triangles and squares) in counterclockwise ! order when looking towards the origin; triangle faces first, then the rectangles faces ( 1 : 4 , 1 ) = ( / 1 , 3 , 2 , 0 / ) faces ( 1 : 4 , 2 ) = ( / 1 , 4 , 3 , 0 / ) faces ( 1 : 4 , 3 ) = ( / 1 , 5 , 4 , 0 / ) faces ( 1 : 4 , 4 ) = ( / 1 , 6 , 5 , 0 / ) faces ( 1 : 4 , 5 ) = ( / 1 , 7 , 6 , 0 / ) faces ( 1 : 4 , 6 ) = ( / 1 , 2 , 7 , 0 / ) faces ( 1 : 4 , 7 ) = ( / 14 , 8 , 9 , 0 / ) faces ( 1 : 4 , 8 ) = ( / 14 , 9 , 10 , 0 / ) faces ( 1 : 4 , 9 ) = ( / 14 , 10 , 11 , 0 / ) faces ( 1 : 4 , 10 ) = ( / 14 , 11 , 12 , 0 / ) faces ( 1 : 4 , 11 ) = ( / 14 , 12 , 13 , 0 / ) faces ( 1 : 4 , 12 ) = ( / 14 , 13 , 8 , 0 / ) faces ( 1 : 4 , 13 ) = ( / 2 , 3 , 9 , 8 / ) faces ( 1 : 4 , 14 ) = ( / 3 , 4 , 10 , 9 / ) faces ( 1 : 4 , 15 ) = ( / 4 , 5 , 11 , 10 / ) faces ( 1 : 4 , 16 ) = ( / 5 , 6 , 12 , 11 / ) faces ( 1 : 4 , 17 ) = ( / 6 , 7 , 13 , 12 / ) faces ( 1 : 4 , 18 ) = ( / 7 , 2 , 8 , 13 / ) ! next we get the outward normal for each of the faces ! we'll get the outward normal by computing the cross product of 2-1 and 2-3 do i = 1 , nn r21 ( 1 : 3 ) = vertex ( 1 : 3 , faces ( 3 , i )) - vertex ( 1 : 3 , faces ( 2 , i )) r23 ( 1 : 3 ) = vertex ( 1 : 3 , faces ( 1 , i )) - vertex ( 1 : 3 , faces ( 2 , i )) normals ( 1 : 3 , i ) = ( / r21 ( 2 ) * r23 ( 3 ) - r21 ( 3 ) * r23 ( 2 ), r21 ( 3 ) * r23 ( 1 ) - r21 ( 1 ) * r23 ( 3 ), r21 ( 1 ) * r23 ( 2 ) - r21 ( 2 ) * r23 ( 1 ) / ) write ( * , * ) i , dot_product ( vertex ( 1 : 3 , faces ( 3 , i )), normals ( 1 : 3 , i )) end do ! here we do the regular cubochoric sampling, but use the dot product test to ! determine whether or not the point is inside the twin RFZ ! cube semi-edge length s = 0.5D0 * LPs % ap ! step size for sampling of grid; total number of samples = (2*nsteps+1)**3 delta = s / dble ( nsteps ) ! set the counter to zero FZcnt = 0 ! make sure the linked lists are empty if ( associated ( FZlist )) then FZtmp => FZlist % next FZtmp2 => FZlist do deallocate ( FZtmp2 ) if (. not . associated ( FZtmp ) ) EXIT FZtmp2 => FZtmp FZtmp => FZtmp % next end do nullify ( FZlist ) end if ! we always want the identity rotation to be the first one on the list ! it is automatically skipped later on... allocate ( FZlist ) FZtmp => FZlist nullify ( FZtmp % next ) FZtmp % rod = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) FZcnt = 1 ! loop over the cube of volume pi&#94;2; note that we do not want to include ! the opposite edges/facets of the cube, to avoid double counting rotations ! with a rotation angle of 180 degrees.  This only affects the cyclic groups. x = - s do while ( x . lt . s ) y = - s do while ( y . lt . s ) z = - s do while ( z . lt . s ) if (( x . ne . 0.D0 ). and .( y . ne . 0.D0 ). and .( z . ne . 0.D0 )) then ! convert to Rodrigues representation rod = cu2ro ( ( / x , y , z / ) ) ro ( 1 : 3 ) = rod ( 1 : 3 ) * rod ( 4 ) ! assume the point is inside and start the tests for each of the face normals inside = . TRUE . FACELOOP : do i = 1 , nn rv ( 1 : 3 ) = vertex ( 1 : 3 , faces ( 1 , i )) - ro ( 1 : 3 ) dp = DOT_PRODUCT ( rv , normals ( 1 : 3 , i )) if ( dp . lt . 0.D0 ) then inside = . FALSE . exit FACELOOP end if end do FACELOOP ! If inside=.TRUE., then add this point to the linked list FZlist and keep ! track how many points there are on this list if ( inside ) then allocate ( FZtmp % next ) FZtmp => FZtmp % next nullify ( FZtmp % next ) FZtmp % rod = rod FZcnt = FZcnt + 1 end if end if z = z + delta end do y = y + delta end do x = x + delta end do ! that's it. write ( * , * ) 'nsteps, delta, s = ' , nsteps , delta , s write ( * , * ) 'FZcnt = ' , FZcnt end subroutine SamplefcctwinRFZ !-------------------------------------------------------------------------- ! ! SUBROUTINE: SampleRFZtwin ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief use a quaternion to rotate the fundamental zone, then sample it !> this is useful for twins etc, hence the name of the routine... ! !> @param nsteps number of steps along semi-edge in cubochoric grid !> @param pgnum point group number to determine the appropriate Rodrigues fundamental zone !> @param qt rotation quaternion !> @param FZcnt (output) number of points inside fundamental zone !> @param FZlist (output) linked list of points inside fundamental zone ! !> @date 04/07/15 SS  1.0 original !-------------------------------------------------------------------------- recursive subroutine SampleRFZtwin ( nsteps , pgnum , qt , FZcnt , FZlist ) !DEC$ ATTRIBUTES DLLEXPORT :: SampleRFZtwin use local use constants use typedefs use rotations use quaternions IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: nsteps integer ( kind = irg ), INTENT ( IN ) :: pgnum real ( kind = sgl ), INTENT ( IN ) :: qt ( 4 ) integer ( kind = irg ), INTENT ( OUT ) :: FZcnt ! counts number of entries in linked list type ( FZpointd ), pointer , INTENT ( OUT ) :: FZlist ! pointers real ( kind = dbl ) :: x , y , z , s , rod ( 4 ), rodt ( 4 ), delta , rval , ro ( 3 ) type ( FZpointd ), pointer :: FZtmp , FZtmp2 integer ( kind = irg ) :: FZtype , FZorder ! cube semi-edge length s = 0.5D0 * LPs % ap ! step size for sampling of grid; total number of samples = (2*nsteps+1)**3 delta = s / dble ( nsteps ) ! set the counter to zero FZcnt = 0 ! make sure the linked lists are empty if ( associated ( FZlist )) then FZtmp => FZlist % next FZtmp2 => FZlist do deallocate ( FZtmp2 ) if (. not . associated ( FZtmp ) ) EXIT FZtmp2 => FZtmp FZtmp => FZtmp % next end do nullify ( FZlist ) end if ! we always want the identity rotation to be the first one on the list ! it is automatically skipped later on... allocate ( FZlist ) FZtmp => FZlist nullify ( FZtmp % next ) FZtmp % rod = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) FZcnt = 1 ! determine which function we should call for this point group symmetry FZtype = FZtarray ( pgnum ) FZorder = FZoarray ( pgnum ) ! loop over the cube of volume pi&#94;2; note that we do not want to include ! the opposite edges/facets of the cube, to avoid double counting rotations ! with a rotation angle of 180 degrees.  This only affects the cyclic groups. x = - s do while ( x . lt . s ) y = - s do while ( y . lt . s ) z = - s do while ( z . lt . s ) if (( x . ne . 0.D0 ). and .( y . ne . 0.D0 ). and .( z . ne . 0.D0 )) then ! convert to Rodrigues representation rod = cu2ro ( ( / x , y , z / ) ) ! convert to an actual vector ro ( 1 : 3 ) = rod ( 1 : 3 ) ! then apply the twinning quaternion ro = quat_Lp ( dble ( qt ), ro ) ! convert back to a Rodrigues vector rodt = rod rodt ( 1 : 3 ) = ro ( 1 : 3 ) ! If insideFZ=.TRUE., then add this point to the linked list FZlist and keep ! track of how many points there are on this list if ( IsinsideFZ ( rodt , FZtype , FZorder )) then allocate ( FZtmp % next ) FZtmp => FZtmp % next nullify ( FZtmp % next ) FZtmp % rod = rod FZcnt = FZcnt + 1 end if end if z = z + delta end do y = y + delta end do x = x + delta end do ! that's it. write ( * , * ) 'pgnum, nsteps, delta, s = ' , pgnum , nsteps , delta , s write ( * , * ) 'FZtype, FZorder = ' , FZtype , FZorder write ( * , * ) 'FZcnt = ' , FZcnt end subroutine SampleRFZtwin !-------------------------------------------------------------------------- ! ! SUBROUTINE: sample_isoCube ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief sample a centered cube surface inside the Cubochoric cube for a given misorientation angle ! !> @details linked list wil have a length of 6(N-1)&#94;2+2 entries ! !> @param misang the misorientation angle [degrees] !> @param N number of points along cube semi-edge !> @param CMcnt the number of components in the returned linked list !> @param CMlist (output) linked list of Rodrigues vectors ! !> @date 03/03/16 MDG 1.0 original !> @date 04/19/16 MDG 1.1 changed value of N to be along the semi-edge instead of the edge !-------------------------------------------------------------------------- recursive subroutine sample_isoCube ( misang , N , CMcnt , CMlist ) ! CM = Constant Misorientation !DEC$ ATTRIBUTES DLLEXPORT :: sample_isoCube use constants use typedefs use rotations IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: misang ! desired misorientation angle (degrees) integer ( kind = irg ), INTENT ( IN ) :: N ! desired number of sampling points along cube edge integer ( kind = irg ), INTENT ( INOUT ) :: CMcnt ! number of entries in linked list type ( FZpointd ), pointer :: CMlist ! pointer to start of linked list type ( FZpointd ), pointer :: CMtmp , CMtmp2 real ( kind = dbl ) :: edge , misangr , dx , cu ( 3 ), x , y , z integer ( kind = irg ) :: i , j , k ! initialize parameters CMcnt = 0 ! convert the misorientation angle to radians misangr = misang * cPi / 18 0.D0 ! make sure the linked list is empty if ( associated ( CMlist )) then CMtmp => CMlist % next CMtmp2 => CMlist do deallocate ( CMtmp2 ) if (. not . associated ( CMtmp ) ) EXIT CMtmp2 => CMtmp CMtmp => CMtmp % next end do nullify ( CMlist ) end if ! allocate the linked list allocate ( CMlist ) CMtmp => CMlist ! set the cube edge length based on the misorientation angle edge = ( cPi * ( misangr - sin ( misangr ))) ** ( 1.D0 / 3.D0 ) * 0.5D0 dx = edge / dble ( N ) write ( * , * ) ' edge = ' , edge , '; delta = ' , dx ! and generate the linked list of surface points ! do the x-y bottom and top planes first (each have N&#94;2 points) do i =- N , N x = dble ( i ) * dx do j =- N , N y = dble ( j ) * dx ! add the point to the list cu = ( / x , y , edge / ) CMtmp % rod = cu2ro ( cu ) CMcnt = CMcnt + 1 allocate ( CMtmp % next ) CMtmp => CMtmp % next nullify ( CMtmp % next ) ! and its mirror image in the top plane cu = ( / x , y , - edge / ) CMtmp % rod = cu2ro ( cu ) CMcnt = CMcnt + 1 allocate ( CMtmp % next ) CMtmp => CMtmp % next nullify ( CMtmp % next ) end do end do ! then we do the y-z planes; each have N*(N-2) points do j =- N , N y = dble ( j ) * dx do k =- N + 1 , N - 1 z = dble ( k ) * dx ! add the point to the list cu = ( / edge , y , z / ) CMtmp % rod = cu2ro ( cu ) CMcnt = CMcnt + 1 allocate ( CMtmp % next ) CMtmp => CMtmp % next nullify ( CMtmp % next ) ! and its mirror image in the top plane cu = ( / - edge , y , z / ) CMtmp % rod = cu2ro ( cu ) CMcnt = CMcnt + 1 allocate ( CMtmp % next ) CMtmp => CMtmp % next nullify ( CMtmp % next ) end do end do ! and finally the x-z planes, with (N-2)&#94;2 points each do i =- N + 1 , N - 1 x = dble ( i ) * dx do k =- N + 1 , N - 1 z = dble ( k ) * dx ! add the point to the list cu = ( / x , edge , z / ) CMtmp % rod = cu2ro ( cu ) CMcnt = CMcnt + 1 allocate ( CMtmp % next ) CMtmp => CMtmp % next nullify ( CMtmp % next ) ! and its mirror image in the top plane cu = ( / x , - edge , z / ) CMtmp % rod = cu2ro ( cu ) CMcnt = CMcnt + 1 allocate ( CMtmp % next ) CMtmp => CMtmp % next nullify ( CMtmp % next ) end do end do end subroutine sample_isoCube !-------------------------------------------------------------------------- ! ! SUBROUTINE: sample_isoCubeFilled ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief sample a centered cube inside the Cubochoric cube for a given misorientation angle ! !> @details This routine is different from the sample_isoCube routine in that it !> generates ALL the points inside the centered cube instead of just the points on !> the outer surface.  This can be useful to uniformly sample a small volume of orientation !> space around some point out to a given misorientation angle.  Since the sampling has concentric !> cubes, all the samples can be subdivided into discrete misorientation classes. !> The linked list wil have a length of N&#94;3 ! !> @param misang the misorientation angle [degrees] !> @param N number of points along cube edge !> @param CMcnt the number of components in the returned linked list !> @param CMlist (output) linked list of Rodrigues vectors ! !> @date 04/08/16 MDG 1.0 original !> @date 04/19/16 MDG 1.1 changed value of N to be along the semi-edge instead of the edge !-------------------------------------------------------------------------- recursive subroutine sample_isoCubeFilled ( misang , N , CMcnt , CMlist ) ! CM = Constant Misorientation !DEC$ ATTRIBUTES DLLEXPORT :: sample_isoCubeFilled use constants use typedefs use rotations IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: misang ! desired misorientation angle (degrees) integer ( kind = irg ), INTENT ( IN ) :: N ! desired number of sampling points along cube edge integer ( kind = irg ), INTENT ( INOUT ) :: CMcnt ! number of entries in linked list type ( FZpointd ), pointer :: CMlist ! pointer to start of linked list type ( FZpointd ), pointer :: CMtmp , CMtmp2 real ( kind = dbl ) :: edge , misangr , dx , cu ( 3 ), x , y , z , xc , yc , zc integer ( kind = irg ) :: i , j , k ! initialize parameters CMcnt = 0 ! convert the misorientation angle to radians misangr = misang * cPi / 18 0.D0 ! make sure the linked list is empty if ( associated ( CMlist )) then CMtmp => CMlist % next CMtmp2 => CMlist do deallocate ( CMtmp2 ) if (. not . associated ( CMtmp ) ) EXIT CMtmp2 => CMtmp CMtmp => CMtmp % next end do nullify ( CMlist ) end if ! allocate the linked list allocate ( CMlist ) CMtmp => CMlist ! set the cube edge length based on the misorientation angle edge = ( cPi * ( misangr - sin ( misangr ))) ** ( 1.D0 / 3.D0 ) * 0.5D0 dx = edge / dble ( N ) ! and generate the linked list of surface points ! loop over the (2N+1)&#94;3 points do i =- N , N x = dble ( i ) * dx do j =- N , N y = dble ( j ) * dx do k =- N , N z = dble ( k ) * dx ! add the point to the list cu = ( / x , y , z / ) CMtmp % rod = cu2ro ( cu ) CMcnt = CMcnt + 1 allocate ( CMtmp % next ) CMtmp => CMtmp % next nullify ( CMtmp % next ) end do end do end do end subroutine sample_isoCubeFilled !-------------------------------------------------------------------------- ! ! SUBROUTINE: sample_Cone ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief sample a cone centered on a unit vector with apex in the origin and given opening angle ! !> @param unitvector  unit vector describing the cone axis !> @param dpmax = cosine of half the cone angle !> @param N number of points along cube edge !> @param CMcnt the number of components in the returned linked list !> @param CMlist (output) linked list of Rodrigues vectors ! !> @date 02/01/17 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine sample_Cone ( unitvector , dpmax , N , FZtype , FZorder , cnt , list ) !DEC$ ATTRIBUTES DLLEXPORT :: sample_Cone use constants use typedefs use rotations IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: unitvector ( 3 ) ! axis of cone real ( kind = dbl ), INTENT ( IN ) :: dpmax ! maximum dot product integer ( kind = irg ), INTENT ( IN ) :: N ! number of sampling points along cube semi edge integer ( kind = irg ), INTENT ( IN ) :: FZtype integer ( kind = irg ), INTENT ( IN ) :: FZorder integer ( kind = irg ), INTENT ( INOUT ) :: cnt ! number of entries in linked list type ( FZpointd ), pointer :: list ! pointer to start of linked list type ( FZpointd ), pointer :: tmp , tmp2 real ( kind = dbl ) :: dx , rod ( 4 ), x , y , z , s , delta , dp , r ( 3 ) ! initialize parameters cnt = 0 ! cube semi-edge length s = 0.5D0 * LPs % ap ! step size for sampling of grid; total number of samples = (2*nsteps+1)**3 delta = s / dble ( N ) ! make sure the linked list is empty if ( associated ( list )) then tmp => list % next tmp2 => list do deallocate ( tmp2 ) if (. not . associated ( tmp ) ) EXIT tmp2 => tmp tmp => tmp % next end do nullify ( list ) end if ! allocate the linked list and insert the origin allocate ( list ) tmp => list nullify ( tmp % next ) tmp % rod = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) cnt = 1 ! and generate the linked list of points inside the cone x = - s do while ( x . lt . s ) y = - s do while ( y . lt . s ) z = - s do while ( z . lt . s ) if (( x . ne . 0.D0 ). and .( y . ne . 0.D0 ). and .( z . ne . 0.D0 )) then ! convert to Rodrigues representation rod = cu2ro ( ( / x , y , z / ) ) r = rod ( 1 : 3 ) / sqrt ( sum ( rod ( 1 : 3 ) ** 2 )) ! compute the dot product of this vector and the unitvector dp = unitvector ( 1 ) * r ( 1 ) + unitvector ( 2 ) * r ( 2 ) + unitvector ( 3 ) * r ( 3 ) ! conditionally add the point to the list if it lies inside the cone (dpmax <= dp) if (( dp . ge . dpmax ). and .( IsinsideFZ ( rod , FZtype , FZorder ))) then allocate ( tmp % next ) tmp => tmp % next nullify ( tmp % next ) tmp % trod = rod cnt = cnt + 1 end if end if z = z + delta end do y = y + delta end do x = x + delta end do end subroutine sample_Cone !-------------------------------------------------------------------------- ! ! SUBROUTINE: SampleIsoMisorientation ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief Constant Misorientation sampling routine; input list must be generated by sampleCubeSurface ! !> @param rhozero central Rodrigues point around which constant misorientation sample is requested !> @param misang the misorientation angle [degrees] !> @param CMcnt the number of components in the returned linked list !> @param CMlist (output) linked list of Rodrigues vectors, with transformed vectors in trod(4) entries ! !> @date 03/03/16 SS/MDG 1.0 original (merged from two separate implementations) !-------------------------------------------------------------------------- recursive subroutine SampleIsoMisorientation ( rhozero , misang , CMcnt , CMlist ) ! CM = Constant Misorientation !DEC$ ATTRIBUTES DLLEXPORT :: SampleIsoMisorientation use constants use typedefs use math IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: rhozero ( 4 ) ! center Rodrigues vector real ( kind = dbl ), INTENT ( IN ) :: misang ! desired misorientation angle (degrees) integer ( kind = irg ), INTENT ( INOUT ) :: CMcnt ! number of entries in linked list type ( FZpointd ), pointer :: CMlist ! pointer to start of linked list type ( FZpointd ), pointer :: CMtmp real ( kind = dbl ) :: rhovec ( 3 ), s , vv ( 3 ) integer ( kind = irg ) :: i ! go through the list and transform all points to the spheroid misorientation surface ! the resulting Rodrigues vectors are stored in the trod(4) entry. rhovec ( 1 : 3 ) = rhozero ( 1 : 3 ) * rhozero ( 4 ) CMtmp => CMlist do i = 1 , CMcnt ! get the actual Rodrigues vector vv ( 1 : 3 ) = CMtmp % rod ( 1 : 3 ) * CMtmp % rod ( 4 ) ! apply the Rodrigues transformation formula vv = ( - vv + rhovec + cross3 ( rhovec , vv )) / ( 1.D0 + DOT_PRODUCT ( vv , rhovec )) ! and convert back to the 4-component format s = dsqrt ( sum ( vv * vv )) if ( s . gt . 0.D0 ) then CMtmp % trod = ( / vv ( 1 ) / s , vv ( 2 ) / s , vv ( 3 ) / s , s / ) else CMtmp % trod = ( / 0.D0 , 0.D0 , 1.D0 , 0.D0 / ) end if CMtmp => CMtmp % next end do end subroutine SampleIsoMisorientation !-------------------------------------------------------------------------- ! ! SUBROUTINE: getEulersfromFile ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read a list of Euler angles from a text file and insert them in a linked list ! !> @param eulerfile name of the Euler angle file (with usual path handling) !> @param FZcnt the number of components in the returned linked list !> @param FZlist (output) linked list of Rodrigues vectors, with transformed vectors in trod(4) entries ! !> @date 12/22/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine getEulersfromFile ( eulerfile , FZcnt , FZlist ) !DEC$ ATTRIBUTES DLLEXPORT :: getEulersfromFile use constants use typedefs use rotations IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: eulerfile integer ( kind = irg ), INTENT ( INOUT ) :: FZcnt ! number of entries in linked list type ( FZpointd ), pointer :: FZlist ! pointer to start of linked list character ( fnlen ) :: filepath character ( 2 ) :: anglemode integer ( kind = irg ) :: numang , i real ( kind = dbl ) :: eu ( 3 ), dtor type ( FZpointd ), pointer :: FZtmp , FZtmp2 dtor = cPi / 18 0.D0 ! set the file path filepath = trim ( EMsoft_getEMdatapathname ()) // trim ( eulerfile ) filepath = EMsoft_toNativePath ( filepath ) open ( unit = 53 , file = trim ( filepath ), status = 'old' , action = 'read' ) read ( 53 , * ) anglemode read ( 53 , * ) numang ! make sure the linked list is empty if ( associated ( FZlist )) then FZtmp => FZlist % next FZtmp2 => FZlist do deallocate ( FZtmp2 ) if (. not . associated ( FZtmp ) ) EXIT FZtmp2 => FZtmp FZtmp => FZtmp % next end do nullify ( FZlist ) end if ! allocate the linked list allocate ( FZlist ) FZtmp => FZlist do i = 1 , numang read ( 53 , * ) eu ( 1 : 3 ) FZtmp % rod = eu2ro ( eu * dtor ) FZcnt = FZcnt + 1 allocate ( FZtmp % next ) FZtmp => FZtmp % next nullify ( FZtmp % next ) end do close ( unit = 53 , status = 'keep' ) end subroutine getEulersfromFile !-------------------------------------------------------------------------- ! ! FUNCTION: IsinsideMFZ ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief does Rodrigues point lie inside the relevant Mackenzie (disorientation) FZ ! !> @param rod Rodrigues coordinates  (double precision) !> @param MFZtype MFZ type !> @param MFZorder MFZ order ! !> @date 09/09/16 MDG 1.0 new routine !-------------------------------------------------------------------------- recursive function IsinsideMFZ ( rod , MFZtype , MFZorder ) result ( insideMFZ ) !DEC$ ATTRIBUTES DLLEXPORT :: IsinsideMFZ use constants IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: rod ( 4 ) integer ( kind = irg ), INTENT ( IN ) :: MFZtype integer ( kind = irg ), INTENT ( IN ) :: MFZorder logical :: insideMFZ select case ( MFZtype ) case ( 0 ) insideMFZ = . TRUE . ! all points are inside the FZ case ( 1 ) insideMFZ = insideCyclicFZ ( rod , MFZtype , MFZorder ) ! infinity is checked inside this function case ( 2 ) if ( rod ( 4 ). ne . inftyd ) insideMFZ = insideDihedralMFZ ( rod , MFZorder ) case ( 3 ) if ( rod ( 4 ). ne . inftyd ) insideMFZ = insideCubicMFZ ( rod , 'tet' ) case ( 4 ) if ( rod ( 4 ). ne . inftyd ) insideMFZ = insideCubicMFZ ( rod , 'oct' ) end select end function IsinsideMFZ !-------------------------------------------------------------------------- ! ! FUNCTION: insideCubicMFZ ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief does Rodrigues point lie inside cubic MacKenzie FZ (octahedral or tetrahedral)? ! !> @param rod Rodrigues coordinates  (double precision) !> @param ot 'oct' or 'tet', depending on symmetry ! !> @date 09/09/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive function insideCubicMFZ ( rod , ot ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: insideCubicMFZ use constants IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: rod ( 4 ) character ( 3 ), INTENT ( IN ) :: ot logical :: res , c0 , c1 , c2 , c3 real ( kind = dbl ) :: r ( 3 ) res = . FALSE . ! first of all, we need to be inside the regular FZ c0 = insideCubicFz ( rod , ot ) r ( 1 : 3 ) = rod ( 1 : 3 ) * rod ( 4 ) if ( ot . eq . 'oct' ) then c1 = ( c0 . and .( r ( 3 ). ge . 0.D0 )) c2 = ( c1 . and .( r ( 2 ). ge . r ( 3 ))) c3 = ( c2 . and .( r ( 1 ). ge . r ( 2 ))) else c1 = ( c0 . and .( minval ( r ). ge . 0.D0 )) ! in the first octant if ( r ( 1 ). le . r ( 2 )) then c3 = ( c1 . and .( r ( 3 ). le . r ( 1 ))) else c3 = ( c1 . and .( r ( 3 ). le . r ( 2 ))) end if end if res = c3 end function insideCubicMFZ !-------------------------------------------------------------------------- ! ! FUNCTION: insideDihedralMFZ ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief does Rodrigues point lie inside cubic MacKenzie FZ (octahedral or tetrahedral)? ! !> @param rod Rodrigues coordinates  (double precision) !> @param ot 'oct' or 'tet', depending on symmetry ! !> @date 09/09/16 MDG 1.0 original !> @date 09/15/16 MDG 1.0 completed all orders !-------------------------------------------------------------------------- recursive function insideDihedralMFZ ( rod , MFZorder ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: insideDihedralMFZ use constants IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: rod ( 4 ) integer , INTENT ( IN ) :: MFZorder logical :: res , c0 , c1 , c2 , c3 real ( kind = dbl ) :: r ( 3 ) real ( kind = dbl ), parameter :: v = 0.57735026918962584D0 ! v = 1.0/dsqrt(3.D0) res = . FALSE . ! first of all, we need to be inside the regular FZ c0 = insideDihedralFZ ( rod , MFZorder ) r ( 1 : 3 ) = rod ( 1 : 3 ) * rod ( 4 ) if ( c0 ) then select case ( MFZorder ) case ( 2 ) c2 = ( minval ( r ). ge . 0.D0 ) case ( 3 ) c1 = ( minval ( ( / r ( 1 ), r ( 3 ) / ) ). ge . 0.D0 ) c2 = ( c1 . and .( r ( 1 ). ge . dabs ( r ( 2 )) * v )) case ( 4 ) c1 = ( minval ( r ). ge . 0.D0 ) c2 = ( c1 . and .( r ( 1 ). ge . r ( 2 ))) case ( 6 ) c1 = ( minval ( r ). ge . 0.D0 ) c2 = ( c1 . and .( r ( 1 ). ge . r ( 2 ) * v )) end select end if res = c2 end function insideDihedralMFZ end module so3","tags":"","loc":"sourcefile/so3.f90.html","title":"so3.f90 – Fortran Program"},{"text":"Files Dependent On This One sourcefile~~stemmodule.f90~~AfferentGraph sourcefile~stemmodule.f90 STEMmodule.f90 sourcefile~dispfield.f90 dispfield.f90 sourcefile~stemmodule.f90->sourcefile~dispfield.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules STEMmodule Source Code STEMmodule.f90 Source Code ! ################################################################### ! Copyright (c) 2013-2014, Marc De Graef/Carnegie Mellon University ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without modification, are ! permitted provided that the following conditions are met: ! !     - Redistributions of source code must retain the above copyright notice, this list !        of conditions and the following disclaimer. !     - Redistributions in binary form must reproduce the above copyright notice, this !        list of conditions and the following disclaimer in the documentation and/or !        other materials provided with the distribution. !     - Neither the names of Marc De Graef, Carnegie Mellon University nor the names !        of its contributors may be used to endorse or promote products derived from !        this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE ! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ################################################################### !-------------------------------------------------------------------------- ! EMsoft:STEMmodule.f90 !-------------------------------------------------------------------------- ! ! MODULE: STEMmodule ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief Provides routines to handle the STEM detector geometry and weightfactors. ! !> @date   04/29/11 MDG 1.0 original !> @date   06/12/13 MDG 2.0 rewrite !-------------------------------------------------------------------------- module STEMmodule use local use typedefs contains !-------------------------------------------------------------------------- ! ! SUBROUTINE: init_STEM ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief initialize the weight factors for the systematic row case. ! !> @param STEM STEM structure !> @param cell unit cell pointer !> @param nn number of beams !> @param g systematic row basic vector ! !> @date   04/29/11 MDG 1.0 original !> @date   06/12/13 MDG 2.0 rewrite !> @date   06/09/14 MDG 3.0 added STEM and cell arguments !-------------------------------------------------------------------------- recursive subroutine init_STEM ( STEM , cell , nn , g ) !DEC$ ATTRIBUTES DLLEXPORT :: init_STEM use io use crystal use diffraction IMPLICIT NONE type ( STEMtype ), INTENT ( INOUT ) :: STEM type ( unitcell ), pointer :: cell integer ( kind = irg ), INTENT ( IN ) :: nn integer ( kind = irg ), INTENT ( IN ) :: g ( 3 ) integer ( kind = irg ) :: i , j , n , ira , jj , k , kk , iCL real ( kind = sgl ) :: glen , thb , alp , omega_c , omega_min , omega_max , omega , a , b , c , th , dom , p , q , dr , dx real ( kind = sgl ), parameter :: cPi = 3.141592654 ! these are only used to debug this routine real ( kind = sgl ), allocatable :: thetar (:), outar (:,:,:) logical :: debug = . FALSE ., diffappresent = . FALSE ., apinBF = . FALSE . , apinADF = . FALSE . ! this routine initializes the excitation error arrays and the weight-factor arrays for systematic row STEM signals ! we'll assume that the central beam is centered on the BF detector; then we can ! compute the complete geometry by working in mrad units throughout. ! allocate the excitation error array areal(1..nn,1..STEM%numberofsvalues) allocate ( STEM % sgarray ( nn , STEM % numberofsvalues )) ! determine the lower and upper bounds of the excitation error for the fundamental reflection G thb = CalcDiffAngle ( cell , g ( 1 ), g ( 2 ), g ( 3 )) * 0.5 ! Bragg angle in radians ! convert k_t to the alp and omega angles (in radians) glen = CalcLength ( cell , float ( g ), 'r' ) alp = - 2.0 * STEM % kt * thb omega_c = cPi * 0.5 + alp omega_min = omega_c - STEM % beamconvergence / 100 0.0 omega_max = omega_c + STEM % beamconvergence / 100 0.0 ! step size dom = ( omega_max - omega_min ) / float ( STEM % numberofsvalues - 1 ) ! and for each value in between, compute each reflection's excitation error ira = ( nn + 1 ) / 2 do j = 1 , STEM % numberofsvalues ! set omega angle omega = omega_min + float ( j - 1 ) * dom do i = 1 , nn n = - ira + i ! excitation error STEM % sgarray ( nn + 1 - i , j ) = - n * glen * cos ( omega ) - ( 1.0 - sqrt ( 1.0 - ( n * cell % mLambda * glen * sin ( omega )) ** 2 )) / cell % mLambda end do end do if ( debug ) then allocate ( thetar ( 25 )) thetar = 0.0 thetar ( 1 : 7 ) = ( / a , b , c , th , dom , dr , dx / ) end if ! next, we compute the weightfactors, i.e., how much does each excitation error value contribute ! to the BF or ADF signal?  The weight factor is basically the length of the chord across the overlap ! area of the diffraction disk and the detector, which requires a little bit of math to figure out; ! the math employs the concept of the radical line (see mathworld.com section on circle-circle intersections) ! this computation is carried out in mrad units ! allocate ( STEM % BFweightsarray ( nn , STEM % numberofsvalues , STEM % numCL ), STEM % ADFweightsarray ( nn , STEM % numberofsvalues , STEM % numCL )) STEM % BFweightsarray = 0.0 STEM % ADFweightsarray = 0.0 outerCLloop : do iCL = 1 , STEM % numCL ! this is the outer loop over the microscope camera lengths (very long loop !!!) ! fist, convert the detector parameters to mrad units STEM % BFmrad = atan ( STEM % BFradius / STEM % CLarray ( iCL )) * 100 0.0 STEM % ADFimrad = atan ( STEM % ADFinnerradius / STEM % CLarray ( iCL )) * 100 0.0 STEM % ADFomrad = atan ( STEM % ADFouterradius / STEM % CLarray ( iCL )) * 100 0.0 if ( STEM % diffapmrad . ne . 0.0 ) diffappresent = . TRUE . ! then, for each point inside each diffraction disk, determine where it falls with respect to ! the BD and ADF detectors ... Also, look for disk overlaps as they might require amplitudes ! to be added in instead of intensities (for starters, we could just not allow that to happen...) ! rename some variables to short symbols a = STEM % ADFimrad b = STEM % ADFomrad c = STEM % BFmrad th = STEM % beamconvergence n = STEM % numberofsvalues if ( diffappresent ) then dr = STEM % diffapmrad dx = STEM % diffapmcenter end if omega_min = - th omega_max = th dom = 2.0 * th / float ( n - 1 ) if (. not . diffappresent ) then ! there is no diffraction aperture, so compute the regular weight factors ! first, do the math for the g=0 disk  (we're dropping common factors of 2 for the weights) i = ira do j = ( n + 1 ) / 2 , n omega = omega_min + float ( j - 1 ) * dom if ( th . gt . c ) then ! the zero disk is larger than the BF detector, so it (potentially) gives two signals if ( omega . le . c ) STEM % BFweightsarray ( i , j , iCL ) = sqrt ( c ** 2 - omega ** 2 ) if ( th . ge . a ) then ! there's overlap with the ADF detector if ( omega . le . a ) then ! the first part needs to have a bit subtracted STEM % ADFweightsarray ( i , j , iCL ) = sqrt (( th ** 2 - omega ** 2 )) - sqrt (( a ** 2 - omega ** 2 )) else ! the second part does not STEM % ADFweightsarray ( i , j , iCL ) = sqrt (( th ** 2 - omega ** 2 )) end if end if else ! the zero disk is smaller than the BF detector, so only a BF signal STEM % BFweightsarray ( i , j , iCL ) = sqrt (( th ** 2 - omega ** 2 )) end if ! then apply symmetry for the other half of the g=0 disk if ( j . ne .( n + 1 ) / 2 ) then jj = n + 1 - j STEM % BFweightsarray ( i , jj , iCL ) = STEM % BFweightsarray ( i , j , iCL ) STEM % ADFweightsarray ( i , jj , iCL ) = STEM % ADFweightsarray ( i , j , iCL ) end if end do ! that completes the central disk weight factors ! the other disks are quite a bit more difficult to deal with ... there are a lot of possible cases to consider ... do i = ira + 1 , nn ! loop over the positive reflections of the systematic row (the rest follows by symmetry) ! redefine a couple of parameters j = i - ira thb = CalcDiffAngle ( cell , j * g ( 1 ), j * g ( 2 ), j * g ( 3 )) * 100 0.0 ! diffraction angle in mrad omega_min = thb - th omega_max = thb + th ! only used for debugging if ( debug ) thetar ( 7 + j ) = thb ! first check if a part of this disk lies inside the BF detector if ( omega_min . lt . c ) then ! yes, it does, so determine the BF weight factors for this disk if ( omega_max . le . c ) then ! does it lie completely inside the BF detector? do j = 1 , n ! yes it does, so compute all weight factors omega = omega_min + float ( j - 1 ) * dom STEM % BFweightsarray ( i , j , iCL ) = sqrt ( th ** 2 - ( thb - omega ) ** 2 ) STEM % BFweightsarray ( 2 * ira - i , n + 1 - j , iCL ) = STEM % BFweightsarray ( i , j , iCL ) end do else ! no, there's some potential overlap with the ADF detector do j = 1 , n ! once again, there are a few cases omega = omega_min + float ( j - 1 ) * dom ! this is the position p = ( thb ** 2 - th ** 2 + a ** 2 ) * 0.5 / thb ! this is the location of the radical line for the ADF detector q = ( thb ** 2 - th ** 2 + c ** 2 ) * 0.5 / thb ! this is the location of the radical line for the BF detector if ( omega . le . q ) then ! this point contributes to the BF detector STEM % BFweightsarray ( i , j , iCL ) = sqrt ( th ** 2 - ( thb - omega ) ** 2 ) end if if (( omega . gt . q ). and .( omega . le . c )) then ! this point contributes to the BF detector STEM % BFweightsarray ( i , j , iCL ) = sqrt ( c ** 2 - omega ** 2 ) end if if (( omega_max . ge . a ). and .( omega . ge . p ). and .( omega . le . a )) then ! this point contributes to the ADF detector (using radical line position) STEM % ADFweightsarray ( i , j , iCL ) = sqrt ( th ** 2 - ( thb - omega ) ** 2 ) - sqrt ( a ** 2 - omega ** 2 ) end if if (( omega_max . ge . a ). and .( omega . gt . a )) then ! this point lies on the ADF detector STEM % ADFweightsarray ( i , j , iCL ) = sqrt ( th ** 2 - ( thb - omega ) ** 2 ) end if STEM % BFweightsarray ( 2 * ira - i , n + 1 - j , iCL ) = STEM % BFweightsarray ( i , j , iCL ) STEM % ADFweightsarray ( 2 * ira - i , n + 1 - j , iCL ) = STEM % ADFweightsarray ( i , j , iCL ) end do end if else ! no, it does not intersect the BF detector, so this disk can only contribute to the ADF weight factors ! once more there are several cases which we'll treat in increasing value of the position... do j = 1 , n omega = omega_min + float ( j - 1 ) * dom ! this is the position p = ( thb ** 2 - th ** 2 + a ** 2 ) * 0.5 / thb ! this is the location of the radical line for the inner ADF detector edge q = ( thb ** 2 - th ** 2 + b ** 2 ) * 0.5 / thb ! this is the location of the radical line for the outer ADF detector edge if (( omega . lt . a ). and .( omega . ge . p )) then ! inside the inner ADF edge, but close enough to contribute STEM % ADFweightsarray ( i , j , iCL ) = sqrt ( th ** 2 - ( thb - omega ) ** 2 ) - sqrt ( a ** 2 - omega ** 2 ) end if if (( omega . ge . a ). and .( omega_max . le . b )) then ! this point lies on the ADF detector STEM % ADFweightsarray ( i , j , iCL ) = sqrt ( th ** 2 - ( thb - omega ) ** 2 ) end if if (( omega_max . gt . b ). and .( omega . le . q )) then ! this point lies on the ADF detector STEM % ADFweightsarray ( i , j , iCL ) = sqrt ( th ** 2 - ( thb - omega ) ** 2 ) end if if (( omega_max . gt . b ). and .( omega . gt . q ). and .( omega . le . b )) then ! this point contributes to the ADF detector STEM % ADFweightsarray ( i , j , iCL ) = sqrt ( b ** 2 - omega ** 2 ) end if STEM % ADFweightsarray ( 2 * ira - i , n + 1 - j , iCL ) = STEM % ADFweightsarray ( i , j , iCL ) end do end if end do end if ! end of regular weight factors without a diffraction aperture if ( diffappresent ) then ! there is a diffraction aperture, so revisit the weight factors. ! once again, there are many different cases that need to be addressed... ! we do not allow for a diffraction aperture that overlaps the boundary between BF and ADF detectors, ! nor an aperture that lies entirely beyond the ADF detector ! first the BF test if ( (( dx - dr ). gt . - c ). and .(( dx + dr ). lt . c )) apinBF = . TRUE . ! then the ADF detector if ( ((( dx - dr ). gt . - b ). and .(( dx + dr ). lt . - c )) . or .((( dx - dr ). gt . a ). and .(( dx + dr ). lt . b )) ) apinADF = . TRUE . ! if the aperture is outside the ADF detector, or it overlaps the space between the detectors, then abort if ( . not . apinBF . and . . not . apinADF ) then call Message ( 'Please fix input: Diffraction aperture outside BF detector disk or ADF ring !' , frm = \"(A)\" ) stop end if if ( apinBF ) then ! figure out which diffraction disk(s) contribute to the BF detector do i = 1 , nn ! loop over all reflections of the systematic row ! redefine a couple of parameters j = - ( nn - 1 ) / 2 - 1 + i if ( j . ne . 0 ) then thb = ( j / abs ( j )) * CalcDiffAngle ( cell , j * g ( 1 ), j * g ( 2 ), j * g ( 3 )) * 100 0.0 ! diffraction angle in mrad else thb = 0.0 end if ! only used for debugging if ( debug ) thetar ( 7 + i ) = thb omega_min = thb - th omega_max = thb + th ! check whether or not there is any overlap between this disk and the diffraction aperture opening if (( omega_max . lt .( dx - dr )). or .( omega_min . gt .( dx + dr ))) then ! this disks does not fall inside the diffraction aperture STEM % BFweightsarray ( i , 1 : n , iCL ) = 0.0 else ! case 1: dx-dr < omega_min < omega_max < dx+dr if (( omega_max . lt .( dx + dr )). and .( omega_min . gt .( dx - dr ))) then do k = 1 , n omega = omega_min + float ( k - 1 ) * dom kk = k if ( j . lt . 0 ) kk = n + 1 - k STEM % BFweightsarray ( i , kk , iCL ) = sqrt (( th ** 2 - ( thb - omega ) ** 2 )) end do end if ! case 2: omega_min < dx-dr  < dx+dr < omega_max if (( omega_max . gt .( dx + dr )). and .( omega_min . lt .( dx - dr ))) then do k = 1 , n omega = omega_min + float ( k - 1 ) * dom kk = k if ( j . lt . 0 ) kk = n + 1 - k if (( omega . gt . dx - dr ). and .( omega . lt . dx + dr )) then STEM % BFweightsarray ( i , kk , iCL ) = sqrt (( dr ** 2 - ( omega - dx ) ** 2 )) end if end do end if ! case 3: omega_min < dx-dr   < omega_max < dx+dr if (( omega_min . lt .( dx - dr )). and .( omega_max . lt .( dx + dr ))) then p = (( dx - thb ) ** 2 - dr ** 2 + th ** 2 ) / 2.0 / ( dx - thb ) + thb do k = 1 , n omega = omega_min + float ( k - 1 ) * dom kk = k !         if (j.lt.0) kk = n+1-k if (( omega . gt . dx - dr ). and .( omega . le . p )) then STEM % BFweightsarray ( i , kk , iCL ) = sqrt ( dr ** 2 - ( omega - dx ) ** 2 ) end if if (( omega . gt . p ). and .( omega . le . omega_max )) then STEM % BFweightsarray ( i , kk , iCL ) = sqrt (( th ** 2 - ( thb - omega ) ** 2 )) end if end do end if ! case 4:  dx-dr   < omega_min < dx+dr < omega_max if (( omega_min . gt .( dx - dr )). and .( omega_max . gt .( dx + dr ))) then p = (( dx - thb ) ** 2 - th ** 2 + dr ** 2 ) / 2.0 / ( thb - dx ) + dx do k = 1 , n omega = omega_min + float ( k - 1 ) * dom kk = k !        if (j.lt.0) kk = n+1-k if (( omega . gt . p ). and .( omega . le . dx + dr )) then STEM % BFweightsarray ( i , kk , iCL ) = sqrt (( dr ** 2 - ( omega - dx ) ** 2 )) end if if (( omega . gt . omega_min ). and .( omega . le . p )) then STEM % BFweightsarray ( i , kk , iCL ) = sqrt (( th ** 2 - ( thb - omega ) ** 2 )) end if end do end if end if end do ! this completes the BF weight factors when a diffraction aperture is present and apinBF=.TRUE. end if ! next determine the ADF weight factors in the presence of an aperture if ( apinADF ) then ! figure out which diffraction disk(s) contribute to the ADF detector do i = 1 , nn ! loop over all reflections of the systematic row ! redefine a couple of parameters j = - ( nn - 1 ) / 2 - 1 + i if ( j . ne . 0 ) then thb = ( j / abs ( j )) * CalcDiffAngle ( cell , j * g ( 1 ), j * g ( 2 ), j * g ( 3 )) * 100 0.0 ! diffraction angle in mrad else thb = 0.0 end if ! only used for debugging if ( debug ) thetar ( 7 + i ) = thb omega_min = thb - th omega_max = thb + th ! check whether or not there is any overlap between this disk and the diffraction aperture opening if (( omega_max . lt .( dx - dr )). or .( omega_min . gt .( dx + dr ))) then ! this disks does not fall inside the diffraction aperture STEM % ADFweightsarray ( i , 1 : n , iCL ) = 0.0 else ! case 1: dx-dr < omega_min < omega_max < dx+dr if (( omega_max . lt .( dx + dr )). and .( omega_min . gt .( dx - dr ))) then do k = 1 , n omega = omega_min + float ( k - 1 ) * dom kk = k if ( j . lt . 0 ) kk = n + 1 - k STEM % ADFweightsarray ( i , kk , iCL ) = sqrt (( th ** 2 - ( thb - omega ) ** 2 )) end do end if ! case 2: omega_min < dx-dr  < dx+dr < omega_max if (( omega_max . gt .( dx + dr )). and .( omega_min . lt .( dx - dr ))) then do k = 1 , n omega = omega_min + float ( k - 1 ) * dom kk = k if ( j . lt . 0 ) kk = n + 1 - k if (( omega . gt . dx - dr ). and .( omega . lt . dx + dr )) then STEM % ADFweightsarray ( i , kk , iCL ) = sqrt (( dr ** 2 - ( omega - dx ) ** 2 )) end if end do end if ! case 3: omega_min < dx-dr   < omega_max < dx+dr if (( omega_min . lt .( dx - dr )). and .( omega_max . lt .( dx + dr ))) then p = (( dx - thb ) ** 2 - dr ** 2 + th ** 2 ) / 2.0 / ( dx - thb ) + thb do k = 1 , n omega = omega_min + float ( k - 1 ) * dom kk = k !         if (j.lt.0) kk = n+1-k if (( omega . gt . dx - dr ). and .( omega . le . p )) then STEM % ADFweightsarray ( i , kk , iCL ) = sqrt ( dr ** 2 - ( omega - dx ) ** 2 ) end if if (( omega . gt . p ). and .( omega . le . omega_max )) then STEM % ADFweightsarray ( i , kk , iCL ) = sqrt (( th ** 2 - ( thb - omega ) ** 2 )) end if end do end if ! case 4:  dx-dr   < omega_min < dx+dr < omega_max if (( omega_min . gt .( dx - dr )). and .( omega_max . gt .( dx + dr ))) then p = (( dx - thb ) ** 2 - th ** 2 + dr ** 2 ) / 2.0 / ( thb - dx ) + dx do k = 1 , n omega = omega_min + float ( k - 1 ) * dom kk = k !        if (j.lt.0) kk = n+1-k if (( omega . gt . p ). and .( omega . le . dx + dr )) then STEM % ADFweightsarray ( i , kk , iCL ) = sqrt (( dr ** 2 - ( omega - dx ) ** 2 )) end if if (( omega . gt . omega_min ). and .( omega . le . p )) then STEM % ADFweightsarray ( i , kk , iCL ) = sqrt (( th ** 2 - ( thb - omega ) ** 2 )) end if end do end if end if end do ! this completes the ADF weight factors when a diffraction aperture is present and apinADF=.TRUE. end if end if ! if aperture is present end do outerCLloop ! see line 146 ! and the rest is also only used for debugging purposes if ( debug ) then allocate ( outar ( 2 * nn , STEM % numberofsvalues , STEM % numCL )) outar ( 1 : nn , 1 : STEM % numberofsvalues , 1 : STEM % numCL ) = STEM % BFweightsarray ( 1 : nn , 1 : STEM % numberofsvalues , 1 : STEM % numCL ) outar ( nn + 1 : 2 * nn , 1 : STEM % numberofsvalues , 1 : STEM % numCL ) = STEM % ADFweightsarray ( 1 : nn , 1 : STEM % numberofsvalues , 1 : STEM % numCL ) ! to make sure that everything is correct, let's export this array so that we can display it in IDL open ( unit = dataunit , file = 'STEMprofiles.data' , status = 'unknown' , form = 'unformatted' ) write ( unit = dataunit ) nn , STEM % numberofsvalues , STEM % numCL write ( unit = dataunit ) thetar write ( unit = dataunit ) outar close ( unit = dataunit , status = 'keep' ) end if end subroutine init_STEM !-------------------------------------------------------------------------- ! ! SUBROUTINE: init_STEM_ZA ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief initialize weight factors for zone-axis STEM case ! !> @note This will need to be reconsidered when we implement sectored detectors ... ! !> @param STEM STEM structure !> @param cell unit cell pointer !> @param F foil normal !> @param khead top of kvector list !> @param reflist top of reflection list !> @param nn number of reflections ! !> @date   04/29/11 MDG 1.0 original !> @date   06/12/13 MDG 2.0 rewrite !> @date   06/09/14 MDG 3.0 added STEM and cell structures and khead+reflist linked lists !> @date   06/10/14 MDG 3.1 added F, Dyn argument !-------------------------------------------------------------------------- recursive subroutine init_STEM_ZA ( STEM , cell , F , Dyn , khead , reflist , nn ) !DEC$ ATTRIBUTES DLLEXPORT :: init_STEM_ZA use crystal use diffraction use kvectors use gvectors IMPLICIT NONE type ( STEMtype ), INTENT ( INOUT ) :: STEM type ( unitcell ), pointer :: cell real ( kind = dbl ), INTENT ( INOUT ) :: F ( 3 ) type ( DynType ), INTENT ( INOUT ) :: Dyn type ( kvectorlist ), pointer :: khead type ( reflisttype ), pointer :: reflist integer ( kind = irg ), INTENT ( IN ) :: nn integer ( kind = irg ) :: ik , ig , iCL real ( kind = sgl ) :: ll ( 3 ), lpg ( 3 ), gg ( 3 ), glen , gplen , kpg type ( kvectorlist ), pointer :: ktmp type ( reflisttype ), pointer :: rltmpa ! this routine initializes the excitation error arrays and the weight-factor arrays for zone axis STEM signals ! the weightfactors are quite a bit different from the ones for the systematic row case; ! they are simpler in principle, since each point in the diffracted disk can only lie in one ! place, and hence only contributes to one detector.  However, not all points in a disk ! contribute to the same detector...  The length of the vector k_t+g, expressed in mrad, ! is what needs to be compared to the radii of the BF and ADF detectors.  For each incident ! beam direction, we take the tangential component of the wave vector and loop over all ! reflections to compute the relevant angle; this then allows us to assign the weight factors ! which are now either 1 or 0 (so they can be stored as logicals). ! allocate the excitation error array areal(1..nn,1..STEM%numk) allocate ( STEM % sgarray ( nn , STEM % numk )) ! transform the foil normal to real space and normalize call TransSpace ( cell , sngl ( F ), Dyn % FN , 'd' , 'r' ) call NormVec ( cell , Dyn % FN , 'r' ) ! allocate the weight factor arrays, one entry for each beam direction, reflection, and camera length allocate ( STEM % ZABFweightsarray ( nn , STEM % numk , STEM % numCL ), STEM % ZAADFweightsarray ( nn , STEM % numk , STEM % numCL )) STEM % ZABFweightsarray = . FALSE . STEM % ZAADFweightsarray = . FALSE . ! loop over the wave vector linked list ktmp => khead beamloopCL : do ik = 1 , STEM % numk ll = ktmp % kt ! this is the tangential component of the wave vector ! and loop over all reflections rltmpa => reflist % next reflectionloopCL : do ig = 1 , nn gg = float ( rltmpa % hkl ) glen = CalcLength ( cell , gg , 'r' ) lpg = ll + gg ! Laue + g gplen = CalcLength ( cell , lpg , 'r' ) kpg = 200 0.0 * asin ( 0.50 * sngl ( cell % mLambda ) * gplen ) ! 2theta in mrad do iCL = 1 , STEM % numCL STEM % BFmrad = atan ( STEM % BFradius / STEM % CLarray ( iCL )) * 100 0.0 STEM % ADFimrad = atan ( STEM % ADFinnerradius / STEM % CLarray ( iCL )) * 100 0.0 STEM % ADFomrad = atan ( STEM % ADFouterradius / STEM % CLarray ( iCL )) * 100 0.0 if ( kpg . le . STEM % BFmrad ) STEM % ZABFweightsarray ( ig , ik , iCL ) = . TRUE . if (( kpg . ge . STEM % ADFimrad ). AND .( kpg . le . STEM % ADFomrad )) STEM % ZAADFweightsarray ( ig , ik , iCL ) = . TRUE . end do ! loop over camera lengths STEM % sgarray ( ig , ik ) = Calcsg ( cell , gg , sngl ( ktmp % k ), Dyn % FN ) ! and we move to the next reflection in the list rltmpa => rltmpa % next end do reflectionloopCL ktmp => ktmp % next end do beamloopCL ! that's it folks! end subroutine init_STEM_ZA !-------------------------------------------------------------------------- ! ! SUBROUTINE: read_STEM_data ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief read detector and other parameters for the STEM case ! !> @param STEM STEM structure !> @param cell unit cell pointer !> @param F foil normal !> @param Dyn dynamical scattering structure !> @param STEMnmlfile filename of the namelist file !> @param khead top of kvector list !> @param reflist top of reflection list !> @param geometry 'SR' for systematic row or 'ZA' for zone axis !> @param nn number of reflections !> @param g fundamental g-vector for systematic row !> @param kt tangential wave vector component !> @param numk number of distinct wave vectors (optional) !> @param beamdiv beam divergence parameter (optional) ! !> @date   04/29/11 MDG 1.0 original !> @date   06/12/13 MDG 2.0 rewrite !> @date   11/26/13 MDG 2.1 made geometry an input parameter instead of part of the STEMdata namelist !> @date   06/10/14 MDG 3.0 added STEM, cell, foil, and Dyn arguments !-------------------------------------------------------------------------- recursive subroutine read_STEM_data ( STEM , cell , F , Dyn , STEMnmlfile , khead , reflist , geometry , nn , g , kt , numk , beamdiv ) !DEC$ ATTRIBUTES DLLEXPORT :: read_STEM_data use io use files use kvectors use gvectors IMPLICIT NONE type ( STEMtype ), INTENT ( INOUT ) :: STEM type ( unitcell ), pointer :: cell real ( kind = dbl ), INTENT ( INOUT ) :: F ( 3 ) type ( DynType ), INTENT ( INOUT ) :: Dyn character ( fnlen ), INTENT ( IN ) :: STEMnmlfile type ( kvectorlist ), pointer :: khead type ( reflisttype ), pointer :: reflist character ( 2 ), INTENT ( IN ) :: geometry ! 'SR' or 'ZA' integer ( kind = irg ), INTENT ( IN ) :: nn integer ( kind = irg ), INTENT ( IN ) :: g ( 3 ) real ( kind = sgl ), INTENT ( IN ) :: kt integer ( kind = irg ), INTENT ( IN ), OPTIONAL :: numk real ( kind = sgl ), INTENT ( OUT ), OPTIONAL :: beamdiv integer ( kind = irg ) :: numberofsvalues , numCL real ( kind = sgl ) :: BFradius , ADFinnerradius , ADFouterradius , beamconvergence , cameralength , & diffaprad , diffapcenter , CLarray ( 20 ) character ( fnlen ) :: weightoutput namelist / STEMdata / BFradius , ADFinnerradius , ADFouterradius , cameralength , numCL , & beamconvergence , numberofsvalues , diffaprad , diffapcenter , weightoutput , CLarray ! set default values (based on OSU Tecnai F20) BFradius = 3.5 ! mm ADFinnerradius = 3.5 ! mm ADFouterradius = 1 0.0 ! mm cameralength = 10 0.0 ! mm numCL = 0 ! number of camera lengths to be used  (if zero, then use cameralength instead) CLarray = 0.0 ! values for the camera lengths beamconvergence = 2.0 ! mrad numberofsvalues = 33 ! integer diffaprad = 0.0 ! diffraction aperture radius in mrad, 0.0 if no aperture is present diffapcenter = 0.0 ! position of center of diffraction aperture in mrad along systematic row weightoutput = '' ! string with filename root for graphical output of weight profiles, empty if not needed ! read the namelist file call Message ( 'opening ' // trim ( STEMnmlfile ), frm = \"(/A)\" ) open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( STEMnmlfile )), DELIM = 'APOSTROPHE' ) read ( UNIT = dataunit , NML = STEMdata ) close ( UNIT = dataunit ) if ( PRESENT ( beamdiv )) beamdiv = beamconvergence ! set the parameters STEM % BFradius = BFradius STEM % ADFinnerradius = ADFinnerradius STEM % ADFouterradius = ADFouterradius STEM % kt = kt STEM % cameralength = cameralength STEM % beamconvergence = beamconvergence if ( numCL . ne . 0 ) then STEM % numCL = numCL STEM % CLarray = CLarray else STEM % numCL = 1 STEM % CLarray = cameralength end if ! make sure the number of s values is an odd number if ( mod ( numberofsvalues , 2 ). eq . 0 ) numberofsvalues = numberofsvalues + 1 STEM % numberofsvalues = numberofsvalues STEM % diffapmrad = diffaprad STEM % diffapmcenter = diffapcenter STEM % weightoutput = weightoutput STEM % geometry = geometry if ( PRESENT ( numk )) then STEM % numk = numk else STEM % numk = STEM % numberofsvalues end if ! and initialize all other STEM related arrays if (. not . PRESENT ( beamdiv )) then if ( geometry . eq . 'SR' ) then call init_STEM ( STEM , cell , nn , g ) else call init_STEM_ZA ( STEM , cell , F , Dyn , khead , reflist , nn ) end if end if end subroutine read_STEM_data end module STEMmodule","tags":"","loc":"sourcefile/stemmodule.f90.html","title":"STEMmodule.f90 – Fortran Program"},{"text":"Files Dependent On This One sourcefile~~timing.f90~~AfferentGraph sourcefile~timing.f90 timing.f90 sourcefile~dispfield.f90 dispfield.f90 sourcefile~timing.f90->sourcefile~dispfield.f90 sourcefile~emdymod.f90 EMdymod.f90 sourcefile~timing.f90->sourcefile~emdymod.f90 sourcefile~simulated_annealing.f90 simulated_annealing.f90 sourcefile~emdymod.f90->sourcefile~simulated_annealing.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Modules timing Source Code timing.f90 Source Code ! ################################################################### ! Copyright (c) 2013-2014, Marc De Graef/Carnegie Mellon University ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without modification, are ! permitted provided that the following conditions are met: ! !     - Redistributions of source code must retain the above copyright notice, this list !        of conditions and the following disclaimer. !     - Redistributions in binary form must reproduce the above copyright notice, this !        list of conditions and the following disclaimer in the documentation and/or !        other materials provided with the distribution. !     - Neither the names of Marc De Graef, Carnegie Mellon University nor the names !        of its contributors may be used to endorse or promote products derived from !        this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" ! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE ! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER ! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, ! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE ! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ################################################################### !-------------------------------------------------------------------------- ! EMsoft:timing.f90 !-------------------------------------------------------------------------- ! ! MODULE: timing ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief Provides a few timing routines ! !> @date   11/19/01 MDG 1.0 original !> @date   06/04/13 MDG 2.0 rewrite !> @date   06/05/14 MDG 3.0 replaced globals by timetype argument !-------------------------------------------------------------------------- module timing use local use typedefs use io IMPLICIT NONE contains !-------------------------------------------------------------------------- ! ! SUBROUTINE: Time_tick ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief start time recording using system_clock ! !> @date   03/17/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive subroutine Time_tick ( t ) !DEC$ ATTRIBUTES DLLEXPORT :: Time_tick IMPLICIT NONE integer , intent ( OUT ) :: t call system_clock ( t ) end subroutine Time_tick !-------------------------------------------------------------------------- ! ! FUNCTION: Time_tock ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief stop time recording using system_clock ! !> @date   03/17/16 MDG 1.0 original !-------------------------------------------------------------------------- recursive function Time_tock ( t ) result ( tock ) !DEC$ ATTRIBUTES DLLEXPORT :: Time_tock IMPLICIT NONE integer ( kind = irg ), intent ( in ) :: t integer ( kind = irg ) :: now , clock_rate integer ( kind = irg ) :: tock call system_clock ( now , clock_rate ) tock = real ( now - t ) / real ( clock_rate ) end function Time_tock !-------------------------------------------------------------------------- ! ! SUBROUTINE: Time_reset ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief reset time recording ! !> @date   06/04/01 MDG 1.0 original !> @date   06/04/13 MDG 2.0 rewrite !> @date   06/05/14 MDG 3.0 added TT as argument !-------------------------------------------------------------------------- recursive subroutine Time_reset ( TT ) !DEC$ ATTRIBUTES DLLEXPORT :: Time_reset IMPLICIT NONE type ( timetype ), INTENT ( INOUT ) :: TT TT % TIME_t_count = 0.0 TT % TIME_unit_count = 0.0 TT % TIME_count = 0 TT % TIME_newcount = 0 TT % TIME_count_rate = 0 TT % TIME_count_max = HUGE ( 0 ) TT % TIME_old = 0 TT % TIME_loops = 0 end subroutine Time_reset !-------------------------------------------------------------------------- ! ! SUBROUTINE: Time_report ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief report time recording ! !> @param TT time structure !> @param interval interval for reporting !> @param stdout optional output unit identifier ! !> @date   06/04/01 MDG 1.0 original !> @date   06/04/13 MDG 2.0 rewrite !> @date   06/05/14 MDG 3.0 added TT as argument !-------------------------------------------------------------------------- recursive subroutine Time_report ( TT , interval , stdout ) !DEC$ ATTRIBUTES DLLEXPORT :: Time_report IMPLICIT NONE type ( timetype ), INTENT ( INOUT ) :: TT real ( kind = sgl ), intent ( IN ) :: interval integer ( kind = irg ), OPTIONAL , INTENT ( IN ) :: stdout integer ( kind = irg ) :: std std = 6 if ( PRESENT ( stdout )) std = stdout TT % TIME_interval = interval TT % TIME_fraction = TT % TIME_interval call Message ( 'Starting computation' , frm = \"(/A)\" , stdout = std ) end subroutine Time_report !-------------------------------------------------------------------------- ! ! SUBROUTINE: Time_start ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief start time recording ! !> @date   06/04/01 MDG 1.0 original !> @date   06/04/13 MDG 2.0 rewrite !> @date   06/05/14 MDG 3.0 added TT as argument !-------------------------------------------------------------------------- recursive subroutine Time_start ( TT ) !DEC$ ATTRIBUTES DLLEXPORT :: Time_start IMPLICIT NONE type ( timetype ), INTENT ( INOUT ) :: TT ! start the timing of the computation call Time_reset ( TT ) call system_clock ( TT % TIME_count , TT % TIME_count_rate , TT % TIME_count_max ) end subroutine Time_start !-------------------------------------------------------------------------- ! ! SUBROUTINE: Time_estimate ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief estimare remaining time ! !> @param TT time structure !> @param numk number of idividual computations !> @param stdout optional output unit identifier ! !> @date   06/04/01 MDG 1.0 original !> @date   06/04/13 MDG 2.0 rewrite !> @date   06/05/14 MDG 3.0 added TT as argument !-------------------------------------------------------------------------- recursive subroutine Time_estimate ( TT , numk , stdout ) !DEC$ ATTRIBUTES DLLEXPORT :: Time_estimate IMPLICIT NONE type ( timetype ), INTENT ( INOUT ) :: TT integer ( kind = irg ), intent ( IN ) :: numk integer ( kind = irg ), INTENT ( IN ), OPTIONAL :: stdout integer ( kind = irg ) :: TIME_nc , std real ( kind = sgl ) :: io_real ( 1 ) std = 6 if ( PRESENT ( stdout )) std = stdout ! get the current time call system_clock ( TIME_nc , TT % TIME_count_rate , TT % TIME_count_max ) TT % TIME_newcount = TIME_nc TT % TIME_t_count = float ( TT % TIME_newcount - TT % TIME_count ) / float ( TT % TIME_count_rate ) TT % TIME_unit_count = TT % TIME_t_count io_real ( 1 ) = TT % TIME_unit_count call WriteValue ( ' Time for first computation step [s, typically overestimate] :' , io_real , 1 , frm = \"(F10.5)\" , stdout = std ) call Message ( '  Anticipated total computation time :' , frm = \"(A$)\" , stdout = std ) call PrintTime ( TT % TIME_unit_count * float ( numk ), stdout = std ) end subroutine Time_estimate !-------------------------------------------------------------------------- ! ! SUBROUTINE: Time_estimate ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief estimate remaining time ! !> @param TT time structure !> @param ik current computation !> @param numk number of idividual computations !> @param stdout optional output unit identifier ! !> @date   06/04/01 MDG 1.0 original !> @date   06/04/13 MDG 2.0 rewrite !> @date   06/05/14 MDG 3.0 added TT as argument !-------------------------------------------------------------------------- recursive subroutine Time_remaining ( TT , ik , numk , stdout ) !DEC$ ATTRIBUTES DLLEXPORT :: Time_remaining IMPLICIT NONE type ( timetype ), INTENT ( INOUT ) :: TT integer ( kind = irg ), intent ( IN ) :: ik integer ( kind = irg ), intent ( IN ) :: numk integer ( kind = irg ), INTENT ( IN ), OPTIONAL :: stdout integer ( kind = irg ) :: TIME_nc , io_int ( 1 ), std real ( kind = sgl ) :: io_real ( 1 ) std = 6 if ( PRESENT ( stdout )) std = stdout TT % TIME_fraction = TT % TIME_fraction + TT % TIME_interval ! get the current time call system_clock ( TIME_nc , TT % TIME_count_rate , TT % TIME_count_max ) ! correct for the resetting of TIME_nc when TIME_count_max is reached if ( TIME_nc . lt . TT % TIME_newcount ) then ! we've looped through the entire cycle TT % TIME_loops = TT % TIME_loops + 1 TT % TIME_count = 0 end if TT % TIME_newcount = TIME_nc ! and print it TT % TIME_t_count = ( float ( TT % TIME_loops ) * float ( TT % TIME_count_max ) + float ( TT % TIME_newcount - TT % TIME_count )) / float ( TT % TIME_count_rate ) ! reset the time per unit TT % TIME_unit_count = TT % TIME_t_count / float ( ik ) ! print estimated remaining time io_int ( 1 ) = nint ( 10 0.0 * TT % TIME_t_count / ( TT % TIME_t_count + TT % TIME_unit_count * ( float ( numk ) - float ( ik )))) call WriteValue ( ' ' , io_int , 1 , frm = \"(1x,I3,' % completed; '$)\" , stdout = std ) io_real ( 1 ) = TT % TIME_t_count call WriteValue ( ' Total computation time [s] ' , io_real , 1 , frm = \"(F$)\" , stdout = std ) call Message ( ';  Estimated remaining time : ' , frm = \"(A$)\" , stdout = std ) call PrintTime ( TT % TIME_unit_count * ( float ( numk ) - float ( ik )), stdout = std ) ! end subroutine Time_remaining !-------------------------------------------------------------------------- ! ! SUBROUTINE: PrintTime ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief print  time ! !> @param tm time variable !> @param stdout optional output unit identifier ! !> @date   06/04/01 MDG 1.0 original !> @date   06/04/13 MDG 2.0 rewrite !> @date   06/05/14 MDG 3.0 changed IO !-------------------------------------------------------------------------- recursive subroutine PrintTime ( tm , stdout ) !DEC$ ATTRIBUTES DLLEXPORT :: PrintTime IMPLICIT NONE real ( kind = sgl ), INTENT ( IN ) :: tm integer ( kind = irg ), INTENT ( IN ), OPTIONAL :: stdout integer ( kind = irg ) :: days , hours , minutes , seconds , io_int ( 4 ), std real ( kind = sgl ) :: secs std = 6 if ( PRESENT ( stdout )) std = stdout secs = tm days = 0 hours = 0 minutes = 0 if ( secs . gt . 8640 0.0 ) then days = int ( secs ) / 86400 secs = mod ( secs , 8640 0.0 ) end if if ( secs . gt . 360 0.0 ) then hours = int ( secs ) / 3600 secs = mod ( secs , 360 0.0 ) end if if ( secs . gt . 6 0.0 ) then minutes = int ( secs ) / 60 secs = mod ( secs , 6 0.0 ) end if seconds = int ( secs ) io_int ( 1 : 4 ) = ( / days , hours , minutes , seconds / ) call WriteValue ( ' ' , io_int , 4 , frm = \"(1x,I3,' d,',I3,' h,',I3,' m,',I3,' s')\" , stdout = std ) end subroutine PrintTime !-------------------------------------------------------------------------- ! ! SUBROUTINE: Time_stop ! !> @author Marc De Graef, Carnegie Mellon University ! !> @brief stop time recording ! !> @param TT time structure !> @param numk total number of computations !> @param stdout optional output unit identifier ! !> @date   06/04/01 MDG 1.0 original !> @date   06/04/13 MDG 2.0 rewrite !> @date   06/05/14 MDG 3.0 added TT; changed IO !-------------------------------------------------------------------------- recursive subroutine Time_stop ( TT , numk , stdout ) !DEC$ ATTRIBUTES DLLEXPORT :: Time_stop IMPLICIT NONE type ( timetype ), INTENT ( INOUT ) :: TT integer ( kind = irg ), INTENT ( IN ) :: numk integer ( kind = irg ), INTENT ( IN ), OPTIONAL :: stdout real ( kind = sgl ) :: io_real ( 1 ) integer ( kind = irg ) :: std std = 6 if ( PRESENT ( stdout )) std = stdout call system_clock ( TT % TIME_newcount , TT % TIME_count_rate , TT % TIME_count_max ) call Message ( '  Total computation time [s] ' , frm = \"(A$)\" , stdout = std ) call PrintTime (( float ( TT % TIME_loops ) * float ( TT % TIME_count_max ) + float ( TT % TIME_newcount - TT % TIME_count )) / float ( TT % TIME_count_rate )) io_real ( 1 ) = float ( TT % TIME_loops ) * float ( TT % TIME_count_max ) + float ( TT % TIME_newcount - TT % TIME_count ) io_real ( 1 ) = io_real ( 1 ) / float ( TT % TIME_count_rate ) / float ( numk ) call WriteValue ( ' Time per step/pixel [s] ' , io_real , 1 , frm = \"(F)\" , stdout = std ) end subroutine Time_stop end module timing","tags":"","loc":"sourcefile/timing.f90.html","title":"timing.f90 – Fortran Program"},{"text":"type, public :: LambertParametersType Variables Pi iPi sPi sPio2 sPi2 srt isrt alpha rtt prea preb prec pred pree pref preg a ap sc beta R1 r2 r22 pi12 pi8 prek r24 tfit BP Source Code LambertParametersType Components Type Visibility Attributes Name Initial real(kind=dbl), public :: Pi = 3.141592653589793D0 real(kind=dbl), public :: iPi = 0.318309886183791D0 real(kind=dbl), public :: sPi = 1.772453850905516D0 real(kind=dbl), public :: sPio2 = 1.253314137315500D0 real(kind=dbl), public :: sPi2 = 0.886226925452758D0 real(kind=dbl), public :: srt = 0.86602540378D0 real(kind=dbl), public :: isrt = 0.57735026919D0 real(kind=dbl), public :: alpha = 1.346773687088598D0 real(kind=dbl), public :: rtt = 1.732050807568877D0 real(kind=dbl), public :: prea = 0.525037567904332D0 real(kind=dbl), public :: preb = 1.050075135808664D0 real(kind=dbl), public :: prec = 0.906899682117109D0 real(kind=dbl), public :: pred = 2.094395102393195D0 real(kind=dbl), public :: pree = 0.759835685651593D0 real(kind=dbl), public :: pref = 1.381976597885342D0 real(kind=dbl), public :: preg = 1.5551203015562141D0 real(kind=dbl), public :: a = 1.925749019958253D0 real(kind=dbl), public :: ap = 2.145029397111025D0 real(kind=dbl), public :: sc = 0.897772786961286D0 real(kind=dbl), public :: beta = 0.962874509979126D0 real(kind=dbl), public :: R1 = 1.330670039491469D0 real(kind=dbl), public :: r2 = 1.414213562373095D0 real(kind=dbl), public :: r22 = 0.707106781186547D0 real(kind=dbl), public :: pi12 = 0.261799387799149D0 real(kind=dbl), public :: pi8 = 0.392699081698724D0 real(kind=dbl), public :: prek = 1.643456402972504D0 real(kind=dbl), public :: r24 = 4.898979485566356D0 real(kind=dbl), public :: tfit (21) = (/0.9999999999999968D0, -0.49999999999986866D0, -0.025000000000632055D0, -0.003928571496460683D0, -0.0008164666077062752D0, -0.00019411896443261646D0, -0.00004985822229871769D0, -0.000014164962366386031D0, -1.9000248160936107D-6, -5.72184549898506D-6, 7.772149920658778D-6, -0.00001053483452909705D0, 9.528014229335313D-6, -5.660288876265125D-6, 1.2844901692764126D-6, 1.1255185726258763D-6, -1.3834391419956455D-6, 7.513691751164847D-7, -2.401996891720091D-7, 4.386887017466388D-8, -3.5917775353564864D-9/) real(kind=dbl), public :: BP (6) = (/0.D0, 1.D0, 0.577350269189626D0, 0.414213562373095D0, 0.D0, 0.267949192431123D0/) Source Code type LambertParametersType real ( kind = dbl ) :: Pi = 3.141592653589793D0 !  pi real ( kind = dbl ) :: iPi = 0.318309886183791D0 !  1/pi real ( kind = dbl ) :: sPi = 1.772453850905516D0 !  sqrt(pi) real ( kind = dbl ) :: sPio2 = 1.253314137315500D0 !  sqrt(pi/2) real ( kind = dbl ) :: sPi2 = 0.886226925452758D0 !  sqrt(pi)/2 real ( kind = dbl ) :: srt = 0.86602540378D0 !  sqrt(3)/2 real ( kind = dbl ) :: isrt = 0.57735026919D0 !  1/sqrt(3) real ( kind = dbl ) :: alpha = 1.346773687088598D0 !  sqrt(pi)/3&#94;(1/4) real ( kind = dbl ) :: rtt = 1.732050807568877D0 !  sqrt(3) real ( kind = dbl ) :: prea = 0.525037567904332D0 !  3&#94;(1/4)/sqrt(2pi) real ( kind = dbl ) :: preb = 1.050075135808664D0 !  3&#94;(1/4)sqrt(2/pi) real ( kind = dbl ) :: prec = 0.906899682117109D0 !  pi/2sqrt(3) real ( kind = dbl ) :: pred = 2.094395102393195D0 !  2pi/3 real ( kind = dbl ) :: pree = 0.759835685651593D0 !  3&#94;(-1/4) real ( kind = dbl ) :: pref = 1.381976597885342D0 !  sqrt(6/pi) real ( kind = dbl ) :: preg = 1.5551203015562141D0 ! 2sqrt(pi)/3&#94;(3/4) ! the following constants are used for the cube to quaternion hemisphere mapping real ( kind = dbl ) :: a = 1.925749019958253D0 ! pi&#94;(5/6)/6&#94;(1/6) real ( kind = dbl ) :: ap = 2.145029397111025D0 ! pi&#94;(2/3) real ( kind = dbl ) :: sc = 0.897772786961286D0 ! a/ap real ( kind = dbl ) :: beta = 0.962874509979126D0 ! pi&#94;(5/6)/6&#94;(1/6)/2 real ( kind = dbl ) :: R1 = 1.330670039491469D0 ! (3pi/4)&#94;(1/3) real ( kind = dbl ) :: r2 = 1.414213562373095D0 ! sqrt(2) real ( kind = dbl ) :: r22 = 0.707106781186547D0 ! 1/sqrt(2) real ( kind = dbl ) :: pi12 = 0.261799387799149D0 ! pi/12 real ( kind = dbl ) :: pi8 = 0.392699081698724D0 ! pi/8 real ( kind = dbl ) :: prek = 1.643456402972504D0 ! R1 2&#94;(1/4)/beta real ( kind = dbl ) :: r24 = 4.898979485566356D0 ! sqrt(24) !       real(kind=dbl)          :: tfit(16) = (/1.0000000000018852D0, -0.5000000002194847D0, & !                                            -0.024999992127593126D0, - 0.003928701544781374D0, & !                                            -0.0008152701535450438D0, - 0.0002009500426119712D0, & !                                            -0.00002397986776071756D0, - 0.00008202868926605841D0, & !                                            +0.00012448715042090092D0, - 0.0001749114214822577D0, & !                                            +0.0001703481934140054D0, - 0.00012062065004116828D0, & !                                            +0.000059719705868660826D0, - 0.00001980756723965647D0, & !                                            +0.000003953714684212874D0, - 0.00000036555001439719544D0 /) ! a more accurate fit, up to order 40  [MDG, 03/28/16] real ( kind = dbl ) :: tfit ( 21 ) = ( / 0.9999999999999968D0 , - 0.49999999999986866D0 , & - 0.025000000000632055D0 , - 0.003928571496460683D0 , & - 0.0008164666077062752D0 , - 0.00019411896443261646D0 , & - 0.00004985822229871769D0 , - 0.000014164962366386031D0 , & - 1.9000248160936107D-6 , - 5.72184549898506D-6 , & 7.772149920658778D-6 , - 0.00001053483452909705D0 , & 9.528014229335313D-6 , - 5.660288876265125D-6 , & 1.2844901692764126D-6 , 1.1255185726258763D-6 , & - 1.3834391419956455D-6 , 7.513691751164847D-7 , & - 2.401996891720091D-7 , 4.386887017466388D-8 , & - 3.5917775353564864D-9 / ) real ( kind = dbl ) :: BP ( 6 ) = ( / 0.D0 , 1.D0 , 0.577350269189626D0 , 0.414213562373095D0 , 0.D0 , & 0.267949192431123D0 / ) ! used for Fundamental Zone determination in so3 module end type LambertParametersType","tags":"","loc":"type/lambertparameterstype.html","title":"LambertParametersType – Fortran Program "},{"text":"type, public :: YDtype Variables burg burgd u un g gn id jd zu bs be bx beta alpha ca sa ta cota a_dc a_id a_di top bottom sig Source Code YDtype Components Type Visibility Attributes Name Initial real(kind=sgl), public :: burg (3) real(kind=sgl), public :: burgd (3) real(kind=sgl), public :: u (3) real(kind=sgl), public :: un (3) real(kind=sgl), public :: g (3) real(kind=sgl), public :: gn (3) real(kind=sgl), public :: id real(kind=sgl), public :: jd real(kind=sgl), public :: zu real(kind=sgl), public :: bs real(kind=sgl), public :: be real(kind=sgl), public :: bx real(kind=sgl), public :: beta real(kind=sgl), public :: alpha real(kind=sgl), public :: ca real(kind=sgl), public :: sa real(kind=sgl), public :: ta real(kind=sgl), public :: cota real(kind=sgl), public :: a_dc (3,3) real(kind=sgl), public :: a_id (3,3) real(kind=sgl), public :: a_di (3,3) real(kind=sgl), public :: top (3) real(kind=sgl), public :: bottom (3) real(kind=sgl), public :: sig Source Code type YDtype real ( kind = sgl ) :: burg ( 3 ), burgd ( 3 ), u ( 3 ), un ( 3 ), g ( 3 ), gn ( 3 ), id , jd , zu , bs , be , bx , beta real ( kind = sgl ) :: alpha , ca , sa , ta , cota , a_dc ( 3 , 3 ), a_id ( 3 , 3 ), a_di ( 3 , 3 ), top ( 3 ), bottom ( 3 ), sig end type YDtype","tags":"","loc":"type/ydtype.html","title":"YDtype – Fortran Program "},{"text":"type, public :: MultiPhaseNameListType Variables nthreads dp1file dp2file dp3file outputfile Source Code MultiPhaseNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: nthreads character(len=fnlen), public :: dp1file character(len=fnlen), public :: dp2file character(len=fnlen), public :: dp3file character(len=fnlen), public :: outputfile Source Code type MultiPhaseNameListType integer ( kind = irg ) :: nthreads character ( fnlen ) :: dp1file character ( fnlen ) :: dp2file character ( fnlen ) :: dp3file character ( fnlen ) :: outputfile end type MultiPhaseNameListType","tags":"","loc":"type/multiphasenamelisttype.html","title":"MultiPhaseNameListType – Fortran Program "},{"text":"type, public :: KosselNameListType Variables stdout numthick npix maxHOLZ nthreads k fn voltage dmin convergence startthick thickinc minten xtalname outname Source Code KosselNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: numthick integer(kind=irg), public :: npix integer(kind=irg), public :: maxHOLZ integer(kind=irg), public :: nthreads integer(kind=irg), public :: k (3) integer(kind=irg), public :: fn (3) real(kind=sgl), public :: voltage real(kind=sgl), public :: dmin real(kind=sgl), public :: convergence real(kind=sgl), public :: startthick real(kind=sgl), public :: thickinc real(kind=sgl), public :: minten character(len=fnlen), public :: xtalname character(len=fnlen), public :: outname Source Code type KosselNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numthick integer ( kind = irg ) :: npix integer ( kind = irg ) :: maxHOLZ integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: k ( 3 ) integer ( kind = irg ) :: fn ( 3 ) real ( kind = sgl ) :: voltage real ( kind = sgl ) :: dmin real ( kind = sgl ) :: convergence real ( kind = sgl ) :: startthick real ( kind = sgl ) :: thickinc real ( kind = sgl ) :: minten character ( fnlen ) :: xtalname character ( fnlen ) :: outname end type KosselNameListType","tags":"","loc":"type/kosselnamelisttype.html","title":"KosselNameListType – Fortran Program "},{"text":"type, public :: KosselMasterNameListType Variables stdout numthick npx nthreads voltage dmin startthick thickinc tfraction Kosselmode xtalname outname Source Code KosselMasterNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: numthick integer(kind=irg), public :: npx integer(kind=irg), public :: nthreads real(kind=sgl), public :: voltage real(kind=sgl), public :: dmin real(kind=sgl), public :: startthick real(kind=sgl), public :: thickinc real(kind=sgl), public :: tfraction character(len=6), public :: Kosselmode character(len=fnlen), public :: xtalname character(len=fnlen), public :: outname Source Code type KosselMasterNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numthick integer ( kind = irg ) :: npx integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: voltage real ( kind = sgl ) :: dmin real ( kind = sgl ) :: startthick real ( kind = sgl ) :: thickinc real ( kind = sgl ) :: tfraction character ( 6 ) :: Kosselmode character ( fnlen ) :: xtalname character ( fnlen ) :: outname end type KosselMasterNameListType","tags":"","loc":"type/kosselmasternamelisttype.html","title":"KosselMasterNameListType – Fortran Program "},{"text":"type, public :: MCNameListType Variables stdout numsx primeseed num_el nthreads sig omega EkeV Ehistmin Ebinsize depthmax depthstep MCmode xtalname dataname Source Code MCNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: numsx integer(kind=irg), public :: primeseed integer(kind=irg), public :: num_el integer(kind=irg), public :: nthreads real(kind=dbl), public :: sig real(kind=dbl), public :: omega real(kind=dbl), public :: EkeV real(kind=dbl), public :: Ehistmin real(kind=dbl), public :: Ebinsize real(kind=dbl), public :: depthmax real(kind=dbl), public :: depthstep character(len=4), public :: MCmode character(len=fnlen), public :: xtalname character(len=fnlen), public :: dataname Source Code type MCNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numsx integer ( kind = irg ) :: primeseed integer ( kind = irg ) :: num_el integer ( kind = irg ) :: nthreads real ( kind = dbl ) :: sig real ( kind = dbl ) :: omega real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep character ( 4 ) :: MCmode character ( fnlen ) :: xtalname character ( fnlen ) :: dataname end type MCNameListType","tags":"","loc":"type/mcnamelisttype.html","title":"MCNameListType – Fortran Program "},{"text":"type, public :: MCLIPSSNameListType Variables stdout numsx primeseed num_el nthreads sig omega EkeV Ehistmin Ebinsize depthmax depthstep lipssamp lipsswave scaled npx vis MCmode xtalname dataname Source Code MCLIPSSNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: numsx integer(kind=irg), public :: primeseed integer(kind=irg), public :: num_el integer(kind=irg), public :: nthreads real(kind=dbl), public :: sig real(kind=dbl), public :: omega real(kind=dbl), public :: EkeV real(kind=dbl), public :: Ehistmin real(kind=dbl), public :: Ebinsize real(kind=dbl), public :: depthmax real(kind=dbl), public :: depthstep real(kind=dbl), public :: lipssamp real(kind=dbl), public :: lipsswave real(kind=dbl), public :: scaled integer(kind=irg), public :: npx integer(kind=irg), public :: vis character(len=4), public :: MCmode character(len=fnlen), public :: xtalname character(len=fnlen), public :: dataname Source Code type MCLIPSSNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numsx integer ( kind = irg ) :: primeseed integer ( kind = irg ) :: num_el integer ( kind = irg ) :: nthreads real ( kind = dbl ) :: sig real ( kind = dbl ) :: omega real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep real ( kind = dbl ) :: lipssamp real ( kind = dbl ) :: lipsswave real ( kind = dbl ) :: scaled integer ( kind = irg ) :: npx integer ( kind = irg ) :: vis character ( 4 ) :: MCmode character ( fnlen ) :: xtalname character ( fnlen ) :: dataname end type MCLIPSSNameListType","tags":"","loc":"type/mclipssnamelisttype.html","title":"MCLIPSSNameListType – Fortran Program "},{"text":"type, public :: reflectorNameListType Variables numphi numtheta dmin masterfile energyfile Source Code reflectorNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: numphi integer(kind=irg), public :: numtheta real(kind=sgl), public :: dmin character(len=fnlen), public :: masterfile character(len=fnlen), public :: energyfile Source Code type reflectorNameListType integer ( kind = irg ) :: numphi integer ( kind = irg ) :: numtheta real ( kind = sgl ) :: dmin character ( fnlen ) :: masterfile character ( fnlen ) :: energyfile end type reflectorNameListType","tags":"","loc":"type/reflectornamelisttype.html","title":"reflectorNameListType – Fortran Program "},{"text":"type, public :: kinematicalNameListType Variables dmin thr voltage xtalname datafile Source Code kinematicalNameListType Components Type Visibility Attributes Name Initial real(kind=sgl), public :: dmin real(kind=sgl), public :: thr real(kind=sgl), public :: voltage character(len=fnlen), public :: xtalname character(len=fnlen), public :: datafile Source Code type kinematicalNameListType real ( kind = sgl ) :: dmin real ( kind = sgl ) :: thr real ( kind = sgl ) :: voltage character ( fnlen ) :: xtalname character ( fnlen ) :: datafile end type kinematicalNameListType","tags":"","loc":"type/kinematicalnamelisttype.html","title":"kinematicalNameListType – Fortran Program "},{"text":"type, public :: OrientationVizNameListType Variables cubochoric homochoric rodrigues stereographic eulerspace reducetoRFZ nx ny nz overridepgnum MacKenzieCell rgb sphrad distance scalingmode df3file xtalname povrayfile anglefile Source Code OrientationVizNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: cubochoric integer(kind=irg), public :: homochoric integer(kind=irg), public :: rodrigues integer(kind=irg), public :: stereographic integer(kind=irg), public :: eulerspace integer(kind=irg), public :: reducetoRFZ integer(kind=irg), public :: nx integer(kind=irg), public :: ny integer(kind=irg), public :: nz integer(kind=irg), public :: overridepgnum integer(kind=irg), public :: MacKenzieCell real(kind=sgl), public :: rgb (3) real(kind=sgl), public :: sphrad real(kind=sgl), public :: distance character(len=3), public :: scalingmode character(len=fnlen), public :: df3file character(len=fnlen), public :: xtalname character(len=fnlen), public :: povrayfile character(len=fnlen), public :: anglefile Source Code type OrientationVizNameListType integer ( kind = irg ) :: cubochoric integer ( kind = irg ) :: homochoric integer ( kind = irg ) :: rodrigues integer ( kind = irg ) :: stereographic integer ( kind = irg ) :: eulerspace integer ( kind = irg ) :: reducetoRFZ integer ( kind = irg ) :: nx integer ( kind = irg ) :: ny integer ( kind = irg ) :: nz integer ( kind = irg ) :: overridepgnum integer ( kind = irg ) :: MacKenzieCell real ( kind = sgl ) :: rgb ( 3 ) real ( kind = sgl ) :: sphrad real ( kind = sgl ) :: distance character ( 3 ) :: scalingmode character ( fnlen ) :: df3file character ( fnlen ) :: xtalname character ( fnlen ) :: povrayfile character ( fnlen ) :: anglefile end type OrientationVizNameListType","tags":"","loc":"type/orientationviznamelisttype.html","title":"OrientationVizNameListType – Fortran Program "},{"text":"type, public :: ConvertOrientationsNameListType Variables reducetoRFZ xtalname cubochoric homochoric rodrigues stereographic eulerangles axisangle quaternion rotationmatrix anglefile Source Code ConvertOrientationsNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: reducetoRFZ character(len=fnlen), public :: xtalname character(len=fnlen), public :: cubochoric character(len=fnlen), public :: homochoric character(len=fnlen), public :: rodrigues character(len=fnlen), public :: stereographic character(len=fnlen), public :: eulerangles character(len=fnlen), public :: axisangle character(len=fnlen), public :: quaternion character(len=fnlen), public :: rotationmatrix character(len=fnlen), public :: anglefile Source Code type ConvertOrientationsNameListType integer ( kind = irg ) :: reducetoRFZ character ( fnlen ) :: xtalname character ( fnlen ) :: cubochoric character ( fnlen ) :: homochoric character ( fnlen ) :: rodrigues character ( fnlen ) :: stereographic character ( fnlen ) :: eulerangles character ( fnlen ) :: axisangle character ( fnlen ) :: quaternion character ( fnlen ) :: rotationmatrix character ( fnlen ) :: anglefile end type ConvertOrientationsNameListType","tags":"","loc":"type/convertorientationsnamelisttype.html","title":"ConvertOrientationsNameListType – Fortran Program "},{"text":"type, public :: MCCLNameListType Variables stdout numsx globalworkgrpsz num_el totnum_el multiplier devid platid sig sigstart sigend sigstep omega EkeV Ehistmin Ebinsize depthmax depthstep thickness radius incloc MCmode xtalname dataname mode Source Code MCCLNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: numsx integer(kind=irg), public :: globalworkgrpsz integer(kind=irg), public :: num_el integer(kind=irg), public :: totnum_el integer(kind=irg), public :: multiplier integer(kind=irg), public :: devid integer(kind=irg), public :: platid real(kind=dbl), public :: sig real(kind=dbl), public :: sigstart real(kind=dbl), public :: sigend real(kind=dbl), public :: sigstep real(kind=dbl), public :: omega real(kind=dbl), public :: EkeV real(kind=dbl), public :: Ehistmin real(kind=dbl), public :: Ebinsize real(kind=dbl), public :: depthmax real(kind=dbl), public :: depthstep real(kind=dbl), public :: thickness real(kind=dbl), public :: radius real(kind=dbl), public :: incloc character(len=4), public :: MCmode character(len=fnlen), public :: xtalname character(len=fnlen), public :: dataname character(len=fnlen), public :: mode Source Code type MCCLNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numsx integer ( kind = irg ) :: globalworkgrpsz integer ( kind = irg ) :: num_el integer ( kind = irg ) :: totnum_el integer ( kind = irg ) :: multiplier integer ( kind = irg ) :: devid integer ( kind = irg ) :: platid real ( kind = dbl ) :: sig real ( kind = dbl ) :: sigstart real ( kind = dbl ) :: sigend real ( kind = dbl ) :: sigstep real ( kind = dbl ) :: omega real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep real ( kind = dbl ) :: thickness real ( kind = dbl ) :: radius real ( kind = dbl ) :: incloc character ( 4 ) :: MCmode character ( fnlen ) :: xtalname character ( fnlen ) :: dataname character ( fnlen ) :: mode end type MCCLNameListType","tags":"","loc":"type/mcclnamelisttype.html","title":"MCCLNameListType – Fortran Program "},{"text":"type, public :: MCCLMultiLayerNameListType Variables stdout numsx globalworkgrpsz num_el totnum_el sig omega EkeV Ehistmin Ebinsize depthmax depthstep filmthickness filmstep MCmode xtalname_film xtalname_subs dataname mode Source Code MCCLMultiLayerNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: numsx integer(kind=irg), public :: globalworkgrpsz integer(kind=irg), public :: num_el integer(kind=irg), public :: totnum_el real(kind=dbl), public :: sig real(kind=dbl), public :: omega real(kind=dbl), public :: EkeV real(kind=dbl), public :: Ehistmin real(kind=dbl), public :: Ebinsize real(kind=dbl), public :: depthmax real(kind=dbl), public :: depthstep real(kind=dbl), public :: filmthickness real(kind=dbl), public :: filmstep character(len=4), public :: MCmode character(len=fnlen), public :: xtalname_film character(len=fnlen), public :: xtalname_subs character(len=fnlen), public :: dataname character(len=fnlen), public :: mode Source Code type MCCLMultiLayerNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numsx integer ( kind = irg ) :: globalworkgrpsz integer ( kind = irg ) :: num_el integer ( kind = irg ) :: totnum_el real ( kind = dbl ) :: sig real ( kind = dbl ) :: omega real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep real ( kind = dbl ) :: filmthickness real ( kind = dbl ) :: filmstep character ( 4 ) :: MCmode character ( fnlen ) :: xtalname_film character ( fnlen ) :: xtalname_subs character ( fnlen ) :: dataname character ( fnlen ) :: mode end type MCCLMultiLayerNameListType","tags":"","loc":"type/mcclmultilayernamelisttype.html","title":"MCCLMultiLayerNameListType – Fortran Program "},{"text":"type, public :: EBSDMasterNameListType Variables stdout npx Esel nthreads dmin energyfile outname restart uniform Source Code EBSDMasterNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: npx integer(kind=irg), public :: Esel integer(kind=irg), public :: nthreads real(kind=sgl), public :: dmin character(len=fnlen), public :: energyfile character(len=fnlen), public :: outname logical, public :: restart logical, public :: uniform Source Code type EBSDMasterNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: npx integer ( kind = irg ) :: Esel integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: dmin character ( fnlen ) :: energyfile character ( fnlen ) :: outname logical :: restart logical :: uniform end type EBSDMasterNameListType","tags":"","loc":"type/ebsdmasternamelisttype.html","title":"EBSDMasterNameListType – Fortran Program "},{"text":"type, public :: TKDMasterNameListType Variables stdout npx Esel nthreads dmin energyfile outname restart uniform Source Code TKDMasterNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: npx integer(kind=irg), public :: Esel integer(kind=irg), public :: nthreads real(kind=sgl), public :: dmin character(len=fnlen), public :: energyfile character(len=fnlen), public :: outname logical, public :: restart logical, public :: uniform Source Code type TKDMasterNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: npx integer ( kind = irg ) :: Esel integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: dmin character ( fnlen ) :: energyfile character ( fnlen ) :: outname logical :: restart logical :: uniform end type TKDMasterNameListType","tags":"","loc":"type/tkdmasternamelisttype.html","title":"TKDMasterNameListType – Fortran Program "},{"text":"type, public :: EBSDMasterOpenCLNameListType Variables stdout npx Esel nthreads platid devid globalworkgrpsz dmin energyfile outname restart uniform Source Code EBSDMasterOpenCLNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: npx integer(kind=irg), public :: Esel integer(kind=irg), public :: nthreads integer(kind=irg), public :: platid integer(kind=irg), public :: devid integer(kind=irg), public :: globalworkgrpsz real(kind=sgl), public :: dmin character(len=fnlen), public :: energyfile character(len=fnlen), public :: outname logical, public :: restart logical, public :: uniform Source Code type EBSDMasterOpenCLNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: npx integer ( kind = irg ) :: Esel integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: platid integer ( kind = irg ) :: devid integer ( kind = irg ) :: globalworkgrpsz real ( kind = sgl ) :: dmin character ( fnlen ) :: energyfile character ( fnlen ) :: outname logical :: restart logical :: uniform end type EBSDMasterOpenCLNameListType","tags":"","loc":"type/ebsdmasteropenclnamelisttype.html","title":"EBSDMasterOpenCLNameListType – Fortran Program "},{"text":"type, public :: EBSDNameListType Variables stdout numsx numsy binning nthreads energyaverage L thetac delta omega xpc ypc energymin energymax gammavalue axisangle alphaBD beamcurrent dwelltime maskpattern scalingmode eulerconvention outputformat spatialaverage anglefile masterfile energyfile datafile numangles numEbins numzbins nsx nsy num_el MCnthreads npx npy nE numset EkeV Ehistmin Ebinsize depthmax depthstep MCsig MComega MCmode anglemode sqorhe MCscversion Masterscversion Masterprogname Masterxtalname Masterenergyfile MCprogname MCxtalname dmin totnum_el platid devid globalworkgrpsz multiplier Source Code EBSDNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: numsx integer(kind=irg), public :: numsy integer(kind=irg), public :: binning integer(kind=irg), public :: nthreads integer(kind=irg), public :: energyaverage real(kind=sgl), public :: L real(kind=sgl), public :: thetac real(kind=sgl), public :: delta real(kind=sgl), public :: omega real(kind=sgl), public :: xpc real(kind=sgl), public :: ypc real(kind=sgl), public :: energymin real(kind=sgl), public :: energymax real(kind=sgl), public :: gammavalue real(kind=sgl), public :: axisangle (4) real(kind=sgl), public :: alphaBD real(kind=dbl), public :: beamcurrent real(kind=dbl), public :: dwelltime character(len=1), public :: maskpattern character(len=3), public :: scalingmode character(len=3), public :: eulerconvention character(len=3), public :: outputformat character(len=1), public :: spatialaverage character(len=fnlen), public :: anglefile character(len=fnlen), public :: masterfile character(len=fnlen), public :: energyfile character(len=fnlen), public :: datafile integer(kind=irg), public :: numangles integer(kind=irg), public :: numEbins integer(kind=irg), public :: numzbins integer(kind=irg), public :: nsx integer(kind=irg), public :: nsy integer(kind=irg), public :: num_el integer(kind=irg), public :: MCnthreads integer(kind=irg), public :: npx integer(kind=irg), public :: npy integer(kind=irg), public :: nE integer(kind=irg), public :: numset real(kind=dbl), public :: EkeV real(kind=dbl), public :: Ehistmin real(kind=dbl), public :: Ebinsize real(kind=dbl), public :: depthmax real(kind=dbl), public :: depthstep real(kind=dbl), public :: MCsig real(kind=dbl), public :: MComega character(len=4), public :: MCmode character(len=5), public :: anglemode character(len=6), public :: sqorhe character(len=8), public :: MCscversion character(len=8), public :: Masterscversion character(len=fnlen), public :: Masterprogname character(len=fnlen), public :: Masterxtalname character(len=fnlen), public :: Masterenergyfile character(len=fnlen), public :: MCprogname character(len=fnlen), public :: MCxtalname real(kind=dbl), public :: dmin integer(kind=irg), public :: totnum_el integer(kind=irg), public :: platid integer(kind=irg), public :: devid integer(kind=irg), public :: globalworkgrpsz integer(kind=irg), public :: multiplier Source Code type EBSDNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numsx integer ( kind = irg ) :: numsy integer ( kind = irg ) :: binning integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: energyaverage real ( kind = sgl ) :: L real ( kind = sgl ) :: thetac real ( kind = sgl ) :: delta real ( kind = sgl ) :: omega real ( kind = sgl ) :: xpc real ( kind = sgl ) :: ypc real ( kind = sgl ) :: energymin real ( kind = sgl ) :: energymax real ( kind = sgl ) :: gammavalue real ( kind = sgl ) :: axisangle ( 4 ) real ( kind = sgl ) :: alphaBD real ( kind = dbl ) :: beamcurrent real ( kind = dbl ) :: dwelltime character ( 1 ) :: maskpattern character ( 3 ) :: scalingmode character ( 3 ) :: eulerconvention character ( 3 ) :: outputformat character ( 1 ) :: spatialaverage character ( fnlen ) :: anglefile character ( fnlen ) :: masterfile character ( fnlen ) :: energyfile character ( fnlen ) :: datafile ! everything below here is not part of the namelist input structure, but is used to pass arguments to subroutines integer ( kind = irg ) :: numangles integer ( kind = irg ) :: numEbins integer ( kind = irg ) :: numzbins integer ( kind = irg ) :: nsx integer ( kind = irg ) :: nsy integer ( kind = irg ) :: num_el integer ( kind = irg ) :: MCnthreads integer ( kind = irg ) :: npx integer ( kind = irg ) :: npy integer ( kind = irg ) :: nE integer ( kind = irg ) :: numset real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep real ( kind = dbl ) :: MCsig real ( kind = dbl ) :: MComega character ( 4 ) :: MCmode ! Monte Carlo mode character ( 5 ) :: anglemode ! 'quats' or 'euler' for angular input character ( 6 ) :: sqorhe ! from Master file, square or hexagonal Lambert projection character ( 8 ) :: MCscversion character ( 8 ) :: Masterscversion character ( fnlen ) :: Masterprogname character ( fnlen ) :: Masterxtalname character ( fnlen ) :: Masterenergyfile character ( fnlen ) :: MCprogname character ( fnlen ) :: MCxtalname real ( kind = dbl ) :: dmin integer ( kind = irg ) :: totnum_el integer ( kind = irg ) :: platid integer ( kind = irg ) :: devid integer ( kind = irg ) :: globalworkgrpsz integer ( kind = irg ) :: multiplier end type EBSDNameListType","tags":"","loc":"type/ebsdnamelisttype.html","title":"EBSDNameListType – Fortran Program "},{"text":"type, public :: TKDNameListType Variables stdout numsx numsy binning nthreads energyaverage L thetac delta omega xpc ypc energymin energymax gammavalue axisangle alphaBD beamcurrent dwelltime maskpattern scalingmode eulerconvention outputformat spatialaverage anglefile masterfile energyfile datafile numangles numEbins numzbins nsx nsy num_el MCnthreads npx npy nE numset EkeV Ehistmin Ebinsize depthmax depthstep MCsig MComega MCmode anglemode sqorhe MCscversion Masterscversion Masterprogname Masterxtalname Masterenergyfile MCprogname MCxtalname dmin totnum_el platid devid globalworkgrpsz multiplier Source Code TKDNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: numsx integer(kind=irg), public :: numsy integer(kind=irg), public :: binning integer(kind=irg), public :: nthreads integer(kind=irg), public :: energyaverage real(kind=sgl), public :: L real(kind=sgl), public :: thetac real(kind=sgl), public :: delta real(kind=sgl), public :: omega real(kind=sgl), public :: xpc real(kind=sgl), public :: ypc real(kind=sgl), public :: energymin real(kind=sgl), public :: energymax real(kind=sgl), public :: gammavalue real(kind=sgl), public :: axisangle (4) real(kind=sgl), public :: alphaBD real(kind=dbl), public :: beamcurrent real(kind=dbl), public :: dwelltime character(len=1), public :: maskpattern character(len=3), public :: scalingmode character(len=3), public :: eulerconvention character(len=3), public :: outputformat character(len=1), public :: spatialaverage character(len=fnlen), public :: anglefile character(len=fnlen), public :: masterfile character(len=fnlen), public :: energyfile character(len=fnlen), public :: datafile integer(kind=irg), public :: numangles integer(kind=irg), public :: numEbins integer(kind=irg), public :: numzbins integer(kind=irg), public :: nsx integer(kind=irg), public :: nsy integer(kind=irg), public :: num_el integer(kind=irg), public :: MCnthreads integer(kind=irg), public :: npx integer(kind=irg), public :: npy integer(kind=irg), public :: nE integer(kind=irg), public :: numset real(kind=dbl), public :: EkeV real(kind=dbl), public :: Ehistmin real(kind=dbl), public :: Ebinsize real(kind=dbl), public :: depthmax real(kind=dbl), public :: depthstep real(kind=dbl), public :: MCsig real(kind=dbl), public :: MComega character(len=4), public :: MCmode character(len=5), public :: anglemode character(len=6), public :: sqorhe character(len=8), public :: MCscversion character(len=8), public :: Masterscversion character(len=fnlen), public :: Masterprogname character(len=fnlen), public :: Masterxtalname character(len=fnlen), public :: Masterenergyfile character(len=fnlen), public :: MCprogname character(len=fnlen), public :: MCxtalname real(kind=dbl), public :: dmin integer(kind=irg), public :: totnum_el integer(kind=irg), public :: platid integer(kind=irg), public :: devid integer(kind=irg), public :: globalworkgrpsz integer(kind=irg), public :: multiplier Source Code type TKDNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numsx integer ( kind = irg ) :: numsy integer ( kind = irg ) :: binning integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: energyaverage real ( kind = sgl ) :: L real ( kind = sgl ) :: thetac real ( kind = sgl ) :: delta real ( kind = sgl ) :: omega real ( kind = sgl ) :: xpc real ( kind = sgl ) :: ypc real ( kind = sgl ) :: energymin real ( kind = sgl ) :: energymax real ( kind = sgl ) :: gammavalue real ( kind = sgl ) :: axisangle ( 4 ) real ( kind = sgl ) :: alphaBD real ( kind = dbl ) :: beamcurrent real ( kind = dbl ) :: dwelltime character ( 1 ) :: maskpattern character ( 3 ) :: scalingmode character ( 3 ) :: eulerconvention character ( 3 ) :: outputformat character ( 1 ) :: spatialaverage character ( fnlen ) :: anglefile character ( fnlen ) :: masterfile character ( fnlen ) :: energyfile character ( fnlen ) :: datafile ! everything below here is not part of the namelist input structure, but is used to pass arguments to subroutines integer ( kind = irg ) :: numangles integer ( kind = irg ) :: numEbins integer ( kind = irg ) :: numzbins integer ( kind = irg ) :: nsx integer ( kind = irg ) :: nsy integer ( kind = irg ) :: num_el integer ( kind = irg ) :: MCnthreads integer ( kind = irg ) :: npx integer ( kind = irg ) :: npy integer ( kind = irg ) :: nE integer ( kind = irg ) :: numset real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep real ( kind = dbl ) :: MCsig real ( kind = dbl ) :: MComega character ( 4 ) :: MCmode ! Monte Carlo mode character ( 5 ) :: anglemode ! 'quats' or 'euler' for angular input character ( 6 ) :: sqorhe ! from Master file, square or hexagonal Lambert projection character ( 8 ) :: MCscversion character ( 8 ) :: Masterscversion character ( fnlen ) :: Masterprogname character ( fnlen ) :: Masterxtalname character ( fnlen ) :: Masterenergyfile character ( fnlen ) :: MCprogname character ( fnlen ) :: MCxtalname real ( kind = dbl ) :: dmin integer ( kind = irg ) :: totnum_el integer ( kind = irg ) :: platid integer ( kind = irg ) :: devid integer ( kind = irg ) :: globalworkgrpsz integer ( kind = irg ) :: multiplier end type TKDNameListType","tags":"","loc":"type/tkdnamelisttype.html","title":"TKDNameListType – Fortran Program "},{"text":"type, public :: EBSDdetparmscanNameListType Variables numdetparm numeuler DetParms Eulertriplet DetParmstepsize Cubochoricstepsize Source Code EBSDdetparmscanNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: numdetparm integer(kind=irg), public :: numeuler real(kind=sgl), public :: DetParms (3) real(kind=sgl), public :: Eulertriplet (3) real(kind=sgl), public :: DetParmstepsize (3) real(kind=sgl), public :: Cubochoricstepsize (3) Source Code type EBSDdetparmscanNameListType integer ( kind = irg ) :: numdetparm integer ( kind = irg ) :: numeuler real ( kind = sgl ) :: DetParms ( 3 ) real ( kind = sgl ) :: Eulertriplet ( 3 ) real ( kind = sgl ) :: DetParmstepsize ( 3 ) real ( kind = sgl ) :: Cubochoricstepsize ( 3 ) end type EBSDdetparmscanNameListType","tags":"","loc":"type/ebsddetparmscannamelisttype.html","title":"EBSDdetparmscanNameListType – Fortran Program "},{"text":"type, public :: EBSDoverlapNameListType Variables stdout PatternAxisA HorizontalAxisA tA tB gA gB fracA masterfileA masterfileB datafile numset npx npy nE sqorhe Masterscversion Masterprogname masterfile Masterxtalname xtalnameA xtalnameB Masterenergyfile Source Code EBSDoverlapNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: PatternAxisA (3) integer(kind=irg), public :: HorizontalAxisA (3) real(kind=sgl), public :: tA (3) real(kind=sgl), public :: tB (3) real(kind=sgl), public :: gA (3) real(kind=sgl), public :: gB (3) real(kind=sgl), public :: fracA character(len=fnlen), public :: masterfileA character(len=fnlen), public :: masterfileB character(len=fnlen), public :: datafile integer(kind=irg), public :: numset integer(kind=irg), public :: npx integer(kind=irg), public :: npy integer(kind=irg), public :: nE character(len=6), public :: sqorhe character(len=8), public :: Masterscversion character(len=fnlen), public :: Masterprogname character(len=fnlen), public :: masterfile character(len=fnlen), public :: Masterxtalname character(len=fnlen), public :: xtalnameA character(len=fnlen), public :: xtalnameB character(len=fnlen), public :: Masterenergyfile Source Code type EBSDoverlapNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: PatternAxisA ( 3 ) integer ( kind = irg ) :: HorizontalAxisA ( 3 ) real ( kind = sgl ) :: tA ( 3 ) real ( kind = sgl ) :: tB ( 3 ) real ( kind = sgl ) :: gA ( 3 ) real ( kind = sgl ) :: gB ( 3 ) real ( kind = sgl ) :: fracA character ( fnlen ) :: masterfileA character ( fnlen ) :: masterfileB character ( fnlen ) :: datafile ! everything below here is not part of the namelist input structure, but is used to pass arguments to subroutines integer ( kind = irg ) :: numset integer ( kind = irg ) :: npx integer ( kind = irg ) :: npy integer ( kind = irg ) :: nE character ( 6 ) :: sqorhe ! from Master file, square or hexagonal Lambert projection character ( 8 ) :: Masterscversion character ( fnlen ) :: Masterprogname character ( fnlen ) :: masterfile character ( fnlen ) :: Masterxtalname character ( fnlen ) :: xtalnameA character ( fnlen ) :: xtalnameB character ( fnlen ) :: Masterenergyfile end type EBSDoverlapNameListType","tags":"","loc":"type/ebsdoverlapnamelisttype.html","title":"EBSDoverlapNameListType – Fortran Program "},{"text":"type, public :: EBSDclusterNameListType Variables NClusters NIterations NScanColumns NScanRows binfactor inputfilename groupname datasetname Source Code EBSDclusterNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: NClusters integer(kind=irg), public :: NIterations integer(kind=irg), public :: NScanColumns integer(kind=irg), public :: NScanRows integer(kind=irg), public :: binfactor character(len=fnlen), public :: inputfilename character(len=fnlen), public :: groupname character(len=fnlen), public :: datasetname Source Code type EBSDclusterNameListType integer ( kind = irg ) :: NClusters integer ( kind = irg ) :: NIterations integer ( kind = irg ) :: NScanColumns integer ( kind = irg ) :: NScanRows integer ( kind = irg ) :: binfactor character ( fnlen ) :: inputfilename character ( fnlen ) :: groupname character ( fnlen ) :: datasetname end type EBSDclusterNameListType","tags":"","loc":"type/ebsdclusternamelisttype.html","title":"EBSDclusterNameListType – Fortran Program "},{"text":"type, public :: ECPNameListType Variables stdout fn_f fn_s nthreads npix gF gS tF tS thetac filmthickness maskpattern xtalname xtalname2 energyfile filmfile subsfile masterfile datafile anglefile eulerconvention gammavalue outputformat sampletilt workingdistance Rin Rout numangle numangle_anglefile numEbins numzbins nsx nsy num_el MCnthreads npx npy nE numset npolar nazimuth EkeV Ehistmin Ebinsize depthmax depthstep dmin MCsigstart MCsigend MCsigstep MComega MCmode anglemode sqorhe MCscversion Masterscversion Masterprogname Masterxtalname Masterenergyfile MCprogname MCxtalname Source Code ECPNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: fn_f (3) integer(kind=irg), public :: fn_s (3) integer(kind=irg), public :: nthreads integer(kind=irg), public :: npix integer(kind=irg), public :: gF (3) integer(kind=irg), public :: gS (3) integer(kind=irg), public :: tF (3) integer(kind=irg), public :: tS (3) real(kind=sgl), public :: thetac real(kind=sgl), public :: filmthickness character(len=1), public :: maskpattern character(len=fnlen), public :: xtalname character(len=fnlen), public :: xtalname2 character(len=fnlen), public :: energyfile character(len=fnlen), public :: filmfile character(len=fnlen), public :: subsfile character(len=fnlen), public :: masterfile character(len=fnlen), public :: datafile character(len=fnlen), public :: anglefile character(len=3), public :: eulerconvention real(kind=sgl), public :: gammavalue character(len=3), public :: outputformat real(kind=dbl), public :: sampletilt real(kind=sgl), public :: workingdistance real(kind=sgl), public :: Rin real(kind=sgl), public :: Rout integer(kind=irg), public :: numangle integer(kind=irg), public :: numangle_anglefile integer(kind=irg), public :: numEbins integer(kind=irg), public :: numzbins integer(kind=irg), public :: nsx integer(kind=irg), public :: nsy integer(kind=irg), public :: num_el integer(kind=irg), public :: MCnthreads integer(kind=irg), public :: npx integer(kind=irg), public :: npy integer(kind=irg), public :: nE integer(kind=irg), public :: numset integer(kind=irg), public :: npolar integer(kind=irg), public :: nazimuth real(kind=dbl), public :: EkeV real(kind=dbl), public :: Ehistmin real(kind=dbl), public :: Ebinsize real(kind=dbl), public :: depthmax real(kind=dbl), public :: depthstep real(kind=sgl), public :: dmin real(kind=dbl), public :: MCsigstart real(kind=dbl), public :: MCsigend real(kind=dbl), public :: MCsigstep real(kind=dbl), public :: MComega character(len=4), public :: MCmode character(len=5), public :: anglemode character(len=6), public :: sqorhe character(len=8), public :: MCscversion character(len=8), public :: Masterscversion character(len=fnlen), public :: Masterprogname character(len=fnlen), public :: Masterxtalname character(len=fnlen), public :: Masterenergyfile character(len=fnlen), public :: MCprogname character(len=fnlen), public :: MCxtalname Source Code type ECPNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: fn_f ( 3 ) integer ( kind = irg ) :: fn_s ( 3 ) integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: npix integer ( kind = irg ) :: gF ( 3 ) integer ( kind = irg ) :: gS ( 3 ) integer ( kind = irg ) :: tF ( 3 ) integer ( kind = irg ) :: tS ( 3 ) real ( kind = sgl ) :: thetac real ( kind = sgl ) :: filmthickness character ( 1 ) :: maskpattern character ( fnlen ) :: xtalname character ( fnlen ) :: xtalname2 character ( fnlen ) :: energyfile character ( fnlen ) :: filmfile character ( fnlen ) :: subsfile character ( fnlen ) :: masterfile character ( fnlen ) :: datafile character ( fnlen ) :: anglefile character ( 3 ) :: eulerconvention real ( kind = sgl ) :: gammavalue character ( 3 ) :: outputformat real ( kind = dbl ) :: sampletilt real ( kind = sgl ) :: workingdistance real ( kind = sgl ) :: Rin real ( kind = sgl ) :: Rout ! everything below here is not part of the namelist input structure, but is used to pass arguments to subroutines integer ( kind = irg ) :: numangle integer ( kind = irg ) :: numangle_anglefile integer ( kind = irg ) :: numEbins integer ( kind = irg ) :: numzbins integer ( kind = irg ) :: nsx integer ( kind = irg ) :: nsy integer ( kind = irg ) :: num_el integer ( kind = irg ) :: MCnthreads integer ( kind = irg ) :: npx integer ( kind = irg ) :: npy integer ( kind = irg ) :: nE integer ( kind = irg ) :: numset integer ( kind = irg ) :: npolar integer ( kind = irg ) :: nazimuth real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep real ( kind = sgl ) :: dmin real ( kind = dbl ) :: MCsigstart real ( kind = dbl ) :: MCsigend real ( kind = dbl ) :: MCsigstep real ( kind = dbl ) :: MComega character ( 4 ) :: MCmode ! Monte Carlo mode character ( 5 ) :: anglemode ! 'quats' or 'euler' for angular input character ( 6 ) :: sqorhe ! from Master file, square or hexagonal Lambert projection character ( 8 ) :: MCscversion character ( 8 ) :: Masterscversion character ( fnlen ) :: Masterprogname character ( fnlen ) :: Masterxtalname character ( fnlen ) :: Masterenergyfile character ( fnlen ) :: MCprogname character ( fnlen ) :: MCxtalname end type ECPNameListType","tags":"","loc":"type/ecpnamelisttype.html","title":"ECPNameListType – Fortran Program "},{"text":"type, public :: LACBEDNameListType Variables stdout k fn maxHOLZ numthick npix nthreads voltage dmin convergence startthick thickinc minten xtalname outname Source Code LACBEDNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: k (3) integer(kind=irg), public :: fn (3) integer(kind=irg), public :: maxHOLZ integer(kind=irg), public :: numthick integer(kind=irg), public :: npix integer(kind=irg), public :: nthreads real(kind=sgl), public :: voltage real(kind=sgl), public :: dmin real(kind=sgl), public :: convergence real(kind=sgl), public :: startthick real(kind=sgl), public :: thickinc real(kind=sgl), public :: minten character(len=fnlen), public :: xtalname character(len=fnlen), public :: outname Source Code type LACBEDNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: k ( 3 ) integer ( kind = irg ) :: fn ( 3 ) integer ( kind = irg ) :: maxHOLZ integer ( kind = irg ) :: numthick integer ( kind = irg ) :: npix integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: voltage real ( kind = sgl ) :: dmin real ( kind = sgl ) :: convergence real ( kind = sgl ) :: startthick real ( kind = sgl ) :: thickinc real ( kind = sgl ) :: minten character ( fnlen ) :: xtalname character ( fnlen ) :: outname end type LACBEDNameListType","tags":"","loc":"type/lacbednamelisttype.html","title":"LACBEDNameListType – Fortran Program "},{"text":"type, public :: ECPMasterNameListType Variables stdout npx Esel nthreads dmin compmode energyfile outname Source Code ECPMasterNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: npx integer(kind=irg), public :: Esel integer(kind=irg), public :: nthreads real(kind=sgl), public :: dmin character(len=fnlen), public :: compmode character(len=fnlen), public :: energyfile character(len=fnlen), public :: outname Source Code type ECPMasterNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: npx integer ( kind = irg ) :: Esel integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: dmin character ( fnlen ) :: compmode character ( fnlen ) :: energyfile character ( fnlen ) :: outname end type ECPMasterNameListType","tags":"","loc":"type/ecpmasternamelisttype.html","title":"ECPMasterNameListType – Fortran Program "},{"text":"type, public :: ECPpatternNameListType Variables stdout npix thetac k masterfile outname Source Code ECPpatternNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: npix real(kind=sgl), public :: thetac real(kind=sgl), public :: k (3) character(len=fnlen), public :: masterfile character(len=fnlen), public :: outname Source Code type ECPpatternNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: npix real ( kind = sgl ) :: thetac real ( kind = sgl ) :: k ( 3 ) character ( fnlen ) :: masterfile character ( fnlen ) :: outname end type ECPpatternNameListType","tags":"","loc":"type/ecppatternnamelisttype.html","title":"ECPpatternNameListType – Fortran Program "},{"text":"type, public :: ECPZANameListType Variables fn k npix nthreads dmin ktmax maskpattern energyfile outname Source Code ECPZANameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: fn (3) integer(kind=irg), public :: k (3) integer(kind=irg), public :: npix integer(kind=irg), public :: nthreads real(kind=sgl), public :: dmin real(kind=sgl), public :: ktmax character(len=1), public :: maskpattern character(len=fnlen), public :: energyfile character(len=fnlen), public :: outname Source Code type ECPZANameListType integer ( kind = irg ) :: fn ( 3 ) integer ( kind = irg ) :: k ( 3 ) integer ( kind = irg ) :: npix integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: dmin real ( kind = sgl ) :: ktmax character ( 1 ) :: maskpattern character ( fnlen ) :: energyfile character ( fnlen ) :: outname end type ECPZANameListType","tags":"","loc":"type/ecpzanamelisttype.html","title":"ECPZANameListType – Fortran Program "},{"text":"type, public :: PEDZANameListType Variables stdout k fn precsample precazimuthal npix nthreads voltage dmin precangle prechalfwidth thickness camlen filemode xtalname outname Source Code PEDZANameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: k (3) integer(kind=irg), public :: fn (3) integer(kind=irg), public :: precsample integer(kind=irg), public :: precazimuthal integer(kind=irg), public :: npix integer(kind=irg), public :: nthreads real(kind=sgl), public :: voltage real(kind=sgl), public :: dmin real(kind=sgl), public :: precangle real(kind=sgl), public :: prechalfwidth real(kind=sgl), public :: thickness real(kind=sgl), public :: camlen character(len=5), public :: filemode character(len=fnlen), public :: xtalname character(len=fnlen), public :: outname Source Code type PEDZANameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: k ( 3 ) integer ( kind = irg ) :: fn ( 3 ) integer ( kind = irg ) :: precsample integer ( kind = irg ) :: precazimuthal integer ( kind = irg ) :: npix integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: voltage real ( kind = sgl ) :: dmin real ( kind = sgl ) :: precangle real ( kind = sgl ) :: prechalfwidth real ( kind = sgl ) :: thickness real ( kind = sgl ) :: camlen character ( 5 ) :: filemode character ( fnlen ) :: xtalname character ( fnlen ) :: outname end type PEDZANameListType","tags":"","loc":"type/pedzanamelisttype.html","title":"PEDZANameListType – Fortran Program "},{"text":"type, public :: PEDkinNameListType Variables stdout npix ncubochoric nthreads voltage dmin thickness rnmpp xtalname outname Source Code PEDkinNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: npix integer(kind=irg), public :: ncubochoric integer(kind=irg), public :: nthreads real(kind=sgl), public :: voltage real(kind=sgl), public :: dmin real(kind=sgl), public :: thickness real(kind=sgl), public :: rnmpp character(len=fnlen), public :: xtalname character(len=fnlen), public :: outname Source Code type PEDkinNameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: npix integer ( kind = irg ) :: ncubochoric integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: voltage real ( kind = sgl ) :: dmin real ( kind = sgl ) :: thickness real ( kind = sgl ) :: rnmpp character ( fnlen ) :: xtalname character ( fnlen ) :: outname end type PEDkinNameListType","tags":"","loc":"type/pedkinnamelisttype.html","title":"PEDkinNameListType – Fortran Program "},{"text":"type, public :: ECCINameListType Variables stdout nthreads k nktstep DF_npix DF_npiy voltage dkt ktmax lauec lauec2 dmin DF_L DF_slice dispmode summode progmode xtalname defectfilename dispfile dataname ECPname sgname Source Code ECCINameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: nthreads integer(kind=irg), public :: k (3) integer(kind=irg), public :: nktstep integer(kind=irg), public :: DF_npix integer(kind=irg), public :: DF_npiy real(kind=sgl), public :: voltage real(kind=sgl), public :: dkt real(kind=sgl), public :: ktmax real(kind=sgl), public :: lauec (2) real(kind=sgl), public :: lauec2 (2) real(kind=sgl), public :: dmin real(kind=sgl), public :: DF_L real(kind=sgl), public :: DF_slice character(len=4), public :: dispmode character(len=4), public :: summode character(len=5), public :: progmode character(len=fnlen), public :: xtalname character(len=fnlen), public :: defectfilename character(len=fnlen), public :: dispfile character(len=fnlen), public :: dataname character(len=fnlen), public :: ECPname character(len=fnlen), public :: sgname Source Code type ECCINameListType integer ( kind = irg ) :: stdout integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: k ( 3 ) integer ( kind = irg ) :: nktstep integer ( kind = irg ) :: DF_npix integer ( kind = irg ) :: DF_npiy real ( kind = sgl ) :: voltage real ( kind = sgl ) :: dkt real ( kind = sgl ) :: ktmax real ( kind = sgl ) :: lauec ( 2 ) real ( kind = sgl ) :: lauec2 ( 2 ) real ( kind = sgl ) :: dmin real ( kind = sgl ) :: DF_L real ( kind = sgl ) :: DF_slice character ( 4 ) :: dispmode character ( 4 ) :: summode character ( 5 ) :: progmode character ( fnlen ) :: xtalname character ( fnlen ) :: defectfilename character ( fnlen ) :: dispfile character ( fnlen ) :: dataname character ( fnlen ) :: ECPname character ( fnlen ) :: sgname end type ECCINameListType","tags":"","loc":"type/eccinamelisttype.html","title":"ECCINameListType – Fortran Program "},{"text":"type, public :: RFZNameListType Variables pgnum nsteps gridtype rodrigues maxmisor conevector semiconeangle samplemode euoutname cuoutname hooutname rooutname quoutname omoutname axoutname Source Code RFZNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: pgnum integer(kind=irg), public :: nsteps integer(kind=irg), public :: gridtype real(kind=dbl), public :: rodrigues (4) real(kind=dbl), public :: maxmisor real(kind=dbl), public :: conevector (3) real(kind=dbl), public :: semiconeangle character(len=fnlen), public :: samplemode character(len=fnlen), public :: euoutname character(len=fnlen), public :: cuoutname character(len=fnlen), public :: hooutname character(len=fnlen), public :: rooutname character(len=fnlen), public :: quoutname character(len=fnlen), public :: omoutname character(len=fnlen), public :: axoutname Source Code type RFZNameListType integer ( kind = irg ) :: pgnum integer ( kind = irg ) :: nsteps integer ( kind = irg ) :: gridtype real ( kind = dbl ) :: rodrigues ( 4 ) real ( kind = dbl ) :: maxmisor real ( kind = dbl ) :: conevector ( 3 ) real ( kind = dbl ) :: semiconeangle character ( fnlen ) :: samplemode character ( fnlen ) :: euoutname character ( fnlen ) :: cuoutname character ( fnlen ) :: hooutname character ( fnlen ) :: rooutname character ( fnlen ) :: quoutname character ( fnlen ) :: omoutname character ( fnlen ) :: axoutname end type RFZNameListType","tags":"","loc":"type/rfznamelisttype.html","title":"RFZNameListType – Fortran Program "},{"text":"type, public :: DictIndxOpenCLListType Variables numexptsingle numdictsingle totnumexpt totnumdict imght imgwd nnk exptfile dictfile eulerfile MeanSubtraction patternflip Source Code DictIndxOpenCLListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: numexptsingle integer(kind=irg), public :: numdictsingle integer(kind=irg), public :: totnumexpt integer(kind=irg), public :: totnumdict integer(kind=irg), public :: imght integer(kind=irg), public :: imgwd integer(kind=irg), public :: nnk character(len=fnlen), public :: exptfile character(len=fnlen), public :: dictfile character(len=fnlen), public :: eulerfile logical, public :: MeanSubtraction logical, public :: patternflip Source Code type DictIndxOpenCLListType integer ( kind = irg ) :: numexptsingle integer ( kind = irg ) :: numdictsingle integer ( kind = irg ) :: totnumexpt integer ( kind = irg ) :: totnumdict integer ( kind = irg ) :: imght integer ( kind = irg ) :: imgwd integer ( kind = irg ) :: nnk character ( fnlen ) :: exptfile character ( fnlen ) :: dictfile character ( fnlen ) :: eulerfile logical :: MeanSubtraction logical :: patternflip end type DictIndxOpenCLListType","tags":"","loc":"type/dictindxopencllisttype.html","title":"DictIndxOpenCLListType – Fortran Program "},{"text":"type, public :: PEDKINIndxListType Variables npix ncubochoric voltage dmin thickness rnmpp xtalname numexptsingle numdictsingle ipf_ht ipf_wd nnk sgmax ww var exptfile datafile ctffile devid platid nthreads Igmax Source Code PEDKINIndxListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: npix integer(kind=irg), public :: ncubochoric real(kind=sgl), public :: voltage real(kind=sgl), public :: dmin real(kind=sgl), public :: thickness real(kind=sgl), public :: rnmpp character(len=fnlen), public :: xtalname integer(kind=irg), public :: numexptsingle integer(kind=irg), public :: numdictsingle integer(kind=irg), public :: ipf_ht integer(kind=irg), public :: ipf_wd integer(kind=irg), public :: nnk real(kind=sgl), public :: sgmax real(kind=sgl), public :: ww real(kind=sgl), public :: var character(len=fnlen), public :: exptfile character(len=fnlen), public :: datafile character(len=fnlen), public :: ctffile integer(kind=irg), public :: devid integer(kind=irg), public :: platid integer(kind=irg), public :: nthreads real(kind=sgl), public :: Igmax Source Code type PEDKINIndxListType integer ( kind = irg ) :: npix integer ( kind = irg ) :: ncubochoric real ( kind = sgl ) :: voltage real ( kind = sgl ) :: dmin real ( kind = sgl ) :: thickness real ( kind = sgl ) :: rnmpp ! reciprocal nanometers per pixel character ( fnlen ) :: xtalname integer ( kind = irg ) :: numexptsingle integer ( kind = irg ) :: numdictsingle integer ( kind = irg ) :: ipf_ht integer ( kind = irg ) :: ipf_wd integer ( kind = irg ) :: nnk real ( kind = sgl ) :: sgmax ! maximum sg value for a beam to be considered real ( kind = sgl ) :: ww ! 2*ww+1 is the size of the spot real ( kind = sgl ) :: var ! variance of gaussian peak character ( fnlen ) :: exptfile character ( fnlen ) :: datafile character ( fnlen ) :: ctffile integer ( kind = irg ) :: devid integer ( kind = irg ) :: platid integer ( kind = irg ) :: nthreads ! all variables below are used to pass values to the subroutine and not read from the namelist file real ( kind = sgl ) :: Igmax end type PEDKINIndxListType","tags":"","loc":"type/pedkinindxlisttype.html","title":"PEDKINIndxListType – Fortran Program "},{"text":"type, public :: DisorientationsNameListType Variables pgnum pgnum2 inputfile outputfile Source Code DisorientationsNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: pgnum integer(kind=irg), public :: pgnum2 character(len=fnlen), public :: inputfile character(len=fnlen), public :: outputfile Source Code type DisorientationsNameListType integer ( kind = irg ) :: pgnum integer ( kind = irg ) :: pgnum2 character ( fnlen ) :: inputfile character ( fnlen ) :: outputfile end type DisorientationsNameListType","tags":"","loc":"type/disorientationsnamelisttype.html","title":"DisorientationsNameListType – Fortran Program "},{"text":"type, public :: AverageOrientationNameListType Variables nmuse reldisx reldisy oldformat dotproductfile averagectffile averagetxtfile disorientationmap Source Code AverageOrientationNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: nmuse integer(kind=irg), public :: reldisx integer(kind=irg), public :: reldisy logical, public :: oldformat character(len=fnlen), public :: dotproductfile character(len=fnlen), public :: averagectffile character(len=fnlen), public :: averagetxtfile character(len=fnlen), public :: disorientationmap Source Code type AverageOrientationNameListType integer ( kind = irg ) :: nmuse integer ( kind = irg ) :: reldisx integer ( kind = irg ) :: reldisy logical :: oldformat character ( fnlen ) :: dotproductfile character ( fnlen ) :: averagectffile character ( fnlen ) :: averagetxtfile character ( fnlen ) :: disorientationmap end type AverageOrientationNameListType","tags":"","loc":"type/averageorientationnamelisttype.html","title":"AverageOrientationNameListType – Fortran Program "},{"text":"type, public :: OrientationSimilarityNameListType Variables nmuse dotproductfile osmtiff Source Code OrientationSimilarityNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: nmuse character(len=fnlen), public :: dotproductfile character(len=fnlen), public :: osmtiff Source Code type OrientationSimilarityNameListType integer ( kind = irg ) :: nmuse character ( fnlen ) :: dotproductfile character ( fnlen ) :: osmtiff end type OrientationSimilarityNameListType","tags":"","loc":"type/orientationsimilaritynamelisttype.html","title":"OrientationSimilarityNameListType – Fortran Program "},{"text":"type, public :: KAMNameListType Variables kamcutoff orav dotproductfile kamtiff Source Code KAMNameListType Components Type Visibility Attributes Name Initial real(kind=sgl), public :: kamcutoff integer(kind=irg), public :: orav character(len=fnlen), public :: dotproductfile character(len=fnlen), public :: kamtiff Source Code type KAMNameListType real ( kind = sgl ) :: kamcutoff integer ( kind = irg ) :: orav character ( fnlen ) :: dotproductfile character ( fnlen ) :: kamtiff end type KAMNameListType","tags":"","loc":"type/kamnamelisttype.html","title":"KAMNameListType – Fortran Program "},{"text":"type, public :: DvsDNameListType Variables nmuse maxdis minang maxang dotproductfile outfile povfile xtalfile Source Code DvsDNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: nmuse real(kind=sgl), public :: maxdis real(kind=sgl), public :: minang real(kind=sgl), public :: maxang character(len=fnlen), public :: dotproductfile character(len=fnlen), public :: outfile character(len=fnlen), public :: povfile character(len=fnlen), public :: xtalfile Source Code type DvsDNameListType integer ( kind = irg ) :: nmuse real ( kind = sgl ) :: maxdis real ( kind = sgl ) :: minang real ( kind = sgl ) :: maxang character ( fnlen ) :: dotproductfile character ( fnlen ) :: outfile character ( fnlen ) :: povfile character ( fnlen ) :: xtalfile end type DvsDNameListType","tags":"","loc":"type/dvsdnamelisttype.html","title":"DvsDNameListType – Fortran Program "},{"text":"type, public :: EBSDIndexingNameListType Variables ncubochoric numexptsingle numdictsingle ipf_ht ipf_wd nnk nnav nosm maskradius exptfile numsx numsy binning nthreads energyaverage devid platid nregions L thetac delta omega xpc ypc energymin energymax gammavalue axisangle beamcurrent dwelltime hipassw maskpattern scalingmode spatialaverage anglefile masterfile energyfile datafile tmpfile ctffile avctffile angfile eulerfile dictfile indexingmode numangles numEbins numzbins nsx nsy num_el MCnthreads npx npy nE numset EkeV Ehistmin Ebinsize depthmax depthstep MCsig MComega dmin StepX StepY WD MCmode anglemode sqorhe MCscversion Masterscversion Masterprogname Masterxtalname Masterenergyfile MCprogname MCxtalname Source Code EBSDIndexingNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: ncubochoric integer(kind=irg), public :: numexptsingle integer(kind=irg), public :: numdictsingle integer(kind=irg), public :: ipf_ht integer(kind=irg), public :: ipf_wd integer(kind=irg), public :: nnk integer(kind=irg), public :: nnav integer(kind=irg), public :: nosm integer(kind=irg), public :: maskradius character(len=fnlen), public :: exptfile integer(kind=irg), public :: numsx integer(kind=irg), public :: numsy integer(kind=irg), public :: binning integer(kind=irg), public :: nthreads integer(kind=irg), public :: energyaverage integer(kind=irg), public :: devid integer(kind=irg), public :: platid integer(kind=irg), public :: nregions real(kind=sgl), public :: L real(kind=sgl), public :: thetac real(kind=sgl), public :: delta real(kind=sgl), public :: omega real(kind=sgl), public :: xpc real(kind=sgl), public :: ypc real(kind=sgl), public :: energymin real(kind=sgl), public :: energymax real(kind=sgl), public :: gammavalue real(kind=sgl), public :: axisangle (4) real(kind=dbl), public :: beamcurrent real(kind=dbl), public :: dwelltime real(kind=dbl), public :: hipassw character(len=1), public :: maskpattern character(len=3), public :: scalingmode character(len=1), public :: spatialaverage character(len=fnlen), public :: anglefile character(len=fnlen), public :: masterfile character(len=fnlen), public :: energyfile character(len=fnlen), public :: datafile character(len=fnlen), public :: tmpfile character(len=fnlen), public :: ctffile character(len=fnlen), public :: avctffile character(len=fnlen), public :: angfile character(len=fnlen), public :: eulerfile character(len=fnlen), public :: dictfile character(len=fnlen), public :: indexingmode integer(kind=irg), public :: numangles integer(kind=irg), public :: numEbins integer(kind=irg), public :: numzbins integer(kind=irg), public :: nsx integer(kind=irg), public :: nsy integer(kind=irg), public :: num_el integer(kind=irg), public :: MCnthreads integer(kind=irg), public :: npx integer(kind=irg), public :: npy integer(kind=irg), public :: nE integer(kind=irg), public :: numset real(kind=dbl), public :: EkeV real(kind=dbl), public :: Ehistmin real(kind=dbl), public :: Ebinsize real(kind=dbl), public :: depthmax real(kind=dbl), public :: depthstep real(kind=dbl), public :: MCsig real(kind=dbl), public :: MComega real(kind=sgl), public :: dmin real(kind=sgl), public :: StepX real(kind=sgl), public :: StepY real(kind=sgl), public :: WD character(len=4), public :: MCmode character(len=5), public :: anglemode character(len=6), public :: sqorhe character(len=8), public :: MCscversion character(len=8), public :: Masterscversion character(len=fnlen), public :: Masterprogname character(len=fnlen), public :: Masterxtalname character(len=fnlen), public :: Masterenergyfile character(len=fnlen), public :: MCprogname character(len=fnlen), public :: MCxtalname Source Code type EBSDIndexingNameListType integer ( kind = irg ) :: ncubochoric integer ( kind = irg ) :: numexptsingle integer ( kind = irg ) :: numdictsingle integer ( kind = irg ) :: ipf_ht integer ( kind = irg ) :: ipf_wd integer ( kind = irg ) :: nnk integer ( kind = irg ) :: nnav integer ( kind = irg ) :: nosm integer ( kind = irg ) :: maskradius character ( fnlen ) :: exptfile integer ( kind = irg ) :: numsx integer ( kind = irg ) :: numsy integer ( kind = irg ) :: binning integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: energyaverage integer ( kind = irg ) :: devid integer ( kind = irg ) :: platid integer ( kind = irg ) :: nregions real ( kind = sgl ) :: L real ( kind = sgl ) :: thetac real ( kind = sgl ) :: delta real ( kind = sgl ) :: omega real ( kind = sgl ) :: xpc real ( kind = sgl ) :: ypc real ( kind = sgl ) :: energymin real ( kind = sgl ) :: energymax real ( kind = sgl ) :: gammavalue real ( kind = sgl ) :: axisangle ( 4 ) real ( kind = dbl ) :: beamcurrent real ( kind = dbl ) :: dwelltime real ( kind = dbl ) :: hipassw character ( 1 ) :: maskpattern character ( 3 ) :: scalingmode !character(3)            :: eulerconvention !character(3)            :: outputformat character ( 1 ) :: spatialaverage character ( fnlen ) :: anglefile !character(fnlen)        :: dotproductfile character ( fnlen ) :: masterfile character ( fnlen ) :: energyfile character ( fnlen ) :: datafile character ( fnlen ) :: tmpfile character ( fnlen ) :: ctffile character ( fnlen ) :: avctffile character ( fnlen ) :: angfile character ( fnlen ) :: eulerfile character ( fnlen ) :: dictfile character ( fnlen ) :: indexingmode ! everything below here is not part of the namelist input structure, but is used to pass arguments to subroutines integer ( kind = irg ) :: numangles integer ( kind = irg ) :: numEbins integer ( kind = irg ) :: numzbins integer ( kind = irg ) :: nsx integer ( kind = irg ) :: nsy integer ( kind = irg ) :: num_el integer ( kind = irg ) :: MCnthreads integer ( kind = irg ) :: npx integer ( kind = irg ) :: npy integer ( kind = irg ) :: nE integer ( kind = irg ) :: numset real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep real ( kind = dbl ) :: MCsig real ( kind = dbl ) :: MComega real ( kind = sgl ) :: dmin real ( kind = sgl ) :: StepX real ( kind = sgl ) :: StepY real ( kind = sgl ) :: WD character ( 4 ) :: MCmode ! Monte Carlo mode character ( 5 ) :: anglemode ! 'quats' or 'euler' for angular input character ( 6 ) :: sqorhe ! from Master file, square or hexagonal Lambert projection character ( 8 ) :: MCscversion character ( 8 ) :: Masterscversion character ( fnlen ) :: Masterprogname character ( fnlen ) :: Masterxtalname character ( fnlen ) :: Masterenergyfile character ( fnlen ) :: MCprogname character ( fnlen ) :: MCxtalname end type EBSDIndexingNameListType","tags":"","loc":"type/ebsdindexingnamelisttype.html","title":"EBSDIndexingNameListType – Fortran Program "},{"text":"type, public :: TKDIndexingNameListType Variables ncubochoric numexptsingle numdictsingle ipf_ht ipf_wd nnk nnav nosm maskradius exptfile numsx numsy binning nthreads energyaverage devid platid nregions L thetac delta omega xpc ypc energymin energymax gammavalue axisangle beamcurrent dwelltime hipassw maskpattern scalingmode spatialaverage anglefile masterfile energyfile datafile tmpfile ctffile avctffile angfile eulerfile dictfile indexingmode numangles numEbins numzbins nsx nsy num_el MCnthreads npx npy nE numset EkeV Ehistmin Ebinsize depthmax depthstep MCsig MComega dmin StepX StepY WD MCmode anglemode sqorhe MCscversion Masterscversion Masterprogname Masterxtalname Masterenergyfile MCprogname MCxtalname Source Code TKDIndexingNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: ncubochoric integer(kind=irg), public :: numexptsingle integer(kind=irg), public :: numdictsingle integer(kind=irg), public :: ipf_ht integer(kind=irg), public :: ipf_wd integer(kind=irg), public :: nnk integer(kind=irg), public :: nnav integer(kind=irg), public :: nosm integer(kind=irg), public :: maskradius character(len=fnlen), public :: exptfile integer(kind=irg), public :: numsx integer(kind=irg), public :: numsy integer(kind=irg), public :: binning integer(kind=irg), public :: nthreads integer(kind=irg), public :: energyaverage integer(kind=irg), public :: devid integer(kind=irg), public :: platid integer(kind=irg), public :: nregions real(kind=sgl), public :: L real(kind=sgl), public :: thetac real(kind=sgl), public :: delta real(kind=sgl), public :: omega real(kind=sgl), public :: xpc real(kind=sgl), public :: ypc real(kind=sgl), public :: energymin real(kind=sgl), public :: energymax real(kind=sgl), public :: gammavalue real(kind=sgl), public :: axisangle (4) real(kind=dbl), public :: beamcurrent real(kind=dbl), public :: dwelltime real(kind=dbl), public :: hipassw character(len=1), public :: maskpattern character(len=3), public :: scalingmode character(len=1), public :: spatialaverage character(len=fnlen), public :: anglefile character(len=fnlen), public :: masterfile character(len=fnlen), public :: energyfile character(len=fnlen), public :: datafile character(len=fnlen), public :: tmpfile character(len=fnlen), public :: ctffile character(len=fnlen), public :: avctffile character(len=fnlen), public :: angfile character(len=fnlen), public :: eulerfile character(len=fnlen), public :: dictfile character(len=fnlen), public :: indexingmode integer(kind=irg), public :: numangles integer(kind=irg), public :: numEbins integer(kind=irg), public :: numzbins integer(kind=irg), public :: nsx integer(kind=irg), public :: nsy integer(kind=irg), public :: num_el integer(kind=irg), public :: MCnthreads integer(kind=irg), public :: npx integer(kind=irg), public :: npy integer(kind=irg), public :: nE integer(kind=irg), public :: numset real(kind=dbl), public :: EkeV real(kind=dbl), public :: Ehistmin real(kind=dbl), public :: Ebinsize real(kind=dbl), public :: depthmax real(kind=dbl), public :: depthstep real(kind=dbl), public :: MCsig real(kind=dbl), public :: MComega real(kind=sgl), public :: dmin real(kind=sgl), public :: StepX real(kind=sgl), public :: StepY real(kind=sgl), public :: WD character(len=4), public :: MCmode character(len=5), public :: anglemode character(len=6), public :: sqorhe character(len=8), public :: MCscversion character(len=8), public :: Masterscversion character(len=fnlen), public :: Masterprogname character(len=fnlen), public :: Masterxtalname character(len=fnlen), public :: Masterenergyfile character(len=fnlen), public :: MCprogname character(len=fnlen), public :: MCxtalname Source Code type TKDIndexingNameListType integer ( kind = irg ) :: ncubochoric integer ( kind = irg ) :: numexptsingle integer ( kind = irg ) :: numdictsingle integer ( kind = irg ) :: ipf_ht integer ( kind = irg ) :: ipf_wd integer ( kind = irg ) :: nnk integer ( kind = irg ) :: nnav integer ( kind = irg ) :: nosm integer ( kind = irg ) :: maskradius character ( fnlen ) :: exptfile integer ( kind = irg ) :: numsx integer ( kind = irg ) :: numsy integer ( kind = irg ) :: binning integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: energyaverage integer ( kind = irg ) :: devid integer ( kind = irg ) :: platid integer ( kind = irg ) :: nregions real ( kind = sgl ) :: L real ( kind = sgl ) :: thetac real ( kind = sgl ) :: delta real ( kind = sgl ) :: omega real ( kind = sgl ) :: xpc real ( kind = sgl ) :: ypc real ( kind = sgl ) :: energymin real ( kind = sgl ) :: energymax real ( kind = sgl ) :: gammavalue real ( kind = sgl ) :: axisangle ( 4 ) real ( kind = dbl ) :: beamcurrent real ( kind = dbl ) :: dwelltime real ( kind = dbl ) :: hipassw character ( 1 ) :: maskpattern character ( 3 ) :: scalingmode !character(3)            :: eulerconvention !character(3)            :: outputformat character ( 1 ) :: spatialaverage character ( fnlen ) :: anglefile !character(fnlen)        :: dotproductfile character ( fnlen ) :: masterfile character ( fnlen ) :: energyfile character ( fnlen ) :: datafile character ( fnlen ) :: tmpfile character ( fnlen ) :: ctffile character ( fnlen ) :: avctffile character ( fnlen ) :: angfile character ( fnlen ) :: eulerfile character ( fnlen ) :: dictfile character ( fnlen ) :: indexingmode ! everything below here is not part of the namelist input structure, but is used to pass arguments to subroutines integer ( kind = irg ) :: numangles integer ( kind = irg ) :: numEbins integer ( kind = irg ) :: numzbins integer ( kind = irg ) :: nsx integer ( kind = irg ) :: nsy integer ( kind = irg ) :: num_el integer ( kind = irg ) :: MCnthreads integer ( kind = irg ) :: npx integer ( kind = irg ) :: npy integer ( kind = irg ) :: nE integer ( kind = irg ) :: numset real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep real ( kind = dbl ) :: MCsig real ( kind = dbl ) :: MComega real ( kind = sgl ) :: dmin real ( kind = sgl ) :: StepX real ( kind = sgl ) :: StepY real ( kind = sgl ) :: WD character ( 4 ) :: MCmode ! Monte Carlo mode character ( 5 ) :: anglemode ! 'quats' or 'euler' for angular input character ( 6 ) :: sqorhe ! from Master file, square or hexagonal Lambert projection character ( 8 ) :: MCscversion character ( 8 ) :: Masterscversion character ( fnlen ) :: Masterprogname character ( fnlen ) :: Masterxtalname character ( fnlen ) :: Masterenergyfile character ( fnlen ) :: MCprogname character ( fnlen ) :: MCxtalname end type TKDIndexingNameListType","tags":"","loc":"type/tkdindexingnamelisttype.html","title":"TKDIndexingNameListType – Fortran Program "},{"text":"type, public :: ECPIndexingNameListType Variables ncubochoric numexptsingle numdictsingle totnumexpt maskradius nnk platid devid nregions exptfile fn_f fn_s nthreads npix gF gS tF tS thetac filmthickness maskpattern xtalname xtalname2 energyfile filmfile subsfile masterfile datafile tmpfile ctffile anglefile eulerconvention gammavalue outputformat sampletilt workingdistance Rin Rout numangle numangle_anglefile numEbins numzbins nsx nsy num_el MCnthreads npx npy nE numset npolar nazimuth EkeV Ehistmin Ebinsize depthmax depthstep dmin MCsigstart MCsigend MCsigstep MComega MCmode anglemode sqorhe MCscversion Masterscversion Masterprogname Masterxtalname Masterenergyfile MCprogname MCxtalname Source Code ECPIndexingNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: ncubochoric integer(kind=irg), public :: numexptsingle integer(kind=irg), public :: numdictsingle integer(kind=irg), public :: totnumexpt integer(kind=irg), public :: maskradius integer(kind=irg), public :: nnk integer(kind=irg), public :: platid integer(kind=irg), public :: devid integer(kind=irg), public :: nregions character(len=fnlen), public :: exptfile integer(kind=irg), public :: fn_f (3) integer(kind=irg), public :: fn_s (3) integer(kind=irg), public :: nthreads integer(kind=irg), public :: npix integer(kind=irg), public :: gF (3) integer(kind=irg), public :: gS (3) integer(kind=irg), public :: tF (3) integer(kind=irg), public :: tS (3) real(kind=sgl), public :: thetac real(kind=sgl), public :: filmthickness character(len=1), public :: maskpattern character(len=fnlen), public :: xtalname character(len=fnlen), public :: xtalname2 character(len=fnlen), public :: energyfile character(len=fnlen), public :: filmfile character(len=fnlen), public :: subsfile character(len=fnlen), public :: masterfile character(len=fnlen), public :: datafile character(len=fnlen), public :: tmpfile character(len=fnlen), public :: ctffile character(len=fnlen), public :: anglefile character(len=3), public :: eulerconvention real(kind=sgl), public :: gammavalue character(len=3), public :: outputformat real(kind=dbl), public :: sampletilt real(kind=sgl), public :: workingdistance real(kind=sgl), public :: Rin real(kind=sgl), public :: Rout integer(kind=irg), public :: numangle integer(kind=irg), public :: numangle_anglefile integer(kind=irg), public :: numEbins integer(kind=irg), public :: numzbins integer(kind=irg), public :: nsx integer(kind=irg), public :: nsy integer(kind=irg), public :: num_el integer(kind=irg), public :: MCnthreads integer(kind=irg), public :: npx integer(kind=irg), public :: npy integer(kind=irg), public :: nE integer(kind=irg), public :: numset integer(kind=irg), public :: npolar integer(kind=irg), public :: nazimuth real(kind=dbl), public :: EkeV real(kind=dbl), public :: Ehistmin real(kind=dbl), public :: Ebinsize real(kind=dbl), public :: depthmax real(kind=dbl), public :: depthstep real(kind=sgl), public :: dmin real(kind=dbl), public :: MCsigstart real(kind=dbl), public :: MCsigend real(kind=dbl), public :: MCsigstep real(kind=dbl), public :: MComega character(len=4), public :: MCmode character(len=5), public :: anglemode character(len=6), public :: sqorhe character(len=8), public :: MCscversion character(len=8), public :: Masterscversion character(len=fnlen), public :: Masterprogname character(len=fnlen), public :: Masterxtalname character(len=fnlen), public :: Masterenergyfile character(len=fnlen), public :: MCprogname character(len=fnlen), public :: MCxtalname Source Code type ECPIndexingNameListType integer ( kind = irg ) :: ncubochoric integer ( kind = irg ) :: numexptsingle integer ( kind = irg ) :: numdictsingle integer ( kind = irg ) :: totnumexpt integer ( kind = irg ) :: maskradius integer ( kind = irg ) :: nnk integer ( kind = irg ) :: platid integer ( kind = irg ) :: devid integer ( kind = irg ) :: nregions character ( fnlen ) :: exptfile integer ( kind = irg ) :: fn_f ( 3 ) integer ( kind = irg ) :: fn_s ( 3 ) integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: npix integer ( kind = irg ) :: gF ( 3 ) integer ( kind = irg ) :: gS ( 3 ) integer ( kind = irg ) :: tF ( 3 ) integer ( kind = irg ) :: tS ( 3 ) real ( kind = sgl ) :: thetac real ( kind = sgl ) :: filmthickness character ( 1 ) :: maskpattern character ( fnlen ) :: xtalname character ( fnlen ) :: xtalname2 character ( fnlen ) :: energyfile character ( fnlen ) :: filmfile character ( fnlen ) :: subsfile character ( fnlen ) :: masterfile character ( fnlen ) :: datafile character ( fnlen ) :: tmpfile character ( fnlen ) :: ctffile character ( fnlen ) :: anglefile character ( 3 ) :: eulerconvention real ( kind = sgl ) :: gammavalue character ( 3 ) :: outputformat real ( kind = dbl ) :: sampletilt real ( kind = sgl ) :: workingdistance real ( kind = sgl ) :: Rin real ( kind = sgl ) :: Rout ! everything below here is not part of the namelist input structure, but is used to pass arguments to subroutines integer ( kind = irg ) :: numangle integer ( kind = irg ) :: numangle_anglefile integer ( kind = irg ) :: numEbins integer ( kind = irg ) :: numzbins integer ( kind = irg ) :: nsx integer ( kind = irg ) :: nsy integer ( kind = irg ) :: num_el integer ( kind = irg ) :: MCnthreads integer ( kind = irg ) :: npx integer ( kind = irg ) :: npy integer ( kind = irg ) :: nE integer ( kind = irg ) :: numset integer ( kind = irg ) :: npolar integer ( kind = irg ) :: nazimuth real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep real ( kind = sgl ) :: dmin real ( kind = dbl ) :: MCsigstart real ( kind = dbl ) :: MCsigend real ( kind = dbl ) :: MCsigstep real ( kind = dbl ) :: MComega character ( 4 ) :: MCmode ! Monte Carlo mode character ( 5 ) :: anglemode ! 'quats' or 'euler' for angular input character ( 6 ) :: sqorhe ! from Master file, square or hexagonal Lambert projection character ( 8 ) :: MCscversion character ( 8 ) :: Masterscversion character ( fnlen ) :: Masterprogname character ( fnlen ) :: Masterxtalname character ( fnlen ) :: Masterenergyfile character ( fnlen ) :: MCprogname character ( fnlen ) :: MCxtalname end type ECPIndexingNameListType","tags":"","loc":"type/ecpindexingnamelisttype.html","title":"ECPIndexingNameListType – Fortran Program "},{"text":"type, public :: ZAdefectnameListType Variables xtalname voltage kk lauec dmin progmode STEMnmlfile foilnmlfile DF_L DF_npix DF_npiy DF_slice dinfo sgname numdisl numsf numinc numvoids voidname dislname sfname incname dispfile dispmode dataname t_interval Source Code ZAdefectnameListType Components Type Visibility Attributes Name Initial character(len=fnlen), public :: xtalname real(kind=sgl), public :: voltage integer(kind=irg), public :: kk (3) real(kind=sgl), public :: lauec (2) real(kind=sgl), public :: dmin character(len=fnlen), public :: progmode character(len=fnlen), public :: STEMnmlfile character(len=fnlen), public :: foilnmlfile real(kind=sgl), public :: DF_L real(kind=sgl), public :: DF_npix real(kind=sgl), public :: DF_npiy real(kind=sgl), public :: DF_slice integer(kind=irg), public :: dinfo character(len=fnlen), public :: sgname integer(kind=irg), public :: numdisl integer(kind=irg), public :: numsf integer(kind=irg), public :: numinc integer(kind=irg), public :: numvoids character(len=fnlen), public :: voidname character(len=fnlen), public :: dislname character(len=fnlen), public :: sfname character(len=fnlen), public :: incname character(len=fnlen), public :: dispfile character(len=fnlen), public :: dispmode character(len=fnlen), public :: dataname integer(kind=irg), public :: t_interval Source Code type ZAdefectnameListType character ( fnlen ) :: xtalname real ( kind = sgl ) :: voltage integer ( kind = irg ) :: kk ( 3 ) real ( kind = sgl ) :: lauec ( 2 ) real ( kind = sgl ) :: dmin ! EM or STEM ? character ( fnlen ) :: progmode character ( fnlen ) :: STEMnmlfile character ( fnlen ) :: foilnmlfile ! column approximation parameters and image parameters real ( kind = sgl ) :: DF_L real ( kind = sgl ) :: DF_npix real ( kind = sgl ) :: DF_npiy real ( kind = sgl ) :: DF_slice integer ( kind = irg ) :: dinfo character ( fnlen ) :: sgname ! defect parameters integer ( kind = irg ) :: numdisl integer ( kind = irg ) :: numsf integer ( kind = irg ) :: numinc integer ( kind = irg ) :: numvoids character ( fnlen ) :: voidname character ( fnlen ) :: dislname character ( fnlen ) :: sfname character ( fnlen ) :: incname character ( fnlen ) :: dispfile character ( fnlen ) :: dispmode ! output parameters character ( fnlen ) :: dataname integer ( kind = irg ) :: t_interval end type ZAdefectnameListType","tags":"","loc":"type/zadefectnamelisttype.html","title":"ZAdefectnameListType – Fortran Program "},{"text":"type, public :: EMDPFitListType Variables modalityname masterfile exptfile rhobeg rhoend verbose mask maskradius gammavalue phi phi1 phi2 L thetac delta omega numsx numsy binning xpc ypc beamcurrent dwelltime npix Rin Rout thetacone sampletilt workingdistance step_xpc step_ypc step_L step_phi1 step_phi step_phi2 step_thetacone nrun nregions metric Source Code EMDPFitListType Components Type Visibility Attributes Name Initial character(len=fnlen), public :: modalityname character(len=fnlen), public :: masterfile character(len=fnlen), public :: exptfile real(kind=dbl), public :: rhobeg real(kind=dbl), public :: rhoend logical, public :: verbose logical, public :: mask real(kind=irg), public :: maskradius real(kind=sgl), public :: gammavalue real(kind=sgl), public :: phi real(kind=sgl), public :: phi1 real(kind=sgl), public :: phi2 real(kind=sgl), public :: L real(kind=sgl), public :: thetac real(kind=sgl), public :: delta real(kind=sgl), public :: omega integer(kind=irg), public :: numsx integer(kind=irg), public :: numsy integer(kind=irg), public :: binning real(kind=sgl), public :: xpc real(kind=sgl), public :: ypc real(kind=sgl), public :: beamcurrent real(kind=sgl), public :: dwelltime integer(kind=irg), public :: npix real(kind=sgl), public :: Rin real(kind=sgl), public :: Rout real(kind=sgl), public :: thetacone real(kind=sgl), public :: sampletilt real(kind=sgl), public :: workingdistance real(kind=sgl), public :: step_xpc real(kind=sgl), public :: step_ypc real(kind=sgl), public :: step_L real(kind=sgl), public :: step_phi1 real(kind=sgl), public :: step_phi real(kind=sgl), public :: step_phi2 real(kind=sgl), public :: step_thetacone integer(kind=irg), public :: nrun integer(kind=irg), public :: nregions character(len=2), public :: metric Source Code type EMDPFitListType character ( fnlen ) :: modalityname character ( fnlen ) :: masterfile character ( fnlen ) :: exptfile real ( kind = dbl ) :: rhobeg real ( kind = dbl ) :: rhoend logical :: verbose logical :: mask real ( kind = irg ) :: maskradius real ( kind = sgl ) :: gammavalue real ( kind = sgl ) :: phi , phi1 , phi2 real ( kind = sgl ) :: L real ( kind = sgl ) :: thetac real ( kind = sgl ) :: delta real ( kind = sgl ) :: omega integer ( kind = irg ) :: numsx integer ( kind = irg ) :: numsy integer ( kind = irg ) :: binning real ( kind = sgl ) :: xpc real ( kind = sgl ) :: ypc real ( kind = sgl ) :: beamcurrent real ( kind = sgl ) :: dwelltime integer ( kind = irg ) :: npix real ( kind = sgl ) :: Rin real ( kind = sgl ) :: Rout real ( kind = sgl ) :: thetacone real ( kind = sgl ) :: sampletilt real ( kind = sgl ) :: workingdistance real ( kind = sgl ) :: step_xpc real ( kind = sgl ) :: step_ypc real ( kind = sgl ) :: step_L real ( kind = sgl ) :: step_phi1 real ( kind = sgl ) :: step_phi real ( kind = sgl ) :: step_phi2 real ( kind = sgl ) :: step_thetacone integer ( kind = irg ) :: nrun integer ( kind = irg ) :: nregions character ( 2 ) :: metric end type EMDPFitListType","tags":"","loc":"type/emdpfitlisttype.html","title":"EMDPFitListType – Fortran Program "},{"text":"type, public :: EMDPFit4ListType Variables modalityname masterfile exptfile_pat1 exptfile_pat2 exptfile_pat3 exptfile_pat4 rhobeg rhoend verbose mask maskradius gammavalue phi_pat1 phi1_pat1 phi2_pat1 phi_pat2 phi1_pat2 phi2_pat2 phi_pat3 phi1_pat3 phi2_pat3 phi_pat4 phi1_pat4 phi2_pat4 L thetac delta omega numsx numsy binning xpc ypc beamcurrent dwelltime npix Rin Rout thetacone sampletilt workingdistance step_xpc step_ypc step_L step_phi1 step_phi step_phi2 step_thetacone nrun pixx_pat1 pixy_pat1 pixx_pat2 pixy_pat2 pixx_pat3 pixy_pat3 pixx_pat4 pixy_pat4 stepx stepy nregions metric Source Code EMDPFit4ListType Components Type Visibility Attributes Name Initial character(len=fnlen), public :: modalityname character(len=fnlen), public :: masterfile character(len=fnlen), public :: exptfile_pat1 character(len=fnlen), public :: exptfile_pat2 character(len=fnlen), public :: exptfile_pat3 character(len=fnlen), public :: exptfile_pat4 real(kind=dbl), public :: rhobeg real(kind=dbl), public :: rhoend logical, public :: verbose logical, public :: mask real(kind=irg), public :: maskradius real(kind=sgl), public :: gammavalue real(kind=sgl), public :: phi_pat1 real(kind=sgl), public :: phi1_pat1 real(kind=sgl), public :: phi2_pat1 real(kind=sgl), public :: phi_pat2 real(kind=sgl), public :: phi1_pat2 real(kind=sgl), public :: phi2_pat2 real(kind=sgl), public :: phi_pat3 real(kind=sgl), public :: phi1_pat3 real(kind=sgl), public :: phi2_pat3 real(kind=sgl), public :: phi_pat4 real(kind=sgl), public :: phi1_pat4 real(kind=sgl), public :: phi2_pat4 real(kind=sgl), public :: L real(kind=sgl), public :: thetac real(kind=sgl), public :: delta real(kind=sgl), public :: omega integer(kind=irg), public :: numsx integer(kind=irg), public :: numsy integer(kind=irg), public :: binning real(kind=sgl), public :: xpc real(kind=sgl), public :: ypc real(kind=sgl), public :: beamcurrent real(kind=sgl), public :: dwelltime integer(kind=irg), public :: npix real(kind=sgl), public :: Rin real(kind=sgl), public :: Rout real(kind=sgl), public :: thetacone real(kind=sgl), public :: sampletilt real(kind=sgl), public :: workingdistance real(kind=sgl), public :: step_xpc real(kind=sgl), public :: step_ypc real(kind=sgl), public :: step_L real(kind=sgl), public :: step_phi1 real(kind=sgl), public :: step_phi real(kind=sgl), public :: step_phi2 real(kind=sgl), public :: step_thetacone integer(kind=irg), public :: nrun integer(kind=irg), public :: pixx_pat1 integer(kind=irg), public :: pixy_pat1 integer(kind=irg), public :: pixx_pat2 integer(kind=irg), public :: pixy_pat2 integer(kind=irg), public :: pixx_pat3 integer(kind=irg), public :: pixy_pat3 integer(kind=irg), public :: pixx_pat4 integer(kind=irg), public :: pixy_pat4 real(kind=sgl), public :: stepx real(kind=sgl), public :: stepy integer(kind=irg), public :: nregions character(len=2), public :: metric Source Code type EMDPFit4ListType character ( fnlen ) :: modalityname character ( fnlen ) :: masterfile character ( fnlen ) :: exptfile_pat1 character ( fnlen ) :: exptfile_pat2 character ( fnlen ) :: exptfile_pat3 character ( fnlen ) :: exptfile_pat4 real ( kind = dbl ) :: rhobeg real ( kind = dbl ) :: rhoend logical :: verbose logical :: mask real ( kind = irg ) :: maskradius real ( kind = sgl ) :: gammavalue real ( kind = sgl ) :: phi_pat1 , phi1_pat1 , phi2_pat1 real ( kind = sgl ) :: phi_pat2 , phi1_pat2 , phi2_pat2 real ( kind = sgl ) :: phi_pat3 , phi1_pat3 , phi2_pat3 real ( kind = sgl ) :: phi_pat4 , phi1_pat4 , phi2_pat4 real ( kind = sgl ) :: L real ( kind = sgl ) :: thetac real ( kind = sgl ) :: delta real ( kind = sgl ) :: omega integer ( kind = irg ) :: numsx integer ( kind = irg ) :: numsy integer ( kind = irg ) :: binning real ( kind = sgl ) :: xpc real ( kind = sgl ) :: ypc real ( kind = sgl ) :: beamcurrent real ( kind = sgl ) :: dwelltime integer ( kind = irg ) :: npix real ( kind = sgl ) :: Rin real ( kind = sgl ) :: Rout real ( kind = sgl ) :: thetacone real ( kind = sgl ) :: sampletilt real ( kind = sgl ) :: workingdistance real ( kind = sgl ) :: step_xpc real ( kind = sgl ) :: step_ypc real ( kind = sgl ) :: step_L real ( kind = sgl ) :: step_phi1 real ( kind = sgl ) :: step_phi real ( kind = sgl ) :: step_phi2 real ( kind = sgl ) :: step_thetacone integer ( kind = irg ) :: nrun integer ( kind = irg ) :: pixx_pat1 integer ( kind = irg ) :: pixy_pat1 integer ( kind = irg ) :: pixx_pat2 integer ( kind = irg ) :: pixy_pat2 integer ( kind = irg ) :: pixx_pat3 integer ( kind = irg ) :: pixy_pat3 integer ( kind = irg ) :: pixx_pat4 integer ( kind = irg ) :: pixy_pat4 real ( kind = sgl ) :: stepx real ( kind = sgl ) :: stepy integer ( kind = irg ) :: nregions character ( 2 ) :: metric end type EMDPFit4ListType","tags":"","loc":"type/emdpfit4listtype.html","title":"EMDPFit4ListType – Fortran Program "},{"text":"type, public :: ECPSingleNameListType Variables nthreads npix thetac maskpattern xtalname energyfile datafile eulerconvention gammavalue sampletilt workingdistance Rin Rout phi1 phi phi2 dmin Source Code ECPSingleNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: nthreads integer(kind=irg), public :: npix real(kind=sgl), public :: thetac character(len=1), public :: maskpattern character(len=fnlen), public :: xtalname character(len=fnlen), public :: energyfile character(len=fnlen), public :: datafile character(len=3), public :: eulerconvention real(kind=sgl), public :: gammavalue real(kind=dbl), public :: sampletilt real(kind=sgl), public :: workingdistance real(kind=sgl), public :: Rin real(kind=sgl), public :: Rout real(kind=dbl), public :: phi1 real(kind=dbl), public :: phi real(kind=dbl), public :: phi2 real(kind=sgl), public :: dmin Source Code type ECPSingleNameListType integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: npix real ( kind = sgl ) :: thetac character ( 1 ) :: maskpattern character ( fnlen ) :: xtalname character ( fnlen ) :: energyfile character ( fnlen ) :: datafile character ( 3 ) :: eulerconvention real ( kind = sgl ) :: gammavalue real ( kind = dbl ) :: sampletilt real ( kind = sgl ) :: workingdistance real ( kind = sgl ) :: Rin real ( kind = sgl ) :: Rout real ( kind = dbl ) :: phi1 , phi , phi2 real ( kind = sgl ) :: dmin end type ECPSingleNameListType","tags":"","loc":"type/ecpsinglenamelisttype.html","title":"ECPSingleNameListType – Fortran Program "},{"text":"type, public :: STEMDCINameListType Variables nthreads voltage progmode xtalname kk lauec STEMnmlfile dataname defectfilename dispmode dispfile output dinfo t_interval DF_L DF_npix DF_npiy DF_slice dmin Source Code STEMDCINameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: nthreads real(kind=sgl), public :: voltage character(len=4), public :: progmode character(len=fnlen), public :: xtalname integer(kind=irg), public :: kk (3) real(kind=sgl), public :: lauec (2) character(len=fnlen), public :: STEMnmlfile character(len=fnlen), public :: dataname character(len=fnlen), public :: defectfilename character(len=3), public :: dispmode character(len=fnlen), public :: dispfile integer(kind=irg), public :: output integer(kind=irg), public :: dinfo integer(kind=irg), public :: t_interval real(kind=sgl), public :: DF_L integer(kind=irg), public :: DF_npix integer(kind=irg), public :: DF_npiy real(kind=sgl), public :: DF_slice real(kind=sgl), public :: dmin Source Code type STEMDCINameListType integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: voltage character ( 4 ) :: progmode character ( fnlen ) :: xtalname integer ( kind = irg ) :: kk ( 3 ) real ( kind = sgl ) :: lauec ( 2 ) character ( fnlen ) :: STEMnmlfile character ( fnlen ) :: dataname character ( fnlen ) :: defectfilename character ( 3 ) :: dispmode character ( fnlen ) :: dispfile integer ( kind = irg ) :: output integer ( kind = irg ) :: dinfo integer ( kind = irg ) :: t_interval real ( kind = sgl ) :: DF_L integer ( kind = irg ) :: DF_npix integer ( kind = irg ) :: DF_npiy real ( kind = sgl ) :: DF_slice real ( kind = sgl ) :: dmin end type STEMDCINameListType","tags":"","loc":"type/stemdcinamelisttype.html","title":"STEMDCINameListType – Fortran Program "},{"text":"type, public :: SRdefectNameListType Variables DF_L DF_npix DF_npiy DF_slice dmin progmode dinfo outputformat output dataname t_interval dispfile nthreads dispmode xtalname voltage SRG Grange GLaue STEMnmlfile defectfilename Source Code SRdefectNameListType Components Type Visibility Attributes Name Initial real(kind=sgl), public :: DF_L integer(kind=irg), public :: DF_npix integer(kind=irg), public :: DF_npiy real(kind=sgl), public :: DF_slice real(kind=sgl), public :: dmin character(len=4), public :: progmode integer(kind=irg), public :: dinfo character(len=3), public :: outputformat integer(kind=irg), public :: output character(len=fnlen), public :: dataname integer(kind=irg), public :: t_interval character(len=fnlen), public :: dispfile integer(kind=irg), public :: nthreads character(len=3), public :: dispmode character(len=fnlen), public :: xtalname real(kind=sgl), public :: voltage integer(kind=irg), public :: SRG (3) integer(kind=irg), public :: Grange real(kind=sgl), public :: GLaue character(len=fnlen), public :: STEMnmlfile character(len=fnlen), public :: defectfilename The following are now in ZAdefectnameListType Source Code type SRdefectNameListType real ( kind = sgl ) :: DF_L integer ( kind = irg ) :: DF_npix integer ( kind = irg ) :: DF_npiy real ( kind = sgl ) :: DF_slice real ( kind = sgl ) :: dmin character ( 4 ) :: progmode integer ( kind = irg ) :: dinfo character ( 3 ) :: outputformat integer ( kind = irg ) :: output character ( fnlen ) :: dataname integer ( kind = irg ) :: t_interval character ( fnlen ) :: dispfile integer ( kind = irg ) :: nthreads character ( 3 ) :: dispmode character ( fnlen ) :: xtalname real ( kind = sgl ) :: voltage integer ( kind = irg ) :: SRG ( 3 ) integer ( kind = irg ) :: Grange real ( kind = sgl ) :: GLaue character ( fnlen ) :: STEMnmlfile character ( fnlen ) :: defectfilename !! The following are now in ZAdefectnameListType ! :: foilnmlfile ! moved to ZAdefect type ! :: numvoids ! :: incname ! :: voidname ! :: numdisl ! :: dislname ! :: numsf ! :: sfname end type SRdefectNameListType","tags":"","loc":"type/srdefectnamelisttype.html","title":"SRdefectNameListType – Fortran Program "},{"text":"type, public :: RefineOrientationtype Variables nthreads dotproductfile ctffile step nmis niter Source Code RefineOrientationtype Components Type Visibility Attributes Name Initial integer(kind=irg), public :: nthreads character(len=fnlen), public :: dotproductfile character(len=fnlen), public :: ctffile real(kind=sgl), public :: step integer(kind=irg), public :: nmis integer(kind=irg), public :: niter Source Code type RefineOrientationtype integer ( kind = irg ) :: nthreads character ( fnlen ) :: dotproductfile character ( fnlen ) :: ctffile real ( kind = sgl ) :: step integer ( kind = irg ) :: nmis integer ( kind = irg ) :: niter end type RefineOrientationtype","tags":"","loc":"type/refineorientationtype.html","title":"RefineOrientationtype – Fortran Program "},{"text":"type, public :: FitOrientationPStype Variables nthreads dotproductfile ctffile step angleaxis Source Code FitOrientationPStype Components Type Visibility Attributes Name Initial integer(kind=irg), public :: nthreads character(len=fnlen), public :: dotproductfile character(len=fnlen), public :: ctffile real(kind=sgl), public :: step real(kind=sgl), public :: angleaxis (4) Source Code type FitOrientationPStype integer ( kind = irg ) :: nthreads character ( fnlen ) :: dotproductfile character ( fnlen ) :: ctffile real ( kind = sgl ) :: step real ( kind = sgl ) :: angleaxis ( 4 ) end type FitOrientationPStype","tags":"","loc":"type/fitorientationpstype.html","title":"FitOrientationPStype – Fortran Program "},{"text":"type, public :: PFInversionNameListType Variables nLam nSIRT ncub nfiles xtalname flist datafile Source Code PFInversionNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: nLam integer(kind=irg), public :: nSIRT integer(kind=irg), public :: ncub integer(kind=irg), public :: nfiles character(len=fnlen), public :: xtalname character(len=fnlen), public :: flist (10) character(len=fnlen), public :: datafile Source Code type PFInversionNameListType integer ( kind = irg ) :: nLam integer ( kind = irg ) :: nSIRT integer ( kind = irg ) :: ncub integer ( kind = irg ) :: nfiles character ( fnlen ) :: xtalname character ( fnlen ) :: flist ( 10 ) character ( fnlen ) :: datafile end type PFInversionNameListType","tags":"","loc":"type/pfinversionnamelisttype.html","title":"PFInversionNameListType – Fortran Program "},{"text":"type, public :: rng_t Variables state Source Code rng_t Components Type Visibility Attributes Name Initial integer, public, dimension(ns) :: state = default_seed Source Code type :: rng_t integer , dimension ( ns ) :: state = default_seed end type rng_t","tags":"","loc":"type/rng_t.html","title":"rng_t – Fortran Program "},{"text":"abstract interface public recursive subroutine func(nipar, nfpar, ninit, ipar, fpar, initmeanval, expt1, accum_e, mLPNH, mLPSH, n, x, f, nstep, stepsize, verbose) Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar integer(kind=irg), intent(in) :: ninit integer(kind=c_size_t), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fpar (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) real(kind=c_float), intent(in) :: expt1 (ipar(2)*ipar(3)/ipar(12)**2) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) integer(kind=irg), intent(in) :: n real(kind=dbl), intent(in), dimension(:) :: x real(kind=dbl), intent(out) :: f integer(kind=irg), intent(in) :: nstep real(kind=sgl), intent(in) :: stepsize (nstep) logical, intent(in), optional :: verbose Description calfun interface","tags":"","loc":"interface/func.html","title":"func – Fortran Program"},{"text":"abstract interface public recursive subroutine func2(ipar, initmeanval, expt, accum, mLPNH, mLPSH, n, x, f, mask, prefactor, rgx, rgy, rgz, stepsize, verbose) Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in) :: ipar (9) real(kind=sgl), intent(in) :: initmeanval (3) real(kind=c_float), intent(in) :: expt (ipar(2)*ipar(3)/ipar(1)**2) real(kind=sgl), intent(in) :: accum (ipar(6),ipar(2),ipar(3)) real(kind=sgl), intent(in) :: mLPNH (-ipar(4):ipar(4),-ipar(5):ipar(5),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(4):ipar(4),-ipar(5):ipar(5),ipar(7)) integer(kind=irg), intent(in) :: n real(kind=dbl), intent(in), dimension(:) :: x real(kind=dbl), intent(out) :: f real(kind=sgl), intent(in) :: mask (ipar(2)/ipar(1),ipar(3)/ipar(1)) real(kind=dbl), intent(in) :: prefactor real(kind=sgl), intent(in) :: rgx (ipar(2),ipar(3)) real(kind=sgl), intent(in) :: rgy (ipar(2),ipar(3)) real(kind=sgl), intent(in) :: rgz (ipar(2),ipar(3)) real(kind=sgl), intent(in) :: stepsize (3) logical, intent(in), optional :: verbose Description calfun interface","tags":"","loc":"interface/func2.html","title":"func2 – Fortran Program"},{"text":"abstract interface public subroutine ProgressCallBack(objAddress, patternCompleted) Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in), VALUE :: objAddress integer(kind=4), intent(in), VALUE :: patternCompleted","tags":"","loc":"interface/progresscallback.html","title":"ProgressCallBack – Fortran Program"},{"text":"abstract interface public subroutine ProgressCallBack2(objAddress, loopCompleted, totalLoops, bseYield) Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in), VALUE :: objAddress integer(kind=4), intent(in), VALUE :: loopCompleted integer(kind=4), intent(in), VALUE :: totalLoops real(kind=4), intent(in), VALUE :: bseYield","tags":"","loc":"interface/progresscallback2.html","title":"ProgressCallBack2 – Fortran Program"},{"text":"abstract interface public subroutine ProgressCallBack3(objAddress, loopCompleted, totalLoops, EloopCompleted, totalELoops) Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in), VALUE :: objAddress integer(kind=4), intent(in), VALUE :: loopCompleted integer(kind=4), intent(in), VALUE :: totalLoops integer(kind=4), intent(in), VALUE :: EloopCompleted integer(kind=4), intent(in), VALUE :: totalELoops","tags":"","loc":"interface/progresscallback3.html","title":"ProgressCallBack3 – Fortran Program"},{"text":"abstract interface public recursive subroutine func(nipar, nfpar, ninit, ipar, fpar, initmeanval, expt, accum_e, mLPNH, mLPSH, n, x, f, verbose) Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar integer(kind=irg), intent(in) :: ninit integer(kind=8), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fpar (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) real(kind=sgl), intent(in) :: expt (ipar(2)*ipar(3)) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) integer(kind=irg), intent(in) :: n real(kind=dbl), intent(in), dimension(:) :: x real(kind=dbl), intent(out) :: f logical, intent(in), optional :: verbose Description calfun interface","tags":"","loc":"interface/func~2.html","title":"func – Fortran Program"},{"text":"recursive subroutine CalcRLocal(numvoids, numdisl, numYdisl, numsf, numinc, lDFnums, lDFnpix, lDFnpiy, t_interval, disparray) Uses: local constants crystal crystalvars dislocation foilmodule void stacking_fault inclusion defectmodule timing YSHModule proc~~calcrlocal~~UsesGraph proc~calcrlocal CalcRLocal inclusion inclusion inclusion->proc~calcrlocal module~yshmodule YSHModule module~yshmodule->proc~calcrlocal local local local->proc~calcrlocal local->module~yshmodule module~defectmodule defectmodule local->module~defectmodule module~timing timing local->module~timing module~constants constants local->module~constants stacking_fault stacking_fault stacking_fault->proc~calcrlocal crystal crystal crystal->proc~calcrlocal foilmodule foilmodule foilmodule->proc~calcrlocal module~defectmodule->proc~calcrlocal void void void->proc~calcrlocal crystalvars crystalvars crystalvars->proc~calcrlocal module~timing->proc~calcrlocal dislocation dislocation dislocation->proc~calcrlocal module~constants->proc~calcrlocal quaternions quaternions quaternions->module~defectmodule typedefs typedefs typedefs->module~defectmodule typedefs->module~timing io io io->module~timing Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name integer(kind=irg) :: numvoids integer(kind=irg) :: numdisl integer(kind=irg) :: numYdisl integer(kind=irg) :: numsf integer(kind=irg) :: numinc integer(kind=irg) :: lDFnums integer(kind=irg) :: lDFnpix integer(kind=irg) :: lDFnpiy integer(kind=irg) :: t_interval real(kind=sgl) :: disparray (lDFnums,lDFnpix,lDFnpiy,3) Calls proc~~calcrlocal~~CallsGraph proc~calcrlocal CalcRLocal float float proc~calcrlocal->float proc~time_reset Time_reset proc~calcrlocal->proc~time_reset proc~time_start Time_start proc~calcrlocal->proc~time_start proc~yshdisp YSHDisp proc~calcrlocal->proc~yshdisp proc~time_remaining Time_remaining proc~calcrlocal->proc~time_remaining sngl sngl proc~calcrlocal->sngl proc~time_stop Time_stop proc~calcrlocal->proc~time_stop proc~time_report Time_report proc~calcrlocal->proc~time_report proc~time_start->proc~time_reset datan2 datan2 proc~yshdisp->datan2 proc~time_remaining->float proc~printtime PrintTime proc~time_remaining->proc~printtime writevalue writevalue proc~time_remaining->writevalue message message proc~time_remaining->message proc~time_stop->float proc~time_stop->proc~printtime proc~time_stop->writevalue proc~time_stop->message proc~time_report->message proc~printtime->writevalue Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~calcrlocal~~CalledByGraph proc~calcrlocal CalcRLocal program~dispfield dispfield program~dispfield->proc~calcrlocal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code CalcRLocal Source Code recursive subroutine CalcRLocal ( numvoids , numdisl , numYdisl , numsf , numinc , lDFnums , lDFnpix , lDFnpiy , t_interval , disparray ) ! this routine returns the total displacement field (multithreaded with OPENMP) use local use constants use crystal use crystalvars use dislocation use foilmodule use void use stacking_fault use inclusion use defectmodule use timing use YSHModule IMPLICIT NONE integer ( kind = irg ) :: i , j , k , ii , islice , numvoids , numdisl , numYdisl , numsf , numinc , lDFnums , lDFnpix , lDFnpiy , & TID , NTHR , imat , t_interval , jcnt real ( kind = sgl ) :: disparray ( lDFnums , lDFnpix , lDFnpiy , 3 ) real ( kind = sgl ) :: rx , ry , rz , dis , xpos , ypos , zpos , RR ( 3 ), sumR ( 3 ), thick , tmp ( 3 ), tmpf ( 3 ), u ( 3 ), zaamp , zaphase , zar , zai , zr ( 3 ), zi ( 3 ), & zt , fx , fy , fz , z0 , gdotR , nunit ( 3 ) !,& !                                nu,x,y,z,zn,t,pre,r1,r2,r3,th,rn real ( kind = dbl ) :: afi ( 3 , 3 ), afc ( 3 , 3 ), lDFR ( 3 ) complex ( kind = dbl ) :: za ( 3 ) complex ( kind = sgl ) :: zero logical :: void type ( voidtype ), allocatable :: lvoids (:) real ( kind = sgl ), allocatable :: lsg (:,:) type ( dislocationtype ), allocatable :: lDL (:) type ( YDtype ), allocatable :: YDL (:) type ( stackingfaulttype ), allocatable :: lSF (:) type ( inclusiontype ), allocatable :: linclusions (:) ! before we start the threads, we need to copy data from various modules ! into local variables that can then be accessed by the threads ... Nmat = 10000 ! foil unit normal in microscope frame nunit = matmul ( foil % Fn , transpose ( foil % a_mc )) ! foil normal parameters for zpos computation fx = - nunit ( 1 ) / nunit ( 3 ) fy = - nunit ( 2 ) / nunit ( 3 ) fz = foil % zb * 0.5 ! other parameters z0 = foil % z0 thick = foil % zb zero = cmplx ( 0.0 , 0.0 ) afi = foil % a_fi afc = foil % a_fc if ( allocated ( voids )) then allocate ( lvoids ( numvoids )) lvoids = voids endif allocate ( lsg ( foil % npix , foil % npiy )) lsg = foil % sg if ( allocated ( DL )) then allocate ( lDL ( numdisl + 2 * numsf )) lDL = DL endif if ( allocated ( YD )) then allocate ( YDL ( numYdisl )) YDL = YD endif if ( allocated ( SF )) then allocate ( lSF ( numsf )) do ii = 1 , numsf allocate ( lSF ( ii )% zpos ( foil % npix , foil % npiy )) end do lSF = SF endif if ( allocated ( inclusions )) then allocate ( linclusions ( numinc )) linclusions = inclusions end if ! ok, we've copied all the necessary variables into local structures ! now we can perform the multi-threaded loop ! initiate multi-threaded segment !$OMP     PARALLEL PRIVATE(TID,lDFR,gdotR,i,j,k,imat,zt,xpos,ypos,zpos,islice,dis,sumR,tmp,tmpf, & !$OMP&   ii,void,za,zar,zai,zaamp,zaphase,zr,zi,u,jcnt) & !$OMP&   SHARED(NTHR,lDFnpix,lDFnpiy,lDFnums,DF_L,numvoids,numdisl,numsf,numinc,disparray,t_interval, & !$OMP&    fx,fy,fz,z0,thick,zero,afi,afc,lvoids,lsg,lSF,linclusions,lDL,Nmat,YDL) !  NTHR = OMP_GET_NUM_THREADS() !  TID = OMP_GET_THREAD_NUM() TID = 0 NTHR = 1 if ( TID . eq . 0 ) then ! do time reporting only in the master thread write ( * , * ) 'Message from master thread ' , TID , ': splitting into ' , NTHR , ' threads ' call Time_reset call Time_report ( 0.01 * t_interval ) call Time_start jcnt = 0 end if !$OMP barrier !$OMP DO SCHEDULE (GUIDED) do i = 1 , lDFnpix do j = 1 , lDFnpiy ! compute the displacement vectors lDFR for all points in this column ! scale the image coordinates with respect to the origin at the center of the image; ! this is where we need to include the zoom factor ... xpos = float ( i - lDFnpix / 2 ) * DF_L ypos = float ( j - lDFnpiy / 2 ) * DF_L zt = ( xpos * fx + ypos * fy + fz ) ! loop over all slices (this is the main loop) sliceloop : do islice = 1 , lDFnums lDFR = 0.0 ! zpos is the position down the column, starting at zt (in image coordinates) zpos = zt - float ( islice ) * DF_slice ! set the displacements to zero sumR = 0.0 ! convert image point (xpos,ypos,zpos) to tmpf in the foil reference frame !       tmpf = matmul(matmul( (/ xpos, ypos, zpos /),transpose(afi)),afc) tmpf = matmul ( ( / xpos , ypos , zpos / ), transpose ( afi )) ! let's put a few dislocations in ... (see section 8.4.2) do ii = 1 , numdisl ! convert the defect location from untilted image space to the tilted foil reference frame, and subtract it from the current ! column and slice position tmp = ( / xpos , ypos , zpos / ) - matmul ( ( / DF_L * lDL ( ii )% id , DF_L * lDL ( ii )% jd , lDL ( ii )% zfrac * z0 / ), transpose ( afi ) ) ! then convert the difference vector to the defect reference frame for this dislocation (we will only need the x and y coordinates) tmp = matmul ( tmp , lDL ( ii )% a_id ) ! check the z-coordinate; if it falls beyond the dislocation line that is inside the foil, then skip ! the displacement computation... the top and bottom coordinates of the dislocation intersections ! measured along the dislocation line were pre-computed when the dislocations were first read from ! the namelist files... !         if (abs(tmp(3)).le.lDL(ii)%zu) then ! compute x1 + p_alpha x2  (eq. 8.38) za ( 1 : 3 ) = tmp ( 1 ) + lDL ( ii )% pa ( 1 : 3 ) * tmp ( 2 ) ! compute the displacement vector u (eq. 8.38) [this expands the log of a complex number and takes the real part only] if ( tmp ( 1 ). gt . 0.0 ) then do k = 1 , 3 zar = real ( za ( k )) zai = aimag ( za ( k )) zaamp = abs ( za ( k )) zaphase = abs ( zai / zar ) zr ( k ) = log ( zaamp ) zi ( k ) = atan ( zaphase ) if ( zar . le . 0.0 ) then if ( zai . lt . 0.0 ) zi ( k ) = - cPi + zi ( k ) if ( zai . eq . 0.0 ) zi ( k ) = cPi if ( zai . gt . 0.0 ) zi ( k ) = cPi - zi ( k ) else if ( zai . lt . 0.0 ) zi ( k ) = - zi ( k ) end if end do else do k = 1 , 3 zar = real ( za ( k )) zai = aimag ( za ( k )) zaamp = abs ( za ( k )) zaphase = abs ( zai / zar ) zr ( k ) = log ( zaamp ) zi ( k ) = atan ( zaphase ) if ( zar . le . 0.0 ) then if ( zai . gt . 0.0 ) zi ( k ) = cPi - zi ( k ) if ( zai . eq . 0.0 ) zi ( k ) = cPi if ( zai . lt . 0.0 ) zi ( k ) = cPi + zi ( k ) else if ( zai . lt . 0.0 ) zi ( k ) = 2.0 * cPi - zi ( k ) if ( zai . eq . 0.0 ) zi ( k ) = 0.0 end if end do end if u = 2.0 * real ( matmul ( lDL ( ii )% dismat , cmplx ( zr , zi ))) ! transform displacement vector u to the Cartesian crystal reference frame and then to the foil frame u = matmul ( matmul ( u , lDL ( ii )% a_dc ), transpose ( afc )) sumR = sumR + u !         end if end do ! do we have any dislocations with surface relaxations ?  YSH model if ( numYdisl . gt . 0 ) then do ii = 1 , numYdisl ! first, figure out what the coordinates are in the YSH reference frame for this dislocation ... ! translate to the defect origin tmp = ( / xpos , ypos , zpos / ) - ( / DF_L * YDL ( ii )% id , DF_L * YDL ( ii )% jd , z0 * 0.5 / ) ! rotate into the defect reference frame tmp = matmul ( tmp , YDL ( ii )% a_id ) ! compute the displacement vector u = sngl ( YSHDisp ( dble ( tmp ( 1 )), dble ( tmp ( 2 )), dble ( tmp ( 3 )), ii )) !         write (*,*) u ! and rotate back to the image reference frame u = matmul ( u , YDL ( ii )% a_di ) ! that should do it ! sumR = sumR + u end do end if ! stacking faults (this is easy because we've already done all the work in the stacking_fault module) !       do ii=1,numsf !         if ((zpos.lt.lSF(ii)%zpos(i,j)).and.(lSF(ii)%zpos(i,j).ne.-10000.0)) then !           sumR = sumR + lSF(ii)%lpbc !         end if !       end do ! write(*,*) sumR(1:3) disparray ( islice , i , j , 1 : 3 ) = sumR ( 1 : 3 ) !      if (i.eq.10) write (*,*) sumR(1:3) end do sliceloop end do ! j-loop if ( TID . eq . 0 ) then jcnt = jcnt + 1 if ( mod ( jcnt , t_interval ). eq . 0 ) call Time_remaining ( jcnt , lDFnpix / NTHR ) endif end do ! i-loop !$OMP END DO if ( TID . eq . 0 ) call Time_stop ( DF_npix * DF_npiy ) !$OMP END PARALLEL end subroutine CalcRLocal","tags":"","loc":"proc/calcrlocal.html","title":"CalcRLocal – Fortran Program"},{"text":"function pythag(a, b) PYTHAG computes SQRT ( A * A + B * B ) carefully. Arguments Type Intent Optional Attributes Name real(kind=8) :: a real(kind=8) :: b Return Value real(kind=8)","tags":"","loc":"proc/pythag.html","title":"pythag – Fortran Program"},{"text":"subroutine bakvec(n, t, e, m, z, ierr) BAKVEC determines eigenvectors by reversing the FIGI transformation. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: t (n,3) real(kind=8) :: e (n) integer(kind=4) :: m real(kind=8) :: z (n,m) integer(kind=4) :: ierr","tags":"","loc":"proc/bakvec.html","title":"bakvec – Fortran Program"},{"text":"subroutine balanc(n, a, low, igh, scale) BALANC balances a real matrix before eigenvalue calculations. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: a (n,n) integer(kind=4) :: low integer(kind=4) :: igh real(kind=8) :: scale (n) Calls proc~~balanc~~CallsGraph proc~balanc balanc proc~r8_swap r8_swap proc~balanc->proc~r8_swap Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~balanc~~CalledByGraph proc~balanc balanc proc~rg rg proc~rg->proc~balanc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/balanc.html","title":"balanc – Fortran Program"},{"text":"subroutine balbak(n, low, igh, scale, m, z) BALBAK determines eigenvectors by undoing the BALANC transformation. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n integer(kind=4) :: low integer(kind=4) :: igh real(kind=8) :: scale (n) integer(kind=4) :: m real(kind=8) :: z (n,m) Calls proc~~balbak~~CallsGraph proc~balbak balbak proc~r8_swap r8_swap proc~balbak->proc~r8_swap Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~balbak~~CalledByGraph proc~balbak balbak proc~rg rg proc~rg->proc~balbak Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/balbak.html","title":"balbak – Fortran Program"},{"text":"subroutine bandr(n, mb, a, d, e, e2, matz, z) BANDR reduces a symmetric band matrix to symmetric tridiagonal form. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n integer(kind=4) :: mb real(kind=8) :: a (n,mb) real(kind=8) :: d (n) real(kind=8) :: e (n) real(kind=8) :: e2 (n) logical :: matz real(kind=8) :: z (n,n) Called By proc~~bandr~~CalledByGraph proc~bandr bandr proc~rsb rsb proc~rsb->proc~bandr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/bandr.html","title":"bandr – Fortran Program"},{"text":"subroutine bandv(n, mbw, a, e21, m, w, z, ierr) BANDV finds eigenvectors from eigenvalues, for a real symmetric band matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n integer(kind=4) :: mbw real(kind=8) :: a (n,mbw) real(kind=8) :: e21 integer(kind=4) :: m real(kind=8) :: w (m) real(kind=8) :: z (n,m) integer(kind=4) :: ierr Calls proc~~bandv~~CallsGraph proc~bandv bandv proc~r8_swap r8_swap proc~bandv->proc~r8_swap Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/bandv.html","title":"bandv – Fortran Program"},{"text":"subroutine bisect(n, eps1, d, e, e2, lb, ub, mm, m, w, ind, ierr) BISECT computes some eigenvalues of a real symmetric tridiagonal matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: eps1 real(kind=8) :: d (n) real(kind=8) :: e (n) real(kind=8) :: e2 (n) real(kind=8) :: lb real(kind=8) :: ub integer(kind=4) :: mm integer(kind=4) :: m real(kind=8) :: w (mm) integer(kind=4) :: ind (mm) integer(kind=4) :: ierr Calls proc~~bisect~~CallsGraph proc~bisect bisect to to proc~bisect->to Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/bisect.html","title":"bisect – Fortran Program"},{"text":"subroutine bqr(n, mb, a, t, r, ierr) BQR finds the smallest eigenvalue of a real symmetric band matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n integer(kind=4) :: mb real(kind=8) :: a (n,mb) real(kind=8) :: t real(kind=8) :: r integer(kind=4) :: ierr","tags":"","loc":"proc/bqr.html","title":"bqr – Fortran Program"},{"text":"subroutine cbabk2(n, low, igh, scale, m, zr, zi) CBABK2 finds eigenvectors by undoing the CBAL transformation. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n integer(kind=4) :: low integer(kind=4) :: igh real(kind=8) :: scale (n) integer(kind=4) :: m real(kind=8) :: zr (n,m) real(kind=8) :: zi (n,m) Calls proc~~cbabk2~~CallsGraph proc~cbabk2 cbabk2 proc~r8_swap r8_swap proc~cbabk2->proc~r8_swap Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~cbabk2~~CalledByGraph proc~cbabk2 cbabk2 proc~cg cg proc~cg->proc~cbabk2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/cbabk2.html","title":"cbabk2 – Fortran Program"},{"text":"subroutine cbal(n, ar, ai, low, igh, scale) CBAL balances a complex matrix before eigenvalue calculations. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: ar (n,n) real(kind=8) :: ai (n,n) integer(kind=4) :: low integer(kind=4) :: igh real(kind=8) :: scale (n) Calls proc~~cbal~~CallsGraph proc~cbal cbal proc~r8_swap r8_swap proc~cbal->proc~r8_swap Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~cbal~~CalledByGraph proc~cbal cbal proc~cg cg proc~cg->proc~cbal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/cbal.html","title":"cbal – Fortran Program"},{"text":"subroutine cdiv(ar, ai, br, bi, cr, ci) CDIV emulates complex division, using real arithmetic. Arguments Type Intent Optional Attributes Name real(kind=8) :: ar real(kind=8) :: ai real(kind=8) :: br real(kind=8) :: bi real(kind=8) :: cr real(kind=8) :: ci Called By proc~~cdiv~~CalledByGraph proc~cdiv cdiv proc~comqr2 comqr2 proc~comqr2->proc~cdiv proc~cinvit cinvit proc~cinvit->proc~cdiv proc~hqr2 hqr2 proc~hqr2->proc~cdiv proc~comlr comlr proc~comlr->proc~cdiv proc~comqr comqr proc~comqr->proc~cdiv proc~comlr2 comlr2 proc~comlr2->proc~cdiv proc~comhes comhes proc~comhes->proc~cdiv proc~invit invit proc~invit->proc~cdiv proc~cg cg proc~cg->proc~comqr2 proc~cg->proc~comqr proc~rg rg proc~rg->proc~hqr2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/cdiv.html","title":"cdiv – Fortran Program"},{"text":"subroutine cg(n, ar, ai, wr, wi, matz, zr, zi, ierr) CG gets eigenvalues and eigenvectors of a complex general matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: ar (n,n) real(kind=8) :: ai (n,n) real(kind=8) :: wr (n) real(kind=8) :: wi (n) integer(kind=4) :: matz real(kind=8) :: zr (n,n) real(kind=8) :: zi (n,n) integer(kind=4) :: ierr Calls proc~~cg~~CallsGraph proc~cg cg proc~cbal cbal proc~cg->proc~cbal proc~comqr2 comqr2 proc~cg->proc~comqr2 proc~corth corth proc~cg->proc~corth proc~cbabk2 cbabk2 proc~cg->proc~cbabk2 proc~comqr comqr proc~cg->proc~comqr proc~r8_swap r8_swap proc~cbal->proc~r8_swap proc~csroot csroot proc~comqr2->proc~csroot proc~cdiv cdiv proc~comqr2->proc~cdiv proc~cbabk2->proc~r8_swap proc~comqr->proc~csroot proc~comqr->proc~cdiv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/cg.html","title":"cg – Fortran Program"},{"text":"subroutine ch(n, ar, ai, w, matz, zr, zi, ierr) CH gets eigenvalues and eigenvectors of a complex Hermitian matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: ar (n,n) real(kind=8) :: ai (n,n) real(kind=8) :: w (n) integer(kind=4) :: matz real(kind=8) :: zr (n,n) real(kind=8) :: zi (n,n) integer(kind=4) :: ierr Calls proc~~ch~~CallsGraph proc~ch ch proc~tqlrat tqlrat proc~ch->proc~tqlrat proc~htridi htridi proc~ch->proc~htridi proc~htribk htribk proc~ch->proc~htribk proc~tql2 tql2 proc~ch->proc~tql2 proc~r8_swap r8_swap proc~tql2->proc~r8_swap Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/ch.html","title":"ch – Fortran Program"},{"text":"subroutine cinvit(n, ar, ai, wr, wi, select, mm, m, zr, zi, ierr) CINVIT gets eigenvectors from eigenvalues, for a complex Hessenberg matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: ar (n,n) real(kind=8) :: ai (n,n) real(kind=8) :: wr (n) real(kind=8) :: wi (n) logical :: select (n) integer(kind=4) :: mm integer(kind=4) :: m real(kind=8) :: zr (n,mm) real(kind=8) :: zi (n,mm) integer(kind=4) :: ierr Calls proc~~cinvit~~CallsGraph proc~cinvit cinvit proc~r8_swap r8_swap proc~cinvit->proc~r8_swap proc~cdiv cdiv proc~cinvit->proc~cdiv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/cinvit.html","title":"cinvit – Fortran Program"},{"text":"subroutine combak(n, low, igh, ar, ai, int, m, zr, zi) COMBAK determines eigenvectors by undoing the COMHES transformation. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n integer(kind=4) :: low integer(kind=4) :: igh real(kind=8) :: ar (n,igh) real(kind=8) :: ai (n,igh) integer(kind=4) :: int (igh) integer(kind=4) :: m real(kind=8) :: zr (n,m) real(kind=8) :: zi (n,m) Calls proc~~combak~~CallsGraph proc~combak combak proc~r8_swap r8_swap proc~combak->proc~r8_swap Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/combak.html","title":"combak – Fortran Program"},{"text":"subroutine comhes(n, low, igh, ar, ai, int) COMHES transforms a complex general matrix to upper Hessenberg form. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n integer(kind=4) :: low integer(kind=4) :: igh real(kind=8) :: ar (n,n) real(kind=8) :: ai (n,n) integer(kind=4) :: int (igh) Calls proc~~comhes~~CallsGraph proc~comhes comhes proc~r8_swap r8_swap proc~comhes->proc~r8_swap proc~cdiv cdiv proc~comhes->proc~cdiv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/comhes.html","title":"comhes – Fortran Program"},{"text":"subroutine comlr(n, low, igh, hr, hi, wr, wi, ierr) COMLR gets all eigenvalues of a complex upper Hessenberg matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n integer(kind=4) :: low integer(kind=4) :: igh real(kind=8) :: hr (n,n) real(kind=8) :: hi (n,n) real(kind=8) :: wr (n) real(kind=8) :: wi (n) integer(kind=4) :: ierr Calls proc~~comlr~~CallsGraph proc~comlr comlr proc~csroot csroot proc~comlr->proc~csroot proc~cdiv cdiv proc~comlr->proc~cdiv proc~r8_swap r8_swap proc~comlr->proc~r8_swap Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/comlr.html","title":"comlr – Fortran Program"},{"text":"subroutine comlr2(n, low, igh, int, hr, hi, wr, wi, zr, zi, ierr) COMLR2 gets eigenvalues/vectors of a complex upper Hessenberg matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n integer(kind=4) :: low integer(kind=4) :: igh integer(kind=4) :: int (igh) real(kind=8) :: hr (n,n) real(kind=8) :: hi (n,n) real(kind=8) :: wr (n) real(kind=8) :: wi (n) real(kind=8) :: zr (n,n) real(kind=8) :: zi (n,n) integer(kind=4) :: ierr Calls proc~~comlr2~~CallsGraph proc~comlr2 comlr2 proc~csroot csroot proc~comlr2->proc~csroot proc~cdiv cdiv proc~comlr2->proc~cdiv proc~r8_swap r8_swap proc~comlr2->proc~r8_swap Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/comlr2.html","title":"comlr2 – Fortran Program"},{"text":"subroutine comqr(n, low, igh, hr, hi, wr, wi, ierr) COMQR gets eigenvalues of a complex upper Hessenberg matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n integer(kind=4) :: low integer(kind=4) :: igh real(kind=8) :: hr (n,n) real(kind=8) :: hi (n,n) real(kind=8) :: wr (n) real(kind=8) :: wi (n) integer(kind=4) :: ierr Calls proc~~comqr~~CallsGraph proc~comqr comqr proc~csroot csroot proc~comqr->proc~csroot proc~cdiv cdiv proc~comqr->proc~cdiv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~comqr~~CalledByGraph proc~comqr comqr proc~cg cg proc~cg->proc~comqr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/comqr.html","title":"comqr – Fortran Program"},{"text":"subroutine comqr2(n, low, igh, ortr, orti, hr, hi, wr, wi, zr, zi, ierr) COMQR2 gets eigenvalues/vectors of a complex upper Hessenberg matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n integer(kind=4) :: low integer(kind=4) :: igh real(kind=8) :: ortr (igh) real(kind=8) :: orti (igh) real(kind=8) :: hr (n,n) real(kind=8) :: hi (n,n) real(kind=8) :: wr (n) real(kind=8) :: wi (n) real(kind=8) :: zr (n,n) real(kind=8) :: zi (n,n) integer(kind=4) :: ierr Calls proc~~comqr2~~CallsGraph proc~comqr2 comqr2 proc~csroot csroot proc~comqr2->proc~csroot proc~cdiv cdiv proc~comqr2->proc~cdiv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~comqr2~~CalledByGraph proc~comqr2 comqr2 proc~cg cg proc~cg->proc~comqr2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/comqr2.html","title":"comqr2 – Fortran Program"},{"text":"subroutine cortb(n, low, igh, ar, ai, ortr, orti, m, zr, zi) CORTB determines eigenvectors by undoing the CORTH transformation. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n integer(kind=4) :: low integer(kind=4) :: igh real(kind=8) :: ar (n,igh) real(kind=8) :: ai (n,igh) real(kind=8) :: ortr (igh) real(kind=8) :: orti (igh) integer(kind=4) :: m real(kind=8) :: zr (n,m) real(kind=8) :: zi (n,m)","tags":"","loc":"proc/cortb.html","title":"cortb – Fortran Program"},{"text":"subroutine corth(n, low, igh, ar, ai, ortr, orti) CORTH transforms a complex general matrix to upper Hessenberg form. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n integer(kind=4) :: low integer(kind=4) :: igh real(kind=8) :: ar (n,n) real(kind=8) :: ai (n,n) real(kind=8) :: ortr (igh) real(kind=8) :: orti (igh) Called By proc~~corth~~CalledByGraph proc~corth corth proc~cg cg proc~cg->proc~corth Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/corth.html","title":"corth – Fortran Program"},{"text":"subroutine csroot(xr, xi, yr, yi) CSROOT computes the complex square root of a complex quantity. Arguments Type Intent Optional Attributes Name real(kind=8) :: xr real(kind=8) :: xi real(kind=8) :: yr real(kind=8) :: yi Called By proc~~csroot~~CalledByGraph proc~csroot csroot proc~comlr comlr proc~comlr->proc~csroot proc~comlr2 comlr2 proc~comlr2->proc~csroot proc~comqr comqr proc~comqr->proc~csroot proc~comqr2 comqr2 proc~comqr2->proc~csroot proc~cg cg proc~cg->proc~comqr proc~cg->proc~comqr2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/csroot.html","title":"csroot – Fortran Program"},{"text":"subroutine elmbak(n, low, igh, a, ind, m, z) ELMBAK determines eigenvectors by undoing the ELMHES transformation. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n integer(kind=4) :: low integer(kind=4) :: igh real(kind=8) :: a (n,igh) integer(kind=4) :: ind (igh) integer(kind=4) :: m real(kind=8) :: z (n,m) Calls proc~~elmbak~~CallsGraph proc~elmbak elmbak proc~r8_swap r8_swap proc~elmbak->proc~r8_swap Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/elmbak.html","title":"elmbak – Fortran Program"},{"text":"subroutine elmhes(n, low, igh, a, ind) ELMHES transforms a real general matrix to upper Hessenberg form. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n integer(kind=4) :: low integer(kind=4) :: igh real(kind=8) :: a (n,n) integer(kind=4) :: ind (igh) Calls proc~~elmhes~~CallsGraph proc~elmhes elmhes proc~r8_swap r8_swap proc~elmhes->proc~r8_swap Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~elmhes~~CalledByGraph proc~elmhes elmhes proc~rg rg proc~rg->proc~elmhes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/elmhes.html","title":"elmhes – Fortran Program"},{"text":"subroutine eltran(n, low, igh, a, ind, z) ELTRAN accumulates similarity transformations used by ELMHES. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n integer(kind=4) :: low integer(kind=4) :: igh real(kind=8) :: a (n,igh) integer(kind=4) :: ind (igh) real(kind=8) :: z (n,n) Called By proc~~eltran~~CalledByGraph proc~eltran eltran proc~rg rg proc~rg->proc~eltran Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/eltran.html","title":"eltran – Fortran Program"},{"text":"subroutine figi(n, t, d, e, e2, ierr) FIGI transforms a real nonsymmetric tridiagonal matrix to symmetric form. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: t (n,3) real(kind=8) :: d (n) real(kind=8) :: e (n) real(kind=8) :: e2 (n) integer(kind=4) :: ierr Called By proc~~figi~~CalledByGraph proc~figi figi proc~rt rt proc~rt->proc~figi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/figi.html","title":"figi – Fortran Program"},{"text":"subroutine figi2(n, t, d, e, z, ierr) FIGI2 transforms a real nonsymmetric tridiagonal matrix to symmetric form. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: t (n,3) real(kind=8) :: d (n) real(kind=8) :: e (n) real(kind=8) :: z (n,n) integer(kind=4) :: ierr Called By proc~~figi2~~CalledByGraph proc~figi2 figi2 proc~rt rt proc~rt->proc~figi2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/figi2.html","title":"figi2 – Fortran Program"},{"text":"subroutine hqr(n, low, igh, h, wr, wi, ierr) HQR computes all eigenvalues of a real upper Hessenberg matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n integer(kind=4) :: low integer(kind=4) :: igh real(kind=8) :: h (n,n) real(kind=8) :: wr (n) real(kind=8) :: wi (n) integer(kind=4) :: ierr Called By proc~~hqr~~CalledByGraph proc~hqr hqr proc~rg rg proc~rg->proc~hqr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/hqr.html","title":"hqr – Fortran Program"},{"text":"subroutine hqr2(n, low, igh, h, wr, wi, z, ierr) HQR2 computes eigenvalues and eigenvectors of a real upper Hessenberg matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n integer(kind=4) :: low integer(kind=4) :: igh real(kind=8) :: h (n,n) real(kind=8) :: wr (n) real(kind=8) :: wi (n) real(kind=8) :: z (n,n) integer(kind=4) :: ierr Calls proc~~hqr2~~CallsGraph proc~hqr2 hqr2 proc~cdiv cdiv proc~hqr2->proc~cdiv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~hqr2~~CalledByGraph proc~hqr2 hqr2 proc~rg rg proc~rg->proc~hqr2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/hqr2.html","title":"hqr2 – Fortran Program"},{"text":"subroutine htrib3(n, a, tau, m, zr, zi) HTRIB3 determines eigenvectors by undoing the HTRID3 transformation. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: a (n,n) real(kind=8) :: tau (2,n) integer(kind=4) :: m real(kind=8) :: zr (n,m) real(kind=8) :: zi (n,m)","tags":"","loc":"proc/htrib3.html","title":"htrib3 – Fortran Program"},{"text":"subroutine htribk(n, ar, ai, tau, m, zr, zi) HTRIBK determines eigenvectors by undoing the HTRIDI transformation. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: ar (n,n) real(kind=8) :: ai (n,n) real(kind=8) :: tau (2,n) integer(kind=4) :: m real(kind=8) :: zr (n,m) real(kind=8) :: zi (n,m) Called By proc~~htribk~~CalledByGraph proc~htribk htribk proc~ch ch proc~ch->proc~htribk Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/htribk.html","title":"htribk – Fortran Program"},{"text":"subroutine htrid3(n, a, d, e, e2, tau) HTRID3 tridiagonalizes a complex hermitian packed matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: a (n,n) real(kind=8) :: d (n) real(kind=8) :: e (n) real(kind=8) :: e2 (n) real(kind=8) :: tau (2,n)","tags":"","loc":"proc/htrid3.html","title":"htrid3 – Fortran Program"},{"text":"subroutine htridi(n, ar, ai, d, e, e2, tau) HTRIDI tridiagonalizes a complex hermitian matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: ar (n,n) real(kind=8) :: ai (n,n) real(kind=8) :: d (n) real(kind=8) :: e (n) real(kind=8) :: e2 (n) real(kind=8) :: tau (2,n) Called By proc~~htridi~~CalledByGraph proc~htridi htridi proc~ch ch proc~ch->proc~htridi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/htridi.html","title":"htridi – Fortran Program"},{"text":"subroutine imtql1(n, d, e, ierr) IMTQL1 computes all eigenvalues of a symmetric tridiagonal matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: d (n) real(kind=8) :: e (n) integer(kind=4) :: ierr Called By proc~~imtql1~~CalledByGraph proc~imtql1 imtql1 proc~rst rst proc~rst->proc~imtql1 proc~rt rt proc~rt->proc~imtql1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/imtql1.html","title":"imtql1 – Fortran Program"},{"text":"subroutine imtql2(n, d, e, z, ierr) IMTQL2 computes all eigenvalues/vectors of a symmetric tridiagonal matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: d (n) real(kind=8) :: e (n) real(kind=8) :: z (n,n) integer(kind=4) :: ierr Called By proc~~imtql2~~CalledByGraph proc~imtql2 imtql2 proc~rst rst proc~rst->proc~imtql2 proc~rt rt proc~rt->proc~imtql2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/imtql2.html","title":"imtql2 – Fortran Program"},{"text":"subroutine imtqlv(n, d, e, e2, w, ind, ierr) IMTQLV computes all eigenvalues of a real symmetric tridiagonal matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: d (n) real(kind=8) :: e (n) real(kind=8) :: e2 (n) real(kind=8) :: w (n) integer(kind=4) :: ind (n) integer(kind=4) :: ierr Called By proc~~imtqlv~~CalledByGraph proc~imtqlv imtqlv proc~rsm rsm proc~rsm->proc~imtqlv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/imtqlv.html","title":"imtqlv – Fortran Program"},{"text":"subroutine invit(n, a, wr, wi, select, mm, m, z, ierr) INVIT computes eigenvectors given eigenvalues, for a real upper Hessenberg matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: a (n,n) real(kind=8) :: wr (n) real(kind=8) :: wi (n) logical :: select (n) integer(kind=4) :: mm integer(kind=4) :: m real(kind=8) :: z (n,mm) integer(kind=4) :: ierr Calls proc~~invit~~CallsGraph proc~invit invit proc~r8_swap r8_swap proc~invit->proc~r8_swap proc~cdiv cdiv proc~invit->proc~cdiv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/invit.html","title":"invit – Fortran Program"},{"text":"subroutine minfit(nm, m, n, a, w, ip, b, ierr) MINFIT solves the least squares problem, for a real overdetermined linear system. Arguments Type Intent Optional Attributes Name integer(kind=4) :: nm integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (nm,n) real(kind=8) :: w (n) integer(kind=4) :: ip real(kind=8) :: b (nm,ip) integer(kind=4) :: ierr","tags":"","loc":"proc/minfit.html","title":"minfit – Fortran Program"},{"text":"subroutine ortbak(n, low, igh, a, ort, m, z) ORTBAK determines eigenvectors by undoing the ORTHES transformation. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n integer(kind=4) :: low integer(kind=4) :: igh real(kind=8) :: a (n,igh) real(kind=8) :: ort (igh) integer(kind=4) :: m real(kind=8) :: z (n,m)","tags":"","loc":"proc/ortbak.html","title":"ortbak – Fortran Program"},{"text":"subroutine orthes(n, low, igh, a, ort) ORTHES transforms a real general matrix to upper Hessenberg form. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n integer(kind=4) :: low integer(kind=4) :: igh real(kind=8) :: a (n,n) real(kind=8) :: ort (igh)","tags":"","loc":"proc/orthes.html","title":"orthes – Fortran Program"},{"text":"subroutine ortran(n, low, igh, a, ort, z) ORTRAN accumulates similarity transformations generated by ORTHES. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n integer(kind=4) :: low integer(kind=4) :: igh real(kind=8) :: a (n,igh) real(kind=8) :: ort (igh) real(kind=8) :: z (n,n)","tags":"","loc":"proc/ortran.html","title":"ortran – Fortran Program"},{"text":"subroutine qzhes(n, a, b, matz, z) QZHES carries out transformations for a generalized eigenvalue problem. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: a (n,n) real(kind=8) :: b (n,n) logical :: matz real(kind=8) :: z (n,n) Called By proc~~qzhes~~CalledByGraph proc~qzhes qzhes proc~rgg rgg proc~rgg->proc~qzhes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/qzhes.html","title":"qzhes – Fortran Program"},{"text":"subroutine qzit(n, a, b, eps1, matz, z, ierr) QZIT carries out iterations to solve a generalized eigenvalue problem. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: a (n,n) real(kind=8) :: b (n,n) real(kind=8) :: eps1 logical :: matz real(kind=8) :: z (n,n) integer(kind=4) :: ierr Called By proc~~qzit~~CalledByGraph proc~qzit qzit proc~rgg rgg proc~rgg->proc~qzit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/qzit.html","title":"qzit – Fortran Program"},{"text":"subroutine qzval(n, a, b, alfr, alfi, beta, matz, z) QZVAL computes eigenvalues for a generalized eigenvalue problem. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: a (n,n) real(kind=8) :: b (n,n) real(kind=8) :: alfr (n) real(kind=8) :: alfi (n) real(kind=8) :: beta (n) logical :: matz real(kind=8) :: z (n,n) Called By proc~~qzval~~CalledByGraph proc~qzval qzval proc~rgg rgg proc~rgg->proc~qzval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/qzval.html","title":"qzval – Fortran Program"},{"text":"subroutine qzvec(n, a, b, alfr, alfi, beta, z) QZVEC computes eigenvectors for a generalized eigenvalue problem. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: a (n,n) real(kind=8) :: b (n,n) real(kind=8) :: alfr (n) real(kind=8) :: alfi (n) real(kind=8) :: beta (n) real(kind=8) :: z (n,n) Calls proc~~qzvec~~CallsGraph proc~qzvec qzvec to to proc~qzvec->to Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~qzvec~~CalledByGraph proc~qzvec qzvec proc~rgg rgg proc~rgg->proc~qzvec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/qzvec.html","title":"qzvec – Fortran Program"},{"text":"subroutine r8_swap(x, y) R8_SWAP swaps two R8's. Arguments Type Intent Optional Attributes Name real(kind=8) :: x real(kind=8) :: y Called By proc~~r8_swap~~CalledByGraph proc~r8_swap r8_swap proc~balanc balanc proc~balanc->proc~r8_swap proc~cbabk2 cbabk2 proc~cbabk2->proc~r8_swap proc~elmbak elmbak proc~elmbak->proc~r8_swap proc~cbal cbal proc~cbal->proc~r8_swap proc~cinvit cinvit proc~cinvit->proc~r8_swap proc~comhes comhes proc~comhes->proc~r8_swap proc~invit invit proc~invit->proc~r8_swap proc~combak combak proc~combak->proc~r8_swap proc~tql2 tql2 proc~tql2->proc~r8_swap proc~comlr2 comlr2 proc~comlr2->proc~r8_swap proc~elmhes elmhes proc~elmhes->proc~r8_swap proc~balbak balbak proc~balbak->proc~r8_swap proc~comlr comlr proc~comlr->proc~r8_swap proc~bandv bandv proc~bandv->proc~r8_swap proc~rg rg proc~rg->proc~balanc proc~rg->proc~elmhes proc~rg->proc~balbak proc~cg cg proc~cg->proc~cbabk2 proc~cg->proc~cbal proc~rs rs proc~rs->proc~tql2 proc~ch ch proc~ch->proc~tql2 proc~rsp rsp proc~rsp->proc~tql2 proc~rsg rsg proc~rsg->proc~tql2 proc~rsb rsb proc~rsb->proc~tql2 proc~rsgba rsgba proc~rsgba->proc~tql2 proc~rsgab rsgab proc~rsgab->proc~tql2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/r8_swap.html","title":"r8_swap – Fortran Program"},{"text":"subroutine r8mat_print(m, n, a, title) R8MAT_PRINT prints an R8MAT. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (m,n) character(len=*) :: title Calls proc~~r8mat_print~~CallsGraph proc~r8mat_print r8mat_print proc~r8mat_print_some r8mat_print_some proc~r8mat_print->proc~r8mat_print_some Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/r8mat_print.html","title":"r8mat_print – Fortran Program"},{"text":"subroutine r8mat_print_some(m, n, a, ilo, jlo, ihi, jhi, title) R8MAT_PRINT_SOME prints some of an R8MAT. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (m,n) integer(kind=4) :: ilo integer(kind=4) :: jlo integer(kind=4) :: ihi integer(kind=4) :: jhi character(len=*) :: title Called By proc~~r8mat_print_some~~CalledByGraph proc~r8mat_print_some r8mat_print_some proc~r8mat_print r8mat_print proc~r8mat_print->proc~r8mat_print_some Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/r8mat_print_some.html","title":"r8mat_print_some – Fortran Program"},{"text":"subroutine r8vec_print(n, a, title) R8VEC_PRINT prints an R8VEC. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: a (n) character(len=*) :: title","tags":"","loc":"proc/r8vec_print.html","title":"r8vec_print – Fortran Program"},{"text":"subroutine r8vec2_print(n, a1, a2, title) R8VEC2_PRINT prints an R8VEC2. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: a1 (n) real(kind=8) :: a2 (n) character(len=*) :: title","tags":"","loc":"proc/r8vec2_print.html","title":"r8vec2_print – Fortran Program"},{"text":"subroutine ratqr(n, eps1, d, e, e2, m, w, ind, bd, type, idef, ierr) RATQR computes selected eigenvalues of a real symmetric tridiagonal matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: eps1 real(kind=8) :: d (n) real(kind=8) :: e (n) real(kind=8) :: e2 (n) integer(kind=4) :: m real(kind=8) :: w (n) integer(kind=4) :: ind (n) real(kind=8) :: bd (n) logical :: type integer(kind=4) :: idef integer(kind=4) :: ierr Called By proc~~ratqr~~CalledByGraph proc~ratqr ratqr proc~rspp rspp proc~rspp->proc~ratqr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/ratqr.html","title":"ratqr – Fortran Program"},{"text":"subroutine rebak(n, b, dl, m, z) REBAK determines eigenvectors by undoing the REDUC transformation. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: b (n,n) real(kind=8) :: dl (n) integer(kind=4) :: m real(kind=8) :: z (n,m) Called By proc~~rebak~~CalledByGraph proc~rebak rebak proc~rsg rsg proc~rsg->proc~rebak proc~rsgab rsgab proc~rsgab->proc~rebak Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/rebak.html","title":"rebak – Fortran Program"},{"text":"subroutine rebakb(n, b, dl, m, z) REBAKB determines eigenvectors by undoing the REDUC2 transformation. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: b (n,n) real(kind=8) :: dl (n) integer(kind=4) :: m real(kind=8) :: z (n,m) Called By proc~~rebakb~~CalledByGraph proc~rebakb rebakb proc~rsgba rsgba proc~rsgba->proc~rebakb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/rebakb.html","title":"rebakb – Fortran Program"},{"text":"subroutine reduc(n, a, b, dl, ierr) REDUC reduces the eigenvalue problem A x=lambda B x to A x=lambda*x. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: a (n,n) real(kind=8) :: b (n,n) real(kind=8) :: dl (n) integer(kind=4) :: ierr Called By proc~~reduc~~CalledByGraph proc~reduc reduc proc~rsg rsg proc~rsg->proc~reduc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/reduc.html","title":"reduc – Fortran Program"},{"text":"subroutine reduc2(n, a, b, dl, ierr) REDUC2 reduces the eigenvalue problem A B x=lamdba x to A x=lambda*x. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: a (n,n) real(kind=8) :: b (n,n) real(kind=8) :: dl (n) integer(kind=4) :: ierr Called By proc~~reduc2~~CalledByGraph proc~reduc2 reduc2 proc~rsgab rsgab proc~rsgab->proc~reduc2 proc~rsgba rsgba proc~rsgba->proc~reduc2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/reduc2.html","title":"reduc2 – Fortran Program"},{"text":"subroutine rg(n, a, wr, wi, matz, z, ierr) RG computes eigenvalues and eigenvectors of a real general matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: a (n,n) real(kind=8) :: wr (n) real(kind=8) :: wi (n) integer(kind=4) :: matz real(kind=8) :: z (n,n) integer(kind=4) :: ierr Calls proc~~rg~~CallsGraph proc~rg rg proc~balanc balanc proc~rg->proc~balanc proc~eltran eltran proc~rg->proc~eltran proc~hqr2 hqr2 proc~rg->proc~hqr2 proc~hqr hqr proc~rg->proc~hqr proc~elmhes elmhes proc~rg->proc~elmhes proc~balbak balbak proc~rg->proc~balbak proc~r8_swap r8_swap proc~balanc->proc~r8_swap proc~cdiv cdiv proc~hqr2->proc~cdiv proc~elmhes->proc~r8_swap proc~balbak->proc~r8_swap Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/rg.html","title":"rg – Fortran Program"},{"text":"subroutine rgg(n, a, b, alfr, alfi, beta, matz, z, ierr) RGG computes eigenvalues/vectors for the generalized problem A x = lambda B*x. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: a (n,n) real(kind=8) :: b (n,n) real(kind=8) :: alfr (n) real(kind=8) :: alfi (n) real(kind=8) :: beta (n) integer(kind=4) :: matz real(kind=8) :: z (n,n) integer(kind=4) :: ierr Calls proc~~rgg~~CallsGraph proc~rgg rgg proc~qzhes qzhes proc~rgg->proc~qzhes proc~qzvec qzvec proc~rgg->proc~qzvec proc~qzit qzit proc~rgg->proc~qzit proc~qzval qzval proc~rgg->proc~qzval to to proc~qzvec->to Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/rgg.html","title":"rgg – Fortran Program"},{"text":"subroutine rs(n, a, w, matz, z, ierr) RS computes eigenvalues and eigenvectors of real symmetric matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: a (n,n) real(kind=8) :: w (n) integer(kind=4) :: matz real(kind=8) :: z (n,n) integer(kind=4) :: ierr Calls proc~~rs~~CallsGraph proc~rs rs proc~tqlrat tqlrat proc~rs->proc~tqlrat proc~tql2 tql2 proc~rs->proc~tql2 proc~tred1 tred1 proc~rs->proc~tred1 proc~tred2 tred2 proc~rs->proc~tred2 proc~r8_swap r8_swap proc~tql2->proc~r8_swap Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/rs.html","title":"rs – Fortran Program"},{"text":"subroutine rsb(n, mb, a, w, matz, z, ierr) RSB computes eigenvalues and eigenvectors of a real symmetric band matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n integer(kind=4) :: mb real(kind=8) :: a (n,mb) real(kind=8) :: w (n) integer(kind=4) :: matz real(kind=8) :: z (n,n) integer(kind=4) :: ierr Calls proc~~rsb~~CallsGraph proc~rsb rsb proc~bandr bandr proc~rsb->proc~bandr proc~tql2 tql2 proc~rsb->proc~tql2 proc~tqlrat tqlrat proc~rsb->proc~tqlrat proc~r8_swap r8_swap proc~tql2->proc~r8_swap Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/rsb.html","title":"rsb – Fortran Program"},{"text":"subroutine rsg(n, a, b, w, matz, z, ierr) RSG computes eigenvalues/vectors, A x=lambda B*x, A symmetric, B pos-def. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: a (n,n) real(kind=8) :: b (n,n) real(kind=8) :: w (n) integer(kind=4) :: matz real(kind=8) :: z (n,n) integer(kind=4) :: ierr Calls proc~~rsg~~CallsGraph proc~rsg rsg proc~tqlrat tqlrat proc~rsg->proc~tqlrat proc~tred2 tred2 proc~rsg->proc~tred2 proc~tred1 tred1 proc~rsg->proc~tred1 proc~tql2 tql2 proc~rsg->proc~tql2 proc~reduc reduc proc~rsg->proc~reduc proc~rebak rebak proc~rsg->proc~rebak proc~r8_swap r8_swap proc~tql2->proc~r8_swap Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/rsg.html","title":"rsg – Fortran Program"},{"text":"subroutine rsgab(n, a, b, w, matz, z, ierr) RSGAB computes eigenvalues/vectors, A B x=lambda*x, A symmetric, B pos-def. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: a (n,n) real(kind=8) :: b (n,n) real(kind=8) :: w (n) integer(kind=4) :: matz real(kind=8) :: z (n,n) integer(kind=4) :: ierr Calls proc~~rsgab~~CallsGraph proc~rsgab rsgab proc~tred2 tred2 proc~rsgab->proc~tred2 proc~tqlrat tqlrat proc~rsgab->proc~tqlrat proc~reduc2 reduc2 proc~rsgab->proc~reduc2 proc~tred1 tred1 proc~rsgab->proc~tred1 proc~tql2 tql2 proc~rsgab->proc~tql2 proc~rebak rebak proc~rsgab->proc~rebak proc~r8_swap r8_swap proc~tql2->proc~r8_swap Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/rsgab.html","title":"rsgab – Fortran Program"},{"text":"subroutine rsgba(n, a, b, w, matz, z, ierr) RSGBA computes eigenvalues/vectors, B A x=lambda*x, A symmetric, B pos-def. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: a (n,n) real(kind=8) :: b (n,n) real(kind=8) :: w (n) integer(kind=4) :: matz real(kind=8) :: z (n,n) integer(kind=4) :: ierr Calls proc~~rsgba~~CallsGraph proc~rsgba rsgba proc~tred2 tred2 proc~rsgba->proc~tred2 proc~tqlrat tqlrat proc~rsgba->proc~tqlrat proc~reduc2 reduc2 proc~rsgba->proc~reduc2 proc~tred1 tred1 proc~rsgba->proc~tred1 proc~tql2 tql2 proc~rsgba->proc~tql2 proc~rebakb rebakb proc~rsgba->proc~rebakb proc~r8_swap r8_swap proc~tql2->proc~r8_swap Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/rsgba.html","title":"rsgba – Fortran Program"},{"text":"subroutine rsm(n, a, w, m, z, ierr) RSM computes eigenvalues, some eigenvectors, real symmetric matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: a (n,n) real(kind=8) :: w (n) integer(kind=4) :: m real(kind=8) :: z (n,m) integer(kind=4) :: ierr Calls proc~~rsm~~CallsGraph proc~rsm rsm proc~trbak1 trbak1 proc~rsm->proc~trbak1 proc~tqlrat tqlrat proc~rsm->proc~tqlrat proc~tinvit tinvit proc~rsm->proc~tinvit proc~tred1 tred1 proc~rsm->proc~tred1 proc~imtqlv imtqlv proc~rsm->proc~imtqlv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/rsm.html","title":"rsm – Fortran Program"},{"text":"subroutine rsp(n, nv, a, w, matz, z, ierr) RSP computes eigenvalues and eigenvectors of real symmetric packed matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n integer(kind=4) :: nv real(kind=8) :: a (nv) real(kind=8) :: w (n) integer(kind=4) :: matz real(kind=8) :: z (n,n) integer(kind=4) :: ierr Calls proc~~rsp~~CallsGraph proc~rsp rsp proc~tqlrat tqlrat proc~rsp->proc~tqlrat proc~tred3 tred3 proc~rsp->proc~tred3 proc~trbak3 trbak3 proc~rsp->proc~trbak3 proc~tql2 tql2 proc~rsp->proc~tql2 proc~r8_swap r8_swap proc~tql2->proc~r8_swap Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/rsp.html","title":"rsp – Fortran Program"},{"text":"subroutine rspp(n, nv, a, w, matz, z, ierr, m, type) RSPP computes some eigenvalues/vectors, real symmetric packed matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n integer(kind=4) :: nv real(kind=8) :: a (nv) real(kind=8) :: w (m) integer(kind=4) :: matz real(kind=8) :: z (n,m) integer(kind=4) :: ierr integer(kind=4) :: m logical :: type Calls proc~~rspp~~CallsGraph proc~rspp rspp proc~ratqr ratqr proc~rspp->proc~ratqr proc~tred3 tred3 proc~rspp->proc~tred3 proc~trbak3 trbak3 proc~rspp->proc~trbak3 proc~tinvit tinvit proc~rspp->proc~tinvit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/rspp.html","title":"rspp – Fortran Program"},{"text":"subroutine rst(n, w, e, matz, z, ierr) RST computes eigenvalues/vectors, real symmetric tridiagonal matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: w (n) real(kind=8) :: e (n) integer(kind=4) :: matz real(kind=8) :: z (n,n) integer(kind=4) :: ierr Calls proc~~rst~~CallsGraph proc~rst rst proc~imtql2 imtql2 proc~rst->proc~imtql2 proc~imtql1 imtql1 proc~rst->proc~imtql1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/rst.html","title":"rst – Fortran Program"},{"text":"subroutine rt(n, a, w, matz, z, ierr) RT computes eigenvalues/vectors, real sign-symmetric tridiagonal matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: a (n,3) real(kind=8) :: w (n) integer(kind=4) :: matz real(kind=8) :: z (n,n) integer(kind=4) :: ierr Calls proc~~rt~~CallsGraph proc~rt rt proc~figi2 figi2 proc~rt->proc~figi2 proc~imtql2 imtql2 proc~rt->proc~imtql2 proc~figi figi proc~rt->proc~figi proc~imtql1 imtql1 proc~rt->proc~imtql1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/rt.html","title":"rt – Fortran Program"},{"text":"subroutine svd(m, n, a, w, matu, u, matv, v, ierr) SVD computes the singular value decomposition for a real matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (m,n) real(kind=8) :: w (n) logical :: matu real(kind=8) :: u (m,n) logical :: matv real(kind=8) :: v (n,n) integer(kind=4) :: ierr","tags":"","loc":"proc/svd.html","title":"svd – Fortran Program"},{"text":"subroutine timestamp() TIMESTAMP prints the current YMDHMS date as a time stamp. Arguments None","tags":"","loc":"proc/timestamp.html","title":"timestamp – Fortran Program"},{"text":"subroutine tinvit(n, d, e, e2, m, w, ind, z, ierr) TINVIT computes eigenvectors from eigenvalues, real tridiagonal symmetric. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: d (n) real(kind=8) :: e (n) real(kind=8) :: e2 (n) integer(kind=4) :: m real(kind=8) :: w (m) integer(kind=4) :: ind (m) real(kind=8) :: z (n,m) integer(kind=4) :: ierr Called By proc~~tinvit~~CalledByGraph proc~tinvit tinvit proc~rsm rsm proc~rsm->proc~tinvit proc~rspp rspp proc~rspp->proc~tinvit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/tinvit.html","title":"tinvit – Fortran Program"},{"text":"subroutine tql1(n, d, e, ierr) TQL1 computes all eigenvalues of a real symmetric tridiagonal matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: d (n) real(kind=8) :: e (n) integer(kind=4) :: ierr","tags":"","loc":"proc/tql1.html","title":"tql1 – Fortran Program"},{"text":"subroutine tql2(n, d, e, z, ierr) TQL2 computes all eigenvalues/vectors, real symmetric tridiagonal matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: d (n) real(kind=8) :: e (n) real(kind=8) :: z (n,n) integer(kind=4) :: ierr Calls proc~~tql2~~CallsGraph proc~tql2 tql2 proc~r8_swap r8_swap proc~tql2->proc~r8_swap Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~tql2~~CalledByGraph proc~tql2 tql2 proc~rs rs proc~rs->proc~tql2 proc~ch ch proc~ch->proc~tql2 proc~rsp rsp proc~rsp->proc~tql2 proc~rsg rsg proc~rsg->proc~tql2 proc~rsb rsb proc~rsb->proc~tql2 proc~rsgba rsgba proc~rsgba->proc~tql2 proc~rsgab rsgab proc~rsgab->proc~tql2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/tql2.html","title":"tql2 – Fortran Program"},{"text":"subroutine tqlrat(n, d, e2, ierr) TQLRAT computes all eigenvalues of a real symmetric tridiagonal matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: d (n) real(kind=8) :: e2 (n) integer(kind=4) :: ierr Called By proc~~tqlrat~~CalledByGraph proc~tqlrat tqlrat proc~rs rs proc~rs->proc~tqlrat proc~ch ch proc~ch->proc~tqlrat proc~rsp rsp proc~rsp->proc~tqlrat proc~rsg rsg proc~rsg->proc~tqlrat proc~rsb rsb proc~rsb->proc~tqlrat proc~rsgba rsgba proc~rsgba->proc~tqlrat proc~rsm rsm proc~rsm->proc~tqlrat proc~rsgab rsgab proc~rsgab->proc~tqlrat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/tqlrat.html","title":"tqlrat – Fortran Program"},{"text":"subroutine trbak1(n, a, e, m, z) TRBAK1 determines eigenvectors by undoing the TRED1 transformation. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: a (n,n) real(kind=8) :: e (n) integer(kind=4) :: m real(kind=8) :: z (n,m) Called By proc~~trbak1~~CalledByGraph proc~trbak1 trbak1 proc~rsm rsm proc~rsm->proc~trbak1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/trbak1.html","title":"trbak1 – Fortran Program"},{"text":"subroutine trbak3(n, nv, a, m, z) TRBAK3 determines eigenvectors by undoing the TRED3 transformation. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n integer(kind=4) :: nv real(kind=8) :: a (nv) integer(kind=4) :: m real(kind=8) :: z (n,m) Called By proc~~trbak3~~CalledByGraph proc~trbak3 trbak3 proc~rsp rsp proc~rsp->proc~trbak3 proc~rspp rspp proc~rspp->proc~trbak3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/trbak3.html","title":"trbak3 – Fortran Program"},{"text":"subroutine tred1(n, a, d, e, e2) TRED1 transforms a real symmetric matrix to symmetric tridiagonal form. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: a (n,n) real(kind=8) :: d (n) real(kind=8) :: e (n) real(kind=8) :: e2 (n) Called By proc~~tred1~~CalledByGraph proc~tred1 tred1 proc~rsm rsm proc~rsm->proc~tred1 proc~rs rs proc~rs->proc~tred1 proc~rsgab rsgab proc~rsgab->proc~tred1 proc~rsgba rsgba proc~rsgba->proc~tred1 proc~rsg rsg proc~rsg->proc~tred1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/tred1.html","title":"tred1 – Fortran Program"},{"text":"subroutine tred2(n, a, d, e, z) TRED2 transforms a real symmetric matrix to symmetric tridiagonal form. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: a (n,n) real(kind=8) :: d (n) real(kind=8) :: e (n) real(kind=8) :: z (n,n) Called By proc~~tred2~~CalledByGraph proc~tred2 tred2 proc~rs rs proc~rs->proc~tred2 proc~rsgab rsgab proc~rsgab->proc~tred2 proc~rsgba rsgba proc~rsgba->proc~tred2 proc~rsg rsg proc~rsg->proc~tred2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/tred2.html","title":"tred2 – Fortran Program"},{"text":"subroutine tred3(n, nv, a, d, e, e2) TRED3 transforms a real symmetric packed matrix to symmetric tridiagonal form. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n integer(kind=4) :: nv real(kind=8) :: a (nv) real(kind=8) :: d (n) real(kind=8) :: e (n) real(kind=8) :: e2 (n) Called By proc~~tred3~~CalledByGraph proc~tred3 tred3 proc~rsp rsp proc~rsp->proc~tred3 proc~rspp rspp proc~rspp->proc~tred3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/tred3.html","title":"tred3 – Fortran Program"},{"text":"subroutine tridib(n, eps1, d, e, e2, lb, ub, m11, m, w, ind, ierr) TRIDIB computes some eigenvalues of a real symmetric tridiagonal matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: eps1 real(kind=8) :: d (n) real(kind=8) :: e (n) real(kind=8) :: e2 (n) real(kind=8) :: lb real(kind=8) :: ub integer(kind=4) :: m11 integer(kind=4) :: m real(kind=8) :: w (m) integer(kind=4) :: ind (m) integer(kind=4) :: ierr Calls proc~~tridib~~CallsGraph proc~tridib tridib to to proc~tridib->to Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/tridib.html","title":"tridib – Fortran Program"},{"text":"subroutine tsturm(n, eps1, d, e, e2, lb, ub, mm, m, w, z, ierr) TSTURM computes some eigenvalues/vectors, real symmetric tridiagonal matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: eps1 real(kind=8) :: d (n) real(kind=8) :: e (n) real(kind=8) :: e2 (n) real(kind=8) :: lb real(kind=8) :: ub integer(kind=4) :: mm integer(kind=4) :: m real(kind=8) :: w (mm) real(kind=8) :: z (n,mm) integer(kind=4) :: ierr Calls proc~~tsturm~~CallsGraph proc~tsturm tsturm to to proc~tsturm->to Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/tsturm.html","title":"tsturm – Fortran Program"},{"text":"subroutine timestamp(stdout, timestring, datestring) Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in), optional :: stdout character(len=15), intent(out), optional :: timestring character(len=11), intent(out), optional :: datestring Called By proc~~timestamp~2~~CalledByGraph proc~timestamp~2 timestamp program~hdftest hdftest program~hdftest->proc~timestamp~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code timestamp Source Code subroutine timestamp ( stdout , timestring , datestring ) IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ), OPTIONAL :: stdout character ( len = 11 ), INTENT ( OUT ), OPTIONAL :: datestring character ( len = 15 ), INTENT ( OUT ), OPTIONAL :: timestring integer ( kind = 4 ) :: std character ( len = 8 ) :: ampm integer ( kind = 4 ) :: d character ( len = 8 ) :: date integer ( kind = 4 ) :: h integer ( kind = 4 ) :: mo integer ( kind = 4 ) :: mm character ( len = 3 ), parameter , dimension ( 12 ) :: month = ( / & 'Jan' , 'Feb' , 'Mar' , 'Apr' , 'May' , 'Jun' , 'Jul' , 'Aug' , 'Sep' , 'Oct' , 'Nov' , 'Dec' / ) integer ( kind = 4 ) :: n integer ( kind = 4 ) :: s character ( len = 10 ) :: time integer ( kind = 4 ) :: values ( 8 ) integer ( kind = 4 ) :: y character ( len = 5 ) :: zone std = 6 if ( PRESENT ( stdout )) std = stdout call date_and_time ( date , time , zone , values ) y = values ( 1 ) mo = values ( 2 ) d = values ( 3 ) h = values ( 5 ) n = values ( 6 ) s = values ( 7 ) mm = values ( 8 ) if ( h < 12 ) then ampm = 'AM' else if ( h == 12 ) then if ( n == 0 . and . s == 0 ) then ampm = 'Noon' else ampm = 'PM' end if else h = h - 12 if ( h < 12 ) then ampm = 'PM' else if ( h == 12 ) then if ( n == 0 . and . s == 0 ) then ampm = 'Midnight' else ampm = 'AM' end if end if end if if ((. not . PRESENT ( datestring )). and .(. not . PRESENT ( timestring ))) then write ( std , '(a,1x,i2,1x,i4,2x,i2,a1,i2.2,a1,i2.2,a1,i3.3,1x,a)' ) & month ( mo ), d , y , h , ':' , n , ':' , s , '.' , mm , trim ( ampm ) else if ( PRESENT ( datestring )) write ( datestring , '(a,1x,i2,1x,i4)' ) month ( mo ), d , y if ( PRESENT ( timestring )) then write ( timestring , '(i2,a1,i2.2,a1,i2.2,a1,i3.3,1x,a)' ) h , ':' , n , ':' , s , '.' , mm , trim ( ampm ) end if end if end subroutine timestamp","tags":"","loc":"proc/timestamp~2.html","title":"timestamp – Fortran Program"},{"text":"public recursive subroutine read_apb_data(defects, cell, DF_L, DF_npix, DF_npiy, dinfo) Uses: io files crystal proc~~read_apb_data~~UsesGraph proc~read_apb_data read_apb_data io io io->proc~read_apb_data files files files->proc~read_apb_data crystal crystal crystal->proc~read_apb_data Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief  read apb parameters from file\n @param defects defect structure\n @param cell unit cell pointer\n @param foil foil structure\n @param DF_L column edge length \n @param DF_npix number of x-pixels\n @param DF_npiy number of y-pixels\n @param dinfo logical to trigger verbose output\n @date   02/10/14 MDG 1.0 new code\n @date   06/10/14 MDG 2.0 removed all global variables; added defect, foil arguments Arguments Type Intent Optional Attributes Name type(defecttype), intent(inout) :: defects type(unitcell), pointer :: cell real(kind=sgl), intent(in) :: DF_L integer(kind=irg), intent(in) :: DF_npix integer(kind=irg), intent(in) :: DF_npiy integer(kind=irg), intent(in) :: dinfo Calls proc~~read_apb_data~~CallsGraph proc~read_apb_data read_apb_data float float proc~read_apb_data->float transspace transspace proc~read_apb_data->transspace emsoft_tonativepath emsoft_tonativepath proc~read_apb_data->emsoft_tonativepath writevalue writevalue proc~read_apb_data->writevalue quat_lp quat_lp proc~read_apb_data->quat_lp message message proc~read_apb_data->message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code read_apb_data Source Code recursive subroutine read_apb_data ( defects , cell , DF_L , DF_npix , DF_npiy , dinfo ) !DEC$ ATTRIBUTES DLLEXPORT :: read_apb_data use io use files use crystal IMPLICIT NONE type ( defecttype ), INTENT ( INOUT ) :: defects type ( unitcell ), pointer :: cell integer ( kind = irg ), INTENT ( IN ) :: dinfo , DF_npix , DF_npiy real ( kind = sgl ), INTENT ( IN ) :: DF_L integer ( kind = irg ) :: i , io_int ( 1 ) real ( kind = sgl ) :: Vx , Vy , Vz , Vrad , w , tmp ( 3 ), tmp2 ( 3 ), Rx , Ry , Rz ! open the apbdata file call Message ( 'Opening ' // trim ( defects % apbname ), frm = \"(A)\" ) open ( unit = dataunit , file = trim ( EMsoft_toNativePath ( defects % apbname )), form = 'formatted' ) read ( dataunit , * ) defects % numapb ! PGC unit=dataunit -> dataunit allocate ( defects % apbs ( defects % numapb )) if ( dinfo . eq . 1 ) then io_int ( 1 ) = defects % numapb call WriteValue ( ' Number of APBs ' , io_int , 1 , \"(I)\" ) end if ! read each subsequent line do i = 1 , defects % numapb read ( dataunit , * ) Vx , Vy , Vz , Vrad , w , Rx , Ry , Rz ! PGC unit=dataunit -> dataunit defects % apbs ( i )% xpos = Vx * 0.5 * float ( DF_npix ) * DF_L defects % apbs ( i )% ypos = Vy * 0.5 * float ( DF_npiy ) * DF_L defects % apbs ( i )% zpos = Vz * foil % z0 ! vertical fractional location in interval [-1,1] defects % apbs ( i )% radius = Vrad ! radius in nanometers defects % apbs ( i )% w = w tmp = ( / Rx , Ry , Rz / ) call TransSpace ( cell , tmp , tmp2 , 'd' , 'c' ) defects % apbs ( i )% Rdisp = tmp2 tmp = quat_Lp ( conjg ( foil % a_fc ), dble (( / defects % apbs ( i )% xpos , defects % apbs ( i )% ypos , defects % apbs ( i )% zpos / )) ) defects % apbs ( i )% xpos = tmp ( 1 ) defects % apbs ( i )% ypos = tmp ( 2 ) defects % apbs ( i )% zpos = tmp ( 3 ) end do ! close datafile close ( unit = dataunit , status = 'keep' ) end subroutine read_apb_data","tags":"","loc":"proc/read_apb_data.html","title":"read_apb_data – Fortran Program"},{"text":"public recursive subroutine bobyqa(nipar, nfpar, ninit, ipar, fpar, initmeanval, expt1, n, npt, x, xl, xu, rhobeg, rhoend, iprint, maxfun, calfun, accum_e, mLPNH, mLPSH, nstep, stepsize, verbose) Uses: iso_c_binding proc~~bobyqa~~UsesGraph proc~bobyqa bobyqa iso_c_binding iso_c_binding iso_c_binding->proc~bobyqa Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar integer(kind=irg), intent(in) :: ninit integer(kind=8), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fpar (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) real(kind=c_float), intent(in) :: expt1 (ipar(2)*ipar(3)/ipar(12)**2) integer, intent(in) :: n number of variables (must be at least two) integer, intent(in) :: npt number of interpolation conditions. Its value must be in\n the interval [N+2,(N+1)(N+2)/2]. Choices that exceed 2*N+1 are not\n recommended. real(kind=dbl), intent(inout), dimension(:) :: x Initial values of the variables must be set in X(1),X(2),...,X(N). They\n will be changed to the values that give the least calculated F. real(kind=dbl), intent(in), dimension(:) :: xl lower bounds on x. The construction of quadratic models\n requires XL(I) to be strictly less than XU(I) for each I. Further,\n the contribution to a model from changes to the I-th variable is\n damaged severely by rounding errors if XU(I)-XL(I) is too small. real(kind=dbl), intent(in), dimension(:) :: xu upper bounds on x. The construction of quadratic models\n requires XL(I) to be strictly less than XU(I) for each I. Further,\n the contribution to a model from changes to the I-th variable is\n damaged severely by rounding errors if XU(I)-XL(I) is too small. real(kind=dbl), intent(in) :: rhobeg RHOBEG must be set to the initial value of a trust region radius. It must be positive, and typically should be about one tenth of the greatest\n expected change to a variable.  An error return occurs if any of \n the differences XU(I)-XL(I), I=1,...,N, is less than 2*RHOBEG. real(kind=dbl), intent(in) :: rhoend RHOEND must be set to the final value of a trust\n region radius. It must be positive with RHOEND no greater than\n RHOBEG. Typically, RHOEND should indicate the\n accuracy that is required in the final values of the variables. integer, intent(in) :: iprint IPRINT should be set to 0, 1, 2 or 3, which controls the\n amount of printing. Specifically, there is no output if IPRINT=0 and\n there is output only at the return if IPRINT=1. Otherwise, each new\n value of RHO is printed, with the best vector of variables so far and\n the corresponding value of the objective function. Further, each new\n value of F with its variables are output if IPRINT=3. integer, intent(in) :: maxfun an upper bound on the number of calls of CALFUN. procedure( func ) :: calfun SUBROUTINE CALFUN (N,X,F) has to be provided by the user. It must set\n F to the value of the objective function for the current values of the\n variables X(1),X(2),...,X(N), which are generated automatically in a\n way that satisfies the bounds given in XL and XU. real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) integer(kind=irg), intent(in) :: nstep real(kind=sgl), intent(in) :: stepsize (nstep) logical, intent(in), optional :: verbose Calls proc~~bobyqa~~CallsGraph proc~bobyqa bobyqa proc~bobyqb bobyqb proc~bobyqa->proc~bobyqb proc~prelim prelim proc~bobyqb->proc~prelim proc~altmov altmov proc~bobyqb->proc~altmov proc~update update proc~bobyqb->proc~update proc~trsbox trsbox proc~bobyqb->proc~trsbox proc~rescue rescue proc~bobyqb->proc~rescue proc~rescue->proc~update Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code bobyqa Source Code recursive subroutine bobyqa ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , n , npt , x , xl ,& xu , rhobeg , rhoend , iprint , maxfun , calfun , accum_e , mLPNH , mLPSH ,& nstep , stepsize , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: bobyqa use , INTRINSIC :: ISO_C_BINDING implicit none integer ( 8 ), intent ( in ) :: ipar ( nipar ) real ( sgl ), intent ( inout ) :: fpar ( nfpar ) real ( sgl ), intent ( in ) :: initmeanval ( ninit ) real ( sgl ), intent ( in ) :: stepsize ( nstep ) integer ( irg ), intent ( in ) :: ninit integer ( irg ), intent ( in ) :: nipar integer ( irg ), intent ( in ) :: nfpar integer ( irg ), intent ( in ) :: nstep real ( c_float ), intent ( in ) :: expt1 ( ipar ( 2 ) * ipar ( 3 ) / ipar ( 12 ) ** 2 ) real ( sgl ), intent ( in ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( sgl ), intent ( in ) :: mLPNH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) real ( sgl ), intent ( in ) :: mLPSH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) logical , intent ( in ), optional :: verbose integer , intent ( in ) :: n !! number of variables (must be at least two) integer , intent ( in ) :: npt !! number of interpolation conditions. Its value must be in !! the interval [N+2,(N+1)(N+2)/2]. Choices that exceed 2*N+1 are not !! recommended. real ( dbl ), dimension (:), intent ( inout ) :: x !! Initial values of the variables must be set in X(1),X(2),...,X(N). They !! will be changed to the values that give the least calculated F. real ( dbl ), dimension (:), intent ( in ) :: xl !! lower bounds on x. The construction of quadratic models !! requires XL(I) to be strictly less than XU(I) for each I. Further, !! the contribution to a model from changes to the I-th variable is !! damaged severely by rounding errors if XU(I)-XL(I) is too small. real ( dbl ), dimension (:), intent ( in ) :: xu !! upper bounds on x. The construction of quadratic models !! requires XL(I) to be strictly less than XU(I) for each I. Further, !! the contribution to a model from changes to the I-th variable is !! damaged severely by rounding errors if XU(I)-XL(I) is too small. real ( dbl ), intent ( in ) :: rhobeg !! RHOBEG must be set to the initial value of a trust region radius. !! It must be positive, and typically should be about one tenth of the greatest !! expected change to a variable.  An error return occurs if any of !! the differences XU(I)-XL(I), I=1,...,N, is less than 2*RHOBEG. real ( dbl ), intent ( in ) :: rhoend !! RHOEND must be set to the final value of a trust !! region radius. It must be positive with RHOEND no greater than !! RHOBEG. Typically, RHOEND should indicate the !! accuracy that is required in the final values of the variables. integer , intent ( in ) :: iprint !! IPRINT should be set to 0, 1, 2 or 3, which controls the !! amount of printing. Specifically, there is no output if IPRINT=0 and !! there is output only at the return if IPRINT=1. Otherwise, each new !! value of RHO is printed, with the best vector of variables so far and !! the corresponding value of the objective function. Further, each new !! value of F with its variables are output if IPRINT=3. integer , intent ( in ) :: maxfun !! an upper bound on the number of calls of CALFUN. procedure ( func ) :: calfun !! SUBROUTINE CALFUN (N,X,F) has to be provided by the user. It must set !! F to the value of the objective function for the current values of the !! variables X(1),X(2),...,X(N), which are generated automatically in a !! way that satisfies the bounds given in XL and XU. integer :: ibmat , id , ifv , igo , ihq , ipq , isl , isu , ivl , iw , ixa ,& ixb , ixn , ixo , ixp , izmat , j , jsl , jsu , ndim , np real ( dbl ), dimension (:), allocatable :: w real ( dbl ) :: temp real ( dbl ), parameter :: zero = 0.0_dbl ! The array W will be used for working space. allocate ( w (( NPT + 5 ) * ( NPT + N ) + 3 * N * ( N + 5 ) / 2 ) ) ! !     Return if the value of NPT is unacceptable. ! np = n + 1 if ( npt < n + 2 . or . npt > (( n + 2 ) * np ) / 2 ) then write ( * , '(/4X,A)' ) & 'Return from BOBYQA because NPT is not in the required interval' return end if ! !     Partition the working space array, so that different parts of it can !     be treated separately during the calculation of BOBYQB. The partition !     requires the first (NPT+2)*(NPT+N)+3*N*(N+5)/2 elements of W plus the !     space that is taken by the last array in the argument list of BOBYQB. ! ndim = npt + n ixb = 1 ixp = ixb + n ifv = ixp + n * npt ixo = ifv + npt igo = ixo + n ihq = igo + n ipq = ihq + ( n * np ) / 2 ibmat = ipq + npt izmat = ibmat + ndim * n isl = izmat + npt * ( npt - np ) isu = isl + n ixn = isu + n ixa = ixn + n id = ixa + n ivl = id + n iw = ivl + ndim ! !     Return if there is insufficient space between the bounds. Modify the !     initial X if necessary in order to avoid conflicts between the bounds !     and the construction of the first quadratic model. The lower and upper !     bounds on moves from the updated X are set now, in the ISL and ISU !     partitions of W, in order to provide useful and exact information about !     components of X that become within distance RHOBEG from their bounds. ! do j = 1 , n temp = xu ( j ) - xl ( j ) if ( temp < rhobeg + rhobeg ) then write ( * , '(/4X,A)' ) & 'Return from BOBYQA because one of the differences ' // & 'XU(I)-XL(I) is less than 2*RHOBEG.' return end if jsl = isl + j - 1 jsu = jsl + n w ( jsl ) = xl ( j ) - x ( j ) w ( jsu ) = xu ( j ) - x ( j ) if ( w ( jsl ) >=- rhobeg ) then if ( w ( jsl ) >= zero ) then x ( j ) = xl ( j ) w ( jsl ) = zero w ( jsu ) = temp else x ( j ) = xl ( j ) + rhobeg w ( jsl ) = - rhobeg w ( jsu ) = max ( xu ( j ) - x ( j ), rhobeg ) end if else if ( w ( jsu ) <= rhobeg ) then if ( w ( jsu ) <= zero ) then x ( j ) = xu ( j ) w ( jsl ) = - temp w ( jsu ) = zero else x ( j ) = xu ( j ) - rhobeg w ( jsl ) = min ( xl ( j ) - x ( j ), - rhobeg ) w ( jsu ) = rhobeg end if end if end do ! !     Make the call of BOBYQB. ! if ( present ( verbose )) then call bobyqb ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , n , npt , x , xl , xu , rhobeg , rhoend , iprint ,& maxfun , w ( ixb ), w ( ixp ), w ( ifv ), w ( ixo ), w ( igo ), w ( ihq ), w ( ipq ), w ( ibmat ), w ( izmat ), ndim , w ( isl ), & w ( isu ), w ( ixn ), w ( ixa ), w ( id ), w ( ivl ), w ( iw ), calfun , accum_e , mLPNH , mLPSH , nstep , & stepsize , verbose ) else call bobyqb ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , n , npt , x , xl , xu , rhobeg , rhoend , iprint ,& maxfun , w ( ixb ), w ( ixp ), w ( ifv ), w ( ixo ), w ( igo ), w ( ihq ), w ( ipq ), w ( ibmat ), w ( izmat ), ndim , w ( isl ), & w ( isu ), w ( ixn ), w ( ixa ), w ( id ), w ( ivl ), w ( iw ), calfun , accum_e , mLPNH , mLPSH , nstep , & stepsize ) end if deallocate ( w ) end subroutine bobyqa","tags":"","loc":"proc/bobyqa.html","title":"bobyqa – Fortran Program"},{"text":"public recursive subroutine bobyqb(nipar, nfpar, ninit, ipar, fpar, initmeanval, expt1, n, npt, x, xl, xu, rhobeg, rhoend, iprint, maxfun, xbase, xpt, fval, xopt, gopt, hq, pq, bmat, zmat, ndim, sl, su, xnew, xalt, d, vlag, w, calfun, accum_e, mLPNH, mLPSH, nstep, stepsize, verbose) Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar integer(kind=irg), intent(in) :: ninit integer(kind=8), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fpar (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) real(kind=c_float), intent(in) :: expt1 (ipar(2)*ipar(3)/ipar(12)**2) integer :: n integer :: npt real :: x real :: xl real :: xu real :: rhobeg real :: rhoend integer :: iprint integer :: maxfun real :: xbase real :: xpt real :: fval real :: xopt real :: gopt real :: hq real :: pq real :: bmat real :: zmat integer :: ndim real :: sl real :: su real :: xnew real :: xalt real :: d real :: vlag real :: w procedure( func ) :: calfun real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) integer(kind=irg), intent(in) :: nstep real(kind=sgl), intent(in) :: stepsize (nstep) logical, intent(in), optional :: verbose Calls proc~~bobyqb~~CallsGraph proc~bobyqb bobyqb proc~prelim prelim proc~bobyqb->proc~prelim proc~altmov altmov proc~bobyqb->proc~altmov proc~update update proc~bobyqb->proc~update proc~trsbox trsbox proc~bobyqb->proc~trsbox proc~rescue rescue proc~bobyqb->proc~rescue proc~rescue->proc~update Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~bobyqb~~CalledByGraph proc~bobyqb bobyqb proc~bobyqa bobyqa proc~bobyqa->proc~bobyqb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code bobyqb Source Code recursive subroutine bobyqb ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , n , npt , x , xl , xu ,& rhobeg , rhoend , iprint ,& maxfun , xbase , xpt , fval , xopt , gopt , hq , pq , bmat , zmat , ndim , sl , su , xnew , xalt , & d , vlag , w , calfun , accum_e , mLPNH , mLPSH , nstep , stepsize , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: bobyqb implicit real ( dbl ) ( a - h , o - z ) integer ( 8 ), intent ( in ) :: ipar ( nipar ) real ( sgl ), intent ( inout ) :: fpar ( nfpar ) real ( sgl ), intent ( in ) :: initmeanval ( ninit ) integer ( irg ), intent ( in ) :: ninit integer ( irg ), intent ( in ) :: nipar integer ( irg ), intent ( in ) :: nfpar integer ( irg ), intent ( in ) :: nstep real ( sgl ), intent ( in ) :: stepsize ( nstep ) real ( c_float ), intent ( in ) :: expt1 ( ipar ( 2 ) * ipar ( 3 ) / ipar ( 12 ) ** 2 ) real ( sgl ), intent ( in ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( sgl ), intent ( in ) :: mLPNH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) real ( sgl ), intent ( in ) :: mLPSH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) logical , intent ( in ), optional :: verbose dimension x ( * ), xl ( * ), xu ( * ), xbase ( * ), xpt ( npt , * ), fval ( * ), xopt ( * ), & gopt ( * ), hq ( * ), pq ( * ), bmat ( ndim , * ), zmat ( npt , * ), sl ( * ), su ( * ), & xnew ( * ), xalt ( * ), d ( * ), vlag ( * ), w ( * ) procedure ( func ) :: calfun ! !     The arguments N, NPT, X, XL, XU, RHOBEG, RHOEND, IPRINT and MAXFUN !       are identical to the corresponding arguments in SUBROUTINE BOBYQA. !     XBASE holds a shift of origin that should reduce the contributions !       from rounding errors to values of the model and Lagrange functions. !     XPT is a two-dimensional array that holds the coordinates of the !       interpolation points relative to XBASE. !     FVAL holds the values of F at the interpolation points. !     XOPT is set to the displacement from XBASE of the trust region centre. !     GOPT holds the gradient of the quadratic model at XBASE+XOPT. !     HQ holds the explicit second derivatives of the quadratic model. !     PQ contains the parameters of the implicit second derivatives of the !       quadratic model. !     BMAT holds the last N columns of H. !     ZMAT holds the factorization of the leading NPT by NPT submatrix of H, !       this factorization being ZMAT times ZMAT&#94;T, which provides both the !       correct rank and positive semi-definiteness. !     NDIM is the first dimension of BMAT and has the value NPT+N. !     SL and SU hold the differences XL-XBASE and XU-XBASE, respectively. !       All the components of every XOPT are going to satisfy the bounds !       SL(I) .LEQ. XOPT(I) .LEQ. SU(I), with appropriate equalities when !       XOPT is on a constraint boundary. !     XNEW is chosen by SUBROUTINE TRSBOX or ALTMOV. Usually XBASE+XNEW is the !       vector of variables for the next call of CALFUN. XNEW also satisfies !       the SL and SU constraints in the way that has just been mentioned. !     XALT is an alternative to XNEW, chosen by ALTMOV, that may replace XNEW !       in order to increase the denominator in the updating of UPDATE. !     D is reserved for a trial step from XOPT, which is usually XNEW-XOPT. !     VLAG contains the values of the Lagrange functions at a new point X. !       They are part of a product that requires VLAG to be of length NDIM. !     W is a one-dimensional array that is used for working space. Its length !       must be at least 3*NDIM = 3*(NPT+N). ! !     Set some constants. ! half = 0.5_dbl one = 1.0_dbl ten = 1 0.0_dbl tenth = 0.1_dbl two = 2.0_dbl zero = 0.0_dbl np = n + 1 nptm = npt - np nh = ( n * np ) / 2 ! !     The call of PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ, !     BMAT and ZMAT for the first iteration, with the corresponding values of !     of NF and KOPT, which are the number of calls of CALFUN so far and the !     index of the interpolation point at the trust region centre. Then the !     initial XOPT is set too. The branch to label 720 occurs if MAXFUN is !     less than NPT. GOPT will be updated if KOPT is different from KBASE. ! if ( present ( verbose )) then call prelim ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , n , npt , x , xl , xu , rhobeg ,& iprint , maxfun , xbase , xpt , fval , gopt , hq , pq , bmat , zmat , ndim , sl , su , nf , kopt , calfun , accum_e , & mLPNH , mLPSH , nstep , stepsize , verbose ) else call prelim ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , n , npt , x , xl , xu , rhobeg ,& iprint , maxfun , xbase , xpt , fval , gopt , hq , pq , bmat , zmat , ndim , sl , su , nf , kopt , calfun , accum_e , & mLPNH , mLPSH , nstep , stepsize ) end if xoptsq = zero do i = 1 , n xopt ( i ) = xpt ( kopt , i ) xoptsq = xoptsq + xopt ( i ) ** 2 end do fsave = fval ( 1 ) if ( nf < npt ) then if ( iprint > 0 ) write ( * , '(/4X,A)' ) & 'Return from BOBYQA because CALFUN has been called MAXFUN times.' go to 720 end if kbase = 1 ! !     Complete the settings that are required for the iterative procedure. ! rho = rhobeg delta = rho nresc = nf ntrits = 0 diffa = zero diffb = zero itest = 0 nfsav = nf ! !     Update GOPT if necessary before the first iteration and after each !     call of RESCUE that makes a call of CALFUN. ! 20 if ( kopt /= kbase ) then ih = 0 do j = 1 , n do i = 1 , j ih = ih + 1 if ( i < j ) gopt ( j ) = gopt ( j ) + hq ( ih ) * xopt ( i ) gopt ( i ) = gopt ( i ) + hq ( ih ) * xopt ( j ) end do end do if ( nf > npt ) then do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * xopt ( j ) end do temp = pq ( k ) * temp do i = 1 , n gopt ( i ) = gopt ( i ) + temp * xpt ( k , i ) end do end do end if end if ! !     Generate the next point in the trust region that provides a small value !     of the quadratic model subject to the constraints on the variables. !     The integer NTRITS is set to the number \"trust region\" iterations that !     have occurred since the last \"alternative\" iteration. If the length !     of XNEW-XOPT is less than HALF*RHO, however, then there is a branch to !     label 650 or 680 with NTRITS=-1, instead of calculating F at XNEW. ! 60 call trsbox ( n , npt , xpt , xopt , gopt , hq , pq , sl , su , delta , xnew , d , w , w ( np ), & & w ( np + n ), w ( np + 2 * n ), w ( np + 3 * n ), dsq , crvmin ) dnorm = min ( delta , sqrt ( dsq )) if ( dnorm < half * rho ) then ntrits = - 1 distsq = ( ten * rho ) ** 2 if ( nf <= nfsav + 2 ) go to 650 ! !     The following choice between labels 650 and 680 depends on whether or !     not our work with the current RHO seems to be complete. Either RHO is !     decreased or termination occurs if the errors in the quadratic model at !     the last three interpolation points compare favourably with predictions !     of likely improvements to the model within distance HALF*RHO of XOPT. ! errbig = max ( diffa , diffb , diffc ) frhosq = 0.125_dbl * rho * rho if ( crvmin > zero . and . errbig > frhosq * crvmin ) go to 650 bdtol = errbig / rho do j = 1 , n bdtest = bdtol if ( xnew ( j ) == sl ( j )) bdtest = w ( j ) if ( xnew ( j ) == su ( j )) bdtest = - w ( j ) if ( bdtest < bdtol ) then curv = hq (( j + j * j ) / 2 ) do k = 1 , npt curv = curv + pq ( k ) * xpt ( k , j ) ** 2 end do bdtest = bdtest + half * curv * rho if ( bdtest < bdtol ) go to 650 end if end do go to 680 end if ntrits = ntrits + 1 ! !     Severe cancellation is likely to occur if XOPT is too far from XBASE. !     If the following test holds, then XBASE is shifted so that XOPT becomes !     zero. The appropriate changes are made to BMAT and to the second !     derivatives of the current model, beginning with the changes to BMAT !     that do not depend on ZMAT. VLAG is used temporarily for working space. ! 90 if ( dsq <= 1.0e-3_dbl * xoptsq ) then fracsq = 0.25_dbl * xoptsq sumpq = zero do k = 1 , npt sumpq = sumpq + pq ( k ) sum = - half * xoptsq do i = 1 , n sum = sum + xpt ( k , i ) * xopt ( i ) end do w ( npt + k ) = sum temp = fracsq - half * sum do i = 1 , n w ( i ) = bmat ( k , i ) vlag ( i ) = sum * xpt ( k , i ) + temp * xopt ( i ) ip = npt + i do j = 1 , i bmat ( ip , j ) = bmat ( ip , j ) + w ( i ) * vlag ( j ) + vlag ( i ) * w ( j ) end do end do end do ! !     Then the revisions of BMAT that depend on ZMAT are calculated. ! do jj = 1 , nptm sumz = zero sumw = zero do k = 1 , npt sumz = sumz + zmat ( k , jj ) vlag ( k ) = w ( npt + k ) * zmat ( k , jj ) sumw = sumw + vlag ( k ) end do do j = 1 , n sum = ( fracsq * sumz - half * sumw ) * xopt ( j ) do k = 1 , npt sum = sum + vlag ( k ) * xpt ( k , j ) end do w ( j ) = sum do k = 1 , npt bmat ( k , j ) = bmat ( k , j ) + sum * zmat ( k , jj ) end do end do do i = 1 , n ip = i + npt temp = w ( i ) do j = 1 , i bmat ( ip , j ) = bmat ( ip , j ) + temp * w ( j ) end do end do end do ! !     The following instructions complete the shift, including the changes !     to the second derivative parameters of the quadratic model. ! ih = 0 do j = 1 , n w ( j ) = - half * sumpq * xopt ( j ) do k = 1 , npt w ( j ) = w ( j ) + pq ( k ) * xpt ( k , j ) xpt ( k , j ) = xpt ( k , j ) - xopt ( j ) end do do i = 1 , j ih = ih + 1 hq ( ih ) = hq ( ih ) + w ( i ) * xopt ( j ) + xopt ( i ) * w ( j ) bmat ( npt + i , j ) = bmat ( npt + j , i ) end do end do do i = 1 , n xbase ( i ) = xbase ( i ) + xopt ( i ) xnew ( i ) = xnew ( i ) - xopt ( i ) sl ( i ) = sl ( i ) - xopt ( i ) su ( i ) = su ( i ) - xopt ( i ) xopt ( i ) = zero end do xoptsq = zero end if if ( ntrits == 0 ) go to 210 go to 230 ! !     XBASE is also moved to XOPT by a call of RESCUE. This calculation is !     more expensive than the previous shift, because new matrices BMAT and !     ZMAT are generated from scratch, which may include the replacement of !     interpolation points whose positions seem to be causing near linear !     dependence in the interpolation conditions. Therefore RESCUE is called !     only if rounding errors have reduced by at least a factor of two the !     denominator of the formula for updating the H matrix. It provides a !     useful safeguard, but is not invoked in most applications of BOBYQA. ! 190 nfsav = nf kbase = kopt if ( present ( verbose )) then call rescue ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , n , npt , xl , xu , iprint , maxfun , xbase ,& xpt , fval , xopt , gopt , hq , pq , bmat , zmat , ndim , sl , su , nf , delta , kopt , vlag , w , w ( n + np ), w ( ndim + np ), & calfun , accum_e , mLPNH , mLPSH , nstep , stepsize , verbose ) else call rescue ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , n , npt , xl , xu , iprint , maxfun , xbase ,& xpt , fval , xopt , gopt , hq , pq , bmat , zmat , ndim , sl , su , nf , delta , kopt , vlag , w , w ( n + np ), w ( ndim + np ), & calfun , accum_e , mLPNH , mLPSH , nstep , stepsize ) end if ! !     XOPT is updated now in case the branch below to label 720 is taken. !     Any updating of GOPT occurs after the branch below to label 20, which !     leads to a trust region iteration as does the branch to label 60. ! xoptsq = zero if ( kopt /= kbase ) then do i = 1 , n xopt ( i ) = xpt ( kopt , i ) xoptsq = xoptsq + xopt ( i ) ** 2 end do end if if ( nf < 0 ) then nf = maxfun if ( iprint > 0 ) write ( * , '(/4X,A)' ) & 'Return from BOBYQA because CALFUN has been called MAXFUN times.' go to 720 end if nresc = nf if ( nfsav < nf ) then nfsav = nf go to 20 end if if ( ntrits > 0 ) go to 60 ! !     Pick two alternative vectors of variables, relative to XBASE, that !     are suitable as new positions of the KNEW-th interpolation point. !     Firstly, XNEW is set to the point on a line through XOPT and another !     interpolation point that minimizes the predicted value of the next !     denominator, subject to ||XNEW - XOPT|| .LEQ. ADELT and to the SL !     and SU bounds. Secondly, XALT is set to the best feasible point on !     a constrained version of the Cauchy step of the KNEW-th Lagrange !     function, the corresponding value of the square of this function !     being returned in CAUCHY. The choice between these alternatives is !     going to be made when the denominator is calculated. ! 210 call altmov ( n , npt , xpt , xopt , bmat , zmat , ndim , sl , su , kopt , knew , adelt , & & xnew , xalt , alpha , cauchy , w , w ( np ), w ( ndim + 1 )) do i = 1 , n d ( i ) = xnew ( i ) - xopt ( i ) end do ! !     Calculate VLAG and BETA for the current choice of D. The scalar !     product of D with XPT(K,.) is going to be held in W(NPT+K) for !     use when VQUAD is calculated. ! 230 do k = 1 , npt suma = zero sumb = zero sum = zero do j = 1 , n suma = suma + xpt ( k , j ) * d ( j ) sumb = sumb + xpt ( k , j ) * xopt ( j ) sum = sum + bmat ( k , j ) * d ( j ) end do w ( k ) = suma * ( half * suma + sumb ) vlag ( k ) = sum w ( npt + k ) = suma end do beta = zero do jj = 1 , nptm sum = zero do k = 1 , npt sum = sum + zmat ( k , jj ) * w ( k ) end do beta = beta - sum * sum do k = 1 , npt vlag ( k ) = vlag ( k ) + sum * zmat ( k , jj ) end do end do dsq = zero bsum = zero dx = zero do j = 1 , n dsq = dsq + d ( j ) ** 2 sum = zero do k = 1 , npt sum = sum + w ( k ) * bmat ( k , j ) end do bsum = bsum + sum * d ( j ) jp = npt + j do i = 1 , n sum = sum + bmat ( jp , i ) * d ( i ) end do vlag ( jp ) = sum bsum = bsum + sum * d ( j ) dx = dx + d ( j ) * xopt ( j ) end do beta = dx * dx + dsq * ( xoptsq + dx + dx + half * dsq ) + beta - bsum vlag ( kopt ) = vlag ( kopt ) + one ! !     If NTRITS is zero, the denominator may be increased by replacing !     the step D of ALTMOV by a Cauchy step. Then RESCUE may be called if !     rounding errors have damaged the chosen denominator. ! if ( ntrits == 0 ) then denom = vlag ( knew ) ** 2 + alpha * beta if ( denom < cauchy . and . cauchy > zero ) then do i = 1 , n xnew ( i ) = xalt ( i ) d ( i ) = xnew ( i ) - xopt ( i ) end do cauchy = zero go to 230 end if if ( denom <= half * vlag ( knew ) ** 2 ) then if ( nf > nresc ) go to 190 if ( iprint > 0 ) write ( * , '(/5X,A)' ) & 'Return from BOBYQA because of much cancellation in a denominator.' go to 720 end if ! !     Alternatively, if NTRITS is positive, then set KNEW to the index of !     the next interpolation point to be deleted to make room for a trust !     region step. Again RESCUE may be called if rounding errors have damaged !     the chosen denominator, which is the reason for attempting to select !     KNEW before calculating the next value of the objective function. ! else delsq = delta * delta scaden = zero biglsq = zero knew = 0 do k = 1 , npt if ( k == kopt ) cycle hdiag = zero do jj = 1 , nptm hdiag = hdiag + zmat ( k , jj ) ** 2 end do den = beta * hdiag + vlag ( k ) ** 2 distsq = zero do j = 1 , n distsq = distsq + ( xpt ( k , j ) - xopt ( j )) ** 2 end do temp = max ( one , ( distsq / delsq ) ** 2 ) if ( temp * den > scaden ) then scaden = temp * den knew = k denom = den end if biglsq = max ( biglsq , temp * vlag ( k ) ** 2 ) end do if ( scaden <= half * biglsq ) then if ( nf > nresc ) go to 190 if ( iprint > 0 ) write ( * , '(/5X,A)' ) & 'Return from BOBYQA because of much cancellation in a denominator.' go to 720 end if end if ! !     Put the variables for the next calculation of the objective function !       in XNEW, with any adjustments for the bounds. ! ! !     Calculate the value of the objective function at XBASE+XNEW, unless !       the limit on the number of calculations of F has been reached. ! 360 do i = 1 , n x ( i ) = min ( max ( xl ( i ), xbase ( i ) + xnew ( i )), xu ( i )) if ( xnew ( i ) == sl ( i )) x ( i ) = xl ( i ) if ( xnew ( i ) == su ( i )) x ( i ) = xu ( i ) end do if ( nf >= maxfun ) then if ( iprint > 0 ) write ( * , '(/4X,A)' ) & 'Return from BOBYQA because CALFUN has been called MAXFUN times.' go to 720 end if nf = nf + 1 !======================================================================================= !============changed function call depending on how many call have been made============ !======================================================================================= if ( present ( verbose )) then call calfun ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , accum_e , mLPNH , mLPSH , & n , x ( 1 : n ), f , nstep , stepsize , verbose = verbose ) else call calfun ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , accum_e , mLPNH , mLPSH , & n , x ( 1 : n ), f , nstep , stepsize ) end if if ( iprint == 3 ) then print 400 , nf , f , ( x ( i ), i = 1 , n ) 400 format ( / 4 x , 'Function number' , i6 , '    F =' , 1 pd18 . 10 ,& '   The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if if ( ntrits ==- 1 ) then fsave = f go to 720 end if ! !     Use the quadratic model to predict the change in F due to the step D, !       and set DIFF to the error of this prediction. ! fopt = fval ( kopt ) vquad = zero ih = 0 do j = 1 , n vquad = vquad + d ( j ) * gopt ( j ) do i = 1 , j ih = ih + 1 temp = d ( i ) * d ( j ) if ( i == j ) temp = half * temp vquad = vquad + hq ( ih ) * temp end do end do do k = 1 , npt vquad = vquad + half * pq ( k ) * w ( npt + k ) ** 2 end do diff = f - fopt - vquad diffc = diffb diffb = diffa diffa = abs ( diff ) if ( dnorm > rho ) nfsav = nf ! !     Pick the next value of DELTA after a trust region step. ! if ( ntrits > 0 ) then if ( vquad >= zero ) then if ( iprint > 0 ) print 430 430 format ( / 4 x , 'Return from BOBYQA because a trust' ,& ' region step has failed to reduce Q.' ) go to 720 end if ratio = ( f - fopt ) / vquad if ( ratio <= tenth ) then delta = min ( half * delta , dnorm ) else if ( ratio <= 0.7_dbl ) then delta = max ( half * delta , dnorm ) else delta = max ( half * delta , dnorm + dnorm ) end if if ( delta <= 1.5_dbl * rho ) delta = rho ! !     Recalculate KNEW and DENOM if the new F is less than FOPT. ! if ( f < fopt ) then ksav = knew densav = denom delsq = delta * delta scaden = zero biglsq = zero knew = 0 do k = 1 , npt hdiag = zero do jj = 1 , nptm hdiag = hdiag + zmat ( k , jj ) ** 2 end do den = beta * hdiag + vlag ( k ) ** 2 distsq = zero do j = 1 , n distsq = distsq + ( xpt ( k , j ) - xnew ( j )) ** 2 end do temp = max ( one , ( distsq / delsq ) ** 2 ) if ( temp * den > scaden ) then scaden = temp * den knew = k denom = den end if biglsq = max ( biglsq , temp * vlag ( k ) ** 2 ) end do if ( scaden <= half * biglsq ) then knew = ksav denom = densav end if end if end if ! !     Update BMAT and ZMAT, so that the KNEW-th interpolation point can be !     moved. Also update the second derivative terms of the model. ! call update ( n , npt , bmat , zmat , ndim , vlag , beta , denom , knew , w ) ih = 0 pqold = pq ( knew ) pq ( knew ) = zero do i = 1 , n temp = pqold * xpt ( knew , i ) do j = 1 , i ih = ih + 1 hq ( ih ) = hq ( ih ) + temp * xpt ( knew , j ) end do end do do jj = 1 , nptm temp = diff * zmat ( knew , jj ) do k = 1 , npt pq ( k ) = pq ( k ) + temp * zmat ( k , jj ) end do end do ! !     Include the new interpolation point, and make the changes to GOPT at !     the old XOPT that are caused by the updating of the quadratic model. ! fval ( knew ) = f do i = 1 , n xpt ( knew , i ) = xnew ( i ) w ( i ) = bmat ( knew , i ) end do do k = 1 , npt suma = zero do jj = 1 , nptm suma = suma + zmat ( knew , jj ) * zmat ( k , jj ) end do sumb = zero do j = 1 , n sumb = sumb + xpt ( k , j ) * xopt ( j ) end do temp = suma * sumb do i = 1 , n w ( i ) = w ( i ) + temp * xpt ( k , i ) end do end do do i = 1 , n gopt ( i ) = gopt ( i ) + diff * w ( i ) end do ! !     Update XOPT, GOPT and KOPT if the new calculated F is less than FOPT. ! if ( f < fopt ) then kopt = knew xoptsq = zero ih = 0 do j = 1 , n xopt ( j ) = xnew ( j ) xoptsq = xoptsq + xopt ( j ) ** 2 do i = 1 , j ih = ih + 1 if ( i < j ) gopt ( j ) = gopt ( j ) + hq ( ih ) * d ( i ) gopt ( i ) = gopt ( i ) + hq ( ih ) * d ( j ) end do end do do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * d ( j ) end do temp = pq ( k ) * temp do i = 1 , n gopt ( i ) = gopt ( i ) + temp * xpt ( k , i ) end do end do end if ! !     Calculate the parameters of the least Frobenius norm interpolant to !     the current data, the gradient of this interpolant at XOPT being put !     into VLAG(NPT+I), I=1,2,...,N. ! if ( ntrits > 0 ) then do k = 1 , npt vlag ( k ) = fval ( k ) - fval ( kopt ) w ( k ) = zero end do do j = 1 , nptm sum = zero do k = 1 , npt sum = sum + zmat ( k , j ) * vlag ( k ) end do do k = 1 , npt w ( k ) = w ( k ) + sum * zmat ( k , j ) end do end do do k = 1 , npt sum = zero do j = 1 , n sum = sum + xpt ( k , j ) * xopt ( j ) end do w ( k + npt ) = w ( k ) w ( k ) = sum * w ( k ) end do gqsq = zero gisq = zero do i = 1 , n sum = zero do k = 1 , npt sum = sum + bmat ( k , i ) * vlag ( k ) + xpt ( k , i ) * w ( k ) end do if ( xopt ( i ) == sl ( i )) then gqsq = gqsq + min ( zero , gopt ( i )) ** 2 gisq = gisq + min ( zero , sum ) ** 2 else if ( xopt ( i ) == su ( i )) then gqsq = gqsq + max ( zero , gopt ( i )) ** 2 gisq = gisq + max ( zero , sum ) ** 2 else gqsq = gqsq + gopt ( i ) ** 2 gisq = gisq + sum * sum end if vlag ( npt + i ) = sum end do ! !     Test whether to replace the new quadratic model by the least Frobenius !     norm interpolant, making the replacement if the test is satisfied. ! itest = itest + 1 if ( gqsq < ten * gisq ) itest = 0 if ( itest >= 3 ) then do i = 1 , max ( npt , nh ) if ( i <= n ) gopt ( i ) = vlag ( npt + i ) if ( i <= npt ) pq ( i ) = w ( npt + i ) if ( i <= nh ) hq ( i ) = zero itest = 0 end do end if end if ! !     If a trust region step has provided a sufficient decrease in F, then !     branch for another trust region calculation. The case NTRITS=0 occurs !     when the new interpolation point was reached by an alternative step. ! if ( ntrits == 0 ) go to 60 if ( f <= fopt + tenth * vquad ) go to 60 ! !     Alternatively, find out if the interpolation points are close enough !       to the best point so far. ! distsq = max (( two * delta ) ** 2 , ( ten * rho ) ** 2 ) 650 knew = 0 do k = 1 , npt sum = zero do j = 1 , n sum = sum + ( xpt ( k , j ) - xopt ( j )) ** 2 end do if ( sum > distsq ) then knew = k distsq = sum end if end do ! !     If KNEW is positive, then ALTMOV finds alternative new positions for !     the KNEW-th interpolation point within distance ADELT of XOPT. It is !     reached via label 90. Otherwise, there is a branch to label 60 for !     another trust region iteration, unless the calculations with the !     current RHO are complete. ! if ( knew > 0 ) then dist = sqrt ( distsq ) if ( ntrits ==- 1 ) then delta = min ( tenth * delta , half * dist ) if ( delta <= 1.5_dbl * rho ) delta = rho end if ntrits = 0 adelt = max ( min ( tenth * dist , delta ), rho ) dsq = adelt * adelt go to 90 end if if ( ntrits ==- 1 ) go to 680 if ( ratio > zero ) go to 60 if ( max ( delta , dnorm ) > rho ) go to 60 ! !     The calculations with the current value of RHO are complete. Pick the !       next values of RHO and DELTA. ! 680 if ( rho > rhoend ) then delta = half * rho ratio = rho / rhoend if ( ratio <= 1 6.0_dbl ) then rho = rhoend else if ( ratio <= 25 0.0_dbl ) then rho = sqrt ( ratio ) * rhoend else rho = tenth * rho end if delta = max ( delta , rho ) if ( iprint >= 2 ) then if ( iprint >= 3 ) print 690 690 format ( 5 x ) print 700 , rho , nf 700 format ( / 4 x , 'New RHO =' , 1 pd11 . 4 , 5 x , 'Number of' ,& ' function values =' , i6 ) print 710 , fval ( kopt ), ( xbase ( i ) + xopt ( i ), i = 1 , n ) 710 format ( 4 x , 'Least value of F =' , 1 pd23 . 15 , 9 x ,& 'The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if ntrits = 0 nfsav = nf go to 60 end if ! !     Return from the calculation, after another Newton-Raphson step, if !       it is too short to have been tried before. ! if ( ntrits ==- 1 ) go to 360 720 if ( fval ( kopt ) <= fsave ) then do i = 1 , n x ( i ) = min ( max ( xl ( i ), xbase ( i ) + xopt ( i )), xu ( i )) if ( xopt ( i ) == sl ( i )) x ( i ) = xl ( i ) if ( xopt ( i ) == su ( i )) x ( i ) = xu ( i ) end do f = fval ( kopt ) end if if ( iprint >= 1 ) then print 740 , nf 740 format ( / 4 x , 'At the return from BOBYQA' , 5 x ,& 'Number of function values =' , i6 ) print 710 , f , ( x ( i ), i = 1 , n ) end if return end subroutine bobyqb","tags":"","loc":"proc/bobyqb.html","title":"bobyqb – Fortran Program"},{"text":"public recursive subroutine altmov(n, npt, xpt, xopt, bmat, zmat, ndim, sl, su, kopt, knew, adelt, xnew, xalt, alpha, cauchy, glag, hcol, w) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: xpt real :: xopt real :: bmat real :: zmat integer :: ndim real :: sl real :: su integer :: kopt integer :: knew real :: adelt real :: xnew real :: xalt real :: alpha real :: cauchy real :: glag real :: hcol real :: w Called By proc~~altmov~~CalledByGraph proc~altmov altmov proc~bobyqb bobyqb proc~bobyqb->proc~altmov proc~bobyqa bobyqa proc~bobyqa->proc~bobyqb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code altmov Source Code recursive subroutine altmov ( n , npt , xpt , xopt , bmat , zmat , ndim , sl , su , kopt , knew , adelt , & & xnew , xalt , alpha , cauchy , glag , hcol , w ) !DEC$ ATTRIBUTES DLLEXPORT :: altmov implicit real ( dbl ) ( a - h , o - z ) dimension xpt ( npt , * ), xopt ( * ), bmat ( ndim , * ), zmat ( npt , * ), sl ( * ), su ( * ), & & xnew ( * ), xalt ( * ), glag ( * ), hcol ( * ), w ( * ) ! !     The arguments N, NPT, XPT, XOPT, BMAT, ZMAT, NDIM, SL and SU all have !       the same meanings as the corresponding arguments of BOBYQB. !     KOPT is the index of the optimal interpolation point. !     KNEW is the index of the interpolation point that is going to be moved. !     ADELT is the current trust region bound. !     XNEW will be set to a suitable new position for the interpolation point !       XPT(KNEW,.). Specifically, it satisfies the SL, SU and trust region !       bounds and it should provide a large denominator in the next call of !       UPDATE. The step XNEW-XOPT from XOPT is restricted to moves along the !       straight lines through XOPT and another interpolation point. !     XALT also provides a large value of the modulus of the KNEW-th Lagrange !       function subject to the constraints that have been mentioned, its main !       difference from XNEW being that XALT-XOPT is a constrained version of !       the Cauchy step within the trust region. An exception is that XALT is !       not calculated if all components of GLAG (see below) are zero. !     ALPHA will be set to the KNEW-th diagonal element of the H matrix. !     CAUCHY will be set to the square of the KNEW-th Lagrange function at !       the step XALT-XOPT from XOPT for the vector XALT that is returned, !       except that CAUCHY is set to zero if XALT is not calculated. !     GLAG is a working space vector of length N for the gradient of the !       KNEW-th Lagrange function at XOPT. !     HCOL is a working space vector of length NPT for the second derivative !       coefficients of the KNEW-th Lagrange function. !     W is a working space vector of length 2N that is going to hold the !       constrained Cauchy step from XOPT of the Lagrange function, followed !       by the downhill version of XALT when the uphill step is calculated. ! !     Set the first NPT components of W to the leading elements of the !     KNEW-th column of the H matrix. ! half = 0.5_dbl one = 1.0_dbl zero = 0.0_dbl const = one + sqrt ( 2.0_dbl ) do k = 1 , npt hcol ( k ) = zero end do do j = 1 , npt - n - 1 temp = zmat ( knew , j ) do k = 1 , npt hcol ( k ) = hcol ( k ) + temp * zmat ( k , j ) end do end do alpha = hcol ( knew ) ha = half * alpha ! !     Calculate the gradient of the KNEW-th Lagrange function at XOPT. ! do i = 1 , n glag ( i ) = bmat ( knew , i ) end do do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * xopt ( j ) end do temp = hcol ( k ) * temp do i = 1 , n glag ( i ) = glag ( i ) + temp * xpt ( k , i ) end do end do ! !     Search for a large denominator along the straight lines through XOPT !     and another interpolation point. SLBD and SUBD will be lower and upper !     bounds on the step along each of these lines in turn. PREDSQ will be !     set to the square of the predicted denominator for each line. PRESAV !     will be set to the largest admissible value of PREDSQ that occurs. ! presav = zero do k = 1 , npt if ( k == kopt ) cycle dderiv = zero distsq = zero do i = 1 , n temp = xpt ( k , i ) - xopt ( i ) dderiv = dderiv + glag ( i ) * temp distsq = distsq + temp * temp end do subd = adelt / sqrt ( distsq ) slbd = - subd ilbd = 0 iubd = 0 sumin = min ( one , subd ) ! !     Revise SLBD and SUBD if necessary because of the bounds in SL and SU. ! do i = 1 , n temp = xpt ( k , i ) - xopt ( i ) if ( temp > zero ) then if ( slbd * temp < sl ( i ) - xopt ( i )) then slbd = ( sl ( i ) - xopt ( i )) / temp ilbd = - i end if if ( subd * temp > su ( i ) - xopt ( i )) then subd = max ( sumin , ( su ( i ) - xopt ( i )) / temp ) iubd = i end if else if ( temp < zero ) then if ( slbd * temp > su ( i ) - xopt ( i )) then slbd = ( su ( i ) - xopt ( i )) / temp ilbd = i end if if ( subd * temp < sl ( i ) - xopt ( i )) then subd = max ( sumin , ( sl ( i ) - xopt ( i )) / temp ) iubd = - i end if end if end do ! !     Seek a large modulus of the KNEW-th Lagrange function when the index !     of the other interpolation point on the line through XOPT is KNEW. ! if ( k == knew ) then diff = dderiv - one step = slbd vlag = slbd * ( dderiv - slbd * diff ) isbd = ilbd temp = subd * ( dderiv - subd * diff ) if ( abs ( temp ) > abs ( vlag )) then step = subd vlag = temp isbd = iubd end if tempd = half * dderiv tempa = tempd - diff * slbd tempb = tempd - diff * subd if ( tempa * tempb < zero ) then temp = tempd * tempd / diff if ( abs ( temp ) > abs ( vlag )) then step = tempd / diff vlag = temp isbd = 0 end if end if ! !     Search along each of the other lines through XOPT and another point. ! else step = slbd vlag = slbd * ( one - slbd ) isbd = ilbd temp = subd * ( one - subd ) if ( abs ( temp ) > abs ( vlag )) then step = subd vlag = temp isbd = iubd end if if ( subd > half ) then if ( abs ( vlag ) < 0.25_dbl ) then step = half vlag = 0.25_dbl isbd = 0 end if end if vlag = vlag * dderiv end if ! !     Calculate PREDSQ for the current line search and maintain PRESAV. ! temp = step * ( one - step ) * distsq predsq = vlag * vlag * ( vlag * vlag + ha * temp * temp ) if ( predsq > presav ) then presav = predsq ksav = k stpsav = step ibdsav = isbd end if end do ! !     Construct XNEW in a way that satisfies the bound constraints exactly. ! do i = 1 , n temp = xopt ( i ) + stpsav * ( xpt ( ksav , i ) - xopt ( i )) xnew ( i ) = max ( sl ( i ), min ( su ( i ), temp )) end do if ( ibdsav < 0 ) xnew ( - ibdsav ) = sl ( - ibdsav ) if ( ibdsav > 0 ) xnew ( ibdsav ) = su ( ibdsav ) ! !     Prepare for the iterative method that assembles the constrained Cauchy !     step in W. The sum of squares of the fixed components of W is formed in !     WFIXSQ, and the free components of W are set to BIGSTP. ! bigstp = adelt + adelt iflag = 0 100 wfixsq = zero ggfree = zero do i = 1 , n w ( i ) = zero tempa = min ( xopt ( i ) - sl ( i ), glag ( i )) tempb = max ( xopt ( i ) - su ( i ), glag ( i )) if ( tempa > zero . or . tempb < zero ) then w ( i ) = bigstp ggfree = ggfree + glag ( i ) ** 2 end if end do if ( ggfree == zero ) then cauchy = zero return end if ! !     Investigate whether more components of W can be fixed. ! 120 temp = adelt * adelt - wfixsq if ( temp > zero ) then wsqsav = wfixsq step = sqrt ( temp / ggfree ) ggfree = zero do i = 1 , n if ( w ( i ) == bigstp ) then temp = xopt ( i ) - step * glag ( i ) if ( temp <= sl ( i )) then w ( i ) = sl ( i ) - xopt ( i ) wfixsq = wfixsq + w ( i ) ** 2 else if ( temp >= su ( i )) then w ( i ) = su ( i ) - xopt ( i ) wfixsq = wfixsq + w ( i ) ** 2 else ggfree = ggfree + glag ( i ) ** 2 end if end if end do if ( wfixsq > wsqsav . and . ggfree > zero ) go to 120 end if ! !     Set the remaining free components of W and all components of XALT, !     except that W may be scaled later. ! gw = zero do i = 1 , n if ( w ( i ) == bigstp ) then w ( i ) = - step * glag ( i ) xalt ( i ) = max ( sl ( i ), min ( su ( i ), xopt ( i ) + w ( i ))) else if ( w ( i ) == zero ) then xalt ( i ) = xopt ( i ) else if ( glag ( i ) > zero ) then xalt ( i ) = sl ( i ) else xalt ( i ) = su ( i ) end if gw = gw + glag ( i ) * w ( i ) end do ! !     Set CURV to the curvature of the KNEW-th Lagrange function along W. !     Scale W by a factor less than one if that can reduce the modulus of !     the Lagrange function at XOPT+W. Set CAUCHY to the final value of !     the square of this function. ! curv = zero do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * w ( j ) end do curv = curv + hcol ( k ) * temp * temp end do if ( iflag == 1 ) curv = - curv if ( curv >- gw . and . curv <- const * gw ) then scale = - gw / curv do i = 1 , n temp = xopt ( i ) + scale * w ( i ) xalt ( i ) = max ( sl ( i ), min ( su ( i ), temp )) end do cauchy = ( half * gw * scale ) ** 2 else cauchy = ( gw + half * curv ) ** 2 end if ! !     If IFLAG is zero, then XALT is calculated as before after reversing !     the sign of GLAG. Thus two XALT vectors become available. The one that !     is chosen is the one that gives the larger value of CAUCHY. ! if ( iflag == 0 ) then do i = 1 , n glag ( i ) = - glag ( i ) w ( n + i ) = xalt ( i ) end do csave = cauchy iflag = 1 go to 100 end if if ( csave > cauchy ) then do i = 1 , n xalt ( i ) = w ( n + i ) end do cauchy = csave end if end subroutine altmov","tags":"","loc":"proc/altmov.html","title":"altmov – Fortran Program"},{"text":"public recursive subroutine prelim(nipar, nfpar, ninit, ipar, fpar, initmeanval, expt1, n, npt, x, xl, xu, rhobeg, iprint, maxfun, xbase, xpt, fval, gopt, hq, pq, bmat, zmat, ndim, sl, su, nf, kopt, calfun, accum_e, mLPNH, mLPSH, nstep, stepsize, verbose) Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar integer(kind=irg), intent(in) :: ninit integer(kind=8), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fpar (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) real(kind=c_float), intent(in) :: expt1 (ipar(2)*ipar(3)/ipar(12)**2) integer :: n integer :: npt real :: x real :: xl real :: xu real :: rhobeg integer :: iprint integer :: maxfun real :: xbase real :: xpt real :: fval real :: gopt real :: hq real :: pq real :: bmat real :: zmat integer :: ndim real :: sl real :: su integer :: nf integer :: kopt procedure( func ) :: calfun real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) integer(kind=irg), intent(in) :: nstep real(kind=sgl), intent(in) :: stepsize (nstep) logical, intent(in), optional :: verbose Called By proc~~prelim~~CalledByGraph proc~prelim prelim proc~bobyqb bobyqb proc~bobyqb->proc~prelim proc~bobyqa bobyqa proc~bobyqa->proc~bobyqb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code prelim Source Code recursive subroutine prelim ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , n , npt , x , xl , xu , rhobeg ,& iprint , maxfun , xbase , xpt , fval , gopt , hq , pq , bmat , zmat , ndim , sl , su , nf , kopt , calfun , accum_e , mLPNH , mLPSH ,& nstep , stepsize , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: prelim implicit real ( dbl ) ( a - h , o - z ) integer ( 8 ), intent ( in ) :: ipar ( nipar ) real ( sgl ), intent ( inout ) :: fpar ( nfpar ) real ( sgl ), intent ( in ) :: initmeanval ( ninit ) integer ( irg ), intent ( in ) :: ninit integer ( irg ), intent ( in ) :: nipar integer ( irg ), intent ( in ) :: nfpar integer ( irg ), intent ( in ) :: nstep real ( sgl ), intent ( in ) :: stepsize ( nstep ) real ( c_float ), intent ( in ) :: expt1 ( ipar ( 2 ) * ipar ( 3 ) / ipar ( 12 ) ** 2 ) real ( sgl ), intent ( in ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( sgl ), intent ( in ) :: mLPNH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) real ( sgl ), intent ( in ) :: mLPSH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) logical , intent ( in ), optional :: verbose dimension x ( * ), xl ( * ), xu ( * ), xbase ( * ), xpt ( npt , * ), fval ( * ), gopt ( * ), hq & & ( * ), pq ( * ), bmat ( ndim , * ), zmat ( npt , * ), sl ( * ), su ( * ) procedure ( func ) :: calfun ! !     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the !       same as the corresponding arguments in SUBROUTINE BOBYQA. !     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU !       are the same as the corresponding arguments in BOBYQB, the elements !       of SL and SU being set in BOBYQA. !     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but !       it is set by PRELIM to the gradient of the quadratic model at XBASE. !       If XOPT is nonzero, BOBYQB will change it to its usual value later. !     NF is maintaned as the number of calls of CALFUN so far. !     KOPT will be such that the least calculated value of F so far is at !       the point XPT(KOPT,.)+XBASE in the space of the variables. ! !     SUBROUTINE PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ, !     BMAT and ZMAT for the first iteration, and it maintains the values of !     NF and KOPT. The vector X is also changed by PRELIM. ! !     Set some constants. ! half = 0.5_dbl one = 1.0_dbl two = 2.0_dbl zero = 0.0_dbl rhosq = rhobeg * rhobeg recip = one / rhosq np = n + 1 ! !     Set XBASE to the initial vector of variables, and set the initial !     elements of XPT, BMAT, HQ, PQ and ZMAT to zero. ! do j = 1 , n xbase ( j ) = x ( j ) do k = 1 , npt xpt ( k , j ) = zero end do do i = 1 , ndim bmat ( i , j ) = zero end do end do do ih = 1 , ( n * np ) / 2 hq ( ih ) = zero end do do k = 1 , npt pq ( k ) = zero do j = 1 , npt - np zmat ( k , j ) = zero end do end do ! !     Begin the initialization procedure. NF becomes one more than the number !     of function values so far. The coordinates of the displacement of the !     next initial interpolation point from XBASE are set in XPT(NF+1,.). ! nf = 0 50 nfm = nf nfx = nf - n nf = nf + 1 if ( nfm <= 2 * n ) then if ( nfm >= 1 . and . nfm <= n ) then stepa = rhobeg if ( su ( nfm ) == zero ) stepa = - stepa xpt ( nf , nfm ) = stepa else if ( nfm > n ) then stepa = xpt ( nf - n , nfx ) stepb = - rhobeg if ( sl ( nfx ) == zero ) stepb = min ( two * rhobeg , su ( nfx )) if ( su ( nfx ) == zero ) stepb = max ( - two * rhobeg , sl ( nfx )) xpt ( nf , nfx ) = stepb end if else itemp = ( nfm - np ) / n jpt = nfm - itemp * n - n ipt = jpt + itemp if ( ipt > n ) then itemp = jpt jpt = ipt - n ipt = itemp end if xpt ( nf , ipt ) = xpt ( ipt + 1 , ipt ) xpt ( nf , jpt ) = xpt ( jpt + 1 , jpt ) end if ! !     Calculate the next value of F. The least function value so far and !     its index are required. ! do j = 1 , n x ( j ) = min ( max ( xl ( j ), xbase ( j ) + xpt ( nf , j )), xu ( j )) if ( xpt ( nf , j ) == sl ( j )) x ( j ) = xl ( j ) if ( xpt ( nf , j ) == su ( j )) x ( j ) = xu ( j ) end do !======================================================================================= !============changed function call depending on how many call have been made============ !======================================================================================= if ( present ( verbose )) then call calfun ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , accum_e , mLPNH , mLPSH , & n , x ( 1 : n ), f , nstep , stepsize , verbose = verbose ) else call calfun ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , accum_e , mLPNH , mLPSH , & n , x ( 1 : n ), f , nstep , stepsize ) end if if ( iprint == 3 ) then print 70 , nf , f , ( x ( i ), i = 1 , n ) 70 format ( / 4 x , 'Function number' , i6 , '    F =' , 1 pd18 . 10 ,& '    The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if fval ( nf ) = f if ( nf == 1 ) then fbeg = f kopt = 1 else if ( f < fval ( kopt )) then kopt = nf end if ! !     Set the nonzero initial elements of BMAT and the quadratic model in the !     cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions !     of the NF-th and (NF-N)-th interpolation points may be switched, in !     order that the function value at the first of them contributes to the !     off-diagonal second derivative terms of the initial quadratic model. ! if ( nf <= 2 * n + 1 ) then if ( nf >= 2 . and . nf <= n + 1 ) then gopt ( nfm ) = ( f - fbeg ) / stepa if ( npt < nf + n ) then bmat ( 1 , nfm ) = - one / stepa bmat ( nf , nfm ) = one / stepa bmat ( npt + nfm , nfm ) = - half * rhosq end if else if ( nf >= n + 2 ) then ih = ( nfx * ( nfx + 1 )) / 2 temp = ( f - fbeg ) / stepb diff = stepb - stepa hq ( ih ) = two * ( temp - gopt ( nfx )) / diff gopt ( nfx ) = ( gopt ( nfx ) * stepb - temp * stepa ) / diff if ( stepa * stepb < zero ) then if ( f < fval ( nf - n )) then fval ( nf ) = fval ( nf - n ) fval ( nf - n ) = f if ( kopt == nf ) kopt = nf - n xpt ( nf - n , nfx ) = stepb xpt ( nf , nfx ) = stepa end if end if bmat ( 1 , nfx ) = - ( stepa + stepb ) / ( stepa * stepb ) bmat ( nf , nfx ) = - half / xpt ( nf - n , nfx ) bmat ( nf - n , nfx ) = - bmat ( 1 , nfx ) - bmat ( nf , nfx ) zmat ( 1 , nfx ) = sqrt ( two ) / ( stepa * stepb ) zmat ( nf , nfx ) = sqrt ( half ) / rhosq zmat ( nf - n , nfx ) = - zmat ( 1 , nfx ) - zmat ( nf , nfx ) end if ! !     Set the off-diagonal second derivatives of the Lagrange functions and !     the initial quadratic model. ! else ih = ( ipt * ( ipt - 1 )) / 2 + jpt zmat ( 1 , nfx ) = recip zmat ( nf , nfx ) = recip zmat ( ipt + 1 , nfx ) = - recip zmat ( jpt + 1 , nfx ) = - recip temp = xpt ( nf , ipt ) * xpt ( nf , jpt ) hq ( ih ) = ( fbeg - fval ( ipt + 1 ) - fval ( jpt + 1 ) + f ) / temp end if if ( nf < npt . and . nf < maxfun ) go to 50 end subroutine prelim","tags":"","loc":"proc/prelim.html","title":"prelim – Fortran Program"},{"text":"public recursive subroutine rescue(nipar, nfpar, ninit, ipar, fpar, initmeanval, expt1, n, npt, xl, xu, iprint, maxfun, xbase, xpt, fval, xopt, gopt, hq, pq, bmat, zmat, ndim, sl, su, nf, delta, kopt, vlag, ptsaux, ptsid, w, calfun, accum_e, mLPNH, mLPSH, nstep, stepsize, verbose) Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar integer(kind=irg), intent(in) :: ninit integer(kind=8), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fpar (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) real(kind=c_float), intent(in) :: expt1 (ipar(2)*ipar(3)/ipar(12)**2) integer :: n integer :: npt real :: xl real :: xu integer :: iprint integer :: maxfun real :: xbase real :: xpt real :: fval real :: xopt real :: gopt real :: hq real :: pq real :: bmat real :: zmat integer :: ndim real :: sl real :: su integer :: nf real :: delta integer :: kopt real :: vlag real :: ptsaux real :: ptsid real :: w procedure( func ) :: calfun real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) integer(kind=irg), intent(in) :: nstep real(kind=sgl), intent(in) :: stepsize (nstep) logical, intent(in), optional :: verbose Calls proc~~rescue~~CallsGraph proc~rescue rescue proc~update update proc~rescue->proc~update Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~rescue~~CalledByGraph proc~rescue rescue proc~bobyqb bobyqb proc~bobyqb->proc~rescue proc~bobyqa bobyqa proc~bobyqa->proc~bobyqb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code rescue Source Code recursive subroutine rescue ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , n , npt , xl , xu , iprint ,& maxfun , xbase , xpt , fval , xopt , gopt , hq , pq , bmat , zmat , ndim , sl , su , nf , delta , kopt , vlag ,& ptsaux , ptsid , w , calfun , accum_e , mLPNH , mLPSH , nstep , stepsize , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: rescue implicit real ( dbl ) ( a - h , o - z ) integer ( 8 ), intent ( in ) :: ipar ( nipar ) real ( sgl ), intent ( inout ) :: fpar ( nfpar ) real ( sgl ), intent ( in ) :: initmeanval ( ninit ) integer ( irg ), intent ( in ) :: ninit integer ( irg ), intent ( in ) :: nipar integer ( irg ), intent ( in ) :: nfpar integer ( irg ), intent ( in ) :: nstep real ( sgl ), intent ( in ) :: stepsize ( nstep ) real ( c_float ), intent ( in ) :: expt1 ( ipar ( 2 ) * ipar ( 3 ) / ipar ( 12 ) ** 2 ) real ( sgl ), intent ( in ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( sgl ), intent ( in ) :: mLPNH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) real ( sgl ), intent ( in ) :: mLPSH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) logical , intent ( in ), optional :: verbose dimension xl ( * ), xu ( * ), xbase ( * ), xpt ( npt , * ), fval ( * ), xopt ( * ), gopt ( * ), & & hq ( * ), pq ( * ), bmat ( ndim , * ), zmat ( npt , * ), sl ( * ), su ( * ), vlag ( * ), ptsaux & & ( 2 , * ), ptsid ( * ), w ( * ) procedure ( func ) :: calfun ! !     The arguments N, NPT, XL, XU, IPRINT, MAXFUN, XBASE, XPT, FVAL, XOPT, !       GOPT, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU have the same meanings as !       the corresponding arguments of BOBYQB on the entry to RESCUE. !     NF is maintained as the number of calls of CALFUN so far, except that !       NF is set to -1 if the value of MAXFUN prevents further progress. !     KOPT is maintained so that FVAL(KOPT) is the least calculated function !       value. Its correct value must be given on entry. It is updated if a !       new least function value is found, but the corresponding changes to !       XOPT and GOPT have to be made later by the calling program. !     DELTA is the current trust region radius. !     VLAG is a working space vector that will be used for the values of the !       provisional Lagrange functions at each of the interpolation points. !       They are part of a product that requires VLAG to be of length NDIM. !     PTSAUX is also a working space array. For J=1,2,...,N, PTSAUX(1,J) and !       PTSAUX(2,J) specify the two positions of provisional interpolation !       points when a nonzero step is taken along e_J (the J-th coordinate !       direction) through XBASE+XOPT, as specified below. Usually these !       steps have length DELTA, but other lengths are chosen if necessary !       in order to satisfy the given bounds on the variables. !     PTSID is also a working space array. It has NPT components that denote !       provisional new positions of the original interpolation points, in !       case changes are needed to restore the linear independence of the !       interpolation conditions. The K-th point is a candidate for change !       if and only if PTSID(K) is nonzero. In this case let p and q be the !       integer parts of PTSID(K) and (PTSID(K)-p) multiplied by N+1. If p !       and q are both positive, the step from XBASE+XOPT to the new K-th !       interpolation point is PTSAUX(1,p)*e_p + PTSAUX(1,q)*e_q. Otherwise !       the step is PTSAUX(1,p)*e_p or PTSAUX(2,q)*e_q in the cases q=0 or !       p=0, respectively. !     The first NDIM+NPT elements of the array W are used for working space. !     The final elements of BMAT and ZMAT are set in a well-conditioned way !       to the values that are appropriate for the new interpolation points. !     The elements of GOPT, HQ and PQ are also revised to the values that are !       appropriate to the final quadratic model. ! !     Set some constants. ! half = 0.5_dbl one = 1.0_dbl zero = 0.0_dbl np = n + 1 sfrac = half / real ( np , dbl ) nptm = npt - np ! !     Shift the interpolation points so that XOPT becomes the origin, and set !     the elements of ZMAT to zero. The value of SUMPQ is required in the !     updating of HQ below. The squares of the distances from XOPT to the !     other interpolation points are set at the end of W. Increments of WINC !     may be added later to these squares to balance the consideration of !     the choice of point that is going to become current. ! sumpq = zero winc = zero do k = 1 , npt distsq = zero do j = 1 , n xpt ( k , j ) = xpt ( k , j ) - xopt ( j ) distsq = distsq + xpt ( k , j ) ** 2 end do sumpq = sumpq + pq ( k ) w ( ndim + k ) = distsq winc = max ( winc , distsq ) do j = 1 , nptm zmat ( k , j ) = zero end do end do ! !     Update HQ so that HQ and PQ define the second derivatives of the model !     after XBASE has been shifted to the trust region centre. ! ih = 0 do j = 1 , n w ( j ) = half * sumpq * xopt ( j ) do k = 1 , npt w ( j ) = w ( j ) + pq ( k ) * xpt ( k , j ) end do do i = 1 , j ih = ih + 1 hq ( ih ) = hq ( ih ) + w ( i ) * xopt ( j ) + w ( j ) * xopt ( i ) end do end do ! !     Shift XBASE, SL, SU and XOPT. Set the elements of BMAT to zero, and !     also set the elements of PTSAUX. ! do j = 1 , n xbase ( j ) = xbase ( j ) + xopt ( j ) sl ( j ) = sl ( j ) - xopt ( j ) su ( j ) = su ( j ) - xopt ( j ) xopt ( j ) = zero ptsaux ( 1 , j ) = min ( delta , su ( j )) ptsaux ( 2 , j ) = max ( - delta , sl ( j )) if ( ptsaux ( 1 , j ) + ptsaux ( 2 , j ) < zero ) then temp = ptsaux ( 1 , j ) ptsaux ( 1 , j ) = ptsaux ( 2 , j ) ptsaux ( 2 , j ) = temp end if if ( abs ( ptsaux ( 2 , j )) < half * abs ( ptsaux ( 1 , j ))) then ptsaux ( 2 , j ) = half * ptsaux ( 1 , j ) end if do i = 1 , ndim bmat ( i , j ) = zero end do end do fbase = fval ( kopt ) ! !     Set the identifiers of the artificial interpolation points that are !     along a coordinate direction from XOPT, and set the corresponding !     nonzero elements of BMAT and ZMAT. ! ptsid ( 1 ) = sfrac do j = 1 , n jp = j + 1 jpn = jp + n ptsid ( jp ) = real ( j , dbl ) + sfrac if ( jpn <= npt ) then ptsid ( jpn ) = real ( j , dbl ) / real ( np , dbl ) + sfrac temp = one / ( ptsaux ( 1 , j ) - ptsaux ( 2 , j )) bmat ( jp , j ) = - temp + one / ptsaux ( 1 , j ) bmat ( jpn , j ) = temp + one / ptsaux ( 2 , j ) bmat ( 1 , j ) = - bmat ( jp , j ) - bmat ( jpn , j ) zmat ( 1 , j ) = sqrt ( 2.0_dbl ) / abs ( ptsaux ( 1 , j ) * ptsaux ( 2 , j )) zmat ( jp , j ) = zmat ( 1 , j ) * ptsaux ( 2 , j ) * temp zmat ( jpn , j ) = - zmat ( 1 , j ) * ptsaux ( 1 , j ) * temp else bmat ( 1 , j ) = - one / ptsaux ( 1 , j ) bmat ( jp , j ) = one / ptsaux ( 1 , j ) bmat ( j + npt , j ) = - half * ptsaux ( 1 , j ) ** 2 end if end do ! !     Set any remaining identifiers with their nonzero elements of ZMAT. ! if ( npt >= n + np ) then do k = 2 * np , npt iw = ( real ( k - np , dbl ) - half ) / real ( n , dbl ) ip = k - np - iw * n iq = ip + iw if ( iq > n ) iq = iq - n ptsid ( k ) = real ( ip , dbl ) + real ( iq , dbl ) / real ( np , dbl ) + sfrac temp = one / ( ptsaux ( 1 , ip ) * ptsaux ( 1 , iq )) zmat ( 1 , k - np ) = temp zmat ( ip + 1 , k - np ) = - temp zmat ( iq + 1 , k - np ) = - temp zmat ( k , k - np ) = temp end do end if nrem = npt kold = 1 knew = kopt ! !     Reorder the provisional points in the way that exchanges PTSID(KOLD) !     with PTSID(KNEW). ! 80 do j = 1 , n temp = bmat ( kold , j ) bmat ( kold , j ) = bmat ( knew , j ) bmat ( knew , j ) = temp end do do j = 1 , nptm temp = zmat ( kold , j ) zmat ( kold , j ) = zmat ( knew , j ) zmat ( knew , j ) = temp end do ptsid ( kold ) = ptsid ( knew ) ptsid ( knew ) = zero w ( ndim + knew ) = zero nrem = nrem - 1 if ( knew /= kopt ) then temp = vlag ( kold ) vlag ( kold ) = vlag ( knew ) vlag ( knew ) = temp ! !     Update the BMAT and ZMAT matrices so that the status of the KNEW-th !     interpolation point can be changed from provisional to original. The !     subroutine returns if all the original points are reinstated. !     The nonnegative values of W(NDIM+K) are required in the search below. ! call update ( n , npt , bmat , zmat , ndim , vlag , beta , denom , knew , w ) if ( nrem == 0 ) return do k = 1 , npt w ( ndim + k ) = abs ( w ( ndim + k )) end do end if ! !     Pick the index KNEW of an original interpolation point that has not !     yet replaced one of the provisional interpolation points, giving !     attention to the closeness to XOPT and to previous tries with KNEW. ! 120 dsqmin = zero do k = 1 , npt if ( w ( ndim + k ) > zero ) then if ( dsqmin == zero . or . w ( ndim + k ) < dsqmin ) then knew = k dsqmin = w ( ndim + k ) end if end if end do if ( dsqmin == zero ) go to 260 ! !     Form the W-vector of the chosen original interpolation point. ! do j = 1 , n w ( npt + j ) = xpt ( knew , j ) end do do k = 1 , npt sum = zero if ( k == kopt ) then continue else if ( ptsid ( k ) == zero ) then do j = 1 , n sum = sum + w ( npt + j ) * xpt ( k , j ) end do else ip = ptsid ( k ) if ( ip > 0 ) sum = w ( npt + ip ) * ptsaux ( 1 , ip ) iq = real ( np , dbl ) * ptsid ( k ) - real ( ip * np , dbl ) if ( iq > 0 ) then iw = 1 if ( ip == 0 ) iw = 2 sum = sum + w ( npt + iq ) * ptsaux ( iw , iq ) end if end if w ( k ) = half * sum * sum end do ! !     Calculate VLAG and BETA for the required updating of the H matrix if !     XPT(KNEW,.) is reinstated in the set of interpolation points. ! do k = 1 , npt sum = zero do j = 1 , n sum = sum + bmat ( k , j ) * w ( npt + j ) end do vlag ( k ) = sum end do beta = zero do j = 1 , nptm sum = zero do k = 1 , npt sum = sum + zmat ( k , j ) * w ( k ) end do beta = beta - sum * sum do k = 1 , npt vlag ( k ) = vlag ( k ) + sum * zmat ( k , j ) end do end do bsum = zero distsq = zero do j = 1 , n sum = zero do k = 1 , npt sum = sum + bmat ( k , j ) * w ( k ) end do jp = j + npt bsum = bsum + sum * w ( jp ) do ip = npt + 1 , ndim sum = sum + bmat ( ip , j ) * w ( ip ) end do bsum = bsum + sum * w ( jp ) vlag ( jp ) = sum distsq = distsq + xpt ( knew , j ) ** 2 end do beta = half * distsq * distsq + beta - bsum vlag ( kopt ) = vlag ( kopt ) + one ! !     KOLD is set to the index of the provisional interpolation point that is !     going to be deleted to make way for the KNEW-th original interpolation !     point. The choice of KOLD is governed by the avoidance of a small value !     of the denominator in the updating calculation of UPDATE. ! denom = zero vlmxsq = zero do k = 1 , npt if ( ptsid ( k ) /= zero ) then hdiag = zero do j = 1 , nptm hdiag = hdiag + zmat ( k , j ) ** 2 end do den = beta * hdiag + vlag ( k ) ** 2 if ( den > denom ) then kold = k denom = den end if end if vlmxsq = max ( vlmxsq , vlag ( k ) ** 2 ) end do if ( denom <= 1.0e-2_dbl * vlmxsq ) then w ( ndim + knew ) = - w ( ndim + knew ) - winc go to 120 end if go to 80 ! !     When label 260 is reached, all the final positions of the interpolation !     points have been chosen although any changes have not been included yet !     in XPT. Also the final BMAT and ZMAT matrices are complete, but, apart !     from the shift of XBASE, the updating of the quadratic model remains to !     be done. The following cycle through the new interpolation points begins !     by putting the new point in XPT(KPT,.) and by setting PQ(KPT) to zero, !     except that a RETURN occurs if MAXFUN prohibits another value of F. ! 260 do kpt = 1 , npt if ( ptsid ( kpt ) == zero ) cycle if ( nf >= maxfun ) then nf = - 1 return end if ih = 0 do j = 1 , n w ( j ) = xpt ( kpt , j ) xpt ( kpt , j ) = zero temp = pq ( kpt ) * w ( j ) do i = 1 , j ih = ih + 1 hq ( ih ) = hq ( ih ) + temp * w ( i ) end do end do pq ( kpt ) = zero ip = ptsid ( kpt ) iq = real ( np , dbl ) * ptsid ( kpt ) - real ( ip * np , dbl ) if ( ip > 0 ) then xp = ptsaux ( 1 , ip ) xpt ( kpt , ip ) = xp end if if ( iq > 0 ) then xq = ptsaux ( 1 , iq ) if ( ip == 0 ) xq = ptsaux ( 2 , iq ) xpt ( kpt , iq ) = xq end if ! !     Set VQUAD to the value of the current model at the new point. ! vquad = fbase if ( ip > 0 ) then ihp = ( ip + ip * ip ) / 2 vquad = vquad + xp * ( gopt ( ip ) + half * xp * hq ( ihp )) end if if ( iq > 0 ) then ihq = ( iq + iq * iq ) / 2 vquad = vquad + xq * ( gopt ( iq ) + half * xq * hq ( ihq )) if ( ip > 0 ) then iw = max ( ihp , ihq ) - abs ( ip - iq ) vquad = vquad + xp * xq * hq ( iw ) end if end if do k = 1 , npt temp = zero if ( ip > 0 ) temp = temp + xp * xpt ( k , ip ) if ( iq > 0 ) temp = temp + xq * xpt ( k , iq ) vquad = vquad + half * pq ( k ) * temp * temp end do ! !     Calculate F at the new interpolation point, and set DIFF to the factor !     that is going to multiply the KPT-th Lagrange function when the model !     is updated to provide interpolation to the new function value. ! do i = 1 , n w ( i ) = min ( max ( xl ( i ), xbase ( i ) + xpt ( kpt , i )), xu ( i )) if ( xpt ( kpt , i ) == sl ( i )) w ( i ) = xl ( i ) if ( xpt ( kpt , i ) == su ( i )) w ( i ) = xu ( i ) end do nf = nf + 1 !======================================================================================= !============changed function call depending on how many call have been made============ !======================================================================================= if ( present ( verbose )) then call calfun ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , accum_e , mLPNH , mLPSH , & n , w ( 1 : n ), f , nstep , stepsize , verbose = verbose ) else call calfun ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt1 , accum_e , mLPNH , mLPSH , & n , w ( 1 : n ), f , nstep , stepsize ) end if if ( iprint == 3 ) then print 300 , nf , f , ( w ( i ), i = 1 , n ) 300 format ( / 4 x , 'Function number' , i6 , '    F =' , 1 pd18 . 10 ,& '    The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if fval ( kpt ) = f if ( f < fval ( kopt )) kopt = kpt diff = f - vquad ! !     Update the quadratic model. The RETURN from the subroutine occurs when !     all the new interpolation points are included in the model. ! do i = 1 , n gopt ( i ) = gopt ( i ) + diff * bmat ( kpt , i ) end do do k = 1 , npt sum = zero do j = 1 , nptm sum = sum + zmat ( k , j ) * zmat ( kpt , j ) end do temp = diff * sum if ( ptsid ( k ) == zero ) then pq ( k ) = pq ( k ) + temp else ip = ptsid ( k ) iq = real ( np , dbl ) * ptsid ( k ) - real ( ip * np , dbl ) ihq = ( iq * iq + iq ) / 2 if ( ip == 0 ) then hq ( ihq ) = hq ( ihq ) + temp * ptsaux ( 2 , iq ) ** 2 else ihp = ( ip * ip + ip ) / 2 hq ( ihp ) = hq ( ihp ) + temp * ptsaux ( 1 , ip ) ** 2 if ( iq > 0 ) then hq ( ihq ) = hq ( ihq ) + temp * ptsaux ( 1 , iq ) ** 2 iw = max ( ihp , ihq ) - abs ( iq - ip ) hq ( iw ) = hq ( iw ) + temp * ptsaux ( 1 , ip ) * ptsaux ( 1 , iq ) end if end if end if end do ptsid ( kpt ) = zero end do end subroutine rescue","tags":"","loc":"proc/rescue.html","title":"rescue – Fortran Program"},{"text":"public recursive subroutine trsbox(n, npt, xpt, xopt, gopt, hq, pq, sl, su, delta, xnew, d, gnew, xbdi, s, hs, hred, dsq, crvmin) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: xpt real :: xopt real :: gopt real :: hq real :: pq real :: sl real :: su real :: delta real :: xnew real :: d real :: gnew real :: xbdi real :: s real :: hs real :: hred real :: dsq real :: crvmin Called By proc~~trsbox~~CalledByGraph proc~trsbox trsbox proc~bobyqb bobyqb proc~bobyqb->proc~trsbox proc~bobyqa bobyqa proc~bobyqa->proc~bobyqb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code trsbox Source Code recursive subroutine trsbox ( n , npt , xpt , xopt , gopt , hq , pq , sl , su , delta , xnew , d , gnew , & & xbdi , s , hs , hred , dsq , crvmin ) !DEC$ ATTRIBUTES DLLEXPORT :: trsbox implicit real ( dbl ) ( a - h , o - z ) dimension xpt ( npt , * ), xopt ( * ), gopt ( * ), hq ( * ), pq ( * ), sl ( * ), su ( * ), xnew & & ( * ), d ( * ), gnew ( * ), xbdi ( * ), s ( * ), hs ( * ), hred ( * ) ! !     The arguments N, NPT, XPT, XOPT, GOPT, HQ, PQ, SL and SU have the same !       meanings as the corresponding arguments of BOBYQB. !     DELTA is the trust region radius for the present calculation, which !       seeks a small value of the quadratic model within distance DELTA of !       XOPT subject to the bounds on the variables. !     XNEW will be set to a new vector of variables that is approximately !       the one that minimizes the quadratic model within the trust region !       subject to the SL and SU constraints on the variables. It satisfies !       as equations the bounds that become active during the calculation. !     D is the calculated trial step from XOPT, generated iteratively from an !       initial value of zero. Thus XNEW is XOPT+D after the final iteration. !     GNEW holds the gradient of the quadratic model at XOPT+D. It is updated !       when D is updated. !     XBDI is a working space vector. For I=1,2,...,N, the element XBDI(I) is !       set to -1.0, 0.0, or 1.0, the value being nonzero if and only if the !       I-th variable has become fixed at a bound, the bound being SL(I) or !       SU(I) in the case XBDI(I)=-1.0 or XBDI(I)=1.0, respectively. This !       information is accumulated during the construction of XNEW. !     The arrays S, HS and HRED are also used for working space. They hold the !       current search direction, and the changes in the gradient of Q along S !       and the reduced D, respectively, where the reduced D is the same as D, !       except that the components of the fixed variables are zero. !     DSQ will be set to the square of the length of XNEW-XOPT. !     CRVMIN is set to zero if D reaches the trust region boundary. Otherwise !       it is set to the least curvature of H that occurs in the conjugate !       gradient searches that are not restricted by any constraints. The !       value CRVMIN=-1.0D0 is set, however, if all of these searches are !       constrained. ! !     A version of the truncated conjugate gradient is applied. If a line !     search is restricted by a constraint, then the procedure is restarted, !     the values of the variables that are at their bounds being fixed. If !     the trust region boundary is reached, then further changes may be made !     to D, each one being in the two dimensional space that is spanned !     by the current D and the gradient of Q at XOPT+D, staying on the trust !     region boundary. Termination occurs when the reduction in Q seems to !     be close to the greatest reduction that can be achieved. ! !     Set some constants. ! half = 0.5_dbl one = 1.0_dbl onemin = - 1.0_dbl zero = 0.0_dbl ! !     The sign of GOPT(I) gives the sign of the change to the I-th variable !     that will reduce Q from its value at XOPT. Thus XBDI(I) shows whether !     or not to fix the I-th variable at one of its bounds initially, with !     NACT being set to the number of fixed variables. D and GNEW are also !     set for the first iteration. DELSQ is the upper bound on the sum of !     squares of the free variables. QRED is the reduction in Q so far. ! iterc = 0 nact = 0 sqstp = zero do i = 1 , n xbdi ( i ) = zero if ( xopt ( i ) <= sl ( i )) then if ( gopt ( i ) >= zero ) xbdi ( i ) = onemin else if ( xopt ( i ) >= su ( i )) then if ( gopt ( i ) <= zero ) xbdi ( i ) = one end if if ( xbdi ( i ) /= zero ) nact = nact + 1 d ( i ) = zero gnew ( i ) = gopt ( i ) end do delsq = delta * delta qred = zero crvmin = onemin ! !     Set the next search direction of the conjugate gradient method. It is !     the steepest descent direction initially and when the iterations are !     restarted because a variable has just been fixed by a bound, and of !     course the components of the fixed variables are zero. ITERMAX is an !     upper bound on the indices of the conjugate gradient iterations. ! 20 beta = zero 30 stepsq = zero do i = 1 , n if ( xbdi ( i ) /= zero ) then s ( i ) = zero else if ( beta == zero ) then s ( i ) = - gnew ( i ) else s ( i ) = beta * s ( i ) - gnew ( i ) end if stepsq = stepsq + s ( i ) ** 2 end do if ( stepsq == zero ) go to 190 if ( beta == zero ) then gredsq = stepsq itermax = iterc + n - nact end if if ( gredsq * delsq <= 1.0e-4_dbl * qred * qred ) go to 190 ! !     Multiply the search direction by the second derivative matrix of Q and !     calculate some scalars for the choice of steplength. Then set BLEN to !     the length of the the step to the trust region boundary and STPLEN to !     the steplength, ignoring the simple bounds. ! go to 210 50 resid = delsq ds = zero shs = zero do i = 1 , n if ( xbdi ( i ) == zero ) then resid = resid - d ( i ) ** 2 ds = ds + s ( i ) * d ( i ) shs = shs + s ( i ) * hs ( i ) end if end do if ( resid <= zero ) go to 90 temp = sqrt ( stepsq * resid + ds * ds ) if ( ds < zero ) then blen = ( temp - ds ) / stepsq else blen = resid / ( temp + ds ) end if stplen = blen if ( shs > zero ) then stplen = min ( blen , gredsq / shs ) end if ! ! !     Reduce STPLEN if necessary in order to preserve the simple bounds, !     letting IACT be the index of the new constrained variable. ! iact = 0 do i = 1 , n if ( s ( i ) /= zero ) then xsum = xopt ( i ) + d ( i ) if ( s ( i ) > zero ) then temp = ( su ( i ) - xsum ) / s ( i ) else temp = ( sl ( i ) - xsum ) / s ( i ) end if if ( temp < stplen ) then stplen = temp iact = i end if end if end do ! !     Update CRVMIN, GNEW and D. Set SDEC to the decrease that occurs in Q. ! sdec = zero if ( stplen > zero ) then iterc = iterc + 1 temp = shs / stepsq if ( iact == 0 . and . temp > zero ) then crvmin = min ( crvmin , temp ) if ( crvmin == onemin ) crvmin = temp end if ggsav = gredsq gredsq = zero do i = 1 , n gnew ( i ) = gnew ( i ) + stplen * hs ( i ) if ( xbdi ( i ) == zero ) gredsq = gredsq + gnew ( i ) ** 2 d ( i ) = d ( i ) + stplen * s ( i ) end do sdec = max ( stplen * ( ggsav - half * stplen * shs ), zero ) qred = qred + sdec end if ! !     Restart the conjugate gradient method if it has hit a new bound. ! if ( iact > 0 ) then nact = nact + 1 xbdi ( iact ) = one if ( s ( iact ) < zero ) xbdi ( iact ) = onemin delsq = delsq - d ( iact ) ** 2 if ( delsq <= zero ) go to 90 go to 20 end if ! !     If STPLEN is less than BLEN, then either apply another conjugate !     gradient iteration or RETURN. ! if ( stplen < blen ) then if ( iterc == itermax ) go to 190 if ( sdec <= 0.01_dbl * qred ) go to 190 beta = gredsq / ggsav go to 30 end if 90 crvmin = zero ! !     Prepare for the alternative iteration by calculating some scalars and !     by multiplying the reduced D by the second derivative matrix of Q. ! 100 if ( nact >= n - 1 ) go to 190 dredsq = zero dredg = zero gredsq = zero do i = 1 , n if ( xbdi ( i ) == zero ) then dredsq = dredsq + d ( i ) ** 2 dredg = dredg + d ( i ) * gnew ( i ) gredsq = gredsq + gnew ( i ) ** 2 s ( i ) = d ( i ) else s ( i ) = zero end if end do itcsav = iterc go to 210 ! !     Let the search direction S be a linear combination of the reduced D !     and the reduced G that is orthogonal to the reduced D. ! 120 iterc = iterc + 1 temp = gredsq * dredsq - dredg * dredg if ( temp <= 1.0e-4_dbl * qred * qred ) go to 190 temp = sqrt ( temp ) do i = 1 , n if ( xbdi ( i ) == zero ) then s ( i ) = ( dredg * d ( i ) - dredsq * gnew ( i )) / temp else s ( i ) = zero end if end do sredg = - temp ! !     By considering the simple bounds on the variables, calculate an upper !     bound on the tangent of half the angle of the alternative iteration, !     namely ANGBD, except that, if already a free variable has reached a !     bound, there is a branch back to label 100 after fixing that variable. ! angbd = one iact = 0 do i = 1 , n if ( xbdi ( i ) == zero ) then tempa = xopt ( i ) + d ( i ) - sl ( i ) tempb = su ( i ) - xopt ( i ) - d ( i ) if ( tempa <= zero ) then nact = nact + 1 xbdi ( i ) = onemin go to 100 else if ( tempb <= zero ) then nact = nact + 1 xbdi ( i ) = one go to 100 end if ratio = one ssq = d ( i ) ** 2 + s ( i ) ** 2 temp = ssq - ( xopt ( i ) - sl ( i )) ** 2 if ( temp > zero ) then temp = sqrt ( temp ) - s ( i ) if ( angbd * temp > tempa ) then angbd = tempa / temp iact = i xsav = onemin end if end if temp = ssq - ( su ( i ) - xopt ( i )) ** 2 if ( temp > zero ) then temp = sqrt ( temp ) + s ( i ) if ( angbd * temp > tempb ) then angbd = tempb / temp iact = i xsav = one end if end if end if end do ! !     Calculate HHD and some curvatures for the alternative iteration. ! go to 210 150 shs = zero dhs = zero dhd = zero do i = 1 , n if ( xbdi ( i ) == zero ) then shs = shs + s ( i ) * hs ( i ) dhs = dhs + d ( i ) * hs ( i ) dhd = dhd + d ( i ) * hred ( i ) end if end do ! !     Seek the greatest reduction in Q for a range of equally spaced values !     of ANGT in [0,ANGBD], where ANGT is the tangent of half the angle of !     the alternative iteration. ! redmax = zero isav = 0 redsav = zero iu = 1 7.0_dbl * angbd + 3.1_dbl do i = 1 , iu angt = angbd * real ( i , dbl ) / real ( iu , dbl ) sth = ( angt + angt ) / ( one + angt * angt ) temp = shs + angt * ( angt * dhd - dhs - dhs ) rednew = sth * ( angt * dredg - sredg - half * sth * temp ) if ( rednew > redmax ) then redmax = rednew isav = i rdprev = redsav else if ( i == isav + 1 ) then rdnext = rednew end if redsav = rednew end do ! !     Return if the reduction is zero. Otherwise, set the sine and cosine !     of the angle of the alternative iteration, and calculate SDEC. ! if ( isav == 0 ) go to 190 if ( isav < iu ) then temp = ( rdnext - rdprev ) / ( redmax + redmax - rdprev - rdnext ) angt = angbd * ( real ( isav , dbl ) + half * temp ) / real ( iu , dbl ) end if cth = ( one - angt * angt ) / ( one + angt * angt ) sth = ( angt + angt ) / ( one + angt * angt ) temp = shs + angt * ( angt * dhd - dhs - dhs ) sdec = sth * ( angt * dredg - sredg - half * sth * temp ) if ( sdec <= zero ) go to 190 ! !     Update GNEW, D and HRED. If the angle of the alternative iteration !     is restricted by a bound on a free variable, that variable is fixed !     at the bound. ! dredg = zero gredsq = zero do i = 1 , n gnew ( i ) = gnew ( i ) + ( cth - one ) * hred ( i ) + sth * hs ( i ) if ( xbdi ( i ) == zero ) then d ( i ) = cth * d ( i ) + sth * s ( i ) dredg = dredg + d ( i ) * gnew ( i ) gredsq = gredsq + gnew ( i ) ** 2 end if hred ( i ) = cth * hred ( i ) + sth * hs ( i ) end do qred = qred + sdec if ( iact > 0 . and . isav == iu ) then nact = nact + 1 xbdi ( iact ) = xsav go to 100 end if ! !     If SDEC is sufficiently small, then RETURN after setting XNEW to !     XOPT+D, giving careful attention to the bounds. ! if ( sdec > 0.01_dbl * qred ) go to 120 190 dsq = zero do i = 1 , n xnew ( i ) = max ( min ( xopt ( i ) + d ( i ), su ( i )), sl ( i )) if ( xbdi ( i ) == onemin ) xnew ( i ) = sl ( i ) if ( xbdi ( i ) == one ) xnew ( i ) = su ( i ) d ( i ) = xnew ( i ) - xopt ( i ) dsq = dsq + d ( i ) ** 2 end do return ! !     The following instructions multiply the current S-vector by the second !     derivative matrix of the quadratic model, putting the product in HS. !     They are reached from three different parts of the software above and !     they can be regarded as an external subroutine. ! 210 ih = 0 do j = 1 , n hs ( j ) = zero do i = 1 , j ih = ih + 1 if ( i < j ) hs ( j ) = hs ( j ) + hq ( ih ) * s ( i ) hs ( i ) = hs ( i ) + hq ( ih ) * s ( j ) end do end do do k = 1 , npt if ( pq ( k ) /= zero ) then temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * s ( j ) end do temp = temp * pq ( k ) do i = 1 , n hs ( i ) = hs ( i ) + temp * xpt ( k , i ) end do end if end do if ( crvmin /= zero ) go to 50 if ( iterc > itcsav ) go to 150 do i = 1 , n hred ( i ) = hs ( i ) end do go to 120 end subroutine trsbox","tags":"","loc":"proc/trsbox.html","title":"trsbox – Fortran Program"},{"text":"public recursive subroutine update(n, npt, bmat, zmat, ndim, vlag, beta, denom, knew, w) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: bmat real :: zmat integer :: ndim real :: vlag real :: beta real :: denom integer :: knew real :: w Called By proc~~update~~CalledByGraph proc~update update proc~rescue rescue proc~rescue->proc~update proc~bobyqb bobyqb proc~bobyqb->proc~update proc~bobyqb->proc~rescue proc~bobyqa bobyqa proc~bobyqa->proc~bobyqb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code update Source Code recursive subroutine update ( n , npt , bmat , zmat , ndim , vlag , beta , denom , knew , w ) !DEC$ ATTRIBUTES DLLEXPORT :: update implicit real ( dbl ) ( a - h , o - z ) dimension bmat ( ndim , * ), zmat ( npt , * ), vlag ( * ), w ( * ) ! !     The arrays BMAT and ZMAT are updated, as required by the new position !     of the interpolation point that has the index KNEW. The vector VLAG has !     N+NPT components, set on entry to the first NPT and last N components !     of the product Hw in equation (4.11) of the Powell (2006) paper on !     NEWUOA. Further, BETA is set on entry to the value of the parameter !     with that name, and DENOM is set to the denominator of the updating !     formula. Elements of ZMAT may be treated as zero if their moduli are !     at most ZTEST. The first NDIM elements of W are used for working space. ! !     Set some constants. ! one = 1.0_dbl zero = 0.0_dbl nptm = npt - n - 1 ztest = zero do k = 1 , npt do j = 1 , nptm ztest = max ( ztest , abs ( zmat ( k , j ))) end do end do ztest = 1.0e-20_dbl * ztest ! !     Apply the rotations that put zeros in the KNEW-th row of ZMAT. ! jl = 1 do j = 2 , nptm if ( abs ( zmat ( knew , j )) > ztest ) then temp = sqrt ( zmat ( knew , 1 ) ** 2 + zmat ( knew , j ) ** 2 ) tempa = zmat ( knew , 1 ) / temp tempb = zmat ( knew , j ) / temp do i = 1 , npt temp = tempa * zmat ( i , 1 ) + tempb * zmat ( i , j ) zmat ( i , j ) = tempa * zmat ( i , j ) - tempb * zmat ( i , 1 ) zmat ( i , 1 ) = temp end do end if zmat ( knew , j ) = zero end do ! !     Put the first NPT components of the KNEW-th column of HLAG into W, !     and calculate the parameters of the updating formula. ! do i = 1 , npt w ( i ) = zmat ( knew , 1 ) * zmat ( i , 1 ) end do alpha = w ( knew ) tau = vlag ( knew ) vlag ( knew ) = vlag ( knew ) - one ! !     Complete the updating of ZMAT. ! temp = sqrt ( denom ) tempb = zmat ( knew , 1 ) / temp tempa = tau / temp do i = 1 , npt zmat ( i , 1 ) = tempa * zmat ( i , 1 ) - tempb * vlag ( i ) end do ! !     Finally, update the matrix BMAT. ! do j = 1 , n jp = npt + j w ( jp ) = bmat ( knew , j ) tempa = ( alpha * vlag ( jp ) - tau * w ( jp )) / denom tempb = ( - beta * w ( jp ) - tau * vlag ( jp )) / denom do i = 1 , jp bmat ( i , j ) = bmat ( i , j ) + tempa * vlag ( i ) + tempb * w ( i ) if ( i > npt ) bmat ( jp , i - npt ) = bmat ( i , j ) end do end do end subroutine update","tags":"","loc":"proc/update.html","title":"update – Fortran Program"},{"text":"public recursive subroutine bobyqa(ipar, initmeanval, expt, n, npt, x, xl, xu, rhobeg, rhoend, iprint, maxfun, calfun, accum, mLPNH, mLPSH, mask, prefactor, rgx, rgy, rgz, stepsize, verbose) Uses: iso_c_binding proc~~bobyqa~2~~UsesGraph proc~bobyqa~2 bobyqa iso_c_binding iso_c_binding iso_c_binding->proc~bobyqa~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in) :: ipar (9) real(kind=sgl), intent(in) :: initmeanval (3) real(kind=sgl), intent(in) :: expt (ipar(2)*ipar(3)/ipar(1)**2) integer, intent(in) :: n number of variables (must be at least two) integer, intent(in) :: npt number of interpolation conditions. Its value must be in\n the interval [N+2,(N+1)(N+2)/2]. Choices that exceed 2*N+1 are not\n recommended. real(kind=dbl), intent(inout), dimension(:) :: x Initial values of the variables must be set in X(1),X(2),...,X(N). They\n will be changed to the values that give the least calculated F. real(kind=dbl), intent(in), dimension(:) :: xl lower bounds on x. The construction of quadratic models\n requires XL(I) to be strictly less than XU(I) for each I. Further,\n the contribution to a model from changes to the I-th variable is\n damaged severely by rounding errors if XU(I)-XL(I) is too small. real(kind=dbl), intent(in), dimension(:) :: xu upper bounds on x. The construction of quadratic models\n requires XL(I) to be strictly less than XU(I) for each I. Further,\n the contribution to a model from changes to the I-th variable is\n damaged severely by rounding errors if XU(I)-XL(I) is too small. real(kind=dbl), intent(in) :: rhobeg RHOBEG must be set to the initial value of a trust region radius. It must be positive, and typically should be about one tenth of the greatest\n expected change to a variable.  An error return occurs if any of \n the differences XU(I)-XL(I), I=1,...,N, is less than 2*RHOBEG. real(kind=dbl), intent(in) :: rhoend RHOEND must be set to the final value of a trust\n region radius. It must be positive with RHOEND no greater than\n RHOBEG. Typically, RHOEND should indicate the\n accuracy that is required in the final values of the variables. integer, intent(in) :: iprint IPRINT should be set to 0, 1, 2 or 3, which controls the\n amount of printing. Specifically, there is no output if IPRINT=0 and\n there is output only at the return if IPRINT=1. Otherwise, each new\n value of RHO is printed, with the best vector of variables so far and\n the corresponding value of the objective function. Further, each new\n value of F with its variables are output if IPRINT=3. integer, intent(in) :: maxfun an upper bound on the number of calls of CALFUN. procedure( func2 ) :: calfun SUBROUTINE CALFUN has to be provided by the user. It must set\n F to the value of the objective function for the current values of the\n variables X(1),X(2),...,X(N), which are generated automatically in a\n way that satisfies the bounds given in XL and XU. real(kind=sgl), intent(in) :: accum (ipar(6),ipar(2),ipar(3)) real(kind=sgl), intent(in) :: mLPNH (-ipar(4):ipar(4),-ipar(5):ipar(5),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(4):ipar(4),-ipar(5):ipar(5),ipar(7)) real(kind=sgl), intent(in) :: mask (ipar(2)/ipar(1),ipar(3)/ipar(1)) real(kind=dbl) :: prefactor real(kind=sgl), intent(in) :: rgx (ipar(2),ipar(3)) real(kind=sgl), intent(in) :: rgy (ipar(2),ipar(3)) real(kind=sgl), intent(in) :: rgz (ipar(2),ipar(3)) real(kind=sgl), intent(in) :: stepsize (3) logical, intent(in), optional :: verbose Calls proc~~bobyqa~2~~CallsGraph proc~bobyqa~2 bobyqa proc~bobyqb~2 bobyqb proc~bobyqa~2->proc~bobyqb~2 proc~update~2 update proc~bobyqb~2->proc~update~2 proc~trsbox~2 trsbox proc~bobyqb~2->proc~trsbox~2 proc~altmov~2 altmov proc~bobyqb~2->proc~altmov~2 proc~prelim~2 prelim proc~bobyqb~2->proc~prelim~2 proc~rescue~2 rescue proc~bobyqb~2->proc~rescue~2 proc~rescue~2->proc~update~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code bobyqa Source Code recursive subroutine bobyqa ( ipar , initmeanval , expt , n , npt , x , xl ,& xu , rhobeg , rhoend , iprint , maxfun , calfun , accum , mLPNH , mLPSH ,& mask , prefactor , rgx , rgy , rgz , stepsize , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: bobyqa use , INTRINSIC :: ISO_C_BINDING implicit none integer ( c_size_t ), intent ( in ) :: ipar ( 9 ) real ( sgl ), intent ( in ) :: initmeanval ( 3 ) real ( sgl ), intent ( in ) :: stepsize ( 3 ) real ( kind = sgl ), intent ( in ) :: expt ( ipar ( 2 ) * ipar ( 3 ) / ipar ( 1 ) ** 2 ) real ( kind = sgl ), INTENT ( IN ) :: accum ( ipar ( 6 ), ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: mLPNH ( - ipar ( 4 ): ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), ipar ( 7 )) real ( kind = sgl ), INTENT ( IN ) :: mLPSH ( - ipar ( 4 ): ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), ipar ( 7 )) real ( kind = sgl ), INTENT ( IN ) :: rgx ( ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: rgy ( ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: rgz ( ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: mask ( ipar ( 2 ) / ipar ( 1 ), ipar ( 3 ) / ipar ( 1 )) real ( kind = dbl ) :: prefactor logical , intent ( in ), optional :: verbose integer , intent ( in ) :: n !! number of variables (must be at least two) integer , intent ( in ) :: npt !! number of interpolation conditions. Its value must be in !! the interval [N+2,(N+1)(N+2)/2]. Choices that exceed 2*N+1 are not !! recommended. real ( dbl ), dimension (:), intent ( inout ) :: x !! Initial values of the variables must be set in X(1),X(2),...,X(N). They !! will be changed to the values that give the least calculated F. real ( dbl ), dimension (:), intent ( in ) :: xl !! lower bounds on x. The construction of quadratic models !! requires XL(I) to be strictly less than XU(I) for each I. Further, !! the contribution to a model from changes to the I-th variable is !! damaged severely by rounding errors if XU(I)-XL(I) is too small. real ( dbl ), dimension (:), intent ( in ) :: xu !! upper bounds on x. The construction of quadratic models !! requires XL(I) to be strictly less than XU(I) for each I. Further, !! the contribution to a model from changes to the I-th variable is !! damaged severely by rounding errors if XU(I)-XL(I) is too small. real ( dbl ), intent ( in ) :: rhobeg !! RHOBEG must be set to the initial value of a trust region radius. !! It must be positive, and typically should be about one tenth of the greatest !! expected change to a variable.  An error return occurs if any of !! the differences XU(I)-XL(I), I=1,...,N, is less than 2*RHOBEG. real ( dbl ), intent ( in ) :: rhoend !! RHOEND must be set to the final value of a trust !! region radius. It must be positive with RHOEND no greater than !! RHOBEG. Typically, RHOEND should indicate the !! accuracy that is required in the final values of the variables. integer , intent ( in ) :: iprint !! IPRINT should be set to 0, 1, 2 or 3, which controls the !! amount of printing. Specifically, there is no output if IPRINT=0 and !! there is output only at the return if IPRINT=1. Otherwise, each new !! value of RHO is printed, with the best vector of variables so far and !! the corresponding value of the objective function. Further, each new !! value of F with its variables are output if IPRINT=3. integer , intent ( in ) :: maxfun !! an upper bound on the number of calls of CALFUN. procedure ( func2 ) :: calfun !! SUBROUTINE CALFUN has to be provided by the user. It must set !! F to the value of the objective function for the current values of the !! variables X(1),X(2),...,X(N), which are generated automatically in a !! way that satisfies the bounds given in XL and XU. integer :: ibmat , id , ifv , igo , ihq , ipq , isl , isu , ivl , iw , ixa ,& ixb , ixn , ixo , ixp , izmat , j , jsl , jsu , ndim , np real ( dbl ), dimension (:), allocatable :: w real ( dbl ) :: temp real ( dbl ), parameter :: zero = 0.0_dbl ! The array W will be used for working space. allocate ( w (( NPT + 5 ) * ( NPT + N ) + 3 * N * ( N + 5 ) / 2 ) ) ! !     Return if the value of NPT is unacceptable. ! np = n + 1 if ( npt < n + 2 . or . npt > (( n + 2 ) * np ) / 2 ) then write ( * , '(/4X,A)' ) & 'Return from BOBYQA because NPT is not in the required interval' return end if ! !     Partition the working space array, so that different parts of it can !     be treated separately during the calculation of BOBYQB. The partition !     requires the first (NPT+2)*(NPT+N)+3*N*(N+5)/2 elements of W plus the !     space that is taken by the last array in the argument list of BOBYQB. ! ndim = npt + n ixb = 1 ixp = ixb + n ifv = ixp + n * npt ixo = ifv + npt igo = ixo + n ihq = igo + n ipq = ihq + ( n * np ) / 2 ibmat = ipq + npt izmat = ibmat + ndim * n isl = izmat + npt * ( npt - np ) isu = isl + n ixn = isu + n ixa = ixn + n id = ixa + n ivl = id + n iw = ivl + ndim ! !     Return if there is insufficient space between the bounds. Modify the !     initial X if necessary in order to avoid conflicts between the bounds !     and the construction of the first quadratic model. The lower and upper !     bounds on moves from the updated X are set now, in the ISL and ISU !     partitions of W, in order to provide useful and exact information about !     components of X that become within distance RHOBEG from their bounds. ! do j = 1 , n temp = xu ( j ) - xl ( j ) if ( temp < rhobeg + rhobeg ) then write ( * , '(/4X,A)' ) & 'Return from BOBYQA because one of the differences ' // & 'XU(I)-XL(I) is less than 2*RHOBEG.' return end if jsl = isl + j - 1 jsu = jsl + n w ( jsl ) = xl ( j ) - x ( j ) w ( jsu ) = xu ( j ) - x ( j ) if ( w ( jsl ) >=- rhobeg ) then if ( w ( jsl ) >= zero ) then x ( j ) = xl ( j ) w ( jsl ) = zero w ( jsu ) = temp else x ( j ) = xl ( j ) + rhobeg w ( jsl ) = - rhobeg w ( jsu ) = max ( xu ( j ) - x ( j ), rhobeg ) end if else if ( w ( jsu ) <= rhobeg ) then if ( w ( jsu ) <= zero ) then x ( j ) = xu ( j ) w ( jsl ) = - temp w ( jsu ) = zero else x ( j ) = xu ( j ) - rhobeg w ( jsl ) = min ( xl ( j ) - x ( j ), - rhobeg ) w ( jsu ) = rhobeg end if end if end do ! !     Make the call of BOBYQB. ! if ( present ( verbose )) then call bobyqb ( ipar , initmeanval , expt , n , npt , x , xl , xu , rhobeg , rhoend , iprint ,& maxfun , w ( ixb ), w ( ixp ), w ( ifv ), w ( ixo ), w ( igo ), w ( ihq ), w ( ipq ), w ( ibmat ), w ( izmat ), ndim , w ( isl ), & w ( isu ), w ( ixn ), w ( ixa ), w ( id ), w ( ivl ), w ( iw ), calfun , accum , mLPNH , mLPSH , mask , prefactor , & rgx , rgy , rgz , stepsize , verbose ) else call bobyqb ( ipar , initmeanval , expt , n , npt , x , xl , xu , rhobeg , rhoend , iprint ,& maxfun , w ( ixb ), w ( ixp ), w ( ifv ), w ( ixo ), w ( igo ), w ( ihq ), w ( ipq ), w ( ibmat ), w ( izmat ), ndim , w ( isl ), & w ( isu ), w ( ixn ), w ( ixa ), w ( id ), w ( ivl ), w ( iw ), calfun , accum , mLPNH , mLPSH , mask , prefactor , & rgx , rgy , rgz , stepsize ) end if deallocate ( w ) end subroutine bobyqa","tags":"","loc":"proc/bobyqa~2.html","title":"bobyqa – Fortran Program"},{"text":"public recursive subroutine bobyqb(ipar, initmeanval, expt1, n, npt, x, xl, xu, rhobeg, rhoend, iprint, maxfun, xbase, xpt, fval, xopt, gopt, hq, pq, bmat, zmat, ndim, sl, su, xnew, xalt, d, vlag, w, calfun, accum, mLPNH, mLPSH, mask, prefactor, rgx, rgy, rgz, stepsize, verbose) Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in) :: ipar (9) real(kind=sgl), intent(in) :: initmeanval (3) real(kind=sgl), intent(in) :: expt1 (ipar(2)*ipar(3)/ipar(1)**2) integer :: n integer :: npt real :: x real :: xl real :: xu real :: rhobeg real :: rhoend integer :: iprint integer :: maxfun real :: xbase real :: xpt real :: fval real :: xopt real :: gopt real :: hq real :: pq real :: bmat real :: zmat integer :: ndim real :: sl real :: su real :: xnew real :: xalt real :: d real :: vlag real :: w procedure( func2 ) :: calfun real(kind=sgl), intent(in) :: accum (ipar(6),ipar(2),ipar(3)) real(kind=sgl), intent(in) :: mLPNH (-ipar(4):ipar(4),-ipar(5):ipar(5),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(4):ipar(4),-ipar(5):ipar(5),ipar(7)) real(kind=sgl), intent(in) :: mask (ipar(2)/ipar(1),ipar(3)/ipar(1)) real(kind=dbl) :: prefactor real(kind=sgl), intent(in) :: rgx (ipar(2),ipar(3)) real(kind=sgl), intent(in) :: rgy (ipar(2),ipar(3)) real(kind=sgl), intent(in) :: rgz (ipar(2),ipar(3)) real(kind=sgl), intent(in) :: stepsize (3) logical, intent(in), optional :: verbose Calls proc~~bobyqb~2~~CallsGraph proc~bobyqb~2 bobyqb proc~update~2 update proc~bobyqb~2->proc~update~2 proc~trsbox~2 trsbox proc~bobyqb~2->proc~trsbox~2 proc~altmov~2 altmov proc~bobyqb~2->proc~altmov~2 proc~prelim~2 prelim proc~bobyqb~2->proc~prelim~2 proc~rescue~2 rescue proc~bobyqb~2->proc~rescue~2 proc~rescue~2->proc~update~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~bobyqb~2~~CalledByGraph proc~bobyqb~2 bobyqb proc~bobyqa~2 bobyqa proc~bobyqa~2->proc~bobyqb~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code bobyqb Source Code recursive subroutine bobyqb ( ipar , initmeanval , expt1 , n , npt , x , xl , xu ,& rhobeg , rhoend , iprint , maxfun , xbase , xpt , fval , xopt , gopt , hq ,& pq , bmat , zmat , ndim , sl , su , xnew , xalt , d , vlag , w , calfun , accum ,& mLPNH , mLPSH , mask , prefactor , rgx , rgy , rgz , stepsize , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: bobyqb implicit real ( dbl ) ( a - h , o - z ) integer ( c_size_t ), intent ( in ) :: ipar ( 9 ) real ( sgl ), intent ( in ) :: initmeanval ( 3 ) real ( sgl ), intent ( in ) :: stepsize ( 3 ) real ( sgl ), intent ( in ) :: expt1 ( ipar ( 2 ) * ipar ( 3 ) / ipar ( 1 ) ** 2 ) real ( kind = sgl ), INTENT ( IN ) :: accum ( ipar ( 6 ), ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: mLPNH ( - ipar ( 4 ): ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), ipar ( 7 )) real ( kind = sgl ), INTENT ( IN ) :: mLPSH ( - ipar ( 4 ): ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), ipar ( 7 )) real ( kind = sgl ), INTENT ( IN ) :: rgx ( ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: rgy ( ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: rgz ( ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: mask ( ipar ( 2 ) / ipar ( 1 ), ipar ( 3 ) / ipar ( 1 )) real ( kind = dbl ) :: prefactor logical , intent ( in ), optional :: verbose dimension x ( * ), xl ( * ), xu ( * ), xbase ( * ), xpt ( npt , * ), fval ( * ), xopt ( * ), & gopt ( * ), hq ( * ), pq ( * ), bmat ( ndim , * ), zmat ( npt , * ), sl ( * ), su ( * ), & xnew ( * ), xalt ( * ), d ( * ), vlag ( * ), w ( * ) procedure ( func2 ) :: calfun ! !     The arguments N, NPT, X, XL, XU, RHOBEG, RHOEND, IPRINT and MAXFUN !       are identical to the corresponding arguments in SUBROUTINE BOBYQA. !     XBASE holds a shift of origin that should reduce the contributions !       from rounding errors to values of the model and Lagrange functions. !     XPT is a two-dimensional array that holds the coordinates of the !       interpolation points relative to XBASE. !     FVAL holds the values of F at the interpolation points. !     XOPT is set to the displacement from XBASE of the trust region centre. !     GOPT holds the gradient of the quadratic model at XBASE+XOPT. !     HQ holds the explicit second derivatives of the quadratic model. !     PQ contains the parameters of the implicit second derivatives of the !       quadratic model. !     BMAT holds the last N columns of H. !     ZMAT holds the factorization of the leading NPT by NPT submatrix of H, !       this factorization being ZMAT times ZMAT&#94;T, which provides both the !       correct rank and positive semi-definiteness. !     NDIM is the first dimension of BMAT and has the value NPT+N. !     SL and SU hold the differences XL-XBASE and XU-XBASE, respectively. !       All the components of every XOPT are going to satisfy the bounds !       SL(I) .LEQ. XOPT(I) .LEQ. SU(I), with appropriate equalities when !       XOPT is on a constraint boundary. !     XNEW is chosen by SUBROUTINE TRSBOX or ALTMOV. Usually XBASE+XNEW is the !       vector of variables for the next call of CALFUN. XNEW also satisfies !       the SL and SU constraints in the way that has just been mentioned. !     XALT is an alternative to XNEW, chosen by ALTMOV, that may replace XNEW !       in order to increase the denominator in the updating of UPDATE. !     D is reserved for a trial step from XOPT, which is usually XNEW-XOPT. !     VLAG contains the values of the Lagrange functions at a new point X. !       They are part of a product that requires VLAG to be of length NDIM. !     W is a one-dimensional array that is used for working space. Its length !       must be at least 3*NDIM = 3*(NPT+N). ! !     Set some constants. ! half = 0.5_dbl one = 1.0_dbl ten = 1 0.0_dbl tenth = 0.1_dbl two = 2.0_dbl zero = 0.0_dbl np = n + 1 nptm = npt - np nh = ( n * np ) / 2 ! !     The call of PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ, !     BMAT and ZMAT for the first iteration, with the corresponding values of !     of NF and KOPT, which are the number of calls of CALFUN so far and the !     index of the interpolation point at the trust region centre. Then the !     initial XOPT is set too. The branch to label 720 occurs if MAXFUN is !     less than NPT. GOPT will be updated if KOPT is different from KBASE. ! if ( present ( verbose )) then call prelim ( ipar , initmeanval , expt1 , n , npt , x , xl , xu , rhobeg ,& iprint , maxfun , xbase , xpt , fval , gopt , hq , pq , bmat , zmat , ndim , sl , su , nf , kopt , calfun , accum , & mLPNH , mLPSH , mask , prefactor , rgx , rgy , rgz , stepsize , verbose ) else call prelim ( ipar , initmeanval , expt1 , n , npt , x , xl , xu , rhobeg ,& iprint , maxfun , xbase , xpt , fval , gopt , hq , pq , bmat , zmat , ndim , sl , su , nf , kopt , calfun , accum , & mLPNH , mLPSH , mask , prefactor , rgx , rgy , rgz , stepsize ) end if xoptsq = zero do i = 1 , n xopt ( i ) = xpt ( kopt , i ) xoptsq = xoptsq + xopt ( i ) ** 2 end do fsave = fval ( 1 ) if ( nf < npt ) then if ( iprint > 0 ) write ( * , '(/4X,A)' ) & 'Return from BOBYQA because CALFUN has been called MAXFUN times.' go to 720 end if kbase = 1 ! !     Complete the settings that are required for the iterative procedure. ! rho = rhobeg delta = rho nresc = nf ntrits = 0 diffa = zero diffb = zero itest = 0 nfsav = nf ! !     Update GOPT if necessary before the first iteration and after each !     call of RESCUE that makes a call of CALFUN. ! 20 if ( kopt /= kbase ) then ih = 0 do j = 1 , n do i = 1 , j ih = ih + 1 if ( i < j ) gopt ( j ) = gopt ( j ) + hq ( ih ) * xopt ( i ) gopt ( i ) = gopt ( i ) + hq ( ih ) * xopt ( j ) end do end do if ( nf > npt ) then do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * xopt ( j ) end do temp = pq ( k ) * temp do i = 1 , n gopt ( i ) = gopt ( i ) + temp * xpt ( k , i ) end do end do end if end if ! !     Generate the next point in the trust region that provides a small value !     of the quadratic model subject to the constraints on the variables. !     The integer NTRITS is set to the number \"trust region\" iterations that !     have occurred since the last \"alternative\" iteration. If the length !     of XNEW-XOPT is less than HALF*RHO, however, then there is a branch to !     label 650 or 680 with NTRITS=-1, instead of calculating F at XNEW. ! 60 call trsbox ( n , npt , xpt , xopt , gopt , hq , pq , sl , su , delta , xnew , d , w , w ( np ), & & w ( np + n ), w ( np + 2 * n ), w ( np + 3 * n ), dsq , crvmin ) dnorm = min ( delta , sqrt ( dsq )) if ( dnorm < half * rho ) then ntrits = - 1 distsq = ( ten * rho ) ** 2 if ( nf <= nfsav + 2 ) go to 650 ! !     The following choice between labels 650 and 680 depends on whether or !     not our work with the current RHO seems to be complete. Either RHO is !     decreased or termination occurs if the errors in the quadratic model at !     the last three interpolation points compare favourably with predictions !     of likely improvements to the model within distance HALF*RHO of XOPT. ! errbig = max ( diffa , diffb , diffc ) frhosq = 0.125_dbl * rho * rho if ( crvmin > zero . and . errbig > frhosq * crvmin ) go to 650 bdtol = errbig / rho do j = 1 , n bdtest = bdtol if ( xnew ( j ) == sl ( j )) bdtest = w ( j ) if ( xnew ( j ) == su ( j )) bdtest = - w ( j ) if ( bdtest < bdtol ) then curv = hq (( j + j * j ) / 2 ) do k = 1 , npt curv = curv + pq ( k ) * xpt ( k , j ) ** 2 end do bdtest = bdtest + half * curv * rho if ( bdtest < bdtol ) go to 650 end if end do go to 680 end if ntrits = ntrits + 1 ! !     Severe cancellation is likely to occur if XOPT is too far from XBASE. !     If the following test holds, then XBASE is shifted so that XOPT becomes !     zero. The appropriate changes are made to BMAT and to the second !     derivatives of the current model, beginning with the changes to BMAT !     that do not depend on ZMAT. VLAG is used temporarily for working space. ! 90 if ( dsq <= 1.0e-3_dbl * xoptsq ) then fracsq = 0.25_dbl * xoptsq sumpq = zero do k = 1 , npt sumpq = sumpq + pq ( k ) sum = - half * xoptsq do i = 1 , n sum = sum + xpt ( k , i ) * xopt ( i ) end do w ( npt + k ) = sum temp = fracsq - half * sum do i = 1 , n w ( i ) = bmat ( k , i ) vlag ( i ) = sum * xpt ( k , i ) + temp * xopt ( i ) ip = npt + i do j = 1 , i bmat ( ip , j ) = bmat ( ip , j ) + w ( i ) * vlag ( j ) + vlag ( i ) * w ( j ) end do end do end do ! !     Then the revisions of BMAT that depend on ZMAT are calculated. ! do jj = 1 , nptm sumz = zero sumw = zero do k = 1 , npt sumz = sumz + zmat ( k , jj ) vlag ( k ) = w ( npt + k ) * zmat ( k , jj ) sumw = sumw + vlag ( k ) end do do j = 1 , n sum = ( fracsq * sumz - half * sumw ) * xopt ( j ) do k = 1 , npt sum = sum + vlag ( k ) * xpt ( k , j ) end do w ( j ) = sum do k = 1 , npt bmat ( k , j ) = bmat ( k , j ) + sum * zmat ( k , jj ) end do end do do i = 1 , n ip = i + npt temp = w ( i ) do j = 1 , i bmat ( ip , j ) = bmat ( ip , j ) + temp * w ( j ) end do end do end do ! !     The following instructions complete the shift, including the changes !     to the second derivative parameters of the quadratic model. ! ih = 0 do j = 1 , n w ( j ) = - half * sumpq * xopt ( j ) do k = 1 , npt w ( j ) = w ( j ) + pq ( k ) * xpt ( k , j ) xpt ( k , j ) = xpt ( k , j ) - xopt ( j ) end do do i = 1 , j ih = ih + 1 hq ( ih ) = hq ( ih ) + w ( i ) * xopt ( j ) + xopt ( i ) * w ( j ) bmat ( npt + i , j ) = bmat ( npt + j , i ) end do end do do i = 1 , n xbase ( i ) = xbase ( i ) + xopt ( i ) xnew ( i ) = xnew ( i ) - xopt ( i ) sl ( i ) = sl ( i ) - xopt ( i ) su ( i ) = su ( i ) - xopt ( i ) xopt ( i ) = zero end do xoptsq = zero end if if ( ntrits == 0 ) go to 210 go to 230 ! !     XBASE is also moved to XOPT by a call of RESCUE. This calculation is !     more expensive than the previous shift, because new matrices BMAT and !     ZMAT are generated from scratch, which may include the replacement of !     interpolation points whose positions seem to be causing near linear !     dependence in the interpolation conditions. Therefore RESCUE is called !     only if rounding errors have reduced by at least a factor of two the !     denominator of the formula for updating the H matrix. It provides a !     useful safeguard, but is not invoked in most applications of BOBYQA. ! 190 nfsav = nf kbase = kopt if ( present ( verbose )) then call rescue ( ipar , initmeanval , expt1 , n , npt , xl , xu , iprint , maxfun , xbase ,& xpt , fval , xopt , gopt , hq , pq , bmat , zmat , ndim , sl , su , nf , delta , kopt , vlag , w , w ( n + np ), w ( ndim + np ), & calfun , accum , mLPNH , mLPSH , mask , prefactor , rgx , rgy , rgz , stepsize , verbose ) else call rescue ( ipar , initmeanval , expt1 , n , npt , xl , xu , iprint , maxfun , xbase ,& xpt , fval , xopt , gopt , hq , pq , bmat , zmat , ndim , sl , su , nf , delta , kopt , vlag , w , w ( n + np ), w ( ndim + np ), & calfun , accum , mLPNH , mLPSH , mask , prefactor , rgx , rgy , rgz , stepsize ) end if ! !     XOPT is updated now in case the branch below to label 720 is taken. !     Any updating of GOPT occurs after the branch below to label 20, which !     leads to a trust region iteration as does the branch to label 60. ! xoptsq = zero if ( kopt /= kbase ) then do i = 1 , n xopt ( i ) = xpt ( kopt , i ) xoptsq = xoptsq + xopt ( i ) ** 2 end do end if if ( nf < 0 ) then nf = maxfun if ( iprint > 0 ) write ( * , '(/4X,A)' ) & 'Return from BOBYQA because CALFUN has been called MAXFUN times.' go to 720 end if nresc = nf if ( nfsav < nf ) then nfsav = nf go to 20 end if if ( ntrits > 0 ) go to 60 ! !     Pick two alternative vectors of variables, relative to XBASE, that !     are suitable as new positions of the KNEW-th interpolation point. !     Firstly, XNEW is set to the point on a line through XOPT and another !     interpolation point that minimizes the predicted value of the next !     denominator, subject to ||XNEW - XOPT|| .LEQ. ADELT and to the SL !     and SU bounds. Secondly, XALT is set to the best feasible point on !     a constrained version of the Cauchy step of the KNEW-th Lagrange !     function, the corresponding value of the square of this function !     being returned in CAUCHY. The choice between these alternatives is !     going to be made when the denominator is calculated. ! 210 call altmov ( n , npt , xpt , xopt , bmat , zmat , ndim , sl , su , kopt , knew , adelt , & & xnew , xalt , alpha , cauchy , w , w ( np ), w ( ndim + 1 )) do i = 1 , n d ( i ) = xnew ( i ) - xopt ( i ) end do ! !     Calculate VLAG and BETA for the current choice of D. The scalar !     product of D with XPT(K,.) is going to be held in W(NPT+K) for !     use when VQUAD is calculated. ! 230 do k = 1 , npt suma = zero sumb = zero sum = zero do j = 1 , n suma = suma + xpt ( k , j ) * d ( j ) sumb = sumb + xpt ( k , j ) * xopt ( j ) sum = sum + bmat ( k , j ) * d ( j ) end do w ( k ) = suma * ( half * suma + sumb ) vlag ( k ) = sum w ( npt + k ) = suma end do beta = zero do jj = 1 , nptm sum = zero do k = 1 , npt sum = sum + zmat ( k , jj ) * w ( k ) end do beta = beta - sum * sum do k = 1 , npt vlag ( k ) = vlag ( k ) + sum * zmat ( k , jj ) end do end do dsq = zero bsum = zero dx = zero do j = 1 , n dsq = dsq + d ( j ) ** 2 sum = zero do k = 1 , npt sum = sum + w ( k ) * bmat ( k , j ) end do bsum = bsum + sum * d ( j ) jp = npt + j do i = 1 , n sum = sum + bmat ( jp , i ) * d ( i ) end do vlag ( jp ) = sum bsum = bsum + sum * d ( j ) dx = dx + d ( j ) * xopt ( j ) end do beta = dx * dx + dsq * ( xoptsq + dx + dx + half * dsq ) + beta - bsum vlag ( kopt ) = vlag ( kopt ) + one ! !     If NTRITS is zero, the denominator may be increased by replacing !     the step D of ALTMOV by a Cauchy step. Then RESCUE may be called if !     rounding errors have damaged the chosen denominator. ! if ( ntrits == 0 ) then denom = vlag ( knew ) ** 2 + alpha * beta if ( denom < cauchy . and . cauchy > zero ) then do i = 1 , n xnew ( i ) = xalt ( i ) d ( i ) = xnew ( i ) - xopt ( i ) end do cauchy = zero go to 230 end if if ( denom <= half * vlag ( knew ) ** 2 ) then if ( nf > nresc ) go to 190 if ( iprint > 0 ) write ( * , '(/5X,A)' ) & 'Return from BOBYQA because of much cancellation in a denominator.' go to 720 end if ! !     Alternatively, if NTRITS is positive, then set KNEW to the index of !     the next interpolation point to be deleted to make room for a trust !     region step. Again RESCUE may be called if rounding errors have damaged !     the chosen denominator, which is the reason for attempting to select !     KNEW before calculating the next value of the objective function. ! else delsq = delta * delta scaden = zero biglsq = zero knew = 0 do k = 1 , npt if ( k == kopt ) cycle hdiag = zero do jj = 1 , nptm hdiag = hdiag + zmat ( k , jj ) ** 2 end do den = beta * hdiag + vlag ( k ) ** 2 distsq = zero do j = 1 , n distsq = distsq + ( xpt ( k , j ) - xopt ( j )) ** 2 end do temp = max ( one , ( distsq / delsq ) ** 2 ) if ( temp * den > scaden ) then scaden = temp * den knew = k denom = den end if biglsq = max ( biglsq , temp * vlag ( k ) ** 2 ) end do if ( scaden <= half * biglsq ) then if ( nf > nresc ) go to 190 if ( iprint > 0 ) write ( * , '(/5X,A)' ) & 'Return from BOBYQA because of much cancellation in a denominator.' go to 720 end if end if ! !     Put the variables for the next calculation of the objective function !       in XNEW, with any adjustments for the bounds. ! ! !     Calculate the value of the objective function at XBASE+XNEW, unless !       the limit on the number of calculations of F has been reached. ! 360 do i = 1 , n x ( i ) = min ( max ( xl ( i ), xbase ( i ) + xnew ( i )), xu ( i )) if ( xnew ( i ) == sl ( i )) x ( i ) = xl ( i ) if ( xnew ( i ) == su ( i )) x ( i ) = xu ( i ) end do if ( nf >= maxfun ) then if ( iprint > 0 ) write ( * , '(/4X,A)' ) & 'Return from BOBYQA because CALFUN has been called MAXFUN times.' go to 720 end if nf = nf + 1 !======================================================================================= !============changed function call depending on how many call have been made============ !======================================================================================= if ( present ( verbose )) then call calfun ( ipar , initmeanval , expt1 , accum , mLPNH , mLPSH , & n , x ( 1 : n ), f , mask , prefactor , rgx , rgy , rgz , stepsize , verbose = verbose ) else call calfun ( ipar , initmeanval , expt1 , accum , mLPNH , mLPSH , & n , x ( 1 : n ), f , mask , prefactor , rgx , rgy , rgz , stepsize ) end if if ( iprint == 3 ) then print 400 , nf , f , ( x ( i ), i = 1 , n ) 400 format ( / 4 x , 'Function number' , i6 , '    F =' , 1 pd18 . 10 ,& '   The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if if ( ntrits ==- 1 ) then fsave = f go to 720 end if ! !     Use the quadratic model to predict the change in F due to the step D, !       and set DIFF to the error of this prediction. ! fopt = fval ( kopt ) vquad = zero ih = 0 do j = 1 , n vquad = vquad + d ( j ) * gopt ( j ) do i = 1 , j ih = ih + 1 temp = d ( i ) * d ( j ) if ( i == j ) temp = half * temp vquad = vquad + hq ( ih ) * temp end do end do do k = 1 , npt vquad = vquad + half * pq ( k ) * w ( npt + k ) ** 2 end do diff = f - fopt - vquad diffc = diffb diffb = diffa diffa = abs ( diff ) if ( dnorm > rho ) nfsav = nf ! !     Pick the next value of DELTA after a trust region step. ! if ( ntrits > 0 ) then if ( vquad >= zero ) then if ( iprint > 0 ) print 430 430 format ( / 4 x , 'Return from BOBYQA because a trust' ,& ' region step has failed to reduce Q.' ) go to 720 end if ratio = ( f - fopt ) / vquad if ( ratio <= tenth ) then delta = min ( half * delta , dnorm ) else if ( ratio <= 0.7_dbl ) then delta = max ( half * delta , dnorm ) else delta = max ( half * delta , dnorm + dnorm ) end if if ( delta <= 1.5_dbl * rho ) delta = rho ! !     Recalculate KNEW and DENOM if the new F is less than FOPT. ! if ( f < fopt ) then ksav = knew densav = denom delsq = delta * delta scaden = zero biglsq = zero knew = 0 do k = 1 , npt hdiag = zero do jj = 1 , nptm hdiag = hdiag + zmat ( k , jj ) ** 2 end do den = beta * hdiag + vlag ( k ) ** 2 distsq = zero do j = 1 , n distsq = distsq + ( xpt ( k , j ) - xnew ( j )) ** 2 end do temp = max ( one , ( distsq / delsq ) ** 2 ) if ( temp * den > scaden ) then scaden = temp * den knew = k denom = den end if biglsq = max ( biglsq , temp * vlag ( k ) ** 2 ) end do if ( scaden <= half * biglsq ) then knew = ksav denom = densav end if end if end if ! !     Update BMAT and ZMAT, so that the KNEW-th interpolation point can be !     moved. Also update the second derivative terms of the model. ! call update ( n , npt , bmat , zmat , ndim , vlag , beta , denom , knew , w ) ih = 0 pqold = pq ( knew ) pq ( knew ) = zero do i = 1 , n temp = pqold * xpt ( knew , i ) do j = 1 , i ih = ih + 1 hq ( ih ) = hq ( ih ) + temp * xpt ( knew , j ) end do end do do jj = 1 , nptm temp = diff * zmat ( knew , jj ) do k = 1 , npt pq ( k ) = pq ( k ) + temp * zmat ( k , jj ) end do end do ! !     Include the new interpolation point, and make the changes to GOPT at !     the old XOPT that are caused by the updating of the quadratic model. ! fval ( knew ) = f do i = 1 , n xpt ( knew , i ) = xnew ( i ) w ( i ) = bmat ( knew , i ) end do do k = 1 , npt suma = zero do jj = 1 , nptm suma = suma + zmat ( knew , jj ) * zmat ( k , jj ) end do sumb = zero do j = 1 , n sumb = sumb + xpt ( k , j ) * xopt ( j ) end do temp = suma * sumb do i = 1 , n w ( i ) = w ( i ) + temp * xpt ( k , i ) end do end do do i = 1 , n gopt ( i ) = gopt ( i ) + diff * w ( i ) end do ! !     Update XOPT, GOPT and KOPT if the new calculated F is less than FOPT. ! if ( f < fopt ) then kopt = knew xoptsq = zero ih = 0 do j = 1 , n xopt ( j ) = xnew ( j ) xoptsq = xoptsq + xopt ( j ) ** 2 do i = 1 , j ih = ih + 1 if ( i < j ) gopt ( j ) = gopt ( j ) + hq ( ih ) * d ( i ) gopt ( i ) = gopt ( i ) + hq ( ih ) * d ( j ) end do end do do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * d ( j ) end do temp = pq ( k ) * temp do i = 1 , n gopt ( i ) = gopt ( i ) + temp * xpt ( k , i ) end do end do end if ! !     Calculate the parameters of the least Frobenius norm interpolant to !     the current data, the gradient of this interpolant at XOPT being put !     into VLAG(NPT+I), I=1,2,...,N. ! if ( ntrits > 0 ) then do k = 1 , npt vlag ( k ) = fval ( k ) - fval ( kopt ) w ( k ) = zero end do do j = 1 , nptm sum = zero do k = 1 , npt sum = sum + zmat ( k , j ) * vlag ( k ) end do do k = 1 , npt w ( k ) = w ( k ) + sum * zmat ( k , j ) end do end do do k = 1 , npt sum = zero do j = 1 , n sum = sum + xpt ( k , j ) * xopt ( j ) end do w ( k + npt ) = w ( k ) w ( k ) = sum * w ( k ) end do gqsq = zero gisq = zero do i = 1 , n sum = zero do k = 1 , npt sum = sum + bmat ( k , i ) * vlag ( k ) + xpt ( k , i ) * w ( k ) end do if ( xopt ( i ) == sl ( i )) then gqsq = gqsq + min ( zero , gopt ( i )) ** 2 gisq = gisq + min ( zero , sum ) ** 2 else if ( xopt ( i ) == su ( i )) then gqsq = gqsq + max ( zero , gopt ( i )) ** 2 gisq = gisq + max ( zero , sum ) ** 2 else gqsq = gqsq + gopt ( i ) ** 2 gisq = gisq + sum * sum end if vlag ( npt + i ) = sum end do ! !     Test whether to replace the new quadratic model by the least Frobenius !     norm interpolant, making the replacement if the test is satisfied. ! itest = itest + 1 if ( gqsq < ten * gisq ) itest = 0 if ( itest >= 3 ) then do i = 1 , max ( npt , nh ) if ( i <= n ) gopt ( i ) = vlag ( npt + i ) if ( i <= npt ) pq ( i ) = w ( npt + i ) if ( i <= nh ) hq ( i ) = zero itest = 0 end do end if end if ! !     If a trust region step has provided a sufficient decrease in F, then !     branch for another trust region calculation. The case NTRITS=0 occurs !     when the new interpolation point was reached by an alternative step. ! if ( ntrits == 0 ) go to 60 if ( f <= fopt + tenth * vquad ) go to 60 ! !     Alternatively, find out if the interpolation points are close enough !       to the best point so far. ! distsq = max (( two * delta ) ** 2 , ( ten * rho ) ** 2 ) 650 knew = 0 do k = 1 , npt sum = zero do j = 1 , n sum = sum + ( xpt ( k , j ) - xopt ( j )) ** 2 end do if ( sum > distsq ) then knew = k distsq = sum end if end do ! !     If KNEW is positive, then ALTMOV finds alternative new positions for !     the KNEW-th interpolation point within distance ADELT of XOPT. It is !     reached via label 90. Otherwise, there is a branch to label 60 for !     another trust region iteration, unless the calculations with the !     current RHO are complete. ! if ( knew > 0 ) then dist = sqrt ( distsq ) if ( ntrits ==- 1 ) then delta = min ( tenth * delta , half * dist ) if ( delta <= 1.5_dbl * rho ) delta = rho end if ntrits = 0 adelt = max ( min ( tenth * dist , delta ), rho ) dsq = adelt * adelt go to 90 end if if ( ntrits ==- 1 ) go to 680 if ( ratio > zero ) go to 60 if ( max ( delta , dnorm ) > rho ) go to 60 ! !     The calculations with the current value of RHO are complete. Pick the !       next values of RHO and DELTA. ! 680 if ( rho > rhoend ) then delta = half * rho ratio = rho / rhoend if ( ratio <= 1 6.0_dbl ) then rho = rhoend else if ( ratio <= 25 0.0_dbl ) then rho = sqrt ( ratio ) * rhoend else rho = tenth * rho end if delta = max ( delta , rho ) if ( iprint >= 2 ) then if ( iprint >= 3 ) print 690 690 format ( 5 x ) print 700 , rho , nf 700 format ( / 4 x , 'New RHO =' , 1 pd11 . 4 , 5 x , 'Number of' ,& ' function values =' , i6 ) print 710 , fval ( kopt ), ( xbase ( i ) + xopt ( i ), i = 1 , n ) 710 format ( 4 x , 'Least value of F =' , 1 pd23 . 15 , 9 x ,& 'The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if ntrits = 0 nfsav = nf go to 60 end if ! !     Return from the calculation, after another Newton-Raphson step, if !       it is too short to have been tried before. ! if ( ntrits ==- 1 ) go to 360 720 if ( fval ( kopt ) <= fsave ) then do i = 1 , n x ( i ) = min ( max ( xl ( i ), xbase ( i ) + xopt ( i )), xu ( i )) if ( xopt ( i ) == sl ( i )) x ( i ) = xl ( i ) if ( xopt ( i ) == su ( i )) x ( i ) = xu ( i ) end do f = fval ( kopt ) end if if ( iprint >= 1 ) then print 740 , nf 740 format ( / 4 x , 'At the return from BOBYQA' , 5 x ,& 'Number of function values =' , i6 ) print 710 , f , ( x ( i ), i = 1 , n ) end if return end subroutine bobyqb","tags":"","loc":"proc/bobyqb~2.html","title":"bobyqb – Fortran Program"},{"text":"public recursive subroutine altmov(n, npt, xpt, xopt, bmat, zmat, ndim, sl, su, kopt, knew, adelt, xnew, xalt, alpha, cauchy, glag, hcol, w) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: xpt real :: xopt real :: bmat real :: zmat integer :: ndim real :: sl real :: su integer :: kopt integer :: knew real :: adelt real :: xnew real :: xalt real :: alpha real :: cauchy real :: glag real :: hcol real :: w Called By proc~~altmov~2~~CalledByGraph proc~altmov~2 altmov proc~bobyqb~2 bobyqb proc~bobyqb~2->proc~altmov~2 proc~bobyqa~2 bobyqa proc~bobyqa~2->proc~bobyqb~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code altmov Source Code recursive subroutine altmov ( n , npt , xpt , xopt , bmat , zmat , ndim , sl , su , kopt , knew , adelt , & & xnew , xalt , alpha , cauchy , glag , hcol , w ) !DEC$ ATTRIBUTES DLLEXPORT :: altmov implicit real ( dbl ) ( a - h , o - z ) dimension xpt ( npt , * ), xopt ( * ), bmat ( ndim , * ), zmat ( npt , * ), sl ( * ), su ( * ), & & xnew ( * ), xalt ( * ), glag ( * ), hcol ( * ), w ( * ) ! !     The arguments N, NPT, XPT, XOPT, BMAT, ZMAT, NDIM, SL and SU all have !       the same meanings as the corresponding arguments of BOBYQB. !     KOPT is the index of the optimal interpolation point. !     KNEW is the index of the interpolation point that is going to be moved. !     ADELT is the current trust region bound. !     XNEW will be set to a suitable new position for the interpolation point !       XPT(KNEW,.). Specifically, it satisfies the SL, SU and trust region !       bounds and it should provide a large denominator in the next call of !       UPDATE. The step XNEW-XOPT from XOPT is restricted to moves along the !       straight lines through XOPT and another interpolation point. !     XALT also provides a large value of the modulus of the KNEW-th Lagrange !       function subject to the constraints that have been mentioned, its main !       difference from XNEW being that XALT-XOPT is a constrained version of !       the Cauchy step within the trust region. An exception is that XALT is !       not calculated if all components of GLAG (see below) are zero. !     ALPHA will be set to the KNEW-th diagonal element of the H matrix. !     CAUCHY will be set to the square of the KNEW-th Lagrange function at !       the step XALT-XOPT from XOPT for the vector XALT that is returned, !       except that CAUCHY is set to zero if XALT is not calculated. !     GLAG is a working space vector of length N for the gradient of the !       KNEW-th Lagrange function at XOPT. !     HCOL is a working space vector of length NPT for the second derivative !       coefficients of the KNEW-th Lagrange function. !     W is a working space vector of length 2N that is going to hold the !       constrained Cauchy step from XOPT of the Lagrange function, followed !       by the downhill version of XALT when the uphill step is calculated. ! !     Set the first NPT components of W to the leading elements of the !     KNEW-th column of the H matrix. ! half = 0.5_dbl one = 1.0_dbl zero = 0.0_dbl const = one + sqrt ( 2.0_dbl ) do k = 1 , npt hcol ( k ) = zero end do do j = 1 , npt - n - 1 temp = zmat ( knew , j ) do k = 1 , npt hcol ( k ) = hcol ( k ) + temp * zmat ( k , j ) end do end do alpha = hcol ( knew ) ha = half * alpha ! !     Calculate the gradient of the KNEW-th Lagrange function at XOPT. ! do i = 1 , n glag ( i ) = bmat ( knew , i ) end do do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * xopt ( j ) end do temp = hcol ( k ) * temp do i = 1 , n glag ( i ) = glag ( i ) + temp * xpt ( k , i ) end do end do ! !     Search for a large denominator along the straight lines through XOPT !     and another interpolation point. SLBD and SUBD will be lower and upper !     bounds on the step along each of these lines in turn. PREDSQ will be !     set to the square of the predicted denominator for each line. PRESAV !     will be set to the largest admissible value of PREDSQ that occurs. ! presav = zero do k = 1 , npt if ( k == kopt ) cycle dderiv = zero distsq = zero do i = 1 , n temp = xpt ( k , i ) - xopt ( i ) dderiv = dderiv + glag ( i ) * temp distsq = distsq + temp * temp end do subd = adelt / sqrt ( distsq ) slbd = - subd ilbd = 0 iubd = 0 sumin = min ( one , subd ) ! !     Revise SLBD and SUBD if necessary because of the bounds in SL and SU. ! do i = 1 , n temp = xpt ( k , i ) - xopt ( i ) if ( temp > zero ) then if ( slbd * temp < sl ( i ) - xopt ( i )) then slbd = ( sl ( i ) - xopt ( i )) / temp ilbd = - i end if if ( subd * temp > su ( i ) - xopt ( i )) then subd = max ( sumin , ( su ( i ) - xopt ( i )) / temp ) iubd = i end if else if ( temp < zero ) then if ( slbd * temp > su ( i ) - xopt ( i )) then slbd = ( su ( i ) - xopt ( i )) / temp ilbd = i end if if ( subd * temp < sl ( i ) - xopt ( i )) then subd = max ( sumin , ( sl ( i ) - xopt ( i )) / temp ) iubd = - i end if end if end do ! !     Seek a large modulus of the KNEW-th Lagrange function when the index !     of the other interpolation point on the line through XOPT is KNEW. ! if ( k == knew ) then diff = dderiv - one step = slbd vlag = slbd * ( dderiv - slbd * diff ) isbd = ilbd temp = subd * ( dderiv - subd * diff ) if ( abs ( temp ) > abs ( vlag )) then step = subd vlag = temp isbd = iubd end if tempd = half * dderiv tempa = tempd - diff * slbd tempb = tempd - diff * subd if ( tempa * tempb < zero ) then temp = tempd * tempd / diff if ( abs ( temp ) > abs ( vlag )) then step = tempd / diff vlag = temp isbd = 0 end if end if ! !     Search along each of the other lines through XOPT and another point. ! else step = slbd vlag = slbd * ( one - slbd ) isbd = ilbd temp = subd * ( one - subd ) if ( abs ( temp ) > abs ( vlag )) then step = subd vlag = temp isbd = iubd end if if ( subd > half ) then if ( abs ( vlag ) < 0.25_dbl ) then step = half vlag = 0.25_dbl isbd = 0 end if end if vlag = vlag * dderiv end if ! !     Calculate PREDSQ for the current line search and maintain PRESAV. ! temp = step * ( one - step ) * distsq predsq = vlag * vlag * ( vlag * vlag + ha * temp * temp ) if ( predsq > presav ) then presav = predsq ksav = k stpsav = step ibdsav = isbd end if end do ! !     Construct XNEW in a way that satisfies the bound constraints exactly. ! do i = 1 , n temp = xopt ( i ) + stpsav * ( xpt ( ksav , i ) - xopt ( i )) xnew ( i ) = max ( sl ( i ), min ( su ( i ), temp )) end do if ( ibdsav < 0 ) xnew ( - ibdsav ) = sl ( - ibdsav ) if ( ibdsav > 0 ) xnew ( ibdsav ) = su ( ibdsav ) ! !     Prepare for the iterative method that assembles the constrained Cauchy !     step in W. The sum of squares of the fixed components of W is formed in !     WFIXSQ, and the free components of W are set to BIGSTP. ! bigstp = adelt + adelt iflag = 0 100 wfixsq = zero ggfree = zero do i = 1 , n w ( i ) = zero tempa = min ( xopt ( i ) - sl ( i ), glag ( i )) tempb = max ( xopt ( i ) - su ( i ), glag ( i )) if ( tempa > zero . or . tempb < zero ) then w ( i ) = bigstp ggfree = ggfree + glag ( i ) ** 2 end if end do if ( ggfree == zero ) then cauchy = zero return end if ! !     Investigate whether more components of W can be fixed. ! 120 temp = adelt * adelt - wfixsq if ( temp > zero ) then wsqsav = wfixsq step = sqrt ( temp / ggfree ) ggfree = zero do i = 1 , n if ( w ( i ) == bigstp ) then temp = xopt ( i ) - step * glag ( i ) if ( temp <= sl ( i )) then w ( i ) = sl ( i ) - xopt ( i ) wfixsq = wfixsq + w ( i ) ** 2 else if ( temp >= su ( i )) then w ( i ) = su ( i ) - xopt ( i ) wfixsq = wfixsq + w ( i ) ** 2 else ggfree = ggfree + glag ( i ) ** 2 end if end if end do if ( wfixsq > wsqsav . and . ggfree > zero ) go to 120 end if ! !     Set the remaining free components of W and all components of XALT, !     except that W may be scaled later. ! gw = zero do i = 1 , n if ( w ( i ) == bigstp ) then w ( i ) = - step * glag ( i ) xalt ( i ) = max ( sl ( i ), min ( su ( i ), xopt ( i ) + w ( i ))) else if ( w ( i ) == zero ) then xalt ( i ) = xopt ( i ) else if ( glag ( i ) > zero ) then xalt ( i ) = sl ( i ) else xalt ( i ) = su ( i ) end if gw = gw + glag ( i ) * w ( i ) end do ! !     Set CURV to the curvature of the KNEW-th Lagrange function along W. !     Scale W by a factor less than one if that can reduce the modulus of !     the Lagrange function at XOPT+W. Set CAUCHY to the final value of !     the square of this function. ! curv = zero do k = 1 , npt temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * w ( j ) end do curv = curv + hcol ( k ) * temp * temp end do if ( iflag == 1 ) curv = - curv if ( curv >- gw . and . curv <- const * gw ) then scale = - gw / curv do i = 1 , n temp = xopt ( i ) + scale * w ( i ) xalt ( i ) = max ( sl ( i ), min ( su ( i ), temp )) end do cauchy = ( half * gw * scale ) ** 2 else cauchy = ( gw + half * curv ) ** 2 end if ! !     If IFLAG is zero, then XALT is calculated as before after reversing !     the sign of GLAG. Thus two XALT vectors become available. The one that !     is chosen is the one that gives the larger value of CAUCHY. ! if ( iflag == 0 ) then do i = 1 , n glag ( i ) = - glag ( i ) w ( n + i ) = xalt ( i ) end do csave = cauchy iflag = 1 go to 100 end if if ( csave > cauchy ) then do i = 1 , n xalt ( i ) = w ( n + i ) end do cauchy = csave end if end subroutine altmov","tags":"","loc":"proc/altmov~2.html","title":"altmov – Fortran Program"},{"text":"public recursive subroutine prelim(ipar, initmeanval, expt1, n, npt, x, xl, xu, rhobeg, iprint, maxfun, xbase, xpt, fval, gopt, hq, pq, bmat, zmat, ndim, sl, su, nf, kopt, calfun, accum, mLPNH, mLPSH, mask, prefactor, rgx, rgy, rgz, stepsize, verbose) Arguments Type Intent Optional Attributes Name integer(kind=8), intent(in) :: ipar (9) real(kind=sgl), intent(in) :: initmeanval (3) real(kind=sgl), intent(in) :: expt1 (ipar(2)*ipar(3)/ipar(1)**2) integer :: n integer :: npt real :: x real :: xl real :: xu real :: rhobeg integer :: iprint integer :: maxfun real :: xbase real :: xpt real :: fval real :: gopt real :: hq real :: pq real :: bmat real :: zmat integer :: ndim real :: sl real :: su integer :: nf integer :: kopt procedure( func2 ) :: calfun real(kind=sgl), intent(in) :: accum (ipar(6),ipar(2),ipar(3)) real(kind=sgl), intent(in) :: mLPNH (-ipar(4):ipar(4),-ipar(5):ipar(5),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(4):ipar(4),-ipar(5):ipar(5),ipar(7)) real(kind=sgl), intent(in) :: mask (ipar(2)/ipar(1),ipar(3)/ipar(1)) real(kind=dbl) :: prefactor real(kind=sgl), intent(in) :: rgx (ipar(2),ipar(3)) real(kind=sgl), intent(in) :: rgy (ipar(2),ipar(3)) real(kind=sgl), intent(in) :: rgz (ipar(2),ipar(3)) real(kind=sgl), intent(in) :: stepsize (3) logical, intent(in), optional :: verbose Called By proc~~prelim~2~~CalledByGraph proc~prelim~2 prelim proc~bobyqb~2 bobyqb proc~bobyqb~2->proc~prelim~2 proc~bobyqa~2 bobyqa proc~bobyqa~2->proc~bobyqb~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code prelim Source Code recursive subroutine prelim ( ipar , initmeanval , expt1 , n , npt , x , xl , xu , rhobeg ,& iprint , maxfun , xbase , xpt , fval , gopt , hq , pq , bmat , zmat , ndim , sl , su , nf , kopt , calfun , accum , mLPNH , mLPSH ,& mask , prefactor , rgx , rgy , rgz , stepsize , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: prelim implicit real ( dbl ) ( a - h , o - z ) integer ( 8 ), intent ( in ) :: ipar ( 9 ) real ( sgl ), intent ( in ) :: initmeanval ( 3 ) real ( sgl ), intent ( in ) :: stepsize ( 3 ) real ( sgl ), intent ( in ) :: expt1 ( ipar ( 2 ) * ipar ( 3 ) / ipar ( 1 ) ** 2 ) real ( kind = sgl ), INTENT ( IN ) :: accum ( ipar ( 6 ), ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: mLPNH ( - ipar ( 4 ): ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), ipar ( 7 )) real ( kind = sgl ), INTENT ( IN ) :: mLPSH ( - ipar ( 4 ): ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), ipar ( 7 )) real ( kind = sgl ), INTENT ( IN ) :: rgx ( ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: rgy ( ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: rgz ( ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: mask ( ipar ( 2 ) / ipar ( 1 ), ipar ( 3 ) / ipar ( 1 )) real ( kind = dbl ) :: prefactor logical , intent ( in ), optional :: verbose dimension x ( * ), xl ( * ), xu ( * ), xbase ( * ), xpt ( npt , * ), fval ( * ), gopt ( * ), hq & & ( * ), pq ( * ), bmat ( ndim , * ), zmat ( npt , * ), sl ( * ), su ( * ) procedure ( func2 ) :: calfun ! !     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the !       same as the corresponding arguments in SUBROUTINE BOBYQA. !     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU !       are the same as the corresponding arguments in BOBYQB, the elements !       of SL and SU being set in BOBYQA. !     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but !       it is set by PRELIM to the gradient of the quadratic model at XBASE. !       If XOPT is nonzero, BOBYQB will change it to its usual value later. !     NF is maintaned as the number of calls of CALFUN so far. !     KOPT will be such that the least calculated value of F so far is at !       the point XPT(KOPT,.)+XBASE in the space of the variables. ! !     SUBROUTINE PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ, !     BMAT and ZMAT for the first iteration, and it maintains the values of !     NF and KOPT. The vector X is also changed by PRELIM. ! !     Set some constants. ! half = 0.5_dbl one = 1.0_dbl two = 2.0_dbl zero = 0.0_dbl rhosq = rhobeg * rhobeg recip = one / rhosq np = n + 1 ! !     Set XBASE to the initial vector of variables, and set the initial !     elements of XPT, BMAT, HQ, PQ and ZMAT to zero. ! do j = 1 , n xbase ( j ) = x ( j ) do k = 1 , npt xpt ( k , j ) = zero end do do i = 1 , ndim bmat ( i , j ) = zero end do end do do ih = 1 , ( n * np ) / 2 hq ( ih ) = zero end do do k = 1 , npt pq ( k ) = zero do j = 1 , npt - np zmat ( k , j ) = zero end do end do ! !     Begin the initialization procedure. NF becomes one more than the number !     of function values so far. The coordinates of the displacement of the !     next initial interpolation point from XBASE are set in XPT(NF+1,.). ! nf = 0 50 nfm = nf nfx = nf - n nf = nf + 1 if ( nfm <= 2 * n ) then if ( nfm >= 1 . and . nfm <= n ) then stepa = rhobeg if ( su ( nfm ) == zero ) stepa = - stepa xpt ( nf , nfm ) = stepa else if ( nfm > n ) then stepa = xpt ( nf - n , nfx ) stepb = - rhobeg if ( sl ( nfx ) == zero ) stepb = min ( two * rhobeg , su ( nfx )) if ( su ( nfx ) == zero ) stepb = max ( - two * rhobeg , sl ( nfx )) xpt ( nf , nfx ) = stepb end if else itemp = ( nfm - np ) / n jpt = nfm - itemp * n - n ipt = jpt + itemp if ( ipt > n ) then itemp = jpt jpt = ipt - n ipt = itemp end if xpt ( nf , ipt ) = xpt ( ipt + 1 , ipt ) xpt ( nf , jpt ) = xpt ( jpt + 1 , jpt ) end if ! !     Calculate the next value of F. The least function value so far and !     its index are required. ! do j = 1 , n x ( j ) = min ( max ( xl ( j ), xbase ( j ) + xpt ( nf , j )), xu ( j )) if ( xpt ( nf , j ) == sl ( j )) x ( j ) = xl ( j ) if ( xpt ( nf , j ) == su ( j )) x ( j ) = xu ( j ) end do !======================================================================================= !============changed function call depending on how many call have been made============ !======================================================================================= if ( present ( verbose )) then call calfun ( ipar , initmeanval , expt1 , accum , mLPNH , mLPSH , & n , x ( 1 : n ), f , mask , prefactor , rgx , rgy , rgz , stepsize , verbose = verbose ) else call calfun ( ipar , initmeanval , expt1 , accum , mLPNH , mLPSH , & n , x ( 1 : n ), f , mask , prefactor , rgx , rgy , rgz , stepsize ) end if if ( iprint == 3 ) then print 70 , nf , f , ( x ( i ), i = 1 , n ) 70 format ( / 4 x , 'Function number' , i6 , '    F =' , 1 pd18 . 10 ,& '    The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if fval ( nf ) = f if ( nf == 1 ) then fbeg = f kopt = 1 else if ( f < fval ( kopt )) then kopt = nf end if ! !     Set the nonzero initial elements of BMAT and the quadratic model in the !     cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions !     of the NF-th and (NF-N)-th interpolation points may be switched, in !     order that the function value at the first of them contributes to the !     off-diagonal second derivative terms of the initial quadratic model. ! if ( nf <= 2 * n + 1 ) then if ( nf >= 2 . and . nf <= n + 1 ) then gopt ( nfm ) = ( f - fbeg ) / stepa if ( npt < nf + n ) then bmat ( 1 , nfm ) = - one / stepa bmat ( nf , nfm ) = one / stepa bmat ( npt + nfm , nfm ) = - half * rhosq end if else if ( nf >= n + 2 ) then ih = ( nfx * ( nfx + 1 )) / 2 temp = ( f - fbeg ) / stepb diff = stepb - stepa hq ( ih ) = two * ( temp - gopt ( nfx )) / diff gopt ( nfx ) = ( gopt ( nfx ) * stepb - temp * stepa ) / diff if ( stepa * stepb < zero ) then if ( f < fval ( nf - n )) then fval ( nf ) = fval ( nf - n ) fval ( nf - n ) = f if ( kopt == nf ) kopt = nf - n xpt ( nf - n , nfx ) = stepb xpt ( nf , nfx ) = stepa end if end if bmat ( 1 , nfx ) = - ( stepa + stepb ) / ( stepa * stepb ) bmat ( nf , nfx ) = - half / xpt ( nf - n , nfx ) bmat ( nf - n , nfx ) = - bmat ( 1 , nfx ) - bmat ( nf , nfx ) zmat ( 1 , nfx ) = sqrt ( two ) / ( stepa * stepb ) zmat ( nf , nfx ) = sqrt ( half ) / rhosq zmat ( nf - n , nfx ) = - zmat ( 1 , nfx ) - zmat ( nf , nfx ) end if ! !     Set the off-diagonal second derivatives of the Lagrange functions and !     the initial quadratic model. ! else ih = ( ipt * ( ipt - 1 )) / 2 + jpt zmat ( 1 , nfx ) = recip zmat ( nf , nfx ) = recip zmat ( ipt + 1 , nfx ) = - recip zmat ( jpt + 1 , nfx ) = - recip temp = xpt ( nf , ipt ) * xpt ( nf , jpt ) hq ( ih ) = ( fbeg - fval ( ipt + 1 ) - fval ( jpt + 1 ) + f ) / temp end if if ( nf < npt . and . nf < maxfun ) go to 50 end subroutine prelim","tags":"","loc":"proc/prelim~2.html","title":"prelim – Fortran Program"},{"text":"public recursive subroutine rescue(ipar, initmeanval, expt1, n, npt, xl, xu, iprint, maxfun, xbase, xpt, fval, xopt, gopt, hq, pq, bmat, zmat, ndim, sl, su, nf, delta, kopt, vlag, ptsaux, ptsid, w, calfun, accum, mLPNH, mLPSH, mask, prefactor, rgx, rgy, rgz, stepsize, verbose) Arguments Type Intent Optional Attributes Name integer(kind=8), intent(in) :: ipar (9) real(kind=sgl), intent(in) :: initmeanval (3) real(kind=sgl), intent(in) :: expt1 (ipar(2)*ipar(3)/ipar(1)**2) integer :: n integer :: npt real :: xl real :: xu integer :: iprint integer :: maxfun real :: xbase real :: xpt real :: fval real :: xopt real :: gopt real :: hq real :: pq real :: bmat real :: zmat integer :: ndim real :: sl real :: su integer :: nf real :: delta integer :: kopt real :: vlag real :: ptsaux real :: ptsid real :: w procedure( func2 ) :: calfun real(kind=sgl), intent(in) :: accum (ipar(6),ipar(2),ipar(3)) real(kind=sgl), intent(in) :: mLPNH (-ipar(4):ipar(4),-ipar(5):ipar(5),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(4):ipar(4),-ipar(5):ipar(5),ipar(7)) real(kind=sgl), intent(in) :: mask (ipar(2)/ipar(1),ipar(3)/ipar(1)) real(kind=dbl) :: prefactor real(kind=sgl), intent(in) :: rgx (ipar(2),ipar(3)) real(kind=sgl), intent(in) :: rgy (ipar(2),ipar(3)) real(kind=sgl), intent(in) :: rgz (ipar(2),ipar(3)) real(kind=sgl), intent(in) :: stepsize (3) logical, intent(in), optional :: verbose Calls proc~~rescue~2~~CallsGraph proc~rescue~2 rescue proc~update~2 update proc~rescue~2->proc~update~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~rescue~2~~CalledByGraph proc~rescue~2 rescue proc~bobyqb~2 bobyqb proc~bobyqb~2->proc~rescue~2 proc~bobyqa~2 bobyqa proc~bobyqa~2->proc~bobyqb~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code rescue Source Code recursive subroutine rescue ( ipar , initmeanval , expt1 , n , npt , xl , xu , iprint ,& maxfun , xbase , xpt , fval , xopt , gopt , hq , pq , bmat , zmat , ndim , sl , su , nf , delta , kopt , vlag ,& ptsaux , ptsid , w , calfun , accum , mLPNH , mLPSH , mask , prefactor , rgx , rgy , rgz , stepsize , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: rescue implicit real ( dbl ) ( a - h , o - z ) integer ( 8 ), intent ( in ) :: ipar ( 9 ) real ( sgl ), intent ( in ) :: initmeanval ( 3 ) real ( sgl ), intent ( in ) :: stepsize ( 3 ) real ( sgl ), intent ( in ) :: expt1 ( ipar ( 2 ) * ipar ( 3 ) / ipar ( 1 ) ** 2 ) real ( kind = sgl ), INTENT ( IN ) :: accum ( ipar ( 6 ), ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: mLPNH ( - ipar ( 4 ): ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), ipar ( 7 )) real ( kind = sgl ), INTENT ( IN ) :: mLPSH ( - ipar ( 4 ): ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), ipar ( 7 )) real ( kind = sgl ), INTENT ( IN ) :: rgx ( ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: rgy ( ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: rgz ( ipar ( 2 ), ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: mask ( ipar ( 2 ) / ipar ( 1 ), ipar ( 3 ) / ipar ( 1 )) real ( kind = dbl ) :: prefactor logical , intent ( in ), optional :: verbose dimension xl ( * ), xu ( * ), xbase ( * ), xpt ( npt , * ), fval ( * ), xopt ( * ), gopt ( * ), & & hq ( * ), pq ( * ), bmat ( ndim , * ), zmat ( npt , * ), sl ( * ), su ( * ), vlag ( * ), ptsaux & & ( 2 , * ), ptsid ( * ), w ( * ) procedure ( func2 ) :: calfun ! !     The arguments N, NPT, XL, XU, IPRINT, MAXFUN, XBASE, XPT, FVAL, XOPT, !       GOPT, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU have the same meanings as !       the corresponding arguments of BOBYQB on the entry to RESCUE. !     NF is maintained as the number of calls of CALFUN so far, except that !       NF is set to -1 if the value of MAXFUN prevents further progress. !     KOPT is maintained so that FVAL(KOPT) is the least calculated function !       value. Its correct value must be given on entry. It is updated if a !       new least function value is found, but the corresponding changes to !       XOPT and GOPT have to be made later by the calling program. !     DELTA is the current trust region radius. !     VLAG is a working space vector that will be used for the values of the !       provisional Lagrange functions at each of the interpolation points. !       They are part of a product that requires VLAG to be of length NDIM. !     PTSAUX is also a working space array. For J=1,2,...,N, PTSAUX(1,J) and !       PTSAUX(2,J) specify the two positions of provisional interpolation !       points when a nonzero step is taken along e_J (the J-th coordinate !       direction) through XBASE+XOPT, as specified below. Usually these !       steps have length DELTA, but other lengths are chosen if necessary !       in order to satisfy the given bounds on the variables. !     PTSID is also a working space array. It has NPT components that denote !       provisional new positions of the original interpolation points, in !       case changes are needed to restore the linear independence of the !       interpolation conditions. The K-th point is a candidate for change !       if and only if PTSID(K) is nonzero. In this case let p and q be the !       integer parts of PTSID(K) and (PTSID(K)-p) multiplied by N+1. If p !       and q are both positive, the step from XBASE+XOPT to the new K-th !       interpolation point is PTSAUX(1,p)*e_p + PTSAUX(1,q)*e_q. Otherwise !       the step is PTSAUX(1,p)*e_p or PTSAUX(2,q)*e_q in the cases q=0 or !       p=0, respectively. !     The first NDIM+NPT elements of the array W are used for working space. !     The final elements of BMAT and ZMAT are set in a well-conditioned way !       to the values that are appropriate for the new interpolation points. !     The elements of GOPT, HQ and PQ are also revised to the values that are !       appropriate to the final quadratic model. ! !     Set some constants. ! half = 0.5_dbl one = 1.0_dbl zero = 0.0_dbl np = n + 1 sfrac = half / real ( np , dbl ) nptm = npt - np ! !     Shift the interpolation points so that XOPT becomes the origin, and set !     the elements of ZMAT to zero. The value of SUMPQ is required in the !     updating of HQ below. The squares of the distances from XOPT to the !     other interpolation points are set at the end of W. Increments of WINC !     may be added later to these squares to balance the consideration of !     the choice of point that is going to become current. ! sumpq = zero winc = zero do k = 1 , npt distsq = zero do j = 1 , n xpt ( k , j ) = xpt ( k , j ) - xopt ( j ) distsq = distsq + xpt ( k , j ) ** 2 end do sumpq = sumpq + pq ( k ) w ( ndim + k ) = distsq winc = max ( winc , distsq ) do j = 1 , nptm zmat ( k , j ) = zero end do end do ! !     Update HQ so that HQ and PQ define the second derivatives of the model !     after XBASE has been shifted to the trust region centre. ! ih = 0 do j = 1 , n w ( j ) = half * sumpq * xopt ( j ) do k = 1 , npt w ( j ) = w ( j ) + pq ( k ) * xpt ( k , j ) end do do i = 1 , j ih = ih + 1 hq ( ih ) = hq ( ih ) + w ( i ) * xopt ( j ) + w ( j ) * xopt ( i ) end do end do ! !     Shift XBASE, SL, SU and XOPT. Set the elements of BMAT to zero, and !     also set the elements of PTSAUX. ! do j = 1 , n xbase ( j ) = xbase ( j ) + xopt ( j ) sl ( j ) = sl ( j ) - xopt ( j ) su ( j ) = su ( j ) - xopt ( j ) xopt ( j ) = zero ptsaux ( 1 , j ) = min ( delta , su ( j )) ptsaux ( 2 , j ) = max ( - delta , sl ( j )) if ( ptsaux ( 1 , j ) + ptsaux ( 2 , j ) < zero ) then temp = ptsaux ( 1 , j ) ptsaux ( 1 , j ) = ptsaux ( 2 , j ) ptsaux ( 2 , j ) = temp end if if ( abs ( ptsaux ( 2 , j )) < half * abs ( ptsaux ( 1 , j ))) then ptsaux ( 2 , j ) = half * ptsaux ( 1 , j ) end if do i = 1 , ndim bmat ( i , j ) = zero end do end do fbase = fval ( kopt ) ! !     Set the identifiers of the artificial interpolation points that are !     along a coordinate direction from XOPT, and set the corresponding !     nonzero elements of BMAT and ZMAT. ! ptsid ( 1 ) = sfrac do j = 1 , n jp = j + 1 jpn = jp + n ptsid ( jp ) = real ( j , dbl ) + sfrac if ( jpn <= npt ) then ptsid ( jpn ) = real ( j , dbl ) / real ( np , dbl ) + sfrac temp = one / ( ptsaux ( 1 , j ) - ptsaux ( 2 , j )) bmat ( jp , j ) = - temp + one / ptsaux ( 1 , j ) bmat ( jpn , j ) = temp + one / ptsaux ( 2 , j ) bmat ( 1 , j ) = - bmat ( jp , j ) - bmat ( jpn , j ) zmat ( 1 , j ) = sqrt ( 2.0_dbl ) / abs ( ptsaux ( 1 , j ) * ptsaux ( 2 , j )) zmat ( jp , j ) = zmat ( 1 , j ) * ptsaux ( 2 , j ) * temp zmat ( jpn , j ) = - zmat ( 1 , j ) * ptsaux ( 1 , j ) * temp else bmat ( 1 , j ) = - one / ptsaux ( 1 , j ) bmat ( jp , j ) = one / ptsaux ( 1 , j ) bmat ( j + npt , j ) = - half * ptsaux ( 1 , j ) ** 2 end if end do ! !     Set any remaining identifiers with their nonzero elements of ZMAT. ! if ( npt >= n + np ) then do k = 2 * np , npt iw = ( real ( k - np , dbl ) - half ) / real ( n , dbl ) ip = k - np - iw * n iq = ip + iw if ( iq > n ) iq = iq - n ptsid ( k ) = real ( ip , dbl ) + real ( iq , dbl ) / real ( np , dbl ) + sfrac temp = one / ( ptsaux ( 1 , ip ) * ptsaux ( 1 , iq )) zmat ( 1 , k - np ) = temp zmat ( ip + 1 , k - np ) = - temp zmat ( iq + 1 , k - np ) = - temp zmat ( k , k - np ) = temp end do end if nrem = npt kold = 1 knew = kopt ! !     Reorder the provisional points in the way that exchanges PTSID(KOLD) !     with PTSID(KNEW). ! 80 do j = 1 , n temp = bmat ( kold , j ) bmat ( kold , j ) = bmat ( knew , j ) bmat ( knew , j ) = temp end do do j = 1 , nptm temp = zmat ( kold , j ) zmat ( kold , j ) = zmat ( knew , j ) zmat ( knew , j ) = temp end do ptsid ( kold ) = ptsid ( knew ) ptsid ( knew ) = zero w ( ndim + knew ) = zero nrem = nrem - 1 if ( knew /= kopt ) then temp = vlag ( kold ) vlag ( kold ) = vlag ( knew ) vlag ( knew ) = temp ! !     Update the BMAT and ZMAT matrices so that the status of the KNEW-th !     interpolation point can be changed from provisional to original. The !     subroutine returns if all the original points are reinstated. !     The nonnegative values of W(NDIM+K) are required in the search below. ! call update ( n , npt , bmat , zmat , ndim , vlag , beta , denom , knew , w ) if ( nrem == 0 ) return do k = 1 , npt w ( ndim + k ) = abs ( w ( ndim + k )) end do end if ! !     Pick the index KNEW of an original interpolation point that has not !     yet replaced one of the provisional interpolation points, giving !     attention to the closeness to XOPT and to previous tries with KNEW. ! 120 dsqmin = zero do k = 1 , npt if ( w ( ndim + k ) > zero ) then if ( dsqmin == zero . or . w ( ndim + k ) < dsqmin ) then knew = k dsqmin = w ( ndim + k ) end if end if end do if ( dsqmin == zero ) go to 260 ! !     Form the W-vector of the chosen original interpolation point. ! do j = 1 , n w ( npt + j ) = xpt ( knew , j ) end do do k = 1 , npt sum = zero if ( k == kopt ) then continue else if ( ptsid ( k ) == zero ) then do j = 1 , n sum = sum + w ( npt + j ) * xpt ( k , j ) end do else ip = ptsid ( k ) if ( ip > 0 ) sum = w ( npt + ip ) * ptsaux ( 1 , ip ) iq = real ( np , dbl ) * ptsid ( k ) - real ( ip * np , dbl ) if ( iq > 0 ) then iw = 1 if ( ip == 0 ) iw = 2 sum = sum + w ( npt + iq ) * ptsaux ( iw , iq ) end if end if w ( k ) = half * sum * sum end do ! !     Calculate VLAG and BETA for the required updating of the H matrix if !     XPT(KNEW,.) is reinstated in the set of interpolation points. ! do k = 1 , npt sum = zero do j = 1 , n sum = sum + bmat ( k , j ) * w ( npt + j ) end do vlag ( k ) = sum end do beta = zero do j = 1 , nptm sum = zero do k = 1 , npt sum = sum + zmat ( k , j ) * w ( k ) end do beta = beta - sum * sum do k = 1 , npt vlag ( k ) = vlag ( k ) + sum * zmat ( k , j ) end do end do bsum = zero distsq = zero do j = 1 , n sum = zero do k = 1 , npt sum = sum + bmat ( k , j ) * w ( k ) end do jp = j + npt bsum = bsum + sum * w ( jp ) do ip = npt + 1 , ndim sum = sum + bmat ( ip , j ) * w ( ip ) end do bsum = bsum + sum * w ( jp ) vlag ( jp ) = sum distsq = distsq + xpt ( knew , j ) ** 2 end do beta = half * distsq * distsq + beta - bsum vlag ( kopt ) = vlag ( kopt ) + one ! !     KOLD is set to the index of the provisional interpolation point that is !     going to be deleted to make way for the KNEW-th original interpolation !     point. The choice of KOLD is governed by the avoidance of a small value !     of the denominator in the updating calculation of UPDATE. ! denom = zero vlmxsq = zero do k = 1 , npt if ( ptsid ( k ) /= zero ) then hdiag = zero do j = 1 , nptm hdiag = hdiag + zmat ( k , j ) ** 2 end do den = beta * hdiag + vlag ( k ) ** 2 if ( den > denom ) then kold = k denom = den end if end if vlmxsq = max ( vlmxsq , vlag ( k ) ** 2 ) end do if ( denom <= 1.0e-2_dbl * vlmxsq ) then w ( ndim + knew ) = - w ( ndim + knew ) - winc go to 120 end if go to 80 ! !     When label 260 is reached, all the final positions of the interpolation !     points have been chosen although any changes have not been included yet !     in XPT. Also the final BMAT and ZMAT matrices are complete, but, apart !     from the shift of XBASE, the updating of the quadratic model remains to !     be done. The following cycle through the new interpolation points begins !     by putting the new point in XPT(KPT,.) and by setting PQ(KPT) to zero, !     except that a RETURN occurs if MAXFUN prohibits another value of F. ! 260 do kpt = 1 , npt if ( ptsid ( kpt ) == zero ) cycle if ( nf >= maxfun ) then nf = - 1 return end if ih = 0 do j = 1 , n w ( j ) = xpt ( kpt , j ) xpt ( kpt , j ) = zero temp = pq ( kpt ) * w ( j ) do i = 1 , j ih = ih + 1 hq ( ih ) = hq ( ih ) + temp * w ( i ) end do end do pq ( kpt ) = zero ip = ptsid ( kpt ) iq = real ( np , dbl ) * ptsid ( kpt ) - real ( ip * np , dbl ) if ( ip > 0 ) then xp = ptsaux ( 1 , ip ) xpt ( kpt , ip ) = xp end if if ( iq > 0 ) then xq = ptsaux ( 1 , iq ) if ( ip == 0 ) xq = ptsaux ( 2 , iq ) xpt ( kpt , iq ) = xq end if ! !     Set VQUAD to the value of the current model at the new point. ! vquad = fbase if ( ip > 0 ) then ihp = ( ip + ip * ip ) / 2 vquad = vquad + xp * ( gopt ( ip ) + half * xp * hq ( ihp )) end if if ( iq > 0 ) then ihq = ( iq + iq * iq ) / 2 vquad = vquad + xq * ( gopt ( iq ) + half * xq * hq ( ihq )) if ( ip > 0 ) then iw = max ( ihp , ihq ) - abs ( ip - iq ) vquad = vquad + xp * xq * hq ( iw ) end if end if do k = 1 , npt temp = zero if ( ip > 0 ) temp = temp + xp * xpt ( k , ip ) if ( iq > 0 ) temp = temp + xq * xpt ( k , iq ) vquad = vquad + half * pq ( k ) * temp * temp end do ! !     Calculate F at the new interpolation point, and set DIFF to the factor !     that is going to multiply the KPT-th Lagrange function when the model !     is updated to provide interpolation to the new function value. ! do i = 1 , n w ( i ) = min ( max ( xl ( i ), xbase ( i ) + xpt ( kpt , i )), xu ( i )) if ( xpt ( kpt , i ) == sl ( i )) w ( i ) = xl ( i ) if ( xpt ( kpt , i ) == su ( i )) w ( i ) = xu ( i ) end do nf = nf + 1 !======================================================================================= !============changed function call depending on how many call have been made============ !======================================================================================= if ( present ( verbose )) then call calfun ( ipar , initmeanval , expt1 , accum , mLPNH , mLPSH , & n , w ( 1 : n ), f , mask , prefactor , rgx , rgy , rgz , stepsize , verbose = verbose ) else call calfun ( ipar , initmeanval , expt1 , accum , mLPNH , mLPSH , & n , w ( 1 : n ), f , mask , prefactor , rgx , rgy , rgz , stepsize ) end if if ( iprint == 3 ) then print 300 , nf , f , ( w ( i ), i = 1 , n ) 300 format ( / 4 x , 'Function number' , i6 , '    F =' , 1 pd18 . 10 ,& '    The corresponding X is:' / ( 2 x , 5 d15 . 6 )) end if fval ( kpt ) = f if ( f < fval ( kopt )) kopt = kpt diff = f - vquad ! !     Update the quadratic model. The RETURN from the subroutine occurs when !     all the new interpolation points are included in the model. ! do i = 1 , n gopt ( i ) = gopt ( i ) + diff * bmat ( kpt , i ) end do do k = 1 , npt sum = zero do j = 1 , nptm sum = sum + zmat ( k , j ) * zmat ( kpt , j ) end do temp = diff * sum if ( ptsid ( k ) == zero ) then pq ( k ) = pq ( k ) + temp else ip = ptsid ( k ) iq = real ( np , dbl ) * ptsid ( k ) - real ( ip * np , dbl ) ihq = ( iq * iq + iq ) / 2 if ( ip == 0 ) then hq ( ihq ) = hq ( ihq ) + temp * ptsaux ( 2 , iq ) ** 2 else ihp = ( ip * ip + ip ) / 2 hq ( ihp ) = hq ( ihp ) + temp * ptsaux ( 1 , ip ) ** 2 if ( iq > 0 ) then hq ( ihq ) = hq ( ihq ) + temp * ptsaux ( 1 , iq ) ** 2 iw = max ( ihp , ihq ) - abs ( iq - ip ) hq ( iw ) = hq ( iw ) + temp * ptsaux ( 1 , ip ) * ptsaux ( 1 , iq ) end if end if end if end do ptsid ( kpt ) = zero end do end subroutine rescue","tags":"","loc":"proc/rescue~2.html","title":"rescue – Fortran Program"},{"text":"public recursive subroutine trsbox(n, npt, xpt, xopt, gopt, hq, pq, sl, su, delta, xnew, d, gnew, xbdi, s, hs, hred, dsq, crvmin) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: xpt real :: xopt real :: gopt real :: hq real :: pq real :: sl real :: su real :: delta real :: xnew real :: d real :: gnew real :: xbdi real :: s real :: hs real :: hred real :: dsq real :: crvmin Called By proc~~trsbox~2~~CalledByGraph proc~trsbox~2 trsbox proc~bobyqb~2 bobyqb proc~bobyqb~2->proc~trsbox~2 proc~bobyqa~2 bobyqa proc~bobyqa~2->proc~bobyqb~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code trsbox Source Code recursive subroutine trsbox ( n , npt , xpt , xopt , gopt , hq , pq , sl , su , delta , xnew , d , gnew , & & xbdi , s , hs , hred , dsq , crvmin ) !DEC$ ATTRIBUTES DLLEXPORT :: trsbox implicit real ( dbl ) ( a - h , o - z ) dimension xpt ( npt , * ), xopt ( * ), gopt ( * ), hq ( * ), pq ( * ), sl ( * ), su ( * ), xnew & & ( * ), d ( * ), gnew ( * ), xbdi ( * ), s ( * ), hs ( * ), hred ( * ) ! !     The arguments N, NPT, XPT, XOPT, GOPT, HQ, PQ, SL and SU have the same !       meanings as the corresponding arguments of BOBYQB. !     DELTA is the trust region radius for the present calculation, which !       seeks a small value of the quadratic model within distance DELTA of !       XOPT subject to the bounds on the variables. !     XNEW will be set to a new vector of variables that is approximately !       the one that minimizes the quadratic model within the trust region !       subject to the SL and SU constraints on the variables. It satisfies !       as equations the bounds that become active during the calculation. !     D is the calculated trial step from XOPT, generated iteratively from an !       initial value of zero. Thus XNEW is XOPT+D after the final iteration. !     GNEW holds the gradient of the quadratic model at XOPT+D. It is updated !       when D is updated. !     XBDI is a working space vector. For I=1,2,...,N, the element XBDI(I) is !       set to -1.0, 0.0, or 1.0, the value being nonzero if and only if the !       I-th variable has become fixed at a bound, the bound being SL(I) or !       SU(I) in the case XBDI(I)=-1.0 or XBDI(I)=1.0, respectively. This !       information is accumulated during the construction of XNEW. !     The arrays S, HS and HRED are also used for working space. They hold the !       current search direction, and the changes in the gradient of Q along S !       and the reduced D, respectively, where the reduced D is the same as D, !       except that the components of the fixed variables are zero. !     DSQ will be set to the square of the length of XNEW-XOPT. !     CRVMIN is set to zero if D reaches the trust region boundary. Otherwise !       it is set to the least curvature of H that occurs in the conjugate !       gradient searches that are not restricted by any constraints. The !       value CRVMIN=-1.0D0 is set, however, if all of these searches are !       constrained. ! !     A version of the truncated conjugate gradient is applied. If a line !     search is restricted by a constraint, then the procedure is restarted, !     the values of the variables that are at their bounds being fixed. If !     the trust region boundary is reached, then further changes may be made !     to D, each one being in the two dimensional space that is spanned !     by the current D and the gradient of Q at XOPT+D, staying on the trust !     region boundary. Termination occurs when the reduction in Q seems to !     be close to the greatest reduction that can be achieved. ! !     Set some constants. ! half = 0.5_dbl one = 1.0_dbl onemin = - 1.0_dbl zero = 0.0_dbl ! !     The sign of GOPT(I) gives the sign of the change to the I-th variable !     that will reduce Q from its value at XOPT. Thus XBDI(I) shows whether !     or not to fix the I-th variable at one of its bounds initially, with !     NACT being set to the number of fixed variables. D and GNEW are also !     set for the first iteration. DELSQ is the upper bound on the sum of !     squares of the free variables. QRED is the reduction in Q so far. ! iterc = 0 nact = 0 sqstp = zero do i = 1 , n xbdi ( i ) = zero if ( xopt ( i ) <= sl ( i )) then if ( gopt ( i ) >= zero ) xbdi ( i ) = onemin else if ( xopt ( i ) >= su ( i )) then if ( gopt ( i ) <= zero ) xbdi ( i ) = one end if if ( xbdi ( i ) /= zero ) nact = nact + 1 d ( i ) = zero gnew ( i ) = gopt ( i ) end do delsq = delta * delta qred = zero crvmin = onemin ! !     Set the next search direction of the conjugate gradient method. It is !     the steepest descent direction initially and when the iterations are !     restarted because a variable has just been fixed by a bound, and of !     course the components of the fixed variables are zero. ITERMAX is an !     upper bound on the indices of the conjugate gradient iterations. ! 20 beta = zero 30 stepsq = zero do i = 1 , n if ( xbdi ( i ) /= zero ) then s ( i ) = zero else if ( beta == zero ) then s ( i ) = - gnew ( i ) else s ( i ) = beta * s ( i ) - gnew ( i ) end if stepsq = stepsq + s ( i ) ** 2 end do if ( stepsq == zero ) go to 190 if ( beta == zero ) then gredsq = stepsq itermax = iterc + n - nact end if if ( gredsq * delsq <= 1.0e-4_dbl * qred * qred ) go to 190 ! !     Multiply the search direction by the second derivative matrix of Q and !     calculate some scalars for the choice of steplength. Then set BLEN to !     the length of the the step to the trust region boundary and STPLEN to !     the steplength, ignoring the simple bounds. ! go to 210 50 resid = delsq ds = zero shs = zero do i = 1 , n if ( xbdi ( i ) == zero ) then resid = resid - d ( i ) ** 2 ds = ds + s ( i ) * d ( i ) shs = shs + s ( i ) * hs ( i ) end if end do if ( resid <= zero ) go to 90 temp = sqrt ( stepsq * resid + ds * ds ) if ( ds < zero ) then blen = ( temp - ds ) / stepsq else blen = resid / ( temp + ds ) end if stplen = blen if ( shs > zero ) then stplen = min ( blen , gredsq / shs ) end if ! ! !     Reduce STPLEN if necessary in order to preserve the simple bounds, !     letting IACT be the index of the new constrained variable. ! iact = 0 do i = 1 , n if ( s ( i ) /= zero ) then xsum = xopt ( i ) + d ( i ) if ( s ( i ) > zero ) then temp = ( su ( i ) - xsum ) / s ( i ) else temp = ( sl ( i ) - xsum ) / s ( i ) end if if ( temp < stplen ) then stplen = temp iact = i end if end if end do ! !     Update CRVMIN, GNEW and D. Set SDEC to the decrease that occurs in Q. ! sdec = zero if ( stplen > zero ) then iterc = iterc + 1 temp = shs / stepsq if ( iact == 0 . and . temp > zero ) then crvmin = min ( crvmin , temp ) if ( crvmin == onemin ) crvmin = temp end if ggsav = gredsq gredsq = zero do i = 1 , n gnew ( i ) = gnew ( i ) + stplen * hs ( i ) if ( xbdi ( i ) == zero ) gredsq = gredsq + gnew ( i ) ** 2 d ( i ) = d ( i ) + stplen * s ( i ) end do sdec = max ( stplen * ( ggsav - half * stplen * shs ), zero ) qred = qred + sdec end if ! !     Restart the conjugate gradient method if it has hit a new bound. ! if ( iact > 0 ) then nact = nact + 1 xbdi ( iact ) = one if ( s ( iact ) < zero ) xbdi ( iact ) = onemin delsq = delsq - d ( iact ) ** 2 if ( delsq <= zero ) go to 90 go to 20 end if ! !     If STPLEN is less than BLEN, then either apply another conjugate !     gradient iteration or RETURN. ! if ( stplen < blen ) then if ( iterc == itermax ) go to 190 if ( sdec <= 0.01_dbl * qred ) go to 190 beta = gredsq / ggsav go to 30 end if 90 crvmin = zero ! !     Prepare for the alternative iteration by calculating some scalars and !     by multiplying the reduced D by the second derivative matrix of Q. ! 100 if ( nact >= n - 1 ) go to 190 dredsq = zero dredg = zero gredsq = zero do i = 1 , n if ( xbdi ( i ) == zero ) then dredsq = dredsq + d ( i ) ** 2 dredg = dredg + d ( i ) * gnew ( i ) gredsq = gredsq + gnew ( i ) ** 2 s ( i ) = d ( i ) else s ( i ) = zero end if end do itcsav = iterc go to 210 ! !     Let the search direction S be a linear combination of the reduced D !     and the reduced G that is orthogonal to the reduced D. ! 120 iterc = iterc + 1 temp = gredsq * dredsq - dredg * dredg if ( temp <= 1.0e-4_dbl * qred * qred ) go to 190 temp = sqrt ( temp ) do i = 1 , n if ( xbdi ( i ) == zero ) then s ( i ) = ( dredg * d ( i ) - dredsq * gnew ( i )) / temp else s ( i ) = zero end if end do sredg = - temp ! !     By considering the simple bounds on the variables, calculate an upper !     bound on the tangent of half the angle of the alternative iteration, !     namely ANGBD, except that, if already a free variable has reached a !     bound, there is a branch back to label 100 after fixing that variable. ! angbd = one iact = 0 do i = 1 , n if ( xbdi ( i ) == zero ) then tempa = xopt ( i ) + d ( i ) - sl ( i ) tempb = su ( i ) - xopt ( i ) - d ( i ) if ( tempa <= zero ) then nact = nact + 1 xbdi ( i ) = onemin go to 100 else if ( tempb <= zero ) then nact = nact + 1 xbdi ( i ) = one go to 100 end if ratio = one ssq = d ( i ) ** 2 + s ( i ) ** 2 temp = ssq - ( xopt ( i ) - sl ( i )) ** 2 if ( temp > zero ) then temp = sqrt ( temp ) - s ( i ) if ( angbd * temp > tempa ) then angbd = tempa / temp iact = i xsav = onemin end if end if temp = ssq - ( su ( i ) - xopt ( i )) ** 2 if ( temp > zero ) then temp = sqrt ( temp ) + s ( i ) if ( angbd * temp > tempb ) then angbd = tempb / temp iact = i xsav = one end if end if end if end do ! !     Calculate HHD and some curvatures for the alternative iteration. ! go to 210 150 shs = zero dhs = zero dhd = zero do i = 1 , n if ( xbdi ( i ) == zero ) then shs = shs + s ( i ) * hs ( i ) dhs = dhs + d ( i ) * hs ( i ) dhd = dhd + d ( i ) * hred ( i ) end if end do ! !     Seek the greatest reduction in Q for a range of equally spaced values !     of ANGT in [0,ANGBD], where ANGT is the tangent of half the angle of !     the alternative iteration. ! redmax = zero isav = 0 redsav = zero iu = 1 7.0_dbl * angbd + 3.1_dbl do i = 1 , iu angt = angbd * real ( i , dbl ) / real ( iu , dbl ) sth = ( angt + angt ) / ( one + angt * angt ) temp = shs + angt * ( angt * dhd - dhs - dhs ) rednew = sth * ( angt * dredg - sredg - half * sth * temp ) if ( rednew > redmax ) then redmax = rednew isav = i rdprev = redsav else if ( i == isav + 1 ) then rdnext = rednew end if redsav = rednew end do ! !     Return if the reduction is zero. Otherwise, set the sine and cosine !     of the angle of the alternative iteration, and calculate SDEC. ! if ( isav == 0 ) go to 190 if ( isav < iu ) then temp = ( rdnext - rdprev ) / ( redmax + redmax - rdprev - rdnext ) angt = angbd * ( real ( isav , dbl ) + half * temp ) / real ( iu , dbl ) end if cth = ( one - angt * angt ) / ( one + angt * angt ) sth = ( angt + angt ) / ( one + angt * angt ) temp = shs + angt * ( angt * dhd - dhs - dhs ) sdec = sth * ( angt * dredg - sredg - half * sth * temp ) if ( sdec <= zero ) go to 190 ! !     Update GNEW, D and HRED. If the angle of the alternative iteration !     is restricted by a bound on a free variable, that variable is fixed !     at the bound. ! dredg = zero gredsq = zero do i = 1 , n gnew ( i ) = gnew ( i ) + ( cth - one ) * hred ( i ) + sth * hs ( i ) if ( xbdi ( i ) == zero ) then d ( i ) = cth * d ( i ) + sth * s ( i ) dredg = dredg + d ( i ) * gnew ( i ) gredsq = gredsq + gnew ( i ) ** 2 end if hred ( i ) = cth * hred ( i ) + sth * hs ( i ) end do qred = qred + sdec if ( iact > 0 . and . isav == iu ) then nact = nact + 1 xbdi ( iact ) = xsav go to 100 end if ! !     If SDEC is sufficiently small, then RETURN after setting XNEW to !     XOPT+D, giving careful attention to the bounds. ! if ( sdec > 0.01_dbl * qred ) go to 120 190 dsq = zero do i = 1 , n xnew ( i ) = max ( min ( xopt ( i ) + d ( i ), su ( i )), sl ( i )) if ( xbdi ( i ) == onemin ) xnew ( i ) = sl ( i ) if ( xbdi ( i ) == one ) xnew ( i ) = su ( i ) d ( i ) = xnew ( i ) - xopt ( i ) dsq = dsq + d ( i ) ** 2 end do return ! !     The following instructions multiply the current S-vector by the second !     derivative matrix of the quadratic model, putting the product in HS. !     They are reached from three different parts of the software above and !     they can be regarded as an external subroutine. ! 210 ih = 0 do j = 1 , n hs ( j ) = zero do i = 1 , j ih = ih + 1 if ( i < j ) hs ( j ) = hs ( j ) + hq ( ih ) * s ( i ) hs ( i ) = hs ( i ) + hq ( ih ) * s ( j ) end do end do do k = 1 , npt if ( pq ( k ) /= zero ) then temp = zero do j = 1 , n temp = temp + xpt ( k , j ) * s ( j ) end do temp = temp * pq ( k ) do i = 1 , n hs ( i ) = hs ( i ) + temp * xpt ( k , i ) end do end if end do if ( crvmin /= zero ) go to 50 if ( iterc > itcsav ) go to 150 do i = 1 , n hred ( i ) = hs ( i ) end do go to 120 end subroutine trsbox","tags":"","loc":"proc/trsbox~2.html","title":"trsbox – Fortran Program"},{"text":"public recursive subroutine update(n, npt, bmat, zmat, ndim, vlag, beta, denom, knew, w) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: bmat real :: zmat integer :: ndim real :: vlag real :: beta real :: denom integer :: knew real :: w Called By proc~~update~2~~CalledByGraph proc~update~2 update proc~bobyqb~2 bobyqb proc~bobyqb~2->proc~update~2 proc~rescue~2 rescue proc~bobyqb~2->proc~rescue~2 proc~rescue~2->proc~update~2 proc~bobyqa~2 bobyqa proc~bobyqa~2->proc~bobyqb~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code update Source Code recursive subroutine update ( n , npt , bmat , zmat , ndim , vlag , beta , denom , knew , w ) !DEC$ ATTRIBUTES DLLEXPORT :: update implicit real ( dbl ) ( a - h , o - z ) dimension bmat ( ndim , * ), zmat ( npt , * ), vlag ( * ), w ( * ) ! !     The arrays BMAT and ZMAT are updated, as required by the new position !     of the interpolation point that has the index KNEW. The vector VLAG has !     N+NPT components, set on entry to the first NPT and last N components !     of the product Hw in equation (4.11) of the Powell (2006) paper on !     NEWUOA. Further, BETA is set on entry to the value of the parameter !     with that name, and DENOM is set to the denominator of the updating !     formula. Elements of ZMAT may be treated as zero if their moduli are !     at most ZTEST. The first NDIM elements of W are used for working space. ! !     Set some constants. ! one = 1.0_dbl zero = 0.0_dbl nptm = npt - n - 1 ztest = zero do k = 1 , npt do j = 1 , nptm ztest = max ( ztest , abs ( zmat ( k , j ))) end do end do ztest = 1.0e-20_dbl * ztest ! !     Apply the rotations that put zeros in the KNEW-th row of ZMAT. ! jl = 1 do j = 2 , nptm if ( abs ( zmat ( knew , j )) > ztest ) then temp = sqrt ( zmat ( knew , 1 ) ** 2 + zmat ( knew , j ) ** 2 ) tempa = zmat ( knew , 1 ) / temp tempb = zmat ( knew , j ) / temp do i = 1 , npt temp = tempa * zmat ( i , 1 ) + tempb * zmat ( i , j ) zmat ( i , j ) = tempa * zmat ( i , j ) - tempb * zmat ( i , 1 ) zmat ( i , 1 ) = temp end do end if zmat ( knew , j ) = zero end do ! !     Put the first NPT components of the KNEW-th column of HLAG into W, !     and calculate the parameters of the updating formula. ! do i = 1 , npt w ( i ) = zmat ( knew , 1 ) * zmat ( i , 1 ) end do alpha = w ( knew ) tau = vlag ( knew ) vlag ( knew ) = vlag ( knew ) - one ! !     Complete the updating of ZMAT. ! temp = sqrt ( denom ) tempb = zmat ( knew , 1 ) / temp tempa = tau / temp do i = 1 , npt zmat ( i , 1 ) = tempa * zmat ( i , 1 ) - tempb * vlag ( i ) end do ! !     Finally, update the matrix BMAT. ! do j = 1 , n jp = npt + j w ( jp ) = bmat ( knew , j ) tempa = ( alpha * vlag ( jp ) - tau * w ( jp )) / denom tempb = ( - beta * w ( jp ) - tau * vlag ( jp )) / denom do i = 1 , jp bmat ( i , j ) = bmat ( i , j ) + tempa * vlag ( i ) + tempb * w ( i ) if ( i > npt ) bmat ( jp , i - npt ) = bmat ( i , j ) end do end do end subroutine update","tags":"","loc":"proc/update~2.html","title":"update – Fortran Program"},{"text":"public recursive subroutine CLquery_platform_info(platform_id) Uses: iso_c_binding proc~~clquery_platform_info~~UsesGraph proc~clquery_platform_info CLquery_platform_info iso_c_binding iso_c_binding iso_c_binding->proc~clquery_platform_info Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief display information about an OpenCL device (based on (clfortran's query_platforms_devices.f90)\n @param platform_id id number of platform\n @date 02/18/16 MDG 1.0 modification of clfortran's original routine\n @date 05/21/16 MDG 1.1 split CPU and GPU device information into separate blocks Arguments Type Intent Optional Attributes Name integer(kind=c_intptr_t), intent(in) :: platform_id Calls proc~~clquery_platform_info~~CallsGraph proc~clquery_platform_info CLquery_platform_info clgetplatforminfo clgetplatforminfo proc~clquery_platform_info->clgetplatforminfo clgetdeviceinfo clgetdeviceinfo proc~clquery_platform_info->clgetdeviceinfo proc~clerror_check CLerror_check proc~clquery_platform_info->proc~clerror_check clgetdeviceids clgetdeviceids proc~clquery_platform_info->clgetdeviceids writevalue writevalue proc~clerror_check->writevalue fatalerror fatalerror proc~clerror_check->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code CLquery_platform_info Source Code recursive subroutine CLquery_platform_info ( platform_id ) !DEC$ ATTRIBUTES DLLEXPORT :: CLquery_platform_info use ISO_C_BINDING IMPLICIT NONE ! Input variable. integer ( c_intptr_t ), INTENT ( IN ) :: platform_id ! Helper variables to work with OpenCL API. integer ( c_int32_t ) :: err integer ( c_size_t ) :: zero_size = 0 integer ( c_size_t ) :: temp_size ! For quering devices. integer ( c_int64_t ) :: device_type integer ( c_int32_t ) :: num_devices integer ( c_int ) :: i integer ( c_intptr_t ), allocatable , target :: device_ids (:) ! String arrays for holding platform details. character , allocatable , target :: platform_profile (:) character , allocatable , target :: platform_version (:) character , allocatable , target :: platform_name (:) character , allocatable , target :: platform_vendor (:) character , allocatable , target :: platform_extensions (:) ! String array for holding device name. character , allocatable , target :: device_name (:) ! Maximum compute units for device. integer ( c_size_t ), target :: device_mwgs , device_mwis ( 3 ) integer ( c_int32_t ), target :: device_cu integer ( c_int64_t ), target :: device_gms , device_mmas ! Profile. err = clGetPlatformInfo ( platform_id , CL_PLATFORM_PROFILE , zero_size , C_NULL_PTR , temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetPlatformInfo' , err ) allocate ( platform_profile ( temp_size )) err = clGetPlatformInfo ( platform_id , CL_PLATFORM_PROFILE , temp_size , C_LOC ( platform_profile ), temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetPlatformInfo' , err ) print * , 'Profile: ' , platform_profile deallocate ( platform_profile ) ! Version. err = clGetPlatformInfo ( platform_id , CL_PLATFORM_VERSION , zero_size , C_NULL_PTR , temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetPlatformInfo' , err ) allocate ( platform_version ( temp_size )) err = clGetPlatformInfo ( platform_id , CL_PLATFORM_VERSION , temp_size , C_LOC ( platform_version ), temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetPlatformInfo' , err ) print * , 'Version: ' , platform_version deallocate ( platform_version ) ! Name. err = clGetPlatformInfo ( platform_id , CL_PLATFORM_NAME , zero_size , C_NULL_PTR , temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetPlatformInfo' , err ) allocate ( platform_name ( temp_size )) err = clGetPlatformInfo ( platform_id , CL_PLATFORM_NAME , temp_size , C_LOC ( platform_name ), temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetPlatformInfo' , err ) print * , 'Name: ' , platform_name deallocate ( platform_name ) ! Vendor. err = clGetPlatformInfo ( platform_id , CL_PLATFORM_VENDOR , zero_size , C_NULL_PTR , temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetPlatformInfo' , err ) allocate ( platform_vendor ( temp_size )) err = clGetPlatformInfo ( platform_id , CL_PLATFORM_VENDOR , temp_size , C_LOC ( platform_vendor ), temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetPlatformInfo' , err ) print * , 'Vendor: ' , platform_vendor deallocate ( platform_vendor ) ! Extensions. err = clGetPlatformInfo ( platform_id , CL_PLATFORM_EXTENSIONS , zero_size , C_NULL_PTR , temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetPlatformInfo' , err ) allocate ( platform_extensions ( temp_size )) err = clGetPlatformInfo ( platform_id , CL_PLATFORM_EXTENSIONS , temp_size , C_LOC ( platform_extensions ), temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetPlatformInfo' , err ) print * , 'Extensions: ' , platform_extensions deallocate ( platform_extensions ) ! ! Print device information for this platform. ! ! Get device count. print * ! device_type = CL_DEVICE_TYPE_CPU err = clGetDeviceIDs ( platform_id , CL_DEVICE_TYPE_CPU , 0 , C_NULL_PTR , num_devices ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceIDs' , err ,. TRUE .) if ( err /= CL_SUCCESS . or . num_devices < 1 ) then print * , 'No CPU devices found on this platform' else print * print '(A, I2)' , 'Num CPU Devices: ' , num_devices ! Allocate an array to hold device handles. allocate ( device_ids ( num_devices )) ! Get device IDs. err = clGetDeviceIDs ( platform_id , CL_DEVICE_TYPE_CPU , num_devices , C_LOC ( device_ids ), num_devices ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceIDs' , err ) if ( err /= CL_SUCCESS ) then print * , 'Error quering CPU devices: ' , err return end if ! Loop over devices and print information. do i = 1 , num_devices ! Maximum compute units. temp_size = 8 err = clGetDeviceInfo ( device_ids ( i ), CL_DEVICE_MAX_COMPUTE_UNITS , temp_size , C_LOC ( device_cu ), temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceInfo' , err ) temp_size = 8 err = clGetDeviceInfo ( device_ids ( i ), CL_DEVICE_GLOBAL_MEM_SIZE , temp_size , C_LOC ( device_gms ), temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceInfo' , err ) device_gms = device_gms / 1024 / 1024 / 1024 ! temp_size = 8 ! err = clGetDeviceInfo(device_ids(i), CL_DEVICE_MAX_MEM_ALLOC_SIZE, temp_size, C_LOC(device_gms), temp_size) !write (*,*) 'mmas : ', device_mmas ! CL_DEVICE_MAX_WORK_GROUP_SIZE temp_size = 8 err = clGetDeviceInfo ( device_ids ( i ), CL_DEVICE_MAX_WORK_GROUP_SIZE , temp_size , C_LOC ( device_mwgs ), temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceInfo' , err ) ! CL_DEVICE_MAX_WORK_ITEM_SIZES temp_size = 8 * 3 err = clGetDeviceInfo ( device_ids ( i ), CL_DEVICE_MAX_WORK_ITEM_SIZES , temp_size , C_LOC ( device_mwis ), temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceInfo' , err ) ! Name. temp_size = 4 err = clGetDeviceInfo ( device_ids ( i ), CL_DEVICE_NAME , zero_size , C_NULL_PTR , temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceInfo' , err ) allocate ( device_name ( temp_size )) err = clGetDeviceInfo ( device_ids ( i ), CL_DEVICE_NAME , temp_size , C_LOC ( device_name ), temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceInfo' , err ) ! Print brief device details. Since this routine can be used by the user to determine GPU device IDs, ! we subtract 1 from the device ID to make sure that the CPU gets number 0... write ( * , '(A,I2,A,I4,A,I4,A,I4,A,I4,A,I4,A,I3,A,$)' ) ' Device (#' , i , ', CU/MWGS/MWIS/GMS: ' , device_cu , '/' , device_mwgs , '/' ,& device_mwis ( 1 ), ',' , device_mwis ( 2 ), ',' , device_mwis ( 3 ), '/' , device_gms , ') - ' print * , device_name deallocate ( device_name ) end do end if ! Get device count. !device_type = CL_DEVICE_TYPE_ALL print * err = clGetDeviceIDs ( platform_id , CL_DEVICE_TYPE_GPU , 0 , C_NULL_PTR , num_devices ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceIDs' , err ,. TRUE .) if ( err /= CL_SUCCESS . or . num_devices < 1 ) then print * , 'No GPU devices found on this platform ' else print * print '(A, I2)' , 'Num GPU Devices: ' , num_devices ! Allocate an array to hold device handles. if ( allocated ( device_ids )) deallocate ( device_ids ) allocate ( device_ids ( num_devices )) ! Get device IDs. err = clGetDeviceIDs ( platform_id , CL_DEVICE_TYPE_GPU , num_devices , C_LOC ( device_ids ), num_devices ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceIDs' , err ) if ( err /= CL_SUCCESS ) then print * , 'Error quering devices: ' , err return end if ! Loop over devices and print information. do i = 1 , num_devices ! Maximum compute units. temp_size = 8 err = clGetDeviceInfo ( device_ids ( i ), CL_DEVICE_MAX_COMPUTE_UNITS , temp_size , C_LOC ( device_cu ), temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceInfo' , err ) temp_size = 8 err = clGetDeviceInfo ( device_ids ( i ), CL_DEVICE_GLOBAL_MEM_SIZE , temp_size , C_LOC ( device_gms ), temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceInfo' , err ) device_gms = device_gms / 1024 / 1024 / 1024 ! temp_size = 8 ! err = clGetDeviceInfo(device_ids(i), CL_DEVICE_MAX_MEM_ALLOC_SIZE, temp_size, C_LOC(device_gms), temp_size) !write (*,*) 'mmas : ', device_mmas ! CL_DEVICE_MAX_WORK_GROUP_SIZE temp_size = 8 err = clGetDeviceInfo ( device_ids ( i ), CL_DEVICE_MAX_WORK_GROUP_SIZE , temp_size , C_LOC ( device_mwgs ), temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceInfo' , err ) ! CL_DEVICE_MAX_WORK_ITEM_SIZES temp_size = 8 * 3 err = clGetDeviceInfo ( device_ids ( i ), CL_DEVICE_MAX_WORK_ITEM_SIZES , temp_size , C_LOC ( device_mwis ), temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceInfo' , err ) ! Name. temp_size = 4 err = clGetDeviceInfo ( device_ids ( i ), CL_DEVICE_NAME , zero_size , C_NULL_PTR , temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceInfo' , err ) allocate ( device_name ( temp_size )) err = clGetDeviceInfo ( device_ids ( i ), CL_DEVICE_NAME , temp_size , C_LOC ( device_name ), temp_size ) call CLerror_check ( 'CLquery_platform_info:clGetDeviceInfo' , err ) ! Print brief device details. Since this routine can be used by the user to determine GPU device IDs, ! we subtract 1 from the device ID to make sure that the CPU gets number 0... write ( * , '(A,I2,A,I4,A,I4,A,I4,A,I4,A,I4,A,I3,A,$)' ) ' Device (#' , i , ', CU/MWGS/MWIS/GMS: ' , device_cu , '/' , device_mwgs , '/' ,& device_mwis ( 1 ), ',' , device_mwis ( 2 ), ',' , device_mwis ( 3 ), '/' , device_gms , ') - ' print * , device_name deallocate ( device_name ) end do end if print * , ' ' write ( * , * ) '[CU = Compute Units; MWGS = Maximum Work Group Size; MWIS = Maximum Work Item Sizes (3D); ' // & 'GMS = Global Memory Size (Gb)]' end subroutine CLquery_platform_info","tags":"","loc":"proc/clquery_platform_info.html","title":"CLquery_platform_info – Fortran Program"},{"text":"public recursive subroutine CLread_source_file(sourcefile, csource, slength) Uses: local error iso_c_binding proc~~clread_source_file~~UsesGraph proc~clread_source_file CLread_source_file error error error->proc~clread_source_file local local local->proc~clread_source_file iso_c_binding iso_c_binding iso_c_binding->proc~clread_source_file Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read an OpenCL source file and return the source properly formatted\n @param sourcefile filename for the OpenCL source code\n @param source c_str containing the source, NULL-terminated\n @param slength source string length\n @date 02/18/16  MDG 1.0 original\n @date 01/15/17  MDG 1.1 added functionality for second opencl folder for developers... Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: sourcefile character(kind=len=source_length,c_char), intent(out) :: csource integer(kind=c_size_t), intent(out) :: slength Calls proc~~clread_source_file~~CallsGraph proc~clread_source_file CLread_source_file emsoft_getopenclpathname emsoft_getopenclpathname proc~clread_source_file->emsoft_getopenclpathname fatalerror fatalerror proc~clread_source_file->fatalerror emsoft_getemdevelop emsoft_getemdevelop proc~clread_source_file->emsoft_getemdevelop emsoft_tonativepath emsoft_tonativepath proc~clread_source_file->emsoft_tonativepath Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~clread_source_file~~CalledByGraph proc~clread_source_file CLread_source_file proc~emsoftcgetmcopencl EMsoftCgetMCOpenCL proc~emsoftcgetmcopencl->proc~clread_source_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code CLread_source_file Source Code recursive subroutine CLread_source_file ( sourcefile , csource , slength ) !DEC$ ATTRIBUTES DLLEXPORT :: CLread_source_file use local use error use ISO_C_BINDING IMPLICIT NONE integer , parameter :: source_length = 50000 character ( fnlen ), INTENT ( IN ) :: sourcefile character ( len = source_length , KIND = c_char ), INTENT ( OUT ) :: csource integer ( c_size_t ), INTENT ( OUT ) :: slength character ( len = source_length ), target :: source character ( fnlen ) :: fname , clpath , clpath2 , tcf integer ( kind = irg ) :: irec , ierr , ipos , i , j logical :: develop , fexist ! find the cl file in the main opencl folder or the private folder if the Develop mode equals Yes... clpath = trim ( EMsoft_getOpenCLpathname ()) ! then, determine whether or not the user is working in develop mode by checking for the ! Develop keyword in the EMsoftconfig.json file... Regular users will only have a single ! opencl folder, but developers have two, so we need to make sure we check both ! locations.  The second location is the private folder... develop = EMsoft_getEMdevelop () clpath2 = '' if ( develop . eqv .. TRUE .) then ipos = index ( clpath , 'Public' ) do i = 1 , ipos - 1 clpath2 ( i : i ) = clpath ( i : i ) end do tcf = 'Private/opencl/' do i = ipos , ipos + 15 j = i - ipos + 1 clpath2 ( i : i ) = tcf ( j : j ) end do end if fname = trim ( clpath ) // trim ( sourcefile ) fname = EMsoft_toNativePath ( fname ) inquire ( file = trim ( fname ), exist = fexist ) if (. not . fexist ) then if ( develop . eqv .. TRUE .) then fname = trim ( clpath2 ) // trim ( sourcefile ) fname = EMsoft_toNativePath ( fname ) inquire ( file = trim ( fname ), exist = fexist ) if (. not . fexist ) then call FatalError ( 'CLread_source_file' , 'opencl source file ' // trim ( sourcefile ) // ' not found in either opencl folder.' & // trim ( fname )) end if else call FatalError ( 'CLread_source_file' , 'opencl source  file ' // trim ( fname ) // ' not found' ) end if end if ! read the source file from the opencl folder open ( unit = dataunit , file = trim ( fname ), access = 'direct' , status = 'old' , & action = 'read' , iostat = ierr , recl = 1 ) if ( ierr /= 0 ) call FatalError ( \"CLread_source_file: \" , 'Cannot open file ' // fname ) source = '' irec = 1 do read ( unit = dataunit , rec = irec , iostat = ierr ) source ( irec : irec ) if ( ierr /= 0 ) exit if ( irec == source_length ) call FatalError ( \"CLread_source_file: \" , 'Error: CL source file is too big' ) irec = irec + 1 end do close ( unit = dataunit ) csource = trim ( source ) csource ( irec : irec ) = C_NULL_CHAR slength = irec end subroutine CLread_source_file","tags":"","loc":"proc/clread_source_file.html","title":"CLread_source_file – Fortran Program"},{"text":"public recursive subroutine CLinit_PDCCQ(platform, nump, selnump, device, numd, selnumd, devinfo, context, command_queue) Uses: iso_c_binding error io proc~~clinit_pdccq~~UsesGraph proc~clinit_pdccq CLinit_PDCCQ io io io->proc~clinit_pdccq iso_c_binding iso_c_binding iso_c_binding->proc~clinit_pdccq error error error->proc~clinit_pdccq Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief initalize a CL platform, device, context, and command queue\n @param \n @date 02/23/16  MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=c_intptr_t), allocatable, target :: platform (:) integer(kind=irg), intent(out) :: nump integer(kind=irg), intent(in) :: selnump integer(kind=c_intptr_t), allocatable, target :: device (:) integer(kind=irg), intent(out) :: numd integer(kind=irg), intent(in) :: selnumd character(len=fnlen), intent(out) :: devinfo integer(kind=c_intptr_t), target :: context integer(kind=c_intptr_t), target :: command_queue Calls proc~~clinit_pdccq~~CallsGraph proc~clinit_pdccq CLinit_PDCCQ clgetdeviceinfo clgetdeviceinfo proc~clinit_pdccq->clgetdeviceinfo fatalerror fatalerror proc~clinit_pdccq->fatalerror clgetplatformids clgetplatformids proc~clinit_pdccq->clgetplatformids clcreatecontext clcreatecontext proc~clinit_pdccq->clcreatecontext clcreatecommandqueue clcreatecommandqueue proc~clinit_pdccq->clcreatecommandqueue writevalue writevalue proc~clinit_pdccq->writevalue clgetdeviceids clgetdeviceids proc~clinit_pdccq->clgetdeviceids proc~clerror_check CLerror_check proc~clinit_pdccq->proc~clerror_check proc~clerror_check->fatalerror proc~clerror_check->writevalue Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~clinit_pdccq~~CalledByGraph proc~clinit_pdccq CLinit_PDCCQ proc~emsoftcgetmcopencl EMsoftCgetMCOpenCL proc~emsoftcgetmcopencl->proc~clinit_pdccq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code CLinit_PDCCQ Source Code recursive subroutine CLinit_PDCCQ ( platform , nump , selnump , device , numd , selnumd , devinfo , context , command_queue ) !DEC$ ATTRIBUTES DLLEXPORT :: CLinit_PDCCQ use ISO_C_BINDING use error use io IMPLICIT NONE integer ( c_intptr_t ), allocatable , target :: platform (:) integer ( kind = irg ), INTENT ( OUT ) :: nump integer ( kind = irg ), INTENT ( IN ) :: selnump integer ( c_intptr_t ), allocatable , target :: device (:) integer ( kind = irg ), INTENT ( OUT ) :: numd integer ( kind = irg ), INTENT ( IN ) :: selnumd character ( fnlen ), INTENT ( OUT ) :: devinfo integer ( c_intptr_t ), target :: context integer ( c_intptr_t ), target :: command_queue integer ( c_int32_t ) :: ierr integer ( c_size_t ) :: cnuminfo character ( fnlen ), target :: info integer ( c_intptr_t ), target :: ctx_props ( 3 ) integer ( c_int64_t ) :: cmd_queue_props ! get the platform ID ierr = clGetPlatformIDs ( 0 , C_NULL_PTR , nump ) call CLerror_check ( 'CLinit_PDCCQ:clGetPlatformIDs' , ierr ) allocate ( platform ( nump )) ierr = clGetPlatformIDs ( nump , C_LOC ( platform ), nump ) call CLerror_check ( 'CLinit_PDCCQ:clGetPlatformIDs' , ierr ) if ( selnump . gt . nump ) then call FatalError ( \"CLinit_PDCCQ\" , \"non-existing platform id requested\" ) end if ! get the device ID ierr = clGetDeviceIDs ( platform ( selnump ), CL_DEVICE_TYPE_GPU , 0 , C_NULL_PTR , numd ) call CLerror_check ( 'CLinit_PDCCQ:clGetDeviceIDs' , ierr ) allocate ( device ( numd )) ierr = clGetDeviceIDs ( platform ( selnump ), CL_DEVICE_TYPE_GPU , numd , C_LOC ( device ), numd ) call CLerror_check ( 'CLinit_PDCCQ:clGetDeviceIDs' , ierr ) if ( selnumd . gt . numd ) then call FatalError ( \"CLinit_PDCCQ\" , \"non-existing device id requested\" ) end if ! get the device name and return it as devinfo ierr = clGetDeviceInfo ( device ( selnumd ), CL_DEVICE_NAME , sizeof ( info ), C_LOC ( info ), cnuminfo ) call CLerror_check ( 'CLinit_PDCCQ:clGetDeviceInfo' , ierr ) if ( cnuminfo . gt . fnlen ) then call WriteValue ( \"CLinit_PDCCQ\" , \"device info string truncated to 132 characters\" ) devinfo = trim ( info ( 1 : 132 )) else devinfo = trim ( info ( 1 : cnuminfo )) end if ! create the context and the command queue ctx_props ( 1 ) = CL_CONTEXT_PLATFORM ctx_props ( 2 ) = platform ( selnump ) ctx_props ( 3 ) = 0 context = clCreateContext ( C_LOC ( ctx_props ), numd , C_LOC ( device ), C_NULL_FUNPTR , C_NULL_PTR , ierr ) call CLerror_check ( 'CLinit_PDCCQ:clCreateContext' , ierr ) cmd_queue_props = 0 command_queue = clCreateCommandQueue ( context , device ( selnumd ), cmd_queue_props , ierr ) call CLerror_check ( 'CLinit_PDCCQ:clCreateCommandQueue' , ierr ) end subroutine CLinit_PDCCQ","tags":"","loc":"proc/clinit_pdccq.html","title":"CLinit_PDCCQ – Fortran Program"},{"text":"public recursive subroutine CLerror_check(routine, ierr, nonfatal) Uses: iso_c_binding error io proc~~clerror_check~~UsesGraph proc~clerror_check CLerror_check io io io->proc~clerror_check iso_c_binding iso_c_binding iso_c_binding->proc~clerror_check error error error->proc~clerror_check Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief checks whether or not there was a CL 1.2 error and returns the error message.\n @param ierr error number (0 is no error) \n @date 06/06/16  MDG 1.0 original Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: routine integer(kind=c_int32_t), intent(in) :: ierr logical, intent(in), optional :: nonfatal Calls proc~~clerror_check~~CallsGraph proc~clerror_check CLerror_check writevalue writevalue proc~clerror_check->writevalue fatalerror fatalerror proc~clerror_check->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~clerror_check~~CalledByGraph proc~clerror_check CLerror_check proc~clinit_pdccq CLinit_PDCCQ proc~clinit_pdccq->proc~clerror_check proc~clquery_platform_info CLquery_platform_info proc~clquery_platform_info->proc~clerror_check proc~innerprodgpu InnerProdGPU proc~innerprodgpu->proc~clerror_check proc~emsoftcgetmcopencl EMsoftCgetMCOpenCL proc~emsoftcgetmcopencl->proc~clinit_pdccq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code CLerror_check Source Code recursive subroutine CLerror_check ( routine , ierr , nonfatal ) !DEC$ ATTRIBUTES DLLEXPORT :: CLerror_check use ISO_C_BINDING use error use io IMPLICIT NONE character ( * ), INTENT ( IN ) :: routine integer ( kind = c_int32_t ), INTENT ( IN ) :: ierr logical , INTENT ( IN ), OPTIONAL :: nonfatal character ( fnlen ) :: estr integer ( kind = irg ) :: iout ( 1 ) if ( ierr . ne . 0 ) then select case ( ierr ) case ( - 1 ) estr = 'Error: CL_DEVICE_NOT_FOUND' !                       = -1 case ( - 2 ) estr = 'Error: CL_DEVICE_NOT_AVAILABLE' !                   = -2 case ( - 3 ) estr = 'Error: CL_COMPILER_NOT_AVAILABLE' !                 = -3 case ( - 4 ) estr = 'Error: CL_MEM_OBJECT_ALLOCATION_FAILURE' !          = -4 case ( - 5 ) estr = 'Error: CL_OUT_OF_RESOURCES' !                       = -5 case ( - 6 ) estr = 'Error: CL_OUT_OF_HOST_MEMORY' !                     = -6 case ( - 7 ) estr = 'Error: CL_PROFILING_INFO_NOT_AVAILABLE' !           = -7 case ( - 8 ) estr = 'Error: CL_MEM_COPY_OVERLAP' !                       = -8 case ( - 9 ) estr = 'Error: CL_IMAGE_FORMAT_MISMATCH' !                  = -9 case ( - 10 ) estr = 'Error: CL_IMAGE_FORMAT_NOT_SUPPORTED' !             = -10 case ( - 11 ) estr = 'Error: CL_BUILD_PROGRAM_FAILURE' !                  = -11 case ( - 12 ) estr = 'Error: CL_MAP_FAILURE' !                            = -12 case ( - 13 ) estr = 'Error: CL_MISALIGNED_SUB_BUFFER_OFFSET' !           = -13 case ( - 14 ) estr = 'Error: CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST' ! 14 case ( - 15 ) estr = 'Error: CL_COMPILE_PROGRAM_FAILURE' !                = -15 case ( - 16 ) estr = 'Error: CL_LINKER_NOT_AVAILABLE' !                   = -16 case ( - 17 ) estr = 'Error: CL_LINK_PROGRAM_FAILURE' !                   = -17 case ( - 18 ) estr = 'Error: CL_DEVICE_PARTITION_FAILED' !                = -18 case ( - 19 ) estr = 'Error: CL_KERNEL_ARG_INFO_NOT_AVAILABLE' !          = -19 case ( - 30 ) estr = 'Error: CL_INVALID_VALUE' !                          = -30 case ( - 31 ) estr = 'Error: CL_INVALID_DEVICE_TYPE' !                    = -31 case ( - 32 ) estr = 'Error: CL_INVALID_PLATFORM' !                       = -32 case ( - 33 ) estr = 'Error: CL_INVALID_DEVICE' !                         = -33 case ( - 34 ) estr = 'Error: CL_INVALID_CONTEXT' !                        = -34 case ( - 35 ) estr = 'Error: CL_INVALID_QUEUE_PROPERTIES' !               = -35 case ( - 36 ) estr = 'Error: CL_INVALID_COMMAND_QUEUE' !                  = -36 case ( - 37 ) estr = 'Error: CL_INVALID_HOST_PTR' !                       = -37 case ( - 38 ) estr = 'Error: CL_INVALID_MEM_OBJECT' !                     = -38 case ( - 39 ) estr = 'Error: CL_INVALID_IMAGE_FORMAT_DESCRIPTOR' !        = -39 case ( - 40 ) estr = 'Error: CL_INVALID_IMAGE_SIZE' !                     = -40 case ( - 41 ) estr = 'Error: CL_INVALID_SAMPLER' !                        = -41 case ( - 42 ) estr = 'Error: CL_INVALID_BINARY' !                         = -42 case ( - 43 ) estr = 'Error: CL_INVALID_BUILD_OPTION' !                   = -43 case ( - 44 ) estr = 'Error: CL_INVALID_PROGRAM' !                        = -44 case ( - 45 ) estr = 'Error: CL_INVALID_PROGRAM_EXECUTABLE' !             = -45 case ( - 46 ) estr = 'Error: CL_INVALID_KERNEL_NAME' !                    = -46 case ( - 47 ) estr = 'Error: CL_INVALID_KERNEL_DEFINITION' !              = -47 case ( - 48 ) estr = 'Error: CL_INVALID_KERNEL' !                         = -48 case ( - 49 ) estr = 'Error: CL_INVALID_ARG_INDEX' !                      = -49 case ( - 50 ) estr = 'Error: CL_INVALID_ARG_VALUE' !                      = -50 case ( - 51 ) estr = 'Error: CL_INVALID_ARG_SIZE' !                       = -51 case ( - 52 ) estr = 'Error: CL_INVALID_KERNEL_ARGS' !                    = -52 case ( - 53 ) estr = 'Error: CL_INVALID_WORK_DIMENSION' !                 = -53 case ( - 54 ) estr = 'Error: CL_INVALID_WORK_GROUP_SIZE' !                = -54 case ( - 55 ) estr = 'Error: CL_INVALID_WORK_ITEM_SIZE' !                 = -55 case ( - 56 ) estr = 'Error: CL_INVALID_GLOBAL_OFFSET' !                  = -56 case ( - 57 ) estr = 'Error: CL_INVALID_EVENT_WAIT_LIST' !                = -57 case ( - 58 ) estr = 'Error: CL_INVALID_EVENT' !                          = -58 case ( - 59 ) estr = 'Error: CL_INVALID_OPERATION' !                      = -59 case ( - 60 ) estr = 'Error: CL_INVALID_GL_OBJECT' !                      = -60 case ( - 61 ) estr = 'Error: CL_INVALID_BUFFER_SIZE' !                    = -61 case ( - 62 ) estr = 'Error: CL_INVALID_MIP_LEVEL' !                      = -62 case ( - 63 ) estr = 'Error: CL_INVALID_GLOBAL_WORK_SIZE' !               = -63 case ( - 64 ) estr = 'Error: CL_INVALID_PROPERTY' !                       = -64 case ( - 65 ) estr = 'Error: CL_INVALID_IMAGE_DESCRIPTOR' !               = -65 case ( - 66 ) estr = 'Error: CL_INVALID_COMPILER_OPTIONS' !               = -66 case ( - 67 ) estr = 'Error: CL_INVALID_LINKER_OPTIONS' !                 = -67 case ( - 68 ) estr = 'Error: CL_INVALID_DEVICE_PARTITION_COUNT' !         = -68 case default estr = 'Error: Unknown CL error code' iout ( 1 ) = ierr call WriteValue ( 'Unknown CL error code : ' , iout , 1 ) end select if ( present ( nonfatal )) then if ( nonfatal . eqv .. TRUE .) then print * , ' Non-fatal error: ' // trim ( estr ) end if else call FatalError ( trim ( routine ), trim ( estr )) end if end if end subroutine CLerror_check","tags":"","loc":"proc/clerror_check.html","title":"CLerror_check – Fortran Program"},{"text":"public recursive function YSHDisp(defects, x, y, z, ii) result(res) Uses: constants proc~~yshdisp~2~~UsesGraph proc~yshdisp~2 YSHDisp module~constants constants module~constants->proc~yshdisp~2 local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief  compute the displacement field of an inclined dislocation intersecting the foil surface\n @details compute the displacement field of an inclined dislocation intersecting the top surface of \n the foil, taking into account surface relaxations for the isotropic elastic case (cubic only) ... equations are based on the Shaibani&Hazzledine 1981 paper, along with special limits for \n the alpha->0 case, which were derived by MDG using Mathematica. \n @paraqm defects defects structure\n @param x dislocation x-coordinate\n @param y dislocation y-coordinate\n @param z dislocation z-coordinate\n @param ii dislocation number Todo There is a problem with dislocations normal to the foil surface, likely a typographical error\n in the SH paper; this needs to be resolved further, which may require explicit repetition of all \n analytical computations! Mathematica gives an infinite limit for the bx edge case when normal\n to the foil surface.\n @date    1/5/99  MDG 1.0 original\n @date    5/19/01 MDG 2.0 f90 version\n @date   11/27/01 MDG 2.1 added kind support\n @date   06/04/13 MDG 3.0 rewrite\n @date   11/21/13 MDG 3.1 verification\n @date   06/09/14 MDG 4.0 added defects as argument Arguments Type Intent Optional Attributes Name type(defecttype), intent(inout) :: defects real(kind=dbl), intent(in) :: x real(kind=dbl), intent(in) :: y real(kind=dbl), intent(in) :: z integer(kind=irg), intent(in) :: ii Return Value real(kind=dbl)\n  (3) Calls proc~~yshdisp~2~~CallsGraph proc~yshdisp~2 YSHDisp datan2 datan2 proc~yshdisp~2->datan2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~yshdisp~2~~CalledByGraph proc~yshdisp~2 YSHDisp proc~calcr CalcR proc~calcr->proc~yshdisp~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code YSHDisp Source Code recursive function YSHDisp ( defects , x , y , z , ii ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: YSHDisp use constants IMPLICIT NONE type ( defecttype ), INTENT ( INOUT ) :: defects real ( kind = dbl ), INTENT ( IN ) :: x , y , z integer ( kind = irg ), INTENT ( IN ) :: ii real ( kind = dbl ) :: eta , zeta , etap , zetap , r , oms , omts , xx , sgn , om , omp , AA , BB , BBp , th , & k , lam , alA , alB , u , v , w , ms , S , du , dv , dw , qe , me , De , qx , mx , Dx , rr , eps real ( kind = dbl ) :: res ( 3 ) ! initialize the geometrical parameters eta = y * defects % YD ( ii )% ca - z * defects % YD ( ii )% sa zeta = y * defects % YD ( ii )% sa + z * defects % YD ( ii )% ca etap = - y * defects % YD ( ii )% ca - z * defects % YD ( ii )% sa zetap = y * defects % YD ( ii )% sa - z * defects % YD ( ii )% ca r = sqrt ( x ** 2 + y ** 2 + z ** 2 ) oms = 1.D0 - defects % YD ( ii )% sig omts = 1.D0 - 2.D0 * defects % YD ( ii )% sig ! cover the special case of negative x values (based on IDL tests) xx = x sgn = 1.D0 if ( xx . lt . 0.D0 ) then xx = dabs ( x ) sgn = - 1.D0 else sgn = 1.D0 end if ! more parameters om = ( datan2 ( y , xx ) - datan2 ( eta , xx ) + datan2 ( xx * r * defects % YD ( ii )% sa , eta * y + xx ** 2 * defects % YD ( ii )% ca )) omp = ( datan2 ( y , xx ) - datan2 ( etap , xx ) + datan2 ( xx * r * defects % YD ( ii )% sa , etap * y - xx ** 2 * defects % YD ( ii )% ca )) AA = r - z BB = r - zeta BBp = r - zetap th = 2.D0 * oms * ( omp - om ) lam = omts * dlog ( BBp / BB ) alA = dlog ( AA ) alB = dlog ( BB ) u = 0.D0 v = 0.D0 w = 0.D0 eps = 1.0D-6 ! screw component first if ( abs ( defects % YD ( ii )% bs ). gt . eps ) then ms = xx * sin ( 2.D0 * defects % YD ( ii )% alpha ) / r / BB S = defects % YD ( ii )% bs / ( 4.D0 * cPi ) if ( defects % YD ( ii )% alpha . gt . 0.01 ) then du = xx * ms + 2.D0 * eta * defects % YD ( ii )% ca ** 2 / BB + 2.D0 * omts * defects % YD ( ii )% cota * ( - 1.D0 + defects % YD ( ii )% ca + & defects % YD ( ii )% ca * alA - y * defects % YD ( ii )% sa / AA - alB ) - sin ( 2.D0 * defects % YD ( ii )% alpha ) dv = y * ms - 2.D0 * xx * defects % YD ( ii )% ca / BB - defects % YD ( ii )% sa * ( omp - om ) + 2.D0 * omts * defects % YD ( ii )% cota * & ( xx * defects % YD ( ii )% sa / AA - om * defects % YD ( ii )% ca ) dw = z * ms + defects % YD ( ii )% ca * ( omp - om ) - 2.D0 * omts * om * defects % YD ( ii )% ca else du = 2.D0 * y / ( r - z ) dv = - 2.D0 * xx * ( r + z ) / ( xx ** 2 + y ** 2 ) dw = cPi + datan2 ( y , xx ) - datan2 ( - y , xx ) end if u = u + du * S v = v - sgn * dv * S w = w + sgn * dw * S end if ! then the edge component in the y-z plane if ( abs ( defects % YD ( ii )% be ). gt . eps ) then qe = xx * ( 1.D0 / BBp - 1.D0 / BB + 2.D0 * z * defects % YD ( ii )% ca / BB ** 2 ) me = - qe / r - 4.D0 * oms * xx * defects % YD ( ii )% ca ** 2 / r / BB De = defects % YD ( ii )% be / ( 8.D0 * cPi * oms ) if ( defects % YD ( ii )% alpha . gt . 0.01 ) then k = 4.D0 * oms * omts * defects % YD ( ii )% cota ** 2 du = xx * me + lam + 2.D0 * defects % YD ( ii )% ca * ( z + 2.D0 * oms * eta * defects % YD ( ii )% sa ) / BB - 4.D0 * oms * defects % YD ( ii )% sa ** 2 + & k * ( 1.D0 - defects % YD ( ii )% ca - defects % YD ( ii )% ca * alA + y * defects % YD ( ii )% sa / AA + alB ) dv = y * me + qe * defects % YD ( ii )% sa + th * defects % YD ( ii )% ca + k * ( - xx * defects % YD ( ii )% sa / AA + om * defects % YD ( ii )% ca ) dw = z * me + qe * defects % YD ( ii )% ca + th * defects % YD ( ii )% sa - 2.D0 * xx * defects % YD ( ii )% ca * ( 1.D0 / BBp + omts / BB ) + k * om * defects % YD ( ii )% sa !    write (*,*) du,dv,dw else rr = xx ** 2 + y ** 2 du = 2.D0 * z / ( r - z ) + 4.D0 * xx ** 2 * ( defects % YD ( ii )% sig * rr - r ** 2 ) / r / AA ** 2 / ( r + z ) + 2.D0 * omts * oms * (( xx ** 2 + z * ( z - r )) / AA ** 2 + alA ) + & omts * dlog (( r + z ) / AA ) dv = 4.D0 * xx * y * ( rr * defects % YD ( ii )% sig - r ** 2 ) / r / AA ** 2 / ( r + z ) + 2.D0 * xx * y * ( rr + 2.D0 * z * ( r + z )) * oms * omts / rr ** 2 + & 2.D0 * oms * ( cPi + datan2 ( y , xx ) - datan2 ( - y , xx )) dw = 4.D0 * xx * rr * defects % YD ( ii )% sig * ( z - 2.D0 * r * oms ) / r / AA ** 2 / ( r + z ) end if u = u + du * De v = v + sgn * dv * De w = w + sgn * dw * De end if ! and finally the bx edge component if ( abs ( defects % YD ( ii )% bx ). gt . eps ) then qx = etap / BBp - eta / BB - 2.D0 * z * eta * defects % YD ( ii )% ca / BB ** 2 mx = - qx / r + 2.D0 * omts * y * defects % YD ( ii )% ca / r / BB Dx = defects % YD ( ii )% bx / ( 8.D0 * cPi * oms ) if ( defects % YD ( ii )% alpha . gt . 0.01 ) then k = 4.D0 * oms * omts * defects % YD ( ii )% cota ** 2 du = xx * mx + th + k * ( xx * defects % YD ( ii )% ta / AA - om ) dv = y * mx + qx * defects % YD ( ii )% sa - lam * defects % YD ( ii )% ca - 2.D0 * defects % YD ( ii )% ca * & ( z * defects % YD ( ii )% ca + omts * y * defects % YD ( ii )% sa ) / BB + & k * ( - 1.D0 + defects % YD ( ii )% ca - alA + y * defects % YD ( ii )% ta / AA + defects % YD ( ii )% ca * alB ) dw = z * mx + qx * defects % YD ( ii )% ca - lam * defects % YD ( ii )% sa - 2.D0 * etap * defects % YD ( ii )% ca / BBp + & 4.D0 * defects % YD ( ii )% ca * ( oms * y * defects % YD ( ii )% ca - omts * z * defects % YD ( ii )% sa ) / BB + & k * defects % YD ( ii )% ta * ( defects % YD ( ii )% ca - alA + defects % YD ( ii )% ca * alB ) + 4.D0 * oms * defects % YD ( ii )% ca * defects % YD ( ii )% cota else rr = xx ** 2 + y ** 2 du = - 4.D0 * xx * y * ( rr * defects % YD ( ii )% sig - r ** 2 ) / r / AA ** 2 / ( r + z ) - 2.D0 * xx * y * ( rr + 2.D0 * z * ( r + z )) * oms * omts / rr ** 2 + & 2.D0 * oms * ( cPi + datan2 ( y , xx ) - datan2 ( - y , xx )) dv = 2.D0 * z / ( r - z ) - 4.D0 * y ** 2 * ( defects % YD ( ii )% sig * rr - r ** 2 ) / r / AA ** 2 / ( r + z ) + 2.D0 * omts * oms * ( - 1.D0 + ( z * ( r - z ) - y ** 2 ) / AA ** 2 - alA ) - & omts * dlog (( r + z ) / AA ) dw = 0.D0 ! not sure if this limit is correct ... Mathematica gives a directedinfinity value for the limit, which might mean that the ! original YSH expression in the paper is incorrect for the w component ... this needs to be rederived and verified !!! end if u = u + sgn * du * Dx v = v + dv * Dx w = w + dw * Dx end if ! and return the displacement components res = ( / u , v , w / ) end function YSHDisp","tags":"","loc":"proc/yshdisp~2.html","title":"YSHDisp – Fortran Program"},{"text":"public recursive function Eshelby_disp(defects, i, xyz) result(u) Uses: local math proc~~eshelby_disp~~UsesGraph proc~eshelby_disp Eshelby_disp math math math->proc~eshelby_disp local local local->proc~eshelby_disp Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief compute the actual displacement vector for an isotropic Eshelby ellipsoidal inclusion\n We implemented the Eshelby expressions based on Mura's 1987 book.\n @param defects defects structure\n @param i Einclusion number\n @param xyz coordinate triplet\n @date 12/11/15 MDG 1.0 initial version based on trial IDL script\n @date 12/13/15 MDG 1.1 corrections to some of the auxiliary expressions; sphere limit is now correct Arguments Type Intent Optional Attributes Name type(defecttype), intent(in) :: defects integer(kind=irg), intent(in) :: i real(kind=dbl), intent(in) :: xyz (3) Return Value real(kind=dbl)\n  (3) Calls proc~~eshelby_disp~~CallsGraph proc~eshelby_disp Eshelby_disp dasin dasin proc~eshelby_disp->dasin kdelta kdelta proc~eshelby_disp->kdelta Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~eshelby_disp~~CalledByGraph proc~eshelby_disp Eshelby_disp proc~calcr CalcR proc~calcr->proc~eshelby_disp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code Eshelby_disp Source Code recursive function Eshelby_disp ( defects , i , xyz ) result ( u ) !DEC$ ATTRIBUTES DLLEXPORT :: Eshelby_disp ! ! implement the displacement field equations for an isotropic ellipsoidal inclusion ! use local use math IMPLICIT NONE type ( defecttype ), INTENT ( IN ) :: defects integer ( kind = irg ), INTENT ( IN ) :: i real ( kind = dbl ), INTENT ( IN ) :: xyz ( 3 ) real ( kind = dbl ) :: u ( 3 ) integer ( kind = irg ) :: itheta , j , l , k real ( kind = dbl ) :: Treps , r2 ( 3 ), rsq , dd , v , w , modt , lambda , xx , thetaEl , dtheta , sigma , & II1 , II3 , II ( 3 ), IIJ ( 3 , 3 ), phici ( 3 ), psicjli ( 3 , 3 , 3 ), c , t1 , t2 , dt ( 3 ), Delta , EE , EF complex ( kind = dbl ) :: t , s , q Treps = defects % Einclusions ( i )% epsstar ( 1 , 1 ) + defects % Einclusions ( i )% epsstar ( 2 , 2 ) + defects % Einclusions ( i )% epsstar ( 3 , 3 ) r2 = xyz ** 2 rsq = sum ( r2 ) dd = dsqrt ( xyz ( 1 ) ** 2 / defects % Einclusions ( i )% a12 + xyz ( 2 ) ** 2 / defects % Einclusions ( i )% a22 + xyz ( 3 ) ** 2 / defects % Einclusions ( i )% a32 ) !  first we need the lambda value for this point lambda = 0.D0 if ( dd . gt . 1.D0 ) then s = dcmplx ( ( rsq - defects % Einclusions ( i )% eta ) ** 2 + sum ( defects % Einclusions ( i )% svec * r2 ) - defects % Einclusions ( i )% ss1 , 0.D0 ) q = dcmplx ( - 2.D0 * rsq ** 3 - 3.D0 * defects % Einclusions ( i )% eta * rsq ** 2 + rsq * ( 3.D0 * defects % Einclusions ( i )% eta ** 2 + & sum ( defects % Einclusions ( i )% qvec1 * r2 )) - sum ( defects % Einclusions ( i )% qvec2 * r2 ) - defects % Einclusions ( i )% qs1 , 0.D0 ) t = ( q + sqrt ( q * q - 4.D0 * s * s * s ) ) ** ( 1.D0 / 3.D0 ) v = real ( t ) w = abs ( imag ( t )) modt = v ** 2 + w ** 2 lambda = ( rsq - defects % Einclusions ( i )% eta ) / 3.D0 + ( v + defects % Einclusions ( i )% s3 * w ) * & ( 2.D0 * real ( s ) + defects % Einclusions ( i )% c1 * modt ) / defects % Einclusions ( i )% c2 / modt end if ! predefine a couple of parameters dt = ( / defects % Einclusions ( i )% a12 , defects % Einclusions ( i )% a22 , defects % Einclusions ( i )% a32 / ) + lambda Delta = dsqrt ( dt ( 1 ) * dt ( 2 ) * dt ( 3 )) if ( lambda . ne . 0.D0 ) then ! next, we compute the elliptic integrals by interpolating the look-up tables thetaEl = dasin ( dsqrt ( defects % Einclusions ( i )% Deltaij ( 1 , 3 ) ** 2 / dt ( 1 ))) xx = defects % Einclusions ( i )% thpre * ( thetaEl - defects % Einclusions ( i )% mith ) itheta = int ( xx ) + 1 dtheta = xx - int ( xx ) if ( itheta . lt . defects % Einclusions ( i )% nLUT ) then EF = ( 1.D0 - dtheta ) * defects % Einclusions ( i )% EFLUT ( itheta ) + dtheta * defects % Einclusions ( i )% EFLUT ( itheta + 1 ) EE = ( 1.D0 - dtheta ) * defects % Einclusions ( i )% EELUT ( itheta ) + dtheta * defects % Einclusions ( i )% EELUT ( itheta + 1 ) else EF = defects % Einclusions ( i )% EFLUT ( itheta ) EE = defects % Einclusions ( i )% EELUT ( itheta ) end if ! first order integrals II1 = defects % Einclusions ( i )% preI1 * ( EF - EE ) II3 = defects % Einclusions ( i )% preI3 * ( defects % Einclusions ( i )% Deltaij ( 1 , 3 ) * dt ( 2 ) / Delta - EE ) II = ( / II1 , 3.D0 * defects % Einclusions ( i )% V / Delta - II1 - II3 , II3 / ) ! second order integrals IIJ ( 1 , 2 ) = - ( II ( 1 ) - II ( 2 )) / defects % Einclusions ( i )% Deltaij ( 1 , 2 ) ** 2 IIJ ( 2 , 1 ) = IIJ ( 1 , 2 ) IIJ ( 1 , 3 ) = - ( II ( 1 ) - II ( 3 )) / defects % Einclusions ( i )% Deltaij ( 1 , 3 ) ** 2 IIJ ( 3 , 1 ) = IIJ ( 1 , 3 ) IIJ ( 2 , 3 ) = - ( II ( 2 ) - II ( 3 )) / defects % Einclusions ( i )% Deltaij ( 2 , 3 ) ** 2 IIJ ( 3 , 2 ) = IIJ ( 2 , 3 ) IIJ ( 1 , 1 ) = defects % Einclusions ( i )% V / dt ( 1 ) / Delta - ( IIJ ( 1 , 2 ) + IIJ ( 1 , 3 )) / 3.0 IIJ ( 2 , 2 ) = defects % Einclusions ( i )% V / dt ( 2 ) / Delta - ( IIJ ( 2 , 1 ) + IIJ ( 2 , 3 )) / 3.0 IIJ ( 3 , 3 ) = defects % Einclusions ( i )% V / dt ( 3 ) / Delta - ( IIJ ( 3 , 1 ) + IIJ ( 3 , 2 )) / 3.0 else II = defects % Einclusions ( i )% IIinside IIJ = defects % Einclusions ( i )% IIJinside end if ! then we need to evaluate the large number of \"tensor\" components in the phi_{,j} ! and psi_{,jli} arrays, as defined in Muro's 1987 book; we've actually computed the ! derivatives ourselves similar to the computation of eq. (11.40) phici = ( / - xyz ( 1 ) * II ( 1 ), - xyz ( 2 ) * II ( 2 ), - xyz ( 3 ) * II ( 3 ) / ) c = 0.D0 sigma = ( xyz ( 1 ) / dt ( 1 )) ** 2 + ( xyz ( 2 ) / dt ( 2 )) ** 2 + ( xyz ( 3 ) / dt ( 3 )) ** 2 do j = 1 , 3 do l = 1 , 3 do k = 1 , 3 if ( lambda . ne . 0.D0 ) c = 3.D0 * defects % Einclusions ( i )% V * lambda * xyz ( k ) * xyz ( j ) * xyz ( l ) / dt ( k ) / dt ( j ) / dt ( l ) / Delta / sigma t1 = kdelta ( j , l ) * xyz ( k ) * ( II ( k ) - defects % Einclusions ( i )% asq ( j ) * IIJ ( j , k )) t2 = ( kdelta ( k , j ) * xyz ( l ) + kdelta ( k , l ) * xyz ( j )) * ( II ( l ) - defects % Einclusions ( i )% asq ( j ) * IIJ ( j , l )) psicjli ( j , l , k ) = - t1 - t2 + c end do end do end do do k = 1 , 3 ! middle term of Mura eq. (11.30) u ( k ) = - 2.0 * defects % Einclusions ( i )% nu * Treps * phici ( k ) ! last term do l = 1 , 3 u ( k ) = u ( k ) - 4.D0 * ( 1.D0 - defects % Einclusions ( i )% nu ) * defects % Einclusions ( i )% epsstar ( k , l ) * phici ( l ) end do ! first term do j = 1 , 3 do l = 1 , 3 u ( k ) = u ( k ) + defects % Einclusions ( i )% epsstar ( j , l ) * psicjli ( j , l , k ) end do end do end do u = defects % Einclusions ( i )% pre * u end function Eshelby_disp","tags":"","loc":"proc/eshelby_disp.html","title":"Eshelby_disp – Fortran Program"},{"text":"public recursive subroutine InitializeDefects(cell, defects, jsonname, npix, npiy, L, gf, error_cnt, verbose) Uses: local typedefs io JSONsupport proc~~initializedefects~~UsesGraph proc~initializedefects InitializeDefects typedefs typedefs typedefs->proc~initializedefects module~jsonsupport JSONsupport typedefs->module~jsonsupport local local local->proc~initializedefects local->module~jsonsupport module~namelisttypedefs NameListTypedefs local->module~namelisttypedefs module~jsonsupport->proc~initializedefects io io io->proc~initializedefects json_module json_module json_module->module~jsonsupport module~namelisttypedefs->module~jsonsupport iso_fortran_env iso_fortran_env iso_fortran_env->module~jsonsupport Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read defect information, and generate all data that can be precomputed for each defect\n @date  11/22/15 MDG 1.0 original\n @date  11/24/15 MDG 1.1 added Ydislocations, stacking faults, inclusions and voids Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(defecttype), intent(inout) :: defects character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(in) :: npix integer(kind=irg), intent(in) :: npiy real(kind=sgl), intent(in) :: L real(kind=sgl), intent(in) :: gf (3) integer(kind=irg), intent(inout) :: error_cnt logical, intent(in), optional :: verbose Calls proc~~initializedefects~~CallsGraph proc~initializedefects InitializeDefects proc~init_foil_data init_foil_data proc~initializedefects->proc~init_foil_data proc~jsonreaddefectfile JSONreadDefectFile proc~initializedefects->proc~jsonreaddefectfile proc~init_dislocation_data init_dislocation_data proc~initializedefects->proc~init_dislocation_data proc~init_stacking_fault_data init_stacking_fault_data proc~initializedefects->proc~init_stacking_fault_data proc~init_ysh_dislocation_data init_YSH_dislocation_data proc~initializedefects->proc~init_ysh_dislocation_data proc~init_void_data init_void_data proc~initializedefects->proc~init_void_data proc~initializeeshelbyinclusion InitializeEshelbyInclusion proc~initializedefects->proc~initializeeshelbyinclusion writevalue writevalue proc~initializedefects->writevalue proc~init_inclusion_data init_inclusion_data proc~initializedefects->proc~init_inclusion_data message message proc~initializedefects->message proc~init_foil_data->writevalue float float proc~init_foil_data->float qu2om qu2om proc~init_foil_data->qu2om proc~initialize_foil_geometry initialize_foil_geometry proc~init_foil_data->proc~initialize_foil_geometry proc~jsonreaddefectfile->writevalue proc~jsongetdouble JSONgetDouble proc~jsonreaddefectfile->proc~jsongetdouble json_parse json_parse proc~jsonreaddefectfile->json_parse emsoft_tonativepath emsoft_tonativepath proc~jsonreaddefectfile->emsoft_tonativepath proc~jsongetdoublevector JSONgetDoubleVector proc~jsonreaddefectfile->proc~jsongetdoublevector json_print_error_message json_print_error_message proc~jsonreaddefectfile->json_print_error_message json_get_child json_get_child proc~jsonreaddefectfile->json_get_child proc~jsonreadfoildata JSONreadFoilData proc~jsonreaddefectfile->proc~jsonreadfoildata json_get json_get proc~jsonreaddefectfile->json_get fatalerror fatalerror proc~jsonreaddefectfile->fatalerror emsoft_getemdatapathname emsoft_getemdatapathname proc~jsonreaddefectfile->emsoft_getemdatapathname json_failed json_failed proc~jsonreaddefectfile->json_failed json_info json_info proc~jsonreaddefectfile->json_info proc~json_failtest JSON_failtest proc~jsonreaddefectfile->proc~json_failtest json_initialize json_initialize proc~jsonreaddefectfile->json_initialize proc~init_dislocation_data->float proc~makedislocation makedislocation proc~init_dislocation_data->proc~makedislocation proc~init_stacking_fault_data->float proc~makestackingfaultecci makestackingfaultECCI proc~init_stacking_fault_data->proc~makestackingfaultecci proc~makestackingfault makestackingfault proc~init_stacking_fault_data->proc~makestackingfault proc~init_ysh_dislocation_data->float proc~makeyshdislocation makeYSHdislocation proc~init_ysh_dislocation_data->proc~makeyshdislocation proc~init_void_data->float quat_lp quat_lp proc~init_void_data->quat_lp proc~initializeeshelbyinclusion->float el2k el2k proc~initializeeshelbyinclusion->el2k kdelta kdelta proc~initializeeshelbyinclusion->kdelta el1k el1k proc~initializeeshelbyinclusion->el1k dasin dasin proc~initializeeshelbyinclusion->dasin proc~init_inclusion_data->float proc~init_inclusion_data->quat_lp proc~initialize_foil_geometry->writevalue proc~initialize_foil_geometry->message proc~initialize_foil_geometry->float om2qu om2qu proc~initialize_foil_geometry->om2qu quat_mult quat_mult proc~initialize_foil_geometry->quat_mult init_orientation init_orientation proc~initialize_foil_geometry->init_orientation print_orientation print_orientation proc~initialize_foil_geometry->print_orientation normvec normvec proc~initialize_foil_geometry->normvec dcos dcos proc~initialize_foil_geometry->dcos proc~initialize_foil_geometry->quat_lp transspace transspace proc~initialize_foil_geometry->transspace calccross calccross proc~initialize_foil_geometry->calccross dsin dsin proc~initialize_foil_geometry->dsin proc~jsongetdouble->writevalue proc~jsongetdouble->json_get proc~jsongetdoublevector->writevalue proc~jsongetdoublevector->json_get proc~jsonreadfoildata->writevalue proc~jsonreadfoildata->message proc~jsonreadfoildata->proc~jsongetdouble proc~jsonreadfoildata->json_parse proc~jsonreadfoildata->emsoft_tonativepath proc~jsonreadfoildata->proc~jsongetdoublevector proc~jsonreadfoildata->json_print_error_message proc~jsonreadfoildata->json_get_child proc~jsonreadfoildata->emsoft_getemdatapathname proc~jsonreadfoildata->json_failed proc~jsonreadfoildata->json_info proc~jsonreadfoildata->proc~json_failtest calcdot calcdot proc~jsonreadfoildata->calcdot proc~json_failtest->json_print_error_message proc~json_failtest->json_failed proc~makedislocation->qu2om proc~makedislocation->om2qu proc~makedislocation->quat_mult proc~makedislocation->normvec proc~makedislocation->quat_lp proc~makedislocation->transspace proc~makedislocation->calccross printmatrixcd printmatrixcd proc~makedislocation->printmatrixcd print_orientation_d print_orientation_d proc~makedislocation->print_orientation_d minvert minvert proc~makedislocation->minvert zroots zroots proc~makedislocation->zroots cinvert cinvert proc~makedislocation->cinvert init_orientation_d init_orientation_d proc~makedislocation->init_orientation_d transfourthranktensor transfourthranktensor proc~makedislocation->transfourthranktensor printmatrixd printmatrixd proc~makedislocation->printmatrixd calcangle calcangle proc~makedislocation->calcangle proc~makestackingfaultecci->float proc~makestackingfaultecci->normvec proc~makestackingfaultecci->quat_lp proc~makestackingfaultecci->transspace proc~makestackingfaultecci->calccross proc~makestackingfaultecci->calcangle point_inside_polygon point_inside_polygon proc~makestackingfaultecci->point_inside_polygon sgetrf sgetrf proc~makestackingfaultecci->sgetrf sngl sngl proc~makestackingfaultecci->sngl proc~makestackingfaultecci->proc~makeyshdislocation proc~makestackingfault->float proc~makestackingfault->normvec proc~makestackingfault->quat_lp proc~makestackingfault->transspace proc~makestackingfault->calccross proc~makestackingfault->proc~makedislocation proc~makestackingfault->point_inside_polygon proc~makestackingfault->sgetrf proc~makeyshdislocation->writevalue proc~makeyshdislocation->om2qu proc~makeyshdislocation->normvec proc~makeyshdislocation->transspace proc~makeyshdislocation->calccross proc~makeyshdislocation->fatalerror proc~makeyshdislocation->calcdot proc~makeyshdislocation->calcangle calclength calclength proc~makeyshdislocation->calclength var panprocinitializedefectsCallsGraph = svgPanZoom('#procinitializedefectsCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code InitializeDefects Source Code recursive subroutine InitializeDefects ( cell , defects , jsonname , npix , npiy , L , gf , error_cnt , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: InitializeDefects use local use typedefs use io use JSONsupport IMPLICIT NONE type ( unitcell ), pointer :: cell type ( defecttype ), INTENT ( INOUT ) :: defects character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( IN ) :: npix integer ( kind = irg ), INTENT ( IN ) :: npiy real ( kind = sgl ), INTENT ( IN ) :: L real ( kind = sgl ), INTENT ( IN ) :: gf ( 3 ) integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt logical , INTENT ( IN ), OPTIONAL :: verbose integer ( kind = irg ) :: v , i , io_int ( 1 ) error_cnt = 0 v = 0 if ( PRESENT ( verbose )) then if ( verbose ) then v = 1 end if end if defects % numdisl = 0 defects % numYdisl = 0 defects % numsf = 0 defects % numvoids = 0 defects % numinc = 0 defects % numEinc = 0 ! first of all, we need to read all the defect data from the jsonname file, including the foil data call JSONreadDefectFile ( cell , jsonname , defects , error_cnt , verbose ) call Message ( 'The following defects were initialized : ' ) io_int ( 1 ) = defects % numdisl call WriteValue ( '  Number of dislocations       : ' , io_int , 1 ) io_int ( 1 ) = defects % numYdisl call WriteValue ( '  Number of Yoffe dislocations : ' , io_int , 1 ) io_int ( 1 ) = defects % numsf call WriteValue ( '  Number of stacking faults    : ' , io_int , 1 ) io_int ( 1 ) = defects % numinc call WriteValue ( '  Number of inclusions         : ' , io_int , 1 ) io_int ( 1 ) = defects % numEinc call WriteValue ( '  Number of Eshelby inclusions : ' , io_int , 1 ) io_int ( 1 ) = defects % numvoids call WriteValue ( '  Number of voids              : ' , io_int , 1 ) ! once we have this data, we need to initialize all other defect related parameters, including ! things like displacement field parameters etc... ! we begin with the foil itself call init_foil_data ( cell , defects , npix , npiy , L , v ) ! then we add the defects, starting with all the regular dislocations, if any if ( defects % numdisl . ne . 0 ) call init_dislocation_data ( cell , defects , npix , npiy , gf , L , v ) ! then Ydislocations if ( defects % numYdisl . ne . 0 ) call init_YSH_dislocation_data ( cell , defects , npix , npiy , gf , L , v ) ! stacking faults if ( defects % numsf . ne . 0 ) call init_stacking_fault_data ( cell , defects , L , npix , npiy , gf , v ) ! inclusions if ( defects % numinc . ne . 0 ) call init_inclusion_data ( defects , L , npix , npiy , v ) ! Eshelby inclusions if ( defects % numEinc . ne . 0 ) then do i = 1 , defects % numEinc call InitializeEshelbyInclusion ( cell , defects , i , v , L , npix , npiy ) end do end if ! voids if ( defects % numvoids . ne . 0 ) call init_void_data ( defects , L , npix , npiy , v ) end subroutine InitializeDefects","tags":"","loc":"proc/initializedefects.html","title":"InitializeDefects – Fortran Program"},{"text":"public recursive subroutine init_foil_data(cell, defects, npix, npiy, L, dinfo) Uses: crystal io constants files rotations typedefs proc~~init_foil_data~~UsesGraph proc~init_foil_data init_foil_data module~constants constants module~constants->proc~init_foil_data crystal crystal crystal->proc~init_foil_data rotations rotations rotations->proc~init_foil_data io io io->proc~init_foil_data typedefs typedefs typedefs->proc~init_foil_data files files files->proc~init_foil_data local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief  initializes the foil geometry data\n @param cell unit cell pointer\n @param defects defects structure\n @param npix number of x image pixels\n @param npiy number of y image pixels\n @param L pixel size for column approximation\n @param dinfo flag to print information\n @date 11/22/15 MDG 1.0 new routine in Release 3.1; read portion replaced with JSONreadFoilData in JSONsupport Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(defecttype), intent(inout) :: defects integer(kind=irg), intent(in) :: npix integer(kind=irg), intent(in) :: npiy real(kind=sgl), intent(in) :: L integer(kind=irg), intent(in) :: dinfo Calls proc~~init_foil_data~~CallsGraph proc~init_foil_data init_foil_data float float proc~init_foil_data->float qu2om qu2om proc~init_foil_data->qu2om writevalue writevalue proc~init_foil_data->writevalue proc~initialize_foil_geometry initialize_foil_geometry proc~init_foil_data->proc~initialize_foil_geometry proc~initialize_foil_geometry->float proc~initialize_foil_geometry->writevalue om2qu om2qu proc~initialize_foil_geometry->om2qu quat_mult quat_mult proc~initialize_foil_geometry->quat_mult init_orientation init_orientation proc~initialize_foil_geometry->init_orientation print_orientation print_orientation proc~initialize_foil_geometry->print_orientation message message proc~initialize_foil_geometry->message normvec normvec proc~initialize_foil_geometry->normvec dcos dcos proc~initialize_foil_geometry->dcos quat_lp quat_lp proc~initialize_foil_geometry->quat_lp transspace transspace proc~initialize_foil_geometry->transspace calccross calccross proc~initialize_foil_geometry->calccross dsin dsin proc~initialize_foil_geometry->dsin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~init_foil_data~~CalledByGraph proc~init_foil_data init_foil_data proc~initializedefects InitializeDefects proc~initializedefects->proc~init_foil_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code init_foil_data Source Code recursive subroutine init_foil_data ( cell , defects , npix , npiy , L , dinfo ) !DEC$ ATTRIBUTES DLLEXPORT :: init_foil_data use crystal use io use constants use files use rotations use typedefs IMPLICIT NONE type ( unitcell ), pointer :: cell type ( defecttype ), INTENT ( INOUT ) :: defects integer ( kind = irg ), INTENT ( IN ) :: npix , npiy , dinfo real ( kind = sgl ), INTENT ( IN ) :: L real ( kind = sgl ) :: io_real ( 1 ) real ( kind = dbl ) :: amat ( 3 , 3 ) ! assign these values to the appropriate slots in foil%   [verified 4/23/11] defects % foil % alP = defects % foil % alP * cPi / 18 0.0 ! convert the tilt and rotation angles to radians defects % foil % alS = defects % foil % alS * cPi / 18 0.0 defects % foil % alR = defects % foil % alR * cPi / 18 0.0 defects % foil % npix = npix ! image size (this duplicates some values, but it's easier this way) defects % foil % npiy = npiy ! shape parameters defects % foil % cpx = defects % foil % cpx * float ( npix ) * 0.5 * L ! we'll define the foil shape center w.r.t. to the center of the image in [nm] coordinates defects % foil % cpy = defects % foil % cpy * float ( npiy ) * 0.5 * L ! ! initialize a bunch of foil related quantities, using quaternions for all rotations call initialize_foil_geometry ( cell , defects % foil , dinfo ) ! compute the projected thickness amat = qu2om ( defects % foil % a_fm ) defects % foil % zb = defects % foil % z0 / amat ( 3 , 3 ) if ( dinfo . eq . 1 ) then io_real ( 1 ) = defects % foil % z0 call WriteValue ( 'Nominal foil thickness = ' , io_real , 1 , \"(F8.3)\" ) io_real ( 1 ) = defects % foil % zb call WriteValue ( 'Effective foil thickness = ' , io_real , 1 , \"(F8.3/)\" ) end if end subroutine init_foil_data","tags":"","loc":"proc/init_foil_data.html","title":"init_foil_data – Fortran Program"},{"text":"public recursive subroutine init_dislocation_data(cell, defects, DF_npix, DF_npiy, DF_gf, L, dinfo) Uses: io files proc~~init_dislocation_data~~UsesGraph proc~init_dislocation_data init_dislocation_data io io io->proc~init_dislocation_data files files files->proc~init_dislocation_data Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief  init dislocation namelist files\n @param cell unit cell pointer\n @param defects defect structure\n @param DF_npix number of x-pixels\n @param DF_npiy number of y-pixels\n @param DF_gf \n @param L \n @param dinfo logical to trigger verbose output\n @date 01/05/99 MDG 1.0 original\n @date 05/19/01 MDG 2.0 f90 version\n @date 11/27/01 MDG 2.1 added kind support\n @date 06/04/13 MDG 3.0 rewrite\n @date 06/09/14 MDG 4.0 added cell, DL argument\n @date 11/22/15 MDG 4.1 old routine obsolete with Release 3.1; replaced by JsonreadDefectFile\n @date 11/23/15 MDG 4.2 moved from dislocation.f90 to defectmodule.f90 Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(defecttype), intent(inout) :: defects integer(kind=irg), intent(in) :: DF_npix integer(kind=irg), intent(in) :: DF_npiy real(kind=sgl), intent(in) :: DF_gf (3) real(kind=sgl), intent(in) :: L integer(kind=irg), intent(in) :: dinfo Calls proc~~init_dislocation_data~~CallsGraph proc~init_dislocation_data init_dislocation_data float float proc~init_dislocation_data->float proc~makedislocation makedislocation proc~init_dislocation_data->proc~makedislocation printmatrixcd printmatrixcd proc~makedislocation->printmatrixcd om2qu om2qu proc~makedislocation->om2qu transspace transspace proc~makedislocation->transspace print_orientation_d print_orientation_d proc~makedislocation->print_orientation_d minvert minvert proc~makedislocation->minvert zroots zroots proc~makedislocation->zroots quat_mult quat_mult proc~makedislocation->quat_mult calccross calccross proc~makedislocation->calccross cinvert cinvert proc~makedislocation->cinvert init_orientation_d init_orientation_d proc~makedislocation->init_orientation_d transfourthranktensor transfourthranktensor proc~makedislocation->transfourthranktensor qu2om qu2om proc~makedislocation->qu2om quat_lp quat_lp proc~makedislocation->quat_lp printmatrixd printmatrixd proc~makedislocation->printmatrixd calcangle calcangle proc~makedislocation->calcangle normvec normvec proc~makedislocation->normvec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~init_dislocation_data~~CalledByGraph proc~init_dislocation_data init_dislocation_data proc~initializedefects InitializeDefects proc~initializedefects->proc~init_dislocation_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code init_dislocation_data Source Code recursive subroutine init_dislocation_data ( cell , defects , DF_npix , DF_npiy , DF_gf , L , dinfo ) !DEC$ ATTRIBUTES DLLEXPORT :: init_dislocation_data use io use files IMPLICIT NONE type ( defecttype ), INTENT ( INOUT ) :: defects type ( unitcell ), pointer :: cell integer ( kind = irg ), INTENT ( IN ) :: DF_npix , DF_npiy , dinfo real ( kind = sgl ), INTENT ( IN ) :: DF_gf ( 3 ), L integer ( kind = irg ) :: i ! zfrac goes between -0.5 and +0.5, with -0.5 being the top surface and +0.5 the bottom ! this only really matters for dislocations that are parallel to the foil surfaces ! loop over all regular dislocations and initialize their displacement field parameters do i = 1 , defects % numdisl ! +2*defects%numsf   ! we do not deal with partials in stacking faults here ... ! center of dislocation inside the foil is transformed to foil coordinates [nm] with defects%DL(i)%kd=0 (center of foil) [verified 4/23/11] ! the point (0,0) is at the center of the image ... hence the factor of 0.5 defects % DL ( i )% id = defects % DL ( i )% id * 0.5 * float ( DF_npix ) ! * L   scaling (zooming) is done later in the image reference frame... defects % DL ( i )% jd = defects % DL ( i )% jd * 0.5 * float ( DF_npiy ) ! * L defects % DL ( i )% g = DF_gf ! and pre-compute the dislocation displacement field parameters call makedislocation ( cell , defects , i , dinfo , L ) end do end subroutine init_dislocation_data","tags":"","loc":"proc/init_dislocation_data.html","title":"init_dislocation_data – Fortran Program"},{"text":"public recursive subroutine init_stacking_fault_data(cell, defects, DF_L, DF_npix, DF_npiy, DF_g, dinfo, ECCI) Uses: io files proc~~init_stacking_fault_data~~UsesGraph proc~init_stacking_fault_data init_stacking_fault_data io io io->proc~init_stacking_fault_data files files files->proc~init_stacking_fault_data Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief  read stacking fault namelist files\n @param cell unit cell pointer\n @param defects defect structure\n @param DF_L \n @param DF_npix number of x-pixels\n @param DF_npiy number of y-pixels\n @param DF_gf \n @param dinfo logical to trigger verbose output\n @param ECCI logical optional to indicate ECCI formatting rather than regular TEM\n @date    1/5/99  MDG 1.0 original\n @date    5/19/01 MDG 2.0 f90 version\n @date   11/27/01 MDG 2.1 added kind support\n @date   06/04/13 MDG 3.0 rewrite\n @date   12/17/13 MDG 3.1 added ECCI mode\n @date   06/09/14 MDG 4.0 added cell, defects arguments\n @date   06/10/14 MDG 4.1 added foil argument Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(defecttype), intent(inout) :: defects real(kind=sgl), intent(in) :: DF_L integer(kind=irg), intent(in) :: DF_npix integer(kind=irg), intent(in) :: DF_npiy real(kind=sgl), intent(in) :: DF_g (3) integer(kind=irg), intent(in) :: dinfo logical, intent(in), optional :: ECCI Calls proc~~init_stacking_fault_data~~CallsGraph proc~init_stacking_fault_data init_stacking_fault_data float float proc~init_stacking_fault_data->float proc~makestackingfaultecci makestackingfaultECCI proc~init_stacking_fault_data->proc~makestackingfaultecci proc~makestackingfault makestackingfault proc~init_stacking_fault_data->proc~makestackingfault proc~makestackingfaultecci->float transspace transspace proc~makestackingfaultecci->transspace point_inside_polygon point_inside_polygon proc~makestackingfaultecci->point_inside_polygon sgetrf sgetrf proc~makestackingfaultecci->sgetrf calcangle calcangle proc~makestackingfaultecci->calcangle sngl sngl proc~makestackingfaultecci->sngl quat_lp quat_lp proc~makestackingfaultecci->quat_lp proc~makeyshdislocation makeYSHdislocation proc~makestackingfaultecci->proc~makeyshdislocation calccross calccross proc~makestackingfaultecci->calccross normvec normvec proc~makestackingfaultecci->normvec proc~makestackingfault->float proc~makestackingfault->transspace proc~makestackingfault->point_inside_polygon proc~makestackingfault->sgetrf proc~makestackingfault->quat_lp proc~makestackingfault->calccross proc~makestackingfault->normvec proc~makedislocation makedislocation proc~makestackingfault->proc~makedislocation proc~makeyshdislocation->transspace proc~makeyshdislocation->calcangle proc~makeyshdislocation->calccross proc~makeyshdislocation->normvec om2qu om2qu proc~makeyshdislocation->om2qu calcdot calcdot proc~makeyshdislocation->calcdot calclength calclength proc~makeyshdislocation->calclength fatalerror fatalerror proc~makeyshdislocation->fatalerror writevalue writevalue proc~makeyshdislocation->writevalue proc~makedislocation->transspace proc~makedislocation->calcangle proc~makedislocation->quat_lp proc~makedislocation->calccross proc~makedislocation->normvec proc~makedislocation->om2qu printmatrixcd printmatrixcd proc~makedislocation->printmatrixcd print_orientation_d print_orientation_d proc~makedislocation->print_orientation_d minvert minvert proc~makedislocation->minvert zroots zroots proc~makedislocation->zroots quat_mult quat_mult proc~makedislocation->quat_mult cinvert cinvert proc~makedislocation->cinvert init_orientation_d init_orientation_d proc~makedislocation->init_orientation_d transfourthranktensor transfourthranktensor proc~makedislocation->transfourthranktensor qu2om qu2om proc~makedislocation->qu2om printmatrixd printmatrixd proc~makedislocation->printmatrixd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~init_stacking_fault_data~~CalledByGraph proc~init_stacking_fault_data init_stacking_fault_data proc~initializedefects InitializeDefects proc~initializedefects->proc~init_stacking_fault_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code init_stacking_fault_data Source Code recursive subroutine init_stacking_fault_data ( cell , defects , DF_L , DF_npix , DF_npiy , DF_g , dinfo , ECCI ) !DEC$ ATTRIBUTES DLLEXPORT :: init_stacking_fault_data use io use files IMPLICIT NONE type ( unitcell ), pointer :: cell type ( defecttype ), INTENT ( INOUT ) :: defects integer ( kind = irg ), INTENT ( IN ) :: DF_npix , DF_npiy , dinfo real ( kind = sgl ), INTENT ( IN ) :: DF_g ( 3 ) real ( kind = sgl ), INTENT ( IN ) :: DF_L logical , INTENT ( IN ), OPTIONAL :: ECCI integer ( kind = irg ) :: i real ( kind = sgl ) :: poisson ! read the namelist files for all of the stacking faults do i = 1 , defects % numsf !   SFR = (/ 0.0, 0.0, 0.0 /) poisson = 0.0 ! transform the fault fractional coordinates to nm in the image reference frame defects % SF ( i )% id = defects % SF ( i )% id * 0.5 * float ( DF_npix ) ! * DF_L  (zooming is done later in the image reference frame) defects % SF ( i )% jd = defects % SF ( i )% jd * 0.5 * float ( DF_npiy ) ! * DF_L defects % SF ( i )% poisson = poisson !   if (sum(abs(SFR)).eq.0.0) then defects % SF ( i )% Rdisp = defects % SF ( i )% lpb !   else !     defects%SF(i)%Rdisp = SFR !   end if ! initialize the stacking fault variables and both partial dislocations; this might depend ! on the imaging mode (TEM vs. ECCI); careful here, since the counting of dislocations has ! changed with respect to release 2.0 !!! if ( present ( ECCI )) then call makestackingfaultECCI ( cell , defects , i , DF_L , DF_npix , DF_npiy , DF_g , dinfo ) defects % numYdisl = defects % numYdisl + 2 else call makestackingfault ( cell , defects , i , DF_L , DF_npix , DF_npiy , DF_g , dinfo ) defects % numdisl = defects % numdisl + 2 end if end do end subroutine init_stacking_fault_data","tags":"","loc":"proc/init_stacking_fault_data.html","title":"init_stacking_fault_data – Fortran Program"},{"text":"public recursive subroutine init_YSH_dislocation_data(cell, defects, DF_npix, DF_npiy, DF_gf, L, dinfo) Uses: io files proc~~init_ysh_dislocation_data~~UsesGraph proc~init_ysh_dislocation_data init_YSH_dislocation_data io io io->proc~init_ysh_dislocation_data files files files->proc~init_ysh_dislocation_data Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief init Yoffe dislocation \n @param cell unit cell pointer\n @param defects defects structure\n @param DF_npix number of x-pixels\n @param DF_npiy number of y-pixels\n @param DF_gf \n @param L \n @param dinfo logical to trigger verbose output\n @date  1/5/99  MDG 1.0 original\n @date  5/19/01 MDG 2.0 f90 version\n @date 11/27/01 MDG 2.1 added kind support\n @date 03/25/13 MDG 3.0 updated IO\n @date 11/21/13 MDG 3.1 verification\n @date 06/10/14 MDG 4.0 added defects, cell and foil arguments\n @date 11/23/15 MDG 4.1 made foil part of defects Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(defecttype), intent(inout) :: defects integer(kind=irg), intent(in) :: DF_npix integer(kind=irg), intent(in) :: DF_npiy real(kind=sgl), intent(in) :: DF_gf (3) real(kind=sgl), intent(in) :: L integer(kind=irg), intent(in) :: dinfo Calls proc~~init_ysh_dislocation_data~~CallsGraph proc~init_ysh_dislocation_data init_YSH_dislocation_data float float proc~init_ysh_dislocation_data->float proc~makeyshdislocation makeYSHdislocation proc~init_ysh_dislocation_data->proc~makeyshdislocation om2qu om2qu proc~makeyshdislocation->om2qu normvec normvec proc~makeyshdislocation->normvec calcdot calcdot proc~makeyshdislocation->calcdot calcangle calcangle proc~makeyshdislocation->calcangle calclength calclength proc~makeyshdislocation->calclength fatalerror fatalerror proc~makeyshdislocation->fatalerror writevalue writevalue proc~makeyshdislocation->writevalue calccross calccross proc~makeyshdislocation->calccross transspace transspace proc~makeyshdislocation->transspace Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~init_ysh_dislocation_data~~CalledByGraph proc~init_ysh_dislocation_data init_YSH_dislocation_data proc~initializedefects InitializeDefects proc~initializedefects->proc~init_ysh_dislocation_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code init_YSH_dislocation_data Source Code recursive subroutine init_YSH_dislocation_data ( cell , defects , DF_npix , DF_npiy , DF_gf , L , dinfo ) !DEC$ ATTRIBUTES DLLEXPORT :: init_YSH_dislocation_data use io use files IMPLICIT NONE type ( unitcell ), pointer :: cell type ( defecttype ), INTENT ( INOUT ) :: defects integer ( kind = irg ), INTENT ( IN ) :: DF_npix , DF_npiy , dinfo real ( kind = sgl ), INTENT ( IN ) :: DF_gf ( 3 ), L integer ( kind = irg ) :: i real ( kind = sgl ) :: id , jd , u ( 3 ), bv ( 3 ), poisson ! these are just the individual dislocations; the ones that belong to ! stacking faults are handled separately do i = 1 , defects % numYdisl ! top-of-the-foil intersection of dislocation line is transformed to foil coordinates [nm] with DL(i)%kd=0 (center of foil) [verified 4/23/11] ! the point (0,0) is at the center of the image ... hence the factor of 0.5 defects % YD ( i )% id = defects % YD ( i )% id * 0.5 * float ( DF_npix ) ! * L   scaling (zooming) is done later in the image reference frame... defects % YD ( i )% jd = defects % YD ( i )% jd * 0.5 * float ( DF_npiy ) ! * L defects % YD ( i )% g = DF_gf ! and pre-compute the dislocation displacement field parameters call makeYSHdislocation ( cell , defects , i , dinfo , L ) end do end subroutine init_YSH_dislocation_data","tags":"","loc":"proc/init_ysh_dislocation_data.html","title":"init_YSH_dislocation_data – Fortran Program"},{"text":"public recursive subroutine init_void_data(defects, DF_L, DF_npix, DF_npiy, dinfo) Uses: io files proc~~init_void_data~~UsesGraph proc~init_void_data init_void_data io io io->proc~init_void_data files files files->proc~init_void_data Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief  init void parameters \n @param defects defects structure\n @param DF_L column edge length \n @param DF_npix number of x-pixels\n @param DF_npiy number of y-pixels\n @param dinfo logical to trigger verbose output\n @date 01/05/99 MDG 1.0 original\n @date 05/19/01 MDG 2.0 f90 version\n @date 11/27/01 MDG 2.1 added kind support\n @date 03/25/13 MDG 3.0 updated IO\n @date 06/09/14 MDG 4.0 added defects argument\n @date 06/10/14 MDG 4.1 added foil argument\n @date 11/23/15 MDG 4.2 removed foil and put it inside defects Arguments Type Intent Optional Attributes Name type(defecttype), intent(inout) :: defects real(kind=sgl), intent(in) :: DF_L integer(kind=irg), intent(in) :: DF_npix integer(kind=irg), intent(in) :: DF_npiy integer(kind=irg), intent(in) :: dinfo Calls proc~~init_void_data~~CallsGraph proc~init_void_data init_void_data float float proc~init_void_data->float quat_lp quat_lp proc~init_void_data->quat_lp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~init_void_data~~CalledByGraph proc~init_void_data init_void_data proc~initializedefects InitializeDefects proc~initializedefects->proc~init_void_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code init_void_data Source Code recursive subroutine init_void_data ( defects , DF_L , DF_npix , DF_npiy , dinfo ) !DEC$ ATTRIBUTES DLLEXPORT :: init_void_data use io use files IMPLICIT NONE type ( defecttype ), INTENT ( INOUT ) :: defects integer ( kind = irg ), INTENT ( IN ) :: dinfo , DF_npix , DF_npiy real ( kind = sgl ), INTENT ( IN ) :: DF_L integer ( kind = irg ) :: i real ( kind = sgl ) :: tmp ( 3 ) ! read each subsequent line do i = 1 , defects % numvoids defects % voids ( i )% xpos = defects % voids ( i )% xpos * 0.5 * float ( DF_npix ) * DF_L defects % voids ( i )% ypos = defects % voids ( i )% ypos * 0.5 * float ( DF_npiy ) * DF_L defects % voids ( i )% zpos = defects % voids ( i )% zpos * defects % foil % z0 ! transform to the foil reference frame tmp = quat_Lp ( conjg ( defects % foil % a_fc ), dble (( / defects % voids ( i )% xpos , defects % voids ( i )% ypos , defects % voids ( i )% zpos / )) ) defects % voids ( i )% xpos = tmp ( 1 ) defects % voids ( i )% ypos = tmp ( 2 ) defects % voids ( i )% zpos = tmp ( 3 ) if ( dinfo . eq . 1 ) write ( * , * ) i , defects % voids ( i )% xpos , defects % voids ( i )% ypos , defects % voids ( i )% zpos , defects % voids ( i )% radius end do end subroutine init_void_data","tags":"","loc":"proc/init_void_data.html","title":"init_void_data – Fortran Program"},{"text":"public recursive subroutine init_inclusion_data(defects, DF_L, DF_npix, DF_npiy, dinfo) Uses: io files proc~~init_inclusion_data~~UsesGraph proc~init_inclusion_data init_inclusion_data io io io->proc~init_inclusion_data files files files->proc~init_inclusion_data Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief  init inclusion parameters \n @param defects defect structure\n @param DF_L column edge length \n @param DF_npix number of x-pixels\n @param DF_npiy number of y-pixels\n @param dinfo logical to trigger verbose output\n @date  01/05/99 MDG 1.0 original\n @date  05/19/01 MDG 2.0 f90 version\n @date  11/27/01 MDG 2.1 added kind support\n @date  03/25/13 MDG 3.0 updated IO\n @date  06/09/14 MDG 4.0 added defects argument\n @date  06/10/14 MDG 4.1 added foil argument\n @date  11/23/15 MDG 4.2 made foil part of defects Arguments Type Intent Optional Attributes Name type(defecttype), intent(inout) :: defects real(kind=sgl), intent(in) :: DF_L integer(kind=irg), intent(in) :: DF_npix integer(kind=irg), intent(in) :: DF_npiy integer(kind=irg), intent(in) :: dinfo Calls proc~~init_inclusion_data~~CallsGraph proc~init_inclusion_data init_inclusion_data float float proc~init_inclusion_data->float quat_lp quat_lp proc~init_inclusion_data->quat_lp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~init_inclusion_data~~CalledByGraph proc~init_inclusion_data init_inclusion_data proc~initializedefects InitializeDefects proc~initializedefects->proc~init_inclusion_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code init_inclusion_data Source Code recursive subroutine init_inclusion_data ( defects , DF_L , DF_npix , DF_npiy , dinfo ) !DEC$ ATTRIBUTES DLLEXPORT :: init_inclusion_data use io use files IMPLICIT NONE type ( defecttype ), INTENT ( INOUT ) :: defects integer ( kind = irg ), INTENT ( IN ) :: dinfo , DF_npix , DF_npiy real ( kind = sgl ), INTENT ( IN ) :: DF_L integer ( kind = irg ) :: i real ( kind = sgl ) :: tmp ( 3 ) ! read each subsequent line do i = 1 , defects % numinc defects % inclusions ( i )% xpos = defects % inclusions ( i )% xpos * 0.5 * float ( DF_npix ) * DF_L defects % inclusions ( i )% ypos = defects % inclusions ( i )% ypos * 0.5 * float ( DF_npiy ) * DF_L defects % inclusions ( i )% zpos = defects % inclusions ( i )% zpos * defects % foil % z0 ! vertical fractional location in interval [-1,1] tmp = quat_Lp ( conjg ( defects % foil % a_fc ), dble (( / defects % inclusions ( i )% xpos , defects % inclusions ( i )% ypos , & defects % inclusions ( i )% zpos / )) ) defects % inclusions ( i )% xpos = tmp ( 1 ) defects % inclusions ( i )% ypos = tmp ( 2 ) defects % inclusions ( i )% zpos = tmp ( 3 ) if ( dinfo . eq . 1 ) write ( * , * ) i , defects % inclusions ( i )% xpos , defects % inclusions ( i )% ypos , defects % inclusions ( i )% zpos , & defects % inclusions ( i )% radius , defects % inclusions ( i )% C end do end subroutine init_inclusion_data","tags":"","loc":"proc/init_inclusion_data.html","title":"init_inclusion_data – Fortran Program"},{"text":"public recursive subroutine init_Einclusion_data(cell, defects, DF_L, DF_npix, DF_npiy, dinfo) Uses: io files proc~~init_einclusion_data~~UsesGraph proc~init_einclusion_data init_Einclusion_data io io io->proc~init_einclusion_data files files files->proc~init_einclusion_data Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief  init inclusion parameters \n @param cell cell structure pointer\n @param defects defect structure\n @param DF_L column edge length \n @param DF_npix number of x-pixels\n @param DF_npiy number of y-pixels\n @param dinfo logical to trigger verbose output\n @date  01/05/99 MDG 1.0 original\n @date  05/19/01 MDG 2.0 f90 version\n @date  11/27/01 MDG 2.1 added kind support\n @date  03/25/13 MDG 3.0 updated IO\n @date  06/09/14 MDG 4.0 added defects argument\n @date  06/10/14 MDG 4.1 added foil argument\n @date  11/23/15 MDG 4.2 made foil part of defects\n @date  12/08/15 MDG 4.3 forked from init_inclusion_data\n @date  12/11/15 MDG 4.4 reworked based on IDL ellipsoid.pro script Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(defecttype), intent(inout) :: defects real(kind=sgl), intent(in) :: DF_L integer(kind=irg), intent(in) :: DF_npix integer(kind=irg), intent(in) :: DF_npiy integer(kind=irg), intent(in) :: dinfo Calls proc~~init_einclusion_data~~CallsGraph proc~init_einclusion_data init_Einclusion_data float float proc~init_einclusion_data->float proc~initializeeshelbyinclusion InitializeEshelbyInclusion proc~init_einclusion_data->proc~initializeeshelbyinclusion quat_lp quat_lp proc~init_einclusion_data->quat_lp proc~initializeeshelbyinclusion->float el2k el2k proc~initializeeshelbyinclusion->el2k kdelta kdelta proc~initializeeshelbyinclusion->kdelta el1k el1k proc~initializeeshelbyinclusion->el1k dasin dasin proc~initializeeshelbyinclusion->dasin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code init_Einclusion_data Source Code recursive subroutine init_Einclusion_data ( cell , defects , DF_L , DF_npix , DF_npiy , dinfo ) !DEC$ ATTRIBUTES DLLEXPORT :: init_Einclusion_data use io use files IMPLICIT NONE type ( unitcell ), pointer :: cell type ( defecttype ), INTENT ( INOUT ) :: defects integer ( kind = irg ), INTENT ( IN ) :: dinfo , DF_npix , DF_npiy real ( kind = sgl ), INTENT ( IN ) :: DF_L integer ( kind = irg ) :: i real ( kind = sgl ) :: tmp ( 3 ) ! read each subsequent line do i = 1 , defects % numEinc defects % Einclusions ( i )% xpos = defects % Einclusions ( i )% xyz ( 1 ) * 0.5 * float ( DF_npix ) * DF_L defects % Einclusions ( i )% ypos = defects % Einclusions ( i )% xyz ( 2 ) * 0.5 * float ( DF_npiy ) * DF_L defects % Einclusions ( i )% zpos = defects % Einclusions ( i )% xyz ( 3 ) * defects % foil % z0 ! vertical fractional location in interval [-1,1] tmp = quat_Lp ( conjg ( defects % foil % a_fc ), dble (( / defects % Einclusions ( i )% xpos , defects % Einclusions ( i )% ypos , & defects % Einclusions ( i )% zpos / )) ) defects % Einclusions ( i )% xpos = tmp ( 1 ) defects % Einclusions ( i )% ypos = tmp ( 2 ) defects % Einclusions ( i )% zpos = tmp ( 3 ) ! here we call the initialization routine to compute a series of arrays ! and look-up tables for elliptic integrals call InitializeEshelbyInclusion ( cell , defects , i , dinfo , DF_L , DF_npix , DF_npiy ) if ( dinfo . eq . 1 ) write ( * , * ) i , defects % Einclusions ( i )% xpos , defects % Einclusions ( i )% ypos , defects % Einclusions ( i )% zpos end do end subroutine init_Einclusion_data","tags":"","loc":"proc/init_einclusion_data.html","title":"init_Einclusion_data – Fortran Program"},{"text":"public recursive subroutine initialize_foil_geometry(cell, foil, dinfo) Uses: local typedefs math constants crystal symmetry io rotations proc~~initialize_foil_geometry~~UsesGraph proc~initialize_foil_geometry initialize_foil_geometry io io io->proc~initialize_foil_geometry module~constants constants module~constants->proc~initialize_foil_geometry crystal crystal crystal->proc~initialize_foil_geometry symmetry symmetry symmetry->proc~initialize_foil_geometry rotations rotations rotations->proc~initialize_foil_geometry math math math->proc~initialize_foil_geometry typedefs typedefs typedefs->proc~initialize_foil_geometry local local local->proc~initialize_foil_geometry local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief  Initializes the foil geometry\n @details This new implementation uses quaternions for all rotations. \n @param cell unit cell pointer\n @param dinfo\n @date  1/ 5/99 MDG 1.0 original\n @date  1/11/10 MDG 2.0 rewrite of beam direction part\n @date  3/28/11 MDG 2.1 code verified\n @date  4/23/11 MDG 2.2 redefined origin to be at center of image\n @date  6/03/13 MDG 3.0 replaced rotation matrices by quaternions throughout\n @date 10/30/13 MDG 3.1 complete debug of quaternion and rotation implementation \n @date 06/09/14 MDG 4.0 added cell and foil as argument Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(foiltype), intent(inout) :: foil integer(kind=sgl), intent(in) :: dinfo Calls proc~~initialize_foil_geometry~~CallsGraph proc~initialize_foil_geometry initialize_foil_geometry writevalue writevalue proc~initialize_foil_geometry->writevalue om2qu om2qu proc~initialize_foil_geometry->om2qu quat_mult quat_mult proc~initialize_foil_geometry->quat_mult float float proc~initialize_foil_geometry->float init_orientation init_orientation proc~initialize_foil_geometry->init_orientation print_orientation print_orientation proc~initialize_foil_geometry->print_orientation message message proc~initialize_foil_geometry->message normvec normvec proc~initialize_foil_geometry->normvec dcos dcos proc~initialize_foil_geometry->dcos quat_lp quat_lp proc~initialize_foil_geometry->quat_lp transspace transspace proc~initialize_foil_geometry->transspace calccross calccross proc~initialize_foil_geometry->calccross dsin dsin proc~initialize_foil_geometry->dsin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~initialize_foil_geometry~~CalledByGraph proc~initialize_foil_geometry initialize_foil_geometry proc~init_foil_data init_foil_data proc~init_foil_data->proc~initialize_foil_geometry proc~initializedefects InitializeDefects proc~initializedefects->proc~init_foil_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code initialize_foil_geometry Source Code recursive subroutine initialize_foil_geometry ( cell , foil , dinfo ) !DEC$ ATTRIBUTES DLLEXPORT :: initialize_foil_geometry use local use typedefs use math use constants use crystal use symmetry use io use rotations IMPLICIT NONE type ( unitcell ), pointer :: cell type ( foiltype ), INTENT ( INOUT ) :: foil integer ( kind = sgl ), INTENT ( IN ) :: dinfo real ( kind = dbl ) :: ey ( 3 ), ex ( 3 ), tt , dx , dy real ( kind = sgl ) :: io_real ( 3 ) real ( kind = dbl ) :: cp , sp , cs , ss , cr , sr , ca , sa , a_fc ( 3 , 3 ) integer ( kind = irg ) :: i , j type ( orientationtyped ) :: ot character ( 10 ) :: pret ! determine the foil-to-microscope transformations [verified on 4/23/11, converted to quaternions on 6/4/13, ! verified 10/30/13, and again on 11/11/13 after some changes elsewhere] if ( foil % alR . eq . 0.D0 ) then ! the double tilt holder transformation a_fm; note quaternions, hence we need the half-angles ! ! a_fm transforms a vector v FROM the microscope reference frame To the foil reference frame ! using the quat_rotate_vector routine. cp = dcos ( foil % alP * 0.5D0 ) sp = dsin ( foil % alP * 0.5D0 ) ca = dcos ( foil % alP ) sa = dsin ( foil % alP ) cs = dcos ( foil % alS * 0.5D0 ) ss = dsin ( foil % alS * 0.5D0 ) foil % a_fm = conjg ( quat_mult ( ( / cs , 0.D0 , ss * ca , ss * sa / ), ( / cp , sp , 0.D0 , 0.D0 / ) ) ) else ! the rotation tilt holder transformation a_fm [verified on 4/23/11, converted to quaternions on 6/4/13, ! and again on 11/11/13 after changes elsewhere] cp = dcos ( foil % alP * 0.5D0 ) sp = dsin ( foil % alP * 0.5D0 ) cr = dcos ( foil % alR * 0.5D0 ) sr = dsin ( foil % alR * 0.5D0 ) ca = dcos ( foil % alP ) sa = dsin ( foil % alP ) foil % a_fm = conjg ( quat_mult ( ( / cr , 0.D0 , - sr * sa , sr * ca / ), ( / cp , sp , 0.D0 , 0.D0 / ) ) ) end if if ( dinfo . eq . 1 ) then pret = 'a_fm: ' ot = init_orientation ( foil % a_fm , 'qu' ) call print_orientation ( ot , 'om' , pret ) end if ! a_mi (image to microscope) apart from a scale factor, these two are identical ! The EM book uses a beta rotation angle between the image and the microscope, ! but that is really not necessary because we already fix the image with respect to ! the microscope by defining q (the horizontal image direction) to point to the ! airlock. [verified 4/23/11, converted to quaternions on 6/4/13] ! So we'll keep this transformation equal to the identity at all times. foil % a_mi = ( / 1.D0 , 0.D0 , 0.D0 , 0.D0 / ) ! identity quaternion if ( dinfo . eq . 1 ) then pret = 'a_mi: ' ot = init_orientation ( foil % a_mi , 'qu' ) call print_orientation ( ot , 'om' , pret ) end if ! This allows us to get the beam direction, since we know the foil normal and tilt angles ! The beam direction is the inverse transform of the microscope e_z-axis to the foil reference frame [verified 11/12/13] foil % B = quat_Lp ( conjg ( foil % a_fm ), ( / 0.D0 , 0.D0 , - 1.D0 / ) ) foil % Bn = foil % B call NormVec ( cell , foil % Bn , 'c' ) if ( dinfo . eq . 1 ) then io_real ( 1 : 3 ) = foil % B ( 1 : 3 ) call WriteValue ( '  Beam direction (foil reference frame) = ' , io_real , 3 , \"('[',F12.5,',',F12.5,',',F12.5,']')\" ) end if ! transform both the foil normal and the q-vector to the crystal cartesian reference frame (eq. 8.8) [verified 4/23/11, ! and again on 11/12/13 afterchanges elsewhere] call TransSpace ( cell , foil % F , foil % Fn , 'd' , 'c' ) call TransSpace ( cell , foil % q , foil % qn , 'r' , 'c' ) call NormVec ( cell , foil % Fn , 'c' ) call NormVec ( cell , foil % qn , 'c' ) ! a_fc (crystal to foil) a_fc ( 3 , 1 : 3 ) = foil % Fn ( 1 : 3 ) a_fc ( 1 , 1 : 3 ) = foil % qn ( 1 : 3 ) call CalcCross ( cell , foil % Fn , foil % qn , ey , 'c' , 'c' , 0 ) call NormVec ( cell , ey , 'c' ) a_fc ( 2 , 1 : 3 ) = ey ( 1 : 3 ) foil % a_fc = om2qu ( a_fc ) if ( dinfo . eq . 1 ) then pret = 'a_fc: ' ot = init_orientation ( foil % a_fc , 'qu' ) call print_orientation ( ot , 'om' , pret ) end if ! a_mc (crystal to microscope) foil % a_mc = quat_mult ( conjg ( foil % a_fm ), foil % a_fc ) if ( dinfo . eq . 1 ) then pret = 'a_mc: ' ot = init_orientation ( foil % a_mc , 'qu' ) call print_orientation ( ot , 'om' , pret ) end if ! a_ic (crystal to image) foil % a_ic = quat_mult ( conjg ( foil % a_mi ) , foil % a_mc ) if ( dinfo . eq . 1 ) then pret = 'a_ic: ' ot = init_orientation ( foil % a_ic , 'qu' ) call print_orientation ( ot , 'om' , pret ) end if ! a_fi (image to foil) foil % a_fi = quat_mult ( foil % a_fc , conjg ( foil % a_ic ) ) if ( dinfo . eq . 1 ) then pret = 'a_fi: ' ot = init_orientation ( foil % a_fi , 'qu' ) call print_orientation ( ot , 'om' , pret ) end if ! express the beam direction in the Bravais reference frame [verified 4/23/11, and again on 11/12/13 ! after changes elsewhere] ex = quat_Lp ( conjg ( foil % a_fc ), dble ( foil % Bn ) ) call TransSpace ( cell , ex , ey , 'c' , 'd' ) call NormVec ( cell , ey , 'c' ) if ( dinfo . eq . 1 ) then io_real ( 1 : 3 ) = ey ( 1 : 3 ) call WriteValue ( '  Beam direction (crystal reference frame) = ' , io_real , 3 , \"('[',F12.5,',',F12.5,',',F12.5,']'/)\" ) end if ! define the foil shape (for now as an elliptic paraboloid z = brx * (x-xc)&#94;2 + bry * (y-yc)&#94;2) if (. not . allocated ( foil % sg )) allocate ( foil % sg ( foil % npix , foil % npiy )) ! if the foil is not bent, then we set this array to zero, otherwise we compute the elliptical paraboloid if (( foil % brx . eq . 0.0 ). and .( foil % bry . eq . 0.0 )) then if ( dinfo . eq . 1 ) then call Message ( ' Initializing a flat foil ' , frm = \"(A)\" ) end if foil % sg = 0.0 else dx = foil % npix * 0.5 dy = foil % npiy * 0.5 do i = 1 , foil % npix tt = foil % brx * ( float ( i ) - dx - foil % cpx ) ** 2 do j = 1 , foil % npiy ! initialize the foil shape function; we assume that the center of the elliptic paraboloid is at location (cpx,cpy) ! presumably, this surface could also be a saddle point if the brx and bry values have opposite sign ... foil % sg ( i , j ) = tt + foil % bry * ( float ( j ) - dy - foil % cpy ) ** 2 + 2.0 * foil % brxy * ( float ( j ) - dy - foil % cpy ) * ( float ( i ) - dx - foil % cpx ) end do end do if ( dinfo . eq . 1 ) then call Message ( ' Initializing a bent foil ' , frm = \"(A)\" ) io_real ( 1 ) = minval ( foil % sg ); io_real ( 2 ) = maxval ( foil % sg ); call WriteValue ( 'Range of local excitation error deviations : ' , io_real , 2 , \"(F10.6,',',F10.6/)\" ) end if end if end subroutine initialize_foil_geometry","tags":"","loc":"proc/initialize_foil_geometry.html","title":"initialize_foil_geometry – Fortran Program"},{"text":"public recursive subroutine makedislocation(cell, defects, inum, dinfo, DF_L) Uses: math constants crystal math io symmetry rotations proc~~makedislocation~~UsesGraph proc~makedislocation makedislocation module~constants constants module~constants->proc~makedislocation io io io->proc~makedislocation symmetry symmetry symmetry->proc~makedislocation rotations rotations rotations->proc~makedislocation crystal crystal crystal->proc~makedislocation math math math->proc~makedislocation local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief  Compute the dismat displacement matrix for a given dislocation\n @details This subroutine computes the matrix dismat that describes the displacement field\n of a dislocation.  The routine needs the elastic moduli tensor, the transformation\n matrix between the crystal and dislocation reference frames, and the dislocation\n Burgers vector.  The routine computes the arrays dismat and pa, which should be used as follows: R_k = 2.0 real([ sum_a=1&#94;3 (dismat(k,a) log(Z_a)) ]), with Z_a = x_1 + pa(a)*x_2 [see CalcR subroutine for more information] We must also make sure that the x=0 plane of the defect reference frame contains the \n incident beam direction, to avoid getting stacking-fault fringes in the wrong plane...\n Actual stacking faults are added in using a different module (stacking_fault.f90). @param cell unit cell pointer\n @param defects defect structure\n @param inum\n @param dinfo\n @param DF_L column width\n @date   1/ 5/99 MDG 1.0 original\n @date   5/19/01 MDG 2.0 f90 version\n @date  11/27/01 MDG 2.1 added kind support\n @date  06/04/13 MDG 3.0 rewrite\n @date  10/30/13 MDG 3.1 debug of all rotation parts\n @date  06/09/14 MDG 4.0 added cell, defects arguments\n @date  06/10/14 MDG 4.1 added foil as argument\n @date  11/21/15 MDG 4.2 moved foil into defects structure Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(defecttype), intent(inout) :: defects integer(kind=irg), intent(in) :: inum integer(kind=irg), intent(in) :: dinfo real(kind=sgl), intent(in) :: DF_L Calls proc~~makedislocation~~CallsGraph proc~makedislocation makedislocation printmatrixcd printmatrixcd proc~makedislocation->printmatrixcd om2qu om2qu proc~makedislocation->om2qu transspace transspace proc~makedislocation->transspace print_orientation_d print_orientation_d proc~makedislocation->print_orientation_d minvert minvert proc~makedislocation->minvert zroots zroots proc~makedislocation->zroots quat_mult quat_mult proc~makedislocation->quat_mult calccross calccross proc~makedislocation->calccross cinvert cinvert proc~makedislocation->cinvert init_orientation_d init_orientation_d proc~makedislocation->init_orientation_d transfourthranktensor transfourthranktensor proc~makedislocation->transfourthranktensor qu2om qu2om proc~makedislocation->qu2om quat_lp quat_lp proc~makedislocation->quat_lp printmatrixd printmatrixd proc~makedislocation->printmatrixd calcangle calcangle proc~makedislocation->calcangle normvec normvec proc~makedislocation->normvec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~makedislocation~~CalledByGraph proc~makedislocation makedislocation proc~init_dislocation_data init_dislocation_data proc~init_dislocation_data->proc~makedislocation proc~makestackingfault makestackingfault proc~makestackingfault->proc~makedislocation proc~initializedefects InitializeDefects proc~initializedefects->proc~init_dislocation_data proc~init_stacking_fault_data init_stacking_fault_data proc~initializedefects->proc~init_stacking_fault_data proc~init_stacking_fault_data->proc~makestackingfault Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code makedislocation Source Code recursive subroutine makedislocation ( cell , defects , inum , dinfo , DF_L ) !DEC$ ATTRIBUTES DLLEXPORT :: makedislocation use math use constants use crystal use math use io use symmetry use rotations IMPLICIT NONE type ( unitcell ), pointer :: cell type ( defecttype ), INTENT ( INOUT ) :: defects integer ( kind = irg ), INTENT ( IN ) :: inum integer ( kind = irg ), INTENT ( IN ) :: dinfo real ( kind = sgl ), INTENT ( IN ) :: DF_L type ( foiltype ) :: foil real ( kind = dbl ) :: zz , zang , zmin real ( kind = sgl ) :: ec ( 6 , 6 ), lec ( 6 , 6 ) real ( kind = dbl ) :: a_dc ( 3 , 3 ), tmp ( 3 ), ex ( 3 ), ey ( 3 ) real ( kind = dbl ) :: Bij ( 3 , 3 ), Hij ( 3 , 3 ) complex ( kind = dbl ) :: a ( 0 : 6 ), b ( 0 : 6 ), c ( 0 : 6 ), d ( 0 : 6 ), e ( 0 : 6 ), ff ( 0 : 6 ), tt ( 5 , 0 : 6 ), s ( 0 : 6 ), roots ( 6 ), & zero , pasq ( 3 ), mat ( 3 , 3 ), aka ( 3 , 3 ), Lia ( 3 , 3 ), Mai ( 3 , 3 ), v ( 3 ), pas integer ( kind = irg ) :: i , j , k , l , imin , ind ( 3 ), jnd ( 3 ) foil = defects % foil ! convert line direction and g-vector to the Cartesian crystal reference frame call TransSpace ( cell , defects % DL ( inum )% u , defects % DL ( inum )% un , 'd' , 'c' ) call TransSpace ( cell , defects % DL ( inum )% g , defects % DL ( inum )% gn , 'r' , 'c' ) ! normalize both vectors call NormVec ( cell , defects % DL ( inum )% un , 'c' ) call NormVec ( cell , defects % DL ( inum )% gn , 'c' ) ! first find the length of the dislocation line inside the foil along the ! dislocation z-axis, which is the line direction; also, compute the intersection ! points of the line with the top and bottom surfaces  (all components in [nm]) zang = CalcAngle ( cell , defects % DL ( inum )% u , dble ( foil % F ), 'd' ) zz = cos ( zang ) if ( abs ( zz ). gt . 0.00001 ) then defects % DL ( inum )% zu = 0.5 * foil % z0 / zz else defects % DL ( inum )% zu = 10000 0.0 ! this is when the dislocation is nearly parallel to the foil end if ! transform the line direction to the foil reference frame tmp = quat_Lp ( foil % a_fc , dble ( defects % DL ( inum )% un ) ) / DF_L if ( dinfo . eq . 1 ) then write ( * , * ) 'transformed line direction ' , tmp , zang , zz end if ! determine the top and bottom intersection coordinates if ( zz . gt . 0.0 ) then ! u points to the top of the foil defects % DL ( inum )% top = ( / defects % DL ( inum )% id + tmp ( 1 ) * defects % DL ( inum )% zu , defects % DL ( inum )% jd + & tmp ( 2 ) * defects % DL ( inum )% zu , 0.5D0 * foil % z0 / ) defects % DL ( inum )% bottom = ( / defects % DL ( inum )% id - tmp ( 1 ) * defects % DL ( inum )% zu , defects % DL ( inum )% jd - & tmp ( 2 ) * defects % DL ( inum )% zu , - 0.5D0 * foil % z0 / ) else ! u points to the bottom of the foil defects % DL ( inum )% top = ( / defects % DL ( inum )% id - tmp ( 1 ) * defects % DL ( inum )% zu , defects % DL ( inum )% jd - & tmp ( 2 ) * defects % DL ( inum )% zu , - 0.5D0 * foil % z0 / ) defects % DL ( inum )% bottom = ( / defects % DL ( inum )% id + tmp ( 1 ) * defects % DL ( inum )% zu , defects % DL ( inum )% jd + & tmp ( 2 ) * defects % DL ( inum )% zu , 0.5D0 * foil % z0 / ) end if if ( dinfo . eq . 1 ) then write ( * , * ) defects % DL ( inum )% id , defects % DL ( inum )% jd write ( * , * ) 'dislocation top intersection at ' , defects % DL ( inum )% top write ( * , * ) 'dislocation bottom intersection at ' , defects % DL ( inum )% bottom end if ! a_dc (crystal to defect)  matrix corrected on 11/29/10 to put defect x-axis in the plane of u and B if ( dinfo . eq . 1 ) then write ( * , * ) 'cartesian quantities' write ( * , * ) 'unit line direction = ' , defects % DL ( inum )% un write ( * , * ) 'unit beam direction = ' , foil % Bn end if ! transform beam direction (currently in foil frame) to cartesian tmp = quat_Lp ( conjg ( foil % a_fc ), dble ( foil % Bn )) !tmp = quat_rotate_vector(conjg(foil%a_fc), (/ 0.0D0, 0.0D0, -1.0D0/) ) call NormVec ( cell , tmp , 'c' ) ! the defect z axis is the line direction and x is in the plane of u and B to avoid the intrinsic discontinuity (cut plane) a_dc ( 3 , 1 : 3 ) = defects % DL ( inum )% un ( 1 : 3 ) call CalcCross ( cell , dble ( defects % DL ( inum )% un ), tmp , ex , 'c' , 'c' , 0 ) call NormVec ( cell , ex , 'c' ) a_dc ( 1 , 1 : 3 ) = ex ( 1 : 3 ) call CalcCross ( cell , dble ( defects % DL ( inum )% un ), ex , ey , 'c' , 'c' , 0 ) call NormVec ( cell , ey , 'c' ) a_dc ( 2 , 1 : 3 ) = ey ( 1 : 3 ) defects % DL ( inum )% a_dc = om2qu ( a_dc ) if ( dinfo . eq . 1 ) then call PrintMatrixd ( 'a_dc' , a_dc ) end if ! a_di (image to defect) defects % DL ( inum )% a_di = quat_mult ( defects % DL ( inum )% a_dc , conjg ( foil % a_ic ) ) defects % DL ( inum )% a_id = conjg ( defects % DL ( inum )% a_di ) if ( dinfo . eq . 1 ) then call print_orientation_d ( init_orientation_d ( defects % DL ( inum )% a_di , 'qu' ), 'om' , 'a_di:     ' ) call print_orientation_d ( init_orientation_d ( defects % DL ( inum )% a_id , 'qu' ), 'om' , 'a_id:     ' ) end if ! finally, get the foil to defect transformation (used in defect module) defects % DL ( inum )% a_df = quat_mult ( defects % DL ( inum )% a_di , conjg ( foil % a_fi ) ) ! Burgers vector (in the defect reference frame !!!) ! first transform Burgers vector to crystal cartesian reference frame call TransSpace ( cell , dble ( defects % DL ( inum )% burg ), tmp , 'd' , 'c' ) ! then convert this to the defect reference frame defects % DL ( inum )% burgd ( 1 : 3 ) = quat_Lp ( defects % DL ( inum )% a_dc , dble ( tmp )) if ( dinfo . eq . 1 ) then write ( * , * ) 'rotated burgers vector  = ' , defects % DL ( inum )% burgd ( 1 : 3 ) end if ! transform the elastic moduli lec = foil % elmo ! transform lec to defect reference frame a_dc = qu2om ( defects % DL ( inum )% a_dc ) call TransFourthRankTensor ( a_dc , lec , ec ) if ( dinfo . eq . 1 ) then write ( * , * ) 'Elasticity tensor in defect reference frame' do i = 1 , 6 write ( * , \"(6(F8.4,2x))\" ) ( ec ( i , j ), j = 1 , 6 ) end do write ( * , * ) '----' end if ! next, create the sextic polynomial zero = cmplx ( 0.0 , 0.0 , dbl ) a = zero ; b = zero ; c = zero ; d = zero ; e = zero ; ff = zero a ( 0 : 2 ) = ( / cmplx ( ec ( 1 , 1 ), 0.0 , dbl ), cmplx ( ec ( 1 , 6 ) * 2.0 , 0.0 , dbl ), cmplx ( ec ( 6 , 6 ), 0.0 , dbl ) / ) b ( 0 : 2 ) = ( / cmplx ( ec ( 6 , 6 ), 0.0 , dbl ), cmplx ( ec ( 2 , 6 ) * 2.0 , 0.0 , dbl ), cmplx ( ec ( 2 , 2 ), 0.0 , dbl ) / ) c ( 0 : 2 ) = ( / cmplx ( ec ( 5 , 5 ), 0.0 , dbl ), cmplx ( ec ( 4 , 5 ) * 2.0 , 0.0 , dbl ), cmplx ( ec ( 4 , 4 ), 0.0 , dbl ) / ) d ( 0 : 2 ) = ( / cmplx ( ec ( 5 , 6 ), 0.0 , dbl ), cmplx ( ec ( 4 , 6 ) + ec ( 2 , 5 ), 0.0 , dbl ), cmplx ( ec ( 2 , 4 ), 0.0 , dbl ) / ) e ( 0 : 2 ) = ( / cmplx ( ec ( 1 , 5 ), 0.0 , dbl ), cmplx ( ec ( 1 , 4 ) + ec ( 5 , 6 ), 0.0 , dbl ), cmplx ( ec ( 4 , 6 ), 0.0 , dbl ) / ) ff ( 0 : 2 ) = ( / cmplx ( ec ( 1 , 6 ), 0.0 , dbl ), cmplx ( ec ( 1 , 2 ) + ec ( 6 , 6 ), 0.0 , dbl ), cmplx ( ec ( 2 , 6 ), 0.0 , dbl ) / ) tt = zero s = zero ! matrix elements do j = 0 , 6 do i = 0 , j tt ( 1 , j ) = tt ( 1 , j ) + a ( j - i ) * b ( i ) tt ( 2 , j ) = tt ( 2 , j ) + d ( j - i ) * e ( i ) tt ( 3 , j ) = tt ( 3 , j ) + a ( j - i ) * d ( i ) tt ( 4 , j ) = tt ( 4 , j ) + b ( j - i ) * e ( i ) tt ( 5 , j ) = tt ( 5 , j ) + c ( j - i ) * ff ( i ) end do end do ! determinant leading to the sextic equation do j = 0 , 6 do i = 0 , j s ( j ) = s ( j ) + tt ( 1 , j - i ) * c ( i ) + 2.0 * tt ( 2 , j - i ) * ff ( i ) - tt ( 3 , j - i ) * d ( i ) - tt ( 4 , j - i ) * e ( i ) - tt ( 5 , j - i ) * ff ( i ) end do end do ! get the complex root pairs call zroots ( s , roots ) ! then, solve the equation for the vector A_k using the roots with positive imaginary part. k = 1 do j = 1 , 6 if ( aimag ( roots ( j )). gt . 0.0 ) then defects % DL ( inum )% pa ( k ) = roots ( j ) k = k + 1 end if end do ! renumber them to avoid the symmetry degeneracy (see page 328 Head et al.) v ( 1 : 3 ) = ec ( 5 , 5 ) + 2.0 * defects % DL ( inum )% pa ( 1 : 3 ) * ec ( 4 , 5 ) + ec ( 4 , 4 ) * defects % DL ( inum )% pa ( 1 : 3 ) ** 2 zmin = 10 0.0 imin = 0 ! where is the smallest value ? do i = 1 , 3 if ( abs ( v ( i )). lt . zmin ) then imin = i zmin = abs ( v ( i )) end if end do ! is the 3rd one the smallest ? if not, then swap with the current 3rd one. if ( imin . ne . 3 ) then pas = defects % DL ( inum )% pa ( imin ) defects % DL ( inum )% pa ( imin ) = defects % DL ( inum )% pa ( 3 ) defects % DL ( inum )% pa ( 3 ) = pas end if pas = defects % DL ( inum )% pa ( 1 ) defects % DL ( inum )% pa ( 1 ) = defects % DL ( inum )% pa ( 2 ) defects % DL ( inum )% pa ( 2 ) = pas ! eliminate really small numbers do i = 1 , 3 if ( abs ( aimag ( defects % DL ( inum )% pa ( i ))). lt . 1.0e-8 ) defects % DL ( inum )% pa ( i ) = cmplx ( real ( defects % DL ( inum )% pa ( i )), 0.0 , dbl ) if ( abs ( real ( defects % DL ( inum )% pa ( i ))). lt . 1.0e-8 ) defects % DL ( inum )% pa ( i ) = cmplx ( 0.0 , aimag ( defects % DL ( inum )% pa ( i )), dbl ) end do if ( dinfo . eq . 1 ) then write ( * , * ) ' sextic roots' do i = 1 , 3 write ( * , * ) defects % DL ( inum )% pa ( i ) end do write ( * , * ) '---' end if !  compute the A_ka vectors (see description on page 328 of Head et al.) pasq = defects % DL ( inum )% pa ** 2 if ( dinfo . eq . 1 ) write ( * , * ) 'Aka vectors' do k = 1 , 3 mat = zero mat ( 1 , 1 ) = ec ( 1 , 1 ) + 2.D0 * defects % DL ( inum )% pa ( k ) * ec ( 1 , 6 ) + ec ( 6 , 6 ) * pasq ( k ) mat ( 2 , 2 ) = ec ( 6 , 6 ) + 2.D0 * defects % DL ( inum )% pa ( k ) * ec ( 2 , 6 ) + ec ( 2 , 2 ) * pasq ( k ) mat ( 3 , 3 ) = ec ( 5 , 5 ) + 2.D0 * defects % DL ( inum )% pa ( k ) * ec ( 4 , 5 ) + ec ( 4 , 4 ) * pasq ( k ) mat ( 2 , 3 ) = ec ( 5 , 6 ) + defects % DL ( inum )% pa ( k ) * ( ec ( 4 , 6 ) + ec ( 2 , 5 )) + ec ( 2 , 4 ) * pasq ( k ) mat ( 1 , 3 ) = ec ( 1 , 5 ) + defects % DL ( inum )% pa ( k ) * ( ec ( 1 , 4 ) + ec ( 5 , 6 )) + ec ( 4 , 6 ) * pasq ( k ) mat ( 1 , 2 ) = ec ( 1 , 6 ) + defects % DL ( inum )% pa ( k ) * ( ec ( 1 , 2 ) + ec ( 6 , 6 )) + ec ( 2 , 6 ) * pasq ( k ) if ( k . eq . 1 ) then aka ( 1 , 1 ) = mat ( 2 , 2 ) * mat ( 3 , 3 ) - mat ( 2 , 3 ) * mat ( 2 , 3 ) aka ( 1 , 2 ) = mat ( 1 , 3 ) * mat ( 2 , 3 ) - mat ( 1 , 2 ) * mat ( 3 , 3 ) aka ( 1 , 3 ) = mat ( 1 , 2 ) * mat ( 2 , 3 ) - mat ( 1 , 3 ) * mat ( 2 , 2 ) end if if ( k . eq . 2 ) then aka ( 2 , 1 ) = mat ( 1 , 3 ) * mat ( 2 , 3 ) - mat ( 1 , 2 ) * mat ( 3 , 3 ) aka ( 2 , 2 ) = mat ( 1 , 1 ) * mat ( 3 , 3 ) - mat ( 1 , 3 ) * mat ( 1 , 3 ) aka ( 2 , 3 ) = mat ( 1 , 3 ) * mat ( 1 , 2 ) - mat ( 1 , 1 ) * mat ( 2 , 3 ) end if if ( k . eq . 3 ) then aka ( 3 , 1 ) = mat ( 1 , 2 ) * mat ( 2 , 3 ) - mat ( 1 , 3 ) * mat ( 2 , 2 ) aka ( 3 , 2 ) = mat ( 1 , 3 ) * mat ( 1 , 2 ) - mat ( 1 , 1 ) * mat ( 2 , 3 ) aka ( 3 , 3 ) = mat ( 1 , 1 ) * mat ( 2 , 2 ) - mat ( 1 , 2 ) * mat ( 1 , 2 ) end if if ( dinfo . eq . 1 ) write ( * , * ) k ,( aka ( k , j ), j = 1 , 3 ) end do aka = transpose ( aka ) ! next, create the L_ialpha matrix ind = ( / 6 , 2 , 4 / ) jnd = ( / 1 , 6 , 5 / ) Lia = zero do i = 1 , 3 do j = 1 , 3 do k = 1 , 3 Lia ( i , j ) = Lia ( i , j ) + ( ec ( ind ( i ), jnd ( k )) + defects % DL ( inum )% pa ( j ) * ec ( ind ( i ), ind ( k ))) * aka ( k , j ) end do end do end do if ( dinfo . eq . 1 ) call PrintMatrixcd ( 'Lia ' , Lia ) ! and invert it call cInvert ( Lia , Mai ) if ( dinfo . eq . 1 ) call PrintMatrixcd ( 'Mai ' , Mai ) ! compute Bij ( real matrix ) Bij = 0.D0 do i = 1 , 3 do j = 1 , 3 do k = 1 , 3 Bij ( i , j ) = Bij ( i , j ) - aimag ( aka ( i , k )) * real ( Mai ( k , j )) - real ( aka ( i , k )) * aimag ( Mai ( k , j )) end do end do end do if ( dinfo . eq . 1 ) call PrintMatrixd ( 'Bij ' , Bij ) ! and invert to get Hij call mInvert ( Bij , Hij ,. FALSE .) if ( dinfo . eq . 1 ) call PrintMatrixd ( 'Hij ' , Hij ) ! compute matrix (this is what actually gets to be used for the ! displacement field); needs to know the Burgers vector. defects % DL ( inum )% dismat = zero do k = 1 , 3 do l = 1 , 3 do i = 1 , 3 do j = 1 , 3 defects % DL ( inum )% dismat ( k , l ) = defects % DL ( inum )% dismat ( k , l ) + defects % DL ( inum )% burgd ( i ) * Hij ( j , i ) * Mai ( l , j ) * aka ( k , l ) end do end do end do end do ! scale by 1/4pi defects % DL ( inum )% dismat = defects % DL ( inum )% dismat * 0.25D0 / cPi if ( dinfo . eq . 1 ) call PrintMatrixcd ( 'dismat' , defects % DL ( inum )% dismat ) ! and return to calling routine end subroutine makedislocation","tags":"","loc":"proc/makedislocation.html","title":"makedislocation – Fortran Program"},{"text":"public recursive subroutine makestackingfault(cell, defects, inum, DF_L, nx, ny, DF_g, dinfo) Uses: math constants files rotations crystal symmetry math proc~~makestackingfault~~UsesGraph proc~makestackingfault makestackingfault module~constants constants module~constants->proc~makestackingfault crystal crystal crystal->proc~makestackingfault symmetry symmetry symmetry->proc~makestackingfault rotations rotations rotations->proc~makestackingfault math math math->proc~makestackingfault files files files->proc~makestackingfault local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief compute parameters for a stacking fault\n @details  This subroutine computes the geometrical parameters for a \n stacking fault.  It computes, among others, the coordinates of the \n centers of the partial dislocations, the intersections of each dislocation\n line with the top and bottom foil surface, and an array that indicates, for\n each image pixel, whether or not the corresponding integration column \n contains this fault; if it does not, the  value in the array is set to \n -10000; if it does, then the value is equal to the point where the fault\n plane intersects with the column, measured from the top surface.\n In short, anything that is needed in the CalcR routine and can be computed \n ahead of time, is computed here.  The routine also calls the makedislocation \n routine to create the partials.\n @param cell unit cell pointer\n @param defects defect structure\n @param inum\n @param DF_L column edge length\n @param nx\n @param ny\n @param DF_g\n @param ndl\n @param dinfo trigger for verbose output\n @date   11/05/13 MDG 1.0 new attempt to replace faulty original routine\n @date   11/13/13 MDG 1.1 traced error to problem with transformations in defectmodule\n @date   11/13/13 MDG 1.2 changed SF normal transformation for zpos array computation (to be tested)\n @date   06/09/14 MDG 2.0 added defects and cell as arguments\n @date   06/10/14 MDG 2.1 added foil as argument Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(defecttype), intent(inout) :: defects integer(kind=irg), intent(in) :: inum real(kind=sgl), intent(in) :: DF_L integer(kind=irg), intent(in) :: nx integer(kind=irg), intent(in) :: ny real(kind=sgl), intent(in) :: DF_g (3) integer(kind=irg), intent(in) :: dinfo Calls proc~~makestackingfault~~CallsGraph proc~makestackingfault makestackingfault float float proc~makestackingfault->float transspace transspace proc~makestackingfault->transspace proc~makedislocation makedislocation proc~makestackingfault->proc~makedislocation normvec normvec proc~makestackingfault->normvec point_inside_polygon point_inside_polygon proc~makestackingfault->point_inside_polygon quat_lp quat_lp proc~makestackingfault->quat_lp calccross calccross proc~makestackingfault->calccross sgetrf sgetrf proc~makestackingfault->sgetrf proc~makedislocation->transspace proc~makedislocation->normvec proc~makedislocation->quat_lp proc~makedislocation->calccross printmatrixcd printmatrixcd proc~makedislocation->printmatrixcd om2qu om2qu proc~makedislocation->om2qu print_orientation_d print_orientation_d proc~makedislocation->print_orientation_d minvert minvert proc~makedislocation->minvert zroots zroots proc~makedislocation->zroots quat_mult quat_mult proc~makedislocation->quat_mult cinvert cinvert proc~makedislocation->cinvert init_orientation_d init_orientation_d proc~makedislocation->init_orientation_d transfourthranktensor transfourthranktensor proc~makedislocation->transfourthranktensor qu2om qu2om proc~makedislocation->qu2om printmatrixd printmatrixd proc~makedislocation->printmatrixd calcangle calcangle proc~makedislocation->calcangle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~makestackingfault~~CalledByGraph proc~makestackingfault makestackingfault proc~init_stacking_fault_data init_stacking_fault_data proc~init_stacking_fault_data->proc~makestackingfault proc~initializedefects InitializeDefects proc~initializedefects->proc~init_stacking_fault_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code makestackingfault Source Code recursive subroutine makestackingfault ( cell , defects , inum , DF_L , nx , ny , DF_g , dinfo ) !DEC$ ATTRIBUTES DLLEXPORT ::  makestackingfault use math use constants use files use rotations use crystal use symmetry use math IMPLICIT NONE type ( defecttype ), INTENT ( INOUT ) :: defects type ( unitcell ), pointer :: cell real ( kind = sgl ), INTENT ( IN ) :: DF_L real ( kind = sgl ), INTENT ( IN ) :: DF_g ( 3 ) integer ( kind = irg ), INTENT ( IN ) :: inum , nx , ny , dinfo real ( kind = sgl ) :: fpn ( 3 ), am ( 4 , 4 ), midpoint ( 3 ), ex ( 3 ), ey ( 3 ),& lptopi ( 3 ), lpboti ( 3 ), tptopi ( 3 ), tpboti ( 3 ), det , A ( 4 ), xx ( 4 ), yy ( 4 ), tmp ( 3 ), & planenormal ( 3 ), rzero ( 3 ), unita ( 3 ) integer ( kind = irg ) :: i , j , info , ipiv , minx , maxx , miny , maxy , ndl ndl = defects % numdisl ! we begin by computing the geometry in the foil reference frame, which is the cartesian frame ! for zero sample tilt;  sample tilts are applied once we known the partial dislocation geometry call TransSpace ( cell , defects % SF ( inum )% plane , tmp , 'r' , 'c' ) call NormVec ( cell , tmp , 'c' ) planenormal = tmp call CalcCross ( cell , planenormal , ( / 0.0 , 0.0 , 1.0 / ), unita , 'c' , 'c' , 0 ) call NormVec ( cell , unita , 'c' ) fpn = planenormal if ( dinfo . eq . 1 ) write ( * , * ) ' unita should have zero third component ' , unita , fpn ! the fault plane goes through the point rzero in the foil center plane rzero = ( / defects % SF ( inum )% id , defects % SF ( inum )% jd , 0.0 / ) ! this leads to the location of the partial dislocation centers defects % SF ( inum )% lpr = rzero + 0.5 * defects % SF ( inum )% sep * unita / DF_L defects % SF ( inum )% tpr = rzero - 0.5 * defects % SF ( inum )% sep * unita / DF_L if ( dinfo . eq . 1 ) write ( * , * ) 'lpr_i = ' , defects % SF ( inum )% lpr ( 1 : 3 ) if ( dinfo . eq . 1 ) write ( * , * ) 'tpr_i = ' , defects % SF ( inum )% tpr ( 1 : 3 ) ! call makedislocation for each of the partials defects % DL ( ndl + 1 )% id = defects % SF ( inum )% lpr ( 1 ) defects % DL ( ndl + 1 )% jd = defects % SF ( inum )% lpr ( 2 ) defects % DL ( ndl + 1 )% u = defects % SF ( inum )% lpu defects % DL ( ndl + 1 )% burg = defects % SF ( inum )% lpb defects % DL ( ndl + 1 )% g = DF_g call makedislocation ( cell , defects , ndl + 1 , dinfo , DF_L ) if ( dinfo . eq . 1 ) write ( * , * ) 'Leading Partial Position ' , defects % DL ( ndl + 1 )% id , defects % DL ( ndl + 1 )% jd defects % DL ( ndl + 2 )% id = defects % SF ( inum )% tpr ( 1 ) defects % DL ( ndl + 2 )% jd = defects % SF ( inum )% tpr ( 2 ) defects % DL ( ndl + 2 )% u = defects % SF ( inum )% tpu defects % DL ( ndl + 2 )% burg = defects % SF ( inum )% tpb defects % DL ( ndl + 2 )% g = DF_g call makedislocation ( cell , defects , ndl + 2 , dinfo , DF_L ) if ( dinfo . eq . 1 ) write ( * , * ) 'Trailing Partial Position ' , defects % DL ( ndl + 2 )% id , defects % DL ( ndl + 2 )% jd ! copy the top and bottom dislocation intersections (computed in make_dislocation) ! into the corresponding variables of the SF record defects % SF ( inum )% lpbot = defects % DL ( ndl + 1 )% bottom defects % SF ( inum )% lptop = defects % DL ( ndl + 1 )% top defects % SF ( inum )% tpbot = defects % DL ( ndl + 2 )% bottom defects % SF ( inum )% tptop = defects % DL ( ndl + 2 )% top ! obviously, these four points need to lie in a single plane; at this point, we check that this is indeed the case ! by computing the volume of the tetrahedron formed by these four points; if the volume is zero, then the ! points are co-planar.  (Use LAPACK's LU-decomposition and compute the product of the diagonal elements of U) am ( 1 : 4 , 1 ) = ( / defects % SF ( inum )% lptop ( 1 : 3 ), 1.0 / ) am ( 1 : 4 , 2 ) = ( / defects % SF ( inum )% lpbot ( 1 : 3 ), 1.0 / ) am ( 1 : 4 , 3 ) = ( / defects % SF ( inum )% tptop ( 1 : 3 ), 1.0 / ) am ( 1 : 4 , 4 ) = ( / defects % SF ( inum )% tpbot ( 1 : 3 ), 1.0 / ) call sgetrf ( 4 , 4 , am , 4 , ipiv , info ) det = abs ( am ( 1 , 1 ) * am ( 2 , 2 ) * am ( 3 , 3 ) * am ( 4 , 4 )) if ( dinfo . eq . 1 ) write ( * , * ) 'determinant (should be zero) = ' , det ! ok, next we need to figure out which image pixels lie on the projection of the stacking fault plane. ! We need to transform the corner points into the image reference frame !!! lptopi = quat_Lp ( defects % foil % a_fi , dble ( defects % SF ( inum )% lptop )) lpboti = quat_Lp ( defects % foil % a_fi , dble ( defects % SF ( inum )% lpbot )) tptopi = quat_Lp ( defects % foil % a_fi , dble ( defects % SF ( inum )% tptop )) tpboti = quat_Lp ( defects % foil % a_fi , dble ( defects % SF ( inum )% tpbot )) if ( dinfo . eq . 1 ) then write ( * , * ) 'SF parameters :' write ( * , * ) lptopi , ' <> ' , lpboti write ( * , * ) tptopi , ' <> ' , tpboti end if ! define the array that will contain the zpos values allocate ( defects % SF ( inum )% zpos ( nx , ny )) defects % SF ( inum )% zpos = - 1000 0.0 ! set all points to be outside the projected SF ! first determine the smaller box minx = nint ( min ( lptopi ( 1 ), lpboti ( 1 ), tptopi ( 1 ), tpboti ( 1 ) )) - 2 maxx = nint ( max ( lptopi ( 1 ), lpboti ( 1 ), tptopi ( 1 ), tpboti ( 1 ) )) + 2 miny = nint ( min ( lptopi ( 2 ), lpboti ( 2 ), tptopi ( 2 ), tpboti ( 2 ) )) - 2 maxy = nint ( max ( lptopi ( 2 ), lpboti ( 2 ), tptopi ( 2 ), tpboti ( 2 ) )) + 2 ! the fault edges may fall outside of the viewing frame (origin at the center !!!) if ( minx . lt .( - nx / 2 + 1 )) minx =- nx / 2 + 1 if ( maxx . gt . nx / 2 ) maxx = nx / 2 if ( miny . lt .( - ny / 2 + 1 )) miny =- ny / 2 + 1 if ( maxy . gt . ny / 2 ) maxy = ny / 2 if ( dinfo . eq . 1 ) write ( * , * ) 'Integer fault box = ' , minx , maxx , miny , maxy ! get the equation of the stacking fault plane in the image reference frame ! first the unit plane normal in image space ! we'll take two vectors: ex = from ltop to ttop; ey = from ltop to lbot ex = tptopi - lptopi ey = lpboti - lptopi call NormVec ( cell , ex , 'c' ) call NormVec ( cell , ey , 'c' ) call CalcCross ( cell , ex , ey , fpn , 'c' , 'c' , 0 ) A ( 1 : 3 ) = fpn ! quat_LPstar( conjg(foil%a_fi), dble(fpn(1:3)) ) midpoint = 0.25 * ( lptopi + lpboti + tptopi + tpboti ) ! quat_LPstar( conjg(foil%a_fi), dble(0.25*(lptopi+lpboti+tptopi+tpboti) )) A ( 4 ) = sum ( A ( 1 : 3 ) * midpoint ) if ( dinfo . eq . 1 ) write ( * , * ) 'fault plane parameters : ' , A , midpoint ! rank the corner points so that the polygon is convex ! call rank_points(tpboti(1:2),lpboti(1:2),lptopi(1:2),tptopi(1:2),xx,yy) xx = ( / lptopi ( 1 ), tptopi ( 1 ), tpboti ( 1 ), lpboti ( 1 ) / ) yy = ( / lptopi ( 2 ), tptopi ( 2 ), tpboti ( 2 ), lpboti ( 2 ) / ) ! for all of the points inside this box: do i = minx , maxx do j = miny , maxy if ( point_inside_polygon ( float ( i ), float ( j ), xx , yy ). gt . 0 ) then ! the point lies inside the projected region, ! so we need the depth of the SF plane at this position, taking into account the ! proper coordinate transformation (depth must be expressed in image reference frame) defects % SF ( inum )% zpos ( i + nx / 2 , j + ny / 2 ) = DF_L * ( A ( 4 ) - A ( 1 ) * float ( i ) - A ( 2 ) * float ( j ) ) / A ( 3 ) end if end do end do if ( dinfo . eq . 1 ) write ( * , * ) 'fault plane pixels determined' ! let's also make sure that the SF displacement vector is translated to the ! cartesian reference frame, so that it can be used directly by the CalcR routine defects % SF ( inum )% lpbc = matmul ( cell % dsm , defects % SF ( inum )% Rdisp ) ! that should do it for the stacking fault...  The rest ! takes place in the CalcR routine. end subroutine makestackingfault","tags":"","loc":"proc/makestackingfault.html","title":"makestackingfault – Fortran Program"},{"text":"public recursive subroutine makestackingfaultECCI(cell, defects, inum, DF_L, nx, ny, DF_g, dinfo) Uses: math constants files rotations crystal symmetry math proc~~makestackingfaultecci~~UsesGraph proc~makestackingfaultecci makestackingfaultECCI module~constants constants module~constants->proc~makestackingfaultecci crystal crystal crystal->proc~makestackingfaultecci symmetry symmetry symmetry->proc~makestackingfaultecci rotations rotations rotations->proc~makestackingfaultecci math math math->proc~makestackingfaultecci files files files->proc~makestackingfaultecci local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief compute parameters for a stacking fault in ECCI mode\n @details  This subroutine computes the geometrical parameters for a \n stacking fault.  It computes, among others, the coordinates of the surface\n intersections of the partial dislocations, and an array that indicates, for\n each image pixel, whether or not the corresponding integration column \n contains this fault; if it does not, the  value in the array is set to \n -10000; if it does, then the value is equal to the point where the fault\n plane intersects with the column, measured from the top surface.\n In short, anything that is needed in the CalcR routine and can be computed \n ahead of time, is computed here.  The routine also calls the makedislocation \n routine to create the partials.\n @param cell unit cell pointer\n @param defects defect structure\n @param inum\n @param DF_L column edge length\n @param nx\n @param ny\n @param DF_g\n @param ndl\n @param dinfo trigger for verbose output\n @date   11/05/13 MDG 1.0 new attempt to replace faulty original routine\n @date   11/13/13 MDG 1.1 traced error to problem with transformations in defectmodule\n @date   11/13/13 MDG 1.2 changed SF normal transformation for zpos array computation (to be tested)\n @date   12/17/13 MDG 1.3 branch from original routine to deal with different ECCI geometry\n @date   12/18/13 MDG 1.4 debug of stacking fault location array\n @date   06/09/14 MDG 2.0 added cell, SF, YD arguments\n @date   06/10/14 MDG 2.1 added foil argument Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(defecttype), intent(inout) :: defects integer(kind=irg), intent(in) :: inum real(kind=sgl), intent(in) :: DF_L integer(kind=irg), intent(in) :: nx integer(kind=irg), intent(in) :: ny real(kind=sgl), intent(in) :: DF_g (3) integer(kind=irg), intent(in) :: dinfo Calls proc~~makestackingfaultecci~~CallsGraph proc~makestackingfaultecci makestackingfaultECCI float float proc~makestackingfaultecci->float transspace transspace proc~makestackingfaultecci->transspace point_inside_polygon point_inside_polygon proc~makestackingfaultecci->point_inside_polygon sgetrf sgetrf proc~makestackingfaultecci->sgetrf calcangle calcangle proc~makestackingfaultecci->calcangle sngl sngl proc~makestackingfaultecci->sngl quat_lp quat_lp proc~makestackingfaultecci->quat_lp proc~makeyshdislocation makeYSHdislocation proc~makestackingfaultecci->proc~makeyshdislocation calccross calccross proc~makestackingfaultecci->calccross normvec normvec proc~makestackingfaultecci->normvec proc~makeyshdislocation->transspace proc~makeyshdislocation->calcangle proc~makeyshdislocation->calccross proc~makeyshdislocation->normvec om2qu om2qu proc~makeyshdislocation->om2qu calcdot calcdot proc~makeyshdislocation->calcdot calclength calclength proc~makeyshdislocation->calclength fatalerror fatalerror proc~makeyshdislocation->fatalerror writevalue writevalue proc~makeyshdislocation->writevalue Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~makestackingfaultecci~~CalledByGraph proc~makestackingfaultecci makestackingfaultECCI proc~init_stacking_fault_data init_stacking_fault_data proc~init_stacking_fault_data->proc~makestackingfaultecci proc~initializedefects InitializeDefects proc~initializedefects->proc~init_stacking_fault_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code makestackingfaultECCI Source Code recursive subroutine makestackingfaultECCI ( cell , defects , inum , DF_L , nx , ny , DF_g , dinfo ) !DEC$ ATTRIBUTES DLLEXPORT :: makestackingfaultECCI use math use constants use files use rotations use crystal use symmetry use math IMPLICIT NONE type ( defecttype ), INTENT ( INOUT ) :: defects type ( unitcell ), pointer :: cell real ( kind = sgl ), INTENT ( IN ) :: DF_L real ( kind = sgl ), INTENT ( IN ) :: DF_g ( 3 ) integer ( kind = irg ), INTENT ( IN ) :: inum , nx , ny , dinfo real ( kind = sgl ) :: fpn ( 3 ), am ( 4 , 4 ), midpoint ( 3 ), ex ( 3 ), ey ( 3 ),& lptopi ( 3 ), lpboti ( 3 ), tptopi ( 3 ), tpboti ( 3 ), det , A ( 4 ), xx ( 4 ), yy ( 4 ), tmp ( 3 ), & planenormal ( 3 ), rzero ( 3 ), unita ( 3 ), lun ( 3 ), tun ( 3 ), zang , zu , zz integer ( kind = irg ) :: i , j , info , ipiv , minx , maxx , miny , maxy , ndl ndl = defects % numYdisl ! we begin by computing the geometry in the foil reference frame, which is the cartesian frame ! for zero sample tilt;  sample tilts are applied once we known the partial dislocation geometry call TransSpace ( cell , defects % SF ( inum )% plane , tmp , 'r' , 'c' ) call NormVec ( cell , tmp , 'c' ) planenormal = tmp call CalcCross ( cell , planenormal , ( / 0.0 , 0.0 , 1.0 / ), unita , 'c' , 'c' , 0 ) call NormVec ( cell , unita , 'c' ) fpn = planenormal if ( dinfo . eq . 1 ) write ( * , * ) ' unita should have zero third component ' , unita , fpn ! the fault plane goes through the point rzero in the foil top surface rzero = ( / defects % SF ( inum )% id , defects % SF ( inum )% jd , sngl ( defects % foil % z0 ) * 0.5 / ) ! this leads to the location of the partial dislocation intersections, and these must ! be Yoffe dislocations !!! defects % SF ( inum )% lpr = rzero + 0.5 * defects % SF ( inum )% sep * unita / DF_L defects % SF ( inum )% tpr = rzero - 0.5 * defects % SF ( inum )% sep * unita / DF_L if ( dinfo . eq . 1 ) write ( * , * ) 'lpr_i = ' , defects % SF ( inum )% lpr ( 1 : 3 ) if ( dinfo . eq . 1 ) write ( * , * ) 'tpr_i = ' , defects % SF ( inum )% tpr ( 1 : 3 ) ! convert line directions to the Cartesian crystal reference frame call TransSpace ( cell , defects % SF ( inum )% lpu , lun , 'd' , 'c' ) call TransSpace ( cell , defects % SF ( inum )% tpu , tun , 'd' , 'c' ) ! normalize both vectors call NormVec ( cell , lun , 'c' ) call NormVec ( cell , tun , 'c' ) ! call makeYSHdislocation for each of the partials [must be done in main program] !  if (.not. allocated(YD)) allocate(defects%YD(3*maxdefects)) defects % YD ( ndl + 1 )% id = defects % SF ( inum )% lpr ( 1 ) defects % YD ( ndl + 1 )% jd = defects % SF ( inum )% lpr ( 2 ) defects % YD ( ndl + 1 )% u ( 1 : 3 ) = dble ( defects % SF ( inum )% lpu ( 1 : 3 )) defects % YD ( ndl + 1 )% burg ( 1 : 3 ) = dble ( defects % SF ( inum )% lpb ( 1 : 3 )) defects % YD ( ndl + 1 )% g = DF_g defects % YD ( ndl + 1 )% sig = defects % SF ( inum )% poisson defects % YD ( ndl + 2 )% id = defects % SF ( inum )% tpr ( 1 ) defects % YD ( ndl + 2 )% jd = defects % SF ( inum )% tpr ( 2 ) defects % YD ( ndl + 2 )% u ( 1 : 3 ) = dble ( defects % SF ( inum )% tpu ( 1 : 3 )) defects % YD ( ndl + 2 )% burg ( 1 : 3 ) = dble ( defects % SF ( inum )% tpb ( 1 : 3 )) defects % YD ( ndl + 2 )% g = DF_g defects % YD ( ndl + 2 )% sig = defects % SF ( inum )% poisson call makeYSHdislocation ( cell , defects , ndl + 1 , dinfo , DF_L ) if ( dinfo . eq . 1 ) write ( * , * ) 'Leading Partial Position ' , defects % YD ( ndl + 1 )% id , defects % YD ( ndl + 1 )% jd call makeYSHdislocation ( cell , defects , ndl + 2 , dinfo , DF_L ) if ( dinfo . eq . 1 ) write ( * , * ) 'Trailing Partial Position ' , defects % YD ( ndl + 2 )% id , defects % YD ( ndl + 2 )% jd ! first find the length of the dislocation line inside the foil along the ! dislocation z-axis, which is the line direction; also, compute the intersection ! points of the line with the top and bottom surfaces  (all components in [nm]) zang = CalcAngle ( cell , defects % YD ( ndl + 1 )% u , defects % foil % F , 'd' ) zz = cos ( zang ) if ( abs ( zz ). gt . 0.00001 ) then zu = abs ( defects % foil % z0 / zz ) else zu = 10000 0.0 ! this is when the dislocation is nearly parallel to the foil end if ! transform the line direction to the foil reference frame tmp = quat_Lp ( conjg ( defects % foil % a_fc ), dble ( lun ) ) / DF_L ! determine the top and bottom intersection coordinates defects % YD ( ndl + 1 )% top = ( / defects % YD ( ndl + 1 )% id , defects % YD ( ndl + 1 )% jd , defects % foil % z0 * 0.5 / ) if ( zz . gt . 0.0 ) then ! u points to the top of the foil defects % YD ( ndl + 1 )% bottom = ( / defects % YD ( ndl + 1 )% id - tmp ( 1 ) * zu , defects % YD ( ndl + 1 )% jd - tmp ( 2 ) * zu , - 0.5D0 * defects % foil % z0 / ) else ! u points to the bottom of the foil defects % YD ( ndl + 1 )% bottom = ( / defects % YD ( ndl + 1 )% id + tmp ( 1 ) * zu , defects % YD ( ndl + 1 )% jd + tmp ( 2 ) * zu , - 0.5D0 * defects % foil % z0 / ) end if ! first find the length of the dislocation line inside the foil along the ! dislocation z-axis, which is the line direction; also, compute the intersection ! points of the line with the top and bottom surfaces  (all components in [nm]) zang = CalcAngle ( cell , defects % YD ( ndl + 2 )% u , defects % foil % F , 'd' ) zz = cos ( zang ) if ( abs ( zz ). gt . 0.00001 ) then zu = abs ( defects % foil % z0 / zz ) else zu = 10000 0.0 ! this is when the dislocation is nearly parallel to the foil end if ! transform the line direction to the foil reference frame tmp = quat_Lp ( conjg ( defects % foil % a_fc ), dble ( tun ) ) / DF_L ! determine the top and bottom intersection coordinates defects % YD ( ndl + 2 )% top = ( / defects % YD ( ndl + 2 )% id , defects % YD ( ndl + 2 )% jd , defects % foil % z0 * 0.5 / ) if ( zz . gt . 0.0 ) then ! u points to the top of the foil defects % YD ( ndl + 2 )% bottom = ( / defects % YD ( ndl + 2 )% id - tmp ( 1 ) * zu , defects % YD ( ndl + 2 )% jd - tmp ( 2 ) * zu , - 0.5D0 * defects % foil % z0 / ) else ! u points to the bottom of the foil defects % YD ( ndl + 2 )% bottom = ( / defects % YD ( ndl + 2 )% id + tmp ( 1 ) * zu , defects % YD ( ndl + 2 )% jd + tmp ( 2 ) * zu , - 0.5D0 * defects % foil % z0 / ) end if ! copy the top and bottom dislocation intersections ! into the corresponding variables of the SF record defects % SF ( inum )% lpbot = defects % YD ( ndl + 1 )% bottom defects % SF ( inum )% lptop = defects % YD ( ndl + 1 )% top defects % SF ( inum )% tpbot = defects % YD ( ndl + 2 )% bottom defects % SF ( inum )% tptop = defects % YD ( ndl + 2 )% top ! obviously, these four points need to lie in a single plane; at this point, we check that this is indeed the case ! by computing the volume of the tetrahedron formed by these four points; if the volume is zero, then the ! points are co-planar.  (Use LAPACK's LU-decomposition and compute the product of the diagonal elements of U) am ( 1 : 4 , 1 ) = ( / defects % SF ( inum )% lptop ( 1 : 3 ), 1.0 / ) am ( 1 : 4 , 2 ) = ( / defects % SF ( inum )% lpbot ( 1 : 3 ), 1.0 / ) am ( 1 : 4 , 3 ) = ( / defects % SF ( inum )% tptop ( 1 : 3 ), 1.0 / ) am ( 1 : 4 , 4 ) = ( / defects % SF ( inum )% tpbot ( 1 : 3 ), 1.0 / ) call sgetrf ( 4 , 4 , am , 4 , ipiv , info ) det = abs ( am ( 1 , 1 ) * am ( 2 , 2 ) * am ( 3 , 3 ) * am ( 4 , 4 )) if ( dinfo . eq . 1 ) write ( * , * ) 'determinant (should be zero) = ' , det ! ok, next we need to figure out which image pixels lie on the projection of the stacking fault plane. ! We need to transform the corner points into the image reference frame !!! lptopi = quat_Lp ( defects % foil % a_fi , dble ( defects % SF ( inum )% lptop )) lpboti = quat_Lp ( defects % foil % a_fi , dble ( defects % SF ( inum )% lpbot )) tptopi = quat_Lp ( defects % foil % a_fi , dble ( defects % SF ( inum )% tptop )) tpboti = quat_Lp ( defects % foil % a_fi , dble ( defects % SF ( inum )% tpbot )) if ( dinfo . eq . 1 ) then write ( * , * ) 'SF parameters :' write ( * , * ) lptopi , ' <> ' , lpboti write ( * , * ) tptopi , ' <> ' , tpboti end if ! define the array that will contain the zpos values allocate ( defects % SF ( inum )% zpos ( nx , ny )) defects % SF ( inum )% zpos = - 1000 0.0 ! set all points to be outside the projected SF ! first determine the smaller box minx = nint ( min ( lptopi ( 1 ), lpboti ( 1 ), tptopi ( 1 ), tpboti ( 1 ) )) - 2 maxx = nint ( max ( lptopi ( 1 ), lpboti ( 1 ), tptopi ( 1 ), tpboti ( 1 ) )) + 2 miny = nint ( min ( lptopi ( 2 ), lpboti ( 2 ), tptopi ( 2 ), tpboti ( 2 ) )) - 2 maxy = nint ( max ( lptopi ( 2 ), lpboti ( 2 ), tptopi ( 2 ), tpboti ( 2 ) )) + 2 ! the fault edges may fall outside of the viewing frame (origin at the center !!!) if ( minx . lt .( - nx / 2 + 1 )) minx =- nx / 2 + 1 if ( maxx . gt . nx / 2 ) maxx = nx / 2 if ( miny . lt .( - ny / 2 + 1 )) miny =- ny / 2 + 1 if ( maxy . gt . ny / 2 ) maxy = ny / 2 if ( dinfo . eq . 1 ) write ( * , * ) 'Integer fault box = ' , minx , maxx , miny , maxy ! get the equation of the stacking fault plane in the image reference frame ! first the unit plane normal in image space ! we'll take two vectors: ex = from ltop to ttop; ey = from ltop to lbot ex = tptopi - lptopi ey = lpboti - lptopi call NormVec ( cell , ex , 'c' ) call NormVec ( cell , ey , 'c' ) call CalcCross ( cell , ex , ey , fpn , 'c' , 'c' , 0 ) A ( 1 : 3 ) = fpn ! quat_LPstar( conjg(foil%a_fi), dble(fpn(1:3)) ) midpoint = 0.25 * ( lptopi + lpboti + tptopi + tpboti ) ! quat_LPstar( conjg(foil%a_fi), dble(0.25*(lptopi+lpboti+tptopi+tpboti) )) A ( 4 ) = sum ( A ( 1 : 3 ) * midpoint ) if ( dinfo . eq . 1 ) write ( * , * ) 'fault plane parameters : ' , A , midpoint ! rank the corner points so that the polygon is convex ! call rank_points(tpboti(1:2),lpboti(1:2),lptopi(1:2),tptopi(1:2),xx,yy) xx = ( / lptopi ( 1 ), tptopi ( 1 ), tpboti ( 1 ), lpboti ( 1 ) / ) yy = ( / lptopi ( 2 ), tptopi ( 2 ), tpboti ( 2 ), lpboti ( 2 ) / ) ! for all of the points inside this box: do i = minx , maxx do j = miny , maxy if ( point_inside_polygon ( float ( i ), float ( j ), xx , yy ). gt . 0 ) then ! the point lies inside the projected region, ! so we need the depth of the SF plane at this position, taking into account the ! proper coordinate transformation (depth must be expressed in image reference frame) defects % SF ( inum )% zpos ( i + nx / 2 , j + ny / 2 ) = ( A ( 4 ) - A ( 1 ) * float ( i ) - A ( 2 ) * float ( j ) ) / A ( 3 ) end if end do end do if ( dinfo . eq . 1 ) write ( * , * ) 'fault plane pixels determined' ! let's also make sure that the SF displacement vector is translated to the ! cartesian reference frame, so that it can be used directly by the CalcR routine defects % SF ( inum )% lpbc = matmul ( cell % dsm , defects % SF ( inum )% Rdisp ) ! that should do it for the stacking fault...  The rest ! takes place in the CalcR routine. end subroutine makestackingfaultECCI","tags":"","loc":"proc/makestackingfaultecci.html","title":"makestackingfaultECCI – Fortran Program"},{"text":"public recursive subroutine makeYSHdislocation(cell, defects, i, dinfo, L) Uses: constants crystal io error rotations proc~~makeyshdislocation~~UsesGraph proc~makeyshdislocation makeYSHdislocation crystal crystal crystal->proc~makeyshdislocation rotations rotations rotations->proc~makeyshdislocation error error error->proc~makeyshdislocation module~constants constants module~constants->proc~makeyshdislocation io io io->proc~makeyshdislocation local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief pre-compute geometrical parametersf or the Yoffe&Shaibani&Hazzledine (YSH) \n surface-relaxed dislocation in an elastically isotropic matrix. \n @details These parameters are then used in the CalcR routine. We implemented the YSH expressions instead of Yoffe's \n since the former are more easily handled for numerical computations. SH have redefined the x-y-z reference frame used by Yoffe to fall along\n the dislocation line itself.  As a result, the Burgers vector must be decomposed\n into a screw component and two edge components, one in the plane of the \n discontinuity, the other normal to that plane (which is by definition the x-axis).\n Check the SH paper for more details.\n @param cell unit cell pointer\n @param defects defects structure\n @param i dislocation number\n @param dinfo triggers verbose output\n @param L column edge length Todo Convert IO to Write_Value calls\n @date  1/5/99  MDG 1.0 original\n @date  5/19/01 MDG 2.0 f90 version\n @date 11/27/01 MDG 2.1 added kind support\n @date 06/04/13 MDG 3.0 rewrite+added quaternions\n @date 11/21/13 MDG 3.1 verification + rewrite of output handling\n @date 06/09/14 MDG 4.0 added cell and defects arguments\n @date 06/10/14 MDG 4.1 added foil argument Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(defecttype), intent(inout) :: defects integer(kind=irg), intent(in) :: i integer(kind=irg), intent(in) :: dinfo real(kind=sgl), intent(in) :: L Calls proc~~makeyshdislocation~~CallsGraph proc~makeyshdislocation makeYSHdislocation om2qu om2qu proc~makeyshdislocation->om2qu normvec normvec proc~makeyshdislocation->normvec calcdot calcdot proc~makeyshdislocation->calcdot calcangle calcangle proc~makeyshdislocation->calcangle calclength calclength proc~makeyshdislocation->calclength fatalerror fatalerror proc~makeyshdislocation->fatalerror writevalue writevalue proc~makeyshdislocation->writevalue calccross calccross proc~makeyshdislocation->calccross transspace transspace proc~makeyshdislocation->transspace Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~makeyshdislocation~~CalledByGraph proc~makeyshdislocation makeYSHdislocation proc~init_ysh_dislocation_data init_YSH_dislocation_data proc~init_ysh_dislocation_data->proc~makeyshdislocation proc~makestackingfaultecci makestackingfaultECCI proc~makestackingfaultecci->proc~makeyshdislocation proc~initializedefects InitializeDefects proc~initializedefects->proc~init_ysh_dislocation_data proc~init_stacking_fault_data init_stacking_fault_data proc~initializedefects->proc~init_stacking_fault_data proc~init_stacking_fault_data->proc~makestackingfaultecci Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code makeYSHdislocation Source Code recursive subroutine makeYSHdislocation ( cell , defects , i , dinfo , L ) !DEC$ ATTRIBUTES DLLEXPORT :: makeYSHdislocation use constants use crystal use io use error use rotations IMPLICIT NONE type ( unitcell ), pointer :: cell type ( defecttype ), INTENT ( INOUT ) :: defects integer ( kind = irg ), INTENT ( IN ) :: i integer ( kind = irg ), INTENT ( IN ) :: dinfo real ( kind = sgl ), INTENT ( IN ) :: L real ( kind = dbl ) :: alpha , beta , tu ( 3 ), tx ( 3 ), ty ( 3 ), te ( 3 ), tb ( 3 ), bl , fx ( 3 ), fy ( 3 ), fz ( 3 ), & dx , dy , a_di ( 3 , 3 ), io_real ( 3 ) ! first, determine the alpha angle between the ! negative z-axis, which is really the negative foil normal, and the line direction ! (make sure to reduce the angle to [0,90] interval). ! Each YSH dislocation must have a line direction that points INTO the foil !!! alpha = CalcAngle ( cell , defects % foil % F , dble ( defects % YD ( i )% u ), 'd' ) * 18 0.0 / cPi if ( alpha . ge . 9 0.0 ) then alpha = 18 0.0 - alpha if ( dinfo . eq . 1 ) then io_real ( 1 : 3 ) = defects % foil % F ( 1 : 3 ) call WriteValue ( 'Foil normal = ' , io_real , 3 , \"('[',3F5.1,']')\" ) io_real ( 1 : 3 ) = defects % YD ( i )% u ( 1 : 3 ) call WriteValue ( 'line direction = ' , io_real , 3 , \"('[',3F5.1,']')\" ) io_real ( 1 ) = alpha call WriteValue ( ' --> alpha angle = ' , io_real , 1 , \"(F5.1)\" ) end if alpha = alpha * cPi / 18 0.0 else call FatalError ( 'makeYSHdislocation' , 'YSH dislocations must have line directions pointing into the foil ! ' ) end if ! normalize the line direction call TransSpace ( cell , defects % YD ( i )% u , tu , 'd' , 'c' ) call NormVec ( cell , tu , 'c' ) ! consider the case of alpha=0 separately if ( alpha . gt . 0.0 ) then call TransSpace ( cell , defects % foil % F , ty , 'd' , 'c' ) call NormVec ( cell , ty , 'c' ) !  F call CalcCross ( cell , tu , ty , tx , 'c' , 'c' , 0 ) ! x = u x F call NormVec ( cell , tx , 'c' ) call CalcCross ( cell , tx , tu , te , 'c' , 'c' , 0 ) ! e = x x u call NormVec ( cell , te , 'c' ) call CalcCross ( cell , ty , tx , ty , 'c' , 'c' , 0 ) call NormVec ( cell , ty , 'c' ) else tx = defects % foil % qn call CalcCross ( cell , tx , tu , te , 'c' , 'c' , 0 ) ! e = x x u call NormVec ( cell , te , 'c' ) end if bl = CalcLength ( cell , defects % YD ( i )% burg , 'd' ) if ( dinfo . eq . 1 ) then io_real ( 1 : 3 ) = tx ( 1 : 3 ) call WriteValue ( ' tx = ' , io_real , 3 , \"(3F5.1)\" ) io_real ( 1 : 3 ) = te ( 1 : 3 ) call WriteValue ( ' te = ' , io_real , 3 , \"(3F5.1)\" ) io_real ( 1 : 3 ) = tu ( 1 : 3 ) call WriteValue ( ' tu = ' , io_real , 3 , \"(3F5.1)\" ) io_real ( 1 : 3 ) = ty ( 1 : 3 ) call WriteValue ( ' ty = ' , io_real , 3 , \"(3F5.1)\" ) io_real ( 1 ) = bl call WriteValue ( ' bl = ' , io_real , 1 , \"(F8.3)\" ) end if call TransSpace ( cell , defects % YD ( i )% burg , tb , 'd' , 'c' ) call NormVec ( cell , tb , 'c' ) defects % YD ( i )% bx = bl * CalcDot ( cell , tb , tx , 'c' ) ! edge component normal to cut plane defects % YD ( i )% be = bl * CalcDot ( cell , tb , te , 'c' ) ! edge component in cut plane defects % YD ( i )% bs = bl * CalcDot ( cell , tb , tu , 'c' ) ! screw component if ( dinfo . eq . 1 ) then io_real ( 1 : 3 ) = ( / defects % YD ( i )% bx , defects % YD ( i )% be , defects % YD ( i )% bs / ) call WriteValue ( 'Burgers vector components (bx,be,bs) ' , io_real , 3 , \"(3F12.6)\" ) end if ! verified MDG 7/31/11 ! we will also need to know the quaternion rotation between the dislocation reference frame ! and the foil reference frame, so that we can transform the foil coordinates to defect ! coordinates...  We need the angle beta between the defect x axis (tx) and the foil x axis, ! which is the first column of the foil%a_fc matrix ...   We must make sure that this angle ! is measured in a CCW sense. ! projection of defect x axis onto foil x and y axes call TransSpace ( cell , defects % foil % q , fx , 'd' , 'c' ) call TransSpace ( cell , defects % foil % F , fz , 'd' , 'c' ) call NormVec ( cell , fx , 'c' ) call NormVec ( cell , fz , 'c' ) call CalcCross ( cell , fz , fx , fy , 'c' , 'c' , 0 ) dx = CalcDot ( cell , tx , fx , 'c' ) dy = CalcDot ( cell , tx , fy , 'c' ) ! use the arctan function to get the angle with correct quadrant computation defects % YD ( i )% beta = atan2 ( dy , dx ) !+ cPi*0.5 if ( dinfo . eq . 1 ) then io_real ( 1 ) = dx call WriteValue ( ' dx = ' , io_real , 1 , \"(F8.3)\" ) io_real ( 1 ) = dy call WriteValue ( ' dy = ' , io_real , 1 , \"(F8.3)\" ) io_real ( 1 ) = defects % YD ( i )% beta call WriteValue ( ' beta = ' , io_real , 1 , \"(F8.3)\" ) end if ! convert to a quaternion beta = defects % YD ( i )% beta a_di ( 1 , 1 : 3 ) = ( / cos ( beta ), sin ( beta ), 0.D0 / ) a_di ( 2 , 1 : 3 ) = ( / - sin ( beta ), cos ( beta ), 0.D0 / ) a_di ( 3 , 1 : 3 ) = ( / 0.D0 , 0.D0 , 1.D0 / ) defects % YD ( i )% a_di = om2qu ( a_di ) defects % YD ( i )% a_id = conjg ( defects % YD ( i )% a_di ) if ( dinfo . eq . 1 ) then write ( * , * ) 'beta = ' , beta write ( * , * ) defects % YD ( i )% a_di write ( * , * ) defects % YD ( i )% a_id end if ! finally some geometrical parameters needed for the displacement field computation... defects % YD ( i )% alpha = alpha defects % YD ( i )% ca = cos ( alpha ) defects % YD ( i )% sa = sin ( alpha ) defects % YD ( i )% ta = tan ( alpha ) defects % YD ( i )% cota = 1.0 / defects % YD ( i )% ta ! that's it! the rest is handled in the CalcR routine. end subroutine makeYSHdislocation","tags":"","loc":"proc/makeyshdislocation.html","title":"makeYSHdislocation – Fortran Program"},{"text":"public recursive subroutine InitializeEshelbyInclusion(cell, defects, i, dinfo, L, npix, npiy) Uses: local constants typedefs math proc~~initializeeshelbyinclusion~~UsesGraph proc~initializeeshelbyinclusion InitializeEshelbyInclusion typedefs typedefs typedefs->proc~initializeeshelbyinclusion math math math->proc~initializeeshelbyinclusion local local local->proc~initializeeshelbyinclusion module~constants constants local->module~constants module~constants->proc~initializeeshelbyinclusion Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief pre-compute all parameters for an isotropic Eshelby ellipsoidal inclusion\n @details These parameters are then used in the CalcR routine. We implemented the Eshelby expressions based on Mura's 1987 book.\n @param cell unit cell pointer\n @param defects defects structure\n @param i dislocation number\n @param dinfo triggers verbose output\n @param L column edge length\n @date 12/11/15 MDG 1.0 initial version based on trial IDL script\n @date 12/13/15 MDG 1.1 corrections to some of the auxiliary expressions; sphere limit is now correct Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(defecttype), intent(inout) :: defects integer(kind=irg), intent(in) :: i integer(kind=irg), intent(in) :: dinfo real(kind=sgl), intent(in) :: L integer(kind=irg), intent(in) :: npix integer(kind=irg), intent(in) :: npiy Calls proc~~initializeeshelbyinclusion~~CallsGraph proc~initializeeshelbyinclusion InitializeEshelbyInclusion el2k el2k proc~initializeeshelbyinclusion->el2k float float proc~initializeeshelbyinclusion->float kdelta kdelta proc~initializeeshelbyinclusion->kdelta el1k el1k proc~initializeeshelbyinclusion->el1k dasin dasin proc~initializeeshelbyinclusion->dasin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~initializeeshelbyinclusion~~CalledByGraph proc~initializeeshelbyinclusion InitializeEshelbyInclusion proc~initializedefects InitializeDefects proc~initializedefects->proc~initializeeshelbyinclusion proc~init_einclusion_data init_Einclusion_data proc~init_einclusion_data->proc~initializeeshelbyinclusion Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code InitializeEshelbyInclusion Source Code recursive subroutine InitializeEshelbyInclusion ( cell , defects , i , dinfo , L , npix , npiy ) !DEC$ ATTRIBUTES DLLEXPORT :: InitalizeEshelbyInclusion use local use constants use typedefs use math IMPLICIT NONE type ( unitcell ), pointer :: cell type ( defecttype ), INTENT ( INOUT ) :: defects integer ( kind = irg ), INTENT ( IN ) :: i integer ( kind = irg ), INTENT ( IN ) :: dinfo real ( kind = sgl ), INTENT ( IN ) :: L integer ( kind = irg ), INTENT ( IN ) :: npix integer ( kind = irg ), INTENT ( IN ) :: npiy integer ( kind = irg ) :: j , k , ll , ii complex ( kind = dbl ) :: t , s , q real ( kind = dbl ) :: rsq , v , w , modt , lambda , II1 , II3 , EF , EE , Delta , dth real ( kind = dbl ) :: r2 ( 3 ), IIinside ( 3 ), IIJinside ( 3 , 3 ), maxr ( 3 ), ES ( 3 , 3 , 3 , 3 ), ESV ( 6 , 6 ) real ( kind = dbl ), allocatable :: z (:) ! set the size of the elliptic integral lookup tables defects % Einclusions ( i )% nLUT = 500 ! copy the defect position defects % Einclusions ( i )% xpos = defects % Einclusions ( i )% xyz ( 1 ) * 0.5 * float ( npix ) defects % Einclusions ( i )% ypos = defects % Einclusions ( i )% xyz ( 2 ) * 0.5 * float ( npiy ) defects % Einclusions ( i )% zpos = defects % Einclusions ( i )% xyz ( 3 ) * defects % foil % z0 ! copy the semi-axis into the individual variables defects % Einclusions ( i )% a1 = defects % Einclusions ( i )% a123 ( 1 ) defects % Einclusions ( i )% a2 = defects % Einclusions ( i )% a123 ( 2 ) defects % Einclusions ( i )% a3 = defects % Einclusions ( i )% a123 ( 3 ) ! rearrange the ellipsoid semi-axes from largest to smallest and initialize the ! corresponding permutation matrix as well as the rotation matrix based on the ! eigenvectors... ! to be implemented ! determine the maximum vector length for the computation of theta(lambda) maxr = ( / 51 2.D0 , 51 2.D0 , 10 0.D0 / ) ! to be corrected ... ! elastic parameters defects % Einclusions ( i )% omnu = 1.D0 - 2.D0 * defects % Einclusions ( i )% nu defects % Einclusions ( i )% pre = 1.D0 / ( 8.D0 * cPi * ( 1.D0 - defects % Einclusions ( i )% nu )) ! volume defects % Einclusions ( i )% V = 4.D0 * cPi * defects % Einclusions ( i )% a1 * defects % Einclusions ( i )% a2 * defects % Einclusions ( i )% a3 / 3.D0 ! and some other derived constants defects % Einclusions ( i )% a12 = defects % Einclusions ( i )% a1 ** 2 defects % Einclusions ( i )% a22 = defects % Einclusions ( i )% a2 ** 2 defects % Einclusions ( i )% a32 = defects % Einclusions ( i )% a3 ** 2 defects % Einclusions ( i )% asq = ( / defects % Einclusions ( i )% a12 , defects % Einclusions ( i )% a22 , defects % Einclusions ( i )% a32 / ) defects % Einclusions ( i )% eta = defects % Einclusions ( i )% a12 + defects % Einclusions ( i )% a22 + defects % Einclusions ( i )% a32 ! used in s variable (to compute lambda) defects % Einclusions ( i )% ss1 = 3.D0 * ( defects % Einclusions ( i )% a12 * defects % Einclusions ( i )% a22 + & defects % Einclusions ( i )% a22 * defects % Einclusions ( i )% a32 + & defects % Einclusions ( i )% a32 * defects % Einclusions ( i )% a12 ) defects % Einclusions ( i )% svec = 3.D0 * ( / defects % Einclusions ( i )% eta - defects % Einclusions ( i )% a12 , & defects % Einclusions ( i )% eta - defects % Einclusions ( i )% a22 , & defects % Einclusions ( i )% eta - defects % Einclusions ( i )% a32 / ) ! used in q variable (to compute lambda) defects % Einclusions ( i )% qs1 = ( defects % Einclusions ( i )% eta - 3.D0 * defects % Einclusions ( i )% a12 ) * & ( defects % Einclusions ( i )% eta - 3.D0 * defects % Einclusions ( i )% a22 ) * & ( defects % Einclusions ( i )% eta - 3.D0 * defects % Einclusions ( i )% a32 ) defects % Einclusions ( i )% qvec1 = 9.D0 * ( / defects % Einclusions ( i )% a12 , defects % Einclusions ( i )% a22 , defects % Einclusions ( i )% a32 / ) defects % Einclusions ( i )% qvec2 = 9.D0 * ( / defects % Einclusions ( i )% a12 ** 2 + 2.D0 * defects % Einclusions ( i )% a22 * defects % Einclusions ( i )% a32 ,& defects % Einclusions ( i )% a22 ** 2 + 2.D0 * defects % Einclusions ( i )% a12 * defects % Einclusions ( i )% a32 ,& defects % Einclusions ( i )% a32 ** 2 + 2.D0 * defects % Einclusions ( i )% a12 * defects % Einclusions ( i )% a22 / ) ! Delta matrix  (we'll symmetrize it) defects % Einclusions ( i )% Deltaij = 0.D0 defects % Einclusions ( i )% Deltaij ( 1 , 2 ) = defects % Einclusions ( i )% a12 - defects % Einclusions ( i )% a22 defects % Einclusions ( i )% Deltaij ( 1 , 3 ) = defects % Einclusions ( i )% a12 - defects % Einclusions ( i )% a32 defects % Einclusions ( i )% Deltaij ( 2 , 3 ) = defects % Einclusions ( i )% a22 - defects % Einclusions ( i )% a32 defects % Einclusions ( i )% Deltaij ( 2 , 1 ) = defects % Einclusions ( i )% Deltaij ( 1 , 2 ) defects % Einclusions ( i )% Deltaij ( 3 , 1 ) = defects % Einclusions ( i )% Deltaij ( 1 , 3 ) defects % Einclusions ( i )% Deltaij ( 3 , 2 ) = defects % Einclusions ( i )% Deltaij ( 2 , 3 ) defects % Einclusions ( i )% Deltaij = dsqrt ( defects % Einclusions ( i )% Deltaij ) ! second argument of Elliptic functions defects % Einclusions ( i )% kEl = defects % Einclusions ( i )% Deltaij ( 1 , 2 ) / defects % Einclusions ( i )% Deltaij ( 1 , 3 ) ! some other prefactors defects % Einclusions ( i )% preI1 = 3.D0 * & defects % Einclusions ( i )% V / defects % Einclusions ( i )% Deltaij ( 1 , 2 ) ** 2 / defects % Einclusions ( i )% Deltaij ( 1 , 3 ) defects % Einclusions ( i )% preI3 = 3.D0 * & defects % Einclusions ( i )% V / defects % Einclusions ( i )% Deltaij ( 2 , 3 ) ** 2 / defects % Einclusions ( i )% Deltaij ( 1 , 3 ) defects % Einclusions ( i )% s3 = dsqrt ( 3.D0 ) defects % Einclusions ( i )% c1 = 2.D0 ** ( 1.D0 / 3.D0 ) defects % Einclusions ( i )% c2 = 6.D0 * 2.D0 ** ( 2.D0 / 3.D0 ) defects % Einclusions ( i )% math = dasin ( dsqrt ( defects % Einclusions ( i )% Deltaij ( 1 , 3 ) ** 2 / defects % Einclusions ( i )% a12 )) ! next we need the largest possible lambda value; we'll have the user pass in the coordinates of the furthest point r2 = maxr ** 2 rsq = sum ( r2 ) s = dcmplx ( ( rsq - defects % Einclusions ( i )% eta ) ** 2 + sum ( defects % Einclusions ( i )% svec * r2 ) - defects % Einclusions ( i )% ss1 , 0.D0 ) q = dcmplx ( - 2.D0 * rsq ** 3 - 3.D0 * defects % Einclusions ( i )% eta * rsq ** 2 + rsq * ( 3.D0 * defects % Einclusions ( i )% eta ** 2 + & sum ( defects % Einclusions ( i )% qvec1 * r2 )) - sum ( defects % Einclusions ( i )% qvec2 * r2 ) - defects % Einclusions ( i )% qs1 , 0.D0 ) t = ( q + sqrt ( q * q - 4.D0 * s * s * s ) ) ** ( 1.D0 / 3.D0 ) v = real ( t ) w = abs ( imag ( t )) modt = v ** 2 + w ** 2 lambda = ( rsq - defects % Einclusions ( i )% eta ) / 3.D0 + & ( v + defects % Einclusions ( i )% s3 * w ) * ( 2.D0 * real ( s ) + defects % Einclusions ( i )% c1 * modt ) / defects % Einclusions ( i )% c2 / modt defects % Einclusions ( i )% mith = dasin ( defects % Einclusions ( i )% Deltaij ( 1 , 3 ) / dsqrt ( defects % Einclusions ( i )% a12 + lambda )) ! pre-compute the look-up tables for the elliptic integrals allocate ( z ( defects % Einclusions ( i )% nLUT )) dth = ( defects % Einclusions ( i )% math - defects % Einclusions ( i )% mith ) / dble ( defects % Einclusions ( i )% nLUT - 1 ) do j = 1 , defects % Einclusions ( i )% nLUT z ( j ) = defects % Einclusions ( i )% mith + dble ( j - 1 ) * dth end do allocate ( defects % Einclusions ( i )% EFLUT ( defects % Einclusions ( i )% nLUT )) allocate ( defects % Einclusions ( i )% EELUT ( defects % Einclusions ( i )% nLUT )) defects % Einclusions ( i )% EFLUT = 0.D0 defects % Einclusions ( i )% EELUT = 0.D0 do j = 1 , defects % Einclusions ( i )% nLUT defects % Einclusions ( i )% EFLUT ( j ) = el1k ( z ( j ), defects % Einclusions ( i )% kEl ) defects % Einclusions ( i )% EELUT ( j ) = el2k ( z ( j ), defects % Einclusions ( i )% kEl ) end do defects % Einclusions ( i )% thpre = dble ( defects % Einclusions ( i )% nLUT - 1 ) / ( defects % Einclusions ( i )% math - defects % Einclusions ( i )% mith ) deallocate ( z ) ! also, when lambda=0 (inside the ellipsoid), we can simplify things a little ! by using precomputed II and IIJ arrays; in that case we use math to compute ! the integrals EF = defects % Einclusions ( i )% EFLUT ( defects % Einclusions ( i )% nLUT ) EE = defects % Einclusions ( i )% EELUT ( defects % Einclusions ( i )% nLUT ) Delta = defects % Einclusions ( i )% a1 * defects % Einclusions ( i )% a2 * defects % Einclusions ( i )% a3 ! first order integrals II1 = defects % Einclusions ( i )% preI1 * ( EF - EE ) II3 = defects % Einclusions ( i )% preI3 * ( defects % Einclusions ( i )% Deltaij ( 1 , 3 ) * defects % Einclusions ( i )% a22 / Delta - EE ) IIinside = ( / II1 , 3.D0 * defects % Einclusions ( i )% V / Delta - II1 - II3 , II3 / ) defects % Einclusions ( i )% IIinside = IIinside ! second order integrals IIJinside = 0.D0 IIJinside ( 1 , 2 ) = - ( defects % Einclusions ( i )% IIinside ( 1 ) - defects % Einclusions ( i )% IIinside ( 2 )) / defects % Einclusions ( i )% Deltaij ( 1 , 2 ) ** 2 IIJinside ( 2 , 1 ) = IIJinside ( 1 , 2 ) IIJinside ( 1 , 3 ) = - ( defects % Einclusions ( i )% IIinside ( 1 ) - defects % Einclusions ( i )% IIinside ( 3 )) / defects % Einclusions ( i )% Deltaij ( 1 , 3 ) ** 2 IIJinside ( 3 , 1 ) = IIJinside ( 1 , 3 ) IIJinside ( 2 , 3 ) = - ( defects % Einclusions ( i )% IIinside ( 2 ) - defects % Einclusions ( i )% IIinside ( 3 )) / defects % Einclusions ( i )% Deltaij ( 2 , 3 ) ** 2 IIJinside ( 3 , 2 ) = IIJinside ( 2 , 3 ) IIJinside ( 1 , 1 ) = defects % Einclusions ( i )% V / defects % Einclusions ( i )% a12 / Delta - ( IIJinside ( 1 , 2 ) + IIJinside ( 1 , 3 )) / 3.D0 IIJinside ( 2 , 2 ) = defects % Einclusions ( i )% V / defects % Einclusions ( i )% a22 / Delta - ( IIJinside ( 2 , 1 ) + IIJinside ( 2 , 3 )) / 3.D0 IIJinside ( 3 , 3 ) = defects % Einclusions ( i )% V / defects % Einclusions ( i )% a32 / Delta - ( IIJinside ( 3 , 1 ) + IIJinside ( 3 , 2 )) / 3.D0 defects % Einclusions ( i )% IIJinside = IIJinside ! and finally the Eshelby S tensor for inside the inclusion (i.e., lambda=0) ES = 0.D0 do ii = 1 , 3 do j = 1 , 3 do k = 1 , 3 do ll = 1 , 3 Es ( ii , j , k , ll ) = kdelta ( ii , j ) * kdelta ( k , ll ) * ( 2.D0 * defects % Einclusions ( i )% nu * IIinside ( ii ) - IIinside ( k ) + & defects % Einclusions ( i )% a123 ( ii ) ** 2 * IIJinside ( k , ii )) + ( kdelta ( ii , k ) * kdelta ( j , ll ) + kdelta ( j , k ) * kdelta ( ii , ll )) * & ( defects % Einclusions ( i )% a123 ( ii ) ** 2 * IIJinside ( ii , j ) - IIinside ( j ) + ( 1.D0 - defects % Einclusions ( i )% nu ) * & ( IIinside ( k ) + IIinside ( ll ))) end do end do end do end do ES = ES / ( 8.0 * cPi * ( 1.D0 - defects % Einclusions ( i )% nu )) defects % Einclusions ( i )% EshelbyS = ES ! convert this tensor to Voigt notation as a 6x6 matrix ESV = 0.D0 ESV ( 1 , 1 ) = ES ( 1 , 1 , 1 , 1 ) ESV ( 2 , 2 ) = ES ( 2 , 2 , 2 , 2 ) ESV ( 3 , 3 ) = ES ( 3 , 3 , 3 , 3 ) ESV ( 4 , 4 ) = ES ( 2 , 3 , 2 , 3 ) ESV ( 5 , 5 ) = ES ( 3 , 1 , 3 , 1 ) ESV ( 6 , 6 ) = ES ( 1 , 2 , 1 , 2 ) ESV ( 1 , 2 ) = ES ( 1 , 1 , 2 , 2 ) ESV ( 1 , 3 ) = ES ( 1 , 1 , 3 , 3 ) ESV ( 2 , 1 ) = ES ( 2 , 2 , 1 , 1 ) ESV ( 3 , 1 ) = ES ( 3 , 3 , 1 , 1 ) ESV ( 3 , 2 ) = ES ( 3 , 3 , 2 , 2 ) ESV ( 2 , 3 ) = ES ( 2 , 2 , 3 , 3 ) defects % Einclusions ( i )% ESV = ESV end subroutine InitializeEshelbyInclusion","tags":"","loc":"proc/initializeeshelbyinclusion.html","title":"InitializeEshelbyInclusion – Fortran Program"},{"text":"public recursive subroutine CalcR(cell, defects, i, j) Uses: local constants crystal rotations proc~~calcr~~UsesGraph proc~calcr CalcR crystal crystal crystal->proc~calcr rotations rotations rotations->proc~calcr local local local->proc~calcr module~constants constants local->module~constants module~constants->proc~calcr Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief returns the total displacement vector for each slice in a column\n @details Note that the end result MUST be expressed in the cartesian reference frame !\n @param cell unit cell pointer\n @param defects defect structure\n @param i integer x coordinate \n @param j integer y coordinate Note This entire routine was thoroughly verified after the quaternion conversion ! General comment for those who wish to add other defects... the general procedure to implement a defect displacement field is as follows:\n - if the defect has its own reference frame, then transform (xpos,ypos,zpos) to\n   that frame (see the dislocation section below for an example), and then do\n   the computation of the displacement vector and express it in the cartesian frame. if the defect uses the foil reference frame (e.g., voids, inclusions), then use tmpf\n  as the current position vector.\n @date  10/20/98 MDG 1.0 original\n @date   5/22/01 MDG 2.0 f90\n @date  11/27/01 MDG 2.1 added kind support\n @date  03/26/13 MDG 3.0 updated IO\n @date  10/30/13 MDG 3.1 debug of coordinate rotations\n @date  11/13/13 MDG 3.2 finally, the bug has been found! @date  06/09/14 MDG 4.0 introduced defects argument and simplified routine\n @date  06/10/14 MDG 4.1 added foil argument\n @date  11/23/15 MDG 4.2 removed foil argument and placed it inside defects Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(defecttype), intent(inout) :: defects integer(kind=irg), intent(in) :: i integer(kind=irg), intent(in) :: j Calls proc~~calcr~~CallsGraph proc~calcr CalcR float float proc~calcr->float proc~eshelby_disp Eshelby_disp proc~calcr->proc~eshelby_disp sngl sngl proc~calcr->sngl proc~yshdisp~2 YSHDisp proc~calcr->proc~yshdisp~2 calclength calclength proc~calcr->calclength qu2om qu2om proc~calcr->qu2om quat_lp quat_lp proc~calcr->quat_lp dasin dasin proc~eshelby_disp->dasin kdelta kdelta proc~eshelby_disp->kdelta datan2 datan2 proc~yshdisp~2->datan2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code CalcR Source Code recursive subroutine CalcR ( cell , defects , i , j ) !DEC$ ATTRIBUTES DLLEXPORT :: CalcR use local use constants use crystal use rotations IMPLICIT NONE type ( unitcell ), pointer :: cell type ( defecttype ), INTENT ( INOUT ) :: defects integer ( kind = irg ), INTENT ( IN ) :: i , j integer ( kind = irg ) :: k , islice , ii real ( kind = dbl ) :: dis , xpos , ypos , zpos , sumR ( 3 ), thick , tmp ( 3 ), tmp2 ( 3 ), & tmpf ( 3 ), u ( 3 ), zaamp , zaphase , zar , zai , zr ( 3 ), zi ( 3 ), & zt , fx , fy , fz , a_fm ( 3 , 3 ), ar !,& !                                nu,x,y,z,zn,t,pre,r1,r2,r3,th,rn complex ( kind = dbl ) :: za ( 3 ) complex ( kind = sgl ) :: zero logical :: isvoid ! scale the image coordinates with respect to the origin at the center of the image xpos = float ( i - defects % DF_npix / 2 ) * defects % DF_L ypos = float ( j - defects % DF_npiy / 2 ) * defects % DF_L ! determine the starting point of the z-integration for the tilted foil ! this depends on the foil normal components which give the equation ! of the top foil plane as F . r = z0/2, from which we get zt... a_fm = qu2om ( defects % foil % a_fm ) fx = a_fm ( 3 , 1 ) fy = a_fm ( 3 , 2 ) fz = a_fm ( 3 , 3 ) zt = defects % foil % zb * 0.5 - ( fx * xpos + fy * ypos ) / fz ! initialize some other variables thick = defects % foil % zb zero = cmplx ( 0.0 , 0.0 ) ! loop over all slices (this is the main loop) sliceloop : do islice = 1 , defects % DF_nums ! zpos is the position down the column, starting at zt (in image coordinates) zpos = zt - float ( islice ) * defects % DF_slice ! set the displacements to zero sumR = 0.0 ! set the position in the foil reference frame tmpf = quat_Lp ( defects % foil % a_fi , dble ( ( / xpos , ypos , zpos / )) ) !------------ !----VOIDS--- !------------ ! voids are easy to deal with; we simply return -10000 for each point tmpf that lies inside ! one of the voids; the calling routine then knows to use the void scattering matrix. if ( defects % numvoids . ne . 0 ) then ! are we inside a void ? isvoid = . FALSE . voidloop : do ii = 1 , defects % numvoids ! subtract the void position from the current slice position to get the relative position vector tmp = tmpf - ( / defects % voids ( ii )% xpos , defects % voids ( ii )% ypos , defects % voids ( ii )% zpos / ) dis = CalcLength ( cell , tmp , 'c' ) if ( dis . lt . defects % voids ( ii )% radius ) then ! inside void isvoid = . TRUE . exit voidloop end if end do voidloop ! skip the rest of the computation for this slice if we are inside a void if ( isvoid . eqv .. TRUE .) then defects % DF_R ( islice , 1 ) = - 1000 0.0 cycle sliceloop end if end if ! ok, if we get here, then we're not inside a void... !------------------ !----CURVED FOIL--- !------------------ ! first we take the foil shape into account using equations (8.28) and (8.29) sumR = sumR + float ( islice ) * defects % DF_slice * defects % foil % sg ( i , j ) * defects % DF_gstar !----------------- !--DISLOCATIONS-- !----------------- ! let's put a few dislocations in ... (see section 8.4.2) do ii = 1 , defects % numdisl ! compute the difference vector between the current (xpos,ypos,zpos) in the foil reference frame ! and the defect center coordinate tmp2 = tmpf - dble (( / defects % DF_L * defects % DL ( ii )% id , defects % DF_L * defects % DL ( ii )% jd , defects % DL ( ii )% zfrac * defects % foil % z0 / )) ! then convert the difference vector to the defect reference frame for this dislocation (we will only need the x and y coordinates) tmp = quat_Lp ( defects % DL ( ii )% a_df , tmp2 ) ! compute x1 + p_alpha x2  (eq. 8.38) za ( 1 : 3 ) = tmp ( 1 ) + defects % DL ( ii )% pa ( 1 : 3 ) * tmp ( 2 ) ! compute the displacement vector u (eq. 8.38) [this expands the log of a complex number and takes the real part only, ! taking proper care of the branch cut] if ( tmp ( 1 ). gt . 0.0 ) then do k = 1 , 3 zar = real ( za ( k )) zai = aimag ( za ( k )) zaamp = abs ( za ( k )) zaphase = abs ( zai / zar ) zr ( k ) = log ( zaamp ) zi ( k ) = atan ( zaphase ) if ( zar . le . 0.0 ) then if ( zai . lt . 0.0 ) zi ( k ) = - cPi + zi ( k ) if ( zai . eq . 0.0 ) zi ( k ) = cPi if ( zai . gt . 0.0 ) zi ( k ) = cPi - zi ( k ) else if ( zai . lt . 0.0 ) zi ( k ) = - zi ( k ) end if end do else do k = 1 , 3 zar = real ( za ( k )) zai = aimag ( za ( k )) zaamp = abs ( za ( k )) zaphase = abs ( zai / zar ) zr ( k ) = log ( zaamp ) zi ( k ) = atan ( zaphase ) if ( zar . le . 0.0 ) then if ( zai . gt . 0.0 ) zi ( k ) = cPi - zi ( k ) if ( zai . eq . 0.0 ) zi ( k ) = cPi if ( zai . lt . 0.0 ) zi ( k ) = cPi + zi ( k ) else if ( zai . lt . 0.0 ) zi ( k ) = 2.0 * cPi - zi ( k ) if ( zai . eq . 0.0 ) zi ( k ) = 0.0 end if end do end if u = 2.0 * real ( matmul ( defects % DL ( ii )% dismat , cmplx ( zr , zi ))) ! transform displacement vector u to the Cartesian crystal reference frame u = quat_Lp ( conjg ( defects % DL ( ii )% a_dc ), dble ( u ) ) sumR = sumR + u end do !------------------------------------- !--SURFACE INTERSECTING DISLOCATIONS-- !------------------------------------- ! this part is mostly used for ECCI-type image simulations, not for EM or STEM, ! although it could probably be used there as well; we would need to extend it ! to incorporate both top and bottom foil surfaces ! do we have any dislocations with surface relaxations ?  YSH model if ( defects % numYdisl . gt . 0 ) then do ii = 1 , defects % numYdisl ! first, figure out what the coordinates are in the YSH reference frame for this dislocation ... ! translate to the defect origin tmp = tmpf - ( / defects % DF_L * defects % YD ( ii )% id , defects % DF_L * defects % YD ( ii )% jd , defects % foil % z0 * 0.5 / ) ! rotate into the defect reference frame tmp = quat_Lp ( conjg ( defects % YD ( ii )% a_di ), tmp ) ! compute the displacement vector !     u = sngl(YSHDisp(dble(tmp(2)),-dble(tmp(1)),dble(tmp(3)),ii)) u = sngl ( YSHDisp ( defects , dble ( tmp ( 1 )), dble ( tmp ( 2 )), dble ( tmp ( 3 )), ii )) ! and rotate back to the image reference frame u = quat_Lp ( conjg ( defects % YD ( ii )% a_id ), u ) u = quat_Lp ( defects % foil % a_ic , u ) ! that should do it ! sumR = sumR + u end do end if !-------------------- !--STACKING FAULTS-- !-------------------- ! stacking faults (this is easy because we've already done all the work in the stacking_fault module) ! all we need is the z-value at which the stacking fault plane is crossed in this particular image ! column; from that point on, we simply add the leading partial Burgers vector to the total displacement. do ii = 1 , defects % numsf if (( zpos . lt . defects % SF ( ii )% zpos ( i , j )). and .( defects % SF ( ii )% zpos ( i , j ). ne . - 1000 0.0 )) then sumR = sumR + defects % SF ( ii )% lpbc end if end do !-------------------- !--LARGE INCLUSIONS--  currently commented out !-------------------- ! Mader's expression for the displacement field of a large inclusion !   if (0.eq.1.) then !    nu = 0.25 !    ce = 0.005 !    rn = 25.0*DF_L !    x = (float(i-DF_npix/2)-0.5)*DF_L !    y = (float(j-DF_npiy/2)-0.5)*DF_L !    z = float(k)*DF_slice !    zn = 100.5*DF_slice !    t = DF_slice * DF_nums !    pre = (1.0+nu)/(3.0*(1.0-nu))*ce*rn**3 ! !    r1 = sqrt(x**2+y**2+(z-zn)**2) !    r2 = sqrt(x**2+y**2+(z+zn)**2) !    r3 = sqrt(x**2+y**2+(2.0*t-z-zn)**2) ! !    if (((r1.eq.0.0).or.(r2.eq.0.0)).or.(r3.eq.0.0)) then !      return !    else !     dis = (1.0/r1**3+(3.0-4.0*nu)/r2**3-6.0*z*(z+zn)/r2**5+(3.0-4.0*nu)/r3**3-6.0*(t-z)*(2.0*t-z-zn)/r3**5) !     rx = x*dis !     ry = y*dis !     rz = (z-zn)/r1**3-(3.0-4.0*nu)*((z+zn)/r2**3+(2.0*t-z-zn)/r3**3)-6.0*z*(z+zn)**2/r2**5 + & !          2.0*z/r2**3+6.0*(t-z)*(2.0*t-z-zn)**2/r3**5-2.0*(t-z)/r3**3 ! !     sumR = pre*(/ rx, ry, rz /) !     return !    end if !   end if !-------------------- !--SMALL INCLUSIONS-- !-------------------- ! then the coherent precipitates, using the model in section 8.4.1 if ( defects % numinc . gt . 0 ) then do ii = 1 , defects % numinc ! subtract the inclusion position from the current slice position to get the relative position vector tmp = tmpf - ( / defects % inclusions ( ii )% xpos , defects % inclusions ( ii )% ypos , defects % inclusions ( ii )% zpos / ) dis = CalcLength ( cell , tmp , 'c' ) if ( dis . ge . defects % inclusions ( ii )% radius ) then ! outside particle tmp = tmp * ( defects % inclusions ( ii )% radius / dis ) ** 3 end if sumR = sumR + defects % inclusions ( ii )% C * tmp end do end if !--------------------- !--SMALL EINCLUSIONS-- !--------------------- ! then the coherent ellipsoidally distorted precipitates, using Eshelby's model if ( defects % numEinc . gt . 0 ) then do ii = 1 , defects % numEinc ! subtract the inclusion position from the current slice position to get the relative position vector tmp = tmpf - ( / defects % Einclusions ( ii )% xpos , defects % Einclusions ( ii )% ypos , defects % Einclusions ( ii )% zpos / ) ! and also get the position vector for the mirror image inclusion, to make sure we get a traction-free surface... tmp2 = tmpf - ( / defects % Einclusions ( ii )% xpos , defects % Einclusions ( ii )% ypos , - defects % Einclusions ( ii )% zpos / ) u = Eshelby_disp ( defects , ii , tmp ) + Eshelby_disp ( defects , ii , tmp2 ) ! we need to check the reference frame here ! sumR = sumR + u end do end if ! TO BE IMPLEMENTED FOR RICHARD LESAR'S Discrete Dislocation Dynamics ! ! finally any displacement fields defined by the user routine UserDisp ! sumR = sumR + UserDisp() ! TO BE IMPLEMENTED FOR YUNZHI WANG's Dislocation Simulations ! ! finally any displacement fields defined by the user routine UserDisp ! sumR = sumR + UserDisp() defects % DF_R ( islice , 1 : 3 ) = sumR ( 1 : 3 ) end do sliceloop ! main loop over the slices end subroutine CalcR","tags":"","loc":"proc/calcr.html","title":"CalcR – Fortran Program"},{"text":"private recursive function DI_RotateToMu(N, lmu, y) result(ymu) Uses: local proc~~di_rotatetomu~~UsesGraph proc~di_rotatetomu DI_RotateToMu local local local->proc~di_rotatetomu Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University \n @brief Rotate an array of quaternions to an average direction lmu using the null space approach\n @param N number of samples to return\n @param seed random number generator seed value\n @param mu mean direction (unit quaternion)\n @param kappa concentration\n @date 02/05/15 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: N real(kind=dbl), intent(in) :: lmu (4) real(kind=dbl), intent(in) :: y (4,N) Return Value real(kind=dbl)\n  (4,N) Calls proc~~di_rotatetomu~~CallsGraph proc~di_rotatetomu DI_RotateToMu dgesvd dgesvd proc~di_rotatetomu->dgesvd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~di_rotatetomu~~CalledByGraph proc~di_rotatetomu DI_RotateToMu proc~di_sampledd DI_SampleDD proc~di_sampledd->proc~di_rotatetomu Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code DI_RotateToMu Source Code recursive function DI_RotateToMu ( N , lmu , y ) result ( ymu ) !DEC$ ATTRIBUTES DLLEXPORT :: DI_RotateToMu use local IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: N real ( kind = dbl ), INTENT ( IN ) :: lmu ( 4 ) real ( kind = dbl ), INTENT ( IN ) :: y ( 4 , N ) real ( kind = dbl ) :: ymu ( 4 , N ) integer ( kind = irg ) :: i ! parameters for the singular value decomposition integer ( kind = irg ) :: nr , LDA , LDU , LDVT , lwork , info real ( kind = dbl ) :: mA ( 4 , 4 ), ss ( 4 ), u ( 4 , 4 ), vt , work ( 20 ) ! Rotate the distribution along the desired mean direction mu ! In Matlab, one uses the null() operator which returns the null space of the argument ! This is then inserted into a 4x4 rotation matrix and multiplied with the quaternions ! from the random sample.  The null space of the input quaternion can be computed with ! singular value decomposition, which is done with the dgesvd Lapack routine. The matrix ! returned as u is the desired rotation matrix, except that the numbers in the first ! column must have their signs reversed. mA = 0.D0 mA ( 1 : 4 , 1 ) = lmu ( 1 : 4 ) nr = 4 LDA = 4 LDVT = 1 LDU = 4 lwork = 20 call DGESVD ( 'A' , 'N' , nr , nr , mA , LDA , ss , u , LDU , vt , LDVT , work , lwork , info ) u ( 1 : 4 , 1 ) = - u ( 1 : 4 , 1 ) ! next, apply this 4x4 rotation matrix to all of the generated quaternions to ! rotate them along the mean direction mu do i = 1 , N ymu ( 1 : 4 , i ) = matmul ( u , y ( 1 : 4 , i )) end do end function DI_RotateToMu","tags":"","loc":"proc/di_rotatetomu.html","title":"DI_RotateToMu – Fortran Program"},{"text":"private recursive function randUniformSphere(N, seed) result(ranSphere) Uses: local math proc~~randuniformsphere~~UsesGraph proc~randuniformsphere randUniformSphere math math math->proc~randuniformsphere local local local->proc~randuniformsphere Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University / Yu-Hui Chen, U. Michigan\n @brief Return a set of random vectors on the sphere S&#94;2 using normal random sampling\n @param N number of samples to return\n @param seed random number generator seed value\n @date 01/07/15 MDG 1.0 original, based on Yu-Hui's Matlab code, output transposed Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: N integer(kind=irg), intent(inout) :: seed Return Value real(kind=dbl)\n  (3,N) Calls proc~~randuniformsphere~~CallsGraph proc~randuniformsphere randUniformSphere r8vec_normal_01 r8vec_normal_01 proc~randuniformsphere->r8vec_normal_01 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~randuniformsphere~~CalledByGraph proc~randuniformsphere randUniformSphere proc~di_sampledd DI_SampleDD proc~di_sampledd->proc~randuniformsphere Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code randUniformSphere Source Code recursive function randUniformSphere ( N , seed ) result ( ranSphere ) !DEC$ ATTRIBUTES DLLEXPORT :: randUniformSphere use local use math IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: N integer ( kind = irg ), INTENT ( INOUT ) :: seed real ( kind = dbl ) :: ranSphere ( 3 , N ) real ( kind = dbl ) :: nq , NR ( N * 3 ), randNorm ( 3 , N ) integer ( kind = irg ) :: i ranSphere = 0.D0 call R8VEC_normal_01 ( N * 3 , seed , NR ) randNorm = reshape ( NR , ( / 3 , N / ) ) ! and normalize the three-vectors do i = 1 , N nq = dsqrt ( sum ( randNorm ( 1 : 3 , i ) ** 2 )) RanSphere ( 1 : 3 , i ) = randNorm ( 1 : 3 , i ) / nq end do end function randUniformSphere","tags":"","loc":"proc/randuniformsphere.html","title":"randUniformSphere – Fortran Program"},{"text":"public recursive function DI_SampleDD(N, seed, mu, kappa, Dtype) result(sDD) Uses: local error proc~~di_sampledd~~UsesGraph proc~di_sampledd DI_SampleDD error error error->proc~di_sampledd local local local->proc~di_sampledd Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University / Yu-Hui Chen, U. Michigan\n @brief Sample a directional distribution (VMF or WAT) on the quaternion unit sphere\n @param N number of samples to return\n @param seed random number generator seed value\n @param mu mean direction (unit quaternion)\n @param kappa concentration\n @param Dtype 'VMF' for von-Mises-Fisher  or 'WAT' for axial Watson\n @date 01/07/15 MDG 1.0 original, based on Yu-Hui's Matlab code Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: N integer(kind=irg), intent(inout) :: seed real(kind=dbl), intent(in) :: mu (4) real(kind=dbl), intent(in) :: kappa character(len=3), intent(in) :: Dtype Return Value real(kind=dbl)\n  (4,N) Calls proc~~di_sampledd~~CallsGraph proc~di_sampledd DI_SampleDD proc~di_rotatetomu DI_RotateToMu proc~di_sampledd->proc~di_rotatetomu proc~randddmarginal randDDMarginal proc~di_sampledd->proc~randddmarginal fatalerror fatalerror proc~di_sampledd->fatalerror proc~randuniformsphere randUniformSphere proc~di_sampledd->proc~randuniformsphere dgesvd dgesvd proc~di_rotatetomu->dgesvd r8_uniform_01 r8_uniform_01 proc~randddmarginal->r8_uniform_01 proc~watsonmeandirdensity WatsonMeanDirDensity proc~randddmarginal->proc~watsonmeandirdensity proc~getdddensitylbm getDDDensityLBM proc~randddmarginal->proc~getdddensitylbm proc~vmfmeandirdensity VMFMeanDirDensity proc~randddmarginal->proc~vmfmeandirdensity r8vec_normal_01 r8vec_normal_01 proc~randuniformsphere->r8vec_normal_01 proc~watsonmeandirdensity->fatalerror dexp dexp proc~watsonmeandirdensity->dexp proc~getdddensitylbm->fatalerror proc~getdddensitylbm->proc~watsonmeandirdensity proc~getdddensitylbm->proc~vmfmeandirdensity proc~vmfmeandirdensity->fatalerror proc~vmfmeandirdensity->dexp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code DI_SampleDD Source Code recursive function DI_SampleDD ( N , seed , mu , kappa , Dtype ) result ( sDD ) !DEC$ ATTRIBUTES DLLEXPORT :: DI_SampleDD use local use error IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: N integer ( kind = irg ), INTENT ( INOUT ) :: seed real ( kind = dbl ), INTENT ( IN ) :: mu ( 4 ) real ( kind = dbl ), INTENT ( IN ) :: kappa character ( 3 ), INTENT ( IN ) :: Dtype real ( kind = dbl ) :: sDD ( 4 , N ) real ( kind = dbl ) :: nq , tmpmu ( 4 ), RandSphere ( 3 , N ), t ( N ), RS ( 4 , N ), lmu ( 4 ), y ( 4 , N ) integer ( kind = irg ) :: i ! make sure the input quaternion is normalized nq = dsqrt ( sum ( mu * mu )) if ( nq . eq . 0.D0 ) call FatalError ( 'DI_SampleDD' , 'Input quaternion has zero length' ) lmu = mu / nq ! initialize a bunch of parameters tmpmu = ( / 1.D0 , 0.D0 , 0.D0 , 0.D0 / ) sDD = 0.D0 RS = 0.D0 ! get the t-parameter t = randDDMarginal ( N , kappa , seed , Dtype ) ! and the distribution of random directions on the 2-sphere RandSphere = randUniformSphere ( N , seed ) RS ( 2 : 4 , 1 : N ) = RandSphere ( 1 : 3 , 1 : N ) ! merge these two parameters into the desired random variables y = transpose ( spread ( t , DIM = 2 , NCOPIES = 4 ) * spread ( tmpmu , DIM = 1 , NCOPIES = N ) + & spread ( dsqrt ( 1.D0 - t * t ), DIM = 2 , NCOPIES = 4 ) * transpose ( RS ) ) ! Rotate the distribution along the desired mean direction mu sDD = DI_RotateToMu ( N , lmu , y ) end function DI_SampleDD","tags":"","loc":"proc/di_sampledd.html","title":"DI_SampleDD – Fortran Program"},{"text":"private recursive function randDDMarginal(N, k, seed, Dtype) result(t) Uses: local math proc~~randddmarginal~~UsesGraph proc~randddmarginal randDDMarginal math math math->proc~randddmarginal local local local->proc~randddmarginal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University / Yu-Hui Chen, U. Michigan\n @brief rejection sampling for the t parameter for the marginal directional distribution\n @details This algorithm samples the parameter t from a marginal distribution f(t), which\n by itself is the VMF or Watson distribution integrated around the mean direction.  These\n expressions were derived by Yu-Hui and verified by MDG [02/05/15] and then implemented;\n there are some typographical errors in the literature, and the versions documented here\n are correct [numerical verification].\n @param N number of samples to return\n @param k concentration\n @param seed random number generator seed value\n @param Dtype 'VMF' or 'WAT'\n @date 01/07/15 MDG 1.0 original, based on Yu-Hui's Matlab code\n @date 02/05/15 MDG 1.1 consolidated routines for VMF and WAT distributions Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: N real(kind=dbl), intent(in) :: k integer(kind=irg), intent(inout) :: seed character(len=3), intent(in) :: Dtype Return Value real(kind=dbl)\n  (N) Calls proc~~randddmarginal~~CallsGraph proc~randddmarginal randDDMarginal r8_uniform_01 r8_uniform_01 proc~randddmarginal->r8_uniform_01 proc~watsonmeandirdensity WatsonMeanDirDensity proc~randddmarginal->proc~watsonmeandirdensity proc~getdddensitylbm getDDDensityLBM proc~randddmarginal->proc~getdddensitylbm proc~vmfmeandirdensity VMFMeanDirDensity proc~randddmarginal->proc~vmfmeandirdensity fatalerror fatalerror proc~watsonmeandirdensity->fatalerror dexp dexp proc~watsonmeandirdensity->dexp proc~getdddensitylbm->proc~watsonmeandirdensity proc~getdddensitylbm->proc~vmfmeandirdensity proc~getdddensitylbm->fatalerror proc~vmfmeandirdensity->fatalerror proc~vmfmeandirdensity->dexp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~randddmarginal~~CalledByGraph proc~randddmarginal randDDMarginal proc~di_sampledd DI_SampleDD proc~di_sampledd->proc~randddmarginal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code randDDMarginal Source Code recursive function randDDMarginal ( N , k , seed , Dtype ) result ( t ) !DEC$ ATTRIBUTES DLLEXPORT :: randDDMarginal use local use math IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: N real ( kind = dbl ), INTENT ( IN ) :: k integer ( kind = irg ), INTENT ( INOUT ) :: seed character ( 3 ), INTENT ( IN ) :: Dtype real ( kind = dbl ) :: t ( N ) real ( kind = dbl ) :: LBM ( 2 ), h , x , C integer ( kind = irg ) :: i ! Find the left bound and maximum needed for rejection sampling C = 0.D0 LBM = getDDDensityLBM ( k , C , Dtype ) ! apply the rejection sampling algorithm to either VMF or Watson marginal distributions t = 0.D0 do i = 1 , N do x = r8_uniform_01 ( seed ) * ( 1.D0 - LBM ( 1 )) + LBM ( 1 ) if ( Dtype . eq . 'VMF' ) h = VMFMeanDirDensity ( x , k , C ) if ( Dtype . eq . 'WAT' ) h = WatsonMeanDirDensity ( x , k , C ) if ( r8_uniform_01 ( seed ) * LBM ( 2 ). le . h ) EXIT end do t ( i ) = x end do end function randDDMarginal","tags":"","loc":"proc/randddmarginal.html","title":"randDDMarginal – Fortran Program"},{"text":"private recursive function getDDDensityLBM(k, C, Dtype) result(LBM) Uses: local error proc~~getdddensitylbm~~UsesGraph proc~getdddensitylbm getDDDensityLBM error error error->proc~getdddensitylbm local local local->proc~getdddensitylbm Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University / Yu-Hui Chen, U. Michigan\n @brief determines the left bound and maximum for rejection sampling\n @param k concentration\n @param C constant prefactor of distribution function\n @param Dtype 'VMF' or 'WAT'\n @date 01/07/15 MDG 1.0 original, based on Yu-Hui's Matlab code\n @date 02/05/15 MDG 1.1 consolidated routines for VMF and WAT distributions Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: k real(kind=dbl), intent(inout) :: C character(len=3), intent(in) :: Dtype Return Value real(kind=dbl)\n  (2) Calls proc~~getdddensitylbm~~CallsGraph proc~getdddensitylbm getDDDensityLBM proc~watsonmeandirdensity WatsonMeanDirDensity proc~getdddensitylbm->proc~watsonmeandirdensity fatalerror fatalerror proc~getdddensitylbm->fatalerror proc~vmfmeandirdensity VMFMeanDirDensity proc~getdddensitylbm->proc~vmfmeandirdensity proc~watsonmeandirdensity->fatalerror dexp dexp proc~watsonmeandirdensity->dexp proc~vmfmeandirdensity->fatalerror proc~vmfmeandirdensity->dexp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~getdddensitylbm~~CalledByGraph proc~getdddensitylbm getDDDensityLBM proc~randddmarginal randDDMarginal proc~randddmarginal->proc~getdddensitylbm proc~di_sampledd DI_SampleDD proc~di_sampledd->proc~randddmarginal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getDDDensityLBM Source Code recursive function getDDDensityLBM ( k , C , Dtype ) result ( LBM ) !DEC$ ATTRIBUTES DLLEXPORT :: getDDDensityLBM use local use error IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: k real ( kind = dbl ), INTENT ( INOUT ) :: C character ( 3 ), INTENT ( IN ) :: Dtype real ( kind = dbl ) :: LBM ( 2 ) real ( kind = dbl ), parameter :: min_thresh = 0.00001D0 real ( kind = dbl ) :: s , x , start integer ( kind = irg ) :: f start = - 1.D0 if ( Dtype . eq . 'WAT' ) start = 0.D0 ! first we look for the left bound f = 1 do x = start + dble ( f ) * 0.00001D0 if ( x . eq . 1.D0 ) call FatalError ( 'getDDDensityLBM' , 'reached +1 in leftbound determination' ) if ( Dtype . eq . 'VMF' ) s = VMFMeanDirDensity ( x , k , C ) if ( Dtype . eq . 'WAT' ) s = WatsonMeanDirDensity ( x , k , C ) if ( s . ge . min_thresh ) EXIT f = f + 1 end do ! LBM ( 1 ) = start + dble ( f ) * 0.00001D0 if ( Dtype . eq . 'VMF' ) then ! for the simplified version of the density function, we have an analytical ! expression for where the maximum of the function occurs [convert the BesselI(3/2,x) ! to hyperbolic functions, then to exponential, and ignore the negative exponential ! which will be very small for reasonably sized k and t...] x = ( - 1.D0 + dsqrt ( 1.D0 + 4.D0 * k * k )) / ( 2.D0 * k ) LBM ( 2 ) = VMFMeanDirDensity ( x , k , C ) end if if ( Dtype . eq . 'WAT' ) then ! for the simplified version of the density function, we have an analytical ! expression for where the maximum of the function occurs x = dsqrt (( 2.D0 * k - 1.D0 ) / ( 2.D0 * k )) LBM ( 2 ) = WatsonMeanDirDensity ( x , k , C ) end if end function getDDDensityLBM","tags":"","loc":"proc/getdddensitylbm.html","title":"getDDDensityLBM – Fortran Program"},{"text":"private recursive function VMFMeanDirDensity(x, k, C) result(y) Uses: local constants math error proc~~vmfmeandirdensity~~UsesGraph proc~vmfmeandirdensity VMFMeanDirDensity math math math->proc~vmfmeandirdensity error error error->proc~vmfmeandirdensity local local local->proc~vmfmeandirdensity module~constants constants local->module~constants module~constants->proc~vmfmeandirdensity Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University / Yu-Hui Chen, U. Michigan\n @brief function to be sampled for VMF random sampling; we're using a close approximation\n @param x argument value\n @param k concentration\n @param C constant prefactor\n @date 01/07/15 MDG 1.0 original, based on Yu-Hui's Matlab code Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: x real(kind=dbl), intent(in) :: k real(kind=dbl), intent(inout) :: C Return Value real(kind=dbl) Calls proc~~vmfmeandirdensity~~CallsGraph proc~vmfmeandirdensity VMFMeanDirDensity fatalerror fatalerror proc~vmfmeandirdensity->fatalerror dexp dexp proc~vmfmeandirdensity->dexp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~vmfmeandirdensity~~CalledByGraph proc~vmfmeandirdensity VMFMeanDirDensity proc~randddmarginal randDDMarginal proc~randddmarginal->proc~vmfmeandirdensity proc~getdddensitylbm getDDDensityLBM proc~randddmarginal->proc~getdddensitylbm proc~getdddensitylbm->proc~vmfmeandirdensity proc~di_sampledd DI_SampleDD proc~di_sampledd->proc~randddmarginal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code VMFMeanDirDensity Source Code recursive function VMFMeanDirDensity ( x , k , C ) result ( y ) !DEC$ ATTRIBUTES DLLEXPORT :: VMFMeanDirDensity use local use constants use math use error IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: x real ( kind = dbl ), INTENT ( IN ) :: k real ( kind = dbl ), INTENT ( INOUT ) :: C real ( kind = dbl ) :: y if ( dabs ( x ). gt . 1.D0 ) call FatalError ( 'VMFMeanDirDensity' , 'argument must be in [-1,1]' ) ! explicit expression for p=4 (Gamma[3/2]Gamma[1/2] = pi/2) ! and the BesselI(3/2) function reduces to hyperbolic functions ! diverges for k->0, and becomes really small for large k if ( C . eq . 0.D0 ) then C = 2.D0 * k ** ( 2.5D0 ) / dsqrt ( 2.D0 * cPi ) / ( k - 1.D0 ) end if ! this is a close approximation, really good for larger values of k ! and numerically more stable than the original, which has problems for k>600 or so y = C * dexp ( k * ( x - 1.D0 )) * dsqrt ( 1.D0 - x * x ) end function VMFMeanDirDensity","tags":"","loc":"proc/vmfmeandirdensity.html","title":"VMFMeanDirDensity – Fortran Program"},{"text":"private recursive function WatsonMeanDirDensity(x, k, C) result(y) Uses: local constants math error proc~~watsonmeandirdensity~~UsesGraph proc~watsonmeandirdensity WatsonMeanDirDensity math math math->proc~watsonmeandirdensity error error error->proc~watsonmeandirdensity local local local->proc~watsonmeandirdensity module~constants constants local->module~constants module~constants->proc~watsonmeandirdensity Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief function to be sampled for Watson random sampling; we're using a close approximation\n @param x argument value\n @param k concentration\n @param C constant prefactor\n @date 02/05/15 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: x real(kind=dbl), intent(in) :: k real(kind=dbl), intent(inout) :: C Return Value real(kind=dbl) Calls proc~~watsonmeandirdensity~~CallsGraph proc~watsonmeandirdensity WatsonMeanDirDensity fatalerror fatalerror proc~watsonmeandirdensity->fatalerror dexp dexp proc~watsonmeandirdensity->dexp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~watsonmeandirdensity~~CalledByGraph proc~watsonmeandirdensity WatsonMeanDirDensity proc~randddmarginal randDDMarginal proc~randddmarginal->proc~watsonmeandirdensity proc~getdddensitylbm getDDDensityLBM proc~randddmarginal->proc~getdddensitylbm proc~getdddensitylbm->proc~watsonmeandirdensity proc~di_sampledd DI_SampleDD proc~di_sampledd->proc~randddmarginal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code WatsonMeanDirDensity Source Code recursive function WatsonMeanDirDensity ( x , k , C ) result ( y ) !DEC$ ATTRIBUTES DLLEXPORT :: WatsonMeanDirDensity use local use constants use math use error IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: x real ( kind = dbl ), INTENT ( IN ) :: k real ( kind = dbl ), INTENT ( INOUT ) :: C real ( kind = dbl ) :: y real ( kind = dbl ), parameter :: CC = 14 4.43253338822560946D0 ! 256/sqrt(pi) if ( dabs ( x ). gt . 1.D0 ) call FatalError ( 'WatsonMeanDirDensity' , 'argument must be in [-1,1]' ) ! approximate expression for p=4 if ( C . eq . 0.D0 ) then C = CC * k ** 4.5D0 / ( 52 5.D0 + 4.D0 * k * ( 4 5.D0 + 8.D0 * k * ( 3.D0 + 4.D0 * k ))) end if ! this is a close approximation, really good for larger values of k ! and numerically more stable than the original, which has problems for k>600 or so y = C * dexp ( k * ( x * x - 1.D0 )) * dsqrt ( 1.D0 - x * x ) end function WatsonMeanDirDensity","tags":"","loc":"proc/watsonmeandirdensity.html","title":"WatsonMeanDirDensity – Fortran Program"},{"text":"private recursive function DD_Estep(X, dict, Pmdims, nums, Mu, Kappa, Dtype) result(R) Uses: local typedefs quaternions proc~~dd_estep~~UsesGraph proc~dd_estep DD_Estep typedefs typedefs typedefs->proc~dd_estep local local local->proc~dd_estep quaternions quaternions quaternions->proc~dd_estep Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University / Yu-Hui Chen, U. Michigan\n @brief computes the E step of the EM process, verified against Matlab code on 01/02/15\n @param X list of input quaternions\n @param dict dictionary type\n @param Pmdims number of quaternion symmetry operators\n @param nums number of samples\n @param Mu current guess for mean quaternion\n @param Kappa input parameter\n @date 01/01/15 MDG 1.0 original\n @date 01/06/15 MDG 1.1 added optional argument full\n @date 01/09/15 MDG 1.2 removed optional argument full (incorporated in dicttype)\n @date 02/06/15 MDG 1.3 removed full handling after extensive checking\n @date 02/06/15 MDG 1.4 merged VMF and Watson Esteps into a single routine and renamed Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: X (4,nums) type(dicttype), intent(in) :: dict integer(kind=irg), intent(in) :: Pmdims integer(kind=irg), intent(in) :: nums real(kind=dbl), intent(in) :: Mu (4) real(kind=dbl), intent(in) :: Kappa character(len=3), intent(in) :: Dtype Return Value real(kind=dbl)\n  (nums,Pmdims) Calls proc~~dd_estep~~CallsGraph proc~dd_estep DD_Estep proc~dd_density DD_Density proc~dd_estep->proc~dd_density proc~logcp logCp proc~dd_estep->proc~logcp quat_mult quat_mult proc~dd_estep->quat_mult dexp dexp proc~dd_density->dexp besseli0 besseli0 proc~logcp->besseli0 besseli1 besseli1 proc~logcp->besseli1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~dd_estep~~CalledByGraph proc~dd_estep DD_Estep proc~di_emfordd DI_EMforDD proc~di_emfordd->proc~dd_estep Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code DD_Estep Source Code recursive function DD_Estep ( X , dict , Pmdims , nums , Mu , Kappa , Dtype ) result ( R ) !DEC$ ATTRIBUTES DLLEXPORT :: DD_Estep use local use typedefs use quaternions IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: X ( 4 , nums ) type ( dicttype ), INTENT ( IN ) :: dict integer ( kind = irg ), INTENT ( IN ) :: Pmdims integer ( kind = irg ), INTENT ( IN ) :: nums real ( kind = dbl ), INTENT ( IN ) :: Mu ( 4 ) real ( kind = dbl ), INTENT ( IN ) :: Kappa character ( 3 ), INTENT ( IN ) :: Dtype real ( kind = dbl ) :: R ( nums , Pmdims ) integer ( kind = irg ) :: j real ( kind = dbl ) :: Rdenom ( nums ), PmMu ( 4 ), C C = logCp ( kappa , Dtype ) do j = 1 , Pmdims PmMu = quat_mult ( Mu , dict % Pm ( 1 : 4 , j )) R ( 1 : nums , j ) = DD_Density ( X , nums , PmMu , Kappa , C , Dtype ) end do ! and determine the normalization factors Rdenom = 1.D0 / sum ( R , 2 ) do j = 1 , Pmdims R ( 1 : nums , j ) = R ( 1 : nums , j ) * Rdenom ( 1 : nums ) end do end function DD_Estep","tags":"","loc":"proc/dd_estep.html","title":"DD_Estep – Fortran Program"},{"text":"private recursive function DD_Mstep(X, dict, Pmdims, nums, R, Dtype) result(MuKa) Uses: local typedefs quaternions proc~~dd_mstep~~UsesGraph proc~dd_mstep DD_Mstep typedefs typedefs typedefs->proc~dd_mstep local local local->proc~dd_mstep quaternions quaternions quaternions->proc~dd_mstep Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University / Yu-Hui Chen, U. Michigan\n @brief computes the M step of the EM process\n @param X list of input quaternions\n @param dict dictionary type\n @param Pmdims number of quaternion symmetry operators\n @param nums number of samples\n @param R weight factors form the E step\n @param Dtype 'VMF' or 'WAT'\n @date 01/01/15 MDG 1.0 original\n @date 01/06/15 MDG 1.1 added optional full parameter\n @date 01/09/15 MDG 1.2 removed optional argument full (incorporated in dicttype)\n @date 01/09/15 MDG 1.3 introduced accurate numerical approximation for kappa determination\n @date 02/06/15 MDG 1.4 removed full handling after extensive checking\n @date 02/06/15 MDG 1.5 merged Msteps for VMF and WAT and renamed Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: X (4,nums) type(dicttype), intent(in) :: dict integer(kind=irg), intent(in) :: Pmdims integer(kind=irg), intent(in) :: nums real(kind=dbl), intent(in) :: R (nums,Pmdims) character(len=3), intent(in) :: Dtype Return Value real(kind=dbl)\n  (5) Calls proc~~dd_mstep~~CallsGraph proc~dd_mstep DD_Mstep quat_mult quat_mult proc~dd_mstep->quat_mult dsyev dsyev proc~dd_mstep->dsyev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~dd_mstep~~CalledByGraph proc~dd_mstep DD_Mstep proc~di_emfordd DI_EMforDD proc~di_emfordd->proc~dd_mstep Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code DD_Mstep Source Code recursive function DD_Mstep ( X , dict , Pmdims , nums , R , Dtype ) result ( MuKa ) !DEC$ ATTRIBUTES DLLEXPORT :: DD_Mstep use local use typedefs use quaternions IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: X ( 4 , nums ) type ( dicttype ), INTENT ( IN ) :: dict integer ( kind = irg ), INTENT ( IN ) :: Pmdims integer ( kind = irg ), INTENT ( IN ) :: nums real ( kind = dbl ), INTENT ( IN ) :: R ( nums , Pmdims ) character ( 3 ), INTENT ( IN ) :: Dtype real ( kind = dbl ) :: MuKa ( 5 ) real ( kind = dbl ) :: tmpGamma ( 4 ), nGamma , diff ( dict % Apnum ), qu ( 4 ), y , Tscatt ( 4 , 4 ), tmp ( 4 , 4 ) integer ( kind = irg ) :: minp , i , j ! variables needed for the dsyev Lapack eigenvalue routine CHARACTER :: JOBZ , UPLO INTEGER :: INFO , LDA , LWORK , NN DOUBLE PRECISION :: A ( 4 , 4 ), W ( 4 ), WORK ( 20 ) if ( Dtype . eq . 'VMF' ) then ! this is simplified from the Matlab routine and uses straight summations and ! quaternion multiplication instead of arrays tmpGamma = 0.D0 do j = 1 , Pmdims do i = 1 , nums qu = quat_mult ( X ( 1 : 4 , i ), conjg ( dict % Pm ( 1 : 4 , j ))) tmpGamma = tmpGamma + R ( i , j ) * qu end do end do nGamma = cabs ( tmpGamma ) MuKa ( 1 : 4 ) = tmpGamma / nGamma y = nGamma / dble ( nums ) end if if ( Dtype . eq . 'WAT' ) then ! here, we compute the modified scattering matrix Tscatt and compute its largest eigenvalue ! under the assumption that kappa will always be positive for the types of problems that we ! need to consider; we need to use the outer product, implemented using spread calls Tscatt = 0.D0 do j = 1 , Pmdims do i = 1 , nums qu = quat_mult ( X ( 1 : 4 , i ), conjg ( dict % Pm ( 1 : 4 , j ))) tmp = spread ( qu , dim = 2 , ncopies = 4 ) * spread ( qu , dim = 1 , ncopies = 4 ) Tscatt = Tscatt + R ( i , j ) * tmp end do end do Tscatt = Tscatt / dble ( nums ) JOBZ = 'V' UPLO = 'U' NN = 4 LDA = 4 LWORK = 20 A = Tscatt call DSYEV ( JOBZ , UPLO , NN , A , LDA , W , WORK , LWORK , INFO ) qu ( 1 : 4 ) = A ( 1 : 4 , 4 ) MuKa ( 1 : 4 ) = qu ( 1 : 4 ) y = dot_product ( qu , matmul ( Tscatt , qu )) end if ! find kappa corresponding to this value of gamma (equation 17 in appendix of paper) ! we split this into two regionds: 0<=y<0.94, for which we use the look-up table ! approach, and 0.94<=y<=1, for which we have derived an analytical approximation ! that is pretty accurate in the relevant region of kappa>30. if ( y . ge . 0.94D0 ) then if ( Dtype . eq . 'VMF' ) MuKa ( 5 ) = ( 1 5.D0 - 3.D0 * y + dsqrt ( 1 5.D0 + 9 0.D0 * y + 3 9.D0 * y * y )) / ( 1 6.D0 * ( 1.0D0 - y )) if ( Dtype . eq . 'WAT' ) MuKa ( 5 ) = ( 5.D0 * y - 1 1.D0 - dsqrt ( 3 9.D0 - 1 2.D0 * y + 9.D0 * y ** 2 )) / ( 8.D0 * ( y - 1.D0 )) else diff = dabs ( y - dict % yAp ) minp = minloc ( diff , 1 ) if ( minp . eq . 1 ) minp = 2 MuKa ( 5 ) = dict % xAp ( minp ) end if end function DD_Mstep","tags":"","loc":"proc/dd_mstep.html","title":"DD_Mstep – Fortran Program"},{"text":"public recursive function DD_Density(X, nums, mu, kappa, C, Dtype) result(y) Uses: local proc~~dd_density~~UsesGraph proc~dd_density DD_Density local local local->proc~dd_density Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University / Yu-Hui Chen, U. Michigan\n @brief computes the VMF or Watson density function\n @details \n original in Matlab by Yu-Hui Chen, U. Michigan\n converted to IDL by MDG, 12/18/14, simplified arguments\n converted to f90 by MDG, 12/31/14, further simplifications\n output validated against Matlab output on 12/31/14\n @param X input quaternion samples\n @param nums number of samples\n @param mu mean direction\n @param kappa concentration\n @param C logCp(kappa) or exp(logCp(kappa) (precomputed in calling routine)\n @param Dtype 'VMF' or 'WAT'\n @date 01/01/15 MDG 1.0 original\n @date 01/06/15 MDG 1.1 added C and full parameters\n @date 02/06/15 MDG 1.2 removed full handling\n @date 02/06/15 MDG 1.3 merged 'VMF' and 'WAT' routines and renamed Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: X (4,nums) integer(kind=irg), intent(in) :: nums real(kind=dbl), intent(in) :: mu (4) real(kind=dbl), intent(in) :: kappa real(kind=dbl), intent(in) :: C character(len=3), intent(in) :: Dtype Return Value real(kind=dbl)\n  (nums) Calls proc~~dd_density~~CallsGraph proc~dd_density DD_Density dexp dexp proc~dd_density->dexp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~dd_density~~CalledByGraph proc~dd_density DD_Density proc~dd_getqandl DD_getQandL proc~dd_getqandl->proc~dd_density proc~dd_estep DD_Estep proc~dd_estep->proc~dd_density proc~di_emfordd DI_EMforDD proc~di_emfordd->proc~dd_getqandl proc~di_emfordd->proc~dd_estep Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code DD_Density Source Code recursive function DD_Density ( X , nums , mu , kappa , C , Dtype ) result ( y ) !DEC$ ATTRIBUTES DLLEXPORT :: DD_Density use local IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: X ( 4 , nums ) integer ( kind = irg ), INTENT ( IN ) :: nums real ( kind = dbl ), INTENT ( IN ) :: mu ( 4 ) real ( kind = dbl ), INTENT ( IN ) :: kappa real ( kind = dbl ), INTENT ( IN ) :: C character ( 3 ), INTENT ( IN ) :: Dtype real ( kind = dbl ) :: y ( nums ) integer ( kind = irg ) :: j if ( Dtype . eq . 'VMF' ) then do j = 1 , nums y ( j ) = dexp ( C + kappa * dot_product ( mu , X ( 1 : 4 , j ))) end do end if if ( Dtype . eq . 'WAT' ) then do j = 1 , nums y ( j ) = dexp ( C + kappa * dot_product ( mu , X ( 1 : 4 , j )) ** 2 ) end do end if end function DD_Density","tags":"","loc":"proc/dd_density.html","title":"DD_Density – Fortran Program"},{"text":"private recursive function logCp(kappa, Dtype) result(lCp) Uses: local constants math proc~~logcp~~UsesGraph proc~logcp logCp math math math->proc~logcp local local local->proc~logcp module~constants constants local->module~constants module~constants->proc~logcp Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University / Yu-Hui Chen, U. Michigan\n @brief computes the logarithm of Cp for VMF and Watson distributions\n @details \n original in Matlab by Yu-Hui Chen, U. Michigan\n converted to IDL by MDG, 12/18/14, simplified arguments\n converted to f90 by MDG, 12/31/14, further simplifications\n output validated against Matlab output on 12/31/14\n @param kappa input parameter\n @param Dtype 'VMF' or 'WAT'\n @date 12/31/14 MDG 1.0 original\n @date 01/09/14 MDG 1.1 introduced more accurate numerical approximation for Cp\n @date 01/09/14 MDG 1.2 moved some of the constants in front of the logarithm\n @date 02/06/15 MDG 1.3 merged VMF and WAT routines Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: kappa character(len=3), intent(in) :: Dtype Return Value real(kind=dbl) Calls proc~~logcp~~CallsGraph proc~logcp logCp besseli0 besseli0 proc~logcp->besseli0 besseli1 besseli1 proc~logcp->besseli1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~logcp~~CalledByGraph proc~logcp logCp proc~dd_getqandl DD_getQandL proc~dd_getqandl->proc~logcp proc~dd_estep DD_Estep proc~dd_estep->proc~logcp proc~di_emfordd DI_EMforDD proc~di_emfordd->proc~dd_getqandl proc~di_emfordd->proc~dd_estep Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code logCp Source Code recursive function logCp ( kappa , Dtype ) result ( lCp ) !DEC$ ATTRIBUTES DLLEXPORT :: logCp use local use constants use math IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: kappa character ( 3 ), INTENT ( IN ) :: Dtype real ( kind = dbl ) :: lCp ! pre-computed constants real ( kind = dbl ), parameter :: C =- 3.675754132818690967D0 ! C = ln(1.D0/(2.D0*cPi)**2) real ( kind = dbl ), parameter :: C2 = 4.1746562059854348688D0 ! C2 = ln(512/sqrt(2)/pi&#94;(3/2)) real ( kind = dbl ), parameter :: C2W = 5.4243952068443172530D0 ! C2 = ln(128*sqrt(pi)) if ( Dtype . eq . 'VMF' ) then ! for arguments larger than kappa=30, we use a simple numerical approximation if ( kappa . gt . 3 0.D0 ) then lCp = kappa ** 4.5D0 / ( - 105 D0 + 8.D0 * kappa * ( - 1 5.D0 + 1 6.D0 * kappa * ( - 3.D0 + 8.D0 * kappa ))) lCp = C2 - kappa + dlog ( lCp ) else lCp = C + dlog ( kappa / BesselI1 ( kappa ) ) end if end if if ( Dtype . eq . 'WAT' ) then ! for arguments larger than kappa=20, we use a simple numerical approximation if ( kappa . gt . 2 0.D0 ) then lCp = kappa ** 4.5D0 / ( 52 5.D0 + 4.D0 * kappa * ( 4 5.D0 + 8.D0 * kappa * ( 3.D0 + 4.D0 * kappa ))) lCp = C2W - kappa + dlog ( lCp ) else lCp = - kappa * 0.5D0 - dlog ( BesselI0 ( kappa * 0.5D0 ) - BesselI1 ( kappa * 0.5D0 ) ) end if end if end function logCp","tags":"","loc":"proc/logcp.html","title":"logCp – Fortran Program"},{"text":"public recursive subroutine DI_Init(dict, Dtype) Uses: local typedefs error math proc~~di_init~~UsesGraph proc~di_init DI_Init typedefs typedefs typedefs->proc~di_init math math math->proc~di_init local local local->proc~di_init error error error->proc~di_init Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University / Yu-Hui Chen, U. Michigan\n @brief initialize the dictionary indexing parameters (symmetry operators and precomputed Ap lookup table)\n @details For all details, see following paper:\n @param dict dictionary parameter (must be declared in calling routine)\n @param Dtype  'VMF' or 'WAT' for von Mises-Fisher and Watson distributions, respectively.\n @date 12/31/14 MDG 1.0 original\n @date 01/06/15 MDG 1.1 added optional argument full\n @date 02/06/15 MDG 1.2 removed full again after extensive testing; no need to use 2M operators Arguments Type Intent Optional Attributes Name type(dicttype), intent(inout) :: dict character(len=3), intent(in) :: Dtype Calls proc~~di_init~~CallsGraph proc~di_init DI_Init fatalerror fatalerror proc~di_init->fatalerror besselin besselin proc~di_init->besselin besseli1 besseli1 proc~di_init->besseli1 sym_qsymop sym_qsymop proc~di_init->sym_qsymop besseli0 besseli0 proc~di_init->besseli0 pgrot pgrot proc~di_init->pgrot Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~di_init~~CalledByGraph proc~di_init DI_Init proc~forwardprojection ForwardProjection proc~forwardprojection->proc~di_init proc~backprojection BackProjection proc~backprojection->proc~di_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code DI_Init Source Code recursive subroutine DI_Init ( dict , Dtype ) !DEC$ ATTRIBUTES DLLEXPORT :: DI_Init use local use typedefs use error use math IMPLICIT NONE type ( dicttype ), INTENT ( INOUT ) :: dict character ( 3 ), INTENT ( IN ) :: Dtype integer ( kind = irg ) :: i real ( kind = dbl ) :: y1 , y2 ! here we need to analyze the rotational symmetry group, and copy the appropriate ! quaternion symmetry operators into the dict%Pm array ! first get the number of the rotational point group that corresponds to the crystal point group dict % prot = PGrot ( dict % pgnum ) ! possible values for dict%prot are: (/1,3,6,9,12,16,18,21,24,28,30/) ! corresponding to the point groups 1, 2, 222, 4, 422, 3, 32, 6, 622, 23, and 432, respectively !------------ ! IMPORTANT NOTE: the original von Mises-Fischer (VMF) approach requires that q and -q are considered to ! be separate quaternions, so the original Matlab code included the negatives of all quaternion symmetry operators ! as well, leading to a cardinality of twice the rotational point group order.  It appears that we do not have to ! do so if we replace the exponential in the VMF by a hyperbolic cosine function, which would account directly ! for the q, -q duplicity... Alternatively, one can use the axial Watson distribution. !------------ ! identity operator is part of all point groups dict % Pm = 0.D0 ! initialize all entries to zero dict % Pm ( 1 : 4 , 1 ) = SYM_Qsymop ( 1 : 4 , 1 ) ! select statement for each individual rotational point group (see typedefs.f90 for SYM_Qsymop definitions) select case ( dict % prot ) case ( 1 ) ! 1 (no additional symmetry elements) dict % Nqsym = 1 dict % Pm ( 1 : 4 , 2 ) = - dict % Pm ( 1 : 4 , 1 ) case ( 3 ) ! 2  (we'll assume that the two-fold axis lies along the e_y-axis) dict % Nqsym = 2 dict % Pm ( 1 : 4 , 2 ) = SYM_Qsymop ( 1 : 4 , 3 ) case ( 6 ) ! 222 dict % Nqsym = 4 do i = 2 , 4 dict % Pm ( 1 : 4 , i ) = SYM_Qsymop ( 1 : 4 , i ) end do case ( 9 ) ! 4 dict % Nqsym = 4 dict % Pm ( 1 : 4 , 2 ) = SYM_Qsymop ( 1 : 4 , 4 ) dict % Pm ( 1 : 4 , 3 ) = SYM_Qsymop ( 1 : 4 , 7 ) dict % Pm ( 1 : 4 , 4 ) = SYM_Qsymop ( 1 : 4 , 10 ) case ( 12 ) ! 422 dict % Nqsym = 8 dict % Pm ( 1 : 4 , 2 ) = SYM_Qsymop ( 1 : 4 , 4 ) dict % Pm ( 1 : 4 , 3 ) = SYM_Qsymop ( 1 : 4 , 7 ) dict % Pm ( 1 : 4 , 4 ) = SYM_Qsymop ( 1 : 4 , 10 ) dict % Pm ( 1 : 4 , 5 ) = SYM_Qsymop ( 1 : 4 , 2 ) dict % Pm ( 1 : 4 , 6 ) = SYM_Qsymop ( 1 : 4 , 3 ) dict % Pm ( 1 : 4 , 7 ) = SYM_Qsymop ( 1 : 4 , 11 ) dict % Pm ( 1 : 4 , 8 ) = SYM_Qsymop ( 1 : 4 , 12 ) case ( 16 ) ! 3 dict % Nqsym = 2 call FatalError ( 'InitDictionaryIndexing' , 'this symmetry has not yet been implemented (pg 3)' ) case ( 18 ) ! 32 (needs special handling) dict % Nqsym = 2 call FatalError ( 'InitDictionaryIndexing' , 'this symmetry has not yet been implemented (pg 32)' ) case ( 21 ) ! 6 dict % Nqsym = 6 do i = 25 , 29 dict % Pm ( 1 : 4 , i - 23 ) = SYM_Qsymop ( 1 : 4 , i ) end do case ( 24 ) ! 622 dict % Nqsym = 12 do i = 25 , 35 dict % Pm ( 1 : 4 , i - 23 ) = SYM_Qsymop ( 1 : 4 , i ) end do case ( 28 ) ! 23 dict % Nqsym = 12 do i = 2 , 4 dict % Pm ( 1 : 4 , i ) = SYM_Qsymop ( 1 : 4 , i ) end do do i = 17 , 24 dict % Pm ( 1 : 4 , 4 + ( i - 16 )) = SYM_Qsymop ( 1 : 4 , i ) end do case ( 30 ) ! 432 dict % Nqsym = 24 do i = 2 , 24 dict % Pm ( 1 : 4 , i ) = SYM_Qsymop ( 1 : 4 , i ) end do case default ! this should never happen ... call FatalError ( 'InitDictionaryIndexing' , 'unknown rotational point group number' ) end select ! von Mises-Fisher mode: ! the next part of the initial Matlab code computes a lookup table for the parameter Ap(u) (Appendix in paper) ! this lookup table is only used when the ratio of the BesselI functions is between 0 and 0.95; for the ! region between 0.95 and 1, we use an analytical approximation (see VMF_Mstep routine). ! ! Watson mode: ! we've used a similar approach to create a lookup table for values of kappa that are smaller than 35, in ! which case we use the standard ratio of Kummer functions:  Kummer[3/2,3,k]/Kummer[1/2,2,k]/k.  For ! larger kappa values, we have an expansion using the large argument behavior of the modified Bessel functions. ! dict % Apnum = 35000 allocate ( dict % xAp ( dict % Apnum ), dict % yAp ( dict % Apnum )) ! define the xAp array dict % xAp = ( / ( 0.001D0 + dble ( i - 1 ) * 0.001D0 , i = 1 , dict % Apnum ) / ) if ( Dtype . eq . 'VMF' ) then ! von Mises-Fisher distribution do i = 1 , dict % Apnum dict % yAp ( i ) = BesselIn ( dict % xAp ( i ), 2 ) / BesselI1 ( dict % xAp ( i )) end do end if if ( Dtype . eq . 'WAT' ) then ! Watson distribution do i = 1 , dict % Apnum y1 = BesselI1 ( dict % xAp ( i ) * 0.5D0 ) y2 = BesselI0 ( dict % xAp ( i ) * 0.5D0 ) dict % yAp ( i ) = y1 / ( y2 - y1 ) / dict % xAp ( i ) end do end if end subroutine DI_Init","tags":"","loc":"proc/di_init.html","title":"DI_Init – Fortran Program"},{"text":"public recursive subroutine DI_EMforDD(X, dict, nums, seed, muhat, kappahat, Dtype) Uses: local constants typedefs math quaternions rotations so3 proc~~di_emfordd~~UsesGraph proc~di_emfordd DI_EMforDD local local local->proc~di_emfordd module~so3 so3 local->module~so3 module~constants constants local->module~constants quaternions quaternions quaternions->proc~di_emfordd rotations rotations rotations->proc~di_emfordd math math math->proc~di_emfordd typedefs typedefs typedefs->proc~di_emfordd module~so3->proc~di_emfordd module~constants->proc~di_emfordd Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Yu-Hui Chen, U. Michigan / Marc De Graef, Carnegie Mellon University\n @brief Expectation maximization approach to maximum likelihood problem for mu and kappa\n @details For all details, see following paper:\n @param X list of input quaternions\n @param dict dictionary parameter (must be declared in calling routine)\n @param nums number of input quaternions\n @param seed for normal random number generator \n @param muhat output mean orientation\n @param kappahat output concentration parameter\n @param Dtype 'VMF' or 'WAT'\n @date 01/01/15 MDG 1.0 original, based on Chen's Matlab version + simplifications\n @date 01/06/15 MDG 1.1 added optional argument full\n @date 02/06/15 MDG 1.2 removed full again, added Dtype and streamlined code; removed duplications Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: X (4,nums) type(dicttype), intent(inout) :: dict integer(kind=irg), intent(in) :: nums integer(kind=irg), intent(inout) :: seed real(kind=dbl), intent(out) :: muhat (4) real(kind=dbl), intent(out) :: kappahat character(len=3), intent(in) :: Dtype Calls proc~~di_emfordd~~CallsGraph proc~di_emfordd DI_EMforDD fztarray fztarray proc~di_emfordd->fztarray isinsidefz isinsidefz proc~di_emfordd->isinsidefz quat_mult quat_mult proc~di_emfordd->quat_mult qu2ro qu2ro proc~di_emfordd->qu2ro proc~dd_mstep DD_Mstep proc~di_emfordd->proc~dd_mstep fzoarray fzoarray proc~di_emfordd->fzoarray proc~dd_getqandl DD_getQandL proc~di_emfordd->proc~dd_getqandl r8vec_normal_01 r8vec_normal_01 proc~di_emfordd->r8vec_normal_01 proc~dd_estep DD_Estep proc~di_emfordd->proc~dd_estep proc~dd_mstep->quat_mult dsyev dsyev proc~dd_mstep->dsyev proc~dd_getqandl->quat_mult proc~dd_density DD_Density proc~dd_getqandl->proc~dd_density proc~logcp logCp proc~dd_getqandl->proc~logcp dexp dexp proc~dd_getqandl->dexp proc~dd_estep->quat_mult proc~dd_estep->proc~dd_density proc~dd_estep->proc~logcp proc~dd_density->dexp besseli0 besseli0 proc~logcp->besseli0 besseli1 besseli1 proc~logcp->besseli1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code DI_EMforDD Source Code recursive subroutine DI_EMforDD ( X , dict , nums , seed , muhat , kappahat , Dtype ) !DEC$ ATTRIBUTES DLLEXPORT :: DI_EMforDD use local use constants use typedefs use math , only : r8vec_normal_01 , r4_uniform_01 ! array of normal random numbers use quaternions use rotations , only : qu2ro ! we only need to move to Rodrigues-Frank space use so3 , only : IsinsideFZ ! we only need to do a test ... IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: X ( 4 , nums ) type ( dicttype ), INTENT ( INOUT ) :: dict integer ( kind = irg ), INTENT ( IN ) :: nums integer ( kind = irg ), INTENT ( INOUT ) :: seed real ( kind = dbl ), INTENT ( OUT ) :: muhat ( 4 ) real ( kind = dbl ), INTENT ( OUT ) :: kappahat character ( 3 ), INTENT ( IN ) :: Dtype integer ( kind = irg ) :: i , j , N , Pmdims , init , dd integer ( kind = irg ) :: FZtype , FZorder real ( kind = dbl ), allocatable :: Mu_All (:,:), Kappa_All (:), R_All (:,:,:), L_All (:), & R (:,:), Q (:), L (:) real ( kind = dbl ) :: Mu ( 4 ), PmMu ( 4 ), MuKa ( 5 ), Qi , Li , rod ( 4 ), qu ( 4 ), Kappa ! In this routine, we perform the EM algorithm to obtain an estimate for the ! mean direction and concentration parameter of the modified von Mises-Fisher (mVMF) ! distribution that models the statistics of the orientation point cloud. ! array sizes (we use shorthand notations) N = nums Pmdims = dict % Nqsym ! initialize some auxiliary arrays allocate ( Mu_All ( dict % Num_of_init , 4 ), Kappa_All ( dict % Num_of_init ), & R_All ( N , Pmdims , dict % Num_of_init ), L_All ( dict % num_of_init )) Mu_All = 0.D0 Kappa_All = 0.D0 R_All = 0.D0 L_All = 0.D0 ! main loop (EM typically uses a few starting parameter sets to make sure we don't get stuck in a local maximum) do init = 1 , dict % Num_of_init ! create a vector to hold the results allocate ( R ( N , Pmdims )) R = 0.D0 ! generate a normal random vector and normalize it as a starting guess for Mu (i.e., a unit quaternion) call R8VEC_normal_01 ( 4 , seed , Mu ) Mu = Mu / cabs ( Mu ) ! the EMsoft package only considers quaternions with positive first component, ! so we may need to change all the signs if ( Mu ( 1 ). lt . 0.D0 ) Mu = - Mu ! starting value for Kappa Kappa = 3 0.D0 ! define the number of iterations and the Q and L function arrays allocate ( Q ( dict % Num_of_iterations ), L ( dict % Num_of_iterations )) Q = 0.D0 L = 0.D0 ! and here we go with the EM iteration... ! we use quaternion multiplication throughout instead of the matrix version in the Matlab version ! quaternion multiplication has been verified against the 4x4 matrix multiplication of the Matlab code on 01/02/15 iloop : do i = 1 , dict % Num_of_iterations ! E-step R = DD_Estep ( X , dict , Pmdims , N , Mu , Kappa , Dtype ) ! M-step MuKa = DD_Mstep ( X , dict , Pmdims , N , R , Dtype ) ! calculate the Q and Likelihood function values call DD_getQandL ( X , dict , Pmdims , nums , MuKa , R , Qi , Li , Dtype ) L ( i ) = Li Q ( i ) = Qi ! update the containers Mu_All ( init , 1 : 4 ) = MuKa ( 1 : 4 ) Kappa_All ( init ) = MuKa ( 5 ) R_All ( 1 : N , 1 : Pmdims , init ) = R ( 1 : N , 1 : Pmdims ) L_All ( init ) = L ( i ) Mu = MuKa ( 1 : 4 ) Kappa = MuKa ( 5 ) ! and terminate if necessary if ( i . ge . 2 ) then if ( abs ( Q ( i ) - Q ( i - 1 )). lt . 0.01 ) then EXIT iloop end if end if end do iloop deallocate ( R , Q , L ) end do dd = maxloc ( L_All , 1 ) Mu = Mu_all ( dd , 1 : 4 ) kappahat = Kappa_All ( dd ) ! the EMsoft package only considers quaternions with positive first component, ! so we may need to change all the signs if ( Mu ( 1 ). lt . 0.D0 ) Mu = - Mu ! the final step is to make sure that the resulting Mu lies in the same ! fundamental zone that the dictionary elements are located in; since we start ! the EM iterations from a random quaternion, there is no guarantee that the ! result lies in the same fundamental zone. Therefore, we cycle through all the ! equivalent quaternions, and stop as soon as we find one in the Rodrigues ! fundamental zone, which requires routines from the rotations and so3 modules. FZtype = FZtarray ( dict % pgnum ) FZorder = FZoarray ( dict % pgnum ) FZloop : do i = 1 , Pmdims qu = quat_mult ( Mu , dict % Pm ( 1 : 4 , i )) if ( qu ( 1 ). lt . 0.D0 ) qu = - qu rod = qu2ro ( qu ) if ( IsinsideFZ ( rod , FZtype , FZorder )) EXIT FZloop end do FZloop muhat = qu deallocate ( Mu_All , Kappa_All , R_All , L_All ) end subroutine DI_EMforDD","tags":"","loc":"proc/di_emfordd.html","title":"DI_EMforDD – Fortran Program"},{"text":"private recursive subroutine DD_getQandL(X, dict, Pmdims, nums, MuKa, R, Q, L, Dtype) Uses: local typedefs quaternions proc~~dd_getqandl~~UsesGraph proc~dd_getqandl DD_getQandL typedefs typedefs typedefs->proc~dd_getqandl local local local->proc~dd_getqandl quaternions quaternions quaternions->proc~dd_getqandl Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Yu-Hui Chen, U. Michigan / Marc De Graef, Carnegie Mellon University\n @brief Computes the Q array and the log-likelihood array\n @details For all details, see following paper:\n @param X list of input quaternions\n @param dict dictionary parameter (must be declared in calling routine)\n @param Pmdims number of quaternion symmetry operators to consider\n @param number of input quaternions\n @param MuKa  vector with Mu and Kappa\n @param R output from the E step\n @param Q output Q \n @param L output L \n @param Dtype 'VMF' or 'WAT'\n @date 01/01/15 MDG 1.0 original, based on Chen's Matlab version + simplifications\n @date 01.06/15 MDG 1.1 added optional full parameter\n @date 01/09/15 MDG 1.2 removed optional argument full (incorporated in dicttype)\n @date 02/06/15 MDG 1.3 removed full handling after extensive checking\n @date 02/06/15 MDG 1.4 merged VMF and WAT routines and renamed\n @date 12/05/16 MDG 1.5 intercepted case when Phi becomes zero for a VERY sharp texture... Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: X (4,nums) type(dicttype), intent(inout) :: dict integer(kind=irg), intent(in) :: Pmdims integer(kind=irg), intent(in) :: nums real(kind=dbl), intent(in) :: MuKa (5) real(kind=dbl), intent(in) :: R (nums,Pmdims) real(kind=dbl), intent(inout) :: Q real(kind=dbl), intent(inout) :: L character(len=3), intent(in) :: Dtype Calls proc~~dd_getqandl~~CallsGraph proc~dd_getqandl DD_getQandL quat_mult quat_mult proc~dd_getqandl->quat_mult proc~dd_density DD_Density proc~dd_getqandl->proc~dd_density proc~logcp logCp proc~dd_getqandl->proc~logcp dexp dexp proc~dd_getqandl->dexp proc~dd_density->dexp besseli0 besseli0 proc~logcp->besseli0 besseli1 besseli1 proc~logcp->besseli1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~dd_getqandl~~CalledByGraph proc~dd_getqandl DD_getQandL proc~di_emfordd DI_EMforDD proc~di_emfordd->proc~dd_getqandl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code DD_getQandL Source Code recursive subroutine DD_getQandL ( X , dict , Pmdims , nums , MuKa , R , Q , L , Dtype ) !DEC$ ATTRIBUTES DLLEXPORT :: DD_getQandL use local use typedefs use quaternions IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: X ( 4 , nums ) type ( dicttype ), INTENT ( INOUT ) :: dict integer ( kind = irg ), INTENT ( IN ) :: Pmdims integer ( kind = irg ), INTENT ( IN ) :: nums real ( kind = dbl ), INTENT ( IN ) :: MuKa ( 5 ) real ( kind = dbl ), INTENT ( IN ) :: R ( nums , Pmdims ) real ( kind = dbl ), INTENT ( INOUT ) :: Q real ( kind = dbl ), INTENT ( INOUT ) :: L character ( 3 ), INTENT ( IN ) :: Dtype real ( kind = dbl ) :: Phi ( nums , Pmdims ), PmMu ( 4 ), qu ( 4 ), C , oldQ , oldL integer ( kind = irg ) :: j real ( kind = dbl ), parameter :: eps = 0.00001D0 oldQ = Q oldL = L C = logCp ( MuKa ( 5 ), Dtype ) if ( Dtype . eq . 'VMF' ) C = dexp ( C ) ! compute the auxiliary Phi array Phi = 0.D0 qu = MuKa ( 1 : 4 ) do j = 1 , Pmdims PmMu = quat_mult ( dict % Pm ( 1 : 4 , j ), qu ) Phi ( 1 : nums , j ) = DD_Density ( X , nums , PmMu , MuKa ( 5 ), C , Dtype ) end do Phi = Phi / dble ( dict % Nqsym ) if ( minval ( Phi ). gt . 0.D0 ) then ! and convert the array into the Q and L parameters. L = sum ( dlog ( sum ( Phi , 2 ))) Q = sum ( R * dlog ( Phi )) else L = oldL Q = oldQ end if ! else, we reuse the old values end subroutine DD_getQandL","tags":"","loc":"proc/dd_getqandl.html","title":"DD_getQandL – Fortran Program"},{"text":"public recursive subroutine DI_Similarity_Classifier(array, k, npx, npy, returnarr) Uses: local proc~~di_similarity_classifier~~UsesGraph proc~di_similarity_classifier DI_Similarity_Classifier local local local->proc~di_similarity_classifier Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University / Yu-Hui Chen, U. Michigan\n @brief classify the point as grain interior or anomalous point\n @details takes the kNN neighbor information as input and returns the \n @param array input array\n @param k number of top matches for each pixel\n @param npx number of pixels in the x direction\n @param npy number of pixels in the y direction\n @date 01/05/15 SS 1.0 original\n @date 01/06/15 MDG 1.1 simplified summation loop and renamed routine Arguments Type Intent Optional Attributes Name integer(kind=sgl), intent(in) :: array (npx,npy,k) integer(kind=irg), intent(in) :: k integer(kind=irg), intent(in) :: npx integer(kind=irg), intent(in) :: npy real(kind=sgl), intent(out) :: returnarr (npx,npy) Calls proc~~di_similarity_classifier~~CallsGraph proc~di_similarity_classifier DI_Similarity_Classifier float float proc~di_similarity_classifier->float proc~cardintersection CardIntersection proc~di_similarity_classifier->proc~cardintersection Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code DI_Similarity_Classifier Source Code recursive subroutine DI_Similarity_Classifier ( array , k , npx , npy , returnarr ) !DEC$ ATTRIBUTES DLLEXPORT :: DI_Similarity_Classifier use local IMPLICIT NONE integer ( kind = sgl ), INTENT ( IN ) :: array ( npx , npy , k ) integer ( kind = irg ), INTENT ( IN ) :: k integer ( kind = irg ), INTENT ( IN ) :: npx integer ( kind = irg ), INTENT ( IN ) :: npy real ( kind = sgl ), INTENT ( OUT ) :: returnarr ( npx , npy ) integer ( kind = irg ) :: ii , jj , ki , kj , similarity_measure_sum , res real ( kind = sgl ) :: similarity_measure similarity_measure_sum = 0 similarity_measure = 0.0 returnarr = 0.0 do ii = 2 , npx - 1 do jj = 2 , npy - 1 do ki = - 1 , 1 do kj = - 1 , 1 if (( abs ( ki ) + abs ( kj )). ne . 0 ) then call CardIntersection ( array ( ii + ki , jj + kj , 1 : k ), array ( ii , jj , 1 : k ), k , res ) similarity_measure_sum = similarity_measure_sum + res similarity_measure = float ( similarity_measure_sum ) / float ( 8 * k ) returnarr ( ii , jj ) = similarity_measure similarity_measure = 0.0 similarity_measure_sum = 0 end if end do end do end do end do end subroutine DI_Similarity_Classifier","tags":"","loc":"proc/di_similarity_classifier.html","title":"DI_Similarity_Classifier – Fortran Program"},{"text":"private recursive subroutine CardIntersection(set1, set2, k, res) Uses: local proc~~cardintersection~~UsesGraph proc~cardintersection CardIntersection local local local->proc~cardintersection Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University / Yu-Hui Chen, U. Michigan\n @brief calculate the cardinality of the intersection of two sets\n @param set1\n @param set2\n @param k number of elements in each set\n @date 01/05/15 SS 1.0 original\n @date MDG 1.1 changed types to integer Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: set1 (k) integer(kind=irg), intent(in) :: set2 (k) integer(kind=irg), intent(in) :: k integer(kind=irg), intent(out) :: res Called By proc~~cardintersection~~CalledByGraph proc~cardintersection CardIntersection proc~di_similarity_classifier DI_Similarity_Classifier proc~di_similarity_classifier->proc~cardintersection Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code CardIntersection Source Code recursive subroutine CardIntersection ( set1 , set2 , k , res ) !DEC$ ATTRIBUTES DLLEXPORT :: CardIntersection use local IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: set1 ( k ) integer ( kind = irg ), INTENT ( IN ) :: set2 ( k ) integer ( kind = irg ), INTENT ( IN ) :: k integer ( kind = irg ), INTENT ( OUT ) :: res integer ( kind = irg ) :: ii , jj jj = 1 res = 0 do ii = 1 , k do jj = 1 , k if ( set1 ( ii ) . eq . set2 ( jj )) then res = res + 1 EXIT end if end do end do end subroutine CardIntersection","tags":"","loc":"proc/cardintersection.html","title":"CardIntersection – Fortran Program"},{"text":"public recursive subroutine ReduceDisorientationtoMFZ(ro, cell, FZtype, FZorder, roMFZ) Uses: local rotations quaternions so3 typedefs symmetry proc~~reducedisorientationtomfz~~UsesGraph proc~reducedisorientationtomfz ReduceDisorientationtoMFZ local local local->proc~reducedisorientationtomfz module~so3 so3 local->module~so3 symmetry symmetry symmetry->proc~reducedisorientationtomfz quaternions quaternions quaternions->proc~reducedisorientationtomfz rotations rotations rotations->proc~reducedisorientationtomfz typedefs typedefs typedefs->proc~reducedisorientationtomfz module~so3->proc~reducedisorientationtomfz Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief Reduce a disorientation (Rodrigues) to the Mackenzie Fundamental Zone\n @details This requires the symmetry operations of the Rodrigues FZ, which \n includes mirrors and inversion symmetry, i.e., the regular (full) point group\n symmetry of the shape of the RFZ.  We already have those implemented in the \n regular symmetry module, and we assume that those symmetry matrices have been\n initialized and are present in the cell structure.  Then we just call the regular\n CalcStar routine to generate the equivalents and pick the one that is inside\n the MFZ.\n @param ro Rodrigues vector\n @param cell cell pointer\n @param FZtype Fundamental Zone type\n @param FZorder Fundamental Zone order\n @param euFZ Euler triplet in fundamental zone (in radians)\n @date 07/29/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: ro (4) type(unitcell), intent(in), pointer :: cell integer(kind=irg), intent(in) :: FZtype integer(kind=irg), intent(in) :: FZorder real(kind=dbl), intent(out) :: roMFZ (4) Calls proc~~reducedisorientationtomfz~~CallsGraph proc~reducedisorientationtomfz ReduceDisorientationtoMFZ calcstar calcstar proc~reducedisorientationtomfz->calcstar proc~isinsidemfz IsinsideMFZ proc~reducedisorientationtomfz->proc~isinsidemfz proc~insidecubicmfz insideCubicMFZ proc~isinsidemfz->proc~insidecubicmfz proc~insidecyclicfz insideCyclicFZ proc~isinsidemfz->proc~insidecyclicfz proc~insidedihedralmfz insideDihedralMFZ proc~isinsidemfz->proc~insidedihedralmfz proc~insidecubicfz insideCubicFZ proc~insidecubicmfz->proc~insidecubicfz proc~insidedihedralfz insideDihedralFZ proc~insidedihedralmfz->proc~insidedihedralfz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code ReduceDisorientationtoMFZ Source Code recursive subroutine ReduceDisorientationtoMFZ ( ro , cell , FZtype , FZorder , roMFZ ) !DEC$ ATTRIBUTES DLLEXPORT :: ReduceDisorientationtoMFZ use local use rotations use quaternions use so3 use typedefs use symmetry IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: ro ( 4 ) type ( unitcell ), pointer , INTENT ( IN ) :: cell integer ( kind = irg ), INTENT ( IN ) :: FZtype integer ( kind = irg ), INTENT ( IN ) :: FZorder real ( kind = dbl ), INTENT ( OUT ) :: roMFZ ( 4 ) real ( kind = dbl ) :: r ( 3 ), rod ( 4 ), mag integer ( kind = irg ) :: i , j , n real ( kind = dbl ) :: stmp ( 48 , 3 ) logical :: inMFZ roMFZ = 0.D0 r ( 1 : 3 ) = ro ( 1 : 3 ) * ro ( 4 ) stmp = 0.0 call CalcStar ( cell , r , n , stmp , 'd' ) MFZloop : do j = 1 , n mag = dsqrt ( sum ( stmp ( j , 1 : 3 ) ** 2 )) rod ( 4 ) = mag rod ( 1 : 3 ) = stmp ( j , 1 : 3 ) / mag inMFZ = IsinsideMFZ ( rod , FZtype , FZorder ) if ( inMFZ ) EXIT MFZloop ! we really should never get to the following line ... if ( j . eq . n ) then write ( * , * ) 'problem ... ' , j , inMFZ write ( * , * ) r , n write ( * , * ) mag , rod write ( * , * ) transpose ( stmp ) stop end if end do MFZloop roMFZ = rod end subroutine ReduceDisorientationtoMFZ","tags":"","loc":"proc/reducedisorientationtomfz.html","title":"ReduceDisorientationtoMFZ – Fortran Program"},{"text":"public recursive subroutine ReduceOrientationtoCubicEFZ(eu, dict, euFZ) Uses: local rotations quaternions constants so3 proc~~reduceorientationtocubicefz~~UsesGraph proc~reduceorientationtocubicefz ReduceOrientationtoCubicEFZ module~constants constants module~constants->proc~reduceorientationtocubicefz quaternions quaternions quaternions->proc~reduceorientationtocubicefz local local local->proc~reduceorientationtocubicefz local->module~constants module~so3 so3 local->module~so3 module~so3->proc~reduceorientationtocubicefz rotations rotations rotations->proc~reduceorientationtocubicefz Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief Reduce an orientation (Euler angles) to the cubic FZ in Euler space\n @param eu Euler triplet (in radians)\n @param dict dict structure\n @param euFZ Euler triplet in Euler fundamental zone (in radians)\n @date 07/29/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: eu (3) type(dicttype), intent(in) :: dict real(kind=dbl), intent(out) :: euFZ (3) Calls proc~~reduceorientationtocubicefz~~CallsGraph proc~reduceorientationtocubicefz ReduceOrientationtoCubicEFZ qu2eu qu2eu proc~reduceorientationtocubicefz->qu2eu eu2qu eu2qu proc~reduceorientationtocubicefz->eu2qu quat_mult quat_mult proc~reduceorientationtocubicefz->quat_mult Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code ReduceOrientationtoCubicEFZ Source Code recursive subroutine ReduceOrientationtoCubicEFZ ( eu , dict , euFZ ) !DEC$ ATTRIBUTES DLLEXPORT :: ReduceOrientationtoCubicEFZ use local use rotations use quaternions use constants use so3 IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: eu ( 3 ) type ( dicttype ), INTENT ( IN ) :: dict real ( kind = dbl ), INTENT ( OUT ) :: euFZ ( 3 ) real ( kind = dbl ) :: Mu ( 4 ), qu ( 4 ), rod ( 4 ), c , s , z integer ( kind = irg ) :: i , j , Pmdims euFZ = 0.D0 Pmdims = dict % Nqsym Mu = eu2qu ( eu ) if ( Mu ( 1 ). lt . 0.D0 ) Mu = - Mu FZloop : do j = 1 , Pmdims qu = quat_mult ( dict % Pm ( 1 : 4 , j ), Mu ) if ( qu ( 1 ). lt . 0.D0 ) qu = - qu euFZ = qu2eu ( qu ) ! apply the cubic Euler FZ boundary conditions c = cos ( euFZ ( 3 )) s = sin ( euFZ ( 3 )) z = acos ( minval ( ( / c / sqrt ( 1 + c * c ), s / sqrt ( 1 + s * s ) / ) )) if (( euFZ ( 2 ). gt . z ). and .( euFZ ( 2 ). lt . cPi / 2 D0 ). and .( euFZ ( 3 ). lt . cPi / 2.D0 )) EXIT FZloop ! we really should never get to the following line ... if ( j . eq . Pmdims ) write ( * , * ) 'problem ... ' , i end do FZloop end subroutine ReduceOrientationtoCubicEFZ","tags":"","loc":"proc/reduceorientationtocubicefz.html","title":"ReduceOrientationtoCubicEFZ – Fortran Program"},{"text":"public recursive subroutine ReduceOrientationtoRFZ(eu, dict, FZtype, FZorder, euFZ, MFZ) Uses: local rotations quaternions so3 constants proc~~reduceorientationtorfz~~UsesGraph proc~reduceorientationtorfz ReduceOrientationtoRFZ module~constants constants module~constants->proc~reduceorientationtorfz quaternions quaternions quaternions->proc~reduceorientationtorfz local local local->proc~reduceorientationtorfz local->module~constants module~so3 so3 local->module~so3 module~so3->proc~reduceorientationtorfz rotations rotations rotations->proc~reduceorientationtorfz Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief Reduce an orientation (Euler angles) to the Rodrigues Fundamental Zone\n @param eu Euler triplet (in radians)\n @param dict dict structure\n @param FZtype Fundamental Zone type\n @param FZorder Fundamental Zone order\n @param euFZ Euler triplet in fundamental zone (in radians)\n @param MFZ (optonal) apply MacKenzie cell\n @date 07/29/16 MDG 1.0 original\n @date 03/27/17 MDG 1.1 added checking of MacKenzie cell Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: eu (3) type(dicttype), intent(in) :: dict integer(kind=irg), intent(in) :: FZtype integer(kind=irg), intent(in) :: FZorder real(kind=dbl), intent(out) :: euFZ (3) logical, intent(in), optional :: MFZ Calls proc~~reduceorientationtorfz~~CallsGraph proc~reduceorientationtorfz ReduceOrientationtoRFZ proc~isinsidefz IsinsideFZ proc~reduceorientationtorfz->proc~isinsidefz eu2qu eu2qu proc~reduceorientationtorfz->eu2qu qu2ro qu2ro proc~reduceorientationtorfz->qu2ro quat_mult quat_mult proc~reduceorientationtorfz->quat_mult ro2eu ro2eu proc~reduceorientationtorfz->ro2eu proc~isinsidemfz IsinsideMFZ proc~reduceorientationtorfz->proc~isinsidemfz proc~insidecubicfz insideCubicFZ proc~isinsidefz->proc~insidecubicfz proc~insidecubehexfz insideCubeHexFZ proc~isinsidefz->proc~insidecubehexfz proc~insidecyclicfz insideCyclicFZ proc~isinsidefz->proc~insidecyclicfz proc~insidedihedralfz insideDihedralFZ proc~isinsidefz->proc~insidedihedralfz proc~isinsidemfz->proc~insidecyclicfz proc~insidecubicmfz insideCubicMFZ proc~isinsidemfz->proc~insidecubicmfz proc~insidedihedralmfz insideDihedralMFZ proc~isinsidemfz->proc~insidedihedralmfz proc~insidecubicmfz->proc~insidecubicfz proc~insidedihedralmfz->proc~insidedihedralfz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~reduceorientationtorfz~~CalledByGraph proc~reduceorientationtorfz ReduceOrientationtoRFZ proc~forwardprojection ForwardProjection proc~forwardprojection->proc~reduceorientationtorfz proc~backprojection BackProjection proc~backprojection->proc~reduceorientationtorfz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code ReduceOrientationtoRFZ Source Code recursive subroutine ReduceOrientationtoRFZ ( eu , dict , FZtype , FZorder , euFZ , MFZ ) !DEC$ ATTRIBUTES DLLEXPORT :: ReduceOrientationtoRFZ use local use rotations use quaternions use so3 use constants IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: eu ( 3 ) type ( dicttype ), INTENT ( IN ) :: dict integer ( kind = irg ), INTENT ( IN ) :: FZtype integer ( kind = irg ), INTENT ( IN ) :: FZorder real ( kind = dbl ), INTENT ( OUT ) :: euFZ ( 3 ) logical , OPTIONAL , INTENT ( IN ) :: MFZ real ( kind = dbl ) :: Mu ( 4 ), qu ( 4 ), rod ( 4 ) integer ( kind = irg ) :: i , j , Pmdims logical :: useMFZ useMFZ = . FALSE . if ( present ( MFZ )) then if ( MFZ . eqv .. TRUE .) then useMFZ = . TRUE . end if endif euFZ = 0.D0 Pmdims = dict % Nqsym Mu = eu2qu ( eu ) if ( Mu ( 1 ). lt . 0.D0 ) Mu = - Mu FZloop : do j = 1 , Pmdims qu = quat_mult ( dict % Pm ( 1 : 4 , j ), Mu ) if ( qu ( 1 ). lt . 0.D0 ) qu = - qu rod = qu2ro ( qu ) if ( abs ( rod ( 4 )) . gt . 1.0D10 ) rod ( 4 ) = inftyd if ( useMFZ . eqv .. TRUE .) then if ( IsinsideMFZ ( rod , FZtype , FZorder )) EXIT FZloop else if ( IsinsideFZ ( rod , FZtype , FZorder )) EXIT FZloop end if ! we really should never get to the following line ... !if (j.eq.Pmdims) write (*,*) 'problem ... ',180.0*eu(1:3)/cPi,eu2ro(eu) end do FZloop euFZ = ro2eu ( rod ) end subroutine ReduceOrientationtoRFZ","tags":"","loc":"proc/reduceorientationtorfz.html","title":"ReduceOrientationtoRFZ – Fortran Program"},{"text":"public recursive subroutine getDisorientationAngleDouble(eu1, eu2, dict, disang, ax) Uses: local rotations quaternions proc~~getdisorientationangledouble~~UsesGraph proc~getdisorientationangledouble getDisorientationAngleDouble quaternions quaternions quaternions->proc~getdisorientationangledouble local local local->proc~getdisorientationangledouble rotations rotations rotations->proc~getdisorientationangledouble Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief Determine the disorientation angle between two orientations (in radians)\n @param eu1 first Euler triplet (in radians)\n @param eu2 first Euler triplet (in radians)\n @param dict dict structure\n @param Pmdims number of symmetry operators to consider\n @date 07/29/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: eu1 (3) real(kind=dbl), intent(in) :: eu2 (3) type(dicttype), intent(in) :: dict real(kind=dbl), intent(out) :: disang real(kind=dbl), intent(out), optional :: ax (3) Calls proc~~getdisorientationangledouble~~CallsGraph proc~getdisorientationangledouble getDisorientationAngleDouble eu2qu eu2qu proc~getdisorientationangledouble->eu2qu quat_mult quat_mult proc~getdisorientationangledouble->quat_mult Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~getdisorientationangledouble~~CalledByGraph proc~getdisorientationangledouble getDisorientationAngleDouble interface~getdisorientationangle getDisorientationAngle interface~getdisorientationangle->proc~getdisorientationangledouble Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getDisorientationAngleDouble Source Code recursive subroutine getDisorientationAngleDouble ( eu1 , eu2 , dict , disang , ax ) !DEC$ ATTRIBUTES DLLEXPORT :: getDisorientationAngleDouble use local use rotations use quaternions IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: eu1 ( 3 ) real ( kind = dbl ), INTENT ( IN ) :: eu2 ( 3 ) type ( dicttype ), INTENT ( IN ) :: dict real ( kind = dbl ), INTENT ( OUT ) :: disang real ( kind = dbl ), OPTIONAL , INTENT ( OUT ) :: ax ( 3 ) real ( kind = dbl ) :: Mu ( 4 ), qu ( 4 ), Mus ( 4 ), qus ( 4 ), p ( 4 ), ac , a integer ( kind = irg ) :: j , k , Pmdims disang = 0.D0 Pmdims = dict % Nqsym a = sum ( abs ( eu1 - eu2 )) if ( a . ne . 0.D0 ) then Mu = eu2qu ( eu1 ) if ( Mu ( 1 ). lt . 0.D0 ) Mu =- Mu qu = eu2qu ( eu2 ) if ( qu ( 1 ). lt . 0.D0 ) qu =- qu ac = 100 0.D0 do j = 1 , Pmdims ! loop over the symmetric equivalents of Mu Mus = quat_mult ( dict % Pm ( 1 : 4 , j ), Mu ) if ( Mus ( 1 ). lt . 0.D0 ) Mus =- Mus do k = 1 , Pmdims qus = quat_mult ( dict % Pm ( 1 : 4 , k ), qu ) if ( qus ( 1 ). lt . 0.D0 ) qus =- qus p = quat_mult ( Mus , conjg ( qus )) if ( p ( 1 ). lt . 0.D0 ) p =- p a = 2.0 * acos ( p ( 1 )) if ( a . lt . ac ) then ac = a if ( present ( ax )) then ax ( 1 : 3 ) = p ( 2 : 4 ) / NORM2 ( p ( 2 : 4 )) end if end if p = quat_mult ( qus , conjg ( Mus )) if ( p ( 1 ). lt . 0.D0 ) p =- p a = 2.0 * acos ( p ( 1 )) if ( a . lt . ac ) then ac = a if ( present ( ax )) then ax ( 1 : 3 ) = p ( 2 : 4 ) / NORM2 ( p ( 2 : 4 )) end if end if end do end do disang = ac end if end subroutine getDisorientationAngleDouble","tags":"","loc":"proc/getdisorientationangledouble.html","title":"getDisorientationAngleDouble – Fortran Program"},{"text":"public recursive subroutine getDisorientationAngleSingle(eu1, eu2, dict, disang, ax) Uses: local rotations quaternions proc~~getdisorientationanglesingle~~UsesGraph proc~getdisorientationanglesingle getDisorientationAngleSingle quaternions quaternions quaternions->proc~getdisorientationanglesingle local local local->proc~getdisorientationanglesingle rotations rotations rotations->proc~getdisorientationanglesingle Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief Determine the disorientation angle between two orientations (in radians, single precision)\n @param eu1 first Euler triplet (in radians)\n @param eu2 first Euler triplet (in radians)\n @param dict dict structure\n @param Pmdims number of symmetry operators to consider\n @date 07/29/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=sgl), intent(in) :: eu1 (3) real(kind=sgl), intent(in) :: eu2 (3) type(dicttype), intent(inout) :: dict real(kind=sgl), intent(out) :: disang real(kind=dbl), intent(out), optional :: ax (3) Calls proc~~getdisorientationanglesingle~~CallsGraph proc~getdisorientationanglesingle getDisorientationAngleSingle sngl sngl proc~getdisorientationanglesingle->sngl eu2qu eu2qu proc~getdisorientationanglesingle->eu2qu quat_mult quat_mult proc~getdisorientationanglesingle->quat_mult Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~getdisorientationanglesingle~~CalledByGraph proc~getdisorientationanglesingle getDisorientationAngleSingle interface~getdisorientationangle getDisorientationAngle interface~getdisorientationangle->proc~getdisorientationanglesingle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getDisorientationAngleSingle Source Code recursive subroutine getDisorientationAngleSingle ( eu1 , eu2 , dict , disang , ax ) ! result(disang) !DEC$ ATTRIBUTES DLLEXPORT :: getDisorientationAngleSingle use local use rotations use quaternions IMPLICIT NONE real ( kind = sgl ), INTENT ( IN ) :: eu1 ( 3 ) real ( kind = sgl ), INTENT ( IN ) :: eu2 ( 3 ) type ( dicttype ), INTENT ( INOUT ) :: dict real ( kind = sgl ), INTENT ( OUT ) :: disang real ( kind = dbl ), OPTIONAL , INTENT ( OUT ) :: ax ( 3 ) real ( kind = sgl ) :: Mu ( 4 ), qu ( 4 ), Mus ( 4 ), qus ( 4 ), p ( 4 ), ac , a integer ( kind = irg ) :: j , k , Pmdims disang = 0.0 Pmdims = dict % Nqsym a = sum ( abs ( eu1 - eu2 )) if ( a . ne . 0.0 ) then Mu = eu2qu ( eu1 ) if ( Mu ( 1 ). lt . 0.0 ) Mu =- Mu qu = eu2qu ( eu2 ) if ( qu ( 1 ). lt . 0.0 ) qu =- qu ac = 100 0.0 do j = 1 , Pmdims ! loop over the symmetric equivalents of Mu Mus = quat_mult ( sngl ( dict % Pm ( 1 : 4 , j )), Mu ) if ( Mus ( 1 ). lt . 0.0 ) Mus =- Mus do k = 1 , Pmdims qus = quat_mult ( sngl ( dict % Pm ( 1 : 4 , k )), qu ) if ( qus ( 1 ). lt . 0.0 ) qus =- qus p = quat_mult ( Mus , conjg ( qus )) if ( p ( 1 ). lt . 0.0 ) p =- p a = 2.0 * acos ( p ( 1 )) if ( a . lt . ac ) then ac = a if ( present ( ax )) then ax ( 1 : 3 ) = p ( 2 : 4 ) / NORM2 ( p ( 2 : 4 )) end if end if p = quat_mult ( qus , conjg ( Mus )) if ( p ( 1 ). lt . 0.0 ) p =- p a = 2.0 * acos ( p ( 1 )) if ( a . lt . ac ) then ac = a if ( present ( ax )) then ax ( 1 : 3 ) = p ( 2 : 4 ) / NORM2 ( p ( 2 : 4 )) end if end if end do end do disang = ac end if end subroutine getDisorientationAngleSingle","tags":"","loc":"proc/getdisorientationanglesingle.html","title":"getDisorientationAngleSingle – Fortran Program"},{"text":"public recursive subroutine getDisorientationAngleAxis(eu1, eu2, dict, disax) Uses: local rotations quaternions proc~~getdisorientationangleaxis~~UsesGraph proc~getdisorientationangleaxis getDisorientationAngleAxis quaternions quaternions quaternions->proc~getdisorientationangleaxis local local local->proc~getdisorientationangleaxis rotations rotations rotations->proc~getdisorientationangleaxis Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief Determine the disorientation angle and axis between two orientations (in radians)\n @param eu1 first Euler triplet (in radians)\n @param eu2 first Euler triplet (in radians)\n @param dict dict structure\n @date 02/14/17 SS 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: eu1 (3) real(kind=dbl), intent(in) :: eu2 (3) type(dicttype), intent(in) :: dict real(kind=dbl), intent(out) :: disax (4) Calls proc~~getdisorientationangleaxis~~CallsGraph proc~getdisorientationangleaxis getDisorientationAngleAxis eu2qu eu2qu proc~getdisorientationangleaxis->eu2qu quat_mult quat_mult proc~getdisorientationangleaxis->quat_mult Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getDisorientationAngleAxis Source Code recursive subroutine getDisorientationAngleAxis ( eu1 , eu2 , dict , disax ) !DEC$ ATTRIBUTES DLLEXPORT :: getDisorientationAngleAxis use local use rotations use quaternions IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: eu1 ( 3 ) real ( kind = dbl ), INTENT ( IN ) :: eu2 ( 3 ) type ( dicttype ), INTENT ( IN ) :: dict real ( kind = dbl ), INTENT ( OUT ) :: disax ( 4 ) real ( kind = dbl ) :: Mu ( 4 ), qu ( 4 ), Mus ( 4 ), qus ( 4 ), p ( 4 ), ac , a , ax ( 3 ) integer ( kind = irg ) :: j , k , Pmdims disax = 0.D0 Pmdims = dict % Nqsym a = sum ( abs ( eu1 - eu2 )) if ( a . ne . 0.D0 ) then Mu = eu2qu ( eu1 ) if ( Mu ( 1 ). lt . 0.D0 ) Mu =- Mu qu = eu2qu ( eu2 ) if ( qu ( 1 ). lt . 0.D0 ) qu =- qu ac = 100 0.D0 do j = 1 , Pmdims ! loop over the symmetric equivalents of Mu Mus = quat_mult ( dict % Pm ( 1 : 4 , j ), Mu ) if ( Mus ( 1 ). lt . 0.D0 ) Mus =- Mus do k = 1 , Pmdims qus = quat_mult ( dict % Pm ( 1 : 4 , k ), qu ) if ( qus ( 1 ). lt . 0.D0 ) qus =- qus p = quat_mult ( Mus , conjg ( qus )) if ( p ( 1 ). lt . 0.D0 ) p =- p a = 2.0 * acos ( p ( 1 )) if ( a . lt . ac ) then ac = a ax ( 1 : 3 ) = p ( 2 : 4 ) / NORM2 ( p ( 2 : 4 )) end if p = quat_mult ( qus , conjg ( Mus )) if ( p ( 1 ). lt . 0.D0 ) p =- p a = 2.0 * acos ( p ( 1 )) if ( a . lt . ac ) then ac = a ax ( 1 : 3 ) = p ( 2 : 4 ) / NORM2 ( p ( 2 : 4 )) end if end do end do disax ( 1 : 3 ) = ax ( 1 : 3 ) disax ( 4 ) = ac end if end subroutine getDisorientationAngleAxis","tags":"","loc":"proc/getdisorientationangleaxis.html","title":"getDisorientationAngleAxis – Fortran Program"},{"text":"public recursive subroutine getDisorientationAngleAxisTwoPhases(eu1, eu2, dict1, dict2, disax) Uses: local rotations quaternions proc~~getdisorientationangleaxistwophases~~UsesGraph proc~getdisorientationangleaxistwophases getDisorientationAngleAxisTwoPhases quaternions quaternions quaternions->proc~getdisorientationangleaxistwophases local local local->proc~getdisorientationangleaxistwophases rotations rotations rotations->proc~getdisorientationangleaxistwophases Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief Determine the disorientation angle and axis between two orientations (in radians)\n @param eu1 first Euler triplet (in radians)\n @param eu2 first Euler triplet (in radians)\n @param dict1 dict1 structure\n @param dict2 dict2 structure\n @param disax smallest rotation angle disorientation axis-angle pair\n @date 02/14/17 SS 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: eu1 (3) real(kind=dbl), intent(in) :: eu2 (3) type(dicttype), intent(in) :: dict1 type(dicttype), intent(in) :: dict2 real(kind=dbl), intent(out) :: disax (4) Calls proc~~getdisorientationangleaxistwophases~~CallsGraph proc~getdisorientationangleaxistwophases getDisorientationAngleAxisTwoPhases eu2qu eu2qu proc~getdisorientationangleaxistwophases->eu2qu quat_mult quat_mult proc~getdisorientationangleaxistwophases->quat_mult Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getDisorientationAngleAxisTwoPhases Source Code recursive subroutine getDisorientationAngleAxisTwoPhases ( eu1 , eu2 , dict1 , dict2 , disax ) !DEC$ ATTRIBUTES DLLEXPORT :: getDisorientationAngleAxisTwoPhases use local use rotations use quaternions IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: eu1 ( 3 ) real ( kind = dbl ), INTENT ( IN ) :: eu2 ( 3 ) type ( dicttype ), INTENT ( IN ) :: dict1 type ( dicttype ), INTENT ( IN ) :: dict2 real ( kind = dbl ), INTENT ( OUT ) :: disax ( 4 ) real ( kind = dbl ) :: Mu ( 4 ), qu ( 4 ), Mus ( 4 ), qus ( 4 ), p ( 4 ), ac , a , ax ( 3 ), axax ( 4 ) integer ( kind = irg ) :: j , k , Pmdims1 , Pmdims2 disax = 0.D0 Pmdims1 = dict1 % Nqsym Pmdims2 = dict2 % Nqsym a = sum ( abs ( eu1 - eu2 )) if ( a . ne . 0.D0 ) then Mu = eu2qu ( eu1 ) if ( Mu ( 1 ). lt . 0.D0 ) Mu =- Mu qu = eu2qu ( eu2 ) if ( qu ( 1 ). lt . 0.D0 ) qu =- qu ac = 100 0.D0 do j = 1 , Pmdims1 ! loop over the symmetric equivalents of Mu Mus = quat_mult ( dict1 % Pm ( 1 : 4 , j ), Mu ) if ( Mus ( 1 ). lt . 0.D0 ) Mus =- Mus do k = 1 , Pmdims2 qus = quat_mult ( dict2 % Pm ( 1 : 4 , k ), qu ) if ( qus ( 1 ). lt . 0.D0 ) qus =- qus p = quat_mult ( Mus , conjg ( qus )) if ( p ( 1 ). lt . 0.D0 ) p =- p a = 2.0 * acos ( p ( 1 )) if ( a . lt . ac ) then ac = a ax ( 1 : 3 ) = p ( 2 : 4 ) / NORM2 ( p ( 2 : 4 )) end if end do end do disax ( 1 : 3 ) = ax ( 1 : 3 ) disax ( 4 ) = ac end if end subroutine getDisorientationAngleAxisTwoPhases","tags":"","loc":"proc/getdisorientationangleaxistwophases.html","title":"getDisorientationAngleAxisTwoPhases – Fortran Program"},{"text":"public interface getDisorientationAngle Calls interface~~getdisorientationangle~~CallsGraph interface~getdisorientationangle getDisorientationAngle proc~getdisorientationanglesingle getDisorientationAngleSingle interface~getdisorientationangle->proc~getdisorientationanglesingle proc~getdisorientationangledouble getDisorientationAngleDouble interface~getdisorientationangle->proc~getdisorientationangledouble sngl sngl proc~getdisorientationanglesingle->sngl eu2qu eu2qu proc~getdisorientationanglesingle->eu2qu quat_mult quat_mult proc~getdisorientationanglesingle->quat_mult proc~getdisorientationangledouble->eu2qu proc~getdisorientationangledouble->quat_mult Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Module Procedures getDisorientationAngleSingle getDisorientationAngleDouble Module Procedures public recursive subroutine getDisorientationAngleSingle (eu1, eu2, dict, disang, ax) @author Marc De Graef, Carnegie Mellon University\n @brief Determine the disorientation angle between two orientations (in radians, single precision)\n @param eu1 first Euler triplet (in radians)\n @param eu2 first Euler triplet (in radians)\n @param dict dict structure\n @param Pmdims number of symmetry operators to consider\n @date 07/29/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=sgl), intent(in) :: eu1 (3) real(kind=sgl), intent(in) :: eu2 (3) type(dicttype), intent(inout) :: dict real(kind=sgl), intent(out) :: disang real(kind=dbl), intent(out), optional :: ax (3) public recursive subroutine getDisorientationAngleDouble (eu1, eu2, dict, disang, ax) @author Marc De Graef, Carnegie Mellon University\n @brief Determine the disorientation angle between two orientations (in radians)\n @param eu1 first Euler triplet (in radians)\n @param eu2 first Euler triplet (in radians)\n @param dict dict structure\n @param Pmdims number of symmetry operators to consider\n @date 07/29/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: eu1 (3) real(kind=dbl), intent(in) :: eu2 (3) type(dicttype), intent(in) :: dict real(kind=dbl), intent(out) :: disang real(kind=dbl), intent(out), optional :: ax (3)","tags":"","loc":"interface/getdisorientationangle.html","title":"getDisorientationAngle – Fortran Program"},{"text":"public recursive function YSHDisp(x, y, z, ii) Uses: local constants proc~~yshdisp~~UsesGraph proc~yshdisp YSHDisp local local local->proc~yshdisp module~constants constants local->module~constants module~constants->proc~yshdisp Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real(kind=dbl) :: x real(kind=dbl) :: y real(kind=dbl) :: z integer(kind=irg) :: ii Return Value real(kind=dbl)\n  (3) Calls proc~~yshdisp~~CallsGraph proc~yshdisp YSHDisp datan2 datan2 proc~yshdisp->datan2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~yshdisp~~CalledByGraph proc~yshdisp YSHDisp proc~calcrlocal CalcRLocal proc~calcrlocal->proc~yshdisp program~dispfield dispfield program~dispfield->proc~calcrlocal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code YSHDisp Source Code recursive function YSHDisp ( x , y , z , ii ) !DEC$ ATTRIBUTES DLLEXPORT :: YSHDisp ! ! compute the displacement field of an inclined dislocation intersection the top surface of ! the foil, taking into account surface relaxations for the isotropic elastic case (cubic only) ... ! ! equations are based on the Shaibani&Hazzledine 1981 paper, along with special limits for ! the alpha->0 case, which were derived by MDG using Mathematica. use local use constants IMPLICIT NONE integer ( kind = irg ) :: ii real ( kind = dbl ) :: eta , zeta , etap , zetap , r , oms , omts , xx , sgn , om , omp , AA , BB , BBp , th , & k , lam , alA , alB , u , v , w , ms , S , du , dv , dw , qe , me , De , qx , mx , Dx , rr , eps real ( kind = dbl ) :: x , y , z real ( kind = dbl ) :: YSHDisp ( 3 ) ! initialize the geometrical parameters eta = y * YD ( ii )% ca - z * YD ( ii )% sa zeta = y * YD ( ii )% sa + z * YD ( ii )% ca etap = - y * YD ( ii )% ca - z * YD ( ii )% sa zetap = y * YD ( ii )% sa - z * YD ( ii )% ca r = sqrt ( x ** 2 + y ** 2 + z ** 2 ) oms = 1.D0 - YD ( ii )% sig omts = 1.D0 - 2.D0 * YD ( ii )% sig ! cover the special case of negative x values (based on IDL tests) xx = x if ( xx . lt . 0.D0 ) then x = dabs ( x ) sgn = - 1.D0 else sgn = 1.D0 end if ! more parameters om = ( datan2 ( y , x ) - datan2 ( eta , x ) + datan2 ( x * r * YD ( ii )% sa , eta * y + x ** 2 * YD ( ii )% ca )) omp = ( datan2 ( y , x ) - datan2 ( etap , x ) + datan2 ( x * r * YD ( ii )% sa , etap * y - x ** 2 * YD ( ii )% ca )) AA = r - z BB = r - zeta BBp = r - zetap th = 2.D0 * oms * ( omp - om ) k = 4.D0 * oms * omts * YD ( ii )% cota ** 2 lam = omts * dlog ( BBp / BB ) alA = dlog ( AA ) alB = dlog ( BB ) u = 0.D0 v = 0.D0 w = 0.D0 eps = 1.0D-6 ! screw component first if ( abs ( YD ( ii )% bs ). gt . eps ) then ms = x * sin ( 2.D0 * YD ( ii )% alpha ) / r / BB S = YD ( ii )% bs / ( 4.D0 * cPi ) if ( YD ( ii )% alpha . gt . 0.01 ) then du = x * ms + 2.D0 * eta * YD ( ii )% ca ** 2 / BB + 2.D0 * omts * YD ( ii )% cota * ( - 1.D0 + YD ( ii )% ca + & YD ( ii )% ca * alA - y * YD ( ii )% sa / AA - alB ) - sin ( 2.D0 * YD ( ii )% alpha ) dv = y * ms - 2.D0 * x * YD ( ii )% ca / BB - YD ( ii )% sa * ( omp - om ) + 2.D0 * omts * YD ( ii )% cota * ( x * YD ( ii )% sa / AA - om * YD ( ii )% ca ) dw = z * ms + YD ( ii )% ca * ( omp - om ) - 2.D0 * omts * om * YD ( ii )% ca else du = 2.D0 * y / ( r - z ) dv = 2.D0 * x / ( r - z ) dw = cPi + datan2 ( y , x ) - datan2 ( - y , x ) end if u = u + du * S v = v - sgn * dv * S w = w + sgn * dw * S end if ! then the edge component in the y-z plane if ( abs ( YD ( ii )% be ). gt . eps ) then qe = x * ( 1.D0 / BBp - 1.D0 / BB + 2.D0 * z * YD ( ii )% ca / BB ** 2 ) me = - qe / r - 4.D0 * oms * x * YD ( ii )% ca ** 2 / r / BB De = YD ( ii )% be / ( 8.D0 * cPi * oms ) if ( YD ( ii )% alpha . gt . 0.01 ) then du = x * me + lam + 2.D0 * YD ( ii )% ca * ( z + 2.D0 * oms * eta * YD ( ii )% sa ) / BB - 4.D0 * oms * YD ( ii )% sa ** 2 + k * ( 1.D0 - YD ( ii )% ca - YD ( ii )% ca * alA + & y * YD ( ii )% sa / AA + alB ) dv = y * me + qe * YD ( ii )% sa + th * YD ( ii )% ca + k * ( - x * YD ( ii )% sa / AA + om * YD ( ii )% ca ) dw = z * me + qe * YD ( ii )% ca + th * YD ( ii )% sa - 2.D0 * x * YD ( ii )% ca * ( 1.D0 / BBp + omts / BB ) + k * om * YD ( ii )% sa !    write (*,*) du,dv,dw else rr = x ** 2 + y ** 2 du = 2.D0 * z / ( r - z ) + 4.D0 * x ** 2 * ( YD ( ii )% sig * rr - r ** 2 ) / r / AA ** 2 / ( r + z ) + 2.D0 * omts * oms * (( x ** 2 + z * ( z + r )) / AA ** 2 + alA ) + omts * dlog (( r + z ) / AA ) dv = 4.D0 * x * y * ( rr * YD ( ii )% sig - r ** 2 ) / r / AA ** 2 / ( r + z ) + 2.D0 * x * y * ( rr + 2.D0 * z * ( r + z )) * oms * omts / rr ** 2 + & 2.D0 * oms * ( cPi + datan2 ( y , x ) - datan2 ( - y , x )) dw = 4.D0 * x * rr * YD ( ii )% sig * ( z - 2.D0 * r * oms ) / r / AA ** 2 / ( r + z ) end if u = u + du * De v = v + sgn * dv * De w = w + sgn * dw * De end if ! and finally the bx edge component if ( abs ( YD ( ii )% bx ). gt . eps ) then qx = etap / BBp - eta / BB - 2.D0 * z * eta * YD ( ii )% ca / BB ** 2 mx = - qx / r + 2.D0 * omts * y * YD ( ii )% ca / r / BB Dx = YD ( ii )% bx / ( 8.D0 * cPi * oms ) du = x * mx + th + k * ( x * YD ( ii )% ta / AA - om ) dv = y * mx + qx * YD ( ii )% sa - lam * YD ( ii )% ca - 2.D0 * YD ( ii )% ca * ( z * YD ( ii )% ca + omts * y * YD ( ii )% sa ) / BB + k * ( - 1.D0 + YD ( ii )% ca - alA + y * YD ( ii )% ta / AA + & YD ( ii )% ca * alB ) dw = z * mx + qx * YD ( ii )% ca - lam * YD ( ii )% sa - 2.D0 * etap * YD ( ii )% ca / BBp + 4.D0 * YD ( ii )% ca * ( oms * y * YD ( ii )% ca - omts * z * YD ( ii )% sa ) / BB + & k * YD ( ii )% ta * ( YD ( ii )% ca - alA + YD ( ii )% ca * alB ) + 4.D0 * oms * YD ( ii )% ca * YD ( ii )% cota u = u + sgn * du * Dx v = v + dv * Dx w = w + dw * Dx end if ! and return the displacement components !write (*,*) u,v,w YSHDisp = ( / u , v , w / ) end function YSHDisp","tags":"","loc":"proc/yshdisp.html","title":"YSHDisp – Fortran Program"},{"text":"public recursive subroutine makeYSHdislocation(i, dinfo, L) Uses: local foilmodule constants crystal proc~~makeyshdislocation~2~~UsesGraph proc~makeyshdislocation~2 makeYSHdislocation module~constants constants module~constants->proc~makeyshdislocation~2 crystal crystal crystal->proc~makeyshdislocation~2 local local local->proc~makeyshdislocation~2 local->module~constants foilmodule foilmodule foilmodule->proc~makeyshdislocation~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name integer(kind=irg) :: i integer(kind=irg) :: dinfo real(kind=sgl) :: L Calls proc~~makeyshdislocation~2~~CallsGraph proc~makeyshdislocation~2 makeYSHdislocation normvec normvec proc~makeyshdislocation~2->normvec calclength calclength proc~makeyshdislocation~2->calclength calcangle calcangle proc~makeyshdislocation~2->calcangle calcdot calcdot proc~makeyshdislocation~2->calcdot calccross calccross proc~makeyshdislocation~2->calccross transspace transspace proc~makeyshdislocation~2->transspace Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~makeyshdislocation~2~~CalledByGraph proc~makeyshdislocation~2 makeYSHdislocation proc~read_ysh_dislocation_data read_YSH_dislocation_data proc~read_ysh_dislocation_data->proc~makeyshdislocation~2 program~dispfield dispfield program~dispfield->proc~read_ysh_dislocation_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code makeYSHdislocation Source Code recursive subroutine makeYSHdislocation ( i , dinfo , L ) !DEC$ ATTRIBUTES DLLEXPORT :: makeYSHdislocation ! ! this routine pre-computes a number of parameters related to the ! geometry of the Yoffe&Shaibani&Hazzledine (YSH) surface-relaxed dislocation in an elastically ! isotropic matrix.  These parameters are then used in the CalcR routine. ! ! We implemented the YSH expressions instead of Yoffe's ! since the former are more easily handled for numerical computations. ! SH have redefined the x-y-z reference frame used by Yoffe to fall along ! the dislocation line itself.  As a result, the Burgers vector must be decomposed ! into a screw component and two edge components, one in the plane of the ! discontinuity, the other normal to that plane (which is by definition the x-axis). ! Check the SH paper for more details. use local use foilmodule use constants use crystal IMPLICIT NONE real ( kind = sgl ) :: alpha , beta , L , tu ( 3 ), tx ( 3 ), ty ( 3 ), te ( 3 ), tb ( 3 ), bl integer ( kind = irg ) :: i , dinfo ! first, determine the alpha angle between the ! negative z-axis, which is really the negative foil normal, and the line direction ! (make sure to reduce the angle to [0,90] interval). alpha = CalcAngle ( - foil % F , YD ( i )% u , 'd' ) * 18 0.0 / cPi if ( alpha . gt . 9 0.0 ) then alpha = 18 0.0 - alpha YD ( i )% u = - YD ( i )% u ! the u-direction should point down into the foil end if write ( * , * ) 'Foil normal = ' , foil % F write ( * , * ) 'line direction = ' , YD ( i )% u write ( * , * ) '  --> alpha angle = ' , alpha alpha = alpha * cPi / 18 0.0 call TransSpace ( YD ( i )% u , tu , 'd' , 'c' ) call NormVec ( tu , 'c' ) call TransSpace ( foil % F , ty , 'd' , 'c' ) call NormVec ( ty , 'c' ) call CalcCross ( tu , ty , tx , 'c' , 'c' , 0 ) ! x = u x F call NormVec ( tx , 'c' ) call CalcCross ( tx , tu , te , 'c' , 'c' , 0 ) ! e = x x u call NormVec ( te , 'c' ) call CalcCross ( ty , tx , ty , 'c' , 'c' , 0 ) call NormVec ( ty , 'c' ) bl = CalcLength ( YD ( i )% burg , 'd' ) write ( * , * ) ' tx = ' , tx write ( * , * ) ' te = ' , te write ( * , * ) ' tu = ' , tu write ( * , * ) ' ty = ' , ty write ( * , * ) ' bl = ' , bl call TransSpace ( YD ( i )% burg , tb , 'd' , 'c' ) call NormVec ( tb , 'c' ) YD ( i )% bx = bl * CalcDot ( tb , tx , 'c' ) ! edge component normal to cut plane YD ( i )% be = bl * CalcDot ( tb , te , 'c' ) ! edge component in cut plane YD ( i )% bs = bl * CalcDot ( tb , tu , 'c' ) ! screw component write ( * , * ) 'Burgers vector components (bx,be,bs) ' , YD ( i )% bx , YD ( i )% be , YD ( i )% bs ! we will also need to know the rotation matrix between the dislocation reference frame ! and the foil reference frame, so that we can transform the foil coordinates to defect ! coordinates...  We need the angle beta between the defect x axis (tx) and the foil x axis, ! which is the first column of the foil%a_fc matrix ... ty ( 1 : 3 ) = foil % a_fc ( 1 : 3 , 1 ) write ( * , * ) ' tx = ' , tx YD ( i )% beta = CalcAngle ( tx , ty , 'd' ) write ( * , * ) ' ty = ' , ty write ( * , * ) ' beta = ' , YD ( i )% beta beta = YD ( i )% beta YD ( i )% a_di ( 1 , 1 : 3 ) = ( / cos ( beta ), - sin ( beta ), 0.0 / ) YD ( i )% a_di ( 2 , 1 : 3 ) = ( / sin ( beta ), cos ( beta ), 0.0 / ) YD ( i )% a_di ( 3 , 1 : 3 ) = ( / 0.0 , 0.0 , 1.0 / ) YD ( i )% a_id = transpose ( YD ( i )% a_di ) write ( * , * ) YD ( i )% a_di ! finally some geometrical parameters needed for the displacement field computation... YD ( i )% alpha = alpha YD ( i )% ca = cos ( alpha ) YD ( i )% sa = sin ( alpha ) YD ( i )% ta = tan ( alpha ) YD ( i )% cota = 1.0 / YD ( i )% ta write ( * , * ) 'angulars = ' , cos ( alpha ), sin ( alpha ), tan ( alpha ) ! that's it! the rest is handled in the CalcR routine. end subroutine makeYSHdislocation","tags":"","loc":"proc/makeyshdislocation~2.html","title":"makeYSHdislocation – Fortran Program"},{"text":"public recursive subroutine read_YSH_dislocation_data(dislYname, numYdisl, DF_npix, DF_npiy, DF_gf, L, dinfo) Uses: local io files typedefs proc~~read_ysh_dislocation_data~~UsesGraph proc~read_ysh_dislocation_data read_YSH_dislocation_data typedefs typedefs typedefs->proc~read_ysh_dislocation_data io io io->proc~read_ysh_dislocation_data local local local->proc~read_ysh_dislocation_data files files files->proc~read_ysh_dislocation_data Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name character(len=50) :: dislYname (3*maxdefects) integer(kind=irg) :: numYdisl integer(kind=irg) :: DF_npix integer(kind=irg) :: DF_npiy real(kind=sgl) :: DF_gf (3) real(kind=sgl) :: L integer(kind=irg) :: dinfo Calls proc~~read_ysh_dislocation_data~~CallsGraph proc~read_ysh_dislocation_data read_YSH_dislocation_data emsoft_tonativepath emsoft_tonativepath proc~read_ysh_dislocation_data->emsoft_tonativepath proc~makeyshdislocation~2 makeYSHdislocation proc~read_ysh_dislocation_data->proc~makeyshdislocation~2 message message proc~read_ysh_dislocation_data->message float float proc~read_ysh_dislocation_data->float normvec normvec proc~makeyshdislocation~2->normvec calclength calclength proc~makeyshdislocation~2->calclength calcangle calcangle proc~makeyshdislocation~2->calcangle calcdot calcdot proc~makeyshdislocation~2->calcdot calccross calccross proc~makeyshdislocation~2->calccross transspace transspace proc~makeyshdislocation~2->transspace Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~read_ysh_dislocation_data~~CalledByGraph proc~read_ysh_dislocation_data read_YSH_dislocation_data program~dispfield dispfield program~dispfield->proc~read_ysh_dislocation_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code read_YSH_dislocation_data Source Code recursive subroutine read_YSH_dislocation_data ( dislYname , numYdisl , DF_npix , DF_npiy , DF_gf , L , dinfo ) !DEC$ ATTRIBUTES DLLEXPORT :: read_YSH_dislocation_data use local use io use files use typedefs IMPLICIT NONE integer ( kind = irg ) :: i , numYdisl , dinfo , DF_npix , DF_npiy real ( kind = sgl ) :: id , jd , u ( 3 ), bv ( 3 ), DF_gf ( 3 ), L , poisson character ( 50 ) :: dislYname ( 3 * maxdefects ) namelist / dislocationdata / id , jd , u , bv , poisson ! allocate the memory for the dislocation parameters allocate ( YD ( numYdisl )) ! these are just the individual dislocations; the ones that belong to ! stacking faults are handled separately do i = 1 , numYdisl mess = 'opening ' // dislYname ( i ); call Message ( \"(/A)\" ) open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( dislYname ( i ))), DELIM = 'APOSTROPHE' ) read ( UNIT = dataunit , NML = dislocationdata ) close ( UNIT = dataunit ) ! top-of-the-foil intersection of dislocation line is transformed to foil coordinates [nm] with DL(i)%kd=0 (center of foil) [verified 4/23/11] ! the point (0,0) is at the center of the image ... hence the factor of 0.5 YD ( i )% id = id * 0.5 * float ( DF_npix ) ! * L   scaling (zooming) is done in the image reference frame... YD ( i )% jd = jd * 0.5 * float ( DF_npiy ) ! * L YD ( i )% u = u YD ( i )% burg = bv YD ( i )% g = DF_gf YD ( i )% sig = poisson ! and pre-compute the dislocation displacement field parameters call makeYSHdislocation ( i , dinfo , L ) end do end subroutine read_YSH_dislocation_data","tags":"","loc":"proc/read_ysh_dislocation_data.html","title":"read_YSH_dislocation_data – Fortran Program"},{"text":"public recursive subroutine BarrelDistortion(D, img, nnx, nny) Uses: math proc~~barreldistortion~~UsesGraph proc~barreldistortion BarrelDistortion math math math->proc~barreldistortion Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief barrel distortion observed in TESCAN MIRA microscope\n @param D     complex distortion coefficient\n @param img   Input=undistorted image/output = distorted image\n @param nnx   size of image in x\n @param nny   size of image in y\n @date 06/24/14  SS 1.0 original\n @date 01/25/16 MDG 1.1 minor mods to make routine more efficient Arguments Type Intent Optional Attributes Name complex(kind=dbl), intent(in) :: D real(kind=sgl), intent(inout) :: img (nnx,nny) integer(kind=irg), intent(in) :: nnx integer(kind=irg), intent(in) :: nny Calls proc~~barreldistortion~~CallsGraph proc~barreldistortion BarrelDistortion datan2 datan2 proc~barreldistortion->datan2 dsin dsin proc~barreldistortion->dsin dcos dcos proc~barreldistortion->dcos cubicroots cubicroots proc~barreldistortion->cubicroots Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code BarrelDistortion Source Code recursive subroutine BarrelDistortion ( D , img , nnx , nny ) !DEC$ ATTRIBUTES DLLEXPORT :: BarrelDistortion use math IMPLICIT NONE complex ( kind = dbl ), INTENT ( IN ) :: D real ( kind = sgl ), INTENT ( INOUT ) :: img ( nnx , nny ) integer ( kind = irg ), INTENT ( IN ) :: nnx , nny real ( kind = sgl ), allocatable :: dimg (:,:) real ( kind = dbl ) :: co ( 4 ), Dp , thetad integer ( kind = irg ) :: ii , jj , I ( 1 ) complex ( kind = dbl ) :: roots ( 3 ) real ( kind = dbl ) :: x , y , r0 , r , Ap , Bp , theta integer ( kind = irg ) :: nix , niy , nixp , niyp real ( kind = dbl ) :: x_new , y_new , dx , dy , dxm , dym , shx , shy , x2 , tmp , x_new_s , y_new_s real ( kind = dbl ), parameter :: epsdp = 1.0D-8 , epsth = 1.0D-2 Dp = abs ( D ) thetad = datan2 ( imag ( D ), real ( D )) if ( Dp . le . epsdp ) return allocate ( dimg ( nnx , nny )) dimg = 0.0 x_new_s = dble ( nnx ) * 0.5D0 y_new_s = dble ( nny ) * 0.5D0 shx = dble ( floor ( x_new_s )) shy = dble ( floor ( y_new_s )) do ii = 1 , nnx x = dble ( ii ) - shx x2 = x * x do jj = 1 , nny y = dble ( jj ) - shy co = ( / Dp * Dp , 2.D0 * Dp * dcos ( thetad ), 1.D0 , - ( x2 + y * y ) / ) r0 = dsqrt ( - co ( 4 )) if ( r0 . eq . 0 D0 ) then r = 0.D0 Ap = 0.D0 Bp = 0.D0 else if ( abs ( thetad ) . le . epsth ) then co = ( / Dp , 0.D0 , 1.D0 , - dsqrt ( x2 + y * y ) / ) call cubicroots ( co , roots ) I = MINLOC (( / abs ( imag ( roots ( 1 ))), abs ( imag ( roots ( 2 ))), abs ( imag ( roots ( 3 ))) / )) r = real ( roots ( I ( 1 ))) theta = datan2 ( y , x ) else call cubicroots ( co , roots ) I = MINLOC (( / abs ( imag ( roots ( 1 ))), abs ( imag ( roots ( 2 ))), abs ( imag ( roots ( 3 ))) / )) r = dsqrt ( real ( roots ( I ( 1 )))) tmp = Dp * r * r * r / r0 Ap = r / r0 + tmp * dcos ( thetad ) Bp = tmp * dsin ( thetad ) theta = datan2 ( y , x ) - datan2 ( Bp , Ap ) end if end if x_new = r * dcos ( theta ) y_new = r * dsin ( theta ) nix = floor ( x_new + x_new_s ) nixp = nix + 1 dx = x_new + shx - dble ( nix ) niy = floor ( y_new + y_new_s ) niyp = niy + 1 dy = y_new + shy - dble ( niy ) if ( nix . lt . 1 ) then nix = 1 dx = 1.D0 end if if ( nix . gt . nnx ) then nix = nnx dx = 0.D0 end if if ( niy . lt . 1 ) then niy = 1 dy = 1.D0 end if if ( niy . gt . nny ) then niy = nny dy = 0.D0 end if if ( nixp . lt . 1 ) nixp = 1 if ( nixp . gt . nnx ) nixp = nnx if ( niyp . lt . 1 ) niyp = 1 if ( niyp . gt . nny ) niyp = nny dxm = 1.D0 - dx dym = 1.D0 - dy dimg ( ii , jj ) = img ( nix , niy ) * dxm * dym + img ( nixp , niy ) * dxm * dy + & img ( nix , niyp ) * dx * dym + img ( nixp , niyp ) * dx * dy end do end do img = dimg deallocate ( dimg ) end subroutine BarrelDistortion","tags":"","loc":"proc/barreldistortion.html","title":"BarrelDistortion – Fortran Program"},{"text":"public recursive function NANCHK(X) Arguments Type Intent Optional Attributes Name real, intent(in) :: X Return Value logical","tags":"","loc":"proc/nanchk.html","title":"NANCHK – Fortran Program"},{"text":"public recursive subroutine Calckvectorcone(cell, khead, k, ga, ktxy, ktrad, ktstep, numk) Uses: io error diffraction crystal kvectors proc~~calckvectorcone~~UsesGraph proc~calckvectorcone Calckvectorcone io io io->proc~calckvectorcone kvectors kvectors kvectors->proc~calckvectorcone crystal crystal crystal->proc~calckvectorcone diffraction diffraction diffraction->proc~calckvectorcone error error error->proc~calckvectorcone Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief compute a set of incident beam directions for single image ECCI mode\n @param cell unit cell pointer\n @param khead head of kvector linked list\n @param k incident wave vector (zone axis)\n @param ga principal g vector\n @param ktxy tangential components\n @param ktrad cone opening angle\n @param ktstep number of steps along cone radius\n @param numk resulting number of incident beam directions\n @date 11/29/01 MDG 1.0 original\n @date 12/05/13 MDG 2.0 adapted for ECCI simulations \n @date 12/01/15 MDG 2.1 simplification of input parameters Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(kvectorlist), pointer :: khead integer(kind=irg), intent(in) :: k (3) integer(kind=irg), intent(in) :: ga (3) real(kind=sgl), intent(in) :: ktxy (2) real(kind=sgl), intent(in) :: ktrad integer(kind=irg), intent(in) :: ktstep integer(kind=irg), intent(out) :: numk Calls proc~~calckvectorcone~~CallsGraph proc~calckvectorcone Calckvectorcone float float proc~calckvectorcone->float normvec normvec proc~calckvectorcone->normvec calcdot calcdot proc~calckvectorcone->calcdot calclength calclength proc~calckvectorcone->calclength transspace transspace proc~calckvectorcone->transspace calccross calccross proc~calckvectorcone->calccross fatalerror fatalerror proc~calckvectorcone->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code Calckvectorcone Source Code recursive subroutine Calckvectorcone ( cell , khead , k , ga , ktxy , ktrad , ktstep , numk ) !DEC$ ATTRIBUTES DLLEXPORT :: Calckvectorcone use io use error use diffraction use crystal use kvectors IMPLICIT NONE type ( unitcell ), pointer :: cell type ( kvectorlist ), pointer :: khead integer ( kind = irg ), INTENT ( IN ) :: k ( 3 ) integer ( kind = irg ), INTENT ( IN ) :: ga ( 3 ) real ( kind = sgl ), INTENT ( IN ) :: ktxy ( 2 ) real ( kind = sgl ), INTENT ( IN ) :: ktrad integer ( kind = irg ), INTENT ( IN ) :: ktstep integer ( kind = irg ), INTENT ( OUT ) :: numk type ( kvectorlist ), pointer :: ktmp , ktail integer :: istat , imin , imax , jmin , jmax , ijmax , i , j , ic , jc , ki real :: kr ( 3 ), glen , delta , kstar ( 3 ), kt ( 3 ), gan ( 3 ), gperp ( 3 ), ktlen , dkt ! compute geometrical factors glen = CalcLength ( cell , float ( ga ), 'r' ) ! length of ga gan = ga / glen ! normalized ga delta = ktrad * glen / float ( ktstep ) ! grid step size in nm-1 dkt = ktrad / float ( ktstep ) call TransSpace ( cell , float ( k ), kstar , 'd' , 'r' ) ! transform incident direction to reciprocal space call CalcCross ( cell , float ( ga ), kstar , gperp , 'r' , 'r' , 0 ) ! compute g_perp = ga x k call NormVec ( cell , gperp , 'r' ) ! normalize g_perp call NormVec ( cell , kstar , 'r' ) ! normalize reciprocal beam vector ! deal only with the incident beam (parallel illumination) if ( ktstep . eq . 0 ) then if (. not . associated ( khead )) then ! allocate the head and ktail of the linked list allocate ( khead , stat = istat ) ! allocate new value if ( istat . ne . 0 ) call FatalError ( 'Calckvectorcone: unable to allocate head pointer' , ' ' ) ktail => khead ! ktail points to new value nullify ( ktail % next ) ! nullify next in new value numk = 1 ! keep track of number of k-vectors so far ! this should be the center vector of the illumination cone !!! kt = - glen * ( ktxy ( 1 ) * gan + ktxy ( 2 ) * gperp ) ktail % kt = kt ! store tangential component of k ktlen = glen ** 2 * ( ktxy ( 1 ) ** 2 + ktxy ( 2 ) ** 2 ) ! squared length of tangential component kr = kt + sqrt ( 1.0 / cell % mLambda ** 2 - ktlen ) * kstar ! complete wave vector ktail % k = kr ! store in pointer list ktail % kn = CalcDot ( cell , ktail % k , dble ( kstar ), 'r' ) ! normal component of k end if else ! next, put the center of the cone in units of (i,j) (original ECP \"screen\" coordinates) ic = int ( ktxy ( 1 ) * glen / delta ) jc = int ( ktxy ( 2 ) * glen / delta ) ki = ktstep if (. not . associated ( khead )) then ! allocate the head and ktail of the linked list allocate ( khead , stat = istat ) ! allocate new value if ( istat . ne . 0 ) call FatalError ( 'Calckvectorcone: unable to allocate head pointer' , ' ' ) ktail => khead ! ktail points to new value nullify ( ktail % next ) ! nullify next in new value numk = 1 ! keep track of number of k-vectors so far ! this should be the center vector of the illumination cone !!! ktail % i = ic ! i-index of beam ktail % j = jc ! j-index of beam kt = - float ( ktail % i ) * delta * gan - float ( ktail % j ) * delta * gperp ! tangential component of k ktail % kt = kt ! store tangential component of k ktlen = delta ** 2 * ( ktail % i ** 2 + ktail % j ** 2 ) ! squared length of tangential component kr = kt + sqrt ( 1.0 / cell % mLambda ** 2 - ktlen ) * kstar ! complete wave vector ktail % k = kr ! store in pointer list ktail % kn = CalcDot ( cell , ktail % k , dble ( kstar ), 'r' ) ! normal component of k else call FatalError ( 'Calckvectorcone: pointer head already allocated' , ' ' ) end if ! the following lines are quite different if symmetry is taken into account; ! check the MBsym.f90 program to determine how that can be done. imin = - ki ; imax = ki ; jmin = - ki ; jmax = ki ; ijmax = ki ** 2 ! now do the real work do i = imin , imax do j = jmin , jmax if (. not .(( i . eq . 0 ). and .( j . eq . 0 ))) then ! the point (0,0) has already been taken care of if (( i ** 2 + j ** 2 ). le . ijmax ) then ! is point inside the incident cone ? allocate ( ktail % next , stat = istat ) ! allocate new value if ( istat . ne . 0 ) call FatalError ( 'Calckvectorcone: unable to allocate pointer' , ' ' ) ktail => ktail % next ! ktail points to new value nullify ( ktail % next ) ! nullify next in new value numk = numk + 1 ! keep track of number of k-vectors so far ktail % i = ic + i ! i-index of beam ktail % j = jc + j ! j-index of beam kt = - float ( ktail % i ) * delta * gan - float ( ktail % j ) * delta * gperp ! tangential component of k ktail % kt = kt ! store tangential component of k ktlen = delta ** 2 * ( ktail % i ** 2 + ktail % j ** 2 ) ! squared length of tangential component kr = kt + sqrt ( 1.0 / cell % mLambda ** 2 - ktlen ) * kstar ! complete wave vector ktail % k = kr ! store in pointer list ktail % kn = CalcDot ( cell , ktail % k , dble ( kstar ), 'r' ) ! normal component of k end if end if end do end do end if end subroutine Calckvectorcone","tags":"","loc":"proc/calckvectorcone.html","title":"Calckvectorcone – Fortran Program"},{"text":"public recursive subroutine Calckvectortrace(cell, khead, k, ga, ktxy, ktxy2, ktrad, ktstep, numk) Uses: io error diffraction crystal kvectors proc~~calckvectortrace~~UsesGraph proc~calckvectortrace Calckvectortrace io io io->proc~calckvectortrace kvectors kvectors kvectors->proc~calckvectortrace crystal crystal crystal->proc~calckvectortrace diffraction diffraction diffraction->proc~calckvectortrace error error error->proc~calckvectortrace Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief compute a set of incident beam directions for line scan ECCI mode\n @param cell unit cell pointer\n @param khead head of k-vector list\n @param k incident wave vector (zone axis)\n @param ga principal g vector\n @param ktxy tangential components of trace start point\n @param ktxy2 tangential components of trace end point\n @param ktrad cone opening angle\n @param ktstep number of steps along cone radius\n @param numk resulting number of incident beam directions\n @date 12/08/13 MDG 1.0 original\n @date 12/01/15 MDG 1.1 simplifcation of input variables Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(kvectorlist), pointer :: khead integer(kind=irg), intent(in) :: k (3) integer(kind=irg), intent(in) :: ga (3) real(kind=sgl), intent(in) :: ktxy (2) real(kind=sgl), intent(in) :: ktxy2 (2) real(kind=sgl), intent(in) :: ktrad integer(kind=irg), intent(in) :: ktstep integer(kind=irg), intent(out) :: numk Calls proc~~calckvectortrace~~CallsGraph proc~calckvectortrace Calckvectortrace float float proc~calckvectortrace->float normvec normvec proc~calckvectortrace->normvec calcdot calcdot proc~calckvectortrace->calcdot calclength calclength proc~calckvectortrace->calclength transspace transspace proc~calckvectortrace->transspace calccross calccross proc~calckvectortrace->calccross fatalerror fatalerror proc~calckvectortrace->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code Calckvectortrace Source Code recursive subroutine Calckvectortrace ( cell , khead , k , ga , ktxy , ktxy2 , ktrad , ktstep , numk ) !DEC$ ATTRIBUTES DLLEXPORT :: Calckvectortrace use io use error use diffraction use crystal use kvectors IMPLICIT NONE type ( unitcell ), pointer :: cell type ( kvectorlist ), pointer :: khead integer ( kind = irg ), INTENT ( IN ) :: k ( 3 ) integer ( kind = irg ), INTENT ( IN ) :: ga ( 3 ) real ( kind = sgl ), INTENT ( IN ) :: ktxy ( 2 ) real ( kind = sgl ), INTENT ( IN ) :: ktxy2 ( 2 ) real ( kind = sgl ), INTENT ( IN ) :: ktrad integer ( kind = irg ), INTENT ( IN ) :: ktstep integer ( kind = irg ), INTENT ( OUT ) :: numk type ( kvectorlist ), pointer :: ktail integer :: istat , j real :: kr ( 3 ), glen , delta , kstar ( 3 ), kt ( 3 ), gan ( 3 ), gperp ( 3 ), ktlen , dktx , dkty ! compute geometrical factors glen = CalcLength ( cell , float ( ga ), 'r' ) ! length of ga gan = ga / glen ! normalized ga delta = 2.0 * ktrad * glen / float ( 2 * ktstep + 1 ) ! grid step size in nm-1 call TransSpace ( cell , float ( k ), kstar , 'd' , 'r' ) ! transform incident direction to reciprocal space call CalcCross ( cell , float ( ga ), kstar , gperp , 'r' , 'r' , 0 ) ! compute g_perp = ga x k call NormVec ( cell , gperp , 'r' ) ! normalize g_perp call NormVec ( cell , kstar , 'r' ) ! normalize reciprocal beam vector j = 0 if (. not . associated ( khead )) then ! allocate the head and ktail of the linked list allocate ( khead , stat = istat ) ! allocate new value if ( istat . ne . 0 ) call FatalError ( 'Calckvectortrace: unable to allocate head pointer' , ' ' ) ktail => khead ! ktail points to new value nullify ( ktail % next ) ! nullify next in new value numk = 1 ! keep track of number of k-vectors so far ! this should be the starting point of the line trace !   kt = - glen * ( ktxy(1)*gan + ktxy(2) * gperp) kt = - glen * ( ktxy ( 1 ) * gan - ktxy ( 2 ) * gperp ) ktail % kt = kt ! store tangential component of k ktlen = glen ** 2 * ( ktxy ( 1 ) ** 2 + ktxy ( 2 ) ** 2 ) ! squared length of tangential component kr = kt + sqrt ( 1.0 / cell % mLambda ** 2 - ktlen ) * kstar ! complete wave vector ktail % k = kr ! store in pointer list ktail % kn = CalcDot ( cell , ktail % k , dble ( kstar ), 'r' ) ! normal component of k end if dktx = ( ktxy2 ( 1 ) - ktxy ( 1 )) / float ( ktstep - 1 ) dkty = ( ktxy2 ( 2 ) - ktxy ( 2 )) / float ( ktstep - 1 ) do j = 1 , ktstep - 1 allocate ( ktail % next , stat = istat ) ! allocate new value if ( istat . ne . 0 ) call FatalError ( 'Calckvectortrace: unable to allocate pointer' , ' ' ) ktail => ktail % next ! ktail points to new value nullify ( ktail % next ) ! nullify next in new value numk = numk + 1 ! keep track of number of k-vectors so far !     kt = - glen * ( (ktxy(1)+float(j)*dktx)*gan + (ktxy(2)+float(j)*dkty) * gperp) ! tangential component of k kt = - glen * ( ( ktxy ( 1 ) + float ( j ) * dktx ) * gan - ( ktxy ( 2 ) + float ( j ) * dkty ) * gperp ) ! tangential component of k ktail % kt = kt ! store tangential component of k ktlen = delta ** 2 * ( ktail % i ** 2 + ktail % j ** 2 ) ! squared length of tangential component kr = kt + sqrt ( 1.0 / cell % mLambda ** 2 - ktlen ) * kstar ! complete wave vector ktail % k = kr ! store in pointer list ktail % kn = CalcDot ( cell , ktail % k , dble ( kstar ), 'r' ) ! normal component of k end do end subroutine Calckvectortrace","tags":"","loc":"proc/calckvectortrace.html","title":"Calckvectortrace – Fortran Program"},{"text":"public recursive subroutine ECCICalcSgh(cell, nn, Sgh, nat) Uses: local crystal gvectors constants symmetry proc~~eccicalcsgh~~UsesGraph proc~eccicalcsgh ECCICalcSgh module~constants constants module~constants->proc~eccicalcsgh crystal crystal crystal->proc~eccicalcsgh symmetry symmetry symmetry->proc~eccicalcsgh local local local->proc~eccicalcsgh local->module~constants gvectors gvectors gvectors->proc~eccicalcsgh Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief compute structure factor-like array for ECCI and ECP simulations\n @param nn dimension of array\n @param Sgh output array\n @param nat normalization array\n @date 03/05/14  MDG 1.0 original (used to be in-line in ECP and ECCI programs)\n @date 03/11/14  MDG 1.1 converted to diagonal Sgh array only\n @date 10/22/14  MDG 1.2 corrected definition of Sgh and simplified loops; resolves issue #3 for each special position we need to compute its contribution to the Sgh array get Zn-squared for this special position, and include the site occupation parameter as well loop over all contributing reflections\n ir is the row index ic is the column index We'll assume isotropic Debye-Waller factors for now ...\n That means we need the square of the length of s=  kk&#94;2/4 Debye-Waller exponential times Z&#94;2 here is where we should insert the proper weight factor, Z&#94;2 exp[-M_{h-g}]\n and also the detector geometry...   For now, we do nothing with the detector\n geometry; the Rossouw et al 1994 paper lists a factor A that does not depend\n on anything in particular, so we assume it is 1. get the argument of the complex exponential multiply with the prefactor and add Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell integer(kind=irg), intent(in) :: nn complex(kind=dbl), intent(inout) :: Sgh (nn) integer(kind=irg), intent(inout) :: nat (100) Calls proc~~eccicalcsgh~~CallsGraph proc~eccicalcsgh ECCICalcSgh float float proc~eccicalcsgh->float calcorbit calcorbit proc~eccicalcsgh->calcorbit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code ECCICalcSgh Source Code recursive subroutine ECCICalcSgh ( cell , nn , Sgh , nat ) !DEC$ ATTRIBUTES DLLEXPORT :: ECCICalcSgh use local use crystal use gvectors use constants use symmetry IMPLICIT NONE type ( unitcell ), pointer :: cell integer ( kind = irg ), INTENT ( IN ) :: nn ! corrected on 10/22/14 in response to issue #3 of release 2.0 raised by jfikar ! Sgh array changed to one dimensional vector instead of 2D array complex ( kind = dbl ), INTENT ( INOUT ) :: Sgh ( nn ) integer ( kind = irg ), INTENT ( INOUT ) :: nat ( 100 ) integer ( kind = irg ) :: ip , ir , ic , kkk ( 3 ), ikk , n , numset real ( kind = sgl ) :: Znsq , DBWF , kkl complex ( kind = dbl ) :: carg real ( kind = dbl ) :: ctmp ( 192 , 3 ), arg , tpi tpi = 2.D0 * cPi Sgh = dcmplx ( 0.D0 , 0.D0 ) numset = cell % ATOM_ntype ! number of special positions in the unit cell ! comment: this can likely be further simplified and we'll take a closer look at this for ! the next release. ! for each special position we need to compute its contribution to the Sgh vector do ip = 1 , numset call CalcOrbit ( cell , ip , n , ctmp ) nat ( ip ) = n ! get Zn-squared for this special position, and include the site occupation parameter as well Znsq = float ( cell % ATOM_type ( ip )) ** 2 * cell % ATOM_pos ( ip , 4 ) ! loop over all contributing reflections ! ir is the row index ! we don't need to actually go through this list, so the lines are commented out !   rltmpa => reflist%next    ! point to the front of the list !   do ir=1,nn  ! we only need a single summation loop since Sgh is a column vector ! Debye-Waller exponential times Z&#94;2 Sgh = Sgh + dcmplx ( n * Znsq , 0.D0 ) !    rltmpa => rltmpa%next  ! move to next row-entry !   end do end do ! this is the older code which I'm leaving here commented [10/22/14] !! for each special position we need to compute its contribution to the Sgh array !  do ip=1,numset !    call CalcOrbit(ip,n,ctmp) !    nat(ip) = n !! get Zn-squared for this special position, and include the site occupation parameter as well !    Znsq = float(cell%ATOM_type(ip))**2 * cell%ATOM_pos(ip,4) !! loop over all contributing reflections !! ir is the row index !    rltmpa => reflist%next    ! point to the front of the list !    do ir=1,nn !! ic is the column index !      rltmpb => reflist%next    ! point to the front of the list !      do ic=1,nn !        kkk = rltmpb%hkl - rltmpa%hkl !! We'll assume isotropic Debye-Waller factors for now ... !! That means we need the square of the length of s=  kk&#94;2/4 !        kkl = 0.25 * CalcLength(float(kkk),'r')**2 !! Debye-Waller exponential times Z&#94;2 !        DBWF = Znsq * exp(-cell%ATOM_pos(ip,5)*kkl) !! here is where we should insert the proper weight factor, Z&#94;2 exp[-M_{h-g}] !! and also the detector geometry...   For now, we do nothing with the detector !! geometry; the Rossouw et al 1994 paper lists a factor A that does not depend !! on anything in particular, so we assume it is 1. !        do ikk=1,n !! get the argument of the complex exponential !          arg = tpi*sum(kkk(1:3)*ctmp(ikk,1:3)) !          carg = dcmplx(dcos(arg),dsin(arg)) !! multiply with the prefactor and add !          Sgh(ir,ic) = Sgh(ir,ic) + carg * dcmplx(DBWF,0.D0) !        end do !        rltmpb => rltmpb%next  ! move to next column-entry !      end do !     rltmpa => rltmpa%next  ! move to next row-entry !   end do !  end do end subroutine ECCICalcSgh","tags":"","loc":"proc/eccicalcsgh.html","title":"ECCICalcSgh – Fortran Program"},{"text":"public recursive function getEBSDPatternsWrapper(argc, argv) bind(c, name='getEBSDPatternsWrapper') Uses: iso_c_binding proc~~getebsdpatternswrapper~~UsesGraph proc~getebsdpatternswrapper getEBSDPatternsWrapper iso_c_binding iso_c_binding iso_c_binding->proc~getebsdpatternswrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief wrapper routine for getEBSDPatterns see example at https://groups.google.com/forum/#!topic/comp.lang.idl-pvwave/Gk0xxVFbW8E\n @param argc number of argument\n @param argv pointers to subroutine parameters\n @date 10/16/15 MDG 1.0 original\n @date 11/02/15 MDG 1.1 simplified parameters\n @date 01/12/16 MDG 1.2 added dummy arguments for progress callback and cancel handling\n @date 01/13/16 MDG 1.3 removed dummy arguments for progress callback and cancel handling\n @date 07/10/16 MDG 1.4 added energy min/max indices Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in), VALUE :: argc type(c_ptr), intent(inout), dimension(argc) :: argv Return Value real(kind=c_float) Calls proc~~getebsdpatternswrapper~~CallsGraph proc~getebsdpatternswrapper getEBSDPatternsWrapper proc~getebsdpatterns getEBSDPatterns proc~getebsdpatternswrapper->proc~getebsdpatterns float float proc~getebsdpatterns->float quat_lp quat_lp proc~getebsdpatterns->quat_lp lambertspheretosquare lambertspheretosquare proc~getebsdpatterns->lambertspheretosquare sngl sngl proc~getebsdpatterns->sngl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getEBSDPatternsWrapper Source Code recursive function getEBSDPatternsWrapper ( argc , argv ) bind ( c , name = 'getEBSDPatternsWrapper' ) !DEC$ ATTRIBUTES DLLEXPORT :: getEBSDPatternsWrapper use , INTRINSIC :: ISO_C_BINDING IMPLICIT NONE INTEGER ( c_size_t ), VALUE , INTENT ( IN ) :: argc type ( c_ptr ), dimension ( argc ), INTENT ( INOUT ) :: argv REAL ( c_float ) :: getEBSDPatternsWrapper ! wrapper function dependent declarations; they are all pointers ! since we pass everything by reference from IDL integer ( c_size_t ) :: nipar , nfpar , nq integer ( c_size_t ), dimension (:), pointer :: ipar real ( c_float ), dimension (:), pointer :: fpar real ( c_float ), dimension (:,:), pointer :: quats real ( c_float ), dimension (:,:,:), pointer :: EBSDpattern , accum_e real ( c_float ), dimension (:,:,:,:), pointer :: mLPNH , mLPSH ! the following line just helps in identifying the correct order of the subroutine arguments... !                             1      2      3           4         5       6     7 !subroutine getEBSDPatterns(ipar, fpar, EBSDpattern, quats, accum_e, mLPNH, mLPSH) ! ! transform the C pointers above to fortran pointers, and use them in the regular function call nipar = 10 nfpar = 10 nq = 4 call c_f_pointer ( argv ( 1 ), ipar ,( / nipar / )) call c_f_pointer ( argv ( 2 ), fpar ,( / nfpar / )) call c_f_pointer ( argv ( 3 ), EBSDpattern ,( / ipar ( 2 ), ipar ( 3 ), ipar ( 8 ) / )) call c_f_pointer ( argv ( 4 ), quats ,( / nq , ipar ( 8 ) / )) call c_f_pointer ( argv ( 5 ), accum_e ,( / ipar ( 4 ), 2 * ipar ( 5 ) + 1 , 2 * ipar ( 5 ) + 1 / )) call c_f_pointer ( argv ( 6 ), mLPNH ,( / 2 * ipar ( 6 ) + 1 , 2 * ipar ( 6 ) + 1 , ipar ( 4 ), ipar ( 7 ) / )) call c_f_pointer ( argv ( 7 ), mLPSH ,( / 2 * ipar ( 6 ) + 1 , 2 * ipar ( 6 ) + 1 , ipar ( 4 ), ipar ( 7 ) / )) call getEBSDPatterns ( ipar , fpar , EBSDpattern , quats , accum_e , mLPNH , mLPSH ) getEBSDPatternsWrapper = 1._c_float end function getEBSDPatternsWrapper","tags":"","loc":"proc/getebsdpatternswrapper.html","title":"getEBSDPatternsWrapper – Fortran Program"},{"text":"public recursive function getECPatternsWrapper(argc, argv) bind(c, name='getECPatternsWrapper') Uses: iso_c_binding proc~~getecpatternswrapper~~UsesGraph proc~getecpatternswrapper getECPatternsWrapper iso_c_binding iso_c_binding iso_c_binding->proc~getecpatternswrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief wrapper routine for SingleECPPattern; based on Marc's routine above see https://groups.google.com/forum/#!topic/comp.lang.idl-pvwave/Gk0xxVFbW8E @param argc number of argument\n @param argv pointers to subroutine parameters\n @date 10/28/15  SS 1.0 original\n @date 11/02/15 MDG 1.1 simplified parameters Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in), VALUE :: argc type(c_ptr), intent(inout), dimension(argc) :: argv Return Value real(kind=c_float) Calls proc~~getecpatternswrapper~~CallsGraph proc~getecpatternswrapper getECPatternsWrapper proc~getecpatterns getECPatterns proc~getecpatternswrapper->proc~getecpatterns sngl sngl proc~getecpatterns->sngl quat_lp quat_lp proc~getecpatterns->quat_lp lambertspheretosquare lambertspheretosquare proc~getecpatterns->lambertspheretosquare float float proc~getecpatterns->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getECPatternsWrapper Source Code recursive function getECPatternsWrapper ( argc , argv ) bind ( c , name = 'getECPatternsWrapper' ) !DEC$ ATTRIBUTES DLLEXPORT :: getECPatternsWrapper use , INTRINSIC :: ISO_C_BINDING IMPLICIT NONE INTEGER ( c_size_t ), VALUE , INTENT ( IN ) :: argc type ( c_ptr ), dimension ( argc ), INTENT ( INOUT ) :: argv REAL ( c_float ) :: getECPatternsWrapper ! wrapper function dependent declarations; they are all pointers ! since we pass everything by reference from IDL integer ( c_size_t ) :: nipar , nfpar , nq integer ( c_size_t ), dimension (:), pointer :: ipar real ( c_float ), dimension (:), pointer :: fpar real ( c_float ), dimension (:,:,:), pointer :: accum_e , mLPNH , mLPSH , ECPattern real ( c_float ), dimension (:,:), pointer :: quats ! the following line just helps in identifying the correct order of the subroutine arguments... !                             1      2     3       4       5       6       7 !subroutine getECPatterns(ipar, fpar, ECPattern, quats, accum_e, mLPNH, mLPSH) ! ! transform the C pointers above to fortran pointers, and use them in the regular function call nipar = 8 nfpar = 8 nq = 4 call c_f_pointer ( argv ( 1 ), ipar ,( / nipar / )) call c_f_pointer ( argv ( 2 ), fpar ,( / nfpar / )) call c_f_pointer ( argv ( 3 ), ECpattern ,( / ipar ( 2 ), ipar ( 3 ), ipar ( 8 ) / )) call c_f_pointer ( argv ( 4 ), quats ,( / nq , ipar ( 8 ) / )) call c_f_pointer ( argv ( 5 ), accum_e ,( / ipar ( 4 ), 2 * ipar ( 5 ) + 1 , 2 * ipar ( 5 ) + 1 / )) call c_f_pointer ( argv ( 6 ), mLPNH ,( / 2 * ipar ( 7 ) + 1 , 2 * ipar ( 7 ) + 1 , ipar ( 6 ) / )) call c_f_pointer ( argv ( 7 ), mLPSH ,( / 2 * ipar ( 7 ) + 1 , 2 * ipar ( 7 ) + 1 , ipar ( 6 ) / )) call getECPatterns ( ipar , fpar , ECpattern , quats , accum_e , mLPNH , mLPSH ) getECPatternsWrapper = 1._c_float end function getECPatternsWrapper","tags":"","loc":"proc/getecpatternswrapper.html","title":"getECPatternsWrapper – Fortran Program"},{"text":"public recursive function getKosselPatternsWrapper(argc, argv) bind(c, name='getKosselPatternsWrapper') Uses: iso_c_binding proc~~getkosselpatternswrapper~~UsesGraph proc~getkosselpatternswrapper getKosselPatternsWrapper iso_c_binding iso_c_binding iso_c_binding->proc~getkosselpatternswrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief wrapper routine for SingleKosselPattern; nearly identical to ECP case see https://groups.google.com/forum/#!topic/comp.lang.idl-pvwave/Gk0xxVFbW8E\n @param argc number of argument\n @param argv pointers to subroutine parameters\n @date 11/09/15 MDG 1.0 first version Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in), VALUE :: argc type(c_ptr), intent(inout), dimension(argc) :: argv Return Value real(kind=c_float) Calls proc~~getkosselpatternswrapper~~CallsGraph proc~getkosselpatternswrapper getKosselPatternsWrapper proc~getkosselpatterns getKosselPatterns proc~getkosselpatternswrapper->proc~getkosselpatterns float float proc~getkosselpatterns->float lambertspheretosquare lambertspheretosquare proc~getkosselpatterns->lambertspheretosquare quat_lp quat_lp proc~getkosselpatterns->quat_lp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getKosselPatternsWrapper Source Code recursive function getKosselPatternsWrapper ( argc , argv ) bind ( c , name = 'getKosselPatternsWrapper' ) !DEC$ ATTRIBUTES DLLEXPORT :: getKosselPatternsWrapper use , INTRINSIC :: ISO_C_BINDING IMPLICIT NONE INTEGER ( c_size_t ), VALUE , INTENT ( IN ) :: argc type ( c_ptr ), dimension ( argc ), INTENT ( INOUT ) :: argv REAL ( c_float ) :: getKosselPatternsWrapper ! wrapper function dependent declarations; they are all pointers ! since we pass everything by reference from IDL integer ( c_size_t ) :: nipar , nfpar , nq integer ( c_size_t ), dimension (:), pointer :: ipar real ( c_float ), dimension (:), pointer :: fpar real ( c_float ), dimension (:,:), pointer :: quats real ( c_float ), dimension (:,:,:), pointer :: KosselPattern , mLPNH , mLPSH ! the following line just helps in identifying the correct order of the subroutine arguments... !                             1      2     3             4       5       6 !subroutine getKosselPatterns(ipar, fpar, KosselPattern, quats, mLPNH, mLPSH) ! ! transform the C pointers above to fortran pointers, and use them in the regular function call nipar = 6 nfpar = 1 nq = 4 call c_f_pointer ( argv ( 1 ), ipar ,( / nipar / )) call c_f_pointer ( argv ( 2 ), fpar ,( / nfpar / )) call c_f_pointer ( argv ( 3 ), Kosselpattern ,( / ipar ( 2 ), ipar ( 2 ), ipar ( 4 ) / )) call c_f_pointer ( argv ( 4 ), quats ,( / nq , ipar ( 4 ) / )) call c_f_pointer ( argv ( 5 ), mLPNH ,( / 2 * ipar ( 3 ) + 1 , 2 * ipar ( 3 ) + 1 , ipar ( 5 ) / )) call c_f_pointer ( argv ( 6 ), mLPSH ,( / 2 * ipar ( 3 ) + 1 , 2 * ipar ( 3 ) + 1 , ipar ( 5 ) / )) call getKosselPatterns ( ipar , fpar , Kosselpattern , quats , mLPNH , mLPSH ) getKosselPatternsWrapper = 1._c_float end function getKosselPatternsWrapper","tags":"","loc":"proc/getkosselpatternswrapper.html","title":"getKosselPatternsWrapper – Fortran Program"},{"text":"public recursive function efitECPWrapper(argc, argv) bind(c, name='efitECPWrapper') Uses: iso_c_binding local proc~~efitecpwrapper~~UsesGraph proc~efitecpwrapper efitECPWrapper iso_c_binding iso_c_binding iso_c_binding->proc~efitecpwrapper local local local->proc~efitecpwrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief wrapper routine for fitting ECP pattern see https://groups.google.com/forum/#!topic/comp.lang.idl-pvwave/Gk0xxVFbW8E @param argc number of argument\n @param argv pointers to subroutine parameters\n @date 12/15/15  SS 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in), VALUE :: argc type(c_ptr), intent(inout), dimension(argc) :: argv Return Value real(kind=c_float) Source Code efitECPWrapper Source Code recursive function efitECPWrapper ( argc , argv ) bind ( c , name = 'efitECPWrapper' ) !DEC$ ATTRIBUTES DLLEXPORT :: efitECPWrapper use , INTRINSIC :: ISO_C_BINDING ! use bobyqa_module use local IMPLICIT NONE INTEGER ( c_size_t ), VALUE , INTENT ( IN ) :: argc type ( c_ptr ), dimension ( argc ), INTENT ( INOUT ) :: argv REAL ( c_float ) :: efitECPWrapper ! wrapper function dependent declarations; they are all pointers ! since we pass everything by reference from IDL integer ( 4 ) :: nipar , nfpar , ninit , n , iprint , maxfun , npt real ( c_double ), dimension (:), pointer :: rhobeg , rhoend integer ( c_size_t ), dimension (:), pointer :: ipar real ( c_float ), dimension (:), pointer :: fpar real ( c_float ), dimension (:), pointer :: initmeanval real ( c_float ), dimension (:), pointer :: expt real ( c_float ), dimension (:,:,:), pointer :: accum_e real ( c_float ), dimension (:,:,:,:), pointer :: mLPNH real ( c_float ), dimension (:,:,:,:), pointer :: mLPSH real ( c_double ), dimension (:), pointer :: X real ( c_double ), dimension (:), pointer :: XL real ( c_double ), dimension (:), pointer :: XU ! the following line just helps in identifying the correct order of the subroutine arguments... ! !subroutine BOBYQA(nipar, nfpar, ninit, ipar, fpar, initmeanval, expt, N, NPT, X, XL, XU, RHOBEG, RHOEND, IPRINT, MAXFUN, ECPCALFUN, ACCUM_E, mLPNH, mLPSH) ! ! transform the C pointers above to fortran pointers, and use them in the regular function call nipar = 9 nfpar = 10 ninit = 6 n = 6 iprint = 2 maxfun = 10000 npt = n + 6 call c_f_pointer ( argv ( 1 ), ipar ,( / nipar / )) call c_f_pointer ( argv ( 2 ), fpar ,( / nfpar / )) call c_f_pointer ( argv ( 4 ), initmeanval ,( / n / )) call c_f_pointer ( argv ( 5 ), expt ,( / ipar ( 2 ) * ipar ( 3 ) / )) call c_f_pointer ( argv ( 6 ), X ,( / n / )) call c_f_pointer ( argv ( 7 ), XL ,( / n / )) call c_f_pointer ( argv ( 8 ), XU ,( / n / )) call c_f_pointer ( argv ( 9 ), RHOBEG ,( / 1 / )) call c_f_pointer ( argv ( 10 ), RHOEND ,( / 1 / )) call c_f_pointer ( argv ( 11 ), accum_e ,( / ipar ( 4 ), 2 * ipar ( 5 ) + 1 , 2 * ipar ( 5 ) + 1 / )) call c_f_pointer ( argv ( 12 ), mLPNH ,( / 2 * ipar ( 6 ) + 1 , 2 * ipar ( 6 ) + 1 , ipar ( 4 ), ipar ( 7 ) / )) call c_f_pointer ( argv ( 13 ), mLPSH ,( / 2 * ipar ( 6 ) + 1 , 2 * ipar ( 6 ) + 1 , ipar ( 4 ), ipar ( 7 ) / )) ! call BOBYQA(NIPAR, NFPAR, NINIT, IPAR, FPAR, INITMEANVAL, EXPT, N, NPT, X, XL, XU, RHOBEG(1), RHOEND(1),& !      IPRINT, MAXFUN, ECPCALFUN, accum_e, mLPNH, mLPSH) efitECPWrapper = 1._c_float end function efitECPWrapper","tags":"","loc":"proc/efitecpwrapper.html","title":"efitECPWrapper – Fortran Program"},{"text":"public recursive function efitEBSDWrapper(argc, argv) bind(c, name='efitEBSDWrapper') Uses: iso_c_binding local proc~~efitebsdwrapper~~UsesGraph proc~efitebsdwrapper efitEBSDWrapper iso_c_binding iso_c_binding iso_c_binding->proc~efitebsdwrapper local local local->proc~efitebsdwrapper Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief wrapper routine for fitting EBSD pattern see https://groups.google.com/forum/#!topic/comp.lang.idl-pvwave/Gk0xxVFbW8E @param argc number of argument\n @param argv pointers to subroutine parameters\n @date 12/15/15  SS 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in), VALUE :: argc type(c_ptr), intent(inout), dimension(argc) :: argv Return Value real(kind=c_float) Source Code efitEBSDWrapper Source Code recursive function efitEBSDWrapper ( argc , argv ) bind ( c , name = 'efitEBSDWrapper' ) !DEC$ ATTRIBUTES DLLEXPORT :: efitEBSDWrapper use , INTRINSIC :: ISO_C_BINDING !use bobyqa_module use local IMPLICIT NONE INTEGER ( c_size_t ), VALUE , INTENT ( IN ) :: argc type ( c_ptr ), dimension ( argc ), INTENT ( INOUT ) :: argv REAL ( c_float ) :: efitEBSDWrapper ! wrapper function dependent declarations; they are all pointers ! since we pass everything by reference from IDL integer ( 4 ) :: nipar , nfpar , ninit , n , iprint , maxfun , npt real ( c_double ), dimension (:), pointer :: rhobeg , rhoend integer ( c_size_t ), dimension (:), pointer :: ipar real ( c_float ), dimension (:), pointer :: fpar real ( c_float ), dimension (:), pointer :: initmeanval real ( c_float ), dimension (:), pointer :: expt real ( c_float ), dimension (:,:,:), pointer :: accum_e real ( c_float ), dimension (:,:,:,:), pointer :: mLPNH real ( c_float ), dimension (:,:,:,:), pointer :: mLPSH real ( c_double ), dimension (:), pointer :: X real ( c_double ), dimension (:), pointer :: XL real ( c_double ), dimension (:), pointer :: XU ! the following line just helps in identifying the correct order of the subroutine arguments... !                                        1      2     3       4           5           6   7   8   9        10 !subroutine BOBYQA(nipar, nfpar, ninit, ipar, fpar, fname, initmeanval, expt, N, NPT, X, XL, XU, RHOBEG, RHOEND, IPRINT, MAXFUN, EBSDCALFUN) ! ! transform the C pointers above to fortran pointers, and use them in the regular function call nipar = 9 nfpar = 11 ninit = 4 n = 7 iprint = 2 maxfun = 10000 npt = n + 6 call c_f_pointer ( argv ( 1 ), ipar ,( / nipar / )) call c_f_pointer ( argv ( 2 ), fpar ,( / nfpar / )) call c_f_pointer ( argv ( 3 ), initmeanval ,( / n / )) call c_f_pointer ( argv ( 4 ), expt ,( / ipar ( 2 ) * ipar ( 3 ) / )) call c_f_pointer ( argv ( 5 ), X ,( / n / )) call c_f_pointer ( argv ( 6 ), XL ,( / n / )) call c_f_pointer ( argv ( 7 ), XU ,( / n / )) call c_f_pointer ( argv ( 8 ), RHOBEG ,( / 1 / )) call c_f_pointer ( argv ( 9 ), RHOEND ,( / 1 / )) call c_f_pointer ( argv ( 10 ), accum_e ,( / ipar ( 4 ), 2 * ipar ( 5 ) + 1 , 2 * ipar ( 5 ) + 1 / )) call c_f_pointer ( argv ( 11 ), mLPNH ,( / 2 * ipar ( 6 ) + 1 , 2 * ipar ( 6 ) + 1 , ipar ( 4 ), ipar ( 7 ) / )) call c_f_pointer ( argv ( 12 ), mLPSH ,( / 2 * ipar ( 6 ) + 1 , 2 * ipar ( 6 ) + 1 , ipar ( 4 ), ipar ( 7 ) / )) ! call BOBYQA(NIPAR, NFPAR, NINIT, IPAR, FPAR, INITMEANVAL, EXPT, N, NPT, X, XL, XU, RHOBEG(1), RHOEND(1),& !      IPRINT, MAXFUN, EBSDCALFUN, accum_e, mLPNH, mLPSH) efitEBSDWrapper = 1._c_float end function efitEBSDWrapper","tags":"","loc":"proc/efitebsdwrapper.html","title":"efitEBSDWrapper – Fortran Program"},{"text":"public recursive subroutine EMsoftCgetEBSDPatterns(ipar, fpar, EBSDpattern, quats, accum_e, mLPNH, mLPSH, cproc, objAddress, cancel) bind(c, name=\"0\") Uses: local constants Lambert quaternions rotations iso_c_binding proc~~emsoftcgetebsdpatterns~~UsesGraph proc~emsoftcgetebsdpatterns EMsoftCgetEBSDPatterns local local local->proc~emsoftcgetebsdpatterns module~constants constants local->module~constants iso_c_binding iso_c_binding iso_c_binding->proc~emsoftcgetebsdpatterns quaternions quaternions quaternions->proc~emsoftcgetebsdpatterns Lambert Lambert Lambert->proc~emsoftcgetebsdpatterns rotations rotations rotations->proc~emsoftcgetebsdpatterns module~constants->proc~emsoftcgetebsdpatterns Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief This subroutine can be called by a C/C++ program as a standalone function to compute EBSD patterns\n @details This subroutine provides a method to compute a series of EBSD patterns and\n can be called from an external C/C++ program; the routine provides a callback mechanism to\n update the calling program about computational progress, as well as a cancel option.\n The routine is intended to be called form a C/C++ program, e.g., DREAM.3D.  This routine is a simplified version\n of the core of the EMEBSD program. @param ipar array with integer input parameters\n @param fpar array with float input parameters\n @param EBSDpattern output array\n @param quats quaternion input array\n @param accum_e array with Monte Carlo histogram\n @param mLPNH Northern hemisphere master pattern\n @param mLPSH Southern hemisphere master pattern\n @param cproc pointer to a C-function for the callback process\n @param objAddress unique integer identifying the calling class in DREAM.3D\n @param cancel character defined by DREAM.3D; when not equal to NULL (i.e., char(0)), the computation should be halted\n @date 10/16/15 MDG 1.0 original\n @date 11/02/15 MDG 1.1 simplification of the input variables\n @date 11/04/15 MDG 1.2 added array of quaternions as input parameter; used complete mLPNH/SH arrays with local sum\n @date 01/12/16 MDG 1.3 added arguments and functionality for interface with DREAM.3D and other calling programs\n @date 01/13/16 MDG 2.0 forked from original SingleEBSDPattern routine; SAVE atrribute removed; ipar redefined (ipar(1) removed)\n @date 04/28/16 MDG 2.1 adjusted ipar and fpar components to new convention\n @date 06/12/16 MDG 2.2 correction for effective pixel area with respect to equal-area Lambert projection\n @date 07/01/16 MDG 2.3 correction of array subscripts in rgx/y/z arrays.\n @date 12/05/16 MDG 2.4 added option to pass in Euler angles instead of quaternions; quats array dimensions are unchanged Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in) :: ipar (nipar) real(kind=sgl), intent(in) :: fpar (nfpar) real(kind=sgl), intent(out) :: EBSDpattern (ipar(23),ipar(24),ipar(21)) real(kind=sgl), intent(in) :: quats (nq,ipar(21)) integer(kind=c_int32_t), intent(in) :: accum_e (ipar(12),-ipar(1):ipar(1),-ipar(1):ipar(1)) real(kind=sgl), intent(in) :: mLPNH (-ipar(17):ipar(17),-ipar(17):ipar(17),ipar(12),ipar(9)) real(kind=sgl), intent(in) :: mLPSH (-ipar(17):ipar(17),-ipar(17):ipar(17),ipar(12),ipar(9)) type(C_FUNPTR), intent(in), VALUE :: cproc integer(kind=c_size_t), intent(in), VALUE :: objAddress character(len=1), intent(in) :: cancel Calls proc~~emsoftcgetebsdpatterns~~CallsGraph proc~emsoftcgetebsdpatterns EMsoftCgetEBSDPatterns eu2qu eu2qu proc~emsoftcgetebsdpatterns->eu2qu float float proc~emsoftcgetebsdpatterns->float quat_lp quat_lp proc~emsoftcgetebsdpatterns->quat_lp lambertspheretosquare lambertspheretosquare proc~emsoftcgetebsdpatterns->lambertspheretosquare sngl sngl proc~emsoftcgetebsdpatterns->sngl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code EMsoftCgetEBSDPatterns Source Code recursive subroutine EMsoftCgetEBSDPatterns ( ipar , fpar , EBSDpattern , quats , accum_e , mLPNH , mLPSH , cproc , objAddress , cancel ) & bind ( c , name = 'EMsoftCgetEBSDPatterns' ) ! this routine is callable from a C/C++ program !DEC$ ATTRIBUTES DLLEXPORT :: EMsoftCgetEBSDPatterns ! the input parameters are all part of a ipar and fpar input arrays instead of the usual namelist structure to ! make this routine callable by external programs, such as DREAM.3D ! The following is the mapping for the ipar and fpar array components used in this routine: ! ! ipar(1)  = mcnsx ! ipar(9)  = numset ! ipar(12) = detnumEbins ! ipar(17) = mpnpx ! ipar(19) = detnumsx ! ipar(20) = detnumsy ! ipar(21) = numquats ! ipar(22) = binning ! ipar(23) = binned x-dimension ! ipar(24) = binned y-dimension ! ipar(25) = anglemode ! fpar(1)  = enl%MCsig ! fpar(2)  = enl%omega ! fpar(15) = enl%xpc ! fpar(16) = enl%ypc ! fpar(17) = enl%delta ! fpar(18) = enl%thetac ! fpar(19) = enl%L ! fpar(20) = enl%beamcurrent ! fpar(21) = enl%dwelltime ! fpar(22) = gammavalue use local use constants use Lambert use quaternions use rotations use , INTRINSIC :: ISO_C_BINDING IMPLICIT NONE integer ( c_int32_t ), PARAMETER :: nipar = 40 integer ( c_int32_t ), PARAMETER :: nfpar = 40 integer ( c_int32_t ), INTENT ( IN ) :: ipar ( nipar ) real ( kind = sgl ), INTENT ( IN ) :: fpar ( nfpar ) integer ( c_int32_t ), PARAMETER :: nq = 4 real ( kind = sgl ), INTENT ( IN ) :: quats ( nq , ipar ( 21 )) integer ( c_int32_t ), INTENT ( IN ) :: accum_e ( ipar ( 12 ), - ipar ( 1 ): ipar ( 1 ), - ipar ( 1 ): ipar ( 1 )) real ( kind = sgl ), INTENT ( IN ) :: mLPNH ( - ipar ( 17 ): ipar ( 17 ), - ipar ( 17 ): ipar ( 17 ), ipar ( 12 ), ipar ( 9 )) real ( kind = sgl ), INTENT ( IN ) :: mLPSH ( - ipar ( 17 ): ipar ( 17 ), - ipar ( 17 ): ipar ( 17 ), ipar ( 12 ), ipar ( 9 )) real ( kind = sgl ), INTENT ( OUT ) :: EBSDpattern ( ipar ( 23 ), ipar ( 24 ), ipar ( 21 )) TYPE ( C_FUNPTR ), INTENT ( IN ), VALUE :: cproc integer ( c_size_t ), INTENT ( IN ), VALUE :: objAddress character ( len = 1 ), INTENT ( IN ) :: cancel ! various variables and arrays real ( kind = sgl ) :: fullsizepattern ( ipar ( 19 ), ipar ( 20 )), binned ( ipar ( 23 ), ipar ( 24 )) real ( kind = irg ), allocatable :: accum_e_detector (:,:,:) real ( kind = sgl ), allocatable :: rgx (:,:), rgy (:,:), rgz (:,:) real ( kind = sgl ), allocatable :: mLPNHsum (:,:,:), mLPSHsum (:,:,:) real ( kind = sgl ), save :: prefactor real ( kind = sgl ), allocatable :: scin_x (:), scin_y (:) ! scintillator coordinate arrays [microns] real ( kind = sgl ), parameter :: dtor = 0.0174533 ! convert from degrees to radians real ( kind = sgl ) :: alp , ca , sa , cw , sw , quat ( 4 ) real ( kind = sgl ) :: L2 , Ls , Lc ! distances integer ( kind = irg ) :: nix , niy , binx , biny , nixp , niyp , i , j , Emin , Emax , istat , k , ip , dn , cn , & ii , jj , binfac , ipx , ipy ! various parameters real ( kind = sgl ) :: dc ( 3 ), scl , alpha , theta , gam , pcvec ( 3 ), dp , calpha ! direction cosine array real ( kind = sgl ) :: sx , dx , dxm , dy , dym , rhos , x , bindx ! various parameters real ( kind = sgl ) :: ixy ( 2 ) real ( kind = dbl ), parameter :: nAmpere = 6.241D+18 PROCEDURE ( ProgressCallBack ), POINTER :: proc ! link the proc procedure to the cproc argument CALL C_F_PROCPOINTER ( cproc , proc ) ! binned pattern dimensions binx = ipar ( 23 ) biny = ipar ( 24 ) binfac = 2 ** ipar ( 22 ) bindx = 1.0 / float ( binfac ) ** 2 !==================================== ! ------ generate the detector rgx, rgy, rgz arrays (and a few others) !==================================== if ( allocated ( mLPNHsum )) deallocate ( mLPNHsum ) if ( allocated ( mLPSHsum )) deallocate ( mLPSHsum ) allocate ( mLPNHsum ( - ipar ( 17 ): ipar ( 17 ), - ipar ( 17 ): ipar ( 17 ), ipar ( 12 ))) allocate ( mLPSHsum ( - ipar ( 17 ): ipar ( 17 ), - ipar ( 17 ): ipar ( 17 ), ipar ( 12 ))) mLPNHsum = sum ( mLPNH , 4 ) mLPSHsum = sum ( mLPSH , 4 ) allocate ( scin_x ( ipar ( 19 )), scin_y ( ipar ( 20 )), stat = istat ) scin_x = - ( fpar ( 15 ) - ( 1.0 - float ( ipar ( 19 )) ) * 0.5 - ( / ( i - 1 , i = 1 , ipar ( 19 )) / ) ) * fpar ( 17 ) scin_y = ( fpar ( 16 ) - ( 1.0 - float ( ipar ( 20 )) ) * 0.5 - ( / ( i - 1 , i = 1 , ipar ( 20 )) / ) ) * fpar ( 17 ) ! auxiliary angle to rotate between reference frames alp = 0.5 * cPi - ( fpar ( 1 ) - fpar ( 18 )) * dtor ca = cos ( alp ) sa = sin ( alp ) cw = cos ( fpar ( 2 ) * dtor ) sw = sin ( fpar ( 2 ) * dtor ) ! compute auxilliary interpolation arrays if ( allocated ( rgx )) deallocate ( rgx , rgy , rgz ) allocate ( rgx ( ipar ( 19 ), ipar ( 20 )), rgy ( ipar ( 19 ), ipar ( 20 )), rgz ( ipar ( 19 ), ipar ( 20 ))) L2 = fpar ( 19 ) * fpar ( 19 ) do j = 1 , ipar ( 19 ) sx = L2 + scin_x ( j ) * scin_x ( j ) Ls = - sw * scin_x ( j ) + fpar ( 19 ) * cw Lc = cw * scin_x ( j ) + fpar ( 19 ) * sw do i = 1 , ipar ( 20 ) !   rhos = 1.0/sqrt(sx + scin_y(i)**2) rgx ( j , i ) = ( scin_y ( i ) * ca + sa * Ls ) ! * rhos rgy ( j , i ) = Lc ! * rhos rgz ( j , i ) = ( - sa * scin_y ( i ) + ca * Ls ) ! * rhos ! make sure that these vectors are normalized ! x = sqrt ( rgx ( j , i ) ** 2 + rgy ( j , i ) ** 2 + rgz ( j , i ) ** 2 ) rgx ( j , i ) = rgx ( j , i ) / x rgy ( j , i ) = rgy ( j , i ) / x rgz ( j , i ) = rgz ( j , i ) / x end do end do ! remove the auxiliary arrays scin_x and scin_y deallocate ( scin_x , scin_y ) !==================================== ! ------ create the equivalent detector energy array !==================================== ! from the Monte Carlo energy data, we need to extract the relevant ! entries for the detector geometry defined above. ! determine the scale factor for the Lambert interpolation; the square has ! an edge length of 2 x sqrt(pi/2) scl = float ( ipar ( 1 )) ! energy summation will go over all energy bins Emin = 1 Emax = ipar ( 12 ) if ( allocated ( accum_e_detector )) deallocate ( accum_e_detector ) allocate ( accum_e_detector ( ipar ( 12 ), ipar ( 19 ), ipar ( 20 ))) ! correction of change in effective pixel area compared to equal-area Lambert projection alpha = atan ( fpar ( 17 ) / fpar ( 19 ) / sqrt ( sngl ( cPi ))) ipx = ipar ( 19 ) / 2 + nint ( fpar ( 15 )) ipy = ipar ( 20 ) / 2 + nint ( fpar ( 16 )) if ( ipx . gt . ipar ( 19 )) ipx = ipar ( 19 ) if ( ipx . lt . 1 ) ipx = 1 if ( ipy . gt . ipar ( 20 )) ipy = ipar ( 20 ) if ( ipy . lt . 1 ) ipy = 1 pcvec = ( / rgx ( ipx , ipy ), rgy ( ipx , ipy ), rgz ( ipx , ipy ) / ) calpha = cos ( alpha ) do i = 1 , ipar ( 19 ) do j = 1 , ipar ( 20 ) ! do the coordinate transformation for this detector pixel dc = ( / rgx ( i , j ), rgy ( i , j ), rgz ( i , j ) / ) ! make sure the third one is positive; if not, switch all if ( dc ( 3 ). lt . 0.0 ) dc = - dc ! convert these direction cosines to coordinates in the Rosca-Lambert projection ixy = scl * LambertSphereToSquare ( dc , istat ) x = ixy ( 1 ) ixy ( 1 ) = ixy ( 2 ) ixy ( 2 ) = - x ! four-point interpolation (bi-quadratic) nix = int ( ipar ( 1 ) + ixy ( 1 )) - ipar ( 1 ) niy = int ( ipar ( 1 ) + ixy ( 2 )) - ipar ( 1 ) dx = ixy ( 1 ) - nix dy = ixy ( 2 ) - niy dxm = 1.0 - dx dym = 1.0 - dy ! do the area correction for this detector pixel dp = dot_product ( pcvec , dc ) if (( i . eq . ipx ). and .( j . eq . ipy )) then gam = 0.25 else theta = calpha * calpha + dp * dp - 1.0 gam = theta ** 1.5 / ( calpha ** 3 ) * 0.25 end if ! interpolate the intensity do k = Emin , Emax accum_e_detector ( k , i , j ) = gam * ( accum_e ( k , nix , niy ) * dxm * dym + & accum_e ( k , nix + 1 , niy ) * dx * dym + & accum_e ( k , nix , niy + 1 ) * dxm * dy + & accum_e ( k , nix + 1 , niy + 1 ) * dx * dy ) end do end do end do prefactor = 0.25D0 * nAmpere * fpar ( 20 ) * fpar ( 21 ) * 1.0D-15 / sum ( accum_e_detector ) accum_e_detector = accum_e_detector * prefactor ! from here on, we simply compute the EBSD patterns by interpolation, using the above arrays ! no intensity scaling or anything else...other than multiplication by pre-factor ! intensity scaling is left to the user of the calling program. ! define some parameters and initialize EBSDpattern scl = dble ( ipar ( 17 )) EBSDpattern = 0.0 fullsizepattern = 0.0 dn = nint ( float ( ipar ( 21 )) * 0.01 ) cn = dn ! here is the main loop over all quaternions quatloop : do ip = 1 , ipar ( 21 ) binned = 0.0 fullsizepattern = 0.0 if ( ipar ( 25 ). eq . 0 ) then quat = quats ( 1 : 4 , ip ) else quat = eu2qu ( quats ( 1 : 3 , ip )) ! this assumes that the input Euler angles are in radians end if do i = 1 , ipar ( 19 ) do j = 1 , ipar ( 20 ) ! do the active coordinate transformation for this euler angle dc = quat_Lp ( quat , ( / rgx ( i , j ), rgy ( i , j ), rgz ( i , j ) / ) ) ! normalize dc dc = dc / sqrt ( sum ( dc * dc )) ! convert these direction cosines to coordinates in the Rosca-Lambert projection (always square projection !!!) ixy = scl * LambertSphereToSquare ( dc , istat ) if ( istat . eq . 0 ) then ! four-point interpolation (bi-quadratic) nix = int ( ipar ( 17 ) + ixy ( 1 )) - ipar ( 17 ) niy = int ( ipar ( 17 ) + ixy ( 2 )) - ipar ( 17 ) nixp = nix + 1 niyp = niy + 1 if ( nixp . gt . ipar ( 17 )) nixp = nix if ( niyp . gt . ipar ( 17 )) niyp = niy if ( nix . lt . - ipar ( 17 )) nix = nixp if ( niy . lt . - ipar ( 17 )) niy = niyp dx = ixy ( 1 ) - nix dy = ixy ( 2 ) - niy dxm = 1.0 - dx dym = 1.0 - dy if ( dc ( 3 ). gt . 0.0 ) then ! we're in the Northern hemisphere do k = 1 , ipar ( 12 ) fullsizepattern ( i , j ) = fullsizepattern ( i , j ) + accum_e_detector ( k , i , j ) * ( mLPNHsum ( nix , niy , k ) * dxm * dym + & mLPNHsum ( nixp , niy , k ) * dx * dym + mLPNHsum ( nix , niyp , k ) * dxm * dy + & mLPNHsum ( nixp , niyp , k ) * dx * dy ) end do else ! we're in the Southern hemisphere do k = 1 , ipar ( 12 ) fullsizepattern ( i , j ) = fullsizepattern ( i , j ) + accum_e_detector ( k , i , j ) * ( mLPSHsum ( nix , niy , k ) * dxm * dym + & mLPSHsum ( nixp , niy , k ) * dx * dym + mLPSHsum ( nix , niyp , k ) * dxm * dy + & mLPSHsum ( nixp , niyp , k ) * dx * dy ) end do end if end if end do end do ! bin the pattern if necessary and apply the gamma scaling factor if ( binx . ne . ipar ( 19 )) then do ii = 1 , ipar ( 19 ), binfac do jj = 1 , ipar ( 20 ), binfac binned ( ii / binfac + 1 , jj / binfac + 1 ) = & sum ( fullsizepattern ( ii : ii + binfac - 1 , jj : jj + binfac - 1 )) end do end do EBSDpattern ( 1 : binx , 1 : biny , ip ) = ( binned ( 1 : binx , 1 : biny ) * bindx ) ** fpar ( 22 ) else EBSDpattern ( 1 : binx , 1 : biny , ip ) = ( fullsizepattern ( 1 : binx , 1 : biny )) ** fpar ( 22 ) end if ! has the cancel flag been set by the calling program ? if ( cancel . ne . char ( 0 )) EXIT quatloop ! update the progress counter and report it to the calling program via the proc callback routine if ( objAddress . ne . 0 ) then if ( ip . ge . cn ) then cn = cn + dn call proc ( objAddress , ip ) end if end if end do quatloop end subroutine EMsoftCgetEBSDPatterns","tags":"","loc":"proc/emsoftcgetebsdpatterns.html","title":"EMsoftCgetEBSDPatterns – Fortran Program"},{"text":"public recursive subroutine EMsoftCgetECPatterns(ipar, fpar, ECpattern, quats, accum_e, mLPNH, mLPSH, cproc, objAddress, cancel) bind(c, name=\"0\") Uses: local constants Lambert quaternions iso_c_binding proc~~emsoftcgetecpatterns~~UsesGraph proc~emsoftcgetecpatterns EMsoftCgetECPatterns Lambert Lambert Lambert->proc~emsoftcgetecpatterns iso_c_binding iso_c_binding iso_c_binding->proc~emsoftcgetecpatterns local local local->proc~emsoftcgetecpatterns module~constants constants local->module~constants quaternions quaternions quaternions->proc~emsoftcgetecpatterns module~constants->proc~emsoftcgetecpatterns Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh/Marc De Graef, Carnegie Mellon University\n @brief This subroutine can be called by a C/C++ program as a standalone function to compute ECPs\n @details This subroutine provides a method to compute a series of ECPs and\n can be called from an external C/C++ program; the routine provides a callback mechanism to\n update the calling program about computational progress, as well as a cancel option.\n The routine is intended to be called form a C/C++ program, e.g., DREAM.3D.  This routine is a simplified version\n of the core of the EMECP program. This routine will first compute the incident cone vectors etc. if necessary, and then perform\n the usual interpolation from the square Lambert projection. The pattern will be a basic pattern,\n without any intensity scaling or binning etc; the calling program should take care of those \n operations.\n @param ipar array with integer input parameters\n @param fpar array with float input parameters\n @param ECPattern output array\n @param quats array of quaternions\n @param accum_e array with Monte Carlo histogram\n @param mLPNH Northern hemisphere master pattern\n @param mLPSH Southern hemisphere master pattern\n @date 10/16/15  SS 1.0 original\n @date 11/02/14 MDG 1.1 put all integer parameters inside ipar and fixed size of ipar/fpar\n @date 11/04/15 MDG 1.2 added array of quaternions as input parameter\n @date 01/14/16 MDG 2.0 forked from original SingleECPattern routine; SAVE atrribute removed; ipar redefined (ipar(1) removed) Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in) :: ipar (nipar) real(kind=sgl), intent(in) :: fpar (nfpar) real(kind=sgl), intent(out) :: ECpattern (ipar(1),ipar(1),ipar(6)) real(kind=sgl), intent(in) :: quats (nq,ipar(6)) real(kind=sgl), intent(in) :: accum_e (ipar(2),-ipar(3):ipar(3),-ipar(3):ipar(3)) real(kind=sgl), intent(in) :: mLPNH (-ipar(5):ipar(5),-ipar(5):ipar(5),ipar(4)) real(kind=sgl), intent(in) :: mLPSH (-ipar(5):ipar(5),-ipar(5):ipar(5),ipar(4)) type(C_FUNPTR), intent(in), VALUE :: cproc integer(kind=c_size_t), intent(in), VALUE :: objAddress character(len=1), intent(in) :: cancel Calls proc~~emsoftcgetecpatterns~~CallsGraph proc~emsoftcgetecpatterns EMsoftCgetECPatterns sngl sngl proc~emsoftcgetecpatterns->sngl quat_lp quat_lp proc~emsoftcgetecpatterns->quat_lp lambertspheretosquare lambertspheretosquare proc~emsoftcgetecpatterns->lambertspheretosquare float float proc~emsoftcgetecpatterns->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code EMsoftCgetECPatterns Source Code recursive subroutine EMsoftCgetECPatterns ( ipar , fpar , ECpattern , quats , accum_e , mLPNH , mLPSH , cproc , objAddress , cancel ) & bind ( c , name = 'EMsoftCgetECPatterns' ) ! this routine is callable from a C/C++ program !DEC$ ATTRIBUTES DLLEXPORT :: EMsoftCgetECPatterns ! the input parameters are all part of a ipar and fpar input arrays instead of the usual namelist structures. ! The following is the mapping: ! ! ipar(1) = detnumpix ! ipar(2) = numangle ! ipar(3) = mcnsx ! ipar(4) = numset ! ipar(5) = mpnpx ! ipar(6) = numquats ! fpar(1) = ecpnl%thetac ! fpar(2) = ecpnl%sampletilt ! fpar(3) = ecpnl%workingdistance ! fpar(4) = ecpnl%Rin ! fpar(5) = ecpnl%Rout ! fpar(6) = ecpnl%sigstart ! fpar(7) = ecpnl%sigend ! fpar(8) = ecpnl%sigstep use local use constants use Lambert use quaternions use , INTRINSIC :: ISO_C_BINDING IMPLICIT NONE integer ( c_size_t ), PARAMETER :: nipar = 6 integer ( c_size_t ), PARAMETER :: nfpar = 8 integer ( c_size_t ), PARAMETER :: nq = 4 integer ( c_size_t ), INTENT ( IN ) :: ipar ( nipar ) real ( kind = sgl ), INTENT ( IN ) :: fpar ( nfpar ) real ( kind = sgl ), INTENT ( OUT ) :: ECpattern ( ipar ( 1 ), ipar ( 1 ), ipar ( 6 )) real ( kind = sgl ), INTENT ( IN ) :: quats ( nq , ipar ( 6 )) real ( kind = sgl ), INTENT ( IN ) :: accum_e ( ipar ( 2 ), - ipar ( 3 ): ipar ( 3 ), - ipar ( 3 ): ipar ( 3 )) real ( kind = sgl ), INTENT ( IN ) :: mLPNH ( - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 ), ipar ( 4 )) real ( kind = sgl ), INTENT ( IN ) :: mLPSH ( - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 ), ipar ( 4 )) TYPE ( C_FUNPTR ), INTENT ( IN ), VALUE :: cproc integer ( c_size_t ), INTENT ( IN ), VALUE :: objAddress character ( len = 1 ), INTENT ( IN ) :: cancel real ( kind = sgl ), allocatable :: klist (:,:,:), rgx (:,:), rgy (:,:), rgz (:,:), weightfact (:) real ( kind = sgl ), allocatable :: mLPNHsum (:,:), mLPSHsum (:,:) real ( kind = dbl ), parameter :: Rtod = 5 7.2957795131D0 real ( kind = dbl ), parameter :: dtoR = 0.01745329251D0 real ( kind = sgl ) :: kk ( 3 ), thetacr , ktmax , delta , wf , quat ( 4 ) integer ( kind = irg ) :: istat , imin , imax , jmin , jmax , ii , jj , nazimuth , npolar , nsig , ip , dn , cn integer ( kind = irg ) :: ipolar , iazimuth , isig , isampletilt , nix , niy , nixp , niyp , isigp real ( kind = sgl ) :: thetain , thetaout , polar , azimuthal , delpolar , delazimuth , om ( 3 , 3 ) real ( kind = sgl ) :: dc ( 3 ), scl , deltheta , acc_sum , MCangle , ixy ( 2 ), dx , dy , dxm , dym , dp PROCEDURE ( ProgressCallBack ), POINTER :: proc ! link the proc procedure to the cproc argument CALL C_F_PROCPOINTER ( cproc , proc ) !================================================================================== ! ------ generate the detector klist, rgx, rgy, rgz, weightfactors arrays !================================================================================== imin = 1 imax = ipar ( 1 ) jmin = 1 jmax = ipar ( 1 ) if ( allocated ( mLPNHsum )) deallocate ( mLPNHsum ) if ( allocated ( mLPSHsum )) deallocate ( mLPSHsum ) allocate ( mLPNHsum ( - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 ))) allocate ( mLPSHsum ( - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 ))) mLPNHsum = sum ( mLPNH , 3 ) mLPSHsum = sum ( mLPSH , 3 ) if ( allocated ( klist )) deallocate ( klist ) allocate ( klist ( 1 : 3 , 1 : ipar ( 1 ), 1 : ipar ( 1 )), stat = istat ) kk = ( / 0.0 , 0.0 , 1.0 / ) thetacr = DtoR * fpar ( 1 ) ktmax = tan ( thetacr ) delta = 2.0 * ktmax / dble ( ipar ( 1 ) - 1 ) do ii = imin , imax do jj = jmin , jmax klist ( 1 : 3 , ii , jj ) = ( /- ktmax + delta * ( ii - 1 ), - ktmax + delta * ( jj - 1 ), 0.0 / ) + kk ( 1 : 3 ) klist ( 1 : 3 , ii , jj ) = klist ( 1 : 3 , ii , jj ) / sqrt ( sum ( klist ( 1 : 3 , ii , jj ) ** 2 )) end do end do thetain = atan2 ( fpar ( 4 ), fpar ( 3 )) thetaout = atan2 ( fpar ( 5 ), fpar ( 3 )) om ( 1 ,:) = ( / cos ( fpar ( 2 ) * sngl ( dtor )), 0.0 , sin ( fpar ( 2 ) * sngl ( dtor )) / ) om ( 2 ,:) = ( / 0.0 , 1.0 , 0.0 / ) om ( 3 ,:) = ( /- sin ( fpar ( 2 ) * sngl ( dtor )), 0.0 , cos ( fpar ( 2 ) * sngl ( dtor )) / ) npolar = nint (( thetaout - thetain ) * 18 0.0 / cPi ) + 1 delpolar = ( thetaout - thetain ) / float ( npolar - 1 ) nazimuth = 361 delazimuth = 2.0 * cPi / float ( nazimuth - 1 ) if ( allocated ( rgx )) deallocate ( rgx , rgy , rgz ) allocate ( rgx ( npolar , nazimuth ), rgy ( npolar , nazimuth ), rgz ( npolar , nazimuth ), stat = istat ) do ipolar = 1 , npolar polar = thetain + float ( ipolar - 1 ) * delpolar do iazimuth = 1 , nazimuth azimuthal = float ( iazimuth - 1 ) * delazimuth dc ( 1 ) = cos ( azimuthal ) * sin ( polar ) dc ( 2 ) = sin ( azimuthal ) * sin ( polar ) dc ( 3 ) = cos ( polar ) dc = matmul ( om , dc ) rgx ( ipolar , iazimuth ) = dc ( 1 ) rgy ( ipolar , iazimuth ) = dc ( 2 ) rgz ( ipolar , iazimuth ) = dc ( 3 ) end do end do !=================================================================== ! ------ generate the weight factors from the monte carlo histogram !=================================================================== scl = float ( ipar ( 3 )) nsig = nint ( fpar ( 1 ) + abs ( fpar ( 2 ))) + 1 deltheta = ( fpar ( 1 ) + abs ( fpar ( 2 ))) / float ( nsig - 1 ) if ( allocated ( weightfact )) deallocate ( weightfact ) allocate ( weightfact ( 1 : nsig ), stat = istat ) weightfact = 0.0 do isig = 1 , nsig acc_sum = 0.0 MCangle = ( isig - 1 ) * deltheta isampletilt = nint (( MCangle - fpar ( 6 )) / fpar ( 8 )) if ( isampletilt . lt . 1 ) then isampletilt = abs ( isampletilt ) + 1 else isampletilt = isampletilt + 1 end if do ipolar = 1 , npolar do iazimuth = 1 , nazimuth dc ( 1 : 3 ) = ( / rgx ( ipolar , iazimuth ), rgy ( ipolar , iazimuth ), rgz ( ipolar , iazimuth ) / ) ! convert to Rosca-lambert projection ixy = scl * LambertSphereToSquare ( dc , istat ) nix = int ( ipar ( 3 ) + ixy ( 1 )) - ipar ( 3 ) niy = int ( ipar ( 3 ) + ixy ( 2 )) - ipar ( 3 ) nixp = nix + 1 niyp = niy + 1 if ( nixp . gt . ipar ( 3 )) nixp = nix if ( niyp . gt . ipar ( 3 )) niyp = niy if ( nix . lt . - ipar ( 3 )) nix = nixp if ( niy . lt . - ipar ( 3 )) niy = niyp dx = ixy ( 1 ) - nix dy = ixy ( 2 ) - niy dxm = 1.0 - dx dym = 1.0 - dy acc_sum = 0.25 * ( accum_e ( isampletilt , nix , niy ) * dxm * dym + & accum_e ( isampletilt , nixp , niy ) * dx * dym + & accum_e ( isampletilt , nix , niyp ) * dxm * dy + & accum_e ( isampletilt , nixp , niyp ) * dx * dy ) weightfact ( isig ) = weightfact ( isig ) + acc_sum end do end do end do weightfact ( 1 : nsig ) = weightfact ( 1 : nsig ) / weightfact ( 1 ) !=================================================================== ! ------ perform interpolation from square lambert map !=================================================================== scl = float ( ipar ( 5 )) ECPattern = 0.0 dn = nint ( float ( ipar ( 6 )) * 0.01 ) cn = dn quatloop : do ip = 1 , ipar ( 6 ) do ii = imin , imax do jj = jmin , jmax dc ( 1 : 3 ) = klist ( 1 : 3 , ii , jj ) dc = dc / sqrt ( sum ( dc * dc )) dp = DOT_PRODUCT ( dc ( 1 : 3 ),( / sin ( fpar ( 2 ) * dtoR ), 0.D0 , cos ( fpar ( 2 ) * dtoR ) / )) if ( dp . gt . 1.D0 ) dp = 1.0 MCangle = acos ( dp ) * Rtod isig = int ( MCangle ) + 1 if ( isig . gt . nsig ) isig = nsig isigp = isig + 1 if ( isigp . gt . nsig ) isigp = nsig dx = MCangle - int ( MCangle ) dxm = 1.0 - dx wf = weightfact ( isig ) * dxm + weightfact ( isigp ) * dx wf = 1.0 dc = quat_LP ( quats ( 1 : 4 , ip ), dc ) dc = dc / sqrt ( sum ( dc * dc )) ixy = scl * LambertSphereToSquare ( dc , istat ) nix = int ( ipar ( 5 ) + ixy ( 1 )) - ipar ( 5 ) niy = int ( ipar ( 5 ) + ixy ( 2 )) - ipar ( 5 ) nixp = nix + 1 niyp = niy + 1 if ( nixp . gt . ipar ( 5 )) nixp = nix if ( niyp . gt . ipar ( 5 )) niyp = niy if ( nix . lt . - ipar ( 5 )) nix = nixp if ( niy . lt . - ipar ( 5 )) niy = niyp dx = ixy ( 1 ) - nix dy = ixy ( 2 ) - niy dxm = 1.0 - dx dym = 1.0 - dy if ( dc ( 3 ). ge . 0.D0 ) then ECpattern ( ii , jj , ip ) = wf * ( mLPNHsum ( nix , niy ) * dxm * dym + & mLPNHsum ( nixp , niy ) * dx * dym + & mLPNHsum ( nix , niyp ) * dxm * dy + & mLPNHsum ( nixp , niyp ) * dx * dy ) else ECpattern ( ii , jj , ip ) = wf * ( mLPSHsum ( nix , niy ) * dxm * dym + & mLPSHsum ( nixp , niy ) * dx * dym + & mLPSHsum ( nix , niyp ) * dxm * dy + & mLPSHsum ( nixp , niyp ) * dx * dy ) end if end do end do ! has the cancel flag been set by the calling program ? if ( cancel . ne . char ( 0 )) EXIT quatloop ! update the progress counter and report it to the calling program via the proc callback routine if ( objAddress . ne . 0 ) then if ( ip . ge . cn ) then cn = cn + dn call proc ( objAddress , ip ) end if end if end do quatloop end subroutine EMsoftCgetECPatterns","tags":"","loc":"proc/emsoftcgetecpatterns.html","title":"EMsoftCgetECPatterns – Fortran Program"},{"text":"public recursive subroutine EMsoftCgetMCOpenCL(ipar, fpar, atompos, atomtypes, latparm, accum_e, accum_z, cproc, objAddress, cancel) bind(c, name=\"0\") Uses: local constants crystal constants symmetry io typedefs clfortran CLsupport timing iso_c_binding proc~~emsoftcgetmcopencl~~UsesGraph proc~emsoftcgetmcopencl EMsoftCgetMCOpenCL local local local->proc~emsoftcgetmcopencl module~clsupport CLsupport local->module~clsupport module~timing timing local->module~timing module~constants constants local->module~constants iso_c_binding iso_c_binding iso_c_binding->proc~emsoftcgetmcopencl io io io->proc~emsoftcgetmcopencl io->module~timing module~clsupport->proc~emsoftcgetmcopencl symmetry symmetry symmetry->proc~emsoftcgetmcopencl clfortran clfortran clfortran->proc~emsoftcgetmcopencl clfortran->module~clsupport crystal crystal crystal->proc~emsoftcgetmcopencl typedefs typedefs typedefs->proc~emsoftcgetmcopencl typedefs->module~timing module~timing->proc~emsoftcgetmcopencl module~constants->proc~emsoftcgetmcopencl Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief This subroutine can be called by a C/C++ program as a standalone routine to compute Monte Carlo data\n @details This subroutine provides a method to compute a Monte Carlo data set, normally computed\n with the EMMCOpenCL.f90 program.  The routine can be called from an external C/C++ program; \n the routine provides a callback mechanism to update the calling program about computational \n progress, as well as a cancel option. The routine is intended to be called from a C/C++ program, e.g., DREAM.3D.  This routine is a \n simplified version of the core of the EMMCOpenCL program. Since the HDF5 library with fortran90 support can only be a static library on Mac OS X, we must\n have the calling program read the .xtal HDF5 file and pass the necessary information on to\n this routine.  This is a workaround until the HDF group fixes the static library issue; DREAM.3D\n requires a dynamical HDF5 library, so for DREAM.3D and EMsoft to properly work together, the \n callable routines in this file may not depend on any HDF code at all, either directly or indirectly. @param ipar array with integer input parameters\n @param fpar array with float input parameters\n @param atdata atom coordinate array\n @param attypes atom type array\n @param latparm lattice parameter array\n @param accum_e output array with Monte Carlo energy histogram\n @param accum_z output array with Monte Carlo depth histogram\n @date 03/08/16 MDG 1.0 original\n @date 03/19/16 MDG 1.1 corrections to a few variable types\n @date 04/13/16 MDG 1.2 correction to accum_z array size due to changes in calling DREAM.3D filter\n @date 04/18/16 MDG 1.3 increased number of entries in ipar, fpar for compatibility with EMsoftCgetEBSDmaster routine\n @date 04/28/16 MDG 1.4 corrected error in indexing of init_seeds array; caused DREAM.3D to crash randomly Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in) :: ipar (nipar) real(kind=sgl), intent(in) :: fpar (nfpar) real(kind=sgl), intent(in) :: atompos (ipar(9),5) integer(kind=irg), intent(in) :: atomtypes (ipar(9)) real(kind=sgl), intent(in) :: latparm (6) integer(kind=irg), intent(out) :: accum_e (ipar(12),-ipar(1):ipar(1),-ipar(1):ipar(1)) integer(kind=irg), intent(out) :: accum_z (ipar(12),ipar(13),-ipar(16):ipar(16),-ipar(16):ipar(16)) type(C_FUNPTR), intent(in), VALUE :: cproc integer(kind=c_size_t), intent(in), VALUE :: objAddress character(len=1), intent(in) :: cancel Calls proc~~emsoftcgetmcopencl~~CallsGraph proc~emsoftcgetmcopencl EMsoftCgetMCOpenCL emsoft_path_init emsoft_path_init proc~emsoftcgetmcopencl->emsoft_path_init calcmatrices calcmatrices proc~emsoftcgetmcopencl->calcmatrices calcpositions calcpositions proc~emsoftcgetmcopencl->calcpositions generatesymmetry generatesymmetry proc~emsoftcgetmcopencl->generatesymmetry calcdensity calcdensity proc~emsoftcgetmcopencl->calcdensity clcreateprogramwithsource clcreateprogramwithsource proc~emsoftcgetmcopencl->clcreateprogramwithsource clreleasecontext clreleasecontext proc~emsoftcgetmcopencl->clreleasecontext proc~clinit_pdccq CLinit_PDCCQ proc~emsoftcgetmcopencl->proc~clinit_pdccq clbuildprogram clbuildprogram proc~emsoftcgetmcopencl->clbuildprogram clgetprogrambuildinfo clgetprogrambuildinfo proc~emsoftcgetmcopencl->clgetprogrambuildinfo clcreatekernel clcreatekernel proc~emsoftcgetmcopencl->clcreatekernel sngl sngl proc~emsoftcgetmcopencl->sngl emsoft_tonativepath emsoft_tonativepath proc~emsoftcgetmcopencl->emsoft_tonativepath clreleasememobject clreleasememobject proc~emsoftcgetmcopencl->clreleasememobject clreleaseprogram clreleaseprogram proc~emsoftcgetmcopencl->clreleaseprogram emsoft_getrandomseedfilename emsoft_getrandomseedfilename proc~emsoftcgetmcopencl->emsoft_getrandomseedfilename sgpg sgpg proc~emsoftcgetmcopencl->sgpg clcreatebuffer clcreatebuffer proc~emsoftcgetmcopencl->clcreatebuffer float float proc~emsoftcgetmcopencl->float clenqueuewritebuffer clenqueuewritebuffer proc~emsoftcgetmcopencl->clenqueuewritebuffer clreleasekernel clreleasekernel proc~emsoftcgetmcopencl->clreleasekernel proc~time_tick Time_tick proc~emsoftcgetmcopencl->proc~time_tick clsetkernelarg clsetkernelarg proc~emsoftcgetmcopencl->clsetkernelarg proc~clread_source_file CLread_source_file proc~emsoftcgetmcopencl->proc~clread_source_file clenqueuendrangekernel clenqueuendrangekernel proc~emsoftcgetmcopencl->clenqueuendrangekernel clfinish clfinish proc~emsoftcgetmcopencl->clfinish clreleasecommandqueue clreleasecommandqueue proc~emsoftcgetmcopencl->clreleasecommandqueue clenqueuereadbuffer clenqueuereadbuffer proc~emsoftcgetmcopencl->clenqueuereadbuffer proc~time_tock Time_tock proc~emsoftcgetmcopencl->proc~time_tock clgetdeviceinfo clgetdeviceinfo proc~clinit_pdccq->clgetdeviceinfo fatalerror fatalerror proc~clinit_pdccq->fatalerror clgetplatformids clgetplatformids proc~clinit_pdccq->clgetplatformids clcreatecontext clcreatecontext proc~clinit_pdccq->clcreatecontext clcreatecommandqueue clcreatecommandqueue proc~clinit_pdccq->clcreatecommandqueue writevalue writevalue proc~clinit_pdccq->writevalue clgetdeviceids clgetdeviceids proc~clinit_pdccq->clgetdeviceids proc~clerror_check CLerror_check proc~clinit_pdccq->proc~clerror_check proc~clread_source_file->emsoft_tonativepath proc~clread_source_file->fatalerror emsoft_getopenclpathname emsoft_getopenclpathname proc~clread_source_file->emsoft_getopenclpathname emsoft_getemdevelop emsoft_getemdevelop proc~clread_source_file->emsoft_getemdevelop proc~clerror_check->fatalerror proc~clerror_check->writevalue Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code EMsoftCgetMCOpenCL Source Code recursive subroutine EMsoftCgetMCOpenCL ( ipar , fpar , atompos , atomtypes , latparm , accum_e , accum_z , cproc , objAddress , cancel ) & bind ( c , name = 'EMsoftCgetMCOpenCL' ) ! this routine is callable from a C/C++ program !DEC$ ATTRIBUTES DLLEXPORT :: EMsoftCgetMCOpenCL ! ipar components ! ipar(1) : integer(kind=irg)       :: nx  = (numsx-1)/2 ! ipar(2) : integer(kind=irg)       :: globalworkgrpsz ! ipar(3) : integer(kind=irg)       :: num_el ! ipar(4) : integer(kind=irg)       :: totnum_el ! ipar(5) : integer(kind=irg)       :: multiplier ! ipar(6) : integer(kind=irg)       :: devid ! ipar(7) : integer(kind=irg)       :: platid ! ipar(8) : integer(kind=irg)       :: CrystalSystem ! ipar(9) : integer(kind=irg)       :: Natomtypes ! ipar(10): integer(kind=irg)       :: SpaceGroupNumber ! ipar(11): integer(kind=irg)       :: SpaceGroupSetting ! ipar(12): integer(kind=irg)       :: numEbins ! ipar(13): integer(kind=irg)       :: numzbins ! ipar(14): integer(kind=irg)       :: mcmode  ( 1 = 'full', 2 = 'bse1' ) ! ipar(15): integer(kind=irg)       :: numangle ! ipar(16): integer(kind=irg)       :: nxten = nx/10 ! other entries are not used ! fpar components ! fpar(1) : real(kind=dbl)          :: sig ! fpar(2) : real(kind=dbl)          :: omega ! fpar(3) : real(kind=dbl)          :: EkeV ! fpar(4) : real(kind=dbl)          :: Ehistmin ! fpar(5) : real(kind=dbl)          :: Ebinsize ! fpar(6) : real(kind=dbl)          :: depthmax ! fpar(7) : real(kind=dbl)          :: depthstep ! fpar(8) : real(kind=dbl)          :: sigstart ! fpar(9) : real(kind=dbl)          :: sigend ! fpar(10): real(kind=dbl)          :: sigstep ! other entries are not used use local use constants use crystal use constants use symmetry use io use typedefs use clfortran use CLsupport use timing use , INTRINSIC :: ISO_C_BINDING IMPLICIT NONE integer ( c_int32_t ), PARAMETER :: nipar = 40 integer ( c_int32_t ), PARAMETER :: nfpar = 40 integer ( c_int32_t ), INTENT ( IN ) :: ipar ( nipar ) real ( kind = sgl ), INTENT ( IN ) :: fpar ( nfpar ) real ( kind = sgl ), INTENT ( IN ) :: atompos ( ipar ( 9 ), 5 ) integer ( kind = irg ), INTENT ( IN ) :: atomtypes ( ipar ( 9 )) real ( kind = sgl ), INTENT ( IN ) :: latparm ( 6 ) integer ( kind = irg ), INTENT ( OUT ) :: accum_e ( ipar ( 12 ), - ipar ( 1 ): ipar ( 1 ), - ipar ( 1 ): ipar ( 1 )) integer ( kind = irg ), INTENT ( OUT ) :: accum_z ( ipar ( 12 ), ipar ( 13 ), - ipar ( 16 ): ipar ( 16 ), - ipar ( 16 ): ipar ( 16 )) TYPE ( C_FUNPTR ), INTENT ( IN ), VALUE :: cproc integer ( c_size_t ), INTENT ( IN ), VALUE :: objAddress character ( len = 1 ), INTENT ( IN ) :: cancel ! local variables and parameters type ( unitcell ), pointer :: cell character ( 4 ) :: mode integer ( kind = ill ) :: i , j , k , io_int ( 1 ), num_max , totnum_el , ipg , isave , istat integer ( kind = irg ) :: nx , numEbins , numzbins , numangle , iang , cn , dn , totn integer ( kind = irg ), target :: globalworkgrpsz , num_el , steps integer ( kind = 8 ), target :: globalsize ( 2 ), localsize ( 2 ) integer ( kind = 8 ) :: size_in_bytes , size_in_bytes_seeds real ( kind = sgl ), target :: dens , avA , avZ , omega , EkeV , sig , bseyield , io_real ( 3 ) real ( kind = 4 ), target :: density , Ze , at_wt , delta real ( kind = 8 ), parameter :: dtoR = 0.01745329251D0 ! pi/180 real ( kind = 4 ), allocatable , target :: Lamresx (:), Lamresy (:), depthres (:), energyres (:) integer ( kind = 4 ), allocatable :: rnseeds (:) integer ( kind = 4 ), allocatable , target :: init_seeds (:) integer ( kind = 4 ) :: idxy ( 2 ), iE , px , py , iz , nseeds , hdferr , tstart ! auxiliary variables real ( kind = 4 ) :: cxyz ( 3 ), edis , bse , xy ( 2 ), xs , ys , zs , sclf ! auxiliary variables real ( kind = 8 ) :: rand logical :: f_exists ! OpenCL variables integer ( c_intptr_t ), allocatable , target :: platform (:) integer ( c_intptr_t ), allocatable , target :: device (:) integer ( c_intptr_t ), target :: context integer ( c_intptr_t ), target :: command_queue integer ( c_intptr_t ), target :: prog integer ( c_intptr_t ), target :: kernel integer ( c_intptr_t ), target :: LamX , LamY , LamZ , depth , energy , seeds type ( c_ptr ) :: event integer ( c_int32_t ) :: ierr , pcnt integer ( c_size_t ), target :: slength integer ( c_intptr_t ), target :: ctx_props ( 3 ) character ( 2 ), target :: kernelname character ( 19 ), target :: progoptions character ( fnlen ), target :: info ! info about the GPU integer ( c_int64_t ) :: cmd_queue_props integer , parameter :: iunit = 10 integer , parameter :: source_length = 50000 character ( len = source_length ), target :: source character ( len = source_length , KIND = c_char ), TARGET :: csource type ( c_ptr ), target :: psource integer ( c_int ) :: nump , numd , irec , val , val1 ! auxiliary variables integer ( c_size_t ) :: cnum , cnuminfo character ( fnlen ) :: instring , dataname , fname , sourcefile PROCEDURE ( ProgressCallBack2 ), POINTER :: proc ! link the proc procedure to the cproc argument CALL C_F_PROCPOINTER ( cproc , proc ) ! since this routine needs to read a .cl file, we need to make sure that the pathnames are ! properly set... call EMsoft_path_init ! the following is necessitated by the fact that none of this code may ! depend on HDF5 routines, so we need to cut-and-paste from various ! other library routines to set things up so that we can compute the ! density, and the average atomic number and atomic mass... ! copy all the unit cell parameters into the proper fields and compute the ! density parameters needed by the Monte Carlo routine; then discard the cell structure nullify ( cell ) allocate ( cell ) ! lattice parameters cell % a = dble ( latparm ( 1 )) cell % b = dble ( latparm ( 2 )) cell % c = dble ( latparm ( 3 )) cell % alpha = dble ( latparm ( 4 )) cell % beta = dble ( latparm ( 5 )) cell % gamma = dble ( latparm ( 6 )) ! symmetry parameters cell % xtal_system = ipar ( 8 ) cell % SYM_SGset = ipar ( 11 ) cell % SYM_SGnum = ipar ( 10 ) if (( cell % SYM_SGnum . ge . 143 ). and .( cell % SYM_SGnum . le . 167 )) then cell % SG % SYM_trigonal = . TRUE . else cell % SG % SYM_trigonal = . FALSE . end if ! atom type and coordinate parameters cell % ATOM_ntype = ipar ( 9 ) cell % ATOM_type ( 1 : cell % ATOM_ntype ) = atomtypes ( 1 : cell % ATOM_ntype ) cell % ATOM_pos ( 1 : cell % ATOM_ntype , 1 : 5 ) = atompos ( 1 : cell % ATOM_ntype , 1 : 5 ) ! generate the symmetry operations cell % hexset = . FALSE . if ( cell % xtal_system . eq . 4 ) cell % hexset = . TRUE . if (( cell % xtal_system . eq . 5 ). AND .( cell % SYM_SGset . ne . 2 )) cell % hexset = . TRUE . ! compute the metric matrices call CalcMatrices ( cell ) ! First generate the point symmetry matrices, then the actual space group. ! Get the symmorphic space group corresponding to the point group ! of the actual space group ipg = 0 do i = 1 , 32 if ( SGPG ( i ). le . cell % SYM_SGnum ) ipg = i end do ! if the actual group is also the symmorphic group, then both ! steps can be done simultaneously, otherwise two calls to ! GenerateSymmetry are needed. if ( SGPG ( ipg ). eq . cell % SYM_SGnum ) then call GenerateSymmetry ( cell ,. TRUE .) else isave = cell % SYM_SGnum cell % SYM_SGnum = SGPG ( ipg ) call GenerateSymmetry ( cell ,. TRUE .) cell % SYM_SGnum = isave call GenerateSymmetry ( cell ,. FALSE .) end if ! next we get all the atom positions call CalcPositions ( cell , 'v' ) ! and now we have all we need to compute the density, average A and average Z call CalcDensity ( cell , dens , avZ , avA ) ! deallocate the cell structure deallocate ( cell ) ! and copy these values into the desired variables density = dble ( dens ) Ze = dble ( avZ ) at_wt = dble ( avA ) ! define a number of parameters steps = 300 mode = 'full' if ( ipar ( 14 ). ne . 1 ) mode = 'bse1' EkeV = sngl ( fpar ( 3 )) !sig = mcnl%sig*dtoR    ! this is defined later on and depends on the mode omega = sngl ( fpar ( 2 )) * dtoR globalworkgrpsz = ipar ( 2 ) num_el = int ( ipar ( 3 )) ! no. of electron simulation by one work item num_max = globalworkgrpsz * globalworkgrpsz * num_el ! total simulation in one loop totnum_el = ipar ( 4 ) * ipar ( 5 ) ! total number of electrons to simulate globalsize = ( / globalworkgrpsz , globalworkgrpsz / ) !localsize = (/ globalworkgrpsz, globalworkgrpsz /) !localsize = (/ globalworkgrpsz/10, globalworkgrpsz/10 /) numEbins = int ( ipar ( 12 )) numzbins = int ( ipar ( 13 )) nx = int ( ipar ( 1 )) delta = dble ( nx ) size_in_bytes = num_max * sizeof ( EkeV ) size_in_bytes_seeds = 4 * globalworkgrpsz * globalworkgrpsz * sizeof ( EkeV ) numangle = int ( ipar ( 15 )) ! next allocate and initialize a couple of arrays allocate ( Lamresx ( num_max ), Lamresy ( num_max ), depthres ( num_max ), energyres ( num_max ), stat = istat ) depthres = 0.0 energyres = 0.0 Lamresx = 0.0 Lamresy = 0.0 accum_e = 0 accum_z = 0 !====================== ! OpenCL INITIALIZATION !====================== call CLinit_PDCCQ ( platform , nump , int ( ipar ( 7 )), device , numd , int ( ipar ( 6 )), info , context , command_queue ) !===================== ! BUILD THE KERNEL !===================== ! read the source file sourcefile = 'EMMC.cl' call CLread_source_file ( sourcefile , csource , slength ) ! we disable all screen output; perhaps we can feed error messages back to the calling program... ! create the program pcnt = 1 psource = C_LOC ( csource ) prog = clCreateProgramWithSource ( context , pcnt , C_LOC ( psource ), C_LOC ( slength ), ierr ) ! if(ierr /= CL_SUCCESS) call FatalError(\"clCreateProgramWithSource: \",'Error: cannot create program from source.') ! build the program progoptions = '-cl-no-signed-zeros' ierr = clBuildProgram ( prog , numd , C_LOC ( device ), C_LOC ( progoptions ), C_NULL_FUNPTR , C_NULL_PTR ) ! if(ierr /= CL_SUCCESS) call FatalError(\"clBuildProgram: \",'Error: cannot build program.') ! get the compilation log ierr = clGetProgramBuildInfo ( prog , device ( ipar ( 6 )), CL_PROGRAM_BUILD_LOG , sizeof ( source ), C_LOC ( source ), cnum ) ! if(len(trim(source)) > 0) call Message(trim(source(1:cnum)),frm='(A)') ! if(ierr /= CL_SUCCESS) call FatalError(\"clGetProgramBuildInfo: \",'Error building program.') ! if we get here, then the program build was successful and we can proceed with the creation of the kernel ! call Message('Program Build Successful... Creating kernel') ! finally get the kernel and release the program kernelname = 'MC' kernel = clCreateKernel ( prog , C_LOC ( kernelname ), ierr ) ! if(ierr /= CL_SUCCESS) call FatalError(\"clCreateKernel: \",'Error creating kernel MC.') ierr = clReleaseProgram ( prog ) ! if(ierr /= CL_SUCCESS) call FatalError(\"clReleaseProgram: \",'Error releasing program.') open ( unit = iunit , file = trim ( EMsoft_toNativePath ( EMsoft_getRandomseedfilename ())), form = 'unformatted' , status = 'old' ) read ( iunit ) nseeds allocate ( rnseeds ( nseeds )) read ( iunit ) rnseeds close ( unit = iunit , status = 'keep' ) ! the next error needs to be checked in the calling program ! if (globalworkgrpsz**2 .gt. nseeds) call FatalError('EMMCOpenCL:','insufficient prime numbers') allocate ( init_seeds ( 4 * globalworkgrpsz * globalworkgrpsz ), stat = istat ) init_seeds = 0 do i = 1 , globalworkgrpsz do j = 1 , globalworkgrpsz do k = 1 , 4 init_seeds ( 4 * (( i - 1 ) * globalworkgrpsz + ( j - 1 )) + k ) = rnseeds ( 4 * (( i - 1 ) * globalworkgrpsz + j ) + k ) end do end do end do ! create device memory buffers LamX = clCreateBuffer ( context , CL_MEM_WRITE_ONLY , size_in_bytes , C_NULL_PTR , ierr ) ! if(ierr /= CL_SUCCESS) call FatalError('clCreateBuffer: ','cannot allocate device memory for LamX.') LamY = clCreateBuffer ( context , CL_MEM_WRITE_ONLY , size_in_bytes , C_NULL_PTR , ierr ) ! if(ierr /= CL_SUCCESS) call FatalError('clCreateBuffer: ','cannot allocate device memory for LamY.') depth = clCreateBuffer ( context , CL_MEM_WRITE_ONLY , size_in_bytes , C_NULL_PTR , ierr ) !   if(ierr /= CL_SUCCESS) call FatalError('clCreateBuffer: ','cannot allocate device memory for depth.') energy = clCreateBuffer ( context , CL_MEM_WRITE_ONLY , size_in_bytes , C_NULL_PTR , ierr ) !   if(ierr /= CL_SUCCESS) call FatalError('clCreateBuffer: ','cannot allocate device memory for energy.') seeds = clCreateBuffer ( context , CL_MEM_READ_WRITE , size_in_bytes , C_NULL_PTR , ierr ) ! if(ierr /= CL_SUCCESS) call FatalError('clCreateBuffer: ','cannot allocate device memory for seeds.') ierr = clEnqueueWriteBuffer ( command_queue , seeds , CL_TRUE , 0 _ 8 , size_in_bytes_seeds , C_LOC ( init_seeds ( 1 )), & 0 , C_NULL_PTR , C_NULL_PTR ) ! if(ierr /= CL_SUCCESS) call FatalError('clEnqueueWriteBuffer: ','cannot Enqueue write buffer.') ! set the callback parameters dn = 1 cn = dn totn = numangle * ( totnum_el / num_max + 1 ) call Time_tick ( tstart ) ! loop over angles (used for BSE1, single run for full) angleloop : do iang = 1 , numangle if ( mode . eq . 'bse1' ) then sig = ( fpar ( 8 ) + ( iang - 1 ) * fpar ( 10 )) * dtoR else sig = fpar ( 1 ) * dtoR end if mainloop : do i = 1 ,( totnum_el / num_max + 1 ) ! set the kernel arguments ierr = clSetKernelArg ( kernel , 0 , sizeof ( LamX ), C_LOC ( LamX )) !   if(ierr /= CL_SUCCESS) stop 'Error: cannot set kernel argument.' ierr = clSetKernelArg ( kernel , 1 , sizeof ( LamY ), C_LOC ( LamY )) !   if(ierr /= CL_SUCCESS) stop 'Error: cannot set kernel argument.' ierr = clSetKernelArg ( kernel , 2 , sizeof ( EkeV ), C_LOC ( EkeV )) !   if(ierr /= CL_SUCCESS) stop 'Error: cannot set kernel argument.' ierr = clSetKernelArg ( kernel , 3 , sizeof ( globalworkgrpsz ), C_LOC ( globalworkgrpsz )) !   if(ierr /= CL_SUCCESS) stop 'Error: cannot set kernel argument.' ierr = clSetKernelArg ( kernel , 4 , sizeof ( Ze ), C_LOC ( Ze )) !   if(ierr /= CL_SUCCESS) stop 'Error: cannot set kernel argument.' ierr = clSetKernelArg ( kernel , 5 , sizeof ( density ), C_LOC ( density )) !   if(ierr /= CL_SUCCESS) stop 'Error: cannot set kernel argument.' ierr = clSetKernelArg ( kernel , 6 , sizeof ( at_wt ), C_LOC ( at_wt )) !   if(ierr /= CL_SUCCESS) stop 'Error: cannot set kernel argument.' ierr = clSetKernelArg ( kernel , 7 , sizeof ( num_el ), C_LOC ( num_el )) !   if(ierr /= CL_SUCCESS) stop 'Error: cannot set kernel argument.' ierr = clSetKernelArg ( kernel , 8 , sizeof ( seeds ), C_LOC ( seeds )) !   if(ierr /= CL_SUCCESS) stop 'Error: cannot set kernel argument.' ierr = clSetKernelArg ( kernel , 9 , sizeof ( sig ), C_LOC ( sig )) !   if(ierr /= CL_SUCCESS) stop 'Error: cannot set kernel argument.' ierr = clSetKernelArg ( kernel , 10 , sizeof ( omega ), C_LOC ( omega )) !   if(ierr /= CL_SUCCESS) stop 'Error: cannot set kernel argument.' ierr = clSetKernelArg ( kernel , 11 , sizeof ( depth ), C_LOC ( depth )) !   if(ierr /= CL_SUCCESS) stop 'Error: cannot set kernel argument.' ierr = clSetKernelArg ( kernel , 12 , sizeof ( energy ), C_LOC ( energy )) !   if(ierr /= CL_SUCCESS) stop 'Error: cannot set kernel argument.' ierr = clSetKernelArg ( kernel , 13 , sizeof ( steps ), C_LOC ( steps )) !   if(ierr /= CL_SUCCESS) stop 'Error: cannot set kernel argument.' ! execute the kernel !   ierr = clEnqueueNDRangeKernel(command_queue, kernel, 2, C_NULL_PTR, C_LOC(globalsize), C_LOC(localsize), & !                                 0, C_NULL_PTR, C_NULL_PTR) ierr = clEnqueueNDRangeKernel ( command_queue , kernel , 2 , C_NULL_PTR , C_LOC ( globalsize ), C_NULL_PTR , & 0 , C_NULL_PTR , C_NULL_PTR ) ! wait for the commands to finish ierr = clFinish ( command_queue ) ! read the resulting vector from device memory ierr = clEnqueueReadBuffer ( command_queue , LamX , CL_TRUE , 0 _ 8 , size_in_bytes , C_LOC ( Lamresx ( 1 )), 0 , C_NULL_PTR , C_NULL_PTR ) ierr = clEnqueueReadBuffer ( command_queue , LamY , CL_TRUE , 0 _ 8 , size_in_bytes , C_LOC ( Lamresy ( 1 )), 0 , C_NULL_PTR , C_NULL_PTR ) ierr = clEnqueueReadBuffer ( command_queue , depth , CL_TRUE , 0 _ 8 , size_in_bytes , C_LOC ( depthres ( 1 )), 0 , C_NULL_PTR , C_NULL_PTR ) ierr = clEnqueueReadBuffer ( command_queue , energy , CL_TRUE , 0 _ 8 , size_in_bytes , C_LOC ( energyres ( 1 )), 0 , C_NULL_PTR , C_NULL_PTR ) if ( mode . eq . 'full' ) then subloopfull : do j = 1 , num_max if (( Lamresx ( j ) . ne . - 1 0.0 ) . and . ( Lamresy ( j ) . ne . - 1 0.0 ) & . and . ( depthres ( j ) . ne . 1 0.0 ) . and . ( energyres ( j ) . ne . 0.0 ) & . and . . not . isnan ( Lamresx ( j )) . and . . not . isnan ( Lamresy ( j ))) then ! and get the nearest pixel [ take into account reversal of coordinate frame (x,y) -> (y,-x) ] if (( nint ( delta * Lamresy ( j )) . eq . 0.0 ) . and . ( nint ( - delta * Lamresx ( j )) . eq . 0.0 )) then val1 = val1 + 1 end if val = val + 1 idxy = ( / nint ( delta * Lamresy ( j )), nint ( - delta * Lamresx ( j )) / ) if ( maxval ( abs ( idxy )). le . nx ) then ! If Ec larger than Emin, then we should count this electron if ( energyres ( j ). gt . fpar ( 4 )) then iE = nint (( energyres ( j ) - fpar ( 4 )) / fpar ( 5 )) + 1 ! first add this electron to the correct exit distance vs. energy bin (coarser than the angular plot) edis = abs ( depthres ( j )) ! distance from last scattering point to surface along trajectory iz = nint ( edis / fpar ( 7 )) + 1 if ( ( iz . gt . 0 ). and .( iz . le . ipar ( 13 )) ) then px = nint ( idxy ( 1 ) / 1 0.0 ) py = nint ( idxy ( 2 ) / 1 0.0 ) accum_z ( iE , iz , px , py ) = accum_z ( iE , iz , px , py ) + 1 end if ! then add it to the modified Lambert accumulator array. accum_e ( iE , idxy ( 1 ), idxy ( 2 )) = accum_e ( iE , idxy ( 1 ), idxy ( 2 )) + 1 end if end if end if end do subloopfull end if if ( mode . eq . 'bse1' ) then subloopbse1 : do j = 1 , num_max if (( Lamresx ( j ) . ne . - 1 0.0 ) . and . ( Lamresy ( j ) . ne . - 1 0.0 ) & . and . ( depthres ( j ) . ne . 1 0.0 ) . and . ( energyres ( j ) . ne . 0.0 ) & . and . . not . isnan ( Lamresx ( j )) . and . . not . isnan ( Lamresy ( j ))) then ! and get the nearest pixel [ take into account reversal of coordinate frame (x,y) -> (y,-x) ] if (( nint ( delta * Lamresy ( j )) . eq . 0.0 ) . and . ( nint ( - delta * Lamresx ( j )) . eq . 0.0 )) then val1 = val1 + 1 end if val = val + 1 idxy = ( / nint ( delta * Lamresy ( j )), nint ( - delta * Lamresx ( j )) / ) if ( maxval ( abs ( idxy )). le . nx ) then ! first add this electron to the correct exit distance vs. sigma (coarser than the angular plot) edis = abs ( depthres ( j )) ! distance from last scattering point to surface along trajectory iz = nint ( edis / fpar ( 7 )) + 1 if ( ( iz . gt . 0 ). and .( iz . le . ipar ( 13 )) ) then px = nint ( idxy ( 1 ) / 1 0.0 ) py = nint ( idxy ( 2 ) / 1 0.0 ) accum_z ( iang , iz , px , py ) = accum_z ( iang , iz , px , py ) + 1 end if ! then add it to the modified Lambert accumulator array. accum_e ( iang , idxy ( 1 ), idxy ( 2 )) = accum_e ( iang , idxy ( 1 ), idxy ( 2 )) + 1 end if end if end do subloopbse1 end if ! has the cancel flag been set by the calling program ? if ( cancel . ne . char ( 0 )) EXIT angleloop ! update the progress counter and report it to the calling program via the proc callback routine if ( objAddress . ne . 0 ) then cn = cn + dn bseyield = 10 0.0 * float ( sum ( accum_e )) / float ( i * num_max ) write ( * , * ) cn , totn , bseyield call proc ( objAddress , cn , totn , bseyield ) end if end do mainloop end do angleloop write ( * , * ) 'Total GPU time [s] = ' , Time_tock ( tstart ) !===================== ! RELEASE EVERYTHING !===================== ierr = clReleaseKernel ( kernel ) ierr = clReleaseCommandQueue ( command_queue ) ierr = clReleaseContext ( context ) ierr = clReleaseMemObject ( LamX ) ierr = clReleaseMemObject ( LamY ) ierr = clReleaseMemObject ( depth ) ierr = clReleaseMemObject ( energy ) ierr = clReleaseMemObject ( seeds ) end subroutine EMsoftCgetMCOpenCL","tags":"","loc":"proc/emsoftcgetmcopencl.html","title":"EMsoftCgetMCOpenCL – Fortran Program"},{"text":"public recursive subroutine EMsoftCgetEBSDmaster(ipar, fpar, atompos, atomtypes, latparm, accum_z, mLPNH, mLPSH, cproc, objAddress, cancel) bind(c, name=\"0\") Uses: typedefs NameListTypedefs initializers MBmodule symmetry crystal constants error gvectors kvectors io local files diffraction multibeams timing Lambert iso_c_binding omp_lib proc~~emsoftcgetebsdmaster~~UsesGraph proc~emsoftcgetebsdmaster EMsoftCgetEBSDmaster io io io->proc~emsoftcgetebsdmaster module~timing timing io->module~timing error error error->proc~emsoftcgetebsdmaster iso_c_binding iso_c_binding iso_c_binding->proc~emsoftcgetebsdmaster module~initializers initializers module~initializers->proc~emsoftcgetebsdmaster gvectors gvectors gvectors->proc~emsoftcgetebsdmaster crystal crystal crystal->proc~emsoftcgetebsdmaster omp_lib omp_lib omp_lib->proc~emsoftcgetebsdmaster local local local->proc~emsoftcgetebsdmaster module~namelisttypedefs NameListTypedefs local->module~namelisttypedefs module~multibeams multibeams local->module~multibeams local->module~timing module~constants constants local->module~constants diffraction diffraction diffraction->proc~emsoftcgetebsdmaster module~namelisttypedefs->proc~emsoftcgetebsdmaster module~multibeams->proc~emsoftcgetebsdmaster symmetry symmetry symmetry->proc~emsoftcgetebsdmaster files files files->proc~emsoftcgetebsdmaster Lambert Lambert Lambert->proc~emsoftcgetebsdmaster MBmodule MBmodule MBmodule->proc~emsoftcgetebsdmaster module~timing->proc~emsoftcgetebsdmaster typedefs typedefs typedefs->proc~emsoftcgetebsdmaster typedefs->module~timing kvectors kvectors kvectors->proc~emsoftcgetebsdmaster module~constants->proc~emsoftcgetebsdmaster Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief This subroutine can be called by a C/C++ program as a standalone routine to compute EBSD master patterns\n @details This subroutine provides a method to compute an EBSD master pattern for the northern and southern\n hemispheres, i.e., it implements the EMEBSDmaster.f90 program.  The routine can be called from an external C/C++ program; \n the routine provides a callback mechanism to update the calling program about computational \n progress, as well as a cancel option. The routine is intended to be called from a C/C++ program, e.g., DREAM.3D.  This routine is a \n simplified version of the core of the EMEBSDmaster program. Since the HDF5 library with fortran90 support can only be a static library on Mac OS X, we must\n have the calling program read the .xtal HDF5 file and pass the necessary information on to\n this routine.  This is a workaround until the HDF group fixes the static library issue; DREAM.3D\n requires a dynamical HDF5 library, so for DREAM.3D and EMsoft to properly work together, the \n callable routines in this file may not depend on any HDF code at all, either directly or indirectly. @param ipar array with integer input parameters\n @param fpar array with float input parameters\n @param atdata atom coordinate array\n @param attypes atom type array\n @param latparm lattice parameter array\n @param accum_z output array with Monte Carlo depth histogram\n @param mLPNH modified Lambert projection northern hemisphere (output)\n @param mLPSH modified Lambert projection southern hemisphere (output)\n @date 04/17/16 MDG 1.0 original !!$OMP CANCELLATION POINT Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in) :: ipar (nipar) real(kind=sgl), intent(in) :: fpar (nfpar) real(kind=sgl), intent(in) :: atompos (ipar(9),5) integer(kind=irg), intent(in) :: atomtypes (ipar(9)) real(kind=sgl), intent(in) :: latparm (6) integer(kind=irg), intent(in) :: accum_z (ipar(12),ipar(13),-ipar(16):ipar(16),-ipar(16):ipar(16)) real(kind=sgl), intent(out) :: mLPNH (-ipar(17):ipar(17),-ipar(17):ipar(17),1:ipar(12),1:ipar(9)) real(kind=sgl), intent(out) :: mLPSH (-ipar(17):ipar(17),-ipar(17):ipar(17),1:ipar(12),1:ipar(9)) type(C_FUNPTR), intent(in), VALUE :: cproc integer(kind=c_size_t), intent(in), VALUE :: objAddress character(len=1), intent(in) :: cancel Calls proc~~emsoftcgetebsdmaster~~CallsGraph proc~emsoftcgetebsdmaster EMsoftCgetEBSDmaster calcmatrices calcmatrices proc~emsoftcgetebsdmaster->calcmatrices sgpg sgpg proc~emsoftcgetebsdmaster->sgpg generatesymmetry generatesymmetry proc~emsoftcgetebsdmaster->generatesymmetry lambertspheretohex lambertspheretohex proc~emsoftcgetebsdmaster->lambertspheretohex omp_get_thread_num omp_get_thread_num proc~emsoftcgetebsdmaster->omp_get_thread_num apply3dpgsymmetry apply3dpgsymmetry proc~emsoftcgetebsdmaster->apply3dpgsymmetry float float proc~emsoftcgetebsdmaster->float interface~initialize_reflectionlist Initialize_ReflectionList proc~emsoftcgetebsdmaster->interface~initialize_reflectionlist sngl sngl proc~emsoftcgetebsdmaster->sngl calcpositions calcpositions proc~emsoftcgetebsdmaster->calcpositions getdynmat getdynmat proc~emsoftcgetebsdmaster->getdynmat calcwavelength calcwavelength proc~emsoftcgetebsdmaster->calcwavelength lambertsquaretosphere lambertsquaretosphere proc~emsoftcgetebsdmaster->lambertsquaretosphere calckvectors calckvectors proc~emsoftcgetebsdmaster->calckvectors calcsgh calcsgh proc~emsoftcgetebsdmaster->calcsgh fatalerror fatalerror proc~emsoftcgetebsdmaster->fatalerror apply_bethepotentials apply_bethepotentials proc~emsoftcgetebsdmaster->apply_bethepotentials pgsamplingtype pgsamplingtype proc~emsoftcgetebsdmaster->pgsamplingtype calcucg calcucg proc~emsoftcgetebsdmaster->calcucg gethexvsrho gethexvsrho proc~emsoftcgetebsdmaster->gethexvsrho calclgh calclgh proc~emsoftcgetebsdmaster->calclgh calclength calclength proc~emsoftcgetebsdmaster->calclength omp_set_num_threads omp_set_num_threads proc~emsoftcgetebsdmaster->omp_set_num_threads omp_get_num_threads omp_get_num_threads proc~emsoftcgetebsdmaster->omp_get_num_threads delete_kvectorlist delete_kvectorlist proc~emsoftcgetebsdmaster->delete_kvectorlist delete_gvectorlist delete_gvectorlist proc~emsoftcgetebsdmaster->delete_gvectorlist isgallowed isgallowed proc~emsoftcgetebsdmaster->isgallowed interface~initialize_reflectionlist->interface~initialize_reflectionlist proc~initialize_reflectionlist_ewaldsweep Initialize_ReflectionList_EwaldSweep interface~initialize_reflectionlist->proc~initialize_reflectionlist_ewaldsweep proc~initialize_reflectionlist_ewaldsweep->float proc~initialize_reflectionlist_ewaldsweep->sngl proc~initialize_reflectionlist_ewaldsweep->calclength proc~initialize_reflectionlist_ewaldsweep->isgallowed writevalue writevalue proc~initialize_reflectionlist_ewaldsweep->writevalue transspace transspace proc~initialize_reflectionlist_ewaldsweep->transspace calcdot calcdot proc~initialize_reflectionlist_ewaldsweep->calcdot addreflection addreflection proc~initialize_reflectionlist_ewaldsweep->addreflection calcsg calcsg proc~initialize_reflectionlist_ewaldsweep->calcsg normvec normvec proc~initialize_reflectionlist_ewaldsweep->normvec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code EMsoftCgetEBSDmaster Source Code recursive subroutine EMsoftCgetEBSDmaster ( ipar , fpar , atompos , atomtypes , latparm , accum_z , mLPNH , mLPSH , cproc , objAddress , cancel ) & bind ( c , name = 'EMsoftCgetEBSDmaster' ) ! this routine is callable from a C/C++ program !DEC$ ATTRIBUTES DLLEXPORT :: EMsoftCgetEBSDmaster ! these are the same as in the EMsoftCgetMCOpenCL routine, with a few extras at the end. ! ipar components ! ipar(1) : integer(kind=irg)       :: nx  = (numsx-1)/2 ! ipar(2) : integer(kind=irg)       :: globalworkgrpsz ! ipar(3) : integer(kind=irg)       :: num_el ! ipar(4) : integer(kind=irg)       :: totnum_el ! ipar(5) : integer(kind=irg)       :: multiplier ! ipar(6) : integer(kind=irg)       :: devid ! ipar(7) : integer(kind=irg)       :: platid ! ipar(8) : integer(kind=irg)       :: CrystalSystem ! ipar(9) : integer(kind=irg)       :: Natomtypes ! ipar(10): integer(kind=irg)       :: SpaceGroupNumber ! ipar(11): integer(kind=irg)       :: SpaceGroupSetting ! ipar(12): integer(kind=irg)       :: numEbins ! ipar(13): integer(kind=irg)       :: numzbins ! ipar(14): integer(kind=irg)       :: mcmode  ( 1 = 'full', 2 = 'bse1' ) ! ipar(15): integer(kind=irg)       :: numangle ! ipar(16): integer(kind=irg)       :: nxten = nx/10 ! the following are only used in this routine, not in the Monte Carlo routine ! ipar(17): integer(kind=irg)       :: npx ! ipar(18): integer(kind=irg)       :: nthreads ! fpar components ! fpar(1) : real(kind=dbl)          :: sig ! fpar(2) : real(kind=dbl)          :: omega ! fpar(3) : real(kind=dbl)          :: EkeV ! fpar(4) : real(kind=dbl)          :: Ehistmin ! fpar(5) : real(kind=dbl)          :: Ebinsize ! fpar(6) : real(kind=dbl)          :: depthmax ! fpar(7) : real(kind=dbl)          :: depthstep ! fpar(8) : real(kind=dbl)          :: sigstart ! fpar(9) : real(kind=dbl)          :: sigend ! fpar(10): real(kind=dbl)          :: sigstep ! parameters only used in this routine, this includes the Bethe Parameters !!!! ! fpar(11) : real(kind=dbl)         :: dmin ! fpar(12) : real(kind=dbl)         :: Bethe  c1 ! fpar(13) : real(kind=dbl)         :: Bethe  c2 ! fpar(14) : real(kind=dbl)         :: Bethe  c3 use typedefs use NameListTypedefs use initializers use MBmodule use symmetry use crystal use constants use error use gvectors use kvectors use io use local use files use diffraction use multibeams use timing use Lambert use ISO_C_BINDING use omp_lib IMPLICIT NONE integer ( c_int32_t ), PARAMETER :: nipar = 40 integer ( c_int32_t ), PARAMETER :: nfpar = 40 integer ( c_int32_t ), INTENT ( IN ) :: ipar ( nipar ) real ( kind = sgl ), INTENT ( IN ) :: fpar ( nfpar ) real ( kind = sgl ), INTENT ( IN ) :: atompos ( ipar ( 9 ), 5 ) integer ( kind = irg ), INTENT ( IN ) :: atomtypes ( ipar ( 9 )) real ( kind = sgl ), INTENT ( IN ) :: latparm ( 6 ) integer ( kind = irg ), INTENT ( IN ) :: accum_z ( ipar ( 12 ), ipar ( 13 ), - ipar ( 16 ): ipar ( 16 ), - ipar ( 16 ): ipar ( 16 )) real ( kind = sgl ), INTENT ( OUT ) :: mLPNH ( - ipar ( 17 ): ipar ( 17 ), - ipar ( 17 ): ipar ( 17 ), 1 : ipar ( 12 ), 1 : ipar ( 9 )) real ( kind = sgl ), INTENT ( OUT ) :: mLPSH ( - ipar ( 17 ): ipar ( 17 ), - ipar ( 17 ): ipar ( 17 ), 1 : ipar ( 12 ), 1 : ipar ( 9 )) TYPE ( C_FUNPTR ), INTENT ( IN ), VALUE :: cproc integer ( c_size_t ), INTENT ( IN ), VALUE :: objAddress character ( len = 1 ), INTENT ( IN ) :: cancel real ( kind = dbl ) :: ctmp ( 192 , 3 ), arg integer ( kind = irg ) :: isym , i , j , ik , npy , ipx , ipy , ipz , debug , iE , izz , izzmax , iequiv ( 3 , 48 ), nequiv , num_el , MCnthreads , & ! counters numk , & ! number of independent incident beam directions ir , nat ( 100 ), kk ( 3 ), skip , ijmax , one , NUMTHREADS , TID , SamplingType , cancelerr , & numset , n , ix , iy , iz , nns , nnw , nref , Estart , ipg , isave , npx , nthreads , & istat , gzero , ic , ip , ikk , totstrong , totweak , jh , ierr , nix , niy , nixp , niyp , nxten ! counters real ( kind = dbl ) :: tpi , Znsq , kkl , DBWF , kin , delta , h , lambda , omtl , srt , dc ( 3 ), xy ( 2 ), edge , scl , tmp , & dx , dxm , dy , dym , dmin ! real ( kind = sgl ) :: io_real ( 5 ), selE , kn , FN ( 3 ), kkk ( 3 ), tstart , tstop , bp ( 4 ) real ( kind = sgl ), allocatable :: EkeVs (:), svals (:), auxNH (:,:,:), auxSH (:,:,:) ! results complex ( kind = dbl ) :: czero complex ( kind = dbl ), allocatable :: Lgh (:,:), Sgh (:,:,:) logical :: usehex , switchmirror , verbose ! Monte Carlo derived quantities integer ( kind = irg ) :: numEbins , numzbins , nsx , nsy , hdferr , nlines , lastEnergy , cn , dn , totn , cn2 , totn2 ! variables used in MC energy file real ( kind = dbl ) :: EkeV , Ehistmin , Ebinsize , depthmax , depthstep , etotal ! enery variables from MC program integer ( kind = irg ), allocatable :: thick (:), acc_z (:,:,:,:) real ( kind = sgl ), allocatable :: lambdaE (:,:) logical :: f_exists , readonly , overwrite = . TRUE ., insert = . TRUE ., stereog character ( fnlen , KIND = c_char ), allocatable , TARGET :: stringarray (:) character ( fnlen , kind = c_char ) :: line2 ( 1 ) integer ( kind = irg ) :: imh , imk , iml , gg ( 3 ) real ( kind = sgl ) :: dhkl , ddt type ( unitcell ), pointer :: cell type ( DynType ), save :: Dyn type ( gnode ), save :: rlp type ( reflisttype ), pointer :: reflist , firstw , rltmp type ( BetheParameterType ) :: BetheParameters type ( kvectorlist ), pointer :: khead , ktmp real ( kind = sgl ), allocatable :: karray (:,:) integer ( kind = irg ), allocatable :: kij (:,:) complex ( kind = dbl ), allocatable :: DynMat (:,:) character ( fnlen ) :: dataset , instring PROCEDURE ( ProgressCallBack3 ), POINTER :: proc !$OMP THREADPRIVATE(rlp) ! link the proc procedure to the cproc argument CALL C_F_PROCPOINTER ( cproc , proc ) ! initalize a few variables tpi = 2.D0 * cPi czero = dcmplx ( 0.D0 , 0.D0 ) ! parameters that would normally be read from the MC HDF5 file npx = ipar ( 17 ) nxten = ipar ( 16 ) EkeV = fpar ( 3 ) Ehistmin = fpar ( 4 ) Ebinsize = fpar ( 5 ) depthmax = fpar ( 6 ) depthstep = fpar ( 7 ) numEbins = ipar ( 12 ) Estart = numEbins numzbins = ipar ( 13 ) num_el = ipar ( 3 ) dmin = fpar ( 11 ) nthreads = ipar ( 18 ) etotal = dble ( ipar ( 4 )) * dble ( ipar ( 5 )) ! extract the BetheParameters ... BetheParameters % c1 = fpar ( 12 ) BetheParameters % c2 = fpar ( 13 ) BetheParameters % c3 = fpar ( 14 ) !============================================= !============================================= ! crystallography section nullify ( cell ) allocate ( cell ) ! lattice parameters cell % a = dble ( latparm ( 1 )) cell % b = dble ( latparm ( 2 )) cell % c = dble ( latparm ( 3 )) cell % alpha = dble ( latparm ( 4 )) cell % beta = dble ( latparm ( 5 )) cell % gamma = dble ( latparm ( 6 )) ! symmetry parameters cell % xtal_system = ipar ( 8 ) cell % SYM_SGset = ipar ( 11 ) cell % SYM_SGnum = ipar ( 10 ) if (( cell % SYM_SGnum . ge . 143 ). and .( cell % SYM_SGnum . le . 167 )) then cell % SG % SYM_trigonal = . TRUE . else cell % SG % SYM_trigonal = . FALSE . end if ! atom type and coordinate parameters cell % ATOM_ntype = ipar ( 9 ) cell % ATOM_type ( 1 : cell % ATOM_ntype ) = atomtypes ( 1 : cell % ATOM_ntype ) cell % ATOM_pos ( 1 : cell % ATOM_ntype , 1 : 5 ) = atompos ( 1 : cell % ATOM_ntype , 1 : 5 ) ! generate the symmetry operations cell % hexset = . FALSE . if ( cell % xtal_system . eq . 4 ) cell % hexset = . TRUE . if (( cell % xtal_system . eq . 5 ). AND .( cell % SYM_SGset . ne . 2 )) cell % hexset = . TRUE . ! compute the metric matrices call CalcMatrices ( cell ) ! First generate the point symmetry matrices, then the actual space group. ! Get the symmorphic space group corresponding to the point group ! of the actual space group ipg = 0 do i = 1 , 32 if ( SGPG ( i ). le . cell % SYM_SGnum ) ipg = i end do ! if the actual group is also the symmorphic group, then both ! steps can be done simultaneously, otherwise two calls to ! GenerateSymmetry are needed. if ( SGPG ( ipg ). eq . cell % SYM_SGnum ) then call GenerateSymmetry ( cell ,. TRUE .) else isave = cell % SYM_SGnum cell % SYM_SGnum = SGPG ( ipg ) call GenerateSymmetry ( cell ,. TRUE .) cell % SYM_SGnum = isave call GenerateSymmetry ( cell ,. FALSE .) end if ! next we get all the atom positions call CalcPositions ( cell , 'v' ) ! voltage will be set in the energyloop later on... cell % voltage = dble ( EkeV ) skip = 3 ! always use Weickenmeier&Kohl scattering coefficients, including absorptive form factors call CalcWaveLength ( cell , rlp , skip ) ! compute the range of reflections for the lookup table and allocate the table ! The master list is easily created by brute force imh = 1 do dhkl = 1.0 / CalcLength ( cell , ( / float ( imh ) , 0.0_sgl , 0.0_sgl / ), 'r' ) if ( dhkl . lt . dmin ) EXIT imh = imh + 1 end do imk = 1 do dhkl = 1.0 / CalcLength ( cell , ( / 0.0_sgl , float ( imk ), 0.0_sgl / ), 'r' ) if ( dhkl . lt . dmin ) EXIT imk = imk + 1 end do iml = 1 do dhkl = 1.0 / CalcLength ( cell , ( / 0.0_sgl , 0.0_sgl , float ( iml ) / ), 'r' ) if ( dhkl . lt . dmin ) EXIT iml = iml + 1 end do ! the LUT array stores all the Fourier coefficients, so that we only need to compute them once... i.e., here and now allocate ( cell % LUT ( - 2 * imh : 2 * imh , - 2 * imk : 2 * imk , - 2 * iml : 2 * iml ), stat = istat ) if ( istat . ne . 0 ) call FatalError ( 'InitializeCell:' , ' unable to allocate cell%LUT array' ) cell % LUT = dcmplx ( 0.D0 , 0.D0 ) allocate ( cell % LUTqg ( - 2 * imh : 2 * imh , - 2 * imk : 2 * imk , - 2 * iml : 2 * iml ), stat = istat ) if ( istat . ne . 0 ) call FatalError ( 'InitializeCell:' , ' unable to allocate cell%LUTqg array' ) cell % LUTqg = dcmplx ( 0.D0 , 0.D0 ) ! allocate an array that keeps track of potential double diffraction reflections allocate ( cell % dbdiff ( - 2 * imh : 2 * imh , - 2 * imk : 2 * imk , - 2 * iml : 2 * iml ), stat = istat ) if ( istat . ne . 0 ) call FatalError ( 'InitializeCell:' , ' unable to allocate cell%dbdiff array' ) cell % dbdiff = . FALSE . ddt = 1.0e-5 ! changed from 1.0e-10 on 08/14/15 by MDG in response to some issues with double ! diffraction spots not being taken into account in EBSD master pattern simulations ! next, we compute the overall lookup table cell%LUT; we do not, at this point, create a ! list of linked reflections; in the old code, this was done at the same time, but it appears ! it is better to decouple these two computations. In this new approach, we'll compute a much ! shorter linked list based on the incident wave vector direction. ! first, we deal with the transmitted beam gg = ( / 0 , 0 , 0 / ) call CalcUcg ( cell , rlp , gg , applyqgshift = . TRUE .) Dyn % Upz = rlp % Vpmod ! U'0 normal absorption parameter ! and add this reflection to the look-up table cell % LUT ( 0 , 0 , 0 ) = rlp % Ucg cell % LUTqg ( 0 , 0 , 0 ) = rlp % qg ! now do the same for the other allowed reflections ! note that the lookup table must be twice as large as the list of participating reflections, ! since the dynamical matrix uses g-h as its index !!! ixl : do ix =- 2 * imh , 2 * imh iyl : do iy =- 2 * imk , 2 * imk izl : do iz =- 2 * iml , 2 * iml gg = ( / ix , iy , iz / ) if ( IsGAllowed ( cell , gg )) then ! is this reflection allowed by lattice centering ? ! add the reflection to the look up table call CalcUcg ( cell , rlp , gg , applyqgshift = . TRUE .) cell % LUT ( ix , iy , iz ) = rlp % Ucg cell % LUTqg ( ix , iy , iz ) = rlp % qg ! flag this reflection as a double diffraction candidate if cabs(Ucg)<ddt threshold if ( cabs ( rlp % Ucg ). le . ddt ) then cell % dbdiff ( ix , iy , iz ) = . TRUE . end if end if ! IsGAllowed end do izl end do iyl end do ixl ! determine the point group number j = 0 do i = 1 , 32 if ( SGPG ( i ). le . cell % SYM_SGnum ) j = i end do isym = j ! here is new code dealing with all the special cases (quite a few more compared to the ! Laue group case)...  isym is the point group number. Once the symmetry case has been ! fully determined (taking into account things like 31m and 3m1 an such), then the only places ! that symmetry is handled are the modified Calckvectors routine, and the filling of the modified ! Lambert projections after the dynamical simulation step.  We are also changing the name of the ! sr array (or srhex) to mLPNH and mLPSH (modified Lambert Projection Northern/Southern Hemisphere). ! Here, we encode isym into a new number that describes the sampling scheme; the new schemes are ! described in detail in the EBSD manual pdf file. SamplingType = PGSamplingType ( isym ) ! next, intercept the special cases (hexagonal vs. rhombohedral cases that require special treatment) if (( SamplingType . eq . - 1 ). or .( isym . eq . 14 ). or .( isym . eq . 26 )) then SamplingType = getHexvsRho ( cell , isym ) end if ! if the point group is trigonal or hexagonal, we need to switch usehex to .TRUE. so that ! the program will use the hexagonal sampling method usehex = . FALSE . if (( cell % xtal_system . eq . 4 ). or .( cell % xtal_system . eq . 5 )) usehex = . TRUE . ! ---------- end of symmetry and crystallography section !============================================= !============================================= !============================================= !============================================= ! this is where we determine the value for the thickness integration limit for the CalcLgh3 routine... allocate ( EkeVs ( numEbins ), thick ( numEbins )) do i = 1 , numEbins EkeVs ( i ) = Ehistmin + float ( i - 1 ) * Ebinsize end do ! then, for each energy determine the 95% histogram thickness izzmax = 0 do iE = 1 , numEbins do ix =- nxten , nxten do iy =- nxten , nxten istat = sum ( accum_z ( iE ,:, ix , iy )) izz = 1 do while ( sum ( accum_z ( iE , 1 : izz , ix , iy )). lt .( 0.99 * istat )) izz = izz + 1 end do if ( izz . gt . izzmax ) izzmax = izz end do end do thick ( iE ) = dble ( izzmax ) * depthstep end do izz = nint ( maxval ( thick ) / depthstep ) allocate ( lambdaE ( 1 : numEbins , 1 : izz ), stat = istat ) do iE = 1 , numEbins do iz = 1 , izz lambdaE ( iE , iz ) = float ( sum ( accum_z ( iE , iz , - nxten : nxten , - nxten : nxten ))) / etotal end do end do ! ---------- end of 'read Monte Carlo output file and extract necessary parameters' section !============================================= !============================================= !============================================= !============================================= ! ---------- a couple of initializations numset = cell % ATOM_ntype npy = npx allocate ( svals ( numset ), stat = istat ) gzero = 1 ! index of incident beam debug = 0 ! no longer used ! ---------- !============================================= !============================================= !============================================= !============================================= ! ---------- allocate memory for the master patterns (done in calling program) ! allocate(mLPNH(-emnl%npx:emnl%npx,-npy:npy,1,1:numset),stat=istat) ! allocate(mLPSH(-emnl%npx:emnl%npx,-npy:npy,1,1:numset),stat=istat) ! set various arrays to zero mLPNH = 0.0 mLPSH = 0.0 ! force dynamical matrix routine to read new Bethe parameters from file ! this will all be changed with the new version of the Bethe potentials ! these parameters were already defined above, having been passed in ! from the external calling program !  call Set_Bethe_Parameters(BetheParameters) ! set the callback parameters dn = 1 cn = dn cn2 = 0 totn2 = Estart !============================================= !============================================= ! ---------- from here on, we need to repeat the entire computation for each energy value cancelerr = 0 energyloop : do iE = Estart , 1 , - 1 cn2 = cn2 + dn ! set the accelerating voltage skip = 3 cell % voltage = dble ( EkeVs ( iE )) call CalcWaveLength ( cell , rlp , skip ) !============================================= ! ---------- create the incident beam directions list ! determine all independent incident beam directions (use a linked list starting at khead) ! numk is the total number of k-vectors to be included in this computation; ! note that this needs to be redone for each energy, since the wave vector changes with energy nullify ( khead ) if ( usehex ) then call Calckvectors ( khead , cell , ( / 0.D0 , 0.D0 , 1.D0 / ), ( / 0.D0 , 0.D0 , 0.D0 / ), 0.D0 , npx , npy , numk , & SamplingType , ijmax , 'RoscaLambert' , usehex ) else call Calckvectors ( khead , cell , ( / 0.D0 , 0.D0 , 1.D0 / ), ( / 0.D0 , 0.D0 , 0.D0 / ), 0.D0 , npx , npy , numk , & SamplingType , ijmax , 'RoscaLambert' , usehex ) end if totn = numk cn = dn ! convert part of the kvector linked list into arrays for OpenMP allocate ( karray ( 4 , numk ), kij ( 3 , numk ), stat = istat ) ! point to the first beam direction ktmp => khead ! and loop through the list, keeping k, kn, and i,j karray ( 1 : 3 , 1 ) = sngl ( ktmp % k ( 1 : 3 )) karray ( 4 , 1 ) = sngl ( ktmp % kn ) kij ( 1 : 3 , 1 ) = ( / ktmp % i , ktmp % j , ktmp % hs / ) do ik = 2 , numk ktmp => ktmp % next karray ( 1 : 3 , ik ) = sngl ( ktmp % k ( 1 : 3 )) karray ( 4 , ik ) = sngl ( ktmp % kn ) kij ( 1 : 3 , ik ) = ( / ktmp % i , ktmp % j , ktmp % hs / ) end do ! and remove the linked list call Delete_kvectorlist ( khead ) verbose = . FALSE . totstrong = 0 totweak = 0 ! ---------- end of \"create the incident beam directions list\" !============================================= ! here's where we introduce the OpenMP calls, to spead up the overall calculations... ! set the number of OpenMP threads call OMP_SET_NUM_THREADS ( nthreads ) ! use OpenMP to run on multiple cores ... !$OMP PARALLEL COPYIN(rlp) & !$OMP& PRIVATE(DynMat,Sgh,Lgh,ik,FN,TID,kn,ipx,ipy,ix,iequiv,nequiv,reflist,firstw) & !$OMP& PRIVATE(kkk,nns,nnw,nref,svals,nat) SHARED(cancelerr) NUMTHREADS = OMP_GET_NUM_THREADS () TID = OMP_GET_THREAD_NUM () !$OMP DO SCHEDULE(DYNAMIC,100) ! ---------- and here we start the beam direction loop beamloop : do ik = 1 , numk !============================================= ! ---------- create the master reflection list for this beam direction ! Then we must determine the masterlist of reflections (also a linked list); ! This list basically samples a large reciprocal space volume; it does not ! distinguish between zero and higher order Laue zones, since that ! distinction becomes meaningless when we consider the complete ! reciprocal lattice. nullify ( reflist ) kkk = karray ( 1 : 3 , ik ) FN = kkk call Initialize_ReflectionList ( cell , reflist , BetheParameters , FN , kkk , sngl ( dmin ), nref ) ! ---------- end of \"create the master reflection list\" !============================================= ! determine strong and weak reflections nullify ( firstw ) nns = 0 nnw = 0 call Apply_BethePotentials ( cell , reflist , firstw , BetheParameters , nref , nns , nnw ) ! generate the dynamical matrix allocate ( DynMat ( nns , nns )) call GetDynMat ( cell , reflist , firstw , rlp , DynMat , nns , nnw ) totstrong = totstrong + nns totweak = totweak + nnw ! then we need to initialize the Sgh and Lgh arrays if ( allocated ( Sgh )) deallocate ( Sgh ) if ( allocated ( Lgh )) deallocate ( Lgh ) allocate ( Sgh ( nns , nns , numset ), Lgh ( nns , nns )) Sgh = czero Lgh = czero nat = 0 call CalcSgh ( cell , reflist , nns , numset , Sgh , nat ) ! solve the dynamical eigenvalue equation for this beam direction kn = karray ( 4 , ik ) call CalcLgh ( DynMat , Lgh , dble ( thick ( iE )), dble ( kn ), nns , gzero , depthstep , lambdaE ( iE , 1 : izzmax ), izzmax ) deallocate ( DynMat ) ! sum over the element-wise (Hadamard) product of the Lgh and Sgh arrays svals = 0.0 do ix = 1 , numset svals ( ix ) = real ( sum ( Lgh ( 1 : nns , 1 : nns ) * Sgh ( 1 : nns , 1 : nns , ix ))) end do svals = svals / float ( sum ( nat ( 1 : numset ))) ! and store the resulting svals values, applying point group symmetry where needed. ipx = kij ( 1 , ik ) ipy = kij ( 2 , ik ) ipz = kij ( 3 , ik ) ! if ( usehex ) then call Apply3DPGSymmetry ( cell , ipx , ipy , ipz , npx , iequiv , nequiv , usehex ) else if (( cell % SYM_SGnum . ge . 195 ). and .( cell % SYM_SGnum . le . 230 )) then call Apply3DPGSymmetry ( cell , ipx , ipy , ipz , npx , iequiv , nequiv , cubictype = SamplingType ) else call Apply3DPGSymmetry ( cell , ipx , ipy , ipz , npx , iequiv , nequiv ) end if end if !$OMP CRITICAL do ix = 1 , nequiv if ( iequiv ( 3 , ix ). eq . - 1 ) mLPSH ( iequiv ( 1 , ix ), iequiv ( 2 , ix ), iE , 1 : numset ) = svals ( 1 : numset ) if ( iequiv ( 3 , ix ). eq . 1 ) mLPNH ( iequiv ( 1 , ix ), iequiv ( 2 , ix ), iE , 1 : numset ) = svals ( 1 : numset ) end do !$OMP END CRITICAL call Delete_gvectorlist ( reflist ) ! has the cancel flag been set by the calling program ? !!!!$OMP CANCELLATION POINT if ( cancel . ne . char ( 0 )) then !$OMP ATOMIC WRITE cancelerr = 1 !$OMP CANCEL DO end if ! update the progress counter and report it to the calling program via the proc callback routine !$OMP CRITICAL if ( objAddress . ne . 0 ) then cn = cn + dn if ( mod ( cn , 1000 ). eq . 0 ) then call proc ( objAddress , cn , totn , cn2 , totn2 ) end if end if !$OMP END CRITICAL end do beamloop ! end of OpenMP portion !$OMP END PARALLEL ! was the Cancel button pressed in the calling program? if ( cancelerr . ne . 0 ) EXIT energyloop deallocate ( karray , kij ) if ( usehex ) then ! and finally, we convert the hexagonally sampled array to a square Lambert projection which will be used ! for all EBSD pattern interpolations;  we need to do this for both the Northern and Southern hemispheres ! we begin by allocating auxiliary arrays to hold copies of the hexagonal data; the original arrays will ! then be overwritten with the newly interpolated data. allocate ( auxNH ( - npx : npx , - npy : npy , 1 : numset ), stat = istat ) allocate ( auxSH ( - npx : npx , - npy : npy , 1 : numset ), stat = istat ) auxNH = mLPNH ( - npx : npx , - npy : npy , iE , 1 : numset ) auxSH = mLPSH ( - npx : npx , - npy : npy , iE , 1 : numset ) ! edge = 1.D0 / dble ( npx ) scl = float ( npx ) do i =- npx , npx do j =- npy , npy ! determine the spherical direction for this point xy = ( / dble ( i ), dble ( j ) / ) * edge dc = LambertSquareToSphere ( xy , ierr ) ! convert direction cosines to hexagonal Lambert projections xy = scl * LambertSphereToHex ( dc , ierr ) ! interpolate intensity from the neighboring points if ( ierr . eq . 0 ) then nix = floor ( xy ( 1 )) niy = floor ( xy ( 2 )) nixp = nix + 1 niyp = niy + 1 if ( nixp . gt . npx ) nixp = nix if ( niyp . gt . npx ) niyp = niy dx = xy ( 1 ) - nix dy = xy ( 2 ) - niy dxm = 1.D0 - dx dym = 1.D0 - dy mLPNH ( i , j , iE , 1 : numset ) = auxNH ( nix , niy , 1 : numset ) * dxm * dym + auxNH ( nixp , niy , 1 : numset ) * dx * dym + & auxNH ( nix , niyp , 1 : numset ) * dxm * dy + auxNH ( nixp , niyp , 1 : numset ) * dx * dy mLPSH ( i , j , iE , 1 : numset ) = auxSH ( nix , niy , 1 : numset ) * dxm * dym + auxSH ( nixp , niy , 1 : numset ) * dx * dym + & auxSH ( nix , niyp , 1 : numset ) * dxm * dy + auxSH ( nixp , niyp , 1 : numset ) * dx * dy end if end do end do deallocate ( auxNH , auxSH ) end if ! make sure that the outer pixel rim of the mLPSH patterns is identical to ! that of the mLPNH array. mLPSH ( - npx , - npx : npx , iE , 1 : numset ) = mLPNH ( - npx , - npx : npx , iE , 1 : numset ) mLPSH ( npx , - npx : npx , iE , 1 : numset ) = mLPNH ( npx , - npx : npx , iE , 1 : numset ) mLPSH ( - npx : npx , - npx , iE , 1 : numset ) = mLPNH ( - npx : npx , - npx , iE , 1 : numset ) mLPSH ( - npx : npx , npx , iE , 1 : numset ) = mLPNH ( - npx : npx , npx , iE , 1 : numset ) end do energyloop ! that's the end of it... end subroutine EMsoftCgetEBSDmaster","tags":"","loc":"proc/emsoftcgetebsdmaster.html","title":"EMsoftCgetEBSDmaster – Fortran Program"},{"text":"public recursive subroutine getEBSDPatterns(ipar, fpar, EBSDpattern, quats, accum_e, mLPNH, mLPSH) Uses: local constants Lambert quaternions iso_c_binding proc~~getebsdpatterns~~UsesGraph proc~getebsdpatterns getEBSDPatterns Lambert Lambert Lambert->proc~getebsdpatterns iso_c_binding iso_c_binding iso_c_binding->proc~getebsdpatterns local local local->proc~getebsdpatterns module~constants constants local->module~constants quaternions quaternions quaternions->proc~getebsdpatterns module~constants->proc~getebsdpatterns Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief This function can be called as a standalone function to compute an EBSD pattern\n @etails The main purpose of this routine and its accompanying wrapper routine is to\n provide a way for an external program to compute a channeling pattern.  The idea is that \n all the necessary arrays and variables are passed in by reference as arguments, without\n the need for the routine to fetch any other data from files etc...  The initial goal is\n to have a function that can be called with the CALL_EXTERNAL mechanism in IDL or MatLab.\n This routine should be called via the getEBSDPatternsWrapper routine!  For calls from\n a C/C++ program, use the EMsoftCgetEBSDPatterns routine instead.\n @param ipar array with integer input parameters\n @param fpar array with float input parameters\n @param EBSDpattern output array\n @param quats quaternion input array\n @param accum_e array with Monte Carlo histogram\n @param mLPNH Northern hemisphere master pattern\n @param mLPSH Southern hemisphere master pattern\n @date 10/16/15 MDG 1.0 original\n @date 11/02/15 MDG 1.1 simplification of the input variables\n @date 11/04/15 MDG 1.2 added array of quaternions as input parameter; used complete mLPNH/SH arrays with local sum\n @date 01/12/15 MDG 1.3 added arguments and functionality for interface with DREAM.3D and other calling programs\n @date 01/13/15 MDG 1.4 after split with EMsoftCgetEBSDPatterns subroutine, removed DREAM.3D interfacing stuff\n @date 07/10/16 MDG 1.5 added energy min/max parameters\n @date 08/03/16 MDG 1.6 corrected normalizing issue in rgx,y,z arrays that causes NANs to be returned from Lambert projection routines\n @date 08/R2516 MDG 1.7 added transfer optics barrel distortion to rgx,y,z arrays. Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in) :: ipar (nipar) real(kind=sgl), intent(in) :: fpar (nfpar) real(kind=sgl), intent(out) :: EBSDpattern (ipar(2),ipar(3),ipar(8)) real(kind=sgl), intent(in) :: quats (nq,ipar(8)) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(4),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(4),ipar(7)) Calls proc~~getebsdpatterns~~CallsGraph proc~getebsdpatterns getEBSDPatterns float float proc~getebsdpatterns->float quat_lp quat_lp proc~getebsdpatterns->quat_lp lambertspheretosquare lambertspheretosquare proc~getebsdpatterns->lambertspheretosquare sngl sngl proc~getebsdpatterns->sngl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~getebsdpatterns~~CalledByGraph proc~getebsdpatterns getEBSDPatterns proc~ebsd4calfun EBSD4calfun proc~ebsd4calfun->proc~getebsdpatterns proc~getebsdpatternswrapper getEBSDPatternsWrapper proc~getebsdpatternswrapper->proc~getebsdpatterns proc~ebsdcalfun EBSDcalfun proc~ebsdcalfun->proc~getebsdpatterns Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getEBSDPatterns Source Code recursive subroutine getEBSDPatterns ( ipar , fpar , EBSDpattern , quats , accum_e , mLPNH , mLPSH ) !DEC$ ATTRIBUTES DLLEXPORT :: getEBSDPatterns ! the input parameters are all part of a ipar and fpar input arrays instead of the usual namelist structure to ! make this routine callable by external programs; for calls from  C/C++, use the EsoftCgetEBSDPatterns routine instead. ! The following is the mapping for the ipar and fpar arrays: ! ! ipar(1) = 2 if rgx, rgy, rgz detector arrays need to be computed, 1 if not (arrays will have save status) ! ipar(2) = detnumsx ! ipar(3) = detnumsy ! ipar(4) = detnumEbins ! ipar(5) = mcnsx ! ipar(6) = mpnpx ! ipar(7) = numset ! ipar(8) = numquats ! ipar(9) = Eminsel ! ipar(10) = Emaxsel ! fpar(1) = enl%xpc ! fpar(2) = enl%ypc ! fpar(3) = enl%delta ! fpar(4) = enl%MCsig ! fpar(5) = enl%omega ! fpar(6) = enl%thetac ! fpar(7) = enl%L ! fpar(8) = enl%beamcurrent ! fpar(9) = enl%dwelltime ! fpar(10) = enl%alphaBD use local use constants use Lambert use quaternions use , INTRINSIC :: ISO_C_BINDING IMPLICIT NONE integer ( c_size_t ), PARAMETER :: nipar = 10 integer ( c_size_t ), PARAMETER :: nfpar = 10 integer ( c_size_t ), PARAMETER :: nq = 4 integer ( c_size_t ), INTENT ( IN ) :: ipar ( nipar ) real ( kind = sgl ), INTENT ( IN ) :: fpar ( nfpar ) real ( kind = sgl ), INTENT ( IN ) :: quats ( nq , ipar ( 8 )) real ( kind = sgl ), INTENT ( IN ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( kind = sgl ), INTENT ( IN ) :: mLPNH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 4 ), ipar ( 7 )) real ( kind = sgl ), INTENT ( IN ) :: mLPSH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 4 ), ipar ( 7 )) real ( kind = sgl ), INTENT ( OUT ) :: EBSDpattern ( ipar ( 2 ), ipar ( 3 ), ipar ( 8 )) ! variables that must potentially be saved for the next time this function is called real ( kind = sgl ), allocatable , save :: accum_e_detector (:,:,:) real ( kind = sgl ), allocatable , save :: rgx (:,:), rgy (:,:), rgz (:,:) real ( kind = sgl ), allocatable , save :: mLPNHsum (:,:,:), mLPSHsum (:,:,:) real ( kind = sgl ), save :: prefactor ! other variables real ( kind = sgl ), allocatable :: scin_x (:), scin_y (:) ! scintillator coordinate arrays [microns] real ( kind = sgl ), parameter :: dtor = 0.0174533 ! convert from degrees to radians real ( kind = sgl ) :: alp , ca , sa , cw , sw real ( kind = sgl ) :: L2 , Ls , Lc , pcxd , pcyd , xx , yy ! distances integer ( kind = irg ) :: nix , niy , binx , biny , nixp , niyp , i , j , Emin , Emax , istat , k , ip , ipx , ipy ! various parameters real ( kind = sgl ) :: dc ( 3 ), scl , alpha , theta , gam , pcvec ( 3 ), dp , calpha ! direction cosine array real ( kind = sgl ) :: sx , dx , dxm , dy , dym , rhos , x , bindx ! various parameters real ( kind = sgl ) :: ixy ( 2 ) real ( kind = dbl ), parameter :: nAmpere = 6.241D+18 !==================================== ! ------ generate the detector rgx, rgy, rgz arrays if needed (calling program must decide this via ipar(1)) !==================================== if ( ipar ( 1 ). ge . 1 ) then if (( ipar ( 1 ). eq . 2 ). or .(. not . allocated ( mLPNHsum ))) then ! complete reset, including the mLPNHsum and mLPSHsum arrays if ( allocated ( mLPNHsum )) deallocate ( mLPNHsum ) if ( allocated ( mLPSHsum )) deallocate ( mLPSHsum ) allocate ( mLPNHsum ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 4 ))) allocate ( mLPSHsum ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 4 ))) mLPNHsum = sum ( mLPNH , 4 ) mLPSHsum = sum ( mLPSH , 4 ) end if ! This needs to be done only once for a given detector geometry (i.e., when ipar(1)=1 or larger) allocate ( scin_x ( ipar ( 2 )), scin_y ( ipar ( 3 )), stat = istat ) pcxd = fpar ( 1 ) * fpar ( 3 ) pcyd = fpar ( 2 ) * fpar ( 3 ) scin_x = - ( fpar ( 1 ) - ( 1.0 - float ( ipar ( 2 )) ) * 0.5 - ( / ( i - 1 , i = 1 , ipar ( 2 )) / ) ) * fpar ( 3 ) scin_y = ( fpar ( 2 ) - ( 1.0 - float ( ipar ( 3 )) ) * 0.5 - ( / ( i - 1 , i = 1 , ipar ( 3 )) / ) ) * fpar ( 3 ) ! auxiliary angle to rotate between reference frames alp = 0.5 * cPi - ( fpar ( 4 ) - fpar ( 6 )) * dtor ca = cos ( alp ) sa = sin ( alp ) cw = cos ( fpar ( 5 ) * dtor ) sw = sin ( fpar ( 5 ) * dtor ) ! compute auxilliary interpolation arrays if ( allocated ( rgx )) deallocate ( rgx , rgy , rgz ) allocate ( rgx ( ipar ( 2 ), ipar ( 3 )), rgy ( ipar ( 2 ), ipar ( 3 )), rgz ( ipar ( 2 ), ipar ( 3 ))) ! do we need to perform a Barrel Distortion? ! we will do this here by expanding/contracting the radial component of the ! (rgx, rgy) to (rgx,rgy) * (1+alphaBD * (rgx&#94;2+rgy&#94;2)) ! in other words, we pre-distort the sampling grid with the barrel distortion. L2 = fpar ( 7 ) * fpar ( 7 ) do j = 1 , ipar ( 2 ) Ls = - sw * scin_x ( j ) + fpar ( 7 ) * cw Lc = cw * scin_x ( j ) + fpar ( 7 ) * sw do i = 1 , ipar ( 3 ) !    rhos = 1.0/sqrt(sx + scin_y(i)**2) rgx ( j , i ) = ( scin_y ( i ) * ca + sa * Ls ) ! * rhos rgy ( j , i ) = Lc ! * rhos rgz ( j , i ) = ( - sa * scin_y ( i ) + ca * Ls ) ! * rhos ! apply Barrel Distortion ? if ( fpar ( 10 ). ne . 0.0 ) then ! shift the components to the detector center coordinate frame xx = rgx ( j , i ) - pcyd yy = rgy ( j , i ) + pcxd ! compute the distortion amount; the factor of 10&#94;(-10) is inserted here... sx = 1.0 + 1.E-10 * fpar ( 10 ) * ( xx ** 2 + yy ** 2 ) ! and shift them back to the pattern center reference frame rgx ( j , i ) = xx * sx + pcyd rgy ( j , i ) = yy * sx - pcxd end if ! make sure that these vectors are normalized ! x = sqrt ( rgx ( j , i ) ** 2 + rgy ( j , i ) ** 2 + rgz ( j , i ) ** 2 ) rgx ( j , i ) = rgx ( j , i ) / x rgy ( j , i ) = rgy ( j , i ) / x rgz ( j , i ) = rgz ( j , i ) / x end do end do ! test dump of rgx/y/z arrays to check for proper inclusion of barrel distortion: !open(unit=dataunit,file='rgxyz.data',status='unknown',form='unformatted') !write(dataunit) rgx !write(dataunit) rgy !write(dataunit) rgz !close(unit=dataunit,status='keep') ! remove the auxiliary arrays scin_x and scin_y deallocate ( scin_x , scin_y ) !==================================== ! ------ create the equivalent detector energy array !==================================== ! from the Monte Carlo energy data, we need to extract the relevant ! entries for the detector geometry defined above. ! determine the scale factor for the Lambert interpolation; the square has ! an edge length of 2 x sqrt(pi/2) scl = float ( ipar ( 5 )) ! energy summation will go over all energy bins Emin = ipar ( 9 ) Emax = ipar ( 10 ) if ( allocated ( accum_e_detector )) deallocate ( accum_e_detector ) allocate ( accum_e_detector ( ipar ( 4 ), ipar ( 2 ), ipar ( 3 ))) ! correction of change in effective pixel area compared to equal-area Lambert projection alpha = atan ( fpar ( 3 ) / fpar ( 7 ) / sqrt ( sngl ( cPi ))) ipx = ipar ( 2 ) / 2 + nint ( fpar ( 1 )) ipy = ipar ( 3 ) / 2 + nint ( fpar ( 2 )) if (( abs ( ipy ). gt . ipar ( 3 )). or .( abs ( ipx ). gt . ipar ( 2 ))) then pcvec = ( / pcyd * ca + pcxd * sa * sw + fpar ( 7 ) * cw * sa , & fpar ( 7 ) * sw - pcxd * cw ,& fpar ( 7 ) * ca * cw + pcxd * ca * sw - pcyd * sa / ) pcvec = pcvec / NORM2 ( pcvec ) else pcvec = ( / rgx ( ipx , ipy ), rgy ( ipx , ipy ), rgz ( ipx , ipy ) / ) end if calpha = cos ( alpha ) do i = 1 , ipar ( 2 ) do j = 1 , ipar ( 3 ) ! do the coordinate transformation for this detector pixel dc = ( / rgx ( i , j ), rgy ( i , j ), rgz ( i , j ) / ) ! make sure the third one is positive; if not, switch all if ( dc ( 3 ). lt . 0.0 ) dc = - dc ! convert these direction cosines to coordinates in the Rosca-Lambert projection ixy = scl * LambertSphereToSquare ( dc , istat ) x = ixy ( 1 ) ixy ( 1 ) = ixy ( 2 ) ixy ( 2 ) = - x ! four-point interpolation (bi-quadratic) nix = int ( ipar ( 5 ) + ixy ( 1 )) - ipar ( 5 ) niy = int ( ipar ( 5 ) + ixy ( 2 )) - ipar ( 5 ) nixp = nix + 1 niyp = niy + 1 if ( nix . gt . ipar ( 5 )) nix = ipar ( 5 ) if ( niy . gt . ipar ( 5 )) niy = ipar ( 5 ) if ( nix . lt . - ipar ( 5 )) nix = - ipar ( 5 ) if ( niy . lt . - ipar ( 5 )) niy = - ipar ( 5 ) if ( nixp . gt . ipar ( 5 )) nixp = ipar ( 5 ) if ( niyp . gt . ipar ( 5 )) niyp = ipar ( 5 ) if ( nixp . lt . - ipar ( 5 )) nixp = - ipar ( 5 ) if ( niyp . lt . - ipar ( 5 )) niyp = - ipar ( 5 ) dx = ixy ( 1 ) - nix dy = ixy ( 2 ) - niy dxm = 1.0 - dx dym = 1.0 - dy ! do the area correction for this detector pixel dp = dot_product ( pcvec , dc ) if (( i . eq . ipx ). and .( j . eq . ipy )) then gam = 0.25 else gam = (( calpha * calpha + dp * dp - 1.0 ) ** 1.5 ) / ( calpha ** 3 ) * 0.25 end if ! interpolate the intensity do k = Emin , Emax accum_e_detector ( k , i , j ) = gam * ( accum_e ( k , nix , niy ) * dxm * dym + & accum_e ( k , nixp , niy ) * dx * dym + & accum_e ( k , nix , niyp ) * dxm * dy + & accum_e ( k , nixp , niyp ) * dx * dy ) end do end do end do prefactor = 0.25D0 * nAmpere * fpar ( 8 ) * fpar ( 9 ) * 1.0D-15 / sum ( accum_e_detector ) end if ! end of ipar(1)=1 test !open(unit=dataunit,file='TKDdetectorarray_dymod.data',status='unknown',form='unformatted') !write(dataunit) accum_e_detector !close(unit=dataunit,status='keep') ! from here on, we simply compute the EBSD patterns by interpolation, using the saved arrays from above ! no intensity scaling or anything else...other than multiplication by pre-factor ! intensity scaling is left to the user of the calling program. ! define some parameters and initialize EBSDpattern scl = dble ( ipar ( 6 )) EBSDpattern = 0.0 ! here is the main loop over all quaternions quatloop : do ip = 1 , ipar ( 8 ) do i = 1 , ipar ( 2 ) do j = 1 , ipar ( 3 ) ! do the active coordinate transformation for this euler angle dc = quat_Lp ( quats ( 1 : 4 , ip ), ( / rgx ( i , j ), rgy ( i , j ), rgz ( i , j ) / ) ) ! normalize dc dc = dc / sqrt ( sum ( dc * dc )) ! convert these direction cosines to coordinates in the Rosca-Lambert projection (always square projection !!!) ixy = scl * LambertSphereToSquare ( dc , istat ) if ( istat . eq . 0 ) then ! four-point interpolation (bi-quadratic) nix = int ( ipar ( 6 ) + ixy ( 1 )) - ipar ( 6 ) niy = int ( ipar ( 6 ) + ixy ( 2 )) - ipar ( 6 ) nixp = nix + 1 niyp = niy + 1 if ( nix . gt . ipar ( 6 )) nix = ipar ( 6 ) if ( niy . gt . ipar ( 6 )) niy = ipar ( 6 ) if ( nix . lt . - ipar ( 6 )) nix = - ipar ( 6 ) if ( niy . lt . - ipar ( 6 )) niy = - ipar ( 6 ) if ( nixp . gt . ipar ( 6 )) nixp = ipar ( 6 ) if ( niyp . gt . ipar ( 6 )) niyp = ipar ( 6 ) if ( nixp . lt . - ipar ( 6 )) nixp = - ipar ( 6 ) if ( niyp . lt . - ipar ( 6 )) niyp = - ipar ( 6 ) dx = ixy ( 1 ) - nix dy = ixy ( 2 ) - niy dxm = 1.0 - dx dym = 1.0 - dy if ( dc ( 3 ). gt . 0.0 ) then ! we're in the Northern hemisphere do k = Emin , Emax EBSDpattern ( i , j , ip ) = EBSDpattern ( i , j , ip ) + accum_e_detector ( k , i , j ) * ( mLPNHsum ( nix , niy , k ) * dxm * dym + & mLPNHsum ( nixp , niy , k ) * dx * dym + mLPNHsum ( nix , niyp , k ) * dxm * dy + & mLPNHsum ( nixp , niyp , k ) * dx * dy ) end do else ! we're in the Southern hemisphere do k = Emin , Emax EBSDpattern ( i , j , ip ) = EBSDpattern ( i , j , ip ) + accum_e_detector ( k , i , j ) * ( mLPSHsum ( nix , niy , k ) * dxm * dym + & mLPSHsum ( nixp , niy , k ) * dx * dym + mLPSHsum ( nix , niyp , k ) * dxm * dy + & mLPSHsum ( nixp , niyp , k ) * dx * dy ) end do end if end if end do end do end do quatloop ! finally, scale the patterns by the appropriate factor and return to the calling program EBSDpattern = prefactor * EBSDpattern end subroutine getEBSDPatterns","tags":"","loc":"proc/getebsdpatterns.html","title":"getEBSDPatterns – Fortran Program"},{"text":"public recursive subroutine getEBSDPatterns2(ipar, fpar, EBSDpattern, quats, accum_e, mLPNHsum, mLPSHsum) Uses: local constants Lambert quaternions iso_c_binding proc~~getebsdpatterns2~~UsesGraph proc~getebsdpatterns2 getEBSDPatterns2 Lambert Lambert Lambert->proc~getebsdpatterns2 iso_c_binding iso_c_binding iso_c_binding->proc~getebsdpatterns2 local local local->proc~getebsdpatterns2 module~constants constants local->module~constants quaternions quaternions quaternions->proc~getebsdpatterns2 module~constants->proc~getebsdpatterns2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief This function can be called as a standalone function to compute an EBSD pattern\n @etails The main purpose of this routine and its accompanying wrapper routine is to\n provide a way for an external program to compute a channeling pattern.  The idea is that \n all the necessary arrays and variables are passed in by reference as arguments, without\n the need for the routine to fetch any other data from files etc...  The initial goal is\n to have a function that can be called with the CALL_EXTERNAL mechanism in IDL or MatLab.\n This routine should be called via the getEBSDPatternsWrapper routine!  For calls from\n a C/C++ program, use the EMsoftCgetEBSDPatterns routine instead.  This routine is a slightly\n modified version of the regular getEBSDPatterns routine and does not SAVE any variables.\n @param ipar array with integer input parameters\n @param fpar array with float input parameters\n @param EBSDpattern output array\n @param quats quaternion input array\n @param accum_e array with Monte Carlo histogram\n @param mLPNH Northern hemisphere master pattern\n @param mLPSH Southern hemisphere master pattern\n @date 10/16/15 MDG 1.0 original\n @date 11/02/15 MDG 1.1 simplification of the input variables\n @date 11/04/15 MDG 1.2 added array of quaternions as input parameter; used complete mLPNH/SH arrays with local sum\n @date 01/12/15 MDG 1.3 added arguments and functionality for interface with DREAM.3D and other calling programs\n @date 01/13/15 MDG 1.4 after split with EMsoftCgetEBSDPatterns subroutine, removed DREAM.3D interfacing stuff\n @date 07/10/16 MDG 1.5 added energy min/max parameters\n @date 08/03/16 MDG 1.6 corrected normalizing issue in rgx,y,z arrays that causes NANs to be returned from Lambert projection routines\n @date 08/25/16 MDG 1.7 added transfer optics barrel distortion to rgx,y,z arrays.\n @date 04/24/17 MDG 1.8 forked from original routine without SAVEd variables Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in) :: ipar (nipar) real(kind=sgl), intent(in) :: fpar (nfpar) real(kind=sgl), intent(out) :: EBSDpattern (ipar(2),ipar(3),ipar(8)) real(kind=sgl), intent(in) :: quats (nq,ipar(8)) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNHsum (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(4)) real(kind=sgl), intent(in) :: mLPSHsum (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(4)) Calls proc~~getebsdpatterns2~~CallsGraph proc~getebsdpatterns2 getEBSDPatterns2 float float proc~getebsdpatterns2->float quat_lp quat_lp proc~getebsdpatterns2->quat_lp lambertspheretosquare lambertspheretosquare proc~getebsdpatterns2->lambertspheretosquare sngl sngl proc~getebsdpatterns2->sngl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getEBSDPatterns2 Source Code recursive subroutine getEBSDPatterns2 ( ipar , fpar , EBSDpattern , quats , accum_e , mLPNHsum , mLPSHsum ) !DEC$ ATTRIBUTES DLLEXPORT :: getEBSDPatterns2 ! the input parameters are all part of a ipar and fpar input arrays instead of the usual namelist structure to ! make this routine callable by external programs; for calls from  C/C++, use the EsoftCgetEBSDPatterns routine instead. ! The following is the mapping for the ipar and fpar arrays: ! ! ipar(1) = 2 if rgx, rgy, rgz detector arrays need to be computed, 1 if not (arrays will have save status) ! ipar(2) = detnumsx ! ipar(3) = detnumsy ! ipar(4) = detnumEbins ! ipar(5) = mcnsx ! ipar(6) = mpnpx ! ipar(7) = numset ! ipar(8) = numquats ! ipar(9) = Eminsel ! ipar(10) = Emaxsel ! fpar(1) = enl%xpc ! fpar(2) = enl%ypc ! fpar(3) = enl%delta ! fpar(4) = enl%MCsig ! fpar(5) = enl%omega ! fpar(6) = enl%thetac ! fpar(7) = enl%L ! fpar(8) = enl%beamcurrent ! fpar(9) = enl%dwelltime ! fpar(10) = enl%alphaBD use local use constants use Lambert use quaternions use , INTRINSIC :: ISO_C_BINDING IMPLICIT NONE integer ( c_size_t ), PARAMETER :: nipar = 10 integer ( c_size_t ), PARAMETER :: nfpar = 10 integer ( c_size_t ), PARAMETER :: nq = 4 integer ( c_size_t ), INTENT ( IN ) :: ipar ( nipar ) real ( kind = sgl ), INTENT ( IN ) :: fpar ( nfpar ) real ( kind = sgl ), INTENT ( IN ) :: quats ( nq , ipar ( 8 )) real ( kind = sgl ), INTENT ( IN ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( kind = sgl ), INTENT ( IN ) :: mLPNHsum ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 4 )) real ( kind = sgl ), INTENT ( IN ) :: mLPSHsum ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 4 )) real ( kind = sgl ), INTENT ( OUT ) :: EBSDpattern ( ipar ( 2 ), ipar ( 3 ), ipar ( 8 )) ! allocatable variables real ( kind = sgl ), allocatable :: accum_e_detector (:,:,:) real ( kind = sgl ), allocatable :: rgx (:,:), rgy (:,:), rgz (:,:) real ( kind = sgl ), save :: prefactor ! other variables real ( kind = sgl ), allocatable :: scin_x (:), scin_y (:) ! scintillator coordinate arrays [microns] real ( kind = sgl ), parameter :: dtor = 0.0174533 ! convert from degrees to radians real ( kind = sgl ) :: alp , ca , sa , cw , sw real ( kind = sgl ) :: L2 , Ls , Lc , pcxd , pcyd , xx , yy ! distances integer ( kind = irg ) :: nix , niy , binx , biny , nixp , niyp , i , j , Emin , Emax , istat , k , ip , ipx , ipy ! various parameters real ( kind = sgl ) :: dc ( 3 ), scl , alpha , theta , gam , pcvec ( 3 ), dp , calpha ! direction cosine array real ( kind = sgl ) :: sx , dx , dxm , dy , dym , rhos , x , bindx ! various parameters real ( kind = sgl ) :: ixy ( 2 ) real ( kind = dbl ), parameter :: nAmpere = 6.241D+18 !==================================== ! ------ generate the detector rgx, rgy, rgz arrays !==================================== ! This needs to be done only once for a given detector geometry (i.e., when ipar(1)=1 or larger) allocate ( scin_x ( ipar ( 2 )), scin_y ( ipar ( 3 )), stat = istat ) pcxd = fpar ( 1 ) * fpar ( 3 ) pcyd = fpar ( 2 ) * fpar ( 3 ) scin_x = - ( fpar ( 1 ) - ( 1.0 - float ( ipar ( 2 )) ) * 0.5 - ( / ( i - 1 , i = 1 , ipar ( 2 )) / ) ) * fpar ( 3 ) scin_y = ( fpar ( 2 ) - ( 1.0 - float ( ipar ( 3 )) ) * 0.5 - ( / ( i - 1 , i = 1 , ipar ( 3 )) / ) ) * fpar ( 3 ) ! auxiliary angle to rotate between reference frames alp = 0.5 * cPi - ( fpar ( 4 ) - fpar ( 6 )) * dtor ca = cos ( alp ) sa = sin ( alp ) cw = cos ( fpar ( 5 ) * dtor ) sw = sin ( fpar ( 5 ) * dtor ) ! compute auxilliary interpolation arrays allocate ( rgx ( ipar ( 2 ), ipar ( 3 )), rgy ( ipar ( 2 ), ipar ( 3 )), rgz ( ipar ( 2 ), ipar ( 3 ))) ! do we need to perform a Barrel Distortion? ! we will do this here by expanding/contracting the radial component of the ! (rgx, rgy) to (rgx,rgy) * (1+alphaBD * (rgx&#94;2+rgy&#94;2)) ! in other words, we pre-distort the sampling grid with the barrel distortion. L2 = fpar ( 7 ) * fpar ( 7 ) do j = 1 , ipar ( 2 ) Ls = - sw * scin_x ( j ) + fpar ( 7 ) * cw Lc = cw * scin_x ( j ) + fpar ( 7 ) * sw do i = 1 , ipar ( 3 ) !    rhos = 1.0/sqrt(sx + scin_y(i)**2) rgx ( j , i ) = ( scin_y ( i ) * ca + sa * Ls ) ! * rhos rgy ( j , i ) = Lc ! * rhos rgz ( j , i ) = ( - sa * scin_y ( i ) + ca * Ls ) ! * rhos ! apply Barrel Distortion ? if ( fpar ( 10 ). ne . 0.0 ) then ! shift the components to the detector center coordinate frame xx = rgx ( j , i ) - pcyd yy = rgy ( j , i ) + pcxd ! compute the distortion amount; the factor of 10&#94;(-10) is inserted here... sx = 1.0 + 1.E-10 * fpar ( 10 ) * ( xx ** 2 + yy ** 2 ) ! and shift them back to the pattern center reference frame rgx ( j , i ) = xx * sx + pcyd rgy ( j , i ) = yy * sx - pcxd end if ! make sure that these vectors are normalized ! x = sqrt ( rgx ( j , i ) ** 2 + rgy ( j , i ) ** 2 + rgz ( j , i ) ** 2 ) rgx ( j , i ) = rgx ( j , i ) / x rgy ( j , i ) = rgy ( j , i ) / x rgz ( j , i ) = rgz ( j , i ) / x end do end do ! remove the auxiliary arrays scin_x and scin_y deallocate ( scin_x , scin_y ) !==================================== ! ------ create the equivalent detector energy array !==================================== ! from the Monte Carlo energy data, we need to extract the relevant ! entries for the detector geometry defined above. ! determine the scale factor for the Lambert interpolation; the square has ! an edge length of 2 x sqrt(pi/2) scl = float ( ipar ( 5 )) ! energy summation will go over all energy bins Emin = ipar ( 9 ) Emax = ipar ( 10 ) allocate ( accum_e_detector ( ipar ( 4 ), ipar ( 2 ), ipar ( 3 ))) ! correction of change in effective pixel area compared to equal-area Lambert projection alpha = atan ( fpar ( 3 ) / fpar ( 7 ) / sqrt ( sngl ( cPi ))) ipx = ipar ( 2 ) / 2 + nint ( fpar ( 1 )) ipy = ipar ( 3 ) / 2 + nint ( fpar ( 2 )) if ( ipx . gt . ipar ( 2 )) ipx = ipar ( 2 ) if ( ipx . lt . 1 ) ipx = 1 if ( ipy . gt . ipar ( 3 )) ipy = ipar ( 3 ) if ( ipy . lt . 1 ) ipy = 1 pcvec = ( / rgx ( ipx , ipy ), rgy ( ipx , ipy ), rgz ( ipx , ipy ) / ) calpha = cos ( alpha ) do i = 1 , ipar ( 2 ) do j = 1 , ipar ( 3 ) ! do the coordinate transformation for this detector pixel dc = ( / rgx ( i , j ), rgy ( i , j ), rgz ( i , j ) / ) ! make sure the third one is positive; if not, switch all if ( dc ( 3 ). lt . 0.0 ) dc = - dc ! convert these direction cosines to coordinates in the Rosca-Lambert projection ixy = scl * LambertSphereToSquare ( dc , istat ) x = ixy ( 1 ) ixy ( 1 ) = ixy ( 2 ) ixy ( 2 ) = - x ! four-point interpolation (bi-quadratic) nix = int ( ipar ( 5 ) + ixy ( 1 )) - ipar ( 5 ) niy = int ( ipar ( 5 ) + ixy ( 2 )) - ipar ( 5 ) nixp = nix + 1 niyp = niy + 1 if ( nix . gt . ipar ( 5 )) nix = ipar ( 5 ) if ( niy . gt . ipar ( 5 )) niy = ipar ( 5 ) if ( nix . lt . - ipar ( 5 )) nix = - ipar ( 5 ) if ( niy . lt . - ipar ( 5 )) niy = - ipar ( 5 ) if ( nixp . gt . ipar ( 5 )) nixp = ipar ( 5 ) if ( niyp . gt . ipar ( 5 )) niyp = ipar ( 5 ) if ( nixp . lt . - ipar ( 5 )) nixp = - ipar ( 5 ) if ( niyp . lt . - ipar ( 5 )) niyp = - ipar ( 5 ) dx = ixy ( 1 ) - nix dy = ixy ( 2 ) - niy dxm = 1.0 - dx dym = 1.0 - dy ! do the area correction for this detector pixel dp = dot_product ( pcvec , dc ) if (( i . eq . ipx ). and .( j . eq . ipy )) then gam = 0.25 else gam = (( calpha * calpha + dp * dp - 1.0 ) ** 1.5 ) / ( calpha ** 3 ) * 0.25 end if ! interpolate the intensity do k = Emin , Emax accum_e_detector ( k , i , j ) = gam * ( accum_e ( k , nix , niy ) * dxm * dym + & accum_e ( k , nixp , niy ) * dx * dym + & accum_e ( k , nix , niyp ) * dxm * dy + & accum_e ( k , nixp , niyp ) * dx * dy ) end do end do end do prefactor = 0.25D0 * nAmpere * fpar ( 8 ) * fpar ( 9 ) * 1.0D-15 / sum ( accum_e_detector ) ! from here on, we simply compute the EBSD patterns by interpolation, ! no intensity scaling or anything else...other than multiplication by pre-factor ! intensity scaling is left to the user of the calling program. ! define some parameters and initialize EBSDpattern scl = dble ( ipar ( 6 )) EBSDpattern = 0.0 ! here is the main loop over all quaternions quatloop : do ip = 1 , ipar ( 8 ) do i = 1 , ipar ( 2 ) do j = 1 , ipar ( 3 ) ! do the active coordinate transformation for this euler angle dc = quat_Lp ( quats ( 1 : 4 , ip ), ( / rgx ( i , j ), rgy ( i , j ), rgz ( i , j ) / ) ) ! normalize dc dc = dc / sqrt ( sum ( dc * dc )) ! convert these direction cosines to coordinates in the Rosca-Lambert projection (always square projection !!!) ixy = scl * LambertSphereToSquare ( dc , istat ) if ( istat . eq . 0 ) then ! four-point interpolation (bi-quadratic) nix = int ( ipar ( 6 ) + ixy ( 1 )) - ipar ( 6 ) niy = int ( ipar ( 6 ) + ixy ( 2 )) - ipar ( 6 ) nixp = nix + 1 niyp = niy + 1 if ( nix . gt . ipar ( 6 )) nix = ipar ( 6 ) if ( niy . gt . ipar ( 6 )) niy = ipar ( 6 ) if ( nix . lt . - ipar ( 6 )) nix = - ipar ( 6 ) if ( niy . lt . - ipar ( 6 )) niy = - ipar ( 6 ) if ( nixp . gt . ipar ( 6 )) nixp = ipar ( 6 ) if ( niyp . gt . ipar ( 6 )) niyp = ipar ( 6 ) if ( nixp . lt . - ipar ( 6 )) nixp = - ipar ( 6 ) if ( niyp . lt . - ipar ( 6 )) niyp = - ipar ( 6 ) dx = ixy ( 1 ) - nix dy = ixy ( 2 ) - niy dxm = 1.0 - dx dym = 1.0 - dy if ( dc ( 3 ). gt . 0.0 ) then ! we're in the Northern hemisphere do k = Emin , Emax EBSDpattern ( i , j , ip ) = EBSDpattern ( i , j , ip ) + accum_e_detector ( k , i , j ) * ( mLPNHsum ( nix , niy , k ) * dxm * dym + & mLPNHsum ( nixp , niy , k ) * dx * dym + mLPNHsum ( nix , niyp , k ) * dxm * dy + & mLPNHsum ( nixp , niyp , k ) * dx * dy ) end do else ! we're in the Southern hemisphere do k = Emin , Emax EBSDpattern ( i , j , ip ) = EBSDpattern ( i , j , ip ) + accum_e_detector ( k , i , j ) * ( mLPSHsum ( nix , niy , k ) * dxm * dym + & mLPSHsum ( nixp , niy , k ) * dx * dym + mLPSHsum ( nix , niyp , k ) * dxm * dy + & mLPSHsum ( nixp , niyp , k ) * dx * dy ) end do end if end if end do end do end do quatloop deallocate ( accum_e_detector ) ! finally, scale the patterns by the appropriate factor and return to the calling program EBSDpattern = prefactor * EBSDpattern end subroutine getEBSDPatterns2","tags":"","loc":"proc/getebsdpatterns2.html","title":"getEBSDPatterns2 – Fortran Program"},{"text":"public recursive subroutine getECPatterns(ipar, fpar, ECpattern, quats, accum_e, mLPNH, mLPSH) Uses: local constants Lambert quaternions distortion iso_c_binding proc~~getecpatterns~~UsesGraph proc~getecpatterns getECPatterns iso_c_binding iso_c_binding iso_c_binding->proc~getecpatterns local local local->proc~getecpatterns module~distortion distortion local->module~distortion module~constants constants local->module~constants Lambert Lambert Lambert->proc~getecpatterns quaternions quaternions quaternions->proc~getecpatterns module~distortion->proc~getecpatterns module~constants->proc~getecpatterns Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief This function can be called as a standalone function to compute an electron channeling pattern\n based on Marc's code above\n @etails The main purpose of this routine and its accompanying wrapper routine is to\n provide a way for an external program to compute an EC pattern.  The idea is that \n all the necessary arrays and variables are passed in by reference as arguments, without\n the need for the routine to fetch any other data from files etc...  The initial goal is\n to have a function that can be called with the CALL_EXTERNAL mechanism in IDL, but \n in the long run this will also be the approach for calling the routine from C/C++, which\n is an essential part of integration with DREAM.3D.  This routine is a simplified version\n of the core of the EMECP program. This routine will first compute the incident cone vectors etc. if necessary, and then perform\n the usual interpolation from the square Lambert projection. The pattern will be a basic pattern,\n without any intensity scaling or binning etc; the calling program should take care of those \n operations.\n @param ipar array with integer input parameters\n @param fpar array with float input parameters\n @param ECPattern output array\n @param quats array of quaternions\n @param accum_e array with Monte Carlo histogram\n @param mLPNH Northern hemisphere master pattern\n @param mLPSH Southern hemisphere master pattern\n @date 10/16/15  SS 1.0 original\n @date 11/02/14 MDG 1.1 put all integer parameters inside ipar and fixed size of ipar/fpar\n @date 11/04/15 MDG 1.2 added array of quaternions as input parameter !!!!!! removed:  fpar(9-12) =  quaternion for requested Euler angles Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in) :: ipar (nipar) real(kind=sgl), intent(in) :: fpar (nfpar) real(kind=sgl), intent(out) :: ECpattern (ipar(2),ipar(3),ipar(8)) real(kind=sgl), intent(in) :: quats (nq,ipar(8)) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(7):ipar(7),-ipar(7):ipar(7),ipar(6)) real(kind=sgl), intent(in) :: mLPSH (-ipar(7):ipar(7),-ipar(7):ipar(7),ipar(6)) Calls proc~~getecpatterns~~CallsGraph proc~getecpatterns getECPatterns sngl sngl proc~getecpatterns->sngl quat_lp quat_lp proc~getecpatterns->quat_lp lambertspheretosquare lambertspheretosquare proc~getecpatterns->lambertspheretosquare float float proc~getecpatterns->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~getecpatterns~~CalledByGraph proc~getecpatterns getECPatterns proc~getecpatternswrapper getECPatternsWrapper proc~getecpatternswrapper->proc~getecpatterns proc~ecpcalfun ECPcalfun proc~ecpcalfun->proc~getecpatterns Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getECPatterns Source Code recursive subroutine getECPatterns ( ipar , fpar , ECpattern , quats , accum_e , mLPNH , mLPSH ) !DEC$ ATTRIBUTES DLLEXPORT :: GetECPatterns ! the input parameters are all part of a ipar and fpar input arrays instead of the usual namelist structures. ! The following is the mapping: ! ! ipar(1) = 1 if GetVectorsCone detector arrays need to be computed, 0 if not (arrays will have save status) ! ipar(2) = detnumsx ! ipar(3) = detnumsy ! ipar(4) = numangle ! ipar(5) = mcnsx ! ipar(6) = numset ! ipar(7) = mpnpx ! ipar(8) = numquats ! fpar(1) = ecpnl%thetac ! fpar(2) = ecpnl%sampletilt ! fpar(3) = ecpnl%workingdistance ! fpar(4) = ecpnl%Rin ! fpar(5) = ecpnl%Rout ! fpar(6) = ecpnl%sigstart ! fpar(7) = ecpnl%sigend ! fpar(8) = ecpnl%sigstep !!!!!!!! removed:  fpar(9-12) =  quaternion for requested Euler angles use local use constants use Lambert use quaternions use distortion use , INTRINSIC :: ISO_C_BINDING IMPLICIT NONE integer ( c_size_t ), PARAMETER :: nipar = 8 integer ( c_size_t ), PARAMETER :: nfpar = 8 integer ( c_size_t ), PARAMETER :: nq = 4 integer ( c_size_t ), INTENT ( IN ) :: ipar ( nipar ) real ( kind = sgl ), INTENT ( IN ) :: fpar ( nfpar ) real ( kind = sgl ), INTENT ( OUT ) :: ECpattern ( ipar ( 2 ), ipar ( 3 ), ipar ( 8 )) real ( kind = sgl ), INTENT ( IN ) :: quats ( nq , ipar ( 8 )) real ( kind = sgl ), INTENT ( IN ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( kind = sgl ), INTENT ( IN ) :: mLPNH ( - ipar ( 7 ): ipar ( 7 ), - ipar ( 7 ): ipar ( 7 ), ipar ( 6 )) real ( kind = sgl ), INTENT ( IN ) :: mLPSH ( - ipar ( 7 ): ipar ( 7 ), - ipar ( 7 ): ipar ( 7 ), ipar ( 6 )) real ( kind = sgl ), allocatable , save :: klist (:,:,:), rgx (:,:), rgy (:,:), rgz (:,:), weightfact (:) real ( kind = sgl ), allocatable , save :: mLPNHsum (:,:), mLPSHsum (:,:) real ( kind = dbl ), parameter :: Rtod = 5 7.2957795131D0 real ( kind = dbl ), parameter :: dtoR = 0.01745329251D0 real ( kind = sgl ) :: kk ( 3 ), thetacr , ktmax , delta , wf , quat ( 4 ) integer ( kind = irg ) :: istat , imin , imax , jmin , jmax , ii , jj , nazimuth , npolar , nsig , ip integer ( kind = irg ) :: ipolar , iazimuth , isig , isampletilt , nix , niy , nixp , niyp , isigp real ( kind = sgl ) :: thetain , thetaout , polar , azimuthal , delpolar , delazimuth , om ( 3 , 3 ) real ( kind = sgl ) :: dc ( 3 ), scl , deltheta , acc_sum , MCangle , ixy ( 2 ), dx , dy , dxm , dym , dp !================================================================================== ! ------ generate the detector klist, rgx, rgy, rgz, weightfactors arrays if needed !------- (calling program must decide this via ipar(1)) !================================================================================== imin = 1 imax = ipar ( 2 ) jmin = 1 jmax = ipar ( 3 ) if ( ipar ( 1 ). ge . 1 ) then if ( ipar ( 1 ). eq . 2 ) then ! complete reset, including the mLPNHsum and mLPSHsum arrays if ( allocated ( mLPNHsum )) deallocate ( mLPNHsum ) if ( allocated ( mLPSHsum )) deallocate ( mLPSHsum ) allocate ( mLPNHsum ( - ipar ( 7 ): ipar ( 7 ), - ipar ( 7 ): ipar ( 7 ))) allocate ( mLPSHsum ( - ipar ( 7 ): ipar ( 7 ), - ipar ( 7 ): ipar ( 7 ))) mLPNHsum = sum ( mLPNH , 3 ) mLPSHsum = sum ( mLPSH , 3 ) end if if ( allocated ( klist )) deallocate ( klist ) allocate ( klist ( 1 : 3 , 1 : ipar ( 2 ), 1 : ipar ( 3 )), stat = istat ) kk = ( / 0.0 , 0.0 , 1.0 / ) thetacr = DtoR * fpar ( 1 ) ktmax = tan ( thetacr ) delta = 2.0 * ktmax / dble ( ipar ( 2 ) - 1 ) do ii = imin , imax do jj = jmin , jmax klist ( 1 : 3 , ii , jj ) = ( /- ktmax + delta * ( ii - 1 ), - ktmax + delta * ( jj - 1 ), 0.0 / ) + kk ( 1 : 3 ) klist ( 1 : 3 , ii , jj ) = klist ( 1 : 3 , ii , jj ) / sqrt ( sum ( klist ( 1 : 3 , ii , jj ) ** 2 )) end do end do thetain = atan2 ( fpar ( 4 ), fpar ( 3 )) thetaout = atan2 ( fpar ( 5 ), fpar ( 3 )) om ( 1 ,:) = ( / cos ( fpar ( 2 ) * sngl ( dtor )), 0.0 , sin ( fpar ( 2 ) * sngl ( dtor )) / ) om ( 2 ,:) = ( / 0.0 , 1.0 , 0.0 / ) om ( 3 ,:) = ( /- sin ( fpar ( 2 ) * sngl ( dtor )), 0.0 , cos ( fpar ( 2 ) * sngl ( dtor )) / ) npolar = nint (( thetaout - thetain ) * 18 0.0 / cPi ) + 1 delpolar = ( thetaout - thetain ) / float ( npolar - 1 ) nazimuth = 361 delazimuth = 2.0 * cPi / float ( nazimuth - 1 ) if ( allocated ( rgx )) deallocate ( rgx , rgy , rgz ) allocate ( rgx ( npolar , nazimuth ), rgy ( npolar , nazimuth ), rgz ( npolar , nazimuth ), stat = istat ) do ipolar = 1 , npolar polar = thetain + float ( ipolar - 1 ) * delpolar do iazimuth = 1 , nazimuth azimuthal = float ( iazimuth - 1 ) * delazimuth dc ( 1 ) = cos ( azimuthal ) * sin ( polar ) dc ( 2 ) = sin ( azimuthal ) * sin ( polar ) dc ( 3 ) = cos ( polar ) dc = matmul ( om , dc ) rgx ( ipolar , iazimuth ) = dc ( 1 ) rgy ( ipolar , iazimuth ) = dc ( 2 ) rgz ( ipolar , iazimuth ) = dc ( 3 ) end do end do !=================================================================== ! ------ generate the weight factors from the monte carlo histogram !=================================================================== scl = float ( ipar ( 5 )) nsig = nint ( fpar ( 1 ) + abs ( fpar ( 2 ))) + 1 deltheta = ( fpar ( 1 ) + abs ( fpar ( 2 ))) / float ( nsig - 1 ) if ( allocated ( weightfact )) deallocate ( weightfact ) allocate ( weightfact ( 1 : nsig ), stat = istat ) weightfact = 0.0 do isig = 1 , nsig acc_sum = 0.0 MCangle = ( isig - 1 ) * deltheta isampletilt = nint (( MCangle - fpar ( 6 )) / fpar ( 8 )) if ( isampletilt . lt . 1 ) then isampletilt = abs ( isampletilt ) + 1 else isampletilt = isampletilt + 1 end if do ipolar = 1 , npolar do iazimuth = 1 , nazimuth dc ( 1 : 3 ) = ( / rgx ( ipolar , iazimuth ), rgy ( ipolar , iazimuth ), rgz ( ipolar , iazimuth ) / ) ! convert to Rosca-lambert projection ixy = scl * LambertSphereToSquare ( dc , istat ) nix = int ( ipar ( 5 ) + ixy ( 1 )) - ipar ( 5 ) niy = int ( ipar ( 5 ) + ixy ( 2 )) - ipar ( 5 ) nixp = nix + 1 niyp = niy + 1 if ( nixp . gt . ipar ( 5 )) nixp = nix if ( niyp . gt . ipar ( 5 )) niyp = niy if ( nix . lt . - ipar ( 5 )) nix = nixp if ( niy . lt . - ipar ( 5 )) niy = niyp dx = ixy ( 1 ) - nix dy = ixy ( 2 ) - niy dxm = 1.0 - dx dym = 1.0 - dy acc_sum = 0.25 * ( accum_e ( isampletilt , nix , niy ) * dxm * dym + & accum_e ( isampletilt , nixp , niy ) * dx * dym + & accum_e ( isampletilt , nix , niyp ) * dxm * dy + & accum_e ( isampletilt , nixp , niyp ) * dx * dy ) weightfact ( isig ) = weightfact ( isig ) + acc_sum end do end do end do weightfact ( 1 : nsig ) = weightfact ( 1 : nsig ) / weightfact ( 1 ) end if !=================================================================== ! ------ perform interpolation from square lambert map !=================================================================== scl = float ( ipar ( 7 )) do ip = 1 , ipar ( 8 ) do ii = imin , imax do jj = jmin , jmax dc ( 1 : 3 ) = klist ( 1 : 3 , ii , jj ) dc = dc / sqrt ( sum ( dc * dc )) dp = DOT_PRODUCT ( dc ( 1 : 3 ),( / sin ( fpar ( 2 ) * dtoR ), 0.D0 , cos ( fpar ( 2 ) * dtoR ) / )) if ( dp . gt . 1.D0 ) dp = 1.0 MCangle = acos ( dp ) * Rtod isig = int ( MCangle ) + 1 if ( isig . gt . nsig ) isig = nsig isigp = isig + 1 if ( isigp . gt . nsig ) isigp = nsig dx = MCangle - int ( MCangle ) dxm = 1.0 - dx wf = weightfact ( isig ) * dxm + weightfact ( isigp ) * dx wf = 1.0 dc = quat_LP ( quats ( 1 : 4 , ip ), dc ) dc = dc / sqrt ( sum ( dc * dc )) ixy = scl * LambertSphereToSquare ( dc , istat ) nix = int ( ipar ( 7 ) + ixy ( 1 )) - ipar ( 7 ) niy = int ( ipar ( 7 ) + ixy ( 2 )) - ipar ( 7 ) nixp = nix + 1 niyp = niy + 1 if ( nixp . gt . ipar ( 7 )) nixp = nix if ( niyp . gt . ipar ( 7 )) niyp = niy if ( nix . lt . - ipar ( 7 )) nix = nixp if ( niy . lt . - ipar ( 7 )) niy = niyp dx = ixy ( 1 ) - nix dy = ixy ( 2 ) - niy dxm = 1.0 - dx dym = 1.0 - dy if ( dc ( 3 ). gt . 0.0 ) then ECpattern ( ii , jj , ip ) = wf * ( mLPNHsum ( nix , niy ) * dxm * dym + & mLPNHsum ( nixp , niy ) * dx * dym + & mLPNHsum ( nix , niyp ) * dxm * dy + & mLPNHsum ( nixp , niyp ) * dx * dy ) else ECpattern ( ii , jj , ip ) = wf * ( mLPSHsum ( nix , niy ) * dxm * dym + & mLPSHsum ( nixp , niy ) * dx * dym + & mLPSHsum ( nix , niyp ) * dxm * dy + & mLPSHsum ( nixp , niyp ) * dx * dy ) end if end do end do end do end subroutine getECPatterns","tags":"","loc":"proc/getecpatterns.html","title":"getECPatterns – Fortran Program"},{"text":"public recursive subroutine getKosselPatterns(ipar, fpar, Kosselpattern, quats, mLPNH, mLPSH) Uses: local constants Lambert quaternions iso_c_binding proc~~getkosselpatterns~~UsesGraph proc~getkosselpatterns getKosselPatterns Lambert Lambert Lambert->proc~getkosselpatterns iso_c_binding iso_c_binding iso_c_binding->proc~getkosselpatterns local local local->proc~getkosselpatterns module~constants constants local->module~constants quaternions quaternions quaternions->proc~getkosselpatterns module~constants->proc~getkosselpatterns Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief This function can be called as a standalone function to compute a Kossel pattern\n @etails The main purpose of this routine and its accompanying wrapper routine is to\n provide a way for an external program to compute a Kossel pattern.  The idea is that \n all the necessary arrays and variables are passed in by reference as arguments, without\n the need for the routine to fetch any other data from files etc...  The initial goal is\n to have a function that can be called with the CALL_EXTERNAL mechanism in IDL, but \n in the long run this will also be the approach for calling the routine from C/C++, which\n is an essential part of integration with DREAM.3D. This routine will first compute the incident cone vectors etc. if necessary, and then perform\n the usual interpolation from the square Lambert projection. The pattern will be a basic pattern,\n without any intensity scaling or binning etc; the calling program should take care of those \n operations. This is simpler than the ECP case, since there is no energy dependent stuff to \n worry about. We're also keeping the ipar and fpar arrays the same as for the ECP case, even\n though we could in principle simplify them; this facilitates integration with the SEMDisplay \n program.\n @param ipar array with integer input parameters\n @param fpar array with float input parameters\n @param KosselPattern output array\n @param quats array of quaternions\n @param mLPNH Northern hemisphere master pattern\n @param mLPSH Southern hemisphere master pattern\n @date 11/09/15 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in) :: ipar (nipar) real(kind=sgl), intent(in) :: fpar (nfpar) real(kind=sgl), intent(out) :: Kosselpattern (ipar(2),ipar(2),ipar(4)) real(kind=sgl), intent(in) :: quats (nq,ipar(4)) real(kind=sgl), intent(in) :: mLPNH (-ipar(3):ipar(3),-ipar(3):ipar(3),ipar(5)) real(kind=sgl), intent(in) :: mLPSH (-ipar(3):ipar(3),-ipar(3):ipar(3),ipar(5)) Calls proc~~getkosselpatterns~~CallsGraph proc~getkosselpatterns getKosselPatterns float float proc~getkosselpatterns->float lambertspheretosquare lambertspheretosquare proc~getkosselpatterns->lambertspheretosquare quat_lp quat_lp proc~getkosselpatterns->quat_lp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~getkosselpatterns~~CalledByGraph proc~getkosselpatterns getKosselPatterns proc~getkosselpatternswrapper getKosselPatternsWrapper proc~getkosselpatternswrapper->proc~getkosselpatterns Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getKosselPatterns Source Code recursive subroutine getKosselPatterns ( ipar , fpar , Kosselpattern , quats , mLPNH , mLPSH ) !DEC$ ATTRIBUTES DLLEXPORT :: getKosselPatterns ! the input parameters are all part of a ipar and fpar input arrays instead of the usual namelist structures. ! The following is the mapping: ! ! ipar(1) = 1 if GetVectorsCone detector arrays need to be computed, 0 if not (arrays will have save status) ! ipar(2) = detnumsx ! ipar(3) = mpnpx ! ipar(4) = numquats ! ipar(5) = numdepths ! ipar(6) = depthsel ! fpar(1) = ecpnl%thetac use local use constants use Lambert use quaternions use , INTRINSIC :: ISO_C_BINDING IMPLICIT NONE integer ( c_size_t ), PARAMETER :: nipar = 6 integer ( c_size_t ), PARAMETER :: nfpar = 1 integer ( c_size_t ), PARAMETER :: nq = 4 integer ( c_size_t ), INTENT ( IN ) :: ipar ( nipar ) real ( kind = sgl ), INTENT ( IN ) :: fpar ( nfpar ) real ( kind = sgl ), INTENT ( OUT ) :: Kosselpattern ( ipar ( 2 ), ipar ( 2 ), ipar ( 4 )) real ( kind = sgl ), INTENT ( IN ) :: quats ( nq , ipar ( 4 )) real ( kind = sgl ), INTENT ( IN ) :: mLPNH ( - ipar ( 3 ): ipar ( 3 ), - ipar ( 3 ): ipar ( 3 ), ipar ( 5 )) real ( kind = sgl ), INTENT ( IN ) :: mLPSH ( - ipar ( 3 ): ipar ( 3 ), - ipar ( 3 ): ipar ( 3 ), ipar ( 5 )) real ( kind = sgl ), allocatable , save :: klist (:,:,:) real ( kind = dbl ), parameter :: Rtod = 5 7.2957795131D0 real ( kind = dbl ), parameter :: dtoR = 0.01745329251D0 real ( kind = sgl ) :: kk ( 3 ), thetacr , ktmax , delta , quat ( 4 ) integer ( kind = irg ) :: istat , imin , imax , jmin , jmax , ii , jj , nsig , ip integer ( kind = irg ) :: isig , nix , niy , nixp , niyp , isigp real ( kind = sgl ) :: dc ( 3 ), scl , ixy ( 2 ), dx , dy , dxm , dym , dp !================================================================================== ! ------ generate the detector klist array if needed !------- (calling program must decide this via ipar(1)) !================================================================================== if ( ipar ( 1 ). ge . 1 ) then if ( allocated ( klist )) deallocate ( klist ) allocate ( klist ( 1 : 3 , - ipar ( 2 ): ipar ( 2 ), - ipar ( 2 ): ipar ( 2 )), stat = istat ) kk = ( / 0.0 , 0.0 , 1.0 / ) thetacr = DtoR * fpar ( 1 ) ktmax = tan ( thetacr ) delta = 2.0 * ktmax / dble ( ipar ( 2 ) - 1 ) imin = 1 imax = ipar ( 2 ) jmin = 1 jmax = ipar ( 2 ) do ii = imin , imax do jj = jmin , jmax klist ( 1 : 3 , ii , jj ) = ( /- ktmax + delta * ( ii - 1 ), - ktmax + delta * ( jj - 1 ), 0.0 / ) + kk ( 1 : 3 ) klist ( 1 : 3 , ii , jj ) = klist ( 1 : 3 , ii , jj ) / sqrt ( sum ( klist ( 1 : 3 , ii , jj ) ** 2 )) end do end do end if !=================================================================== ! ------ perform interpolation from square lambert map !=================================================================== scl = float ( ipar ( 3 )) do ip = 1 , ipar ( 4 ) do ii = imin , imax do jj = jmin , jmax dc ( 1 : 3 ) = klist ( 1 : 3 , ii , jj ) dc = quat_LP ( quats ( 1 : 4 , ip ), dc ) dc = dc / sqrt ( sum ( dc * dc )) ixy = scl * LambertSphereToSquare ( dc , istat ) nix = int ( ipar ( 3 ) + ixy ( 1 )) - ipar ( 3 ) niy = int ( ipar ( 3 ) + ixy ( 2 )) - ipar ( 3 ) nixp = nix + 1 niyp = niy + 1 if ( nixp . gt . ipar ( 3 )) nixp = nix if ( niyp . gt . ipar ( 3 )) niyp = niy if ( nix . lt . - ipar ( 3 )) nix = nixp if ( niy . lt . - ipar ( 3 )) niy = niyp dx = ixy ( 1 ) - nix dy = ixy ( 2 ) - niy dxm = 1.0 - dx dym = 1.0 - dy if ( dc ( 3 ). gt . 0.0 ) then Kosselpattern ( ii , jj , ip ) = mLPNH ( nix , niy , ipar ( 6 )) * dxm * dym + & mLPNH ( nixp , niy , ipar ( 6 )) * dx * dym + & mLPNH ( nix , niyp , ipar ( 6 )) * dxm * dy + & mLPNH ( nixp , niyp , ipar ( 6 )) * dx * dy else Kosselpattern ( ii , jj , ip ) = mLPSH ( nix , niy , ipar ( 6 )) * dxm * dym + & mLPSH ( nixp , niy , ipar ( 6 )) * dx * dym + & mLPSH ( nix , niyp , ipar ( 6 )) * dxm * dy + & mLPSH ( nixp , niyp , ipar ( 6 )) * dx * dy end if end do end do end do end subroutine getKosselPatterns","tags":"","loc":"proc/getkosselpatterns.html","title":"getKosselPatterns – Fortran Program"},{"text":"public recursive subroutine EBSD4calfun(nipar, nfpar, ninit, ipar, fpar, initmeanval, expt, accum_e, mLPNH, mLPSH, n, x, f, expt2, expt3, expt4, nstep, stepsize, verbose) Uses: local rotations constants distortion filters Indexingmod iso_c_binding proc~~ebsd4calfun~~UsesGraph proc~ebsd4calfun EBSD4calfun iso_c_binding iso_c_binding iso_c_binding->proc~ebsd4calfun module~constants constants module~constants->proc~ebsd4calfun module~filters filters module~filters->proc~ebsd4calfun module~distortion distortion module~distortion->proc~ebsd4calfun rotations rotations rotations->proc~ebsd4calfun module~indexingmod Indexingmod module~indexingmod->proc~ebsd4calfun local local local->proc~ebsd4calfun local->module~constants local->module~filters local->module~distortion local->module~indexingmod module~namelisttypedefs NameListTypedefs local->module~namelisttypedefs module~namelisttypedefs->module~indexingmod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief This function is used by bobyqa to fit an EBSD pattern\n @details The main purpose of this routine is to calculte the difference of 1 with the dot\n product of an experimental pattern with the given set of detector parameters. This is used\n by bobyqa module to fit an EBSD pattern when 4 patterns are fitted simultaneously This routine will first compute the detector arrays rgx etc. if necessary, and then perform\n the usual interpolation from the square Lambert projection. The pattern will be a basic pattern,\n without any intensity scaling or binning etc; the calling program should take care of those \n operations.\n @param ipar array with integer input parameters\n @param fpar array with float input parameters\n @param initmeanval mean value of search space\n @param EBSDpattern output array\n @param quats quaternion input array\n @param accum_e array with Monte Carlo histogram\n @param mLPNH Northern hemisphere master pattern\n @param mLPSH Southern hemisphere master pattern\n @date 12/12/15 SS 1.0 original\n @date 03/28/16 SS 1.1 omega is no longer a variable parameter Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar integer(kind=irg), intent(in) :: ninit integer(kind=c_size_t), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fpar (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) real(kind=c_float), intent(in) :: expt (ipar(2)*ipar(3)/ipar(12)/ipar(12)) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) integer(kind=irg), intent(in) :: n real(kind=dbl), intent(in), dimension(:) :: x real(kind=dbl), intent(out) :: f real(kind=c_float), intent(in) :: expt2 (ipar(2)*ipar(3)/ipar(12)/ipar(12)) real(kind=c_float), intent(in) :: expt3 (ipar(2)*ipar(3)/ipar(12)/ipar(12)) real(kind=c_float), intent(in) :: expt4 (ipar(2)*ipar(3)/ipar(12)/ipar(12)) integer(kind=irg), intent(in) :: nstep real(kind=sgl), intent(in) :: stepsize (nstep) logical, intent(in), optional :: verbose Calls proc~~ebsd4calfun~~CallsGraph proc~ebsd4calfun EBSD4calfun sngl sngl proc~ebsd4calfun->sngl jaccard_distance jaccard_distance proc~ebsd4calfun->jaccard_distance eu2qu eu2qu proc~ebsd4calfun->eu2qu proc~getebsdpatterns getEBSDPatterns proc~ebsd4calfun->proc~getebsdpatterns float float proc~ebsd4calfun->float proc~getebsdpatterns->sngl proc~getebsdpatterns->float quat_lp quat_lp proc~getebsdpatterns->quat_lp lambertspheretosquare lambertspheretosquare proc~getebsdpatterns->lambertspheretosquare Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code EBSD4calfun Source Code recursive subroutine EBSD4calfun ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt , accum_e , & mLPNH , mLPSH , n , x , f , expt2 , expt3 , expt4 , nstep , stepsize , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: EBSD4calfun ! the input parameters are all part of a ipar and fpar input arrays instead of the usual namelist structures. ! The following is the mapping: ! ! ipar(1) = 2 ! ipar(2) = detnumsx ! ipar(3) = detnumsy ! ipar(4) = detnumEbins ! ipar(5) = mcnsx ! ipar(6) = mpnpx ! ipar(7) = numset ! ipar(8) = numquats ! ipar(9) = Emin ! ipar(10) = Emax ! ipar(11) = 0/1 ;0 for no mask, 1 for mask ! ipar(12) = binning ! ipar(13) = pixx_pat1 ! ipar(14) = pixy_pat1 ! ipar(15) = pixx_pat2 ! ipar(16) = pixy_pat2 ! ipar(17) = pixx_pat3 ! ipar(18) = pixy_pat3 ! ipar(19) = pixx_pat4 ! ipar(20) = pixy_pat4 ! fpar(1) = enl%xpc ! fpar(2) = enl%ypc ! fpar(3) = enl%delta ! fpar(4) = enl%MCsig ! fpar(5) = enl%omega ! fpar(6) = enl%thetac ! fpar(7) = enl%L ! fpar(8) = enl%beamcurrent ! fpar(9) = enl%dwelltime ! fpar(10) = enl%gammavalue ! fpar(11) = maskradius ! fpar(12) = stepx ! fpar(13) = stepy ! initmeanval(1) = fpar(7) ! initmeanval(2) = phi1 ! initmeanval(3) = phi ! initmeanval(4) = phi2 ! initmeanval(5) = xpc ! initmeanval(6) = ypc ! stepsize(1) = step_xpc ! stepsize(2) = step_ypc ! stepsize(3) = step_phi1 ; all 4 patterns ! stepsize(4) = step_phi ; all 4 patterns ! stepsize(5) = step_phi2 ; all 4 patterns ! stepsize(6) = step_L ! X = (/xpc, ypc, omega, L, phi1, phi, phi2/) use local use rotations use constants use distortion use filters use Indexingmod , ONLY : Jaccard_Distance use , INTRINSIC :: ISO_C_BINDING implicit none integer ( irg ), intent ( in ) :: nipar integer ( irg ), intent ( in ) :: nfpar integer ( irg ), intent ( in ) :: ninit integer ( c_size_t ), intent ( in ) :: ipar ( nipar ) real ( sgl ), intent ( inout ) :: fpar ( nfpar ) real ( sgl ), intent ( in ) :: initmeanval ( ninit ) integer ( irg ), intent ( in ) :: nstep real ( sgl ), intent ( in ) :: stepsize ( nstep ) real ( c_float ), intent ( in ) :: expt ( ipar ( 2 ) * ipar ( 3 ) / ipar ( 12 ) / ipar ( 12 )) real ( c_float ), intent ( in ) :: expt2 ( ipar ( 2 ) * ipar ( 3 ) / ipar ( 12 ) / ipar ( 12 )) real ( c_float ), intent ( in ) :: expt3 ( ipar ( 2 ) * ipar ( 3 ) / ipar ( 12 ) / ipar ( 12 )) real ( c_float ), intent ( in ) :: expt4 ( ipar ( 2 ) * ipar ( 3 ) / ipar ( 12 ) / ipar ( 12 )) real ( kind = sgl ), INTENT ( in ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( kind = sgl ), INTENT ( in ) :: mLPNH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) real ( kind = sgl ), INTENT ( in ) :: mLPSH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) integer ( irg ), intent ( in ) :: n real ( dbl ), dimension (:), intent ( in ) :: x real ( dbl ), intent ( out ) :: f logical , intent ( in ), optional :: verbose integer ( kind = irg ) :: nnx , nny , binx , biny complex ( dbl ) :: D real ( kind = sgl ) :: quats ( 4 , 1 ), bindx , ma , mi real ( kind = sgl ), allocatable :: EBSDpattern (:,:,:), binned (:,:) real ( kind = sgl ), allocatable :: EBSDpatternintd (:,:) integer ( kind = irg ), allocatable :: EBSDpatterninteger (:,:), EBSDpatternad (:,:) ! variables that must be saved for the next time this function is called real ( kind = sgl ) :: prefactor integer ( kind = irg ), allocatable :: img1 (:), img2 (:), img_fit_cumul (:), img_expt_cumul (:) ! other variables real ( kind = sgl ), parameter :: dtor = 0.0174533 ! convert from degrees to radians real ( kind = sgl ) :: ixy ( 2 ), eu ( 3 ), eu2 ( 3 ), eu3 ( 3 ), eu4 ( 3 ) real ( kind = sgl ), allocatable :: EBSDvector (:), EBSDflip (:,:), mask (:,:) integer ( kind = irg ) :: i , j , istat logical :: stat , readonly integer ( kind = irg ) :: hdferr , nlines real ( kind = sgl ) :: fpar2 ( nfpar ) !fpar(1) = sngl(X(1))*ipar(2) - ipar(2)/2 + initmeanval(5) ! xpc +/- detnumx/2 pixels !fpar(2) = sngl(X(2))*ipar(3) - ipar(3)/2 + initmeanval(6) ! ypc +/- detnumy/2 pixels fpar ( 1 ) = sngl ( X ( 1 )) * 2.0 * stepsize ( 1 ) - stepsize ( 1 ) + initmeanval ( 5 ) ! xpc +/- 5 pixels fpar ( 2 ) = sngl ( X ( 2 )) * 2.0 * stepsize ( 2 ) - stepsize ( 2 ) + initmeanval ( 6 ) ! ypc +/- 5 pixels !fpar(1) = initmeanval(5) ! xpc +/- detnumx/2 pixels !fpar(2) = initmeanval(6) ! ypc +/- detnumy/2 pixels fpar ( 7 ) = sngl ( X ( 4 )) * 2.0 * stepsize ( 6 ) * fpar ( 3 ) - stepsize ( 6 ) * fpar ( 3 ) + initmeanval ( 1 ) ! mean +/- 5 pixels !fpar(7) = initmeanval(1) ! mean +/- 2000 microns ! 03/28/16 omega is no longer a variable parameter anymore fpar ( 5 ) = sngl ( X ( 3 )) * 0.0 - 0.0 ! omega 0 +/- 5 degrees !eu = (/initmeanval(2), initmeanval(3), initmeanval(4)/)*dtor ! don't change the values for euler angles eu = ( / X ( 5 ) * 2.0 * stepsize ( 3 ) - stepsize ( 3 ) + initmeanval ( 2 ), X ( 6 ) * 2.0 * stepsize ( 4 ) - stepsize ( 4 ) + initmeanval ( 3 ), & X ( 7 ) * 2.0 * stepsize ( 5 ) - stepsize ( 5 ) + initmeanval ( 4 ) / ) * dtor ! mean +/- 2 degrees eu2 = ( / X ( 8 ) * 2.0 * stepsize ( 3 ) - stepsize ( 3 ) + initmeanval ( 7 ), X ( 9 ) * 2.0 * stepsize ( 4 ) - stepsize ( 4 ) + initmeanval ( 8 ), & X ( 10 ) * 2.0 * stepsize ( 5 ) - stepsize ( 5 ) + initmeanval ( 9 ) / ) * dtor ! mean +/- 2 degrees eu3 = ( / X ( 11 ) * 2.0 * stepsize ( 3 ) - stepsize ( 3 ) + initmeanval ( 10 ), X ( 12 ) * 2.0 * stepsize ( 4 ) - stepsize ( 4 ) + initmeanval ( 11 ), & X ( 13 ) * 2.0 * stepsize ( 5 ) - stepsize ( 5 ) + initmeanval ( 12 ) / ) * dtor ! mean +/- 2 degrees eu4 = ( / X ( 14 ) * 2.0 * stepsize ( 3 ) - stepsize ( 3 ) + initmeanval ( 13 ), X ( 15 ) * 2.0 * stepsize ( 4 ) - stepsize ( 4 ) + initmeanval ( 14 ), & X ( 16 ) * 2.0 * stepsize ( 5 ) - stepsize ( 5 ) + initmeanval ( 15 ) / ) * dtor ! mean +/- 2 degrees !D = dcmplx(X(8)*0.000002D0 - 0.000001D0 + dble(initmeanval(5)), X(9)*0.000002D0 - 0.000001D0 + dble(initmeanval(6))) binx = ipar ( 2 ) / ipar ( 12 ) biny = ipar ( 3 ) / ipar ( 12 ) bindx = 1.0 / float ( ipar ( 12 ) ** 2 ) allocate ( EBSDvector ( binx * biny ), mask ( binx , biny )) allocate ( EBSDpattern ( ipar ( 2 ), ipar ( 3 ), 1 )) allocate ( binned ( binx , biny )) allocate ( EBSDpatternintd ( ipar ( 2 ), ipar ( 3 )), EBSDpatterninteger ( ipar ( 2 ), ipar ( 3 )), EBSDpatternad ( ipar ( 2 ), ipar ( 3 ))) allocate ( img1 ( binx * biny ), img2 ( binx * biny )) allocate ( img_fit_cumul ( 4 * binx * biny ), img_expt_cumul ( 4 * binx * biny )) binned = 0.0 EBSDpatternintd = 0.0 EBSDpatterninteger = 0 EBSDpatternad = 0 img1 = 0 img2 = 0 img_fit_cumul = 0 img_expt_cumul = 0 mask = 1.0 if ( present ( verbose )) then if ( verbose ) then print * , 'xpc, ypc, L, eu_pat1, eu_pat2, eu_pat3, eu_pat4 = ' , fpar ( 1 ), fpar ( 2 ), fpar ( 7 ), eu ( 1 : 3 ) * 18 0.0 / cPi ,& eu2 ( 1 : 3 ) * 18 0.0 / cPi , eu3 ( 1 : 3 ) * 18 0.0 / cPi , eu4 ( 1 : 3 ) * 18 0.0 / cPi end if end if fpar2 ( 1 : nfpar ) = fpar ( 1 : nfpar ) !============================================================================== !============IMAGE 1=========================================================== !============================================================================== quats ( 1 : 4 , 1 ) = eu2qu ( eu ) fpar2 ( 1 : nfpar ) = fpar ( 1 : nfpar ) fpar2 ( 1 ) = fpar ( 1 ) + ipar ( 13 ) * fpar ( 12 ) / fpar ( 3 ) fpar2 ( 2 ) = fpar ( 2 ) - ipar ( 14 ) * fpar ( 13 ) / fpar ( 3 ) call getEBSDPatterns ( ipar , fpar2 , EBSDpattern , quats , accum_e , mLPNH , mLPSH ) !nnx = ipar(2) !nny = ipar(3) !EBSDpatternintd = ((EBSDPattern(:,:,1) - mi)/ (ma-mi)) !EBSDpatterninteger = nint(EBSDpatternintd*255.0) !EBSDpatternad =  adhisteq(10,nnx,nny,EBSDpatterninteger) !EBSDPattern(:,:,1) = float(EBSDpatternad) if ( ipar ( 12 ) . ne . 1 ) then do i = 1 , binx do j = 1 , biny binned ( i , j ) = sum ( EBSDpattern (( i - 1 ) * ipar ( 12 ) + 1 : i * ipar ( 12 ),( j - 1 ) * ipar ( 12 ) + 1 : j * ipar ( 12 ), 1 )) end do end do binned = binned * bindx else binned ( 1 : binx , 1 : biny ) = EBSDpattern ( 1 : binx , 1 : biny , 1 ) end if if ( ipar ( 11 ) . eq . 1 ) then do i = 1 , binx do j = 1 , biny if ((( float ( i ) - ceiling ( float ( binx ) / 2.0 )) ** 2 + ( float ( j ) - ceiling ( float ( biny ) / 2.0 )) ** 2 ) . gt . fpar ( 11 ) ** 2 ) then mask ( i , j ) = 0.0 end if end do end do end if binned ( 1 : binx , 1 : biny ) = binned ( 1 : binx , 1 : biny ) * mask ( 1 : binx , 1 : biny ) binned = binned ** fpar ( 10 ) do i = 1 , biny do j = 1 , binx EBSDvector (( i - 1 ) * binx + j ) = binned ( j , i ) end do end do ma = maxval ( EBSDvector ) mi = minval ( EBSDvector ) img1 = nint ( 25 5.0 * ( EBSDvector - mi ) / ( ma - mi )) ma = maxval ( expt ) mi = minval ( expt ) img2 = nint ( 25 5.0 * ( expt - mi ) / ( ma - mi )) img_fit_cumul ( 1 : binx * biny ) = img1 ( 1 : binx * biny ) img_expt_cumul ( 1 : binx * biny ) = img2 ( 1 : binx * biny ) !open(unit=13,file='/Users/saranshsingh/Desktop/testd.txt',action='write') !open(unit=14,file='/Users/saranshsingh/Desktop/teste.txt',action='write') !do i = 1,binx !    do j = 1,biny !        write(13,'(F15.6)',advance='no')EBSDvector((i-1)*biny+j) !        write(14,'(F15.6)',advance='no')expt((i-1)*biny+j) !    end do !    write(13,*)'' !    write(14,*)'' !end do !close(13) !close(14) !stop !============================================================================== !============IMAGE 2=========================================================== !============================================================================== quats ( 1 : 4 , 1 ) = eu2qu ( eu2 ) fpar2 ( 1 : nfpar ) = fpar ( 1 : nfpar ) fpar2 ( 1 ) = fpar ( 1 ) + ipar ( 15 ) * fpar ( 12 ) / fpar ( 3 ) fpar2 ( 2 ) = fpar ( 2 ) - ipar ( 16 ) * fpar ( 13 ) / fpar ( 3 ) call getEBSDPatterns ( ipar , fpar2 , EBSDpattern , quats , accum_e , mLPNH , mLPSH ) if ( ipar ( 12 ) . ne . 1 ) then do i = 1 , binx do j = 1 , biny binned ( i , j ) = sum ( EBSDpattern (( i - 1 ) * ipar ( 12 ) + 1 : i * ipar ( 12 ),( j - 1 ) * ipar ( 12 ) + 1 : j * ipar ( 12 ), 1 )) end do end do binned = binned * bindx else binned ( 1 : binx , 1 : biny ) = EBSDpattern ( 1 : binx , 1 : biny , 1 ) end if binned ( 1 : binx , 1 : biny ) = binned ( 1 : binx , 1 : biny ) * mask ( 1 : binx , 1 : biny ) binned = binned ** fpar ( 10 ) do i = 1 , biny do j = 1 , binx EBSDvector (( i - 1 ) * binx + j ) = binned ( j , i ) end do end do ma = maxval ( EBSDvector ) mi = minval ( EBSDvector ) img1 = nint ( 25 5.0 * ( EBSDvector - mi ) / ( ma - mi )) ma = maxval ( expt2 ) mi = minval ( expt2 ) img2 = nint ( 25 5.0 * ( expt2 - mi ) / ( ma - mi )) img_fit_cumul ( binx * biny + 1 : 2 * binx * biny ) = img1 ( 1 : binx * biny ) img_expt_cumul ( binx * biny + 1 : 2 * binx * biny ) = img2 ( 1 : binx * biny ) !============================================================================== !============IMAGE 3=========================================================== !============================================================================== quats ( 1 : 4 , 1 ) = eu2qu ( eu3 ) fpar2 ( 1 : nfpar ) = fpar ( 1 : nfpar ) fpar2 ( 1 ) = fpar ( 1 ) + ipar ( 17 ) * fpar ( 12 ) / fpar ( 3 ) fpar2 ( 2 ) = fpar ( 2 ) - ipar ( 18 ) * fpar ( 13 ) / fpar ( 3 ) call getEBSDPatterns ( ipar , fpar2 , EBSDpattern , quats , accum_e , mLPNH , mLPSH ) if ( ipar ( 12 ) . ne . 1 ) then do i = 1 , binx do j = 1 , biny binned ( i , j ) = sum ( EBSDpattern (( i - 1 ) * ipar ( 12 ) + 1 : i * ipar ( 12 ),( j - 1 ) * ipar ( 12 ) + 1 : j * ipar ( 12 ), 1 )) end do end do binned = binned * bindx else binned ( 1 : binx , 1 : biny ) = EBSDpattern ( 1 : binx , 1 : biny , 1 ) end if binned ( 1 : binx , 1 : biny ) = binned ( 1 : binx , 1 : biny ) * mask ( 1 : binx , 1 : biny ) binned = binned ** fpar ( 10 ) do i = 1 , biny do j = 1 , binx EBSDvector (( i - 1 ) * binx + j ) = binned ( j , i ) end do end do ma = maxval ( EBSDvector ) mi = minval ( EBSDvector ) img1 = nint ( 25 5.0 * ( EBSDvector - mi ) / ( ma - mi )) ma = maxval ( expt3 ) mi = minval ( expt3 ) img2 = nint ( 25 5.0 * ( expt3 - mi ) / ( ma - mi )) img_fit_cumul ( 2 * binx * biny + 1 : 3 * binx * biny ) = img1 ( 1 : binx * biny ) img_expt_cumul ( 2 * binx * biny + 1 : 3 * binx * biny ) = img2 ( 1 : binx * biny ) !============================================================================== !============IMAGE 4=========================================================== !============================================================================== quats ( 1 : 4 , 1 ) = eu2qu ( eu4 ) fpar2 ( 1 : nfpar ) = fpar ( 1 : nfpar ) fpar2 ( 1 ) = fpar ( 1 ) + ipar ( 19 ) * fpar ( 12 ) / fpar ( 3 ) fpar2 ( 2 ) = fpar ( 2 ) - ipar ( 20 ) * fpar ( 13 ) / fpar ( 3 ) call getEBSDPatterns ( ipar , fpar2 , EBSDpattern , quats , accum_e , mLPNH , mLPSH ) if ( ipar ( 12 ) . ne . 1 ) then do i = 1 , binx do j = 1 , biny binned ( i , j ) = sum ( EBSDpattern (( i - 1 ) * ipar ( 12 ) + 1 : i * ipar ( 12 ),( j - 1 ) * ipar ( 12 ) + 1 : j * ipar ( 12 ), 1 )) end do end do binned = binned * bindx else binned ( 1 : binx , 1 : biny ) = EBSDpattern ( 1 : binx , 1 : biny , 1 ) end if binned ( 1 : binx , 1 : biny ) = binned ( 1 : binx , 1 : biny ) * mask ( 1 : binx , 1 : biny ) binned = binned ** fpar ( 10 ) do i = 1 , biny do j = 1 , binx EBSDvector (( i - 1 ) * binx + j ) = binned ( j , i ) end do end do ma = maxval ( EBSDvector ) mi = minval ( EBSDvector ) img1 = nint ( 25 5.0 * ( EBSDvector - mi ) / ( ma - mi )) ma = maxval ( expt4 ) mi = minval ( expt4 ) img2 = nint ( 25 5.0 * ( expt4 - mi ) / ( ma - mi )) img_fit_cumul ( 3 * binx * biny + 1 : 4 * binx * biny ) = img1 ( 1 : binx * biny ) img_expt_cumul ( 3 * binx * biny + 1 : 4 * binx * biny ) = img2 ( 1 : binx * biny ) F = Jaccard_Distance ( img_fit_cumul , img_expt_cumul , 4 * binx * biny ) !F = 1.0 - DOT_PRODUCT(EBSDvector,expt) end subroutine EBSD4calfun","tags":"","loc":"proc/ebsd4calfun.html","title":"EBSD4calfun – Fortran Program"},{"text":"public recursive subroutine EBSDcalfun(nipar, nfpar, ninit, ipar, fpar, initmeanval, expt, accum_e, mLPNH, mLPSH, n, x, f, nstep, stepsize, verbose) Uses: local rotations constants distortion filters Indexingmod iso_c_binding proc~~ebsdcalfun~~UsesGraph proc~ebsdcalfun EBSDcalfun iso_c_binding iso_c_binding iso_c_binding->proc~ebsdcalfun module~constants constants module~constants->proc~ebsdcalfun module~filters filters module~filters->proc~ebsdcalfun module~distortion distortion module~distortion->proc~ebsdcalfun rotations rotations rotations->proc~ebsdcalfun module~indexingmod Indexingmod module~indexingmod->proc~ebsdcalfun local local local->proc~ebsdcalfun local->module~constants local->module~filters local->module~distortion local->module~indexingmod module~namelisttypedefs NameListTypedefs local->module~namelisttypedefs module~namelisttypedefs->module~indexingmod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief This function is used by bobyqa to fit an EBSD pattern\n @details The main purpose of this routine is to calculte the difference of 1 with the dot\n product of an experimental pattern with the given set of detector parameters. This is used\n by bobyqa module to fit an EBSD pattern. This routine will first compute the detector arrays rgx etc. if necessary, and then perform\n the usual interpolation from the square Lambert projection. The pattern will be a basic pattern,\n without any intensity scaling or binning etc; the calling program should take care of those \n operations.\n @param ipar array with integer input parameters\n @param fpar array with float input parameters\n @param initmeanval mean value of search space\n @param EBSDpattern output array\n @param quats quaternion input array\n @param accum_e array with Monte Carlo histogram\n @param mLPNH Northern hemisphere master pattern\n @param mLPSH Southern hemisphere master pattern\n @date 12/12/15 SS 1.0 original\n @date 03/28/16 SS 1.1 omega is no longer a variable parameter Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar integer(kind=irg), intent(in) :: ninit integer(kind=c_size_t), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fpar (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) real(kind=c_float), intent(in) :: expt (ipar(2)*ipar(3)/ipar(12)**2) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) integer(kind=irg), intent(in) :: n real(kind=dbl), intent(in), dimension(:) :: x real(kind=dbl), intent(out) :: f integer(kind=irg), intent(in) :: nstep real(kind=sgl), intent(in) :: stepsize (nstep) logical, intent(in), optional :: verbose Calls proc~~ebsdcalfun~~CallsGraph proc~ebsdcalfun EBSDcalfun float float proc~ebsdcalfun->float eu2qu eu2qu proc~ebsdcalfun->eu2qu jaccard_distance jaccard_distance proc~ebsdcalfun->jaccard_distance sngl sngl proc~ebsdcalfun->sngl proc~adhisteq adhisteq proc~ebsdcalfun->proc~adhisteq proc~getebsdpatterns getEBSDPatterns proc~ebsdcalfun->proc~getebsdpatterns proc~adhisteq->float proc~cumul_histogram cumul_histogram proc~adhisteq->proc~cumul_histogram proc~getebsdpatterns->float proc~getebsdpatterns->sngl quat_lp quat_lp proc~getebsdpatterns->quat_lp lambertspheretosquare lambertspheretosquare proc~getebsdpatterns->lambertspheretosquare proc~cumul_histogram->float proc~image_histogram image_histogram proc~cumul_histogram->proc~image_histogram Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code EBSDcalfun Source Code recursive subroutine EBSDcalfun ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt , accum_e , & mLPNH , mLPSH , n , x , f , nstep , stepsize , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: EBSDcalfun ! the input parameters are all part of a ipar and fpar input arrays instead of the usual namelist structures. ! The following is the mapping: ! ! ipar(1) = 2 ! ipar(2) = detnumsx ! ipar(3) = detnumsy ! ipar(4) = detnumEbins ! ipar(5) = mcnsx ! ipar(6) = mpnpx ! ipar(7) = numset ! ipar(8) = numquats ! ipar(9) = Emin ! ipar(10) = Emax ! ipar(11) = 0/1 ;0 for no mask, 1 for mask ! ipar(12) = binning ! ipar(13) = 0/1; 0 for DP and 1 for JD ! ipar(14) = nregions ! fpar(1) = enl%xpc ! fpar(2) = enl%ypc ! fpar(3) = enl%delta ! fpar(4) = enl%MCsig ! fpar(5) = enl%omega ! fpar(6) = enl%thetac ! fpar(7) = enl%L ! fpar(8) = enl%beamcurrent ! fpar(9) = enl%dwelltime ! fpar(10) = alphaBD ; barrell distortion coefficient ! fpar(11) = maskradius ! fpar(12) = enl%gammavalue ! initmeanval(1) = fpar(7) ! initmeanval(2) = phi1 ! initmeanval(3) = phi ! initmeanval(4) = phi2 ! initmeanval(5) = xpc ! initmeanval(6) = ypc ! stepsize(1) = step_xpc ! stepsize(2) = step_ypc ! stepsize(3) = step_phi1 ! stepsize(4) = step_phi ! stepsize(5) = step_phi2 ! stepsize(6) = step_L ! X = (/xpc, ypc, omega, L, phi1, phi, phi2/) use local use rotations use constants use distortion use filters use Indexingmod , ONLY : Jaccard_Distance use , INTRINSIC :: ISO_C_BINDING implicit none integer ( irg ), intent ( in ) :: nipar integer ( irg ), intent ( in ) :: nfpar integer ( irg ), intent ( in ) :: ninit integer ( c_size_t ), intent ( in ) :: ipar ( nipar ) real ( sgl ), intent ( inout ) :: fpar ( nfpar ) real ( sgl ), intent ( in ) :: initmeanval ( ninit ) integer ( irg ), intent ( in ) :: nstep real ( sgl ), intent ( in ) :: stepsize ( nstep ) real ( c_float ), intent ( in ) :: expt ( ipar ( 2 ) * ipar ( 3 ) / ipar ( 12 ) ** 2 ) real ( kind = sgl ), INTENT ( in ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( kind = sgl ), INTENT ( in ) :: mLPNH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) real ( kind = sgl ), INTENT ( in ) :: mLPSH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) integer ( irg ), intent ( in ) :: n real ( dbl ), dimension (:), intent ( in ) :: x real ( dbl ), intent ( out ) :: f logical , intent ( in ), optional :: verbose integer ( kind = irg ) :: nnx , nny , binx , biny complex ( dbl ) :: D real ( kind = sgl ) :: quats ( 4 , 1 ), bindx , ma , mi real ( kind = sgl ), allocatable :: EBSDpattern (:,:,:), binned (:,:) real ( kind = sgl ), allocatable :: EBSDpatternintd (:,:) integer ( kind = irg ), allocatable :: EBSDpatterninteger (:,:), EBSDpatternad (:,:) ! variables that must be saved for the next time this function is called real ( kind = sgl ) :: prefactor integer ( kind = irg ), allocatable :: img1 (:), img2 (:) ! other variables real ( kind = sgl ), parameter :: dtor = 0.0174533 ! convert from degrees to radians real ( kind = sgl ) :: ixy ( 2 ), eu ( 3 ), eu2 ( 3 ), eu3 ( 3 ), eu4 ( 3 ) real ( kind = sgl ), allocatable :: EBSDvector (:), EBSDflip (:,:), mask (:,:) integer ( kind = irg ) :: i , j , istat logical :: stat , readonly integer ( kind = irg ) :: hdferr , nlines , nregions real ( kind = sgl ) :: fpar2 ( 10 ) integer ( kind = 8 ) :: ipar2 ( 10 ) fpar ( 1 ) = sngl ( X ( 1 )) * 2.0 * stepsize ( 1 ) - stepsize ( 1 ) + initmeanval ( 5 ) ! xpc +/- 5 pixels fpar ( 2 ) = sngl ( X ( 2 )) * 2.0 * stepsize ( 2 ) - stepsize ( 2 ) + initmeanval ( 6 ) ! ypc +/- 5 pixels fpar ( 7 ) = sngl ( X ( 4 )) * 2.0 * stepsize ( 6 ) * fpar ( 3 ) - stepsize ( 6 ) * fpar ( 3 ) + initmeanval ( 1 ) ! mean +/- 5 pixels ! 03/28/16 omega is no longer a variable parameter anymore fpar ( 5 ) = sngl ( X ( 3 )) * 0.0 - 0.0 eu = ( / X ( 5 ) * 2.0 * stepsize ( 3 ) - stepsize ( 3 ) + initmeanval ( 2 ), X ( 6 ) * 2.0 * stepsize ( 4 ) - stepsize ( 4 ) + initmeanval ( 3 ), & X ( 7 ) * 2.0 * stepsize ( 5 ) - stepsize ( 5 ) + initmeanval ( 4 ) / ) * dtor ! mean +/- 2 degrees binx = ipar ( 2 ) / ipar ( 12 ) biny = ipar ( 3 ) / ipar ( 12 ) bindx = 1.0 / float ( ipar ( 12 ) ** 2 ) nnx = ipar ( 2 ) nny = ipar ( 3 ) nregions = IPAR ( 14 ) allocate ( EBSDvector ( binx * biny ), mask ( binx , biny )) allocate ( EBSDpattern ( ipar ( 2 ), ipar ( 3 ), 1 )) allocate ( binned ( binx , biny )) allocate ( EBSDpatternintd ( ipar ( 2 ), ipar ( 3 )), EBSDpatterninteger ( ipar ( 2 ), ipar ( 3 )), EBSDpatternad ( ipar ( 2 ), ipar ( 3 ))) allocate ( img1 ( binx * biny ), img2 ( binx * biny )) binned = 0.0 EBSDpatternintd = 0.0 EBSDpatterninteger = 0 EBSDpatternad = 0 img1 = 0 img2 = 0 mask = 1.0 if ( present ( verbose )) then if ( verbose ) then print * , 'xpc, ypc, L, eu = ' , fpar ( 1 ), fpar ( 2 ), fpar ( 7 ), eu ( 1 : 3 ) * 18 0.0 / cPi end if end if fpar2 ( 1 : 10 ) = fpar ( 1 : 10 ) ipar2 ( 1 : 10 ) = ipar ( 1 : 10 ) quats ( 1 : 4 , 1 ) = eu2qu ( eu ) call getEBSDPatterns ( ipar2 , fpar2 , EBSDpattern , quats , accum_e , mLPNH , mLPSH ) ma = maxval ( EBSDPattern (:,:, 1 )) mi = minval ( EBSDPattern (:,:, 1 )) EBSDpatternintd = (( EBSDPattern (:,:, 1 ) - mi ) / ( ma - mi )) EBSDpatterninteger = nint ( EBSDpatternintd * 25 5.0 ) EBSDpatternad = adhisteq ( nregions , nnx , nny , EBSDpatterninteger ) EBSDPattern (:,:, 1 ) = float ( EBSDpatternad ) if ( ipar ( 12 ) . ne . 1 ) then do i = 1 , binx do j = 1 , biny binned ( i , j ) = sum ( EBSDpattern (( i - 1 ) * ipar ( 12 ) + 1 : i * ipar ( 12 ),( j - 1 ) * ipar ( 12 ) + 1 : j * ipar ( 12 ), 1 )) end do end do binned = binned * bindx else binned ( 1 : binx , 1 : biny ) = EBSDpattern ( 1 : binx , 1 : biny , 1 ) end if if ( ipar ( 11 ) . eq . 1 ) then do i = 1 , binx do j = 1 , biny if ((( float ( i ) - ceiling ( float ( binx ) / 2.0 )) ** 2 + ( float ( j ) - ceiling ( float ( biny ) / 2.0 )) ** 2 ) . gt . fpar ( 11 ) ** 2 ) then mask ( i , j ) = 0.0 end if end do end do end if binned ( 1 : binx , 1 : biny ) = binned ( 1 : binx , 1 : biny ) * mask ( 1 : binx , 1 : biny ) binned = binned ** fpar ( 12 ) do i = 1 , biny do j = 1 , binx EBSDvector (( i - 1 ) * binx + j ) = binned ( j , i ) end do end do EBSDvector = EBSDvector / NORM2 ( EBSDvector ) if ( IPAR ( 13 ) . eq . 1 ) then ma = maxval ( EBSDvector ) mi = minval ( EBSDvector ) img1 = nint ( 25 5.0 * ( EBSDvector - mi ) / ( ma - mi )) ma = maxval ( expt ) mi = minval ( expt ) img2 = nint ( 25 5.0 * ( expt - mi ) / ( ma - mi )) F = Jaccard_Distance ( img1 , img2 , binx * biny ) else F = 1.0 - DOT_PRODUCT ( EBSDvector , expt ) end if end subroutine EBSDcalfun","tags":"","loc":"proc/ebsdcalfun.html","title":"EBSDcalfun – Fortran Program"},{"text":"public recursive subroutine ECPcalfun(nipar, nfpar, ninit, ipar, fpar, initmeanval, expt, accum_e, mLPNH, mLPSH, n, x, f, nstep, stepsize, verbose) Uses: local rotations constants distortion iso_c_binding filters Indexingmod proc~~ecpcalfun~~UsesGraph proc~ecpcalfun ECPcalfun module~filters filters module~filters->proc~ecpcalfun module~constants constants module~constants->proc~ecpcalfun iso_c_binding iso_c_binding iso_c_binding->proc~ecpcalfun module~distortion distortion module~distortion->proc~ecpcalfun rotations rotations rotations->proc~ecpcalfun module~indexingmod Indexingmod module~indexingmod->proc~ecpcalfun local local local->proc~ecpcalfun local->module~filters local->module~constants local->module~distortion local->module~indexingmod module~namelisttypedefs NameListTypedefs local->module~namelisttypedefs module~namelisttypedefs->module~indexingmod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief This function is used by bobyqa to fit an EBSD pattern\n @etails The main purpose of this routine is to calculte the difference of 1 with the dot\n product of an experimental pattern with the given set of detector parameters. This is used\n by bobyqa module to fit an EBSD pattern. This routine will first compute the detector arrays rgx etc. if necessary, and then perform\n the usual interpolation from the square Lambert projection. The pattern will be a basic pattern,\n without any intensity scaling or binning etc; the calling program should take care of those \n operations.\n @param ipar array with integer input parameters\n @param fpar array with float input parameters\n @param initmeanval array with mean value of search space\n @param ECPattern output array\n @param quats array of quaternions\n @param accum_e array with Monte Carlo histogram\n @param mLPNH Northern hemisphere master pattern\n @param mLPSH Southern hemisphere master pattern\n @date 12/12/15  SS 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar integer(kind=irg), intent(in) :: ninit integer(kind=c_size_t), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fpar (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) real(kind=c_float), intent(in) :: expt (ipar(2)*ipar(3)/ipar(12)**2) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) integer(kind=irg), intent(in) :: n real(kind=dbl), intent(in), dimension(:) :: x real(kind=dbl), intent(out) :: f integer(kind=irg), intent(in) :: nstep real(kind=sgl), intent(in) :: stepsize (nstep) logical, intent(in), optional :: verbose Calls proc~~ecpcalfun~~CallsGraph proc~ecpcalfun ECPcalfun proc~getecpatterns getECPatterns proc~ecpcalfun->proc~getecpatterns sngl sngl proc~ecpcalfun->sngl jaccard_distance jaccard_distance proc~ecpcalfun->jaccard_distance eu2qu eu2qu proc~ecpcalfun->eu2qu float float proc~ecpcalfun->float proc~getecpatterns->sngl proc~getecpatterns->float quat_lp quat_lp proc~getecpatterns->quat_lp lambertspheretosquare lambertspheretosquare proc~getecpatterns->lambertspheretosquare Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code ECPcalfun Source Code recursive subroutine ECPcalfun ( nipar , nfpar , ninit , ipar , fpar , initmeanval , expt , accum_e , mLPNH , mLPSH , & n , x , f , nstep , stepsize , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: ECPcalfun ! the input parameters are all part of a ipar and fpar input arrays instead of the usual namelist structures. ! The following is the mapping: ! ! ipar(1) = 1 ! ipar(2) = detnumsx ! ipar(3) = detnumsy ! ipar(4) = numangle ! ipar(5) = mcnsx ! ipar(6) = mpnpx ! ipar(7) = numset ! ipar(8) = numquats ! ipar(9) = 0/1 ;0 for no mask, 1 for mask ! ipar(10) = 1; equal to numEbins ! ipar(11) = 0/1; 0 for DP 1 for JD ! ipar(12) = 1 ;binning ! fpar(1) = ecpnl%thetac ! fpar(2) = ecpnl%sampletilt ! fpar(3) = ecpnl%workingdistance ! fpar(4) = ecpnl%Rin ! fpar(5) = ecpnl%Rout ! fpar(6) = ecpnl%sigstart ! fpar(7) = ecpnl%sigend ! fpar(8) = ecpnl%sigstep ! fpar(9) = ecpnl%gammavalue ! fpar(10) = maskradius ! initmeanval(1) = thetac ! initmeanval(2) = sampletilt ! initmeanval(3) = working distance ! initmeanval(4) = phi1 ! initmeanval(5) = phi ! initmeanval(6) = phi2 ! stepsize(1) = step_thetacone ! stepsize(2) = step_phi1 ! stepsize(3) = step_phi ; all 4 patterns ! stepsize(4) = step_phi2 ; all 4 patterns use local use rotations use constants use distortion use , INTRINSIC :: ISO_C_BINDING use filters use Indexingmod , ONLY : Jaccard_Distance IMPLICIT NONE integer ( c_size_t ), intent ( in ) :: ipar ( nipar ) real ( sgl ), intent ( inout ) :: fpar ( nfpar ) real ( sgl ), intent ( in ) :: initmeanval ( ninit ) integer ( irg ), intent ( in ) :: nipar integer ( irg ), intent ( in ) :: nfpar integer ( irg ), intent ( in ) :: ninit real ( c_float ), intent ( in ) :: expt ( ipar ( 2 ) * ipar ( 3 ) / ipar ( 12 ) ** 2 ) integer ( irg ), intent ( in ) :: nstep real ( sgl ), intent ( in ) :: stepsize ( nstep ) real ( kind = sgl ), INTENT ( in ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( kind = sgl ), INTENT ( in ) :: mLPNH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) real ( kind = sgl ), INTENT ( in ) :: mLPSH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) integer ( irg ), intent ( in ) :: n real ( dbl ), dimension (:), intent ( in ) :: x real ( dbl ), intent ( out ) :: f logical , intent ( in ), optional :: verbose integer ( kind = irg ) :: nnx , nny complex ( dbl ) :: D real ( kind = sgl ) :: quats ( 4 , 1 ), ma , mi real ( kind = sgl ), allocatable :: ECPpattern (:,:,:) real ( kind = sgl ), allocatable :: binned (:,:) real ( kind = sgl ), allocatable :: ECPpatternintd (:,:) integer ( kind = irg ), allocatable :: ECPpatterninteger (:,:), ECPpatternad (:,:) real ( kind = sgl ), allocatable :: ECPvector (:), ECPvectorcpy (:), ECPtmp (:,:) real ( kind = sgl ), allocatable :: mask (:,:) integer ( kind = irg ), allocatable :: img1 (:), img2 (:) integer ( kind = irg ) :: istat , i , j real ( kind = sgl ), parameter :: dtor = 0.0174533 ! convert from degrees to radians real ( kind = sgl ) :: eu ( 3 ) logical :: stat , readonly integer ( kind = irg ) :: hdferr , nlines , nregions fpar ( 1 ) = sngl ( X ( 1 )) * 2.0 * stepsize ( 1 ) - stepsize ( 1 ) + initmeanval ( 1 ) ! thetac mean +/- stepsize degrees degrees only eu = ( / X ( 2 ) * 2.0 * stepsize ( 2 ) - stepsize ( 2 ) + initmeanval ( 2 ), X ( 3 ) * 2.0 * stepsize ( 3 ) - stepsize ( 3 ) + initmeanval ( 3 ), & X ( 4 ) * 2.0 * stepsize ( 4 ) - stepsize ( 4 ) + initmeanval ( 4 ) / ) * cPi / 18 0.0 ! mean +/- stepsize quats ( 1 : 4 , 1 ) = eu2qu ( eu ) !D = dcmplx(0.D0,0.D0) ! read all the files allocate ( ECPvector ( ipar ( 2 ) * ipar ( 3 )), mask ( ipar ( 2 ), ipar ( 3 ))) allocate ( ECPpattern ( ipar ( 2 ), ipar ( 3 ), ipar ( 8 ))) allocate ( ECPpatternintd ( ipar ( 2 ), ipar ( 3 )), ECPpatterninteger ( ipar ( 2 ), ipar ( 3 )), ECPpatternad ( ipar ( 2 ), ipar ( 3 ))) ECPpatternintd = 0.0 ECPpatterninteger = 0 ECPpatternad = 0 if ( present ( verbose )) then if ( verbose ) then print * , 'thetac, eu = ' , sngl ( X ( 1 )) * 2.0 * stepsize ( 1 ) - stepsize ( 1 ) + initmeanval ( 1 ), eu * 18 0.0 / cPi end if end if mask = 1.0 do i = 1 , ipar ( 2 ) do j = 1 , ipar ( 3 ) if ((( float ( i ) - ceiling ( float ( ipar ( 2 )) / 2.0 )) ** 2 + ( float ( j ) - ceiling ( float ( ipar ( 3 )) / 2.0 )) ** 2 ) . gt . fpar ( 10 ) ** 2 ) then mask ( i , j ) = 0.0 end if end do end do call getECPatterns ( ipar , fpar , ECPpattern , quats , accum_e , mLPNH , mLPSH ) nnx = ipar ( 2 ) nny = ipar ( 3 ) !nregions = ipar(12) allocate ( ECPvector ( ipar ( 2 ) * ipar ( 3 )), stat = istat ) if ( ipar ( 9 ) . eq . 1 ) then do i = 1 , ipar ( 8 ) ECPpattern (:,:, i ) = ECPpattern (:,:, i ) * mask end do end if do i = 1 , ipar ( 2 ) do j = 1 , ipar ( 3 ) ECPvector (( i - 1 ) * ipar ( 3 ) + j ) = ECPpattern ( j , i , 1 ) end do end do !ECPvector = 0.0 !do i = 1,ipar(2) !    ECPvector((i-1)*ipar(3)+1:i*ipar(3)) = ECPvectorcpy((ipar(2)-i)*ipar(3)+1:(ipar(2)-i+1)*ipar(3)) !end do ECPvector = ECPvector ** fpar ( 9 ) ECPvector = ECPvector / NORM2 ( ECPvector ) if ( IPAR ( 11 ) . eq . 0 ) then F = 1.0 - DOT_PRODUCT ( ECPvector , expt ) else allocate ( img1 ( ipar ( 2 ) * ipar ( 3 )), img2 ( ipar ( 2 ) * ipar ( 3 ))) ma = maxval ( ECPvector ) mi = minval ( ECPvector ) img1 = nint ( 25 5.0 * ( ECPvector - mi ) / ( ma - mi )) ma = maxval ( expt ) mi = minval ( expt ) img2 = nint ( 25 5.0 * ( expt - mi ) / ( ma - mi )) F = Jaccard_Distance ( img1 , img2 , nnx * nny ) end if end subroutine ECPcalfun","tags":"","loc":"proc/ecpcalfun.html","title":"ECPcalfun – Fortran Program"},{"text":"public recursive function image_histogram(nx, ny, im) result(h) @author Marc De Graef, Carnegie Mellon University\n @brief  compute the histogram of an image \n @param nx x dimension\n @param ny y dimension\n @param im image array; must have values in range [1..256]\n @date 01/23/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nx integer(kind=irg), intent(in) :: ny integer(kind=irg), intent(in) :: im (nx,ny) Return Value integer(kind=irg)\n  (256) Called By proc~~image_histogram~~CalledByGraph proc~image_histogram image_histogram proc~image_mutualinformation image_mutualinformation proc~image_mutualinformation->proc~image_histogram proc~cumul_histogram cumul_histogram proc~cumul_histogram->proc~image_histogram proc~adhisteq adhisteq proc~adhisteq->proc~cumul_histogram proc~ebsdcalfun EBSDcalfun proc~ebsdcalfun->proc~adhisteq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code image_histogram Source Code recursive function image_histogram ( nx , ny , im ) result ( h ) !DEC$ ATTRIBUTES DLLEXPORT :: image_histogram IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: nx integer ( kind = irg ), INTENT ( IN ) :: ny integer ( kind = irg ), INTENT ( IN ) :: im ( nx , ny ) integer ( kind = irg ) :: h ( 256 ) integer ( kind = irg ), parameter :: nh = 256 integer ( kind = irg ) :: i , j ! initialize parameters h = 0 do i = 1 , nx do j = 1 , ny h ( im ( i , j )) = h ( im ( i , j )) + 1 end do end do end function image_histogram","tags":"","loc":"proc/image_histogram.html","title":"image_histogram – Fortran Program"},{"text":"public recursive function image_jointhistogram(nx, ny, im1, im2) result(h) @author Marc De Graef, Carnegie Mellon University\n @brief  compute the joint histogram of two images \n @param nx x dimension\n @param ny y dimension\n @param im1 image array; must have values in range [1..256]\n @param im2 image array; must have values in range [1..256]\n @date 04/23/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nx integer(kind=irg), intent(in) :: ny integer(kind=irg), intent(in) :: im1 (nx,ny) integer(kind=irg), intent(in) :: im2 (nx,ny) Return Value integer(kind=irg)\n  (256,256) Called By proc~~image_jointhistogram~~CalledByGraph proc~image_jointhistogram image_jointhistogram proc~image_mutualinformation image_mutualinformation proc~image_mutualinformation->proc~image_jointhistogram Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code image_jointhistogram Source Code recursive function image_jointhistogram ( nx , ny , im1 , im2 ) result ( h ) !DEC$ ATTRIBUTES DLLEXPORT :: image_jointhistogram IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: nx integer ( kind = irg ), INTENT ( IN ) :: ny integer ( kind = irg ), INTENT ( IN ) :: im1 ( nx , ny ) integer ( kind = irg ), INTENT ( IN ) :: im2 ( nx , ny ) integer ( kind = irg ) :: h ( 256 , 256 ) integer ( kind = irg ), parameter :: nh = 256 integer ( kind = irg ) :: i , j ! initialize parameters h = 0 do i = 1 , nx do j = 1 , ny h ( im1 ( i , j ), im2 ( i , j )) = h ( im1 ( i , j ), im2 ( i , j )) + 1 end do end do end function image_jointhistogram","tags":"","loc":"proc/image_jointhistogram.html","title":"image_jointhistogram – Fortran Program"},{"text":"public recursive function cumul_histogram(nx, ny, im) result(h) @author Marc De Graef, Carnegie Mellon University\n @brief  compute the cumulative histogram of an image \n @param nx x dimension\n @param ny y dimension\n @param im image array; must have values in range [1..256]\n @date 01/23/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nx integer(kind=irg), intent(in) :: ny integer(kind=irg), intent(in) :: im (nx,ny) Return Value integer(kind=irg)\n  (256) Calls proc~~cumul_histogram~~CallsGraph proc~cumul_histogram cumul_histogram proc~image_histogram image_histogram proc~cumul_histogram->proc~image_histogram float float proc~cumul_histogram->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~cumul_histogram~~CalledByGraph proc~cumul_histogram cumul_histogram proc~adhisteq adhisteq proc~adhisteq->proc~cumul_histogram proc~ebsdcalfun EBSDcalfun proc~ebsdcalfun->proc~adhisteq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code cumul_histogram Source Code recursive function cumul_histogram ( nx , ny , im ) result ( h ) !DEC$ ATTRIBUTES DLLEXPORT :: cumul_histogram IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: nx integer ( kind = irg ), INTENT ( IN ) :: ny integer ( kind = irg ), INTENT ( IN ) :: im ( nx , ny ) integer ( kind = irg ) :: h ( 256 ) integer ( kind = irg ), parameter :: nh = 256 integer ( kind = irg ) :: i , j , low , high , hst ( nh ), np , nploc ( 1 ) np = nx * ny hst = 0 ! get the regular histogram h = image_histogram ( nx , ny , im ) ! if all the intensities equal 0, then we need to return a zero cumulative ! histogram. if ( h ( 1 ). eq . np ) then h = 0 return end if ! we need to allow for the possibility that the image is flat, so that ! all intensity is in a single bin.  In that case, the cumulative histogram ! will be a step function and the usual noramlization to [1..256] will ! not work if ( maxval ( h ). eq . np ) then nploc = maxloc ( h ) hst ( 1 : nploc ( 1 ) - 1 ) = h ( 1 ) hst ( nploc ( 1 ): nh ) = 256 h = hst else ! convert h to a cumulative histogram hst hst = 0 hst ( 1 ) = h ( 1 ) do i = 2 , nh hst ( i ) = h ( i ) + hst ( i - 1 ) end do ! and rescale to [1..256] h = int ( 25 5.0 * (( float ( hst ) - float ( hst ( 1 ))) / float ( hst ( nh ) - hst ( 1 )))) + 1 end if end function cumul_histogram","tags":"","loc":"proc/cumul_histogram.html","title":"cumul_histogram – Fortran Program"},{"text":"public recursive function image_entropy(h) result(e) @author Marc De Graef, Carnegie Mellon University\n @brief  compute the Shannon entropy of an image \n @param h a 256 element intensity histogram\n @date 04/23/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: h (256) Return Value real(kind=sgl) Calls proc~~image_entropy~~CallsGraph proc~image_entropy image_entropy float float proc~image_entropy->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~image_entropy~~CalledByGraph proc~image_entropy image_entropy proc~image_mutualinformation image_mutualinformation proc~image_mutualinformation->proc~image_entropy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code image_entropy Source Code recursive function image_entropy ( h ) result ( e ) !DEC$ ATTRIBUTES DLLEXPORT :: image_entropy IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: h ( 256 ) real ( kind = sgl ) :: e integer ( kind = irg ), parameter :: nh = 256 integer ( kind = irg ) :: i , j real ( kind = sgl ) :: hnorm ( 256 ) ! initialize parameters hnorm = float ( h ) ! normalize the histogram hnorm = hnorm / sum ( hnorm ) ! add up the natural logarithm factors for the non-zero bins e = 0.0 do i = 1 , nh if ( h ( i ). ne . 0 ) e = e - hnorm ( i ) * log ( hnorm ( i )) end do end function image_entropy","tags":"","loc":"proc/image_entropy.html","title":"image_entropy – Fortran Program"},{"text":"public recursive function image_jointentropy(h) result(e) @author Marc De Graef, Carnegie Mellon University\n @brief  compute the Shannon joint entropy of two images \n @param h a 256x256 element intensity joint histogram\n @date 04/23/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: h (256,256) Return Value real(kind=sgl) Calls proc~~image_jointentropy~~CallsGraph proc~image_jointentropy image_jointentropy float float proc~image_jointentropy->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~image_jointentropy~~CalledByGraph proc~image_jointentropy image_jointentropy proc~image_mutualinformation image_mutualinformation proc~image_mutualinformation->proc~image_jointentropy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code image_jointentropy Source Code recursive function image_jointentropy ( h ) result ( e ) !DEC$ ATTRIBUTES DLLEXPORT :: image_jointentropy IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: h ( 256 , 256 ) real ( kind = sgl ) :: e integer ( kind = irg ), parameter :: nh = 256 integer ( kind = irg ) :: i , j real ( kind = sgl ) :: hnorm ( 256 , 256 ) ! initialize parameters hnorm = float ( h ) ! normalize the histogram hnorm = hnorm / sum ( hnorm ) ! add up the natural logarithm factors for the non-zero bins e = 0.0 do i = 1 , nh do j = 1 , nh if ( h ( i , j ). ne . 0 ) e = e - hnorm ( i , j ) * log ( hnorm ( i , j )) end do end do end function image_jointentropy","tags":"","loc":"proc/image_jointentropy.html","title":"image_jointentropy – Fortran Program"},{"text":"public recursive function image_mutualinformation(nx, ny, im1, im2) result(mi) @author Marc De Graef, Carnegie Mellon University\n @brief  compute the mutual information of two images \n @param nx x dimension\n @param ny y dimension\n @param im image array; must have values in range [1..256] \n @date 04/23/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nx integer(kind=irg), intent(in) :: ny integer(kind=irg), intent(in) :: im1 (nx,ny) integer(kind=irg), intent(in) :: im2 (nx,ny) Return Value real(kind=sgl) Calls proc~~image_mutualinformation~~CallsGraph proc~image_mutualinformation image_mutualinformation proc~image_entropy image_entropy proc~image_mutualinformation->proc~image_entropy proc~image_jointentropy image_jointentropy proc~image_mutualinformation->proc~image_jointentropy proc~image_jointhistogram image_jointhistogram proc~image_mutualinformation->proc~image_jointhistogram proc~image_histogram image_histogram proc~image_mutualinformation->proc~image_histogram float float proc~image_entropy->float proc~image_jointentropy->float Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code image_mutualinformation Source Code recursive function image_mutualinformation ( nx , ny , im1 , im2 ) result ( mi ) !DEC$ ATTRIBUTES DLLEXPORT :: image_mutualinformation IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: nx integer ( kind = irg ), INTENT ( IN ) :: ny integer ( kind = irg ), INTENT ( IN ) :: im1 ( nx , ny ) integer ( kind = irg ), INTENT ( IN ) :: im2 ( nx , ny ) real ( kind = sgl ) :: mi real ( kind = sgl ) :: e1 , e2 , je ! get the individual and joint histograms e1 = image_entropy ( image_histogram ( nx , ny , im1 )) e2 = image_entropy ( image_histogram ( nx , ny , im2 )) je = image_jointentropy ( image_jointhistogram ( nx , ny , im1 , im2 )) ! compute the mutual information mi = e1 + e2 - je end function image_mutualinformation","tags":"","loc":"proc/image_mutualinformation.html","title":"image_mutualinformation – Fortran Program"},{"text":"public recursive function adhisteq(nr, dimx, dimy, im, verbose) result(output) @author Marc De Graef, Carnegie Mellon University\n @brief  adaptive histogram equalization\n @details This algorithm is based on the original paper by Pizer et al., \n \"Adaptive Histogram Equalization and its Variations\", Computer Vision, \n Graphics, and Image Processing, 39:355-368, 1987. @param nr number of subregions to split the image into [10 works well]\n @param dimx x dimension\n @param dimy y dimension\n @param im image array; must have integer values in range [0..255]\n @date 01/23/16 MDG 1.0 original\n @date 01/27/16 MDG 1.1 correction of off-by-one error in final array copy Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nr integer(kind=irg), intent(in) :: dimx integer(kind=irg), intent(in) :: dimy integer(kind=irg), intent(in) :: im (dimx,dimy) logical, intent(in), optional :: verbose Return Value integer(kind=irg)\n  (dimx,dimy) Calls proc~~adhisteq~~CallsGraph proc~adhisteq adhisteq float float proc~adhisteq->float proc~cumul_histogram cumul_histogram proc~adhisteq->proc~cumul_histogram proc~cumul_histogram->float proc~image_histogram image_histogram proc~cumul_histogram->proc~image_histogram Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~adhisteq~~CalledByGraph proc~adhisteq adhisteq proc~ebsdcalfun EBSDcalfun proc~ebsdcalfun->proc~adhisteq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code adhisteq Source Code recursive function adhisteq ( nr , dimx , dimy , im , verbose ) result ( output ) !DEC$ ATTRIBUTES DLLEXPORT :: adhisteq IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: nr integer ( kind = irg ), INTENT ( IN ) :: dimx integer ( kind = irg ), INTENT ( IN ) :: dimy integer ( kind = irg ), INTENT ( IN ) :: im ( dimx , dimy ) logical , INTENT ( IN ), OPTIONAL :: verbose integer ( kind = irg ) :: output ( dimx , dimy ) integer ( kind = irg ) :: ts , hts , ntx , nty , i , j , i1 , i2 , ir , ic , istop , jstop , ix0 , iy0 , Tvalx , Tvaly integer ( kind = irg ), parameter :: nh = 256 integer ( kind = irg ), allocatable :: subim (:,:) real ( kind = sgl ), allocatable :: tmp (:), tintx (:,:), tinty (:,:), LL (:,:), LR (:,:), UL (:,:), UR (:,:) integer ( kind = irg ), allocatable :: chistarr (:,:,:) if ( PRESENT ( verbose )) write ( * , * ) minval ( im ), maxval ( im ) output = 0 ! determine integer parameters ts = int ( maxval ( ( / dimx , dimy / )) / nr ) ! size of a single tile for histogram computation hts = maxval ( ( / ts / 2 , 1 / ) ) ! half the tile size ntx = ( dimx - 1 ) / hts ! number of tiles along x nty = ( dimy - 1 ) / hts ! number of tiles along y ! allocate temporary array to create tile interpolation matrices allocate ( tmp ( hts )) tmp = ( / ( dble ( i ), i = 0 , hts - 1 ) / ) / dble ( hts ) allocate ( tintx ( hts , hts ), tinty ( hts , hts )) do j = 1 , hts tintx ( 1 : hts , j ) = tmp ( 1 : hts ) end do tinty = transpose ( tintx ) deallocate ( tmp ) ! define the array that will hold two rows of cumulative histograms allocate ( chistarr ( nh , ntx , 2 )) chistarr = 0 do ir = 1 , nty + 1 do i = 1 , ntx chistarr ( 1 : 256 , i , 1 ) = chistarr ( 1 : 256 , i , 2 ) ! copy the histograms from the next row end do ! get the cumulative histograms for this row of tiles if ( ir . lt . nty + 1 ) then do ic = 1 , ntx ! set the sub image array limits ix0 = ( ic - 1 ) * hts + 1 istop = minval ( ( / ix0 + ts - 1 , dimx / ) ) Tvalx = ts if ( istop . eq . dimx ) Tvalx = istop - ix0 + 1 iy0 = ( ir - 1 ) * hts + 1 jstop = minval ( ( / iy0 + ts - 1 , dimy / ) ) Tvaly = ts if ( jstop . eq . dimy ) Tvaly = jstop - iy0 + 1 !if (PRESENT(verbose)) write(*,*) ix0, istop, iy0, jstop, Tvalx, Tvaly ! extract the sub image and compute its cumulative histogram (histogram starts at bin 1) allocate ( subim ( Tvalx , Tvaly )) subim = 0 subim ( 1 : Tvalx , 1 : Tvaly ) = im ( ix0 : istop , iy0 : jstop ) + 1 !if (PRESENT(verbose)) write (*,*) 'subim : ',minval(subim),maxval(subim) chistarr ( 1 : nh , ic , 2 ) = cumul_histogram ( Tvalx , Tvaly , subim ) deallocate ( subim ) end do end if !if (PRESENT(verbose)) write(*,*) minval(chistarr),maxval(chistarr) !stop if ( ir . eq . 1 ) then ! this is done only the first time through... do i = 1 , ntx chistarr ( 1 : 256 , i , 1 ) = chistarr ( 1 : 256 , i , 2 ) ! copy the histograms from the next row end do end if ! and here is the actual interpolation part do ic = 1 , ntx + 1 ! set the sub image array limits (different from above!) ix0 = ( ic - 1 ) * hts + 1 istop = minval ( ( / ix0 + hts - 1 , dimx / ) ) Tvalx = hts if ( istop . eq . dimx ) Tvalx = istop - ix0 + 1 iy0 = ( ir - 1 ) * hts + 1 jstop = minval ( ( / iy0 + hts - 1 , dimy / ) ) Tvaly = hts if ( jstop . eq . dimy ) Tvaly = jstop - iy0 + 1 ! allocate the sub image and the four interpolation arrays allocate ( subim ( Tvalx , Tvaly ), LL ( Tvalx , Tvaly ), LR ( Tvalx , Tvaly ), UL ( Tvalx , Tvaly ), UR ( Tvalx , Tvaly )) ! get the sub image subim ( 1 : Tvalx , 1 : Tvaly ) = im ( ix0 : istop , iy0 : jstop ) + 1 ! set the coordinates to be used in the histogram array i1 = maxval ( ( / ic - 1 , 1 / ) ) i2 = minval ( ( / ic , ntx / ) ) ! and extract the cumulative histogram values for the intensities in the sub image, ! for each of the four interpolation arrays do i = 1 , Tvalx do j = 1 , Tvaly LL ( i , j ) = float ( chistarr ( subim ( i , j ), i1 , 1 )) LR ( i , j ) = float ( chistarr ( subim ( i , j ), i2 , 1 )) UL ( i , j ) = float ( chistarr ( subim ( i , j ), i1 , 2 )) UR ( i , j ) = float ( chistarr ( subim ( i , j ), i2 , 2 )) end do end do ! perform the interpolation along x LL = LL + ( LR - LL ) * tintx ( 1 : Tvalx , 1 : Tvaly ) UL = UL + ( UR - UL ) * tintx ( 1 : Tvalx , 1 : Tvaly ) ! and interpolate along y; store the result in the output array output ( ix0 : istop , iy0 : jstop ) = int ( LL + ( UL - LL ) * tinty ( 1 : Tvalx , 1 : Tvaly )) ! deallocate the arrays deallocate ( subim , LL , LR , UL , UR ) end do end do end function adhisteq","tags":"","loc":"proc/adhisteq.html","title":"adhisteq – Fortran Program"},{"text":"public recursive function HiPassFilter(rdata, dims, w, init, destroy) result(fdata) Uses: FFTW3mod proc~~hipassfilter~~UsesGraph proc~hipassfilter HiPassFilter FFTW3mod FFTW3mod FFTW3mod->proc~hipassfilter Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief  Perform a high pass filter\n @param rdata real data to be transformed\n @param dims dimensions of rdata array\n @param w width of Gaussian profile\n @param init (optional) initialize without computing anything\n @param destroy (optional) destroy fft plans\n @date 02/02/16 MDG 1.0 original\n @date 06/03/16 MDG 1.1 modified mask to inverted Gaussian profile; added init optional parameter Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: rdata (dims(1),dims(2)) integer(kind=irg), intent(in) :: dims (2) real(kind=dbl), intent(in) :: w logical, intent(in), optional :: init logical, intent(in), optional :: destroy Return Value real(kind=dbl)\n  (dims(1),dims(2)) Calls proc~~hipassfilter~~CallsGraph proc~hipassfilter HiPassFilter fftw_plan_dft_2d fftw_plan_dft_2d proc~hipassfilter->fftw_plan_dft_2d float float proc~hipassfilter->float fftw_execute_dft fftw_execute_dft proc~hipassfilter->fftw_execute_dft fftw_destroy_plan fftw_destroy_plan proc~hipassfilter->fftw_destroy_plan dexp dexp proc~hipassfilter->dexp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code HiPassFilter Source Code recursive function HiPassFilter ( rdata , dims , w , init , destroy ) result ( fdata ) !DEC$ ATTRIBUTES DLLEXPORT :: HiPassFilter use FFTW3mod IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dims ( 2 ) real ( kind = dbl ), INTENT ( IN ) :: w real ( kind = dbl ), INTENT ( IN ) :: rdata ( dims ( 1 ), dims ( 2 )) logical , INTENT ( IN ), OPTIONAL :: init logical , INTENT ( IN ), OPTIONAL :: destroy real ( kind = dbl ) :: fdata ( dims ( 1 ), dims ( 2 )) complex ( kind = dbl ), SAVE , allocatable :: hpmask (:,:) complex ( kind = dbl ) :: cone = cmplx ( 1.D0 , 0.D0 ), czero = cmplx ( 0.D0 , 0.D0 ) integer ( kind = irg ) :: i , j , k , ii , jj real ( kind = dbl ) :: x , y , val ! fftw variables type ( C_PTR ), SAVE :: planf , planb complex ( C_DOUBLE_COMPLEX ), SAVE , allocatable :: inp (:,:), outp (:,:) ! are we just destroying the fftw plans ? if ( present ( destroy )) then if ( destroy ) then deallocate ( hpmask , inp , outp ) call fftw_destroy_plan ( planf ) call fftw_destroy_plan ( planb ) fdata = 0.D0 return end if end if ! if init=.TRUE. then initialize the hpmask variable and the fftw plans if ( present ( init )) then if ( init ) then ! allocate arrays allocate ( hpmask ( dims ( 1 ), dims ( 2 )), inp ( dims ( 1 ), dims ( 2 )), outp ( dims ( 1 ), dims ( 2 ))) ! generate the complex inverted Gaussian mask; w = 0.05 produces good results (usually) do i = 1 , dims ( 1 ) / 2 x = float ( i ) do j = 1 , dims ( 2 ) / 2 y = float ( j ) val = 1.D0 - dexp ( - w * ( x * x + y * y )) hpmask ( i , j ) = cmplx ( val , 0.D0 ) hpmask ( dims ( 1 ) + 1 - i , j ) = cmplx ( val , 0.D0 ) hpmask ( i , dims ( 2 ) + 1 - j ) = cmplx ( val , 0.D0 ) hpmask ( dims ( 1 ) + 1 - i , dims ( 2 ) + 1 - j ) = cmplx ( val , 0.D0 ) fdata ( i , j ) = val fdata ( dims ( 1 ) + 1 - i , j ) = val fdata ( i , dims ( 2 ) + 1 - j ) = val fdata ( dims ( 1 ) + 1 - i , dims ( 2 ) + 1 - j ) = val end do end do ! then we set up the fftw plans for forward and reverse transforms planf = fftw_plan_dft_2d ( dims ( 2 ), dims ( 1 ), inp , outp , FFTW_FORWARD , FFTW_ESTIMATE ) planb = fftw_plan_dft_2d ( dims ( 2 ), dims ( 1 ), inp , outp , FFTW_BACKWARD , FFTW_ESTIMATE ) ! and return return end if end if ! apply the hi-pass mask to rdata do j = 1 , dims ( 1 ) do k = 1 , dims ( 2 ) inp ( j , k ) = cmplx ( rdata ( j , k ), 0.D0 ) end do end do call fftw_execute_dft ( planf , inp , outp ) inp = outp * hpmask call fftw_execute_dft ( planb , inp , outp ) fdata ( 1 : dims ( 1 ), 1 : dims ( 2 )) = real ( outp ) end function HiPassFilter","tags":"","loc":"proc/hipassfilter.html","title":"HiPassFilter – Fortran Program"},{"text":"public recursive subroutine CalcHoughLUT(dimx, LUT) Uses: constants proc~~calchoughlut~~UsesGraph proc~calchoughlut CalcHoughLUT module~constants constants module~constants->proc~calchoughlut local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief  create a look-up table for a square Hough transform\n @param dimx x dimension\n @param LUT look-up table, allocated in calling program\n @date 02/02/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dimx real(kind=sgl), intent(out) :: LUT (dimx*dimx,dimx) Calls proc~~calchoughlut~~CallsGraph proc~calchoughlut CalcHoughLUT float float proc~calchoughlut->float sngl sngl proc~calchoughlut->sngl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code CalcHoughLUT Source Code recursive subroutine CalcHoughLUT ( dimx , LUT ) !DEC$ ATTRIBUTES DLLEXPORT :: CalcHoughLUT use constants IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dimx real ( kind = sgl ), INTENT ( OUT ) :: LUT ( dimx * dimx , dimx ) real ( kind = sgl ) :: ct ( dimx ), st ( dimx ), pre , line ( dimx ), d2 , x , y integer ( kind = irg ) :: i , j , k , icnt d2 = float ( dimx / 2 ) + 0.5 ! trigonometric look-up tables ct = 0.0 st = 0.0 pre = sngl ( cPi ) / float ( dimx ) line = ( / ( i , i = 0 , dimx - 1 ) / ) * pre ct = cos ( line ) st = sin ( line ) ! and create the look up table LUT = 0.0 icnt = 1 do j = 1 , dimx y = float ( j ) - d2 do i = 1 , dimx x = float ( i ) - d2 LUT ( icnt ,:) = nint ( x * ct (:) + y * st (:)) icnt = icnt + 1 end do end do LUT = LUT + dimx / 2 + 1 ! this is here just so the ped indexing program can be tested out. ! the out of bounds error in the main chunk of the program should be corrected do i = 1 , dimx * dimx do j = 1 , dimx if ( LUT ( i , j ) . gt . dimx ) LUT ( i , j ) = dimx if ( LUT ( i , j ) . lt . 1.0 ) LUT ( i , j ) = 1.0 end do end do end subroutine CalcHoughLUT","tags":"","loc":"proc/calchoughlut.html","title":"CalcHoughLUT – Fortran Program"},{"text":"public recursive subroutine HoughTransform(dimx, LUT, im, HT) @author Marc De Graef, Carnegie Mellon University\n @brief  Perform a square Hough transform\n @param dimx x dimension\n @param LUT look-up table from CalcHoughLUT\n @param im image array (must be mean-subtracted)\n @param HT resulting Hough transform array\n @date 02/02/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dimx real(kind=sgl), intent(in) :: LUT (dimx*dimx,dimx) real(kind=sgl), intent(in) :: im (dimx*dimx) real(kind=sgl), intent(out) :: HT (dimx,dimx) Source Code HoughTransform Source Code recursive subroutine HoughTransform ( dimx , LUT , im , HT ) !DEC$ ATTRIBUTES DLLEXPORT :: HoughTransform IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dimx real ( kind = sgl ), INTENT ( IN ) :: LUT ( dimx * dimx , dimx ) real ( kind = sgl ), INTENT ( IN ) :: im ( dimx * dimx ) real ( kind = sgl ), INTENT ( OUT ) :: HT ( dimx , dimx ) integer ( kind = irg ) :: i , j , k , d2 HT = 0.0 d2 = dimx / 2 do j = 1 , dimx do i = 1 , dimx * dimx k = LUT ( i , j ) HT ( k , j ) = HT ( k , j ) + im ( i ) end do end do HT = transpose ( HT ) end subroutine HoughTransform","tags":"","loc":"proc/houghtransform.html","title":"HoughTransform – Fortran Program"},{"text":"public recursive subroutine ButterflyMask9x9(input, output, dims) Uses: constants proc~~butterflymask9x9~~UsesGraph proc~butterflymask9x9 ButterflyMask9x9 module~constants constants module~constants->proc~butterflymask9x9 local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief apply 9x9 butterfly mask to the hough image\n @param input input image\n @param output output image\n @param dims dimension of these images\n @date 12/06/16 SS 1.0 original Arguments Type Intent Optional Attributes Name real(kind=sgl), intent(in) :: input (dims,dims) real(kind=sgl), intent(out) :: output (dims,dims) integer(kind=irg), intent(in) :: dims Calls proc~~butterflymask9x9~~CallsGraph proc~butterflymask9x9 ButterflyMask9x9 butterfly9x9 butterfly9x9 proc~butterflymask9x9->butterfly9x9 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code ButterflyMask9x9 Source Code recursive subroutine ButterflyMask9x9 ( input , output , dims ) !DEC$ ATTRIBUTES DLLEXPORT :: ButterflyMask9x9 use constants IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dims real ( kind = sgl ), INTENT ( IN ) :: input ( dims , dims ) real ( kind = sgl ), INTENT ( OUT ) :: output ( dims , dims ) integer ( kind = irg ) :: ii , jj , kk , ll real ( kind = sgl ), allocatable :: inputpadded (:,:) allocate ( inputpadded ( - 3 : dims + 4 , - 3 : dims + 4 )) inputpadded = 0.0 inputpadded ( 1 : dims , 1 : dims ) = input ( 1 : dims , 1 : dims ) !inputpadded(-3:0,:1:dims) = input(dims-3:dims,1:dims) !inputpadded(dims+1:dims+4,1:dims) = input(1:4,1:dims) !inputpadded(1:dims,-3:0) = inputpadded(1:dims,dims-3:dims) !inputpadded(1:dims,dims+1:dims+4) = inputpadded(1:dims,1:4) output = 0.0 do ii = 1 , dims do jj = 1 , dims do kk = - 4 , 4 do ll = - 4 , 4 output ( ii , jj ) = output ( ii , jj ) + inputpadded ( ii + kk , jj + ll ) * Butterfly9x9 (( kk + 4 ) * 9 + ll + 5 ) end do end do end do end do deallocate ( inputpadded ) end subroutine ButterflyMask9x9","tags":"","loc":"proc/butterflymask9x9.html","title":"ButterflyMask9x9 – Fortran Program"},{"text":"public recursive subroutine InversionDivision(input, output, dims) @author Saransh Singh, Carnegie Mellon University\n @brief Inversion division operation to enhance contrast of hough image \n @param input input image; must be between 0-1\n @param output output image\n @param dims dimension of these image\n @date 12/06/16 SS 1.0 original Arguments Type Intent Optional Attributes Name real(kind=sgl), intent(in) :: input (dims,dims) real(kind=sgl), intent(out) :: output (dims,dims) integer(kind=irg), intent(in) :: dims Source Code InversionDivision Source Code recursive subroutine InversionDivision ( input , output , dims ) !DEC$ ATTRIBUTES DLLEXPORT :: InversionDivision IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dims real ( kind = sgl ), INTENT ( IN ) :: input ( dims , dims ) real ( kind = sgl ), INTENT ( OUT ) :: output ( dims , dims ) integer ( kind = irg ) :: ii , jj real ( kind = sgl ), allocatable :: inverse (:,:) real ( kind = sgl ) :: ma , mi allocate ( inverse ( dims , dims )) inverse = ( 1.0 - Input ) do ii = 1 , dims do jj = 1 , dims if ( inverse ( ii , jj ) . ne . 0.0 ) then output ( ii , jj ) = input ( ii , jj ) / inverse ( ii , jj ) else output ( ii , jj ) = 1.0 end if end do end do deallocate ( inverse ) ma = maxval ( output ) mi = minval ( output ) output = ( output - mi ) / ( ma - mi ) end subroutine InversionDivision","tags":"","loc":"proc/inversiondivision.html","title":"InversionDivision – Fortran Program"},{"text":"public recursive function Jaccard_Distance(img1, img2, nn) result(JD) Uses: local proc~~jaccard_distance~~UsesGraph proc~jaccard_distance Jaccard_Distance local local local->proc~jaccard_distance Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: img1 (nn) integer(kind=irg), intent(in) :: img2 (nn) integer(kind=irg), intent(in) :: nn Return Value real(kind=dbl) Source Code Jaccard_Distance Source Code recursive function Jaccard_Distance ( img1 , img2 , nn ) result ( JD ) !DEC$ ATTRIBUTES DLLEXPORT :: Jaccard_Distance use local IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: img1 ( nn ) integer ( kind = irg ), INTENT ( IN ) :: img2 ( nn ) integer ( kind = irg ), INTENT ( IN ) :: nn real ( kind = dbl ) :: JD real ( kind = sgl ) :: hist1 ( 256 ), hist2 ( 256 ), jhist ( 256 , 256 ), H1 , H2 , H12 integer ( kind = irg ) :: ii , jj , kk hist1 = 0.D0 hist2 = 0.D0 jhist = 0.D0 H1 = 0.D0 H2 = 0.D0 H12 = 0.D0 do ii = 1 , nn jj = img1 ( ii ) + 1 kk = img2 ( ii ) + 1 jhist ( jj , kk ) = jhist ( jj , kk ) + 1.D0 end do jhist = jhist / nn hist1 ( 1 : 256 ) = sum ( jhist , 2 ) hist2 ( 1 : 256 ) = sum ( jhist , 1 ) !open(unit=13,file='/Users/saranshsingh/Desktop/jh.txt',form='formatted') do ii = 0 , 255 if ( hist1 ( ii + 1 ) . ne . 0.0 ) then H1 = H1 + hist1 ( ii + 1 ) * log ( hist1 ( ii + 1 )) end if if ( hist2 ( ii + 1 ) . ne . 0.0 ) then H2 = H2 + hist2 ( ii + 1 ) * log ( hist2 ( ii + 1 )) end if do jj = 0 , 255 !write(13,'(F15.6)',advance='no')jhist(ii+1,jj+1) if ( jhist ( ii + 1 , jj + 1 ) . ne . 0.0 ) then H12 = H12 + jhist ( ii + 1 , jj + 1 ) * log ( jhist ( ii + 1 , jj + 1 )) end if end do !write(13,*)'' end do !JD = -H12 + (H1 + H2) JD = 2.D0 - ( H1 + H2 ) / H12 end function Jaccard_Distance","tags":"","loc":"proc/jaccard_distance.html","title":"Jaccard_Distance – Fortran Program"},{"text":"public recursive subroutine InnerProdGPU(cl_expt, cl_dict, Ne, Nd, correctsize, results, numd, selnumd, csource, source_length, platform, device, context, command_queue) Uses: local clfortran CLsupport iso_c_binding io error proc~~innerprodgpu~~UsesGraph proc~innerprodgpu InnerProdGPU error error error->proc~innerprodgpu local local local->proc~innerprodgpu module~clsupport CLsupport local->module~clsupport io io io->proc~innerprodgpu iso_c_binding iso_c_binding iso_c_binding->proc~innerprodgpu clfortran clfortran clfortran->proc~innerprodgpu clfortran->module~clsupport module~clsupport->proc~innerprodgpu Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief Perform the inner product computations for the dictionary approach\n @param expt vector with list of observed patterns\n @param dict vector with list of calculated patterns\n @param Ne number of patterns in the expt vector\n @param Nd number of patterns in the dict vector\n @param L size of one single pattern\n @param result result of the matrix multiplication\n @param source the opencl kernel as a character array\n @param length of character array\n @param platform opencl platform type\n @param device opencl device type\n @param context opencl context type\n @param command_queue opencl command queue\n @date 12/09/14  SS 1.0 original\n @date 27/01/15  SS 1.1 modified to call the subroutine from mastersubroutine\n @date 02/24/16 MDG 1.2 converted OpenCL calls to clfortran from fortrancl\n @date 03/03/16 MDG 1.3 added C_NULL_CHAR to kernelname\n @date 06/07/17 MDG 1.4 removed progoptions from Build Program call; caused some issues on Linux in Release mode Arguments Type Intent Optional Attributes Name integer(kind=c_intptr_t), intent(inout), target :: cl_expt integer(kind=c_intptr_t), intent(inout), target :: cl_dict integer(kind=4), intent(in) :: Ne integer(kind=4), intent(in) :: Nd integer(kind=4), intent(in) :: correctsize real(kind=4), intent(out), target :: results (Ne*Nd) integer(kind=irg), intent(in) :: numd integer(kind=irg), intent(in) :: selnumd character(kind=len=source_length,c_char), intent(in), TARGET :: csource integer(kind=c_size_t), intent(in), target :: source_length integer(kind=c_intptr_t), intent(in), allocatable, target :: platform (:) integer(kind=c_intptr_t), intent(inout), allocatable, target :: device (:) integer(kind=c_intptr_t), intent(inout), target :: context integer(kind=c_intptr_t), intent(inout), target :: command_queue Calls proc~~innerprodgpu~~CallsGraph proc~innerprodgpu InnerProdGPU clreleasememobject clreleasememobject proc~innerprodgpu->clreleasememobject clgetprogrambuildinfo clgetprogrambuildinfo proc~innerprodgpu->clgetprogrambuildinfo clcreatekernel clcreatekernel proc~innerprodgpu->clcreatekernel clenqueuendrangekernel clenqueuendrangekernel proc~innerprodgpu->clenqueuendrangekernel clenqueuereadbuffer clenqueuereadbuffer proc~innerprodgpu->clenqueuereadbuffer clreleasekernel clreleasekernel proc~innerprodgpu->clreleasekernel clsetkernelarg clsetkernelarg proc~innerprodgpu->clsetkernelarg clreleaseprogram clreleaseprogram proc~innerprodgpu->clreleaseprogram clcreatebuffer clcreatebuffer proc~innerprodgpu->clcreatebuffer clfinish clfinish proc~innerprodgpu->clfinish clcreateprogramwithsource clcreateprogramwithsource proc~innerprodgpu->clcreateprogramwithsource clbuildprogram clbuildprogram proc~innerprodgpu->clbuildprogram proc~clerror_check CLerror_check proc~innerprodgpu->proc~clerror_check writevalue writevalue proc~clerror_check->writevalue fatalerror fatalerror proc~clerror_check->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code InnerProdGPU Source Code recursive subroutine InnerProdGPU ( cl_expt , cl_dict , Ne , Nd , correctsize , results , numd , selnumd , csource , source_length , & platform , device , context , command_queue ) !DEC$ ATTRIBUTES DLLEXPORT :: InnerProdGPU use local use clfortran use CLsupport use ISO_C_BINDING use io use error IMPLICIT NONE real ( kind = 4 ), INTENT ( OUT ), target :: results ( Ne * Nd ) integer ( c_intptr_t ), target , INTENT ( INOUT ) :: cl_expt integer ( c_intptr_t ), target , INTENT ( INOUT ) :: cl_dict integer ( kind = 4 ), INTENT ( IN ) :: Ne integer ( kind = 4 ), INTENT ( IN ) :: Nd integer ( kind = 4 ), INTENT ( IN ) :: correctsize integer ( kind = irg ), INTENT ( IN ) :: numd , selnumd integer ( c_size_t ), INTENT ( IN ), target :: source_length character ( len = source_length , KIND = c_char ), TARGET , INTENT ( IN ) :: csource integer ( c_intptr_t ), allocatable , target , INTENT ( IN ) :: platform (:) integer ( c_intptr_t ), allocatable , target , INTENT ( INOUT ) :: device (:) integer ( c_intptr_t ), target , INTENT ( INOUT ) :: context integer ( c_intptr_t ), target , INTENT ( INOUT ) :: command_queue type ( c_ptr ), target :: psource integer ( c_int32_t ) :: ierr , ierr2 , pcnt integer ( c_intptr_t ), target :: prog integer ( c_intptr_t ), target :: kernel integer ( c_intptr_t ), target :: cl_result character ( 19 ), target :: progoptions integer ( c_size_t ) :: cnum character ( len = source_length ), target :: source real ( kind = 4 ) :: dicttranspose ( Nd * correctsize ) integer ( kind = 4 ), parameter :: iunit = 40 character ( fnlen ) :: info ! info about the GPU integer ( kind = 8 ), target :: globalsize ( 2 ), localsize ( 2 ) integer , parameter :: source_length_build_info = 10000 character ( len = source_length ) :: source_build_info integer ( kind = 4 ) :: num , istat , i , j , ii , jj , kk , io_int ( 1 ) integer ( kind = 4 ), target :: Wexp , Wdict integer ( kind = 8 ) :: size_in_bytes_expt , size_in_bytes_dict , size_in_bytes_result character ( 9 ), target :: kernelname character ( 10 , KIND = c_char ), target :: ckernelname integer ( kind = irg ) :: irec size_in_bytes_result = Ne * Nd * sizeof ( results ( 1 )) Wexp = correctsize Wdict = Nd localsize = ( / 16 , 16 / ) globalsize = ( / Ne , Nd / ) !===================== ! INITIALIZATION !===================== ! was performed in the calling program !===================== ! BUILD THE KERNEL !===================== ! create the program pcnt = 1 psource = C_LOC ( csource ) prog = clCreateProgramWithSource ( context , pcnt , C_LOC ( psource ), C_LOC ( source_length ), ierr ) call CLerror_check ( 'InnerProdGPU:clCreateProgramWithSource' , ierr ) ! build the program progoptions = '-cl-no-signed-zeros' ! ierr = clBuildProgram(prog, numd, C_LOC(device), C_LOC(progoptions), C_NULL_FUNPTR, C_NULL_PTR) ierr = clBuildProgram ( prog , numd , C_LOC ( device ), C_NULL_PTR , C_NULL_FUNPTR , C_NULL_PTR ) ! get the compilation log ierr2 = clGetProgramBuildInfo ( prog , device ( selnumd ), CL_PROGRAM_BUILD_LOG , sizeof ( source ), C_LOC ( source ), cnum ) ! if(cnum > 1) call Message(trim(source(1:cnum))//'test',frm='(A)') call CLerror_check ( 'InnerProdGPU:clBuildProgram' , ierr ) call CLerror_check ( 'InnerProdGPU:clGetProgramBuildInfo' , ierr2 ) ! finally get the kernel and release the program kernelname = 'InnerProd' ckernelname = kernelname ckernelname ( 10 : 10 ) = C_NULL_CHAR kernel = clCreateKernel ( prog , C_LOC ( ckernelname ), ierr ) call CLerror_check ( 'InnerProdGPU:clCreateKernel' , ierr ) ierr = clReleaseProgram ( prog ) call CLerror_check ( 'InnerProdGPU:clReleaseProgram' , ierr ) ! create buffer cl_result = clCreateBuffer ( context , CL_MEM_READ_WRITE , size_in_bytes_result , C_NULL_PTR , ierr ) call CLerror_check ( 'InnerProdGPU:clCreateBuffer' , ierr ) ! set kernel arguments ierr = clSetKernelArg ( kernel , 0 , sizeof ( cl_expt ), C_LOC ( cl_expt )) call CLerror_check ( 'InnerProdGPU:clSetKernelArg:cl_expt' , ierr ) ierr = clSetKernelArg ( kernel , 1 , sizeof ( cl_dict ), C_LOC ( cl_dict )) call CLerror_check ( 'InnerProdGPU:clSetKernelArg:cl_dict' , ierr ) ierr = clSetKernelArg ( kernel , 2 , sizeof ( Wexp ), C_LOC ( Wexp )) call CLerror_check ( 'InnerProdGPU:clSetKernelArg:Wexp' , ierr ) ierr = clSetKernelArg ( kernel , 3 , sizeof ( Wdict ), C_LOC ( Wdict )) call CLerror_check ( 'InnerProdGPU:clSetKernelArg:Wdict' , ierr ) ierr = clSetKernelArg ( kernel , 4 , sizeof ( cl_result ), C_LOC ( cl_result )) call CLerror_check ( 'InnerProdGPU:clSetKernelArg:cl_result' , ierr ) !execute the kernel ierr = clEnqueueNDRangeKernel ( command_queue , kernel , 2 , C_NULL_PTR , C_LOC ( globalsize ), C_LOC ( localsize ), & 0 , C_NULL_PTR , C_NULL_PTR ) call CLerror_check ( 'InnerProdGPU:clEnqueueNDRangeKernel' , ierr ) ! wait for the commands to finish ierr = clFinish ( command_queue ) call CLerror_check ( 'InnerProdGPU:clFinish' , ierr ) ! read the resulting vector from device memory ierr = clEnqueueReadBuffer ( command_queue , cl_result , CL_TRUE , 0 _ 8 , size_in_bytes_result , C_LOC ( results ( 1 )), 0 , C_NULL_PTR , C_NULL_PTR ) call CLerror_check ( 'InnerProdGPU:clEnqueueReadBuffer' , ierr ) ierr = clReleaseKernel ( kernel ) call CLerror_check ( 'InnerProdGPU:clReleaseKernel' , ierr ) ierr = clReleaseMemObject ( cl_result ) call CLerror_check ( 'InnerProdGPU:clReleaseMemObject:cl_result' , ierr ) end subroutine InnerProdGPU","tags":"","loc":"proc/innerprodgpu.html","title":"InnerProdGPU – Fortran Program"},{"text":"public recursive subroutine Initialize_ReflectionList(cell, listroot, BetheParameter, FN, k, dmin, nref, verbose) Uses: local typedefs io crystal constants gvectors diffraction symmetry proc~~initialize_reflectionlist~~UsesGraph proc~initialize_reflectionlist Initialize_ReflectionList module~constants constants module~constants->proc~initialize_reflectionlist symmetry symmetry symmetry->proc~initialize_reflectionlist crystal crystal crystal->proc~initialize_reflectionlist gvectors gvectors gvectors->proc~initialize_reflectionlist diffraction diffraction diffraction->proc~initialize_reflectionlist io io io->proc~initialize_reflectionlist typedefs typedefs typedefs->proc~initialize_reflectionlist local local local->proc~initialize_reflectionlist local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief initialize the potential reflection list for a given wave vector\n @param cell unit cell pointer\n @param BetheParameter Bethe potential structure\n @param FN  foil normal\n @param k zone axis direction cosines in direct Bravais lattice\n @param dmin smallest lattice d-spacing to consider\n @param listroot pointer to top of list (could be cell%reflist)\n @param nref number of reflections in main list (used to be DynNbeams)\n @param verbose (optional) used for debugging purposes mostly\n @date 01/10/14 MDG 1.0 original, based on old Compute_ReflectionList\n @date 01/13/14 MDG 1.1 update for new cell type definition and new Bethe potential criterion\n @date 06/15/14 MDG 2.0 update for removal of all globals\n @date 06/16/14 MDG 2.1 added recursive\n @date 06/23/14 MDG 2.2 replaced Dyn structure by FN Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(reflisttype), pointer :: listroot type(BetheParameterType), intent(inout) :: BetheParameter real(kind=sgl), intent(in) :: FN (3) real(kind=sgl), intent(in) :: k (3) real(kind=sgl), intent(in) :: dmin integer(kind=irg), intent(inout) :: nref logical, intent(in), optional :: verbose Calls proc~~initialize_reflectionlist~~CallsGraph proc~initialize_reflectionlist Initialize_ReflectionList float float proc~initialize_reflectionlist->float calclength calclength proc~initialize_reflectionlist->calclength sngl sngl proc~initialize_reflectionlist->sngl isgallowed isgallowed proc~initialize_reflectionlist->isgallowed addreflection addreflection proc~initialize_reflectionlist->addreflection calcsg calcsg proc~initialize_reflectionlist->calcsg writevalue writevalue proc~initialize_reflectionlist->writevalue Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code Initialize_ReflectionList Source Code recursive subroutine Initialize_ReflectionList ( cell , listroot , BetheParameter , FN , k , dmin , nref , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: Initialize_ReflectionList use local use typedefs use io use crystal use constants use gvectors use diffraction use symmetry IMPLICIT NONE type ( unitcell ), pointer :: cell type ( reflisttype ), pointer :: listroot type ( BetheParameterType ), INTENT ( INOUT ) :: BetheParameter real ( kind = sgl ), INTENT ( IN ) :: FN ( 3 ) real ( kind = sgl ), INTENT ( IN ) :: k ( 3 ) real ( kind = sgl ), INTENT ( IN ) :: dmin integer ( kind = irg ), INTENT ( INOUT ) :: nref logical , INTENT ( IN ), OPTIONAL :: verbose integer ( kind = irg ) :: imh , imk , iml , gg ( 3 ), ix , iy , iz , i , minholz , RHOLZ , im , istat , N , & ig , numr , ir , irsel real ( kind = sgl ) :: dhkl , io_real ( 9 ), H , g3 ( 3 ), g3n ( 3 ), FNg ( 3 ), ddt , s , kr ( 3 ), exer , & rBethe_i , rBethe_d , sgp , r_g , la , dval integer ( kind = irg ) :: io_int ( 3 ), gshort ( 3 ), gp ( 3 ) type ( reflisttype ), pointer :: rltail ! set the truncation parameters rBethe_i = BetheParameter % c3 ! if larger than this value, we ignore the reflection completely rBethe_d = BetheParameter % sgdbdiff ! excitation error cutoff for double diffraction reflections la = 1.0 / sngl ( cell % mLambda ) ! get the size of the lookup table gp = shape ( cell % LUT ) imh = ( gp ( 1 ) - 1 ) / 4 imk = ( gp ( 2 ) - 1 ) / 4 iml = ( gp ( 3 ) - 1 ) / 4 nullify ( listroot ) nullify ( rltail ) ! transmitted beam has excitation error zero gg = ( / 0 , 0 , 0 / ) call AddReflection ( rltail , listroot , cell , nref , gg ) ! this guarantees that 000 is always the first reflection rltail % sg = 0.0 ! now compute |sg|/|U_g|/lambda for the other allowed reflections; if this parameter is less than ! the threshhold, rBethe_i, then add the reflection to the list of potential reflections ixl : do ix =- imh , imh iyl : do iy =- imk , imk izl : do iz =- iml , iml if (( abs ( ix ) + abs ( iy ) + abs ( iz )). ne . 0 ) then ! avoid double counting the origin gg = ( / ix , iy , iz / ) dval = 1.0 / CalcLength ( cell , float ( gg ), 'r' ) if (( IsGAllowed ( cell , gg )). and .( dval . gt . dmin )) then ! allowed by the lattice centering, if any sgp = Calcsg ( cell , float ( gg ), k , FN ) if ( cell % dbdiff ( ix , iy , iz )) then ! potential double diffraction reflection if ( abs ( sgp ). le . rBethe_d ) then call AddReflection ( rltail , listroot , cell , nref , gg ) rltail % sg = sgp rltail % dbdiff = . TRUE . end if else r_g = la * abs ( sgp ) / cdabs ( cell % LUT ( ix , iy , iz )) if ( r_g . le . rBethe_i ) then call AddReflection ( rltail , listroot , cell , nref , gg ) rltail % sg = sgp rltail % dbdiff = . FALSE . end if end if end if ! IsGAllowed end if end do izl end do iyl end do ixl if ( present ( verbose )) then if ( verbose ) then io_int ( 1 ) = nref call WriteValue ( ' Length of the master list of reflections : ' , io_int , 1 , \"(I8)\" ) end if end if end subroutine Initialize_ReflectionList","tags":"","loc":"proc/initialize_reflectionlist.html","title":"Initialize_ReflectionList – Fortran Program"},{"text":"public recursive subroutine Initialize_ReflectionList_EwaldSweep(cell, listroot, FN, k, nref, pedangle, goffset, verbose) Uses: local typedefs io crystal constants gvectors diffraction symmetry proc~~initialize_reflectionlist_ewaldsweep~~UsesGraph proc~initialize_reflectionlist_ewaldsweep Initialize_ReflectionList_EwaldSweep module~constants constants module~constants->proc~initialize_reflectionlist_ewaldsweep symmetry symmetry symmetry->proc~initialize_reflectionlist_ewaldsweep crystal crystal crystal->proc~initialize_reflectionlist_ewaldsweep gvectors gvectors gvectors->proc~initialize_reflectionlist_ewaldsweep diffraction diffraction diffraction->proc~initialize_reflectionlist_ewaldsweep io io io->proc~initialize_reflectionlist_ewaldsweep typedefs typedefs typedefs->proc~initialize_reflectionlist_ewaldsweep local local local->proc~initialize_reflectionlist_ewaldsweep local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief initialize the potential reflection list for a given precession electron diffraction geometry\n @param cell unit cell pointer\n @param listroot main pointer for reflection linked list (typically reflist in calling routine)\n @param FN  foil normal\n @param k zone axis direction cosines in direct Bravais lattice\n @param nref number of reflections in main list (used to be DynNbeams)\n @param pedangle precession cone angle in mrad\n @param goffset offset parameter for reflections to be included outside the Ewald sphere precession volume\n @param verbose (optional) used for debugging purposes mostly\n @date 01/10/14 MDG 1.0 original, based on old Compute_ReflectionList\n @date 01/13/14 MDG 1.1 update for new cell type definition and new Bethe potential criterion\n @date 06/15/14 MDG 2.0 update for removal of all globals\n @date 06/16/14 MDG 2.1 added recursive\n @date 06/23/14 MDG 2.2 replaced Dyn structure by FN\n @date 11/30/14 MDG 3.0 forked from original to accommodate PED case Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(reflisttype), pointer :: listroot real(kind=sgl), intent(in) :: FN (3) real(kind=sgl), intent(in) :: k (3) integer(kind=irg), intent(inout) :: nref real(kind=sgl), intent(in) :: pedangle real(kind=sgl), intent(in) :: goffset logical, intent(in), optional :: verbose Calls proc~~initialize_reflectionlist_ewaldsweep~~CallsGraph proc~initialize_reflectionlist_ewaldsweep Initialize_ReflectionList_EwaldSweep writevalue writevalue proc~initialize_reflectionlist_ewaldsweep->writevalue float float proc~initialize_reflectionlist_ewaldsweep->float transspace transspace proc~initialize_reflectionlist_ewaldsweep->transspace sngl sngl proc~initialize_reflectionlist_ewaldsweep->sngl calcdot calcdot proc~initialize_reflectionlist_ewaldsweep->calcdot isgallowed isgallowed proc~initialize_reflectionlist_ewaldsweep->isgallowed calclength calclength proc~initialize_reflectionlist_ewaldsweep->calclength addreflection addreflection proc~initialize_reflectionlist_ewaldsweep->addreflection calcsg calcsg proc~initialize_reflectionlist_ewaldsweep->calcsg normvec normvec proc~initialize_reflectionlist_ewaldsweep->normvec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~initialize_reflectionlist_ewaldsweep~~CalledByGraph proc~initialize_reflectionlist_ewaldsweep Initialize_ReflectionList_EwaldSweep interface~initialize_reflectionlist Initialize_ReflectionList interface~initialize_reflectionlist->proc~initialize_reflectionlist_ewaldsweep interface~initialize_reflectionlist->proc~initialize_reflectionlist_ewaldsweep interface~initialize_reflectionlist->interface~initialize_reflectionlist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code Initialize_ReflectionList_EwaldSweep Source Code recursive subroutine Initialize_ReflectionList_EwaldSweep ( cell , listroot , FN , k , nref , pedangle , goffset , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: Initialize_ReflectionList_EwaldSweep use local use typedefs use io use crystal use constants use gvectors use diffraction use symmetry IMPLICIT NONE type ( unitcell ), pointer :: cell type ( reflisttype ), pointer :: listroot real ( kind = sgl ), INTENT ( IN ) :: FN ( 3 ) real ( kind = sgl ), INTENT ( IN ) :: k ( 3 ) integer ( kind = irg ), INTENT ( INOUT ) :: nref real ( kind = sgl ), INTENT ( IN ) :: pedangle real ( kind = sgl ), INTENT ( IN ) :: goffset logical , INTENT ( IN ), OPTIONAL :: verbose integer ( kind = irg ) :: imh , imk , iml , gg ( 3 ), ix , iy , iz , io_int ( 3 ), gp ( 3 ) real ( kind = sgl ) :: FNg ( 3 ), c , s , kr ( 3 ), sgp , la , kstar ( 3 ), gperp ( 3 ), gpara ( 3 ), bup , blo , y , z , & gdk , glen , gplen type ( reflisttype ), pointer :: rltail ! init a couple of parameters la = 1.0 / sngl ( cell % mLambda ) c = la * cos ( pedangle / 100 0.0 ) s = 2.0 * la * sin ( pedangle / 100 0.0 ) ! reciprocal space wave vector call TransSpace ( cell , k , kstar , 'd' , 'r' ) call NormVec ( cell , kstar , 'r' ) kstar = la * kstar ! get the size of the lookup table gp = shape ( cell % LUT ) imh = ( gp ( 1 ) - 1 ) / 4 imk = ( gp ( 2 ) - 1 ) / 4 iml = ( gp ( 3 ) - 1 ) / 4 nullify ( listroot ) nullify ( rltail ) ! transmitted beam has excitation error zero, and set xg to zero; xg will store the accumulated intensity for each reflection gg = ( / 0 , 0 , 0 / ) call AddReflection ( rltail , listroot , cell , nref , gg ) ! this guarantees that 000 is always the first reflection rltail % sg = 0.0 rltail % xg = 0.0 ! scan through the reciprocal lattice volume corresponding to the dmin value ixl : do ix =- imh , imh iyl : do iy =- imk , imk izl : do iz =- iml , iml if (( abs ( ix ) + abs ( iy ) + abs ( iz )). ne . 0 ) then ! avoid double counting the origin gg = ( / ix , iy , iz / ) if ( IsGAllowed ( cell , gg )) then ! allowed by the lattice centering, if any ! first we need to determine the parallel and perpendicular components of this g vector with respect to the beam direction in reciprocal space gdk = CalcDot ( cell , float ( gg ), kstar , 'r' ) ! projection of gg onto k* gpara = gdk * kstar gperp = float ( gg ) - gpara ! then get the length of the perpendicular and parallel components, including sign of parallel component glen = CalcLength ( cell , gperp , 'r' ) gplen = CalcLength ( cell , gpara , 'r' ) ! sign of length depends on dot product sign of gg onto k* if ( gdk . le . 0.0 ) gplen = - gplen ! compute the upper and lower bounds for this value of glen y = glen * s z = c * c - glen * glen bup = goffset + c - sqrt ( z - y ) blo = - goffset + c - sqrt ( z + y ) ! and check whether or not this point should be taken into account if (( blo . le . gplen ). and .( gplen . le . bup )) then sgp = Calcsg ( cell , float ( gg ), k , FN ) ! note that we are not applying any Bethe parameter conditions here since those will be applied for each beam orientation separately if ( cell % dbdiff ( ix , iy , iz )) then ! potential double diffraction reflection call AddReflection ( rltail , listroot , cell , nref , gg ) rltail % sg = sgp rltail % xg = 0.0 rltail % dbdiff = . TRUE . else call AddReflection ( rltail , listroot , cell , nref , gg ) rltail % sg = sgp rltail % xg = 0.0 rltail % dbdiff = . FALSE . end if end if ! reflection inside precession-swept Ewald sphere volume end if ! IsGAllowed end if ! not the origin end do izl end do iyl end do ixl if ( present ( verbose )) then if ( verbose ) then io_int ( 1 ) = nref call WriteValue ( ' Length of the master list of reflections : ' , io_int , 1 , \"(I8)\" ) end if end if end subroutine Initialize_Reflectionlist_EwaldSweep","tags":"","loc":"proc/initialize_reflectionlist_ewaldsweep.html","title":"Initialize_ReflectionList_EwaldSweep – Fortran Program"},{"text":"public interface Initialize_ReflectionList Calls interface~~initialize_reflectionlist~~CallsGraph interface~initialize_reflectionlist Initialize_ReflectionList interface~initialize_reflectionlist->interface~initialize_reflectionlist proc~initialize_reflectionlist_ewaldsweep Initialize_ReflectionList_EwaldSweep interface~initialize_reflectionlist->proc~initialize_reflectionlist_ewaldsweep writevalue writevalue proc~initialize_reflectionlist_ewaldsweep->writevalue float float proc~initialize_reflectionlist_ewaldsweep->float transspace transspace proc~initialize_reflectionlist_ewaldsweep->transspace sngl sngl proc~initialize_reflectionlist_ewaldsweep->sngl calcdot calcdot proc~initialize_reflectionlist_ewaldsweep->calcdot isgallowed isgallowed proc~initialize_reflectionlist_ewaldsweep->isgallowed calclength calclength proc~initialize_reflectionlist_ewaldsweep->calclength addreflection addreflection proc~initialize_reflectionlist_ewaldsweep->addreflection calcsg calcsg proc~initialize_reflectionlist_ewaldsweep->calcsg normvec normvec proc~initialize_reflectionlist_ewaldsweep->normvec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By interface~~initialize_reflectionlist~~CalledByGraph interface~initialize_reflectionlist Initialize_ReflectionList interface~initialize_reflectionlist->interface~initialize_reflectionlist proc~emsoftcgetebsdmaster EMsoftCgetEBSDmaster proc~emsoftcgetebsdmaster->interface~initialize_reflectionlist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Module Procedures Initialize_ReflectionList Initialize_ReflectionList_EwaldSweep Module Procedures public interface Initialize_ReflectionList () Arguments None public recursive subroutine Initialize_ReflectionList_EwaldSweep (cell, listroot, FN, k, nref, pedangle, goffset, verbose) @author Marc De Graef, Carnegie Mellon University\n @brief initialize the potential reflection list for a given precession electron diffraction geometry\n @param cell unit cell pointer\n @param listroot main pointer for reflection linked list (typically reflist in calling routine)\n @param FN  foil normal\n @param k zone axis direction cosines in direct Bravais lattice\n @param nref number of reflections in main list (used to be DynNbeams)\n @param pedangle precession cone angle in mrad\n @param goffset offset parameter for reflections to be included outside the Ewald sphere precession volume\n @param verbose (optional) used for debugging purposes mostly\n @date 01/10/14 MDG 1.0 original, based on old Compute_ReflectionList\n @date 01/13/14 MDG 1.1 update for new cell type definition and new Bethe potential criterion\n @date 06/15/14 MDG 2.0 update for removal of all globals\n @date 06/16/14 MDG 2.1 added recursive\n @date 06/23/14 MDG 2.2 replaced Dyn structure by FN\n @date 11/30/14 MDG 3.0 forked from original to accommodate PED case Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(reflisttype), pointer :: listroot real(kind=sgl), intent(in) :: FN (3) real(kind=sgl), intent(in) :: k (3) integer(kind=irg), intent(inout) :: nref real(kind=sgl), intent(in) :: pedangle real(kind=sgl), intent(in) :: goffset logical, intent(in), optional :: verbose","tags":"","loc":"interface/initialize_reflectionlist.html","title":"Initialize_ReflectionList – Fortran Program"},{"text":"public recursive function JSON_minify(jsonname) result(jsonreturn) @author Marc De Graef, Carnegie Mellon University\n @brief remove all fortran comment lines from a JSON input file and store file in tmp folder\n @param jsonname json file name\n @param jsonreturn filename of stripped down JSON input file (in EMsoft tmp folder)\n @date 05/11/17  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: jsonname Return Value character(len=fnlen) Source Code JSON_minify Source Code recursive function JSON_minify ( jsonname ) result ( jsonreturn ) !DEC$ ATTRIBUTES DLLEXPORT :: JSON_minify IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: jsonname character ( fnlen ) :: jsonreturn ! the JSON syntax standard does not allow for comment lines/statements of any kind. ! In the XXX.jtemplate files, comment lines starting with the f90 ! comment character ! are interspersed with the name-value pairs.  Those are present to make it easier for ! the user to figure out what each variable means.  They need to be removed before the ! file is sent to the json parser routine, and this is done here.  The stripped down ! file is stored in the EMsoft tmp folder with the same name and must be deleted after ! the parsing has been completed. ! with the 5.3 version of json-fortran, it is possible to convert a json file to a namelist ! file, so since we are already set up to handle namelist files, this will signficantly ! simplify the implementation of the JSON format... ! jsonname is jsonreturn = '' end function JSON_minify","tags":"","loc":"proc/json_minify.html","title":"JSON_minify – Fortran Program"},{"text":"public recursive function JSONgetDouble(child, str, v) result(oval) Uses: io iso_fortran_env proc~~jsongetdouble~~UsesGraph proc~jsongetdouble JSONgetDouble io io io->proc~jsongetdouble iso_fortran_env iso_fortran_env iso_fortran_env->proc~jsongetdouble Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief get vector from a json_value\n @param child json_value structure\n @param str text with variable name\n @param v verbose if 1\n @date 11/21/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(json_value), intent(in), pointer :: child character(len=fnlen) :: str integer(kind=irg), intent(in) :: v Return Value real(kind=dbl) Calls proc~~jsongetdouble~~CallsGraph proc~jsongetdouble JSONgetDouble json_get json_get proc~jsongetdouble->json_get writevalue writevalue proc~jsongetdouble->writevalue Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~jsongetdouble~~CalledByGraph proc~jsongetdouble JSONgetDouble proc~jsonreadfoildata JSONreadFoilData proc~jsonreadfoildata->proc~jsongetdouble proc~jsonreaddefectfile JSONreadDefectFile proc~jsonreaddefectfile->proc~jsongetdouble proc~jsonreaddefectfile->proc~jsonreadfoildata proc~initializedefects InitializeDefects proc~initializedefects->proc~jsonreaddefectfile Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONgetDouble Source Code recursive function JSONgetDouble ( child , str , v ) result ( oval ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONgetDouble use io use , intrinsic :: iso_fortran_env , only : wp => real64 IMPLICIT NONE type ( json_value ), pointer , INTENT ( IN ) :: child character ( fnlen ) :: str integer ( kind = irg ), INTENT ( IN ) :: v real ( kind = dbl ) :: oval real ( kind = wp ) :: val real ( kind = sgl ) :: io_real ( 1 ) call json_get ( child , val ) if ( v . eq . 1 ) then io_real ( 1 ) = val call WriteValue ( str , io_real , 1 ) end if oval = val end function JSONgetDouble","tags":"","loc":"proc/jsongetdouble.html","title":"JSONgetDouble – Fortran Program"},{"text":"public recursive function JSONgetDoubleVector(child, nc, str, v) result(ovec) Uses: io iso_fortran_env proc~~jsongetdoublevector~~UsesGraph proc~jsongetdoublevector JSONgetDoubleVector io io io->proc~jsongetdoublevector iso_fortran_env iso_fortran_env iso_fortran_env->proc~jsongetdoublevector Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief get vector from a json_value\n @param child json_value structure\n @param nc number of items to read\n @param str text with variable name\n @param v verbose if 1\n @date 11/21/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(json_value), intent(in), pointer :: child integer(kind=irg), intent(in) :: nc character(len=fnlen) :: str integer(kind=irg), intent(in) :: v Return Value real(kind=dbl)\n  (nc) Calls proc~~jsongetdoublevector~~CallsGraph proc~jsongetdoublevector JSONgetDoubleVector json_get json_get proc~jsongetdoublevector->json_get writevalue writevalue proc~jsongetdoublevector->writevalue Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~jsongetdoublevector~~CalledByGraph proc~jsongetdoublevector JSONgetDoubleVector proc~jsonreadfoildata JSONreadFoilData proc~jsonreadfoildata->proc~jsongetdoublevector proc~jsonreaddefectfile JSONreadDefectFile proc~jsonreaddefectfile->proc~jsongetdoublevector proc~jsonreaddefectfile->proc~jsonreadfoildata proc~initializedefects InitializeDefects proc~initializedefects->proc~jsonreaddefectfile Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONgetDoubleVector Source Code recursive function JSONgetDoubleVector ( child , nc , str , v ) result ( ovec ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONgetDoubleVector use io use , intrinsic :: iso_fortran_env , only : wp => real64 IMPLICIT NONE type ( json_value ), pointer , INTENT ( IN ) :: child integer ( kind = irg ), INTENT ( IN ) :: nc character ( fnlen ) :: str integer ( kind = irg ), INTENT ( IN ) :: v real ( kind = dbl ) :: ovec ( nc ) real ( kind = wp ), dimension (:), allocatable :: vec real ( kind = sgl ) :: io_real ( nc ) allocate ( vec ( nc )) call json_get ( child , vec ) if ( v . eq . 1 ) then io_real ( 1 : nc ) = vec ( 1 : nc ) call WriteValue ( str , io_real , nc ) end if ovec ( 1 : nc ) = vec ( 1 : nc ) deallocate ( vec ) end function JSONgetDoubleVector","tags":"","loc":"proc/jsongetdoublevector.html","title":"JSONgetDoubleVector – Fortran Program"},{"text":"public recursive subroutine JSON_failtest(error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief executes the json_fail routine; mostly to shorten the remaining code a little\n @param error_cnt error counter\n @date 08/12/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(inout) :: error_cnt Calls proc~~json_failtest~~CallsGraph proc~json_failtest JSON_failtest json_failed json_failed proc~json_failtest->json_failed json_print_error_message json_print_error_message proc~json_failtest->json_print_error_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~json_failtest~~CalledByGraph proc~json_failtest JSON_failtest proc~jsonreadebsdclusternamelist JSONreadEBSDclusterNameList proc~jsonreadebsdclusternamelist->proc~json_failtest proc~json_writenmlintegers JSON_writeNMLintegers proc~json_writenmlintegers->proc~json_failtest proc~jsonreadebsdoverlapnamelist JSONreadEBSDoverlapNameList proc~jsonreadebsdoverlapnamelist->proc~json_failtest proc~jsonreadecpmasternamelist JSONreadECPMasterNameList proc~jsonreadecpmasternamelist->proc~json_failtest proc~jsonreadebsdmasternamelist JSONreadEBSDMasterNameList proc~jsonreadebsdmasternamelist->proc~json_failtest proc~jsonwritedictindxopenclnamelist JSONwriteDictIndxOpenCLNameList proc~jsonwritedictindxopenclnamelist->proc~json_failtest proc~jsonwritedictindxopenclnamelist->proc~json_writenmlintegers proc~json_cleanuppointers JSON_cleanuppointers proc~jsonwritedictindxopenclnamelist->proc~json_cleanuppointers proc~json_initpointers JSON_initpointers proc~jsonwritedictindxopenclnamelist->proc~json_initpointers proc~jsonwriteecpmasternamelist JSONwriteECPMasterNameList proc~jsonwriteecpmasternamelist->proc~json_failtest proc~jsonwriteecpmasternamelist->proc~json_writenmlintegers proc~jsonwriteecpmasternamelist->proc~json_cleanuppointers proc~json_writenmldoubles JSON_writeNMLdoubles proc~jsonwriteecpmasternamelist->proc~json_writenmldoubles proc~jsonwriteecpmasternamelist->proc~json_initpointers proc~jsonwriteebsdnamelist JSONwriteEBSDNameList proc~jsonwriteebsdnamelist->proc~json_failtest proc~jsonwriteebsdnamelist->proc~json_writenmlintegers proc~json_writenmlreals JSON_writeNMLreals proc~jsonwriteebsdnamelist->proc~json_writenmlreals proc~jsonwriteebsdnamelist->proc~json_cleanuppointers proc~jsonwriteebsdnamelist->proc~json_initpointers proc~json_writenmlreals->proc~json_failtest proc~json_cleanuppointers->proc~json_failtest proc~jsonwriteecpnamelist JSONwriteECPNameList proc~jsonwriteecpnamelist->proc~json_failtest proc~jsonwriteecpnamelist->proc~json_writenmlintegers proc~jsonwriteecpnamelist->proc~json_writenmlreals proc~jsonwriteecpnamelist->proc~json_cleanuppointers proc~jsonwriteecpnamelist->proc~json_initpointers proc~jsonreadebsdnamelist JSONreadEBSDNameList proc~jsonreadebsdnamelist->proc~json_failtest proc~jsonwritemcnamelist JSONwriteMCNameList proc~jsonwritemcnamelist->proc~json_failtest proc~jsonwritemcnamelist->proc~json_writenmlintegers proc~jsonwritemcnamelist->proc~json_cleanuppointers proc~jsonwritemcnamelist->proc~json_writenmldoubles proc~jsonwritemcnamelist->proc~json_initpointers proc~jsonwritekosselnamelist JSONwriteKosselNameList proc~jsonwritekosselnamelist->proc~json_failtest proc~jsonwritekosselnamelist->proc~json_writenmlintegers proc~jsonwritekosselnamelist->proc~json_writenmlreals proc~jsonwritekosselnamelist->proc~json_cleanuppointers proc~jsonwritekosselnamelist->proc~json_initpointers proc~jsonwritelacbednamelist JSONwriteLACBEDNameList proc~jsonwritelacbednamelist->proc~json_failtest proc~jsonwritelacbednamelist->proc~json_writenmlintegers proc~jsonwritelacbednamelist->proc~json_writenmlreals proc~jsonwritelacbednamelist->proc~json_cleanuppointers proc~jsonwritelacbednamelist->proc~json_initpointers proc~jsonwriteecppatternnamelist JSONwriteECPpatternNameList proc~jsonwriteecppatternnamelist->proc~json_failtest proc~jsonwriteecppatternnamelist->proc~json_writenmlintegers proc~jsonwriteecppatternnamelist->proc~json_cleanuppointers proc~jsonwriteecppatternnamelist->proc~json_initpointers proc~jsonreadmcclnamelist JSONreadMCCLNameList proc~jsonreadmcclnamelist->proc~json_failtest proc~jsonreadkosselmasternamelist JSONreadKosselMasterNameList proc~jsonreadkosselmasternamelist->proc~json_failtest proc~jsonwritemcclmultilayernamelist JSONwriteMCCLMultiLayerNameList proc~jsonwritemcclmultilayernamelist->proc~json_failtest proc~jsonwritemcclmultilayernamelist->proc~json_writenmlintegers proc~jsonwritemcclmultilayernamelist->proc~json_cleanuppointers proc~jsonwritemcclmultilayernamelist->proc~json_writenmldoubles proc~jsonwritemcclmultilayernamelist->proc~json_initpointers proc~jsonwriteebsdmasternamelist JSONwriteEBSDMasterNameList proc~jsonwriteebsdmasternamelist->proc~json_failtest proc~jsonwriteebsdmasternamelist->proc~json_writenmlintegers proc~jsonwriteebsdmasternamelist->proc~json_cleanuppointers proc~jsonwriteebsdmasternamelist->proc~json_initpointers proc~json_writenmldoubles->proc~json_failtest proc~jsonwriteebsdclusternamelist JSONwriteEBSDclusterNameList proc~jsonwriteebsdclusternamelist->proc~json_failtest proc~jsonwriteebsdclusternamelist->proc~json_writenmlintegers proc~jsonwriteebsdclusternamelist->proc~json_cleanuppointers proc~jsonwriteebsdclusternamelist->proc~json_initpointers proc~jsonwritepedzanamelist JSONwritePEDZANameList proc~jsonwritepedzanamelist->proc~json_failtest proc~jsonwritepedzanamelist->proc~json_writenmlintegers proc~jsonwritepedzanamelist->proc~json_writenmlreals proc~jsonwritepedzanamelist->proc~json_cleanuppointers proc~jsonwritepedzanamelist->proc~json_initpointers proc~jsonwritepedkinnamelist JSONwritePEDkinNameList proc~jsonwritepedkinnamelist->proc~json_failtest proc~jsonwritepedkinnamelist->proc~json_writenmlintegers proc~jsonwritepedkinnamelist->proc~json_writenmlreals proc~jsonwritepedkinnamelist->proc~json_cleanuppointers proc~jsonwritepedkinnamelist->proc~json_initpointers proc~jsonreaddefectfile JSONreadDefectFile proc~jsonreaddefectfile->proc~json_failtest proc~jsonreadfoildata JSONreadFoilData proc~jsonreaddefectfile->proc~jsonreadfoildata proc~json_initpointers->proc~json_failtest proc~jsonreadfoildata->proc~json_failtest proc~jsonwritekosselmasternamelist JSONwriteKosselMasterNameList proc~jsonwritekosselmasternamelist->proc~json_failtest proc~jsonwritekosselmasternamelist->proc~json_writenmlintegers proc~jsonwritekosselmasternamelist->proc~json_writenmlreals proc~jsonwritekosselmasternamelist->proc~json_cleanuppointers proc~jsonwritekosselmasternamelist->proc~json_initpointers proc~jsonwriteeccinamelist JSONwriteECCINameList proc~jsonwriteeccinamelist->proc~json_failtest proc~jsonwriteeccinamelist->proc~json_writenmlintegers proc~jsonwriteeccinamelist->proc~json_writenmlreals proc~jsonwriteeccinamelist->proc~json_cleanuppointers proc~jsonwriteeccinamelist->proc~json_initpointers proc~jsonreadkosselnamelist JSONreadKosselNameList proc~jsonreadkosselnamelist->proc~json_failtest proc~jsonwritemcclnamelist JSONwriteMCCLNameList proc~jsonwritemcclnamelist->proc~json_failtest proc~jsonwritemcclnamelist->proc~json_writenmlintegers proc~jsonwritemcclnamelist->proc~json_cleanuppointers proc~jsonwritemcclnamelist->proc~json_writenmldoubles proc~jsonwritemcclnamelist->proc~json_initpointers proc~jsonreadmcclmultilayernamelist JSONreadMCCLMultiLayerNameList proc~jsonreadmcclmultilayernamelist->proc~json_failtest proc~jsonwriterfznamelist JSONwriteRFZNameList proc~jsonwriterfznamelist->proc~json_failtest proc~jsonwriterfznamelist->proc~json_writenmlintegers proc~jsonwriterfznamelist->proc~json_cleanuppointers proc~jsonwriterfznamelist->proc~json_initpointers proc~jsonreadmcnamelist JSONreadMCNameList proc~jsonreadmcnamelist->proc~json_failtest proc~jsonreadreflectornamelist JSONreadreflectorNameList proc~jsonreadreflectornamelist->proc~json_failtest proc~initializedefects InitializeDefects proc~initializedefects->proc~jsonreaddefectfile var panprocjson_failtestCalledByGraph = svgPanZoom('#procjson_failtestCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSON_failtest Source Code recursive subroutine JSON_failtest ( error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSON_failtest IMPLICIT NONE integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt if ( json_failed (). eqv .. TRUE .) then call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 end if end subroutine JSON_failtest","tags":"","loc":"proc/json_failtest.html","title":"JSON_failtest – Fortran Program"},{"text":"public recursive subroutine JSON_writeNMLintegers(inp, io_int, intlist, n_int, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief write a series of integer namelist entries to a json structure \n @param inp json structure pointer\n @param io_int list of integers\n @param intlist list of string descriptors\n @param n_int number of entries\n @param error_cnt error counter\n @date 08/11/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(json_value), intent(inout), pointer :: inp integer(kind=irg), intent(in) :: io_int (n_int) character(len=20), intent(in) :: intlist (n_int) integer(kind=irg), intent(in) :: n_int integer(kind=irg), intent(inout) :: error_cnt Calls proc~~json_writenmlintegers~~CallsGraph proc~json_writenmlintegers JSON_writeNMLintegers proc~json_failtest JSON_failtest proc~json_writenmlintegers->proc~json_failtest json_add json_add proc~json_writenmlintegers->json_add json_failed json_failed proc~json_failtest->json_failed json_print_error_message json_print_error_message proc~json_failtest->json_print_error_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~json_writenmlintegers~~CalledByGraph proc~json_writenmlintegers JSON_writeNMLintegers proc~jsonwriteecpnamelist JSONwriteECPNameList proc~jsonwriteecpnamelist->proc~json_writenmlintegers proc~jsonwriteecppatternnamelist JSONwriteECPpatternNameList proc~jsonwriteecppatternnamelist->proc~json_writenmlintegers proc~jsonwritekosselnamelist JSONwriteKosselNameList proc~jsonwritekosselnamelist->proc~json_writenmlintegers proc~jsonwritepedkinnamelist JSONwritePEDkinNameList proc~jsonwritepedkinnamelist->proc~json_writenmlintegers proc~jsonwritekosselmasternamelist JSONwriteKosselMasterNameList proc~jsonwritekosselmasternamelist->proc~json_writenmlintegers proc~jsonwritemcnamelist JSONwriteMCNameList proc~jsonwritemcnamelist->proc~json_writenmlintegers proc~jsonwriteecpmasternamelist JSONwriteECPMasterNameList proc~jsonwriteecpmasternamelist->proc~json_writenmlintegers proc~jsonwriteebsdnamelist JSONwriteEBSDNameList proc~jsonwriteebsdnamelist->proc~json_writenmlintegers proc~jsonwritemcclmultilayernamelist JSONwriteMCCLMultiLayerNameList proc~jsonwritemcclmultilayernamelist->proc~json_writenmlintegers proc~jsonwriteeccinamelist JSONwriteECCINameList proc~jsonwriteeccinamelist->proc~json_writenmlintegers proc~jsonwritepedzanamelist JSONwritePEDZANameList proc~jsonwritepedzanamelist->proc~json_writenmlintegers proc~jsonwriteebsdmasternamelist JSONwriteEBSDMasterNameList proc~jsonwriteebsdmasternamelist->proc~json_writenmlintegers proc~jsonwritedictindxopenclnamelist JSONwriteDictIndxOpenCLNameList proc~jsonwritedictindxopenclnamelist->proc~json_writenmlintegers proc~jsonwritelacbednamelist JSONwriteLACBEDNameList proc~jsonwritelacbednamelist->proc~json_writenmlintegers proc~jsonwriterfznamelist JSONwriteRFZNameList proc~jsonwriterfznamelist->proc~json_writenmlintegers proc~jsonwriteebsdclusternamelist JSONwriteEBSDclusterNameList proc~jsonwriteebsdclusternamelist->proc~json_writenmlintegers proc~jsonwritemcclnamelist JSONwriteMCCLNameList proc~jsonwritemcclnamelist->proc~json_writenmlintegers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSON_writeNMLintegers Source Code recursive subroutine JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSON_writeNMLintegers IMPLICIT NONE type ( json_value ), INTENT ( INOUT ), pointer :: inp integer ( kind = irg ), INTENT ( IN ) :: io_int ( n_int ) character ( 20 ), INTENT ( IN ) :: intlist ( n_int ) integer ( kind = irg ), INTENT ( IN ) :: n_int integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt integer ( kind = irg ) :: i character ( fnlen ) :: dataset do i = 1 , n_int dataset = intlist ( i ) call json_add ( inp , dataset , io_int ( i )); call JSON_failtest ( error_cnt ) end do end subroutine JSON_writeNMLintegers","tags":"","loc":"proc/json_writenmlintegers.html","title":"JSON_writeNMLintegers – Fortran Program"},{"text":"public recursive subroutine JSON_writeNMLreals(inp, io_real, reallist, n_real, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief write a series of real namelist entries to a json structure\n @param inp pointer to json_value \n @param io_real list of reals\n @param reallist list of string descriptors\n @param n_real number of entries\n @param error_cnt error counter\n @date 08/11/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(json_value), intent(inout), pointer :: inp real(kind=sgl), intent(in) :: io_real (n_real) character(len=20), intent(in) :: reallist (n_real) integer(kind=irg), intent(in) :: n_real integer(kind=irg), intent(inout) :: error_cnt Calls proc~~json_writenmlreals~~CallsGraph proc~json_writenmlreals JSON_writeNMLreals proc~json_failtest JSON_failtest proc~json_writenmlreals->proc~json_failtest json_add json_add proc~json_writenmlreals->json_add json_failed json_failed proc~json_failtest->json_failed json_print_error_message json_print_error_message proc~json_failtest->json_print_error_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~json_writenmlreals~~CalledByGraph proc~json_writenmlreals JSON_writeNMLreals proc~jsonwriteecpnamelist JSONwriteECPNameList proc~jsonwriteecpnamelist->proc~json_writenmlreals proc~jsonwritekosselnamelist JSONwriteKosselNameList proc~jsonwritekosselnamelist->proc~json_writenmlreals proc~jsonwritepedkinnamelist JSONwritePEDkinNameList proc~jsonwritepedkinnamelist->proc~json_writenmlreals proc~jsonwritekosselmasternamelist JSONwriteKosselMasterNameList proc~jsonwritekosselmasternamelist->proc~json_writenmlreals proc~jsonwriteeccinamelist JSONwriteECCINameList proc~jsonwriteeccinamelist->proc~json_writenmlreals proc~jsonwriteebsdnamelist JSONwriteEBSDNameList proc~jsonwriteebsdnamelist->proc~json_writenmlreals proc~jsonwritelacbednamelist JSONwriteLACBEDNameList proc~jsonwritelacbednamelist->proc~json_writenmlreals proc~jsonwritepedzanamelist JSONwritePEDZANameList proc~jsonwritepedzanamelist->proc~json_writenmlreals Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSON_writeNMLreals Source Code recursive subroutine JSON_writeNMLreals ( inp , io_real , reallist , n_real , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSON_writeNMLreals IMPLICIT NONE type ( json_value ), INTENT ( INOUT ), pointer :: inp real ( kind = sgl ), INTENT ( IN ) :: io_real ( n_real ) character ( 20 ), INTENT ( IN ) :: reallist ( n_real ) integer ( kind = irg ), INTENT ( IN ) :: n_real integer ( kind = irg ) :: hdferr , i character ( fnlen ) :: dataset integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt do i = 1 , n_real dataset = reallist ( i ) call json_add ( inp , dataset , dble ( io_real ( i ))); call JSON_failtest ( error_cnt ) end do end subroutine JSON_writeNMLreals","tags":"","loc":"proc/json_writenmlreals.html","title":"JSON_writeNMLreals – Fortran Program"},{"text":"public recursive subroutine JSON_writeNMLdoubles(inp, io_real, reallist, n_real, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief write a series of double namelist entries to a json structure\n @param inp pointer to json_value \n @param io_real list ofadoubles \n @param reallist list of string descriptors\n @param n_real number of entries\n @param error_cnt error counter\n @date 08/11/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(json_value), intent(inout), pointer :: inp real(kind=dbl), intent(in) :: io_real (n_real) character(len=20), intent(in) :: reallist (n_real) integer(kind=irg), intent(in) :: n_real integer(kind=irg), intent(inout) :: error_cnt Calls proc~~json_writenmldoubles~~CallsGraph proc~json_writenmldoubles JSON_writeNMLdoubles proc~json_failtest JSON_failtest proc~json_writenmldoubles->proc~json_failtest json_add json_add proc~json_writenmldoubles->json_add json_failed json_failed proc~json_failtest->json_failed json_print_error_message json_print_error_message proc~json_failtest->json_print_error_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~json_writenmldoubles~~CalledByGraph proc~json_writenmldoubles JSON_writeNMLdoubles proc~jsonwriteecpmasternamelist JSONwriteECPMasterNameList proc~jsonwriteecpmasternamelist->proc~json_writenmldoubles proc~jsonwritemcclmultilayernamelist JSONwriteMCCLMultiLayerNameList proc~jsonwritemcclmultilayernamelist->proc~json_writenmldoubles proc~jsonwritemcnamelist JSONwriteMCNameList proc~jsonwritemcnamelist->proc~json_writenmldoubles proc~jsonwritemcclnamelist JSONwriteMCCLNameList proc~jsonwritemcclnamelist->proc~json_writenmldoubles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSON_writeNMLdoubles Source Code recursive subroutine JSON_writeNMLdoubles ( inp , io_real , reallist , n_real , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSON_writeNMLdoubles IMPLICIT NONE type ( json_value ), INTENT ( INOUT ), pointer :: inp real ( kind = dbl ), INTENT ( IN ) :: io_real ( n_real ) character ( 20 ), INTENT ( IN ) :: reallist ( n_real ) integer ( kind = irg ), INTENT ( IN ) :: n_real integer ( kind = irg ) :: hdferr , i character ( fnlen ) :: dataset integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt do i = 1 , n_real dataset = reallist ( i ) call json_add ( inp , dataset , io_real ( i )); call JSON_failtest ( error_cnt ) end do end subroutine JSON_writeNMLdoubles","tags":"","loc":"proc/json_writenmldoubles.html","title":"JSON_writeNMLdoubles – Fortran Program"},{"text":"public recursive subroutine JSON_initpointers(p, inp, jsonname, namelistname, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief initialize the necessary pointers to write a namelist json file\n @param inp pointer to json_value \n @param io_real list of reals\n @param reallist list of string descriptors\n @param n_real number of entries\n @param error_cnt error counter\n @date 08/11/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(json_value), intent(inout), pointer :: p type(json_value), intent(inout), pointer :: inp character(len=fnlen), intent(in) :: jsonname character(len=fnlen), intent(in) :: namelistname integer(kind=irg), intent(inout) :: error_cnt Calls proc~~json_initpointers~~CallsGraph proc~json_initpointers JSON_initpointers json_add json_add proc~json_initpointers->json_add proc~json_failtest JSON_failtest proc~json_initpointers->proc~json_failtest json_initialize json_initialize proc~json_initpointers->json_initialize json_create_object json_create_object proc~json_initpointers->json_create_object json_failed json_failed proc~json_failtest->json_failed json_print_error_message json_print_error_message proc~json_failtest->json_print_error_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~json_initpointers~~CalledByGraph proc~json_initpointers JSON_initpointers proc~jsonwriteecpnamelist JSONwriteECPNameList proc~jsonwriteecpnamelist->proc~json_initpointers proc~jsonwriteecppatternnamelist JSONwriteECPpatternNameList proc~jsonwriteecppatternnamelist->proc~json_initpointers proc~jsonwritekosselnamelist JSONwriteKosselNameList proc~jsonwritekosselnamelist->proc~json_initpointers proc~jsonwritepedkinnamelist JSONwritePEDkinNameList proc~jsonwritepedkinnamelist->proc~json_initpointers proc~jsonwritekosselmasternamelist JSONwriteKosselMasterNameList proc~jsonwritekosselmasternamelist->proc~json_initpointers proc~jsonwritemcnamelist JSONwriteMCNameList proc~jsonwritemcnamelist->proc~json_initpointers proc~jsonwriteecpmasternamelist JSONwriteECPMasterNameList proc~jsonwriteecpmasternamelist->proc~json_initpointers proc~jsonwriteebsdnamelist JSONwriteEBSDNameList proc~jsonwriteebsdnamelist->proc~json_initpointers proc~jsonwritemcclmultilayernamelist JSONwriteMCCLMultiLayerNameList proc~jsonwritemcclmultilayernamelist->proc~json_initpointers proc~jsonwriteeccinamelist JSONwriteECCINameList proc~jsonwriteeccinamelist->proc~json_initpointers proc~jsonwritepedzanamelist JSONwritePEDZANameList proc~jsonwritepedzanamelist->proc~json_initpointers proc~jsonwriteebsdmasternamelist JSONwriteEBSDMasterNameList proc~jsonwriteebsdmasternamelist->proc~json_initpointers proc~jsonwritedictindxopenclnamelist JSONwriteDictIndxOpenCLNameList proc~jsonwritedictindxopenclnamelist->proc~json_initpointers proc~jsonwritelacbednamelist JSONwriteLACBEDNameList proc~jsonwritelacbednamelist->proc~json_initpointers proc~jsonwriterfznamelist JSONwriteRFZNameList proc~jsonwriterfznamelist->proc~json_initpointers proc~jsonwriteebsdclusternamelist JSONwriteEBSDclusterNameList proc~jsonwriteebsdclusternamelist->proc~json_initpointers proc~jsonwritemcclnamelist JSONwriteMCCLNameList proc~jsonwritemcclnamelist->proc~json_initpointers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSON_initpointers Source Code recursive subroutine JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSON_initpointers IMPLICIT NONE type ( json_value ), INTENT ( INOUT ), pointer :: p , inp character ( fnlen ), INTENT ( IN ) :: jsonname , namelistname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt ! initialize the json state variables error_cnt = 0 call json_initialize (); call JSON_failtest ( error_cnt ) ! create the json root pointer call json_create_object ( p , trim ( jsonname )); call JSON_failtest ( error_cnt ) ! we'll use the namelist name to configure the inp structure and add it to p call json_create_object ( inp , trim ( namelistname )); call JSON_failtest ( error_cnt ) call json_add ( p , inp ); call JSON_failtest ( error_cnt ) end subroutine JSON_initpointers","tags":"","loc":"proc/json_initpointers.html","title":"JSON_initpointers – Fortran Program"},{"text":"public recursive subroutine JSON_cleanuppointers(p, inp, jsonname, error_cnt) Uses: io proc~~json_cleanuppointers~~UsesGraph proc~json_cleanuppointers JSON_cleanuppointers io io io->proc~json_cleanuppointers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief clean up the pointers and write the json file\n @param p pointer to json_value \n @param inp pointer to json_value \n @param jsonname json output file name\n @param error_cnt error counter\n @date 08/11/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(json_value), intent(inout), pointer :: p type(json_value), intent(inout), pointer :: inp character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt Calls proc~~json_cleanuppointers~~CallsGraph proc~json_cleanuppointers JSON_cleanuppointers emsoft_tonativepath emsoft_tonativepath proc~json_cleanuppointers->emsoft_tonativepath json_destroy json_destroy proc~json_cleanuppointers->json_destroy json_print json_print proc~json_cleanuppointers->json_print proc~json_failtest JSON_failtest proc~json_cleanuppointers->proc~json_failtest json_failed json_failed proc~json_failtest->json_failed json_print_error_message json_print_error_message proc~json_failtest->json_print_error_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~json_cleanuppointers~~CalledByGraph proc~json_cleanuppointers JSON_cleanuppointers proc~jsonwriteecpnamelist JSONwriteECPNameList proc~jsonwriteecpnamelist->proc~json_cleanuppointers proc~jsonwriteecppatternnamelist JSONwriteECPpatternNameList proc~jsonwriteecppatternnamelist->proc~json_cleanuppointers proc~jsonwritekosselnamelist JSONwriteKosselNameList proc~jsonwritekosselnamelist->proc~json_cleanuppointers proc~jsonwritepedkinnamelist JSONwritePEDkinNameList proc~jsonwritepedkinnamelist->proc~json_cleanuppointers proc~jsonwritekosselmasternamelist JSONwriteKosselMasterNameList proc~jsonwritekosselmasternamelist->proc~json_cleanuppointers proc~jsonwritemcnamelist JSONwriteMCNameList proc~jsonwritemcnamelist->proc~json_cleanuppointers proc~jsonwriteecpmasternamelist JSONwriteECPMasterNameList proc~jsonwriteecpmasternamelist->proc~json_cleanuppointers proc~jsonwriteebsdnamelist JSONwriteEBSDNameList proc~jsonwriteebsdnamelist->proc~json_cleanuppointers proc~jsonwritemcclmultilayernamelist JSONwriteMCCLMultiLayerNameList proc~jsonwritemcclmultilayernamelist->proc~json_cleanuppointers proc~jsonwriteeccinamelist JSONwriteECCINameList proc~jsonwriteeccinamelist->proc~json_cleanuppointers proc~jsonwritepedzanamelist JSONwritePEDZANameList proc~jsonwritepedzanamelist->proc~json_cleanuppointers proc~jsonwriteebsdmasternamelist JSONwriteEBSDMasterNameList proc~jsonwriteebsdmasternamelist->proc~json_cleanuppointers proc~jsonwritedictindxopenclnamelist JSONwriteDictIndxOpenCLNameList proc~jsonwritedictindxopenclnamelist->proc~json_cleanuppointers proc~jsonwritelacbednamelist JSONwriteLACBEDNameList proc~jsonwritelacbednamelist->proc~json_cleanuppointers proc~jsonwriterfznamelist JSONwriteRFZNameList proc~jsonwriterfznamelist->proc~json_cleanuppointers proc~jsonwriteebsdclusternamelist JSONwriteEBSDclusterNameList proc~jsonwriteebsdclusternamelist->proc~json_cleanuppointers proc~jsonwritemcclnamelist JSONwriteMCCLNameList proc~jsonwritemcclnamelist->proc~json_cleanuppointers Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSON_cleanuppointers Source Code recursive subroutine JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSON_cleanuppointers use io IMPLICIT NONE type ( json_value ), INTENT ( INOUT ), pointer :: p , inp character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt character ( fnlen ) :: fname ! get rid of inp nullify ( inp ) ! write the json file fname = EMsoft_toNativePath ( jsonname ) open ( unit = dataunit , file = trim ( fname ), status = 'REPLACE' ) call json_print ( p , dataunit ); call JSON_failtest ( error_cnt ) close ( dataunit ) ! final cleanup call json_destroy ( p ); call JSON_failtest ( error_cnt ) end subroutine JSON_cleanuppointers","tags":"","loc":"proc/json_cleanuppointers.html","title":"JSON_cleanuppointers – Fortran Program"},{"text":"public recursive subroutine JSONwriteKosselNameList(knl, jsonname, error_cnt) Uses: iso_c_binding proc~~jsonwritekosselnamelist~~UsesGraph proc~jsonwritekosselnamelist JSONwriteKosselNameList iso_c_binding iso_c_binding iso_c_binding->proc~jsonwritekosselnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief write namelist file into json file\n @param knl Kossel name list structure\n @date 08/11/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(KosselNameListType), intent(in) :: knl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt Calls proc~~jsonwritekosselnamelist~~CallsGraph proc~jsonwritekosselnamelist JSONwriteKosselNameList proc~json_initpointers JSON_initpointers proc~jsonwritekosselnamelist->proc~json_initpointers proc~json_writenmlintegers JSON_writeNMLintegers proc~jsonwritekosselnamelist->proc~json_writenmlintegers proc~json_cleanuppointers JSON_cleanuppointers proc~jsonwritekosselnamelist->proc~json_cleanuppointers proc~json_writenmlreals JSON_writeNMLreals proc~jsonwritekosselnamelist->proc~json_writenmlreals proc~json_failtest JSON_failtest proc~jsonwritekosselnamelist->proc~json_failtest json_add json_add proc~jsonwritekosselnamelist->json_add proc~json_initpointers->proc~json_failtest proc~json_initpointers->json_add json_initialize json_initialize proc~json_initpointers->json_initialize json_create_object json_create_object proc~json_initpointers->json_create_object proc~json_writenmlintegers->proc~json_failtest proc~json_writenmlintegers->json_add proc~json_cleanuppointers->proc~json_failtest emsoft_tonativepath emsoft_tonativepath proc~json_cleanuppointers->emsoft_tonativepath json_destroy json_destroy proc~json_cleanuppointers->json_destroy json_print json_print proc~json_cleanuppointers->json_print proc~json_writenmlreals->proc~json_failtest proc~json_writenmlreals->json_add json_failed json_failed proc~json_failtest->json_failed json_print_error_message json_print_error_message proc~json_failtest->json_print_error_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONwriteKosselNameList Source Code recursive subroutine JSONwriteKosselNameList ( knl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwriteKosselNameList use ISO_C_BINDING IMPLICIT NONE type ( KosselNameListType ), INTENT ( IN ) :: knl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 5 , n_real = 6 integer ( kind = irg ) :: hdferr , io_int ( n_int ) real ( kind = sgl ) :: io_real ( n_real ) character ( 20 ) :: intlist ( n_int ), reallist ( n_real ) character ( fnlen ) :: dataset , namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'Kossellist' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! then we need to add all the necessary fields to the inp structure ! write all the single integers io_int = ( / knl % stdout , knl % numthick , knl % npix , knl % maxHOLZ , knl % nthreads / ) intlist ( 1 ) = 'stdout' intlist ( 2 ) = 'numthick' intlist ( 3 ) = 'npix' intlist ( 4 ) = 'maxHOLZ' intlist ( 5 ) = 'nthreads' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) ! integer vectors dataset = 'k' call json_add ( inp , dataset , knl % k ); call JSON_failtest ( error_cnt ) dataset = 'fn' call json_add ( inp , dataset , knl % fn ); call JSON_failtest ( error_cnt ) ! write all the single reals io_real = ( / knl % voltage , knl % dmin , knl % convergence , knl % startthick , knl % thickinc , knl % minten / ) reallist ( 1 ) = 'voltage' reallist ( 2 ) = 'dmin' reallist ( 3 ) = 'convergence' reallist ( 4 ) = 'startthick' reallist ( 5 ) = 'thickinc' reallist ( 6 ) = 'minten' call JSON_writeNMLreals ( inp , io_real , reallist , n_real , error_cnt ) ! write all the strings dataset = 'xtalname' call json_add ( inp , dataset , knl % xtalname ); call JSON_failtest ( error_cnt ) dataset = 'outname' call json_add ( inp , dataset , knl % outname ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwriteKosselNameList","tags":"","loc":"proc/jsonwritekosselnamelist.html","title":"JSONwriteKosselNameList – Fortran Program"},{"text":"public recursive subroutine JSONwriteKosselMasterNameList(knl, jsonname, error_cnt) Uses: iso_c_binding proc~~jsonwritekosselmasternamelist~~UsesGraph proc~jsonwritekosselmasternamelist JSONwriteKosselMasterNameList iso_c_binding iso_c_binding iso_c_binding->proc~jsonwritekosselmasternamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief write namelist file into json file\n @param knl Kossel name list structure\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/11/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(KosselMasterNameListType), intent(in) :: knl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt Calls proc~~jsonwritekosselmasternamelist~~CallsGraph proc~jsonwritekosselmasternamelist JSONwriteKosselMasterNameList proc~json_initpointers JSON_initpointers proc~jsonwritekosselmasternamelist->proc~json_initpointers proc~json_writenmlintegers JSON_writeNMLintegers proc~jsonwritekosselmasternamelist->proc~json_writenmlintegers proc~json_cleanuppointers JSON_cleanuppointers proc~jsonwritekosselmasternamelist->proc~json_cleanuppointers proc~json_failtest JSON_failtest proc~jsonwritekosselmasternamelist->proc~json_failtest proc~json_writenmlreals JSON_writeNMLreals proc~jsonwritekosselmasternamelist->proc~json_writenmlreals json_add json_add proc~jsonwritekosselmasternamelist->json_add proc~json_initpointers->proc~json_failtest proc~json_initpointers->json_add json_initialize json_initialize proc~json_initpointers->json_initialize json_create_object json_create_object proc~json_initpointers->json_create_object proc~json_writenmlintegers->proc~json_failtest proc~json_writenmlintegers->json_add proc~json_cleanuppointers->proc~json_failtest emsoft_tonativepath emsoft_tonativepath proc~json_cleanuppointers->emsoft_tonativepath json_destroy json_destroy proc~json_cleanuppointers->json_destroy json_print json_print proc~json_cleanuppointers->json_print json_failed json_failed proc~json_failtest->json_failed json_print_error_message json_print_error_message proc~json_failtest->json_print_error_message proc~json_writenmlreals->proc~json_failtest proc~json_writenmlreals->json_add var panprocjsonwritekosselmasternamelistCallsGraph = svgPanZoom('#procjsonwritekosselmasternamelistCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONwriteKosselMasterNameList Source Code recursive subroutine JSONwriteKosselMasterNameList ( knl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwriteKosselMasterNameList use ISO_C_BINDING IMPLICIT NONE type ( KosselMasterNameListType ), INTENT ( IN ) :: knl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 4 , n_real = 5 integer ( kind = irg ) :: io_int ( n_int ) real ( kind = sgl ) :: io_real ( n_real ) character ( 20 ) :: intlist ( n_int ), reallist ( n_real ) character ( fnlen ) :: dataset , namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'Kosselmasterlist' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! then we need to add all the necessary fields to the inp structure ! write all the single integers io_int = ( / knl % stdout , knl % numthick , knl % npx , knl % nthreads / ) intlist ( 1 ) = 'stdout' intlist ( 2 ) = 'numthick' intlist ( 3 ) = 'npx' intlist ( 4 ) = 'nthreads' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) ! write all the single reals io_real = ( / knl % voltage , knl % dmin , knl % startthick , knl % thickinc , knl % tfraction / ) reallist ( 1 ) = 'voltage' reallist ( 2 ) = 'dmin' reallist ( 3 ) = 'startthick' reallist ( 4 ) = 'thickinc' reallist ( 5 ) = 'tfraction' call JSON_writeNMLreals ( inp , io_real , reallist , n_real , error_cnt ) ! write all the strings dataset = 'Kosselmode' call json_add ( inp , dataset , knl % Kosselmode ); call JSON_failtest ( error_cnt ) dataset = 'xtalname' call json_add ( inp , dataset , knl % xtalname ); call JSON_failtest ( error_cnt ) dataset = 'outname' call json_add ( inp , dataset , knl % outname ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwriteKosselMasterNameList","tags":"","loc":"proc/jsonwritekosselmasternamelist.html","title":"JSONwriteKosselMasterNameList – Fortran Program"},{"text":"public recursive subroutine JSONwriteMCNameList(mcnl, jsonname, error_cnt) Uses: iso_c_binding proc~~jsonwritemcnamelist~~UsesGraph proc~jsonwritemcnamelist JSONwriteMCNameList iso_c_binding iso_c_binding iso_c_binding->proc~jsonwritemcnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief write namelist file into JSON file\n @param mcnl Monte Carlo name list structure\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/11/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(MCNameListType), intent(inout) :: mcnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt Calls proc~~jsonwritemcnamelist~~CallsGraph proc~jsonwritemcnamelist JSONwriteMCNameList proc~json_initpointers JSON_initpointers proc~jsonwritemcnamelist->proc~json_initpointers proc~json_writenmlintegers JSON_writeNMLintegers proc~jsonwritemcnamelist->proc~json_writenmlintegers proc~json_cleanuppointers JSON_cleanuppointers proc~jsonwritemcnamelist->proc~json_cleanuppointers proc~json_failtest JSON_failtest proc~jsonwritemcnamelist->proc~json_failtest proc~json_writenmldoubles JSON_writeNMLdoubles proc~jsonwritemcnamelist->proc~json_writenmldoubles json_add json_add proc~jsonwritemcnamelist->json_add proc~json_initpointers->proc~json_failtest proc~json_initpointers->json_add json_initialize json_initialize proc~json_initpointers->json_initialize json_create_object json_create_object proc~json_initpointers->json_create_object proc~json_writenmlintegers->proc~json_failtest proc~json_writenmlintegers->json_add proc~json_cleanuppointers->proc~json_failtest emsoft_tonativepath emsoft_tonativepath proc~json_cleanuppointers->emsoft_tonativepath json_destroy json_destroy proc~json_cleanuppointers->json_destroy json_print json_print proc~json_cleanuppointers->json_print json_failed json_failed proc~json_failtest->json_failed json_print_error_message json_print_error_message proc~json_failtest->json_print_error_message proc~json_writenmldoubles->proc~json_failtest proc~json_writenmldoubles->json_add Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONwriteMCNameList Source Code recursive subroutine JSONwriteMCNameList ( mcnl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwriteMCNameList use ISO_C_BINDING IMPLICIT NONE type ( MCNameListType ), INTENT ( INOUT ) :: mcnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 5 , n_real = 7 integer ( kind = irg ) :: io_int ( n_int ) real ( kind = dbl ) :: io_real ( n_real ) character ( 20 ) :: intlist ( n_int ), reallist ( n_real ) character ( fnlen ) :: dataset , sval ( 1 ), namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'MCdata' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! write all the single integers io_int = ( / mcnl % stdout , mcnl % numsx , mcnl % primeseed , mcnl % num_el , mcnl % nthreads / ) intlist ( 1 ) = 'stdout' intlist ( 2 ) = 'numsx' intlist ( 3 ) = 'primeseed' intlist ( 4 ) = 'num_el' intlist ( 5 ) = 'nthreads' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) ! write all the single doubles io_real = ( / mcnl % sig , mcnl % omega , mcnl % EkeV , mcnl % Ehistmin , mcnl % Ebinsize , mcnl % depthmax , mcnl % depthstep / ) reallist ( 1 ) = 'sig' reallist ( 2 ) = 'omega' reallist ( 3 ) = 'EkeV' reallist ( 4 ) = 'Ehistmin' reallist ( 5 ) = 'Ebinsize' reallist ( 6 ) = 'depthmax' reallist ( 7 ) = 'depthstep' call JSON_writeNMLdoubles ( inp , io_real , reallist , n_real , error_cnt ) ! write all the strings dataset = 'MCmode' call json_add ( inp , dataset , mcnl % MCmode ); call JSON_failtest ( error_cnt ) dataset = 'xtalname' call json_add ( inp , dataset , mcnl % xtalname ); call JSON_failtest ( error_cnt ) dataset = 'dataname' call json_add ( inp , dataset , mcnl % dataname ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwriteMCNameList","tags":"","loc":"proc/jsonwritemcnamelist.html","title":"JSONwriteMCNameList – Fortran Program"},{"text":"public recursive subroutine JSONwriteMCCLNameList(mcnl, jsonname, error_cnt) Uses: iso_c_binding proc~~jsonwritemcclnamelist~~UsesGraph proc~jsonwritemcclnamelist JSONwriteMCCLNameList iso_c_binding iso_c_binding iso_c_binding->proc~jsonwritemcclnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief write namelist to JSON file\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @param mcnl Monte Carlo name list structure\n @date 03/21/15 MDG 1.0 new routine\n @date 09/09/15 MDG 1.1 added devid\n @date 10/12/15 SS  1.2 changes to handle new mc program Arguments Type Intent Optional Attributes Name type(MCCLNameListType), intent(inout) :: mcnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt Calls proc~~jsonwritemcclnamelist~~CallsGraph proc~jsonwritemcclnamelist JSONwriteMCCLNameList proc~json_initpointers JSON_initpointers proc~jsonwritemcclnamelist->proc~json_initpointers proc~json_writenmlintegers JSON_writeNMLintegers proc~jsonwritemcclnamelist->proc~json_writenmlintegers proc~json_cleanuppointers JSON_cleanuppointers proc~jsonwritemcclnamelist->proc~json_cleanuppointers proc~json_failtest JSON_failtest proc~jsonwritemcclnamelist->proc~json_failtest proc~json_writenmldoubles JSON_writeNMLdoubles proc~jsonwritemcclnamelist->proc~json_writenmldoubles json_add json_add proc~jsonwritemcclnamelist->json_add proc~json_initpointers->proc~json_failtest proc~json_initpointers->json_add json_initialize json_initialize proc~json_initpointers->json_initialize json_create_object json_create_object proc~json_initpointers->json_create_object proc~json_writenmlintegers->proc~json_failtest proc~json_writenmlintegers->json_add proc~json_cleanuppointers->proc~json_failtest emsoft_tonativepath emsoft_tonativepath proc~json_cleanuppointers->emsoft_tonativepath json_destroy json_destroy proc~json_cleanuppointers->json_destroy json_print json_print proc~json_cleanuppointers->json_print json_failed json_failed proc~json_failtest->json_failed json_print_error_message json_print_error_message proc~json_failtest->json_print_error_message proc~json_writenmldoubles->proc~json_failtest proc~json_writenmldoubles->json_add Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONwriteMCCLNameList Source Code recursive subroutine JSONwriteMCCLNameList ( mcnl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwriteMCCLNameList use ISO_C_BINDING IMPLICIT NONE type ( MCCLNameListType ), INTENT ( INOUT ) :: mcnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 8 , n_real_bse1 = 9 , n_real_full = 7 integer ( kind = irg ) :: io_int ( n_int ) real ( kind = dbl ) :: io_real_bse1 ( n_real_bse1 ), io_real_full ( n_real_full ) character ( 20 ) :: intlist ( n_int ), reallist_bse1 ( n_real_bse1 ), reallist_full ( n_real_full ) character ( fnlen ) :: dataset , sval ( 1 ), namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'MCCLdata' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! write all the single integers io_int = ( / mcnl % stdout , mcnl % numsx , mcnl % globalworkgrpsz , mcnl % num_el , mcnl % totnum_el , mcnl % multiplier , mcnl % devid , mcnl % platid / ) intlist ( 1 ) = 'stdout' intlist ( 2 ) = 'numsx' intlist ( 3 ) = 'globalworkgrpsz' intlist ( 4 ) = 'num_el' intlist ( 5 ) = 'totnum_el' intlist ( 6 ) = 'multiplier' intlist ( 7 ) = 'devid' intlist ( 8 ) = 'platid' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) ! write all the single doubles for bse1 mode if ( mcnl % mode . eq . 'bse1' ) then io_real_bse1 = ( / mcnl % sigstart , mcnl % sigend , mcnl % sigstep , mcnl % omega , mcnl % EkeV , mcnl % Ehistmin , & mcnl % Ebinsize , mcnl % depthmax , mcnl % depthstep / ) reallist_bse1 ( 1 ) = 'sigstart' reallist_bse1 ( 2 ) = 'sigend' reallist_bse1 ( 3 ) = 'sigstep' reallist_bse1 ( 4 ) = 'omega' reallist_bse1 ( 5 ) = 'EkeV' reallist_bse1 ( 6 ) = 'Ehistmin' reallist_bse1 ( 7 ) = 'Ebinsize' reallist_bse1 ( 8 ) = 'depthmax' reallist_bse1 ( 9 ) = 'depthstep' call JSON_writeNMLdoubles ( inp , io_real_bse1 , reallist_bse1 , n_real_bse1 , error_cnt ) else if ( mcnl % mode . eq . 'full' ) then io_real_full = ( / mcnl % sig , mcnl % omega , mcnl % EkeV , mcnl % Ehistmin , & mcnl % Ebinsize , mcnl % depthmax , mcnl % depthstep / ) reallist_full ( 1 ) = 'sig' reallist_full ( 2 ) = 'omega' reallist_full ( 3 ) = 'EkeV' reallist_full ( 4 ) = 'Ehistmin' reallist_full ( 5 ) = 'Ebinsize' reallist_full ( 6 ) = 'depthmax' reallist_full ( 7 ) = 'depthstep' call JSON_writeNMLdoubles ( inp , io_real_full , reallist_full , n_real_full , error_cnt ) end if ! write all the strings dataset = 'MCmode' call json_add ( inp , dataset , mcnl % MCmode ); call JSON_failtest ( error_cnt ) dataset = 'xtalname' call json_add ( inp , dataset , mcnl % xtalname ); call JSON_failtest ( error_cnt ) dataset = 'dataname' call json_add ( inp , dataset , mcnl % dataname ); call JSON_failtest ( error_cnt ) dataset = 'mode' call json_add ( inp , dataset , mcnl % mode ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwriteMCCLNameList","tags":"","loc":"proc/jsonwritemcclnamelist.html","title":"JSONwriteMCCLNameList – Fortran Program"},{"text":"public recursive subroutine JSONwriteMCCLMultiLayerNameList(mcnl, jsonname, error_cnt) Uses: iso_c_binding proc~~jsonwritemcclmultilayernamelist~~UsesGraph proc~jsonwritemcclmultilayernamelist JSONwriteMCCLMultiLayerNameList iso_c_binding iso_c_binding iso_c_binding->proc~jsonwritemcclmultilayernamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief write namelist to JSON file\n @param mcnl Monte Carlo name list structure\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/11/15 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(MCCLMultiLayerNameListType), intent(inout) :: mcnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt Calls proc~~jsonwritemcclmultilayernamelist~~CallsGraph proc~jsonwritemcclmultilayernamelist JSONwriteMCCLMultiLayerNameList proc~json_initpointers JSON_initpointers proc~jsonwritemcclmultilayernamelist->proc~json_initpointers proc~json_writenmlintegers JSON_writeNMLintegers proc~jsonwritemcclmultilayernamelist->proc~json_writenmlintegers proc~json_cleanuppointers JSON_cleanuppointers proc~jsonwritemcclmultilayernamelist->proc~json_cleanuppointers proc~json_failtest JSON_failtest proc~jsonwritemcclmultilayernamelist->proc~json_failtest proc~json_writenmldoubles JSON_writeNMLdoubles proc~jsonwritemcclmultilayernamelist->proc~json_writenmldoubles json_add json_add proc~jsonwritemcclmultilayernamelist->json_add proc~json_initpointers->proc~json_failtest proc~json_initpointers->json_add json_initialize json_initialize proc~json_initpointers->json_initialize json_create_object json_create_object proc~json_initpointers->json_create_object proc~json_writenmlintegers->proc~json_failtest proc~json_writenmlintegers->json_add proc~json_cleanuppointers->proc~json_failtest emsoft_tonativepath emsoft_tonativepath proc~json_cleanuppointers->emsoft_tonativepath json_destroy json_destroy proc~json_cleanuppointers->json_destroy json_print json_print proc~json_cleanuppointers->json_print json_failed json_failed proc~json_failtest->json_failed json_print_error_message json_print_error_message proc~json_failtest->json_print_error_message proc~json_writenmldoubles->proc~json_failtest proc~json_writenmldoubles->json_add var panprocjsonwritemcclmultilayernamelistCallsGraph = svgPanZoom('#procjsonwritemcclmultilayernamelistCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONwriteMCCLMultiLayerNameList Source Code recursive subroutine JSONwriteMCCLMultiLayerNameList ( mcnl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwriteMCCLMultiLayerNameList use ISO_C_BINDING IMPLICIT NONE type ( MCCLMultiLayerNameListType ), INTENT ( INOUT ) :: mcnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 5 , n_real = 9 integer ( kind = irg ) :: io_int ( n_int ) real ( kind = dbl ) :: io_real ( n_real ) character ( 20 ) :: intlist ( n_int ), reallist ( n_real ) character ( fnlen ) :: dataset , namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'MCCLdata' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! write all the single integers io_int = ( / mcnl % stdout , mcnl % numsx , mcnl % globalworkgrpsz , mcnl % num_el , mcnl % totnum_el / ) intlist ( 1 ) = 'stdout' intlist ( 2 ) = 'numsx' intlist ( 3 ) = 'globalworkgrpsz' intlist ( 4 ) = 'num_el' intlist ( 5 ) = 'totnum_el' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) ! write all the single doubles io_real = ( / mcnl % sig , mcnl % omega , mcnl % EkeV , mcnl % Ehistmin , mcnl % Ebinsize , mcnl % depthmax , mcnl % depthstep , & mcnl % filmthickness , mcnl % filmstep / ) reallist ( 1 ) = 'sig' reallist ( 2 ) = 'omega' reallist ( 3 ) = 'EkeV' reallist ( 4 ) = 'Ehistmin' reallist ( 5 ) = 'Ebinsize' reallist ( 6 ) = 'depthmax' reallist ( 7 ) = 'depthstep' reallist ( 8 ) = 'filmthickness' reallist ( 9 ) = 'filmstep' call JSON_writeNMLdoubles ( inp , io_real , reallist , n_real , error_cnt ) ! write all the strings dataset = 'MCmode' call json_add ( inp , dataset , mcnl % MCmode ); call JSON_failtest ( error_cnt ) dataset = 'xtalname_film' call json_add ( inp , dataset , mcnl % xtalname_film ); call JSON_failtest ( error_cnt ) dataset = 'xtalname_subs' call json_add ( inp , dataset , mcnl % xtalname_subs ); call JSON_failtest ( error_cnt ) dataset = 'dataname' call json_add ( inp , dataset , mcnl % dataname ); call JSON_failtest ( error_cnt ) dataset = 'mode' call json_add ( inp , dataset , mcnl % mode ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwriteMCCLMultiLayerNameList","tags":"","loc":"proc/jsonwritemcclmultilayernamelist.html","title":"JSONwriteMCCLMultiLayerNameList – Fortran Program"},{"text":"public recursive subroutine JSONwriteEBSDMasterNameList(emnl, jsonname, error_cnt) Uses: iso_c_binding proc~~jsonwriteebsdmasternamelist~~UsesGraph proc~jsonwriteebsdmasternamelist JSONwriteEBSDMasterNameList iso_c_binding iso_c_binding iso_c_binding->proc~jsonwriteebsdmasternamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief write namelist to JSON file\n @param emnl EBSD master name list structure\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/12/15 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(EBSDMasterNameListType), intent(inout) :: emnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt Calls proc~~jsonwriteebsdmasternamelist~~CallsGraph proc~jsonwriteebsdmasternamelist JSONwriteEBSDMasterNameList json_add json_add proc~jsonwriteebsdmasternamelist->json_add proc~json_failtest JSON_failtest proc~jsonwriteebsdmasternamelist->proc~json_failtest proc~json_cleanuppointers JSON_cleanuppointers proc~jsonwriteebsdmasternamelist->proc~json_cleanuppointers proc~json_initpointers JSON_initpointers proc~jsonwriteebsdmasternamelist->proc~json_initpointers proc~json_writenmlintegers JSON_writeNMLintegers proc~jsonwriteebsdmasternamelist->proc~json_writenmlintegers json_failed json_failed proc~json_failtest->json_failed json_print_error_message json_print_error_message proc~json_failtest->json_print_error_message proc~json_cleanuppointers->proc~json_failtest emsoft_tonativepath emsoft_tonativepath proc~json_cleanuppointers->emsoft_tonativepath json_destroy json_destroy proc~json_cleanuppointers->json_destroy json_print json_print proc~json_cleanuppointers->json_print proc~json_initpointers->json_add proc~json_initpointers->proc~json_failtest json_initialize json_initialize proc~json_initpointers->json_initialize json_create_object json_create_object proc~json_initpointers->json_create_object proc~json_writenmlintegers->json_add proc~json_writenmlintegers->proc~json_failtest var panprocjsonwriteebsdmasternamelistCallsGraph = svgPanZoom('#procjsonwriteebsdmasternamelistCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONwriteEBSDMasterNameList Source Code recursive subroutine JSONwriteEBSDMasterNameList ( emnl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwriteEBSDMasterNameList use ISO_C_BINDING IMPLICIT NONE type ( EBSDMasterNameListType ), INTENT ( INOUT ) :: emnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 6 , n_real = 1 integer ( kind = irg ) :: io_int ( n_int ), restart , uniform real ( kind = sgl ) :: io_real ( n_real ) character ( 20 ) :: intlist ( n_int ), reallist ( n_real ) character ( fnlen ) :: dataset , namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'EBSDmastervars' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! write all the single integers if ( emnl % restart . eqv .. TRUE .) then restart = 1 else restart = 0 end if if ( emnl % uniform . eqv .. TRUE .) then uniform = 1 else uniform = 0 end if io_int = ( / emnl % stdout , emnl % npx , emnl % Esel , emnl % nthreads , restart , uniform / ) intlist ( 1 ) = 'stdout' intlist ( 2 ) = 'npx' intlist ( 3 ) = 'Esel' intlist ( 4 ) = 'nthreads' intlist ( 5 ) = 'restart' intlist ( 6 ) = 'uniform' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) ! write a single real dataset = 'dmin' call json_add ( inp , dataset , dble ( emnl % dmin )); call JSON_failtest ( error_cnt ) ! write all the strings dataset = 'outname' call json_add ( inp , dataset , emnl % outname ); call JSON_failtest ( error_cnt ) dataset = 'energyfile' call json_add ( inp , dataset , emnl % energyfile ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwriteEBSDMasterNameList","tags":"","loc":"proc/jsonwriteebsdmasternamelist.html","title":"JSONwriteEBSDMasterNameList – Fortran Program"},{"text":"public recursive subroutine JSONwriteEBSDclusterNameList(emnl, jsonname, error_cnt) Uses: iso_c_binding proc~~jsonwriteebsdclusternamelist~~UsesGraph proc~jsonwriteebsdclusternamelist JSONwriteEBSDclusterNameList iso_c_binding iso_c_binding iso_c_binding->proc~jsonwriteebsdclusternamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief write namelist to JSON file\n @param emnl EBSD cluster name list structure\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @date 12/28/15 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(EBSDclusterNameListType), intent(inout) :: emnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt Calls proc~~jsonwriteebsdclusternamelist~~CallsGraph proc~jsonwriteebsdclusternamelist JSONwriteEBSDclusterNameList json_add json_add proc~jsonwriteebsdclusternamelist->json_add proc~json_failtest JSON_failtest proc~jsonwriteebsdclusternamelist->proc~json_failtest proc~json_cleanuppointers JSON_cleanuppointers proc~jsonwriteebsdclusternamelist->proc~json_cleanuppointers proc~json_initpointers JSON_initpointers proc~jsonwriteebsdclusternamelist->proc~json_initpointers proc~json_writenmlintegers JSON_writeNMLintegers proc~jsonwriteebsdclusternamelist->proc~json_writenmlintegers json_failed json_failed proc~json_failtest->json_failed json_print_error_message json_print_error_message proc~json_failtest->json_print_error_message proc~json_cleanuppointers->proc~json_failtest emsoft_tonativepath emsoft_tonativepath proc~json_cleanuppointers->emsoft_tonativepath json_destroy json_destroy proc~json_cleanuppointers->json_destroy json_print json_print proc~json_cleanuppointers->json_print proc~json_initpointers->json_add proc~json_initpointers->proc~json_failtest json_initialize json_initialize proc~json_initpointers->json_initialize json_create_object json_create_object proc~json_initpointers->json_create_object proc~json_writenmlintegers->json_add proc~json_writenmlintegers->proc~json_failtest var panprocjsonwriteebsdclusternamelistCallsGraph = svgPanZoom('#procjsonwriteebsdclusternamelistCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONwriteEBSDclusterNameList Source Code recursive subroutine JSONwriteEBSDclusterNameList ( emnl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwriteEBSDclusterNameList use ISO_C_BINDING IMPLICIT NONE type ( EBSDclusterNameListType ), INTENT ( INOUT ) :: emnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 3 , n_real = 1 integer ( kind = irg ) :: io_int ( n_int ) real ( kind = sgl ) :: io_real ( n_real ) character ( 20 ) :: intlist ( n_int ), reallist ( n_real ) character ( fnlen ) :: dataset , namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'EBSDclustervars' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! write all the single integers io_int = ( / emnl % NClusters , emnl % NIterations , emnl % binfactor / ) intlist ( 1 ) = 'NClusters' intlist ( 2 ) = 'NIterations' intlist ( 3 ) = 'binfactor' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) ! write all the strings dataset = 'inputfilename' call json_add ( inp , dataset , emnl % inputfilename ); call JSON_failtest ( error_cnt ) dataset = 'groupname' call json_add ( inp , dataset , emnl % groupname ); call JSON_failtest ( error_cnt ) dataset = 'datasetname' call json_add ( inp , dataset , emnl % datasetname ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwriteEBSDclusterNameList","tags":"","loc":"proc/jsonwriteebsdclusternamelist.html","title":"JSONwriteEBSDclusterNameList – Fortran Program"},{"text":"public recursive subroutine JSONwriteECPMasterNameList(ecpnl, jsonname, error_cnt) Uses: iso_c_binding proc~~jsonwriteecpmasternamelist~~UsesGraph proc~jsonwriteecpmasternamelist JSONwriteECPMasterNameList iso_c_binding iso_c_binding iso_c_binding->proc~jsonwriteecpmasternamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief write namelist to JSON file\n @param ecpnl ECP master name list structure\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/12/15 MDG 1.0 new routine\n @date 09/15/15 SS  1.1 changes after clean up of ECPmasterListType Arguments Type Intent Optional Attributes Name type(ECPMasterNameListType), intent(inout) :: ecpnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt Calls proc~~jsonwriteecpmasternamelist~~CallsGraph proc~jsonwriteecpmasternamelist JSONwriteECPMasterNameList proc~json_initpointers JSON_initpointers proc~jsonwriteecpmasternamelist->proc~json_initpointers proc~json_writenmlintegers JSON_writeNMLintegers proc~jsonwriteecpmasternamelist->proc~json_writenmlintegers proc~json_cleanuppointers JSON_cleanuppointers proc~jsonwriteecpmasternamelist->proc~json_cleanuppointers proc~json_failtest JSON_failtest proc~jsonwriteecpmasternamelist->proc~json_failtest proc~json_writenmldoubles JSON_writeNMLdoubles proc~jsonwriteecpmasternamelist->proc~json_writenmldoubles json_add json_add proc~jsonwriteecpmasternamelist->json_add proc~json_initpointers->proc~json_failtest proc~json_initpointers->json_add json_initialize json_initialize proc~json_initpointers->json_initialize json_create_object json_create_object proc~json_initpointers->json_create_object proc~json_writenmlintegers->proc~json_failtest proc~json_writenmlintegers->json_add proc~json_cleanuppointers->proc~json_failtest emsoft_tonativepath emsoft_tonativepath proc~json_cleanuppointers->emsoft_tonativepath json_destroy json_destroy proc~json_cleanuppointers->json_destroy json_print json_print proc~json_cleanuppointers->json_print json_failed json_failed proc~json_failtest->json_failed json_print_error_message json_print_error_message proc~json_failtest->json_print_error_message proc~json_writenmldoubles->proc~json_failtest proc~json_writenmldoubles->json_add var panprocjsonwriteecpmasternamelistCallsGraph = svgPanZoom('#procjsonwriteecpmasternamelistCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONwriteECPMasterNameList Source Code recursive subroutine JSONwriteECPMasterNameList ( ecpnl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwriteECPMasterNameList use ISO_C_BINDING IMPLICIT NONE type ( ECPMasterNameListType ), INTENT ( INOUT ) :: ecpnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 4 , n_real = 1 integer ( kind = irg ) :: io_int ( n_int ) real ( kind = dbl ) :: io_real ( n_real ) character ( 20 ) :: intlist ( n_int ), reallist ( n_real ) character ( fnlen ) :: dataset , namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'ECPmastervars' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! write all the single integers io_int = ( / ecpnl % stdout , ecpnl % Esel , ecpnl % npx , ecpnl % nthreads / ) intlist ( 1 ) = 'stdout' intlist ( 2 ) = 'Esel' intlist ( 3 ) = 'npx' intlist ( 4 ) = 'nthreads' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) !dataset = 'distort' !call json_add(inp, dataset, ecpnl%distort); call JSON_failtest(error_cnt) ! integer vectors !dataset = 'fn' !call json_add(inp, dataset, dble(ecpnl%fn)); call JSON_failtest(error_cnt) ! write all the single doubles io_real = ( / ecpnl % dmin / ) reallist ( 1 ) = 'dmin' !reallist(2) = 'startthick' call JSON_writeNMLdoubles ( inp , io_real , reallist , n_real , error_cnt ) ! 3-vectors (real) !dataset = 'abcdist' !call json_add(inp, dataset, dble(ecpnl%abcdist)); call JSON_failtest(error_cnt) !dataset = 'albegadist' !call json_add(inp, dataset, dble(ecpnl%albegadist)); call JSON_failtest(error_cnt) ! write all the strings dataset = 'outname' call json_add ( inp , dataset , ecpnl % outname ); call JSON_failtest ( error_cnt ) dataset = 'energyfile' call json_add ( inp , dataset , ecpnl % energyfile ); call JSON_failtest ( error_cnt ) dataset = 'compmode' call json_add ( inp , dataset , ecpnl % compmode ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwriteECPMasterNameList","tags":"","loc":"proc/jsonwriteecpmasternamelist.html","title":"JSONwriteECPMasterNameList – Fortran Program"},{"text":"public recursive subroutine JSONwriteEBSDNameList(enl, jsonname, error_cnt) Uses: iso_c_binding proc~~jsonwriteebsdnamelist~~UsesGraph proc~jsonwriteebsdnamelist JSONwriteEBSDNameList iso_c_binding iso_c_binding iso_c_binding->proc~jsonwriteebsdnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief write namelist to JSON file\n @param enl EBSD name list structure\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/12/15 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(EBSDNameListType), intent(inout) :: enl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt Calls proc~~jsonwriteebsdnamelist~~CallsGraph proc~jsonwriteebsdnamelist JSONwriteEBSDNameList proc~json_initpointers JSON_initpointers proc~jsonwriteebsdnamelist->proc~json_initpointers proc~json_writenmlintegers JSON_writeNMLintegers proc~jsonwriteebsdnamelist->proc~json_writenmlintegers proc~json_cleanuppointers JSON_cleanuppointers proc~jsonwriteebsdnamelist->proc~json_cleanuppointers proc~json_failtest JSON_failtest proc~jsonwriteebsdnamelist->proc~json_failtest proc~json_writenmlreals JSON_writeNMLreals proc~jsonwriteebsdnamelist->proc~json_writenmlreals json_add json_add proc~jsonwriteebsdnamelist->json_add proc~json_initpointers->proc~json_failtest proc~json_initpointers->json_add json_initialize json_initialize proc~json_initpointers->json_initialize json_create_object json_create_object proc~json_initpointers->json_create_object proc~json_writenmlintegers->proc~json_failtest proc~json_writenmlintegers->json_add proc~json_cleanuppointers->proc~json_failtest emsoft_tonativepath emsoft_tonativepath proc~json_cleanuppointers->emsoft_tonativepath json_destroy json_destroy proc~json_cleanuppointers->json_destroy json_print json_print proc~json_cleanuppointers->json_print json_failed json_failed proc~json_failtest->json_failed json_print_error_message json_print_error_message proc~json_failtest->json_print_error_message proc~json_writenmlreals->proc~json_failtest proc~json_writenmlreals->json_add Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONwriteEBSDNameList Source Code recursive subroutine JSONwriteEBSDNameList ( enl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwriteEBSDNameList use ISO_C_BINDING IMPLICIT NONE type ( EBSDNameListType ), INTENT ( INOUT ) :: enl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 6 , n_real = 9 integer ( kind = irg ) :: io_int ( n_int ) real ( kind = sgl ) :: io_real ( n_real ) real ( kind = dbl ) :: t ( 1 ) character ( 20 ) :: intlist ( n_int ), reallist ( n_real ) character ( fnlen ) :: dataset , namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'EBSDdata' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! write all the single integers io_int = ( / enl % stdout , enl % numsx , enl % numsy , enl % binning , enl % nthreads , enl % energyaverage / ) intlist ( 1 ) = 'stdout' intlist ( 2 ) = 'numsx' intlist ( 3 ) = 'numsy' intlist ( 4 ) = 'binning' intlist ( 5 ) = 'nthreads' intlist ( 6 ) = 'energyaverage' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) ! write all the single reals io_real = ( / enl % L , enl % thetac , enl % delta , enl % xpc , enl % ypc , enl % energymin , enl % energymax , enl % gammavalue , enl % alphaBD / ) reallist ( 1 ) = 'L' reallist ( 2 ) = 'thetac' reallist ( 3 ) = 'delta' reallist ( 4 ) = 'xpc' reallist ( 5 ) = 'ypc' reallist ( 6 ) = 'energymin' reallist ( 7 ) = 'energymax' reallist ( 8 ) = 'gammavalue' reallist ( 9 ) = 'alphaBD' call JSON_writeNMLreals ( inp , io_real , reallist , n_real , error_cnt ) ! a 4-vector dataset = 'axisangle' call json_add ( inp , dataset , dble ( enl % axisangle )); call JSON_failtest ( error_cnt ) ! a few doubles dataset = 'beamcurrent' call json_add ( inp , dataset , enl % beamcurrent ); call JSON_failtest ( error_cnt ) dataset = 'dwelltime' call json_add ( inp , dataset , enl % dwelltime ); call JSON_failtest ( error_cnt ) ! write all the strings dataset = 'maskpattern' call json_add ( inp , dataset , enl % maskpattern ); call JSON_failtest ( error_cnt ) dataset = 'scalingmode' call json_add ( inp , dataset , enl % scalingmode ); call JSON_failtest ( error_cnt ) dataset = 'eulerconvention' call json_add ( inp , dataset , enl % eulerconvention ); call JSON_failtest ( error_cnt ) dataset = 'outputformat' call json_add ( inp , dataset , enl % outputformat ); call JSON_failtest ( error_cnt ) dataset = 'energyfile' call json_add ( inp , dataset , enl % energyfile ); call JSON_failtest ( error_cnt ) dataset = 'masterfile' call json_add ( inp , dataset , enl % masterfile ); call JSON_failtest ( error_cnt ) dataset = 'anglefile' call json_add ( inp , dataset , enl % anglefile ); call JSON_failtest ( error_cnt ) dataset = 'datafile' call json_add ( inp , dataset , enl % datafile ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwriteEBSDNameList","tags":"","loc":"proc/jsonwriteebsdnamelist.html","title":"JSONwriteEBSDNameList – Fortran Program"},{"text":"public recursive subroutine JSONwriteECPNameList(ecpnl, jsonname, error_cnt, twolayerflag) Uses: iso_c_binding error proc~~jsonwriteecpnamelist~~UsesGraph proc~jsonwriteecpnamelist JSONwriteECPNameList iso_c_binding iso_c_binding iso_c_binding->proc~jsonwriteecpnamelist error error error->proc~jsonwriteecpnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief write namelist to JSON file\n @param ecpnl ECP namelist structure\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/12/15 MDG 1.0 new routine\n @date 09/15/15 SS  1.1 changes after modification of ECPListType\n @date 10/15/15 SS  1.2 changes for release Arguments Type Intent Optional Attributes Name type(ECPNameListType), intent(inout) :: ecpnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt logical, intent(in) :: twolayerflag Calls proc~~jsonwriteecpnamelist~~CallsGraph proc~jsonwriteecpnamelist JSONwriteECPNameList fatalerror fatalerror proc~jsonwriteecpnamelist->fatalerror proc~json_writenmlintegers JSON_writeNMLintegers proc~jsonwriteecpnamelist->proc~json_writenmlintegers sngl sngl proc~jsonwriteecpnamelist->sngl proc~json_cleanuppointers JSON_cleanuppointers proc~jsonwriteecpnamelist->proc~json_cleanuppointers proc~json_writenmlreals JSON_writeNMLreals proc~jsonwriteecpnamelist->proc~json_writenmlreals proc~json_failtest JSON_failtest proc~jsonwriteecpnamelist->proc~json_failtest json_add json_add proc~jsonwriteecpnamelist->json_add proc~json_initpointers JSON_initpointers proc~jsonwriteecpnamelist->proc~json_initpointers proc~json_writenmlintegers->proc~json_failtest proc~json_writenmlintegers->json_add proc~json_cleanuppointers->proc~json_failtest emsoft_tonativepath emsoft_tonativepath proc~json_cleanuppointers->emsoft_tonativepath json_destroy json_destroy proc~json_cleanuppointers->json_destroy json_print json_print proc~json_cleanuppointers->json_print proc~json_writenmlreals->proc~json_failtest proc~json_writenmlreals->json_add json_failed json_failed proc~json_failtest->json_failed json_print_error_message json_print_error_message proc~json_failtest->json_print_error_message proc~json_initpointers->proc~json_failtest proc~json_initpointers->json_add json_initialize json_initialize proc~json_initpointers->json_initialize json_create_object json_create_object proc~json_initpointers->json_create_object Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONwriteECPNameList Source Code recursive subroutine JSONwriteECPNameList ( ecpnl , jsonname , error_cnt , twolayerflag ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwriteECPNameList use ISO_C_BINDING use error IMPLICIT NONE type ( ECPNameListType ), INTENT ( INOUT ) :: ecpnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt logical , INTENT ( IN ) :: twolayerflag type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 2 integer ( kind = irg ) :: n_real , istat integer ( kind = irg ) :: io_int ( n_int ) real ( kind = sgl ), allocatable :: io_real (:) character ( 20 ), allocatable :: reallist (:) character ( 20 ) :: intlist ( n_int ) character ( fnlen ) :: dataset , namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'ECPlist' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! write all the single integers io_int = ( / ecpnl % nthreads , ecpnl % npix / ) intlist ( 1 ) = 'nthreads' intlist ( 2 ) = 'npix' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) if ( twolayerflag ) then ! integer vectors dataset = 'fn_f' call json_add ( inp , dataset , ecpnl % fn_f ); call JSON_failtest ( error_cnt ) dataset = 'fn_s' call json_add ( inp , dataset , ecpnl % fn_s ); call JSON_failtest ( error_cnt ) dataset = 'gF' call json_add ( inp , dataset , ecpnl % gF ); call JSON_failtest ( error_cnt ) dataset = 'gS' call json_add ( inp , dataset , ecpnl % gS ); call JSON_failtest ( error_cnt ) dataset = 'tF' call json_add ( inp , dataset , ecpnl % tF ); call JSON_failtest ( error_cnt ) dataset = 'tS' call json_add ( inp , dataset , ecpnl % tS ); call JSON_failtest ( error_cnt ) n_real = 8 allocate ( reallist ( n_real ), io_real ( n_real ), stat = istat ) if ( istat . ne . 0 ) then call FatalError ( 'HDFwriteECPNameList' , 'Cannot allocate the reallist array' ) end if ! write all the single reals io_real = ( / ecpnl % dmin , ecpnl % thetac , sngl ( ecpnl % sampletilt ), ecpnl % workingdistance , & ecpnl % filmthickness , ecpnl % gammavalue , ecpnl % Rin , ecpnl % Rout / ) reallist ( 1 ) = 'dmin' reallist ( 2 ) = 'thetac' reallist ( 3 ) = 'sampletilt' reallist ( 4 ) = 'workingdistance' reallist ( 5 ) = 'filmthickness' reallist ( 6 ) = 'gammavalue' reallist ( 7 ) = 'Rin' reallist ( 8 ) = 'Rout' call JSON_writeNMLreals ( inp , io_real , reallist , n_real , error_cnt ) else n_real = 6 allocate ( reallist ( n_real ), io_real ( n_real ), stat = istat ) if ( istat . ne . 0 ) then call FatalError ( 'HDFwriteECPNameList' , 'Cannot allocate the reallist array' ) end if ! write all the single reals io_real = ( / ecpnl % thetac , sngl ( ecpnl % sampletilt ), & ecpnl % gammavalue , ecpnl % workingdistance , ecpnl % Rin , ecpnl % Rout / ) reallist ( 1 ) = 'thetac' reallist ( 2 ) = 'sampletilt' reallist ( 3 ) = 'gammavalue' reallist ( 4 ) = 'workingdistance' reallist ( 5 ) = 'Rin' reallist ( 6 ) = 'Rout' call JSON_writeNMLreals ( inp , io_real , reallist , n_real , error_cnt ) end if ! write all the strings dataset = 'energyfile' call json_add ( inp , dataset , ecpnl % energyfile ); call JSON_failtest ( error_cnt ) dataset = 'masterfile' call json_add ( inp , dataset , ecpnl % masterfile ); call JSON_failtest ( error_cnt ) dataset = 'datafile' call json_add ( inp , dataset , ecpnl % datafile ); call JSON_failtest ( error_cnt ) dataset = 'xtalname' call json_add ( inp , dataset , ecpnl % xtalname ); call JSON_failtest ( error_cnt ) if ( twolayerflag ) then dataset = 'xtalname2' call json_add ( inp , dataset , ecpnl % xtalname2 ); call JSON_failtest ( error_cnt ) dataset = 'filmfile' call json_add ( inp , dataset , ecpnl % filmfile ); call JSON_failtest ( error_cnt ) dataset = 'subsfile' call json_add ( inp , dataset , ecpnl % subsfile ); call JSON_failtest ( error_cnt ) end if dataset = 'maskpattern' call json_add ( inp , dataset , ecpnl % maskpattern ); call JSON_failtest ( error_cnt ) dataset = 'anglefile' call json_add ( inp , dataset , ecpnl % anglefile ); call JSON_failtest ( error_cnt ) dataset = 'outputformat' call json_add ( inp , dataset , ecpnl % outputformat ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwriteECPNameList","tags":"","loc":"proc/jsonwriteecpnamelist.html","title":"JSONwriteECPNameList – Fortran Program"},{"text":"public recursive subroutine JSONwriteLACBEDNameList(lacbednl, jsonname, error_cnt) Uses: iso_c_binding proc~~jsonwritelacbednamelist~~UsesGraph proc~jsonwritelacbednamelist JSONwriteLACBEDNameList iso_c_binding iso_c_binding iso_c_binding->proc~jsonwritelacbednamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief write namelist to JSON file\n @param lacbednl LACBED name list structure\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/12/15 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(LACBEDNameListType), intent(inout) :: lacbednl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt Calls proc~~jsonwritelacbednamelist~~CallsGraph proc~jsonwritelacbednamelist JSONwriteLACBEDNameList proc~json_initpointers JSON_initpointers proc~jsonwritelacbednamelist->proc~json_initpointers proc~json_writenmlintegers JSON_writeNMLintegers proc~jsonwritelacbednamelist->proc~json_writenmlintegers proc~json_cleanuppointers JSON_cleanuppointers proc~jsonwritelacbednamelist->proc~json_cleanuppointers proc~json_writenmlreals JSON_writeNMLreals proc~jsonwritelacbednamelist->proc~json_writenmlreals proc~json_failtest JSON_failtest proc~jsonwritelacbednamelist->proc~json_failtest json_add json_add proc~jsonwritelacbednamelist->json_add proc~json_initpointers->proc~json_failtest proc~json_initpointers->json_add json_initialize json_initialize proc~json_initpointers->json_initialize json_create_object json_create_object proc~json_initpointers->json_create_object proc~json_writenmlintegers->proc~json_failtest proc~json_writenmlintegers->json_add proc~json_cleanuppointers->proc~json_failtest emsoft_tonativepath emsoft_tonativepath proc~json_cleanuppointers->emsoft_tonativepath json_destroy json_destroy proc~json_cleanuppointers->json_destroy json_print json_print proc~json_cleanuppointers->json_print proc~json_writenmlreals->proc~json_failtest proc~json_writenmlreals->json_add json_failed json_failed proc~json_failtest->json_failed json_print_error_message json_print_error_message proc~json_failtest->json_print_error_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONwriteLACBEDNameList Source Code recursive subroutine JSONwriteLACBEDNameList ( lacbednl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwriteLACBEDNameList use ISO_C_BINDING IMPLICIT NONE type ( LACBEDNameListType ), INTENT ( INOUT ) :: lacbednl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 5 , n_real = 6 integer ( kind = irg ) :: io_int ( n_int ) real ( kind = sgl ) :: io_real ( n_real ) character ( 20 ) :: intlist ( n_int ), reallist ( n_real ) character ( fnlen ) :: dataset , namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'inputlist' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! write all the single integers io_int = ( / lacbednl % stdout , lacbednl % maxHOLZ , lacbednl % numthick , lacbednl % npix , lacbednl % nthreads / ) intlist ( 1 ) = 'stdout' intlist ( 2 ) = 'maxHOLZ' intlist ( 3 ) = 'numthick' intlist ( 4 ) = 'npix' intlist ( 5 ) = 'nthreads' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) ! vectors dataset = 'k' call json_add ( inp , dataset , lacbednl % k ); call JSON_failtest ( error_cnt ) dataset = 'fn' call json_add ( inp , dataset , lacbednl % fn ); call JSON_failtest ( error_cnt ) ! write all the single reals io_real = ( / lacbednl % voltage , lacbednl % dmin , lacbednl % convergence , lacbednl % startthick , lacbednl % thickinc , lacbednl % minten / ) reallist ( 1 ) = 'voltage' reallist ( 2 ) = 'dmin' reallist ( 3 ) = 'convergence' reallist ( 4 ) = 'startthick' reallist ( 5 ) = 'thickinc' reallist ( 6 ) = 'minten' call JSON_writeNMLreals ( inp , io_real , reallist , n_real , error_cnt ) ! write all the strings dataset = 'outname' call json_add ( inp , dataset , lacbednl % outname ); call JSON_failtest ( error_cnt ) dataset = 'xtalname' call json_add ( inp , dataset , lacbednl % xtalname ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwriteLACBEDNameList","tags":"","loc":"proc/jsonwritelacbednamelist.html","title":"JSONwriteLACBEDNameList – Fortran Program"},{"text":"public recursive subroutine JSONwriteECPpatternNameList(ecpnl, jsonname, error_cnt) Uses: iso_c_binding proc~~jsonwriteecppatternnamelist~~UsesGraph proc~jsonwriteecppatternnamelist JSONwriteECPpatternNameList iso_c_binding iso_c_binding iso_c_binding->proc~jsonwriteecppatternnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief write namelist into JSON file\n @param ecpnl ECP name list structure\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/12/15 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(ECPpatternNameListType), intent(inout) :: ecpnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt Calls proc~~jsonwriteecppatternnamelist~~CallsGraph proc~jsonwriteecppatternnamelist JSONwriteECPpatternNameList json_add json_add proc~jsonwriteecppatternnamelist->json_add proc~json_failtest JSON_failtest proc~jsonwriteecppatternnamelist->proc~json_failtest proc~json_cleanuppointers JSON_cleanuppointers proc~jsonwriteecppatternnamelist->proc~json_cleanuppointers proc~json_initpointers JSON_initpointers proc~jsonwriteecppatternnamelist->proc~json_initpointers proc~json_writenmlintegers JSON_writeNMLintegers proc~jsonwriteecppatternnamelist->proc~json_writenmlintegers json_failed json_failed proc~json_failtest->json_failed json_print_error_message json_print_error_message proc~json_failtest->json_print_error_message proc~json_cleanuppointers->proc~json_failtest emsoft_tonativepath emsoft_tonativepath proc~json_cleanuppointers->emsoft_tonativepath json_destroy json_destroy proc~json_cleanuppointers->json_destroy json_print json_print proc~json_cleanuppointers->json_print proc~json_initpointers->json_add proc~json_initpointers->proc~json_failtest json_initialize json_initialize proc~json_initpointers->json_initialize json_create_object json_create_object proc~json_initpointers->json_create_object proc~json_writenmlintegers->json_add proc~json_writenmlintegers->proc~json_failtest var panprocjsonwriteecppatternnamelistCallsGraph = svgPanZoom('#procjsonwriteecppatternnamelistCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONwriteECPpatternNameList Source Code recursive subroutine JSONwriteECPpatternNameList ( ecpnl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwriteECPpatternNameList use ISO_C_BINDING IMPLICIT NONE type ( ECPpatternNameListType ), INTENT ( INOUT ) :: ecpnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 2 , n_real = 6 integer ( kind = irg ) :: io_int ( n_int ) real ( kind = sgl ) :: io_real ( n_real ) character ( 20 ) :: intlist ( n_int ), reallist ( n_real ) character ( fnlen ) :: dataset , namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'ECPvars' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! write all the single integers io_int = ( / ecpnl % stdout , ecpnl % npix / ) intlist ( 1 ) = 'stdout' intlist ( 2 ) = 'npix' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) ! single real dataset = 'thetac' call json_add ( inp , dataset , dble ( ecpnl % thetac )); call JSON_failtest ( error_cnt ) ! real vector dataset = 'k' call json_add ( inp , dataset , dble ( ecpnl % k )); call JSON_failtest ( error_cnt ) ! write all the strings dataset = 'outname' call json_add ( inp , dataset , ecpnl % outname ); call JSON_failtest ( error_cnt ) dataset = 'masterfile' call json_add ( inp , dataset , ecpnl % masterfile ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwriteECPpatternNameList","tags":"","loc":"proc/jsonwriteecppatternnamelist.html","title":"JSONwriteECPpatternNameList – Fortran Program"},{"text":"public recursive subroutine JSONwritePEDkinNameList(pednl, jsonname, error_cnt) Uses: iso_c_binding proc~~jsonwritepedkinnamelist~~UsesGraph proc~jsonwritepedkinnamelist JSONwritePEDkinNameList iso_c_binding iso_c_binding iso_c_binding->proc~jsonwritepedkinnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief write namelist to JSON file\n @param pednl PED name list structure\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/12/15 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(PEDkinNameListType), intent(inout) :: pednl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt Calls proc~~jsonwritepedkinnamelist~~CallsGraph proc~jsonwritepedkinnamelist JSONwritePEDkinNameList proc~json_initpointers JSON_initpointers proc~jsonwritepedkinnamelist->proc~json_initpointers proc~json_writenmlintegers JSON_writeNMLintegers proc~jsonwritepedkinnamelist->proc~json_writenmlintegers proc~json_cleanuppointers JSON_cleanuppointers proc~jsonwritepedkinnamelist->proc~json_cleanuppointers proc~json_failtest JSON_failtest proc~jsonwritepedkinnamelist->proc~json_failtest proc~json_writenmlreals JSON_writeNMLreals proc~jsonwritepedkinnamelist->proc~json_writenmlreals json_add json_add proc~jsonwritepedkinnamelist->json_add proc~json_initpointers->proc~json_failtest proc~json_initpointers->json_add json_initialize json_initialize proc~json_initpointers->json_initialize json_create_object json_create_object proc~json_initpointers->json_create_object proc~json_writenmlintegers->proc~json_failtest proc~json_writenmlintegers->json_add proc~json_cleanuppointers->proc~json_failtest emsoft_tonativepath emsoft_tonativepath proc~json_cleanuppointers->emsoft_tonativepath json_destroy json_destroy proc~json_cleanuppointers->json_destroy json_print json_print proc~json_cleanuppointers->json_print json_failed json_failed proc~json_failtest->json_failed json_print_error_message json_print_error_message proc~json_failtest->json_print_error_message proc~json_writenmlreals->proc~json_failtest proc~json_writenmlreals->json_add Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONwritePEDkinNameList Source Code recursive subroutine JSONwritePEDkinNameList ( pednl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwritePEDkinNameList use ISO_C_BINDING IMPLICIT NONE type ( PEDkinNameListType ), INTENT ( INOUT ) :: pednl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 4 , n_real = 4 integer ( kind = irg ) :: io_int ( n_int ) real ( kind = sgl ) :: io_real ( n_real ) character ( 20 ) :: intlist ( n_int ), reallist ( n_real ) character ( fnlen ) :: dataset , namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'PEDkinNameList' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! write all the single integers io_int = ( / pednl % stdout , pednl % npix , pednl % ncubochoric , pednl % nthreads / ) intlist ( 1 ) = 'stdout' intlist ( 2 ) = 'npix' intlist ( 3 ) = 'ncubochoric' intlist ( 4 ) = 'nthreads' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) ! write all the single reals io_real = ( / pednl % voltage , pednl % thickness , pednl % dmin , pednl % rnmpp / ) reallist ( 1 ) = 'voltage' reallist ( 2 ) = 'thickness' reallist ( 3 ) = 'dmin' reallist ( 4 ) = 'rnmpp' call JSON_writeNMLreals ( inp , io_real , reallist , n_real , error_cnt ) ! write all the strings dataset = 'outname' call json_add ( inp , dataset , pednl % outname ); call JSON_failtest ( error_cnt ) dataset = 'xtalname' call json_add ( inp , dataset , pednl % xtalname ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwritePEDkinNameList","tags":"","loc":"proc/jsonwritepedkinnamelist.html","title":"JSONwritePEDkinNameList – Fortran Program"},{"text":"public recursive subroutine JSONwritePEDZANameList(pednl, jsonname, error_cnt) Uses: iso_c_binding proc~~jsonwritepedzanamelist~~UsesGraph proc~jsonwritepedzanamelist JSONwritePEDZANameList iso_c_binding iso_c_binding iso_c_binding->proc~jsonwritepedzanamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief write namelist to JSON file\n @param pednl PED name list structure\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/12/15 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(PEDZANameListType), intent(inout) :: pednl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt Calls proc~~jsonwritepedzanamelist~~CallsGraph proc~jsonwritepedzanamelist JSONwritePEDZANameList proc~json_initpointers JSON_initpointers proc~jsonwritepedzanamelist->proc~json_initpointers proc~json_writenmlintegers JSON_writeNMLintegers proc~jsonwritepedzanamelist->proc~json_writenmlintegers proc~json_cleanuppointers JSON_cleanuppointers proc~jsonwritepedzanamelist->proc~json_cleanuppointers proc~json_writenmlreals JSON_writeNMLreals proc~jsonwritepedzanamelist->proc~json_writenmlreals proc~json_failtest JSON_failtest proc~jsonwritepedzanamelist->proc~json_failtest json_add json_add proc~jsonwritepedzanamelist->json_add proc~json_initpointers->proc~json_failtest proc~json_initpointers->json_add json_initialize json_initialize proc~json_initpointers->json_initialize json_create_object json_create_object proc~json_initpointers->json_create_object proc~json_writenmlintegers->proc~json_failtest proc~json_writenmlintegers->json_add proc~json_cleanuppointers->proc~json_failtest emsoft_tonativepath emsoft_tonativepath proc~json_cleanuppointers->emsoft_tonativepath json_destroy json_destroy proc~json_cleanuppointers->json_destroy json_print json_print proc~json_cleanuppointers->json_print proc~json_writenmlreals->proc~json_failtest proc~json_writenmlreals->json_add json_failed json_failed proc~json_failtest->json_failed json_print_error_message json_print_error_message proc~json_failtest->json_print_error_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONwritePEDZANameList Source Code recursive subroutine JSONwritePEDZANameList ( pednl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwritePEDZANameList use ISO_C_BINDING IMPLICIT NONE type ( PEDZANameListType ), INTENT ( INOUT ) :: pednl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 5 , n_real = 6 integer ( kind = irg ) :: io_int ( n_int ) real ( kind = sgl ) :: io_real ( n_real ) character ( 20 ) :: intlist ( n_int ), reallist ( n_real ) character ( fnlen ) :: dataset , namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'EMPEDZA' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! write all the single integers io_int = ( / pednl % stdout , pednl % precsample , pednl % precazimuthal , pednl % npix , pednl % nthreads / ) intlist ( 1 ) = 'stdout' intlist ( 2 ) = 'precsample' intlist ( 3 ) = 'precazimuthal' intlist ( 4 ) = 'npix' intlist ( 5 ) = 'nthreads' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) ! vectors dataset = 'k' call json_add ( inp , dataset , pednl % k ); call JSON_failtest ( error_cnt ) dataset = 'fn' call json_add ( inp , dataset , pednl % fn ); call JSON_failtest ( error_cnt ) ! single reals io_real = ( / pednl % voltage , pednl % dmin , pednl % precangle , pednl % prechalfwidth , pednl % thickness , pednl % camlen / ) reallist ( 1 ) = 'voltage' reallist ( 2 ) = 'dmin' reallist ( 3 ) = 'precangle' reallist ( 4 ) = 'prechalfwidth' reallist ( 5 ) = 'thickness' reallist ( 6 ) = 'camlen' call JSON_writeNMLreals ( inp , io_real , reallist , n_real , error_cnt ) ! write all the strings dataset = 'outname' call json_add ( inp , dataset , pednl % outname ); call JSON_failtest ( error_cnt ) dataset = 'xtalname' call json_add ( inp , dataset , pednl % xtalname ); call JSON_failtest ( error_cnt ) dataset = 'filemode' call json_add ( inp , dataset , pednl % filemode ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwritePEDZANameList","tags":"","loc":"proc/jsonwritepedzanamelist.html","title":"JSONwritePEDZANameList – Fortran Program"},{"text":"public recursive subroutine JSONwriteECCINameList(eccinl, jsonname, error_cnt) Uses: iso_c_binding proc~~jsonwriteeccinamelist~~UsesGraph proc~jsonwriteeccinamelist JSONwriteECCINameList iso_c_binding iso_c_binding iso_c_binding->proc~jsonwriteeccinamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief write namelist to JSON file\n @param eccinl ECCI name list structure\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/12/15 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(ECCINameListType), intent(inout) :: eccinl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt Calls proc~~jsonwriteeccinamelist~~CallsGraph proc~jsonwriteeccinamelist JSONwriteECCINameList proc~json_initpointers JSON_initpointers proc~jsonwriteeccinamelist->proc~json_initpointers proc~json_writenmlintegers JSON_writeNMLintegers proc~jsonwriteeccinamelist->proc~json_writenmlintegers proc~json_cleanuppointers JSON_cleanuppointers proc~jsonwriteeccinamelist->proc~json_cleanuppointers proc~json_writenmlreals JSON_writeNMLreals proc~jsonwriteeccinamelist->proc~json_writenmlreals proc~json_failtest JSON_failtest proc~jsonwriteeccinamelist->proc~json_failtest json_add json_add proc~jsonwriteeccinamelist->json_add proc~json_initpointers->proc~json_failtest proc~json_initpointers->json_add json_initialize json_initialize proc~json_initpointers->json_initialize json_create_object json_create_object proc~json_initpointers->json_create_object proc~json_writenmlintegers->proc~json_failtest proc~json_writenmlintegers->json_add proc~json_cleanuppointers->proc~json_failtest emsoft_tonativepath emsoft_tonativepath proc~json_cleanuppointers->emsoft_tonativepath json_destroy json_destroy proc~json_cleanuppointers->json_destroy json_print json_print proc~json_cleanuppointers->json_print proc~json_writenmlreals->proc~json_failtest proc~json_writenmlreals->json_add json_failed json_failed proc~json_failtest->json_failed json_print_error_message json_print_error_message proc~json_failtest->json_print_error_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONwriteECCINameList Source Code recursive subroutine JSONwriteECCINameList ( eccinl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwriteECCINameList use ISO_C_BINDING IMPLICIT NONE type ( ECCINameListType ), INTENT ( INOUT ) :: eccinl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 5 , n_real = 6 integer ( kind = irg ) :: io_int ( n_int ) real ( kind = sgl ) :: io_real ( n_real ) character ( 20 ) :: intlist ( n_int ), reallist ( n_real ) integer ( kind = irg ) :: i character ( fnlen ) :: dataset , namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'ECCIlist' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! write all the single integers io_int = ( / eccinl % stdout , eccinl % nthreads , eccinl % nktstep , eccinl % DF_npix , eccinl % DF_npiy / ) intlist ( 1 ) = 'stdout' intlist ( 2 ) = 'nthreads' intlist ( 3 ) = 'nktstep' intlist ( 4 ) = 'DF_npix' intlist ( 5 ) = 'DF_npiy' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) ! vectors dataset = 'k' call json_add ( inp , dataset , eccinl % k ); call JSON_failtest ( error_cnt ) ! single reals io_real = ( / eccinl % voltage , eccinl % dkt , eccinl % ktmax , eccinl % dmin , eccinl % DF_L , eccinl % DF_slice / ) reallist ( 1 ) = 'voltage' reallist ( 2 ) = 'dkt' reallist ( 3 ) = 'ktmax' reallist ( 4 ) = 'dmin' reallist ( 5 ) = 'DF_L' reallist ( 6 ) = 'DF_slice' call JSON_writeNMLreals ( inp , io_real , reallist , n_real , error_cnt ) ! 2-vectors dataset = 'lauec' call json_add ( inp , dataset , dble ( eccinl % lauec )); call JSON_failtest ( error_cnt ) dataset = 'lauec2' call json_add ( inp , dataset , dble ( eccinl % lauec2 )); call JSON_failtest ( error_cnt ) ! write all the strings dataset = 'dispmode' call json_add ( inp , dataset , eccinl % dispmode ); call JSON_failtest ( error_cnt ) dataset = 'summode' call json_add ( inp , dataset , eccinl % summode ); call JSON_failtest ( error_cnt ) dataset = 'progmode' call json_add ( inp , dataset , eccinl % progmode ); call JSON_failtest ( error_cnt ) dataset = 'xtalname' call json_add ( inp , dataset , eccinl % xtalname ); call JSON_failtest ( error_cnt ) dataset = 'defectfilename' call json_add ( inp , dataset , eccinl % defectfilename ); call JSON_failtest ( error_cnt ) dataset = 'dispfile' call json_add ( inp , dataset , eccinl % dispfile ); call JSON_failtest ( error_cnt ) dataset = 'dataname' call json_add ( inp , dataset , eccinl % dataname ); call JSON_failtest ( error_cnt ) dataset = 'ECPname' call json_add ( inp , dataset , eccinl % ECPname ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwriteECCINameList","tags":"","loc":"proc/jsonwriteeccinamelist.html","title":"JSONwriteECCINameList – Fortran Program"},{"text":"public recursive subroutine JSONwriteRFZNameList(rfznl, jsonname, error_cnt) Uses: iso_c_binding proc~~jsonwriterfznamelist~~UsesGraph proc~jsonwriterfznamelist JSONwriteRFZNameList iso_c_binding iso_c_binding iso_c_binding->proc~jsonwriterfznamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief write namelist to an JSON file\n @param rfznl RFZ name list structure\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/12/15 MDG 1.0 new routine\n @date 08/18/15 MDG 1.1 added other rotation representations Arguments Type Intent Optional Attributes Name type(RFZNameListType), intent(inout) :: rfznl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt Calls proc~~jsonwriterfznamelist~~CallsGraph proc~jsonwriterfznamelist JSONwriteRFZNameList json_add json_add proc~jsonwriterfznamelist->json_add proc~json_failtest JSON_failtest proc~jsonwriterfznamelist->proc~json_failtest proc~json_cleanuppointers JSON_cleanuppointers proc~jsonwriterfznamelist->proc~json_cleanuppointers proc~json_initpointers JSON_initpointers proc~jsonwriterfznamelist->proc~json_initpointers proc~json_writenmlintegers JSON_writeNMLintegers proc~jsonwriterfznamelist->proc~json_writenmlintegers json_failed json_failed proc~json_failtest->json_failed json_print_error_message json_print_error_message proc~json_failtest->json_print_error_message proc~json_cleanuppointers->proc~json_failtest emsoft_tonativepath emsoft_tonativepath proc~json_cleanuppointers->emsoft_tonativepath json_destroy json_destroy proc~json_cleanuppointers->json_destroy json_print json_print proc~json_cleanuppointers->json_print proc~json_initpointers->json_add proc~json_initpointers->proc~json_failtest json_initialize json_initialize proc~json_initpointers->json_initialize json_create_object json_create_object proc~json_initpointers->json_create_object proc~json_writenmlintegers->json_add proc~json_writenmlintegers->proc~json_failtest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONwriteRFZNameList Source Code recursive subroutine JSONwriteRFZNameList ( rfznl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwriteRFZNameList use ISO_C_BINDING IMPLICIT NONE type ( RFZNameListType ), INTENT ( INOUT ) :: rfznl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 3 , n_real = 1 integer ( kind = irg ) :: io_int ( n_int ) real ( kind = sgl ) :: io_real ( n_real ) character ( 20 ) :: intlist ( n_int ), reallist ( n_real ) integer ( kind = irg ) :: i character ( fnlen ) :: dataset , namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'RFZlist' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! write all the single integers io_int = ( / rfznl % pgnum , rfznl % nsteps , rfznl % gridtype / ) intlist ( 1 ) = 'pgnum' intlist ( 2 ) = 'nsteps' intlist ( 3 ) = 'gridtype' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) ! strings dataset = 'euoutname' call json_add ( inp , dataset , rfznl % euoutname ); call JSON_failtest ( error_cnt ) dataset = 'cuoutname' call json_add ( inp , dataset , rfznl % cuoutname ); call JSON_failtest ( error_cnt ) dataset = 'hooutname' call json_add ( inp , dataset , rfznl % hooutname ); call JSON_failtest ( error_cnt ) dataset = 'quoutname' call json_add ( inp , dataset , rfznl % quoutname ); call JSON_failtest ( error_cnt ) dataset = 'rooutname' call json_add ( inp , dataset , rfznl % rooutname ); call JSON_failtest ( error_cnt ) dataset = 'omoutname' call json_add ( inp , dataset , rfznl % omoutname ); call JSON_failtest ( error_cnt ) dataset = 'axoutname' call json_add ( inp , dataset , rfznl % axoutname ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwriteRFZNameList","tags":"","loc":"proc/jsonwriterfznamelist.html","title":"JSONwriteRFZNameList – Fortran Program"},{"text":"public recursive subroutine JSONwriteDictIndxOpenCLNameList(dictindxnl, jsonname, error_cnt) Uses: iso_c_binding local proc~~jsonwritedictindxopenclnamelist~~UsesGraph proc~jsonwritedictindxopenclnamelist JSONwriteDictIndxOpenCLNameList iso_c_binding iso_c_binding iso_c_binding->proc~jsonwritedictindxopenclnamelist local local local->proc~jsonwritedictindxopenclnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief write namelist to JSON file\n @param rfznl RFZ name list structure\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/12/15 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(DictIndxOpenCLListType), intent(inout) :: dictindxnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt Calls proc~~jsonwritedictindxopenclnamelist~~CallsGraph proc~jsonwritedictindxopenclnamelist JSONwriteDictIndxOpenCLNameList json_add json_add proc~jsonwritedictindxopenclnamelist->json_add proc~json_failtest JSON_failtest proc~jsonwritedictindxopenclnamelist->proc~json_failtest proc~json_cleanuppointers JSON_cleanuppointers proc~jsonwritedictindxopenclnamelist->proc~json_cleanuppointers proc~json_initpointers JSON_initpointers proc~jsonwritedictindxopenclnamelist->proc~json_initpointers proc~json_writenmlintegers JSON_writeNMLintegers proc~jsonwritedictindxopenclnamelist->proc~json_writenmlintegers json_failed json_failed proc~json_failtest->json_failed json_print_error_message json_print_error_message proc~json_failtest->json_print_error_message proc~json_cleanuppointers->proc~json_failtest emsoft_tonativepath emsoft_tonativepath proc~json_cleanuppointers->emsoft_tonativepath json_destroy json_destroy proc~json_cleanuppointers->json_destroy json_print json_print proc~json_cleanuppointers->json_print proc~json_initpointers->json_add proc~json_initpointers->proc~json_failtest json_initialize json_initialize proc~json_initpointers->json_initialize json_create_object json_create_object proc~json_initpointers->json_create_object proc~json_writenmlintegers->json_add proc~json_writenmlintegers->proc~json_failtest var panprocjsonwritedictindxopenclnamelistCallsGraph = svgPanZoom('#procjsonwritedictindxopenclnamelistCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONwriteDictIndxOpenCLNameList Source Code recursive subroutine JSONwriteDictIndxOpenCLNameList ( dictindxnl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONwriteDictIndxOpenCLNameList use ISO_C_BINDING use local IMPLICIT NONE type ( DictIndxOpenCLListType ), INTENT ( INOUT ) :: dictindxnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_value ), pointer :: p , inp integer ( kind = irg ), parameter :: n_int = 7 , n_real = 1 integer ( kind = irg ) :: io_int ( n_int ) real ( kind = sgl ) :: io_real ( n_real ) character ( 20 ) :: intlist ( n_int ), reallist ( n_real ) integer ( kind = irg ) :: i character ( fnlen ) :: dataset , namelistname character ( fnlen , kind = c_char ) :: line2 ( 1 ) ! initialize the json state variables namelistname = 'DictIndxOpenCLvars' call JSON_initpointers ( p , inp , jsonname , namelistname , error_cnt ) ! write all the single integers io_int = ( / dictindxnl % numexptsingle , dictindxnl % numdictsingle , dictindxnl % totnumdict , dictindxnl % totnumexpt , dictindxnl % imght , & dictindxnl % imgwd , dictindxnl % nnk / ) intlist ( 1 ) = 'numexptsingle' intlist ( 2 ) = 'numdictsingle' intlist ( 3 ) = 'totnumdict' intlist ( 4 ) = 'totnumexpt' intlist ( 5 ) = 'imght' intlist ( 6 ) = 'imgwd' intlist ( 7 ) = 'nnk' call JSON_writeNMLintegers ( inp , io_int , intlist , n_int , error_cnt ) dataset = 'MeanSubtraction' call json_add ( inp , dataset , dictindxnl % MeanSubtraction ); call JSON_failtest ( error_cnt ) ! strings dataset = 'exptfile' call json_add ( inp , dataset , dictindxnl % exptfile ); call JSON_failtest ( error_cnt ) dataset = 'dictfile' call json_add ( inp , dataset , dictindxnl % dictfile ); call JSON_failtest ( error_cnt ) dataset = 'eulerfile' call json_add ( inp , dataset , dictindxnl % eulerfile ); call JSON_failtest ( error_cnt ) ! and then we write the file and clean up call JSON_cleanuppointers ( p , inp , jsonname , error_cnt ) end subroutine JSONwriteDictIndxOpenCLNameList","tags":"","loc":"proc/jsonwritedictindxopenclnamelist.html","title":"JSONwriteDictIndxOpenCLNameList – Fortran Program"},{"text":"public recursive subroutine JSONreadInteger(json, ep, ival, dval) Uses: iso_c_binding io proc~~jsonreadinteger~~UsesGraph proc~jsonreadinteger JSONreadInteger iso_c_binding iso_c_binding iso_c_binding->proc~jsonreadinteger io io io->proc~jsonreadinteger Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read integer from json file into namelist structure (with auto missing detection)\n @param json structure\n @param ep entry path string\n @param ival integer variable\n @param dval integer variable (default value)\n @date 08/12/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(json_file), intent(inout) :: json character(len=fnlen), intent(in) :: ep integer(kind=irg), intent(inout) :: ival integer(kind=irg), intent(in) :: dval Called By proc~~jsonreadinteger~~CalledByGraph proc~jsonreadinteger JSONreadInteger proc~jsonreadebsdclusternamelist JSONreadEBSDclusterNameList proc~jsonreadebsdclusternamelist->proc~jsonreadinteger proc~jsonreadebsdmasternamelist JSONreadEBSDMasterNameList proc~jsonreadebsdmasternamelist->proc~jsonreadinteger proc~jsonreadmcclmultilayernamelist JSONreadMCCLMultiLayerNameList proc~jsonreadmcclmultilayernamelist->proc~jsonreadinteger proc~jsonreadkosselnamelist JSONreadKosselNameList proc~jsonreadkosselnamelist->proc~jsonreadinteger proc~jsonreadkosselmasternamelist JSONreadKosselMasterNameList proc~jsonreadkosselmasternamelist->proc~jsonreadinteger proc~jsonreadebsdnamelist JSONreadEBSDNameList proc~jsonreadebsdnamelist->proc~jsonreadinteger proc~jsonreadreflectornamelist JSONreadreflectorNameList proc~jsonreadreflectornamelist->proc~jsonreadinteger proc~jsonreadebsdoverlapnamelist JSONreadEBSDoverlapNameList proc~jsonreadebsdoverlapnamelist->proc~jsonreadinteger proc~jsonreadecpmasternamelist JSONreadECPMasterNameList proc~jsonreadecpmasternamelist->proc~jsonreadinteger proc~jsonreadmcnamelist JSONreadMCNameList proc~jsonreadmcnamelist->proc~jsonreadinteger proc~jsonreadmcclnamelist JSONreadMCCLNameList proc~jsonreadmcclnamelist->proc~jsonreadinteger Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONreadInteger Source Code recursive subroutine JSONreadInteger ( json , ep , ival , dval ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadInteger use ISO_C_BINDING use io IMPLICIT NONE type ( json_file ), INTENT ( INOUT ) :: json character ( fnlen ), INTENT ( IN ) :: ep integer ( kind = irg ), INTENT ( INOUT ) :: ival integer ( kind = irg ), INTENT ( IN ) :: dval logical :: found ! if we find the field 'ep' in the file, then we read its corresponding value ! if it is not there, then we return the dval default value call json % get ( ep , ival , found ) if (. not . found ) then write ( error_unit , '(A)' ) 'WARNING: field ' // trim ( ep ) // ' not found in json file; using default value from namelist template' ival = dval end if end subroutine JSONreadInteger","tags":"","loc":"proc/jsonreadinteger.html","title":"JSONreadInteger – Fortran Program"},{"text":"public recursive subroutine JSONreadIntegerVec(json, ep, ivec, dvec, n) Uses: iso_c_binding io proc~~jsonreadintegervec~~UsesGraph proc~jsonreadintegervec JSONreadIntegerVec iso_c_binding iso_c_binding iso_c_binding->proc~jsonreadintegervec io io io->proc~jsonreadintegervec Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read integer vector from json file into namelist structure (with auto missing detection)\n @param json structure\n @param ep entry path string\n @param ival integer vector variable\n @param dval integer vector variable (default value)\n @date 08/12/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(json_file), intent(inout) :: json character(len=fnlen), intent(in) :: ep integer(kind=irg), intent(inout) :: ivec (n) integer(kind=irg), intent(in) :: dvec (n) integer(kind=irg), intent(in) :: n Called By proc~~jsonreadintegervec~~CalledByGraph proc~jsonreadintegervec JSONreadIntegerVec proc~jsonreadebsdoverlapnamelist JSONreadEBSDoverlapNameList proc~jsonreadebsdoverlapnamelist->proc~jsonreadintegervec proc~jsonreadkosselnamelist JSONreadKosselNameList proc~jsonreadkosselnamelist->proc~jsonreadintegervec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONreadIntegerVec Source Code recursive subroutine JSONreadIntegerVec ( json , ep , ivec , dvec , n ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadIntegerVec use ISO_C_BINDING use io IMPLICIT NONE type ( json_file ), INTENT ( INOUT ) :: json character ( fnlen ), INTENT ( IN ) :: ep integer ( kind = irg ), INTENT ( INOUT ) :: ivec ( n ) integer ( kind = irg ), INTENT ( IN ) :: dvec ( n ) integer ( kind = irg ), INTENT ( IN ) :: n logical :: found integer ( kind = irg ), dimension (:), allocatable :: rv ! if we find the field 'ep' in the file, then we read its corresponding value ! if it is not there, then we return the dval default value call json % get ( ep , rv , found ) if (. not . found ) then write ( error_unit , '(A)' ) 'WARNING: field ' // trim ( ep ) // ' not found in json file; using default value from namelist template' ivec = dvec else ivec = rv end if end subroutine JSONreadIntegerVec","tags":"","loc":"proc/jsonreadintegervec.html","title":"JSONreadIntegerVec – Fortran Program"},{"text":"public recursive subroutine JSONreadReal(json, ep, rval, dval) Uses: iso_c_binding io proc~~jsonreadreal~~UsesGraph proc~jsonreadreal JSONreadReal iso_c_binding iso_c_binding iso_c_binding->proc~jsonreadreal io io io->proc~jsonreadreal Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read single precision real from json file into namelist structure (with auto missing detection)\n @param json structure\n @param ep entry path string\n @param rval real variable\n @param dval real variable (default value)\n @date 08/12/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(json_file), intent(inout) :: json character(len=fnlen), intent(in) :: ep real(kind=sgl), intent(inout) :: rval real(kind=sgl), intent(in) :: dval Calls proc~~jsonreadreal~~CallsGraph proc~jsonreadreal JSONreadReal sngl sngl proc~jsonreadreal->sngl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~jsonreadreal~~CalledByGraph proc~jsonreadreal JSONreadReal proc~jsonreadebsdoverlapnamelist JSONreadEBSDoverlapNameList proc~jsonreadebsdoverlapnamelist->proc~jsonreadreal proc~jsonreadkosselnamelist JSONreadKosselNameList proc~jsonreadkosselnamelist->proc~jsonreadreal proc~jsonreadkosselmasternamelist JSONreadKosselMasterNameList proc~jsonreadkosselmasternamelist->proc~jsonreadreal proc~jsonreadebsdnamelist JSONreadEBSDNameList proc~jsonreadebsdnamelist->proc~jsonreadreal proc~jsonreadreflectornamelist JSONreadreflectorNameList proc~jsonreadreflectornamelist->proc~jsonreadreal proc~jsonreadecpmasternamelist JSONreadECPMasterNameList proc~jsonreadecpmasternamelist->proc~jsonreadreal proc~jsonreadebsdmasternamelist JSONreadEBSDMasterNameList proc~jsonreadebsdmasternamelist->proc~jsonreadreal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONreadReal Source Code recursive subroutine JSONreadReal ( json , ep , rval , dval ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadReal use ISO_C_BINDING use io IMPLICIT NONE type ( json_file ), INTENT ( INOUT ) :: json character ( fnlen ), INTENT ( IN ) :: ep real ( kind = sgl ), INTENT ( INOUT ) :: rval real ( kind = sgl ), INTENT ( IN ) :: dval logical :: found real ( kind = dbl ) :: rv ! if we find the field 'ep' in the file, then we read its corresponding value ! if it is not there, then we return the dval default value call json % get ( ep , rv , found ) if (. not . found ) then write ( error_unit , '(A)' ) 'WARNING: field ' // trim ( ep ) // ' not found in json file; using default value from namelist template' rval = dval else rval = sngl ( rv ) end if end subroutine JSONreadReal","tags":"","loc":"proc/jsonreadreal.html","title":"JSONreadReal – Fortran Program"},{"text":"public recursive subroutine JSONreadRealVec(json, ep, rvec, dvec, n) Uses: iso_c_binding io proc~~jsonreadrealvec~~UsesGraph proc~jsonreadrealvec JSONreadRealVec iso_c_binding iso_c_binding iso_c_binding->proc~jsonreadrealvec io io io->proc~jsonreadrealvec Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read single precision real vector from json file into namelist structure (with auto missing detection)\n @param json structure\n @param ep entry path string\n @param rval real vector variable\n @param dval real vector variable (default value)\n @date 08/12/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(json_file), intent(inout) :: json character(len=fnlen), intent(in) :: ep real(kind=sgl), intent(inout) :: rvec (n) real(kind=sgl), intent(in) :: dvec (n) integer(kind=irg), intent(in) :: n Calls proc~~jsonreadrealvec~~CallsGraph proc~jsonreadrealvec JSONreadRealVec sngl sngl proc~jsonreadrealvec->sngl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~jsonreadrealvec~~CalledByGraph proc~jsonreadrealvec JSONreadRealVec proc~jsonreadebsdnamelist JSONreadEBSDNameList proc~jsonreadebsdnamelist->proc~jsonreadrealvec proc~jsonreadebsdoverlapnamelist JSONreadEBSDoverlapNameList proc~jsonreadebsdoverlapnamelist->proc~jsonreadrealvec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONreadRealVec Source Code recursive subroutine JSONreadRealVec ( json , ep , rvec , dvec , n ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadRealVec use ISO_C_BINDING use io IMPLICIT NONE type ( json_file ), INTENT ( INOUT ) :: json character ( fnlen ), INTENT ( IN ) :: ep real ( kind = sgl ), INTENT ( INOUT ) :: rvec ( n ) real ( kind = sgl ), INTENT ( IN ) :: dvec ( n ) integer ( kind = irg ), INTENT ( IN ) :: n logical :: found real ( kind = dbl ), dimension (:), allocatable :: rv ! if we find the field 'ep' in the file, then we read its corresponding value ! if it is not there, then we return the dvec default value call json % get ( ep , rv , found ) if (. not . found ) then write ( error_unit , '(A)' ) 'WARNING: field ' // trim ( ep ) // ' not found in json file; using default value from namelist template' rvec = dvec else rvec = sngl ( rv ) end if end subroutine JSONreadRealVec","tags":"","loc":"proc/jsonreadrealvec.html","title":"JSONreadRealVec – Fortran Program"},{"text":"public recursive subroutine JSONreadDouble(json, ep, rval, dval) Uses: iso_c_binding io proc~~jsonreaddouble~~UsesGraph proc~jsonreaddouble JSONreadDouble iso_c_binding iso_c_binding iso_c_binding->proc~jsonreaddouble io io io->proc~jsonreaddouble Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read double precision real from json file into namelist structure (with auto missing detection)\n @param json structure\n @param ep entry path string\n @param rval real variable\n @param dval real variable (default value)\n @date 08/12/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(json_file), intent(inout) :: json character(len=fnlen), intent(in) :: ep real(kind=dbl), intent(inout) :: rval real(kind=dbl), intent(in) :: dval Called By proc~~jsonreaddouble~~CalledByGraph proc~jsonreaddouble JSONreadDouble proc~jsonreadmcclmultilayernamelist JSONreadMCCLMultiLayerNameList proc~jsonreadmcclmultilayernamelist->proc~jsonreaddouble proc~jsonreadebsdnamelist JSONreadEBSDNameList proc~jsonreadebsdnamelist->proc~jsonreaddouble proc~jsonreadmcnamelist JSONreadMCNameList proc~jsonreadmcnamelist->proc~jsonreaddouble proc~jsonreadmcclnamelist JSONreadMCCLNameList proc~jsonreadmcclnamelist->proc~jsonreaddouble Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONreadDouble Source Code recursive subroutine JSONreadDouble ( json , ep , rval , dval ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadDouble use ISO_C_BINDING use io IMPLICIT NONE type ( json_file ), INTENT ( INOUT ) :: json character ( fnlen ), INTENT ( IN ) :: ep real ( kind = dbl ), INTENT ( INOUT ) :: rval real ( kind = dbl ), INTENT ( IN ) :: dval logical :: found real ( kind = dbl ) :: rv ! if we find the field 'ep' in the file, then we read its corresponding value ! if it is not there, then we return the dval default value call json % get ( ep , rv , found ) if (. not . found ) then write ( error_unit , '(A)' ) 'WARNING: field ' // trim ( ep ) // ' not found in json file; using default value from namelist template' rval = dval else rval = rv end if end subroutine JSONreadDouble","tags":"","loc":"proc/jsonreaddouble.html","title":"JSONreadDouble – Fortran Program"},{"text":"public recursive subroutine JSONreadDoubleVec(json, ep, rvec, dvec, n) Uses: iso_c_binding io proc~~jsonreaddoublevec~~UsesGraph proc~jsonreaddoublevec JSONreadDoubleVec iso_c_binding iso_c_binding iso_c_binding->proc~jsonreaddoublevec io io io->proc~jsonreaddoublevec Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read double precision real vector from json file into namelist structure (with auto missing detection)\n @param json structure\n @param ep entry path string\n @param rval real vector variable\n @param dval real vector variable (default value)\n @date 08/12/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(json_file), intent(inout) :: json character(len=fnlen), intent(in) :: ep real(kind=dbl), intent(inout) :: rvec (n) real(kind=dbl), intent(in) :: dvec (n) integer(kind=irg), intent(in) :: n Source Code JSONreadDoubleVec Source Code recursive subroutine JSONreadDoubleVec ( json , ep , rvec , dvec , n ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadDoubleVec use ISO_C_BINDING use io IMPLICIT NONE type ( json_file ), INTENT ( INOUT ) :: json character ( fnlen ), INTENT ( IN ) :: ep real ( kind = dbl ), INTENT ( INOUT ) :: rvec ( n ) real ( kind = dbl ), INTENT ( IN ) :: dvec ( n ) integer ( kind = irg ), INTENT ( IN ) :: n logical :: found real ( kind = dbl ), dimension (:), allocatable :: rv ! if we find the field 'ep' in the file, then we read its corresponding value ! if it is not there, then we return the dvec default value call json % get ( ep , rv , found ) if (. not . found ) then write ( error_unit , '(A)' ) 'WARNING: field ' // trim ( ep ) // ' not found in json file; using default value from namelist template' rvec = dvec else rvec = rv end if end subroutine JSONreadDoubleVec","tags":"","loc":"proc/jsonreaddoublevec.html","title":"JSONreadDoubleVec – Fortran Program"},{"text":"public recursive subroutine JSONreadString(json, ep, sval, dval) Uses: iso_c_binding io proc~~jsonreadstring~~UsesGraph proc~jsonreadstring JSONreadString iso_c_binding iso_c_binding iso_c_binding->proc~jsonreadstring io io io->proc~jsonreadstring Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read string from json file into namelist structure (with auto missing detection)\n @param json structure\n @param ep entry path string\n @param sval string\n @param dval string (default value)\n @date 08/12/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(json_file), intent(inout) :: json character(len=fnlen), intent(in) :: ep character(len=fnlen), intent(inout) :: sval character(len=fnlen), intent(in) :: dval Called By proc~~jsonreadstring~~CalledByGraph proc~jsonreadstring JSONreadString proc~jsonreadebsdclusternamelist JSONreadEBSDclusterNameList proc~jsonreadebsdclusternamelist->proc~jsonreadstring proc~jsonreadebsdmasternamelist JSONreadEBSDMasterNameList proc~jsonreadebsdmasternamelist->proc~jsonreadstring proc~jsonreadmcclmultilayernamelist JSONreadMCCLMultiLayerNameList proc~jsonreadmcclmultilayernamelist->proc~jsonreadstring proc~jsonreadkosselnamelist JSONreadKosselNameList proc~jsonreadkosselnamelist->proc~jsonreadstring proc~jsonreadkosselmasternamelist JSONreadKosselMasterNameList proc~jsonreadkosselmasternamelist->proc~jsonreadstring proc~jsonreadebsdnamelist JSONreadEBSDNameList proc~jsonreadebsdnamelist->proc~jsonreadstring proc~jsonreadreflectornamelist JSONreadreflectorNameList proc~jsonreadreflectornamelist->proc~jsonreadstring proc~jsonreadebsdoverlapnamelist JSONreadEBSDoverlapNameList proc~jsonreadebsdoverlapnamelist->proc~jsonreadstring proc~jsonreadecpmasternamelist JSONreadECPMasterNameList proc~jsonreadecpmasternamelist->proc~jsonreadstring proc~jsonreadmcnamelist JSONreadMCNameList proc~jsonreadmcnamelist->proc~jsonreadstring proc~jsonreadmcclnamelist JSONreadMCCLNameList proc~jsonreadmcclnamelist->proc~jsonreadstring Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONreadString Source Code recursive subroutine JSONreadString ( json , ep , sval , dval ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadString use ISO_C_BINDING use io IMPLICIT NONE type ( json_file ), INTENT ( INOUT ) :: json character ( fnlen ), INTENT ( IN ) :: ep character ( fnlen ), INTENT ( INOUT ) :: sval character ( fnlen ), INTENT ( IN ) :: dval logical :: found character ( kind = jsonCK , len = :), allocatable :: cval ! if we find the field 'ep' in the file, then we read its corresponding value ! if it is not there, then we return the dval default value call json % get ( ep , cval , found ) if (. not . found ) then write ( error_unit , '(A)' ) 'WARNING: field ' // trim ( ep ) // ' not found in json file; using default value from namelist template' sval = dval else sval = trim ( cval ) end if end subroutine JSONreadString","tags":"","loc":"proc/jsonreadstring.html","title":"JSONreadString – Fortran Program"},{"text":"public recursive subroutine JSONreadLogical(json, ep, sval, dval) Uses: iso_c_binding io proc~~jsonreadlogical~~UsesGraph proc~jsonreadlogical JSONreadLogical iso_c_binding iso_c_binding iso_c_binding->proc~jsonreadlogical io io io->proc~jsonreadlogical Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read logical from json file into namelist structure (with auto missing detection)\n @param json structure\n @param ep entry path string\n @param sval logical \n @param dval logical (default value)\n @date 08/20/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(json_file), intent(inout) :: json character(len=fnlen), intent(in) :: ep logical, intent(inout) :: sval logical, intent(in) :: dval Called By proc~~jsonreadlogical~~CalledByGraph proc~jsonreadlogical JSONreadLogical proc~jsonreadebsdmasternamelist JSONreadEBSDMasterNameList proc~jsonreadebsdmasternamelist->proc~jsonreadlogical Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONreadLogical Source Code recursive subroutine JSONreadLogical ( json , ep , sval , dval ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadLogical use ISO_C_BINDING use io IMPLICIT NONE type ( json_file ), INTENT ( INOUT ) :: json character ( fnlen ), INTENT ( IN ) :: ep logical , INTENT ( INOUT ) :: sval logical , INTENT ( IN ) :: dval logical :: found , cval ! if we find the field 'ep' in the file, then we read its corresponding value ! if it is not there, then we return the dval default value call json % get ( ep , cval , found ) if (. not . found ) then write ( error_unit , '(A)' ) 'WARNING: field ' // trim ( ep ) // ' not found in json file; using default value from namelist template' sval = dval else sval = cval end if end subroutine JSONreadLogical","tags":"","loc":"proc/jsonreadlogical.html","title":"JSONreadLogical – Fortran Program"},{"text":"public recursive subroutine JSONreadFoilData(cell, defects, error_cnt, verbose) Uses: iso_c_binding NameListHandlers io error crystal iso_fortran_env proc~~jsonreadfoildata~~UsesGraph proc~jsonreadfoildata JSONreadFoilData error error error->proc~jsonreadfoildata iso_fortran_env iso_fortran_env iso_fortran_env->proc~jsonreadfoildata io io io->proc~jsonreadfoildata iso_c_binding iso_c_binding iso_c_binding->proc~jsonreadfoildata crystal crystal crystal->proc~jsonreadfoildata module~namelisthandlers NameListHandlers module~namelisthandlers->proc~jsonreadfoildata local local local->module~namelisthandlers module~namelisttypedefs NameListTypedefs local->module~namelisttypedefs module~namelisttypedefs->module~namelisthandlers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief parse json foil file into defect namelist structures\n @param cell unit cell pointer\n @param defects defect structure, to be filled by this routine\n @param error_cnt total number of errors encountered by json routines\n @param verbose [optional] print a lot of output if present and true\n @date 11/21/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(unitcell), intent(in), pointer :: cell type(defecttype), intent(inout) :: defects integer(kind=irg), intent(inout) :: error_cnt logical, intent(in), optional :: verbose Calls proc~~jsonreadfoildata~~CallsGraph proc~jsonreadfoildata JSONreadFoilData writevalue writevalue proc~jsonreadfoildata->writevalue emsoft_getemdatapathname emsoft_getemdatapathname proc~jsonreadfoildata->emsoft_getemdatapathname emsoft_tonativepath emsoft_tonativepath proc~jsonreadfoildata->emsoft_tonativepath json_print_error_message json_print_error_message proc~jsonreadfoildata->json_print_error_message json_get_child json_get_child proc~jsonreadfoildata->json_get_child calcdot calcdot proc~jsonreadfoildata->calcdot proc~jsongetdouble JSONgetDouble proc~jsonreadfoildata->proc~jsongetdouble json_failed json_failed proc~jsonreadfoildata->json_failed proc~jsongetdoublevector JSONgetDoubleVector proc~jsonreadfoildata->proc~jsongetdoublevector json_info json_info proc~jsonreadfoildata->json_info proc~json_failtest JSON_failtest proc~jsonreadfoildata->proc~json_failtest message message proc~jsonreadfoildata->message json_parse json_parse proc~jsonreadfoildata->json_parse proc~jsongetdouble->writevalue json_get json_get proc~jsongetdouble->json_get proc~jsongetdoublevector->writevalue proc~jsongetdoublevector->json_get proc~json_failtest->json_print_error_message proc~json_failtest->json_failed Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~jsonreadfoildata~~CalledByGraph proc~jsonreadfoildata JSONreadFoilData proc~jsonreaddefectfile JSONreadDefectFile proc~jsonreaddefectfile->proc~jsonreadfoildata proc~initializedefects InitializeDefects proc~initializedefects->proc~jsonreaddefectfile Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONreadFoilData Source Code recursive subroutine JSONreadFoilData ( cell , defects , error_cnt , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadFoilData use ISO_C_BINDING use NameListHandlers use io use error use crystal use , intrinsic :: iso_fortran_env , only : wp => real64 IMPLICIT NONE type ( unitcell ), pointer , INTENT ( IN ) :: cell type ( defecttype ), INTENT ( INOUT ) :: defects integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt logical , INTENT ( IN ), OPTIONAL :: verbose type ( json_value ), pointer :: jval , child , child2 , child3 type ( json_value ), pointer :: tmp_json_ptr character ( kind = jsonCK , len = :), allocatable :: name integer ( kind = irg ) :: v , i , j , jj , vart , nc , nc2 , nc3 , io_int ( 3 ) real ( kind = wp ), dimension (:), allocatable :: vec3 real ( kind = wp ) :: val real ( kind = sgl ) :: io_real ( 6 ), x logical :: found character ( 4 ), parameter :: row ( 6 ) = ( / 'row1' , 'row2' , 'row3' , 'row4' , 'row5' , 'row6' / ) character ( fnlen ) :: str , filename v = 0 if ( PRESENT ( verbose )) then if ( verbose ) then v = 1 end if end if ! set the default values for all entries defects % foil % elmo = 0.0 ! elastic moduli defects % foil % F = ( / 0.0 , 0.0 , 1.0 / ) ! foil normal in direct space Bravais reference frame defects % foil % q = ( / 1.0 , 0.0 , 0.0 / ) ! reciprocal space vector along primary tilt axis towards airlock defects % foil % alP = 0.0 ! primary tilt angle in degrees defects % foil % alS = 0.0 ! secondary tilt angle (for double tilt holder) defects % foil % alR = 0.0 ! secondary tilt angle (for rotation tilt holder) defects % foil % beP = 0.0 ! angle of primary tilt axis w.r.t. image bottom edge defects % foil % z0 = 10 0.0 ! foil thickness in nm ! the following are not used currently, but need to be initialized properly defects % foil % brx = 0.0 ! parameters to describe the foil shape as a quadratic surface defects % foil % bry = 0.0 defects % foil % brxy = 0.0 defects % foil % cpx = 0.0 ! center of the foil quadratic surface within [-1,1] range in pixel coordinates defects % foil % cpy = 0.0 filename = trim ( EMsoft_getEMdatapathname ()) // trim ( defects % foilname ) filename = EMsoft_toNativePath ( filename ) ! json has alrady been initialized, so we should be ok directly reading the data from the file call json_parse ( trim ( filename ), jval ) if ( json_failed (). eqv .. TRUE .) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else call json_info ( jval , vart , nc , name ) ! jval name = filename ! loop over the children (only 1) do i = 1 , nc call json_get_child ( jval , i , child ) call json_info ( child , vart , nc2 , name ) ! child name = FoilDescriptor nc2loop : do j = 1 , nc2 call json_get_child ( child , j , child2 ) call json_info ( child2 , vart , nc3 , name ) ! foil normal if ( name . eq . 'foilF' ) then str = '   Foil normal F = ' defects % foil % F = JSONgetDoubleVector ( child2 , nc3 , str , v ) end if ! foil q vector if ( name . eq . 'foilq' ) then str = '   Foil q-vector = ' defects % foil % q = JSONgetDoubleVector ( child2 , nc3 , str , v ) end if ! foil alP tilt if ( name . eq . 'foilalP' ) then str = '   Foil alP tilt = ' defects % foil % alP = JSONgetDouble ( child2 , str , v ) end if ! foil alS tilt if ( name . eq . 'foilalS' ) then str = '   Foil alS tilt = ' defects % foil % alS = JSONgetDouble ( child2 , str , v ) end if ! foil alR tilt if ( name . eq . 'foilalR' ) then str = '   Foil alR tilt = ' defects % foil % alR = JSONgetDouble ( child2 , str , v ) end if ! foil thickness if ( name . eq . 'foilz0' ) then str = '   Foil thickness = ' defects % foil % z0 = JSONgetDouble ( child2 , str , v ) end if ! foil shape parameters if ( name . eq . 'brx' ) then str = '   shape brx = ' defects % foil % brx = JSONgetDouble ( child2 , str , v ) end if ! foil shape parameters if ( name . eq . 'bry' ) then str = '   shape bry = ' defects % foil % bry = JSONgetDouble ( child2 , str , v ) end if ! foil shape parameters if ( name . eq . 'brxy' ) then str = '   shape brxy = ' defects % foil % brxy = JSONgetDouble ( child2 , str , v ) end if ! foil shape parameters if ( name . eq . 'cpx' ) then str = '   shape cpx = ' defects % foil % cpx = JSONgetDouble ( child2 , str , v ) end if ! foil shape parameters if ( name . eq . 'cpy' ) then str = '   shape cpy = ' defects % foil % cpy = JSONgetDouble ( child2 , str , v ) end if ! foil elastic modulus tensor  (6x6 format) if ( name . eq . 'foilelmo' ) then str = '' do jj = 1 , 6 call json_get_child ( child2 , jj , child3 ) call json_info ( child3 , vart , nc3 , name ) if ( name . eq . row ( jj )) defects % foil % elmo ( jj , 1 : 6 ) = JSONgetDoubleVector ( child3 , nc3 , str , 0 ) end do if ( v . eq . 1 ) then call WriteValue ( '   Elastic moduli tensor (Voigt notation)' , '' ) do jj = 1 , 6 io_real ( 1 : 6 ) = defects % foil % elmo ( jj , 1 : 6 ) call WriteValue ( '' , io_real , 6 ) end do end if end if end do nc2loop end do end if call JSON_failtest ( error_cnt ) ! verify that the foil normal (in real space) and q (in reciprocal space) are orthogonal ! in other words, we do a cartesian dot product... x = CalcDot ( cell , defects % foil % F , defects % foil % q , 'c' ) if ( abs ( x ). gt . 0.005 ) then call Message ( 'Foil normal F must be orthogonal to q' , frm = \"(A)\" ) !  stop end if end subroutine JSONreadFoilData","tags":"","loc":"proc/jsonreadfoildata.html","title":"JSONreadFoilData – Fortran Program"},{"text":"public recursive subroutine JSONreadDefectFile(cell, jsonname, defects, error_cnt, verbose) Uses: iso_c_binding NameListHandlers io error iso_fortran_env proc~~jsonreaddefectfile~~UsesGraph proc~jsonreaddefectfile JSONreadDefectFile io io io->proc~jsonreaddefectfile iso_c_binding iso_c_binding iso_c_binding->proc~jsonreaddefectfile error error error->proc~jsonreaddefectfile iso_fortran_env iso_fortran_env iso_fortran_env->proc~jsonreaddefectfile module~namelisthandlers NameListHandlers module~namelisthandlers->proc~jsonreaddefectfile local local local->module~namelisthandlers module~namelisttypedefs NameListTypedefs local->module~namelisttypedefs module~namelisttypedefs->module~namelisthandlers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief parse json file into defect namelist structures\n @param cell unit cell pointer\n @param jsonname input file name\n @param defects defect structure, to be filled by this routine\n @param error_cnt total number of errors encountered by json routines\n @param verbose [optional] print a lot of output if present and true\n @date 11/20/15 MDG 1.0 new routine\n @date 12/08/15 MDG 1.1 added Einclusion defect type Arguments Type Intent Optional Attributes Name type(unitcell), intent(in), pointer :: cell character(len=fnlen), intent(in) :: jsonname type(defecttype), intent(inout) :: defects integer(kind=irg), intent(inout) :: error_cnt logical, intent(in), optional :: verbose Calls proc~~jsonreaddefectfile~~CallsGraph proc~jsonreaddefectfile JSONreadDefectFile writevalue writevalue proc~jsonreaddefectfile->writevalue proc~jsongetdouble JSONgetDouble proc~jsonreaddefectfile->proc~jsongetdouble json_parse json_parse proc~jsonreaddefectfile->json_parse emsoft_tonativepath emsoft_tonativepath proc~jsonreaddefectfile->emsoft_tonativepath proc~jsongetdoublevector JSONgetDoubleVector proc~jsonreaddefectfile->proc~jsongetdoublevector json_print_error_message json_print_error_message proc~jsonreaddefectfile->json_print_error_message json_get_child json_get_child proc~jsonreaddefectfile->json_get_child proc~jsonreadfoildata JSONreadFoilData proc~jsonreaddefectfile->proc~jsonreadfoildata json_get json_get proc~jsonreaddefectfile->json_get fatalerror fatalerror proc~jsonreaddefectfile->fatalerror emsoft_getemdatapathname emsoft_getemdatapathname proc~jsonreaddefectfile->emsoft_getemdatapathname json_failed json_failed proc~jsonreaddefectfile->json_failed json_info json_info proc~jsonreaddefectfile->json_info proc~json_failtest JSON_failtest proc~jsonreaddefectfile->proc~json_failtest json_initialize json_initialize proc~jsonreaddefectfile->json_initialize proc~jsongetdouble->writevalue proc~jsongetdouble->json_get proc~jsongetdoublevector->writevalue proc~jsongetdoublevector->json_get proc~jsonreadfoildata->writevalue proc~jsonreadfoildata->proc~jsongetdouble proc~jsonreadfoildata->json_parse proc~jsonreadfoildata->emsoft_tonativepath proc~jsonreadfoildata->proc~jsongetdoublevector proc~jsonreadfoildata->json_print_error_message proc~jsonreadfoildata->json_get_child proc~jsonreadfoildata->emsoft_getemdatapathname proc~jsonreadfoildata->json_failed proc~jsonreadfoildata->json_info proc~jsonreadfoildata->proc~json_failtest calcdot calcdot proc~jsonreadfoildata->calcdot message message proc~jsonreadfoildata->message proc~json_failtest->json_print_error_message proc~json_failtest->json_failed Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~jsonreaddefectfile~~CalledByGraph proc~jsonreaddefectfile JSONreadDefectFile proc~initializedefects InitializeDefects proc~initializedefects->proc~jsonreaddefectfile Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONreadDefectFile Source Code recursive subroutine JSONreadDefectFile ( cell , jsonname , defects , error_cnt , verbose ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadDefectFile use ISO_C_BINDING use NameListHandlers use io use error use , intrinsic :: iso_fortran_env , only : wp => real64 IMPLICIT NONE type ( unitcell ), pointer , INTENT ( IN ) :: cell character ( fnlen ), INTENT ( IN ) :: jsonname type ( defecttype ), INTENT ( INOUT ) :: defects integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt logical , INTENT ( IN ), OPTIONAL :: verbose type ( json_file ) :: json !the JSON structure read from the file: type ( json_value ), pointer :: jval , child , child2 , child3 , child4 character ( kind = jsonCK , len = :), allocatable :: name integer ( kind = irg ) :: i , j , jj , kk , v , io_int ( 3 ), jskip , ndis integer ( kind = irg ) :: vart , nc , nc2 , nc3 , nc4 , nc5 logical :: found character ( fnlen ) :: foilfilename , str , filename , dummystr real ( wp ) :: v4 ( 4 ), v5 ( 5 ), v6 ( 6 ), v9 ( 9 ), io_real ( 6 ) v = 0 if ( PRESENT ( verbose )) then if ( verbose ) then v = 1 end if end if dummystr = '' ! first of all, initialize json and return an error message if it does not exist error_cnt = 0 call json_initialize (); call JSON_failtest ( error_cnt ) filename = trim ( EMsoft_getEMdatapathname ()) // trim ( jsonname ) filename = EMsoft_toNativePath ( filename ) ! populate the jval json_value structure call json_parse ( trim ( filename ), jval ) if ( json_failed (). eqv .. TRUE .) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! get the top level file descriptor (should be the file name) and the number of its children nc (should really be 1) call json_info ( jval , vart , nc , name ) ! jval name = filename if ( v . eq . 1 ) then call WriteValue ( ' Defect file name : ' , name , \"(' ',A)\" ) end if ! loop over the children do i = 1 , nc call json_get_child ( jval , i , child ) call json_info ( child , vart , nc2 , name ) ! child name = DefectDescriptors ! loop over those children, which are the actual defect descriptors and deal with each of them separately ! the foil date must be the first entry; if it is not, then loop until we find it found = . FALSE . nc2loop : do j = 1 , nc2 call json_get_child ( child , j , child2 ) call json_info ( child2 , vart , nc3 , name ) if (. not .( name . eq . 'foil' )) CYCLE nc2loop ! name = foil, so read the name of the foil descriptor file call json_get ( child2 , 'foilfilename' , child3 , found ) jskip = j if ( found ) then call json_get ( child3 , name ) if ( v . eq . 1 ) call WriteValue ( ' Foil file name = ' , trim ( name ), \"(' ',A)\" ) defects % foilname = trim ( name ) end if end do nc2loop if (. not . found ) then call FatalError ( 'JSONreadDefectFile' , 'JSON file does not contain a foilfilename entry' ) end if ! here we call the foil reading routine to first fill all the foil parameters call JSONreadFoilData ( cell , defects , error_cnt , verbose ) ! then we need to get the total number of defects in the file, so that we can allocate ! the correct array sizes in the defects structure ndis = 0 nc2loop2 : do j = 1 , nc2 if ( j . eq . jskip ) CYCLE nc2loop2 call json_get_child ( child , j , child2 ) call json_info ( child2 , vart , nc3 , name ) if ( name . eq . 'voids' ) then allocate ( defects % voids ( nc3 )) defects % numvoids = nc3 end if if ( name . eq . 'inclusions' ) then allocate ( defects % inclusions ( nc3 )) defects % numinc = nc3 end if if ( name . eq . 'Einclusions' ) then allocate ( defects % Einclusions ( nc3 )) defects % numEinc = nc3 end if if ( name . eq . 'Ydislocations' ) then allocate ( defects % YD ( nc3 )) defects % numYdisl = nc3 end if if ( name . eq . 'dislocations' ) then ndis = ndis + nc3 defects % numdisl = nc3 end if if ( name . eq . 'stackingfaults' ) then allocate ( defects % SF ( nc3 )) ndis = ndis + 2 * nc3 defects % numsf = nc3 end if end do nc2loop2 if ( ndis . gt . 0 ) allocate ( defects % DL ( ndis )) ! now loop over all entries at the child level (Except for the foil data) and ! read the individual defect parameters; note that these are nested on level 4... ndis = 1 nc2loop3 : do j = 1 , nc2 if ( j . eq . jskip ) CYCLE nc2loop3 call json_get_child ( child , j , child2 ) call json_info ( child2 , vart , nc3 , name ) ! dislocations if ( name . eq . 'dislocations' ) then do jj = 1 , nc3 if ( v . eq . 1 ) then io_int ( 1 ) = jj call WriteValue ( '   dislocation #  ' , io_int , 1 , \"(I4)\" ) end if call json_get_child ( child2 , jj , child3 ) call json_info ( child3 , vart , nc4 , name ) do kk = 1 , nc4 call json_get_child ( child3 , kk , child4 ) call json_info ( child4 , vart , nc5 , name ) if ( name . eq . 'id' ) then str = '        x-coordinate  = ' defects % DL ( ndis )% id = JSONgetDouble ( child4 , str , v ) end if if ( name . eq . 'jd' ) then str = '        y-coordinate  = ' defects % DL ( ndis )% jd = JSONgetDouble ( child4 , str , v ) end if if ( name . eq . 'zfrac' ) then str = '        zfrac         = ' defects % DL ( ndis )% zfrac = JSONgetDouble ( child4 , str , v ) end if if ( name . eq . 'u' ) then str = '        u             = ' defects % DL ( ndis )% u = JSONgetDoubleVector ( child4 , nc5 , str , v ) end if if ( name . eq . 'bv' ) then str = '        bv            = ' defects % DL ( ndis )% burg = JSONgetDoubleVector ( child4 , nc5 , str , v ) end if end do ndis = ndis + 1 end do CYCLE nc2loop3 end if ! Ydislocations if ( name . eq . 'Ydislocations' ) then do jj = 1 , nc3 if ( v . eq . 1 ) then io_int ( 1 ) = jj call WriteValue ( '   Ydislocation #  ' , io_int , 1 , \"(I4)\" ) end if call json_get_child ( child2 , jj , child3 ) call json_info ( child3 , vart , nc4 , name ) do kk = 1 , nc4 call json_get_child ( child3 , kk , child4 ) call json_info ( child4 , vart , nc5 , name ) if ( name . eq . 'id' ) then str = '        x-coordinate  = ' defects % YD ( jj )% id = JSONgetDouble ( child4 , str , v ) end if if ( name . eq . 'jd' ) then str = '        y-coordinate  = ' defects % YD ( jj )% jd = JSONgetDouble ( child4 , str , v ) end if if ( name . eq . 'poisson' ) then str = '        poisson       = ' defects % YD ( jj )% sig = JSONgetDouble ( child4 , str , v ) end if if ( name . eq . 'u' ) then str = '        u             = ' defects % YD ( jj )% u = JSONgetDoubleVector ( child4 , nc5 , str , v ) end if if ( name . eq . 'bv' ) then str = '        bv            = ' defects % YD ( jj )% burg = JSONgetDoubleVector ( child4 , nc5 , str , v ) end if end do end do CYCLE nc2loop3 end if ! stacking faults if ( name . eq . 'stackingfaults' ) then do jj = 1 , nc3 if ( v . eq . 1 ) then io_int ( 1 ) = jj call WriteValue ( '   Stacking Fault #  ' , io_int , 1 , \"(I4)\" ) end if call json_get_child ( child2 , jj , child3 ) call json_info ( child3 , vart , nc4 , name ) do kk = 1 , nc4 call json_get_child ( child3 , kk , child4 ) call json_info ( child4 , vart , nc5 , name ) if ( name . eq . 'SFi' ) then str = '        x-coordinate  = ' defects % SF ( jj )% id = JSONgetDouble ( child4 , str , v ) end if if ( name . eq . 'SFj' ) then str = '        y-coordinate  = ' defects % SF ( jj )% jd = JSONgetDouble ( child4 , str , v ) end if if ( name . eq . 'SFsep' ) then str = '        SF separation = ' defects % SF ( jj )% sep = JSONgetDouble ( child4 , str , v ) end if if ( name . eq . 'SFplane' ) then str = '        SF plane      = ' defects % SF ( jj )% plane = JSONgetDoubleVector ( child4 , nc5 , str , v ) end if if ( name . eq . 'SFlpu' ) then str = '        SF lpu        = ' defects % SF ( jj )% lpu = JSONgetDoubleVector ( child4 , nc5 , str , v ) end if if ( name . eq . 'SFtpu' ) then str = '        SF tpu        = ' defects % SF ( jj )% tpu = JSONgetDoubleVector ( child4 , nc5 , str , v ) end if if ( name . eq . 'SFlpb' ) then str = '        SF lpb        = ' defects % SF ( jj )% lpb = JSONgetDoubleVector ( child4 , nc5 , str , v ) end if if ( name . eq . 'SFtpb' ) then str = '        SF tpb        = ' defects % SF ( jj )% tpb = JSONgetDoubleVector ( child4 , nc5 , str , v ) end if end do end do CYCLE nc2loop3 end if ! voids if ( name . eq . 'voids' ) then do jj = 1 , nc3 call json_get_child ( child2 , jj , child3 ) call json_info ( child3 , vart , nc4 , name ) v4 = JSONgetDoubleVector ( child3 , nc4 , dummystr , 0 ) defects % voids ( jj )% xpos = v4 ( 1 ) defects % voids ( jj )% ypos = v4 ( 2 ) defects % voids ( jj )% zpos = v4 ( 3 ) defects % voids ( jj )% radius = v4 ( 4 ) if ( v . eq . 1 ) then io_real ( 1 : 4 ) = v4 ( 1 : 4 ) io_int ( 1 ) = jj call WriteValue ( ' void   ' , io_int , 1 , \"(I4,$)\" ) call WriteValue ( '' , io_real , 4 ) end if end do CYCLE nc2loop3 end if ! inclusions if ( name . eq . 'inclusions' ) then do jj = 1 , nc3 call json_get_child ( child2 , jj , child3 ) call json_info ( child3 , vart , nc4 , name ) v5 = JSONgetDoubleVector ( child3 , nc4 , dummystr , 0 ) defects % inclusions ( jj )% xpos = v5 ( 1 ) defects % inclusions ( jj )% ypos = v5 ( 2 ) defects % inclusions ( jj )% zpos = v5 ( 3 ) defects % inclusions ( jj )% radius = v5 ( 4 ) defects % inclusions ( jj )% C = v5 ( 5 ) if ( v . eq . 1 ) then io_real ( 1 : 5 ) = v5 ( 1 : 5 ) io_int ( 1 ) = jj call WriteValue ( ' inclusion    ' , io_int , 1 , \"(I4,$)\" ) call WriteValue ( '' , io_real , 5 ) end if end do CYCLE nc2loop3 end if ! Eshelby ellipsoidal inclusions (isotropic) if ( name . eq . 'Einclusions' ) then do jj = 1 , nc3 if ( v . eq . 1 ) then io_int ( 1 ) = jj call WriteValue ( '   Einclusion   #  ' , io_int , 1 , \"(I4)\" ) end if call json_get_child ( child2 , jj , child3 ) call json_info ( child3 , vart , nc4 , name ) do kk = 1 , nc4 call json_get_child ( child3 , kk , child4 ) call json_info ( child4 , vart , nc5 , name ) if ( name . eq . 'xyz' ) then str = '        xyz           = ' defects % Einclusions ( jj )% xyz = JSONgetDoubleVector ( child4 , nc5 , str , v ) end if if ( name . eq . 'a123' ) then str = '        a123          = ' defects % Einclusions ( jj )% a123 = JSONgetDoubleVector ( child4 , nc5 , str , v ) end if if ( name . eq . 'nu' ) then str = '        nu            = ' defects % Einclusions ( jj )% nu = JSONgetDouble ( child4 , str , v ) end if if ( name . eq . 'epsstarvoigt' ) then str = '        eps* (Voigt)  = ' v6 = JSONgetDoubleVector ( child4 , nc5 , str , v ) defects % Einclusions ( jj )% epsstar ( 1 , 1 ) = v6 ( 1 ) defects % Einclusions ( jj )% epsstar ( 2 , 2 ) = v6 ( 2 ) defects % Einclusions ( jj )% epsstar ( 3 , 3 ) = v6 ( 3 ) defects % Einclusions ( jj )% epsstar ( 1 , 2 ) = v6 ( 6 ) * 0.5D0 defects % Einclusions ( jj )% epsstar ( 2 , 1 ) = v6 ( 6 ) * 0.5D0 defects % Einclusions ( jj )% epsstar ( 1 , 3 ) = v6 ( 5 ) * 0.5D0 defects % Einclusions ( jj )% epsstar ( 3 , 1 ) = v6 ( 5 ) * 0.5D0 defects % Einclusions ( jj )% epsstar ( 2 , 3 ) = v6 ( 4 ) * 0.5D0 defects % Einclusions ( jj )% epsstar ( 3 , 2 ) = v6 ( 4 ) * 0.5D0 end if if ( name . eq . 'principalaxes' ) then str = '        principalaxes = ' v9 = JSONgetDoubleVector ( child4 , nc5 , str , v ) defects % Einclusions ( jj )% principalaxes ( 1 , 1 : 3 ) = v9 ( 1 : 3 ) defects % Einclusions ( jj )% principalaxes ( 2 , 1 : 3 ) = v9 ( 4 : 6 ) defects % Einclusions ( jj )% principalaxes ( 3 , 1 : 3 ) = v9 ( 7 : 9 ) end if end do end do CYCLE nc2loop3 end if ! other defct types to be added here end do nc2loop3 end do end if call JSON_failtest ( error_cnt ) end subroutine JSONreadDefectFile","tags":"","loc":"proc/jsonreaddefectfile.html","title":"JSONreadDefectFile – Fortran Program"},{"text":"public recursive subroutine JSONreadKosselNameList(knl, jsonname, error_cnt) Uses: iso_c_binding NameListHandlers proc~~jsonreadkosselnamelist~~UsesGraph proc~jsonreadkosselnamelist JSONreadKosselNameList iso_c_binding iso_c_binding iso_c_binding->proc~jsonreadkosselnamelist module~namelisthandlers NameListHandlers module~namelisthandlers->proc~jsonreadkosselnamelist local local local->module~namelisthandlers module~namelisttypedefs NameListTypedefs local->module~namelisttypedefs module~namelisttypedefs->module~namelisthandlers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read json file into namelist structure\n @param knl Kossel name list structure\n @param jsonname input file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/12/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(KosselNameListType), intent(inout) :: knl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt Calls proc~~jsonreadkosselnamelist~~CallsGraph proc~jsonreadkosselnamelist JSONreadKosselNameList proc~jsonreadstring JSONreadString proc~jsonreadkosselnamelist->proc~jsonreadstring proc~jsonreadinteger JSONreadInteger proc~jsonreadkosselnamelist->proc~jsonreadinteger proc~getkosselnamelist GetKosselNameList proc~jsonreadkosselnamelist->proc~getkosselnamelist json_initialize json_initialize proc~jsonreadkosselnamelist->json_initialize json_print_error_message json_print_error_message proc~jsonreadkosselnamelist->json_print_error_message proc~jsonreadintegervec JSONreadIntegerVec proc~jsonreadkosselnamelist->proc~jsonreadintegervec proc~json_failtest JSON_failtest proc~jsonreadkosselnamelist->proc~json_failtest proc~jsonreadreal JSONreadReal proc~jsonreadkosselnamelist->proc~jsonreadreal json_failed json_failed proc~jsonreadkosselnamelist->json_failed emsoft_tonativepath emsoft_tonativepath proc~getkosselnamelist->emsoft_tonativepath fatalerror fatalerror proc~getkosselnamelist->fatalerror proc~json_failtest->json_print_error_message proc~json_failtest->json_failed sngl sngl proc~jsonreadreal->sngl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONreadKosselNameList Source Code recursive subroutine JSONreadKosselNameList ( knl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadKosselNameList use ISO_C_BINDING use NameListHandlers IMPLICIT NONE type ( KosselNameListType ), INTENT ( INOUT ) :: knl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_file ) :: json !the JSON structure read from the file: type ( KosselNameListType ) :: defknl logical :: init = . TRUE . character ( fnlen ) :: nmlfile = '' , ep real ( kind = wp ) :: rval character ( kind = jsonCK , len = :), allocatable :: cval real ( wp ), dimension (:), allocatable :: rvec ! first of all, open the file and return an error message if it does not exist error_cnt = 0 call json_initialize (); call JSON_failtest ( error_cnt ) ! populate the json structure call json % load_file ( filename = trim ( jsonname )) if ( json_failed (). eqv .. TRUE .) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! ok, we got here so we need to initialize the namelist first to its default values (set in NameListHandlers) call GetKosselNameList ( nmlfile , defknl , initonly = init ) ! then we start reading the values in the json file ep = 'Kossellist.stdout' call JSONreadInteger ( json , ep , knl % stdout , defknl % stdout ) ep = 'Kossellist.numthick' call JSONreadInteger ( json , ep , knl % numthick , defknl % numthick ) ep = 'Kossellist.npix' call JSONreadInteger ( json , ep , knl % npix , defknl % npix ) ep = 'Kossellist.maxHOLZ' call JSONreadInteger ( json , ep , knl % maxHOLZ , defknl % maxHOLZ ) ep = 'Kossellist.nthreads' call JSONreadInteger ( json , ep , knl % nthreads , defknl % nthreads ) ep = 'Kossellist.k' call JSONreadIntegerVec ( json , ep , knl % k , defknl % k , size ( knl % k )) ep = 'Kossellist.fn' call JSONreadIntegerVec ( json , ep , knl % fn , defknl % fn , size ( knl % fn )) ep = 'Kossellist.voltage' call JSONreadReal ( json , ep , knl % voltage , defknl % voltage ) ep = 'Kossellist.dmin' call JSONreadReal ( json , ep , knl % dmin , defknl % dmin ) ep = 'Kossellist.convergence' call JSONreadReal ( json , ep , knl % convergence , defknl % convergence ) ep = 'Kossellist.startthick' call JSONreadReal ( json , ep , knl % startthick , defknl % startthick ) ep = 'Kossellist.thickinc' call JSONreadReal ( json , ep , knl % thickinc , defknl % thickinc ) ep = 'Kossellist.minten' call JSONreadReal ( json , ep , knl % minten , defknl % minten ) ep = 'Kossellist.xtalname' call JSONreadString ( json , ep , knl % xtalname , defknl % xtalname ) ep = 'Kossellist.outname' call JSONreadString ( json , ep , knl % outname , defknl % outname ) end if call json % destroy (); call JSON_failtest ( error_cnt ) end subroutine JSONreadKosselNameList","tags":"","loc":"proc/jsonreadkosselnamelist.html","title":"JSONreadKosselNameList – Fortran Program"},{"text":"public recursive subroutine JSONreadKosselMasterNameList(knl, jsonname, error_cnt) Uses: iso_c_binding NameListHandlers proc~~jsonreadkosselmasternamelist~~UsesGraph proc~jsonreadkosselmasternamelist JSONreadKosselMasterNameList iso_c_binding iso_c_binding iso_c_binding->proc~jsonreadkosselmasternamelist module~namelisthandlers NameListHandlers module~namelisthandlers->proc~jsonreadkosselmasternamelist local local local->module~namelisthandlers module~namelisttypedefs NameListTypedefs local->module~namelisttypedefs module~namelisttypedefs->module~namelisthandlers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read json file and fill knl structure (used by EMKosselmaster.f90)\n @param knl Kossel name list structure\n @param jsonname input file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/19/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(KosselMasterNameListType), intent(inout) :: knl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt Calls proc~~jsonreadkosselmasternamelist~~CallsGraph proc~jsonreadkosselmasternamelist JSONreadKosselMasterNameList proc~getkosselmasternamelist GetKosselMasterNameList proc~jsonreadkosselmasternamelist->proc~getkosselmasternamelist proc~jsonreadstring JSONreadString proc~jsonreadkosselmasternamelist->proc~jsonreadstring proc~jsonreadinteger JSONreadInteger proc~jsonreadkosselmasternamelist->proc~jsonreadinteger json_print_error_message json_print_error_message proc~jsonreadkosselmasternamelist->json_print_error_message json_initialize json_initialize proc~jsonreadkosselmasternamelist->json_initialize proc~json_failtest JSON_failtest proc~jsonreadkosselmasternamelist->proc~json_failtest proc~jsonreadreal JSONreadReal proc~jsonreadkosselmasternamelist->proc~jsonreadreal json_failed json_failed proc~jsonreadkosselmasternamelist->json_failed emsoft_tonativepath emsoft_tonativepath proc~getkosselmasternamelist->emsoft_tonativepath fatalerror fatalerror proc~getkosselmasternamelist->fatalerror proc~json_failtest->json_print_error_message proc~json_failtest->json_failed sngl sngl proc~jsonreadreal->sngl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONreadKosselMasterNameList Source Code recursive subroutine JSONreadKosselMasterNameList ( knl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadKosselMasterNameList use ISO_C_BINDING use NameListHandlers IMPLICIT NONE type ( KosselMasterNameListType ), INTENT ( INOUT ) :: knl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_file ) :: json !the JSON structure read from the file: type ( KosselMasterNameListType ) :: defknl logical :: init = . TRUE . character ( fnlen ) :: nmlfile = '' , ep , s , s2 real ( kind = wp ) :: rval character ( kind = jsonCK , len = :), allocatable :: cval real ( wp ), dimension (:), allocatable :: rvec ! first of all, open the file and return an error message if it does not exist error_cnt = 0 call json_initialize (); call JSON_failtest ( error_cnt ) ! populate the json structure call json % load_file ( filename = trim ( jsonname )) if ( json_failed (). eqv .. TRUE .) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! ok, we got here so we need to initialize the namelist first to its default values (set in NameListHandlers) call GetKosselMasterNameList ( nmlfile , defknl , initonly = init ) ! then we start reading the values in the json file ep = 'Kosselmasterlist.stdout' call JSONreadInteger ( json , ep , knl % stdout , defknl % stdout ) ep = 'Kosselmasterlist.numthick' call JSONreadInteger ( json , ep , knl % numthick , defknl % numthick ) ep = 'Kosselmasterlist.npix' call JSONreadInteger ( json , ep , knl % npx , defknl % npx ) ep = 'Kosselmasterlist.nthreads' call JSONreadInteger ( json , ep , knl % nthreads , defknl % nthreads ) ep = 'Kosselmasterlist.voltage' call JSONreadReal ( json , ep , knl % voltage , defknl % voltage ) ep = 'Kosselmasterlist.dmin' call JSONreadReal ( json , ep , knl % dmin , defknl % dmin ) ep = 'Kosselmasterlist.startthick' call JSONreadReal ( json , ep , knl % startthick , defknl % startthick ) ep = 'Kosselmasterlist.thickinc' call JSONreadReal ( json , ep , knl % thickinc , defknl % thickinc ) ep = 'Kosselmasterlist.tfraction' call JSONreadReal ( json , ep , knl % tfraction , defknl % tfraction ) ep = 'Kosselmasterlist.Kosselmode' s = knl % Kosselmode s2 = defknl % Kosselmode call JSONreadString ( json , ep , s , s2 ) ep = 'Kosselmasterlist.xtalname' call JSONreadString ( json , ep , knl % xtalname , defknl % xtalname ) ep = 'Kosselmasterlist.outname' call JSONreadString ( json , ep , knl % outname , defknl % outname ) end if call json % destroy (); call JSON_failtest ( error_cnt ) end subroutine JSONreadKosselMasterNameList","tags":"","loc":"proc/jsonreadkosselmasternamelist.html","title":"JSONreadKosselMasterNameList – Fortran Program"},{"text":"public recursive subroutine JSONreadreflectorNameList(rnl, jsonname, error_cnt) Uses: iso_c_binding NameListHandlers proc~~jsonreadreflectornamelist~~UsesGraph proc~jsonreadreflectornamelist JSONreadreflectorNameList iso_c_binding iso_c_binding iso_c_binding->proc~jsonreadreflectornamelist module~namelisthandlers NameListHandlers module~namelisthandlers->proc~jsonreadreflectornamelist local local local->module~namelisthandlers module~namelisttypedefs NameListTypedefs local->module~namelisttypedefs module~namelisttypedefs->module~namelisthandlers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read json file and fill mcnl structure (used by EMMC.f90)\n @param mcnl Monte Carloname list structure\n @param jsonname input file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/19/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(reflectorNameListType), intent(inout) :: rnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt Calls proc~~jsonreadreflectornamelist~~CallsGraph proc~jsonreadreflectornamelist JSONreadreflectorNameList proc~getreflectornamelist GetreflectorNameList proc~jsonreadreflectornamelist->proc~getreflectornamelist proc~jsonreadstring JSONreadString proc~jsonreadreflectornamelist->proc~jsonreadstring proc~jsonreadinteger JSONreadInteger proc~jsonreadreflectornamelist->proc~jsonreadinteger json_print_error_message json_print_error_message proc~jsonreadreflectornamelist->json_print_error_message json_initialize json_initialize proc~jsonreadreflectornamelist->json_initialize proc~json_failtest JSON_failtest proc~jsonreadreflectornamelist->proc~json_failtest proc~jsonreadreal JSONreadReal proc~jsonreadreflectornamelist->proc~jsonreadreal json_failed json_failed proc~jsonreadreflectornamelist->json_failed emsoft_tonativepath emsoft_tonativepath proc~getreflectornamelist->emsoft_tonativepath fatalerror fatalerror proc~getreflectornamelist->fatalerror proc~json_failtest->json_print_error_message proc~json_failtest->json_failed sngl sngl proc~jsonreadreal->sngl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONreadreflectorNameList Source Code recursive subroutine JSONreadreflectorNameList ( rnl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadreflectorNameList use ISO_C_BINDING use NameListHandlers IMPLICIT NONE type ( reflectorNameListType ), INTENT ( INOUT ) :: rnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_file ) :: json !the JSON structure read from the file: type ( reflectorNameListType ) :: defrnl logical :: init = . TRUE . character ( fnlen ) :: nmlfile = '' , ep , s , s2 real ( kind = wp ) :: rval character ( kind = jsonCK , len = :), allocatable :: cval real ( wp ), dimension (:), allocatable :: rvec ! first of all, open the file and return an error message if it does not exist error_cnt = 0 call json_initialize (); call JSON_failtest ( error_cnt ) ! populate the json structure call json % load_file ( filename = trim ( jsonname )) if ( json_failed (). eqv .. TRUE .) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! ok, we got here so we need to initialize the namelist first to its default values (set in NameListHandlers) call GetreflectorNameList ( nmlfile , defrnl , initonly = init ) ! then we start reading the values in the json file ep = 'EBSDreflectors.numphi' call JSONreadInteger ( json , ep , rnl % numphi , defrnl % numphi ) ep = 'EBSDreflectors.numtheta' call JSONreadInteger ( json , ep , rnl % numtheta , defrnl % numtheta ) ep = 'EBSDreflectors.dmin' call JSONreadReal ( json , ep , rnl % dmin , defrnl % dmin ) ep = 'EBSDreflectors.masterfile' call JSONreadString ( json , ep , rnl % masterfile , defrnl % masterfile ) ep = 'EBSDreflectors.energyfile' call JSONreadString ( json , ep , rnl % energyfile , defrnl % energyfile ) end if call json % destroy (); call JSON_failtest ( error_cnt ) end subroutine JSONreadreflectorNameList","tags":"","loc":"proc/jsonreadreflectornamelist.html","title":"JSONreadreflectorNameList – Fortran Program"},{"text":"public recursive subroutine JSONreadMCNameList(mcnl, jsonname, error_cnt) Uses: iso_c_binding NameListHandlers proc~~jsonreadmcnamelist~~UsesGraph proc~jsonreadmcnamelist JSONreadMCNameList iso_c_binding iso_c_binding iso_c_binding->proc~jsonreadmcnamelist module~namelisthandlers NameListHandlers module~namelisthandlers->proc~jsonreadmcnamelist local local local->module~namelisthandlers module~namelisttypedefs NameListTypedefs local->module~namelisttypedefs module~namelisttypedefs->module~namelisthandlers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read json file and fill mcnl structure (used by EMMC.f90)\n @param mcnl Monte Carloname list structure\n @param jsonname input file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/19/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(MCNameListType), intent(inout) :: mcnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt Calls proc~~jsonreadmcnamelist~~CallsGraph proc~jsonreadmcnamelist JSONreadMCNameList proc~jsonreaddouble JSONreadDouble proc~jsonreadmcnamelist->proc~jsonreaddouble proc~jsonreadstring JSONreadString proc~jsonreadmcnamelist->proc~jsonreadstring proc~jsonreadinteger JSONreadInteger proc~jsonreadmcnamelist->proc~jsonreadinteger json_print_error_message json_print_error_message proc~jsonreadmcnamelist->json_print_error_message json_initialize json_initialize proc~jsonreadmcnamelist->json_initialize proc~getmcnamelist GetMCNameList proc~jsonreadmcnamelist->proc~getmcnamelist proc~json_failtest JSON_failtest proc~jsonreadmcnamelist->proc~json_failtest json_failed json_failed proc~jsonreadmcnamelist->json_failed emsoft_tonativepath emsoft_tonativepath proc~getmcnamelist->emsoft_tonativepath fatalerror fatalerror proc~getmcnamelist->fatalerror proc~json_failtest->json_print_error_message proc~json_failtest->json_failed Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONreadMCNameList Source Code recursive subroutine JSONreadMCNameList ( mcnl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadMCNameList use ISO_C_BINDING use NameListHandlers IMPLICIT NONE type ( MCNameListType ), INTENT ( INOUT ) :: mcnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_file ) :: json !the JSON structure read from the file: type ( MCNameListType ) :: defmcnl logical :: init = . TRUE . character ( fnlen ) :: nmlfile = '' , ep , s , s2 real ( kind = wp ) :: rval character ( kind = jsonCK , len = :), allocatable :: cval real ( wp ), dimension (:), allocatable :: rvec ! first of all, open the file and return an error message if it does not exist error_cnt = 0 call json_initialize (); call JSON_failtest ( error_cnt ) ! populate the json structure call json % load_file ( filename = trim ( jsonname )) if ( json_failed (). eqv .. TRUE .) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! ok, we got here so we need to initialize the namelist first to its default values (set in NameListHandlers) call GetMCNameList ( nmlfile , defmcnl , initonly = init ) ! then we start reading the values in the json file ep = 'MCdata.stdout' call JSONreadInteger ( json , ep , mcnl % stdout , defmcnl % stdout ) ep = 'MCdata.numsx' call JSONreadInteger ( json , ep , mcnl % numsx , defmcnl % numsx ) ep = 'MCdata.num_el' call JSONreadInteger ( json , ep , mcnl % num_el , defmcnl % num_el ) ep = 'MCdata.primeseeds' call JSONreadInteger ( json , ep , mcnl % primeseed , defmcnl % primeseed ) ep = 'MCdata.nthreads' call JSONreadInteger ( json , ep , mcnl % nthreads , defmcnl % nthreads ) ep = 'MCdata.sig' call JSONreadDouble ( json , ep , mcnl % sig , defmcnl % sig ) ep = 'MCdata.omega' call JSONreadDouble ( json , ep , mcnl % omega , defmcnl % omega ) ep = 'MCdata.EkeV' call JSONreadDouble ( json , ep , mcnl % EkeV , defmcnl % EkeV ) ep = 'MCdata.Ehistmin' call JSONreadDouble ( json , ep , mcnl % Ehistmin , defmcnl % Ehistmin ) ep = 'MCdata.Ebinsize' call JSONreadDouble ( json , ep , mcnl % Ebinsize , defmcnl % Ebinsize ) ep = 'MCdata.depthmax' call JSONreadDouble ( json , ep , mcnl % depthmax , defmcnl % depthmax ) ep = 'MCdata.depthstep' call JSONreadDouble ( json , ep , mcnl % depthstep , defmcnl % depthstep ) ep = 'MCdata.MCmode' s = mcnl % MCmode s2 = defmcnl % MCmode call JSONreadString ( json , ep , s , s2 ) ep = 'MCdata.xtalname' call JSONreadString ( json , ep , mcnl % xtalname , defmcnl % xtalname ) ep = 'MCdata.dataname' call JSONreadString ( json , ep , mcnl % dataname , defmcnl % dataname ) end if call json % destroy (); call JSON_failtest ( error_cnt ) end subroutine JSONreadMCNameList","tags":"","loc":"proc/jsonreadmcnamelist.html","title":"JSONreadMCNameList – Fortran Program"},{"text":"public recursive subroutine JSONreadMCCLNameList(mcnl, jsonname, error_cnt) Uses: iso_c_binding NameListHandlers proc~~jsonreadmcclnamelist~~UsesGraph proc~jsonreadmcclnamelist JSONreadMCCLNameList iso_c_binding iso_c_binding iso_c_binding->proc~jsonreadmcclnamelist module~namelisthandlers NameListHandlers module~namelisthandlers->proc~jsonreadmcclnamelist local local local->module~namelisthandlers module~namelisttypedefs NameListTypedefs local->module~namelisttypedefs module~namelisttypedefs->module~namelisthandlers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh/Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMMCCL.f90)\n @param mcnl Monte Carlo name list structure\n @param jsonname input file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/19/15  MDG 1.0 new routine\n @date 09/09/15  MDG 1.1 added devid Arguments Type Intent Optional Attributes Name type(MCCLNameListType), intent(inout) :: mcnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt Calls proc~~jsonreadmcclnamelist~~CallsGraph proc~jsonreadmcclnamelist JSONreadMCCLNameList proc~jsonreaddouble JSONreadDouble proc~jsonreadmcclnamelist->proc~jsonreaddouble proc~jsonreadstring JSONreadString proc~jsonreadmcclnamelist->proc~jsonreadstring proc~jsonreadinteger JSONreadInteger proc~jsonreadmcclnamelist->proc~jsonreadinteger proc~getmcclnamelist GetMCCLNameList proc~jsonreadmcclnamelist->proc~getmcclnamelist json_initialize json_initialize proc~jsonreadmcclnamelist->json_initialize json_print_error_message json_print_error_message proc~jsonreadmcclnamelist->json_print_error_message proc~json_failtest JSON_failtest proc~jsonreadmcclnamelist->proc~json_failtest json_failed json_failed proc~jsonreadmcclnamelist->json_failed emsoft_tonativepath emsoft_tonativepath proc~getmcclnamelist->emsoft_tonativepath fatalerror fatalerror proc~getmcclnamelist->fatalerror proc~json_failtest->json_print_error_message proc~json_failtest->json_failed Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONreadMCCLNameList Source Code recursive subroutine JSONreadMCCLNameList ( mcnl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadMCCLNameList use ISO_C_BINDING use NameListHandlers IMPLICIT NONE type ( MCCLNameListType ), INTENT ( INOUT ) :: mcnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_file ) :: json !the JSON structure read from the file: type ( MCCLNameListType ) :: defmcnl logical :: init = . TRUE . character ( fnlen ) :: nmlfile = '' , ep , s , s2 real ( kind = wp ) :: rval character ( kind = jsonCK , len = :), allocatable :: cval real ( wp ), dimension (:), allocatable :: rvec ! first of all, open the file and return an error message if it does not exist error_cnt = 0 call json_initialize (); call JSON_failtest ( error_cnt ) ! populate the json structure call json % load_file ( filename = trim ( jsonname )) if ( json_failed (). eqv .. TRUE .) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! ok, we got here so we need to initialize the namelist first to its default values (set in NameListHandlers) call GetMCCLNameList ( nmlfile , defmcnl , initonly = init ) ! then we start reading the values in the json file ep = 'MCCLdata.stdout' call JSONreadInteger ( json , ep , mcnl % stdout , defmcnl % stdout ) ep = 'MCCLdata.numsx' call JSONreadInteger ( json , ep , mcnl % numsx , defmcnl % numsx ) ep = 'MCCLdata.globalworkgrpsz' call JSONreadInteger ( json , ep , mcnl % globalworkgrpsz , defmcnl % globalworkgrpsz ) ep = 'MCCLdata.num_el' call JSONreadInteger ( json , ep , mcnl % num_el , defmcnl % num_el ) ep = 'MCCLdata.totnum_el' call JSONreadInteger ( json , ep , mcnl % totnum_el , defmcnl % totnum_el ) ep = 'MCCLdata.multiplier' call JSONreadInteger ( json , ep , mcnl % multiplier , defmcnl % multiplier ) ep = 'MCCLdata.devid' call JSONreadInteger ( json , ep , mcnl % devid , defmcnl % devid ) ep = 'MCCLdata.platid' call JSONreadInteger ( json , ep , mcnl % platid , defmcnl % platid ) ep = 'MCCLdata.sigstart' call JSONreadDouble ( json , ep , mcnl % sigstart , defmcnl % sigstart ) ep = 'MCCLdata.sigend' call JSONreadDouble ( json , ep , mcnl % sigend , defmcnl % sigend ) ep = 'MCCLdata.sigstep' call JSONreadDouble ( json , ep , mcnl % sigstep , defmcnl % sigstep ) ep = 'MCCLdata.omega' call JSONreadDouble ( json , ep , mcnl % omega , defmcnl % omega ) ep = 'MCCLdata.EkeV' call JSONreadDouble ( json , ep , mcnl % EkeV , defmcnl % EkeV ) ep = 'MCCLdata.Ehistmin' call JSONreadDouble ( json , ep , mcnl % Ehistmin , defmcnl % Ehistmin ) ep = 'MCCLdata.Ebinsize' call JSONreadDouble ( json , ep , mcnl % Ebinsize , defmcnl % Ebinsize ) ep = 'MCCLdata.depthmax' call JSONreadDouble ( json , ep , mcnl % depthmax , defmcnl % depthmax ) ep = 'MCCLdata.depthstep' call JSONreadDouble ( json , ep , mcnl % depthstep , defmcnl % depthstep ) ep = 'MCCLdata.MCmode' s = mcnl % MCmode s2 = defmcnl % MCmode call JSONreadString ( json , ep , s , s2 ) ep = 'MCCLdata.xtalname' call JSONreadString ( json , ep , mcnl % xtalname , defmcnl % xtalname ) ep = 'MCCLdata.dataname' call JSONreadString ( json , ep , mcnl % dataname , defmcnl % dataname ) ep = 'MCCLdata.mode' call JSONreadString ( json , ep , mcnl % mode , defmcnl % mode ) end if call json % destroy (); call JSON_failtest ( error_cnt ) end subroutine JSONreadMCCLNameList","tags":"","loc":"proc/jsonreadmcclnamelist.html","title":"JSONreadMCCLNameList – Fortran Program"},{"text":"public recursive subroutine JSONreadMCCLMultiLayerNameList(mcnl, jsonname, error_cnt) Uses: iso_c_binding NameListHandlers proc~~jsonreadmcclmultilayernamelist~~UsesGraph proc~jsonreadmcclmultilayernamelist JSONreadMCCLMultiLayerNameList iso_c_binding iso_c_binding iso_c_binding->proc~jsonreadmcclmultilayernamelist module~namelisthandlers NameListHandlers module~namelisthandlers->proc~jsonreadmcclmultilayernamelist local local local->module~namelisthandlers module~namelisttypedefs NameListTypedefs local->module~namelisttypedefs module~namelisttypedefs->module~namelisthandlers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh/Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMMCCL.f90)\n @param mcnl Monte Carloname list structure\n @param jsonname input file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/19/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(MCCLMultiLayerNameListType), intent(inout) :: mcnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt Calls proc~~jsonreadmcclmultilayernamelist~~CallsGraph proc~jsonreadmcclmultilayernamelist JSONreadMCCLMultiLayerNameList proc~jsonreaddouble JSONreadDouble proc~jsonreadmcclmultilayernamelist->proc~jsonreaddouble proc~jsonreadstring JSONreadString proc~jsonreadmcclmultilayernamelist->proc~jsonreadstring proc~jsonreadinteger JSONreadInteger proc~jsonreadmcclmultilayernamelist->proc~jsonreadinteger json_print_error_message json_print_error_message proc~jsonreadmcclmultilayernamelist->json_print_error_message json_initialize json_initialize proc~jsonreadmcclmultilayernamelist->json_initialize proc~getmcclmultilayernamelist GetMCCLMultiLayerNameList proc~jsonreadmcclmultilayernamelist->proc~getmcclmultilayernamelist proc~json_failtest JSON_failtest proc~jsonreadmcclmultilayernamelist->proc~json_failtest json_failed json_failed proc~jsonreadmcclmultilayernamelist->json_failed emsoft_tonativepath emsoft_tonativepath proc~getmcclmultilayernamelist->emsoft_tonativepath fatalerror fatalerror proc~getmcclmultilayernamelist->fatalerror proc~json_failtest->json_print_error_message proc~json_failtest->json_failed Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONreadMCCLMultiLayerNameList Source Code recursive subroutine JSONreadMCCLMultiLayerNameList ( mcnl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadMCCLMultiLayerNameList use ISO_C_BINDING use NameListHandlers IMPLICIT NONE type ( MCCLMultiLayerNameListType ), INTENT ( INOUT ) :: mcnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_file ) :: json !the JSON structure read from the file: type ( MCCLMultiLayerNameListType ) :: defmcnl logical :: init = . TRUE . character ( fnlen ) :: nmlfile = '' , ep , s , s2 real ( kind = wp ) :: rval character ( kind = jsonCK , len = :), allocatable :: cval real ( wp ), dimension (:), allocatable :: rvec ! first of all, open the file and return an error message if it does not exist error_cnt = 0 call json_initialize (); call JSON_failtest ( error_cnt ) ! populate the json structure call json % load_file ( filename = trim ( jsonname )) if ( json_failed (). eqv .. TRUE .) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! ok, we got here so we need to initialize the namelist first to its default values (set in NameListHandlers) call GetMCCLMultiLayerNameList ( nmlfile , defmcnl , initonly = init ) ! then we start reading the values in the json file ep = 'MCCLdata.stdout' call JSONreadInteger ( json , ep , mcnl % stdout , defmcnl % stdout ) ep = 'MCCLdata.numsx' call JSONreadInteger ( json , ep , mcnl % numsx , defmcnl % numsx ) ep = 'MCCLdata.globalworkgrpsz' call JSONreadInteger ( json , ep , mcnl % globalworkgrpsz , defmcnl % globalworkgrpsz ) ep = 'MCCLdata.num_el' call JSONreadInteger ( json , ep , mcnl % num_el , defmcnl % num_el ) ep = 'MCCLdata.totnum_el' call JSONreadInteger ( json , ep , mcnl % totnum_el , defmcnl % totnum_el ) ep = 'MCCLdata.sig' call JSONreadDouble ( json , ep , mcnl % sig , defmcnl % sig ) ep = 'MCCLdata.omega' call JSONreadDouble ( json , ep , mcnl % omega , defmcnl % omega ) ep = 'MCCLdata.EkeV' call JSONreadDouble ( json , ep , mcnl % EkeV , defmcnl % EkeV ) ep = 'MCCLdata.Ehistmin' call JSONreadDouble ( json , ep , mcnl % Ehistmin , defmcnl % Ehistmin ) ep = 'MCCLdata.Ebinsize' call JSONreadDouble ( json , ep , mcnl % Ebinsize , defmcnl % Ebinsize ) ep = 'MCCLdata.depthmax' call JSONreadDouble ( json , ep , mcnl % depthmax , defmcnl % depthmax ) ep = 'MCCLdata.depthstep' call JSONreadDouble ( json , ep , mcnl % depthstep , defmcnl % depthstep ) ep = 'MCCLdata.filmthickness' call JSONreadDouble ( json , ep , mcnl % filmthickness , defmcnl % filmthickness ) ep = 'MCCLdata.filmstep' call JSONreadDouble ( json , ep , mcnl % filmstep , defmcnl % filmstep ) ep = 'MCCLdata.MCmode' s = mcnl % MCmode s2 = defmcnl % MCmode call JSONreadString ( json , ep , s , s2 ) ep = 'MCCLdata.xtalname_film' call JSONreadString ( json , ep , mcnl % xtalname_film , defmcnl % xtalname_film ) ep = 'MCCLdata.xtalname_subs' call JSONreadString ( json , ep , mcnl % xtalname_subs , defmcnl % xtalname_subs ) ep = 'MCCLdata.dataname' call JSONreadString ( json , ep , mcnl % dataname , defmcnl % dataname ) ep = 'MCCLdata.mode' call JSONreadString ( json , ep , mcnl % mode , defmcnl % mode ) end if call json % destroy (); call JSON_failtest ( error_cnt ) end subroutine JSONreadMCCLMultiLayerNameList","tags":"","loc":"proc/jsonreadmcclmultilayernamelist.html","title":"JSONreadMCCLMultiLayerNameList – Fortran Program"},{"text":"public recursive subroutine JSONreadEBSDMasterNameList(emnl, jsonname, error_cnt) Uses: iso_c_binding NameListHandlers proc~~jsonreadebsdmasternamelist~~UsesGraph proc~jsonreadebsdmasternamelist JSONreadEBSDMasterNameList iso_c_binding iso_c_binding iso_c_binding->proc~jsonreadebsdmasternamelist module~namelisthandlers NameListHandlers module~namelisthandlers->proc~jsonreadebsdmasternamelist local local local->module~namelisthandlers module~namelisttypedefs NameListTypedefs local->module~namelisttypedefs module~namelisttypedefs->module~namelisthandlers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read json file and fill emnl structure (used by EMEBSDmaster.f90)\n @param emnl EBSD master name list structure\n @param jsonname input file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/19/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(EBSDMasterNameListType), intent(inout) :: emnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt Calls proc~~jsonreadebsdmasternamelist~~CallsGraph proc~jsonreadebsdmasternamelist JSONreadEBSDMasterNameList proc~jsonreadlogical JSONreadLogical proc~jsonreadebsdmasternamelist->proc~jsonreadlogical proc~getebsdmasternamelist GetEBSDMasterNameList proc~jsonreadebsdmasternamelist->proc~getebsdmasternamelist proc~jsonreadinteger JSONreadInteger proc~jsonreadebsdmasternamelist->proc~jsonreadinteger json_print_error_message json_print_error_message proc~jsonreadebsdmasternamelist->json_print_error_message json_initialize json_initialize proc~jsonreadebsdmasternamelist->json_initialize proc~jsonreadstring JSONreadString proc~jsonreadebsdmasternamelist->proc~jsonreadstring proc~json_failtest JSON_failtest proc~jsonreadebsdmasternamelist->proc~json_failtest proc~jsonreadreal JSONreadReal proc~jsonreadebsdmasternamelist->proc~jsonreadreal json_failed json_failed proc~jsonreadebsdmasternamelist->json_failed emsoft_tonativepath emsoft_tonativepath proc~getebsdmasternamelist->emsoft_tonativepath fatalerror fatalerror proc~getebsdmasternamelist->fatalerror proc~json_failtest->json_print_error_message proc~json_failtest->json_failed sngl sngl proc~jsonreadreal->sngl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONreadEBSDMasterNameList Source Code recursive subroutine JSONreadEBSDMasterNameList ( emnl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadEBSDMasterNameList use ISO_C_BINDING use NameListHandlers IMPLICIT NONE type ( EBSDMasterNameListType ), INTENT ( INOUT ) :: emnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_file ) :: json !the JSON structure read from the file: type ( EBSDMasterNameListType ) :: defemnl logical :: init = . TRUE . character ( fnlen ) :: nmlfile = '' , ep , s , s2 real ( kind = wp ) :: rval character ( kind = jsonCK , len = :), allocatable :: cval real ( wp ), dimension (:), allocatable :: rvec ! first of all, open the file and return an error message if it does not exist error_cnt = 0 call json_initialize (); call JSON_failtest ( error_cnt ) ! populate the json structure call json % load_file ( filename = trim ( jsonname )) if ( json_failed (). eqv .. TRUE .) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! ok, we got here so we need to initialize the namelist first to its default values (set in NameListHandlers) call GetEBSDMasterNameList ( nmlfile , defemnl , initonly = init ) ! then we start reading the values in the json file ep = 'EBSDmastervars.stdout' call JSONreadInteger ( json , ep , emnl % stdout , defemnl % stdout ) ep = 'EBSDmastervars.npx' call JSONreadInteger ( json , ep , emnl % npx , defemnl % npx ) ep = 'EBSDmastervars.Esel' call JSONreadInteger ( json , ep , emnl % Esel , defemnl % Esel ) ep = 'EBSDmastervars.nthreads' call JSONreadInteger ( json , ep , emnl % nthreads , defemnl % nthreads ) ep = 'EBSDmastervars.dmin' call JSONreadReal ( json , ep , emnl % dmin , defemnl % dmin ) ep = 'EBSDmastervars.energyfile' call JSONreadString ( json , ep , emnl % energyfile , defemnl % energyfile ) ep = 'EBSDmastervars.outname' call JSONreadString ( json , ep , emnl % outname , defemnl % outname ) ep = 'EBSDmastervars.restart' call JSONreadLogical ( json , ep , emnl % restart , defemnl % restart ) end if call json % destroy (); call JSON_failtest ( error_cnt ) end subroutine JSONreadEBSDMasterNameList","tags":"","loc":"proc/jsonreadebsdmasternamelist.html","title":"JSONreadEBSDMasterNameList – Fortran Program"},{"text":"public recursive subroutine JSONreadEBSDclusterNameList(emnl, jsonname, error_cnt) Uses: iso_c_binding NameListHandlers proc~~jsonreadebsdclusternamelist~~UsesGraph proc~jsonreadebsdclusternamelist JSONreadEBSDclusterNameList iso_c_binding iso_c_binding iso_c_binding->proc~jsonreadebsdclusternamelist module~namelisthandlers NameListHandlers module~namelisthandlers->proc~jsonreadebsdclusternamelist local local local->module~namelisthandlers module~namelisttypedefs NameListTypedefs local->module~namelisttypedefs module~namelisttypedefs->module~namelisthandlers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read json file and fill emnl structure (used by EMEBSDcluster.f90)\n @param emnl EBSD cluster name list structure\n @param jsonname input file name\n @param error_cnt total number of errors encountered by json routines\n @date 12/28/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(EBSDclusterNameListType), intent(inout) :: emnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt Calls proc~~jsonreadebsdclusternamelist~~CallsGraph proc~jsonreadebsdclusternamelist JSONreadEBSDclusterNameList proc~jsonreadstring JSONreadString proc~jsonreadebsdclusternamelist->proc~jsonreadstring proc~jsonreadinteger JSONreadInteger proc~jsonreadebsdclusternamelist->proc~jsonreadinteger json_print_error_message json_print_error_message proc~jsonreadebsdclusternamelist->json_print_error_message json_initialize json_initialize proc~jsonreadebsdclusternamelist->json_initialize proc~json_failtest JSON_failtest proc~jsonreadebsdclusternamelist->proc~json_failtest proc~getebsdclusternamelist GetEBSDclusterNameList proc~jsonreadebsdclusternamelist->proc~getebsdclusternamelist json_failed json_failed proc~jsonreadebsdclusternamelist->json_failed proc~json_failtest->json_print_error_message proc~json_failtest->json_failed emsoft_tonativepath emsoft_tonativepath proc~getebsdclusternamelist->emsoft_tonativepath fatalerror fatalerror proc~getebsdclusternamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONreadEBSDclusterNameList Source Code recursive subroutine JSONreadEBSDclusterNameList ( emnl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadEBSDclusterNameList use ISO_C_BINDING use NameListHandlers IMPLICIT NONE type ( EBSDclusterNameListType ), INTENT ( INOUT ) :: emnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_file ) :: json !the JSON structure read from the file: type ( EBSDclusterNameListType ) :: defemnl logical :: init = . TRUE . character ( fnlen ) :: nmlfile = '' , ep , s , s2 real ( kind = wp ) :: rval character ( kind = jsonCK , len = :), allocatable :: cval real ( wp ), dimension (:), allocatable :: rvec ! first of all, open the file and return an error message if it does not exist error_cnt = 0 call json_initialize (); call JSON_failtest ( error_cnt ) ! populate the json structure call json % load_file ( filename = trim ( jsonname )) if ( json_failed (). eqv .. TRUE .) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! ok, we got here so we need to initialize the namelist first to its default values (set in NameListHandlers) call GetEBSDclusterNameList ( nmlfile , defemnl , initonly = init ) ! then we start reading the values in the json file ep = 'EBSDclustervars.NClusters' call JSONreadInteger ( json , ep , emnl % NClusters , defemnl % NClusters ) ep = 'EBSDclustervars.NIterations' call JSONreadInteger ( json , ep , emnl % NIterations , defemnl % NIterations ) ep = 'EBSDclustervars.inputfilename' call JSONreadString ( json , ep , emnl % inputfilename , defemnl % inputfilename ) ep = 'EBSDclustervars.groupname' call JSONreadString ( json , ep , emnl % groupname , defemnl % groupname ) ep = 'EBSDclustervars.datasetname' call JSONreadString ( json , ep , emnl % datasetname , defemnl % datasetname ) end if call json % destroy (); call JSON_failtest ( error_cnt ) end subroutine JSONreadEBSDclusterNameList","tags":"","loc":"proc/jsonreadebsdclusternamelist.html","title":"JSONreadEBSDclusterNameList – Fortran Program"},{"text":"public recursive subroutine JSONreadECPMasterNameList(ecpnl, jsonname, error_cnt) Uses: iso_c_binding NameListHandlers proc~~jsonreadecpmasternamelist~~UsesGraph proc~jsonreadecpmasternamelist JSONreadECPMasterNameList iso_c_binding iso_c_binding iso_c_binding->proc~jsonreadecpmasternamelist module~namelisthandlers NameListHandlers module~namelisthandlers->proc~jsonreadecpmasternamelist local local local->module~namelisthandlers module~namelisttypedefs NameListTypedefs local->module~namelisttypedefs module~namelisttypedefs->module~namelisthandlers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh/Marc De Graef, Carnegie Mellon University\n @brief read json file and fill mcnl structure (used by EMECPmaster.f90)\n @param emnl ECP master name list structure\n @param jsonname input file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/20/15  MDG 1.0 new routine\n @date 09/15/15  SS  1.1 changes after clean up of ECPmasterListType Arguments Type Intent Optional Attributes Name type(ECPMasterNameListType), intent(inout) :: ecpnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt Calls proc~~jsonreadecpmasternamelist~~CallsGraph proc~jsonreadecpmasternamelist JSONreadECPMasterNameList json_failed json_failed proc~jsonreadecpmasternamelist->json_failed proc~jsonreadstring JSONreadString proc~jsonreadecpmasternamelist->proc~jsonreadstring proc~jsonreadinteger JSONreadInteger proc~jsonreadecpmasternamelist->proc~jsonreadinteger json_print_error_message json_print_error_message proc~jsonreadecpmasternamelist->json_print_error_message proc~getecpmasternamelist GetECPMasterNameList proc~jsonreadecpmasternamelist->proc~getecpmasternamelist proc~json_failtest JSON_failtest proc~jsonreadecpmasternamelist->proc~json_failtest proc~jsonreadreal JSONreadReal proc~jsonreadecpmasternamelist->proc~jsonreadreal json_initialize json_initialize proc~jsonreadecpmasternamelist->json_initialize emsoft_tonativepath emsoft_tonativepath proc~getecpmasternamelist->emsoft_tonativepath fatalerror fatalerror proc~getecpmasternamelist->fatalerror proc~json_failtest->json_failed proc~json_failtest->json_print_error_message sngl sngl proc~jsonreadreal->sngl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONreadECPMasterNameList Source Code recursive subroutine JSONreadECPMasterNameList ( ecpnl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadECPMasterNameList use ISO_C_BINDING use NameListHandlers IMPLICIT NONE type ( ECPMasterNameListType ), INTENT ( INOUT ) :: ecpnl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_file ) :: json !the JSON structure read from the file: type ( ECPMasterNameListType ) :: defecpnl logical :: init = . TRUE . character ( fnlen ) :: nmlfile = '' , ep , s , s2 real ( kind = wp ) :: rval character ( kind = jsonCK , len = :), allocatable :: cval real ( wp ), dimension (:), allocatable :: rvec ! first of all, open the file and return an error message if it does not exist error_cnt = 0 call json_initialize (); call JSON_failtest ( error_cnt ) ! populate the json structure call json % load_file ( filename = trim ( jsonname )) if ( json_failed (). eqv .. TRUE .) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! ok, we got here so we need to initialize the namelist first to its default values (set in NameListHandlers) call GetECPMasterNameList ( nmlfile , defecpnl , initonly = init ) ! then we start reading the values in the json file ep = 'ECPmastervars.stdout' call JSONreadInteger ( json , ep , ecpnl % stdout , defecpnl % stdout ) ep = 'ECPmastervars.npx' call JSONreadInteger ( json , ep , ecpnl % npx , defecpnl % npx ) ep = 'ECPmastervars.Esel' call JSONreadInteger ( json , ep , ecpnl % Esel , defecpnl % Esel ) ep = 'ECPmastervars.nthreads' call JSONreadInteger ( json , ep , ecpnl % nthreads , defecpnl % nthreads ) !ep = 'ECPmastervars.startthick' !call JSONreadReal(json, ep, ecpnl%startthick, defecpnl%startthick) ep = 'ECPmastervars.dmin' call JSONreadReal ( json , ep , ecpnl % dmin , defecpnl % dmin ) !ep = 'ECPmastervars.fn' !call JSONreadRealVec(json, ep, ecpnl%fn, defecpnl%fn, size(ecpnl%fn)) !ep = 'ECPmastervars.abcdist' !call JSONreadRealVec(json, ep, ecpnl%abcdist, defecpnl%abcdist, size(ecpnl%abcdist)) !ep = 'ECPmastervars.albegadist' !call JSONreadRealVec(json, ep, ecpnl%albegadist, defecpnl%albegadist, size(ecpnl%albegadist)) ep = 'ECPmastervars.compmode' call JSONreadString ( json , ep , ecpnl % compmode , defecpnl % compmode ) ep = 'ECPmastervars.energyfile' call JSONreadString ( json , ep , ecpnl % energyfile , defecpnl % energyfile ) ep = 'ECPmastervars.outname' call JSONreadString ( json , ep , ecpnl % outname , defecpnl % outname ) !ep = 'ECPmastervars.distort' !call JSONreadLogical(json, ep, ecpnl%distort, defecpnl%distort) end if call json % destroy (); call JSON_failtest ( error_cnt ) end subroutine JSONreadECPMasterNameList","tags":"","loc":"proc/jsonreadecpmasternamelist.html","title":"JSONreadECPMasterNameList – Fortran Program"},{"text":"public recursive subroutine JSONreadEBSDNameList(enl, jsonname, error_cnt) Uses: iso_c_binding NameListHandlers error proc~~jsonreadebsdnamelist~~UsesGraph proc~jsonreadebsdnamelist JSONreadEBSDNameList iso_c_binding iso_c_binding iso_c_binding->proc~jsonreadebsdnamelist error error error->proc~jsonreadebsdnamelist module~namelisthandlers NameListHandlers module~namelisthandlers->proc~jsonreadebsdnamelist local local local->module~namelisthandlers module~namelisttypedefs NameListTypedefs local->module~namelisttypedefs module~namelisttypedefs->module~namelisthandlers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read json file and fill enl structure (used by EMEBSD.f90)\n @param enl EBSD name list structure\n @param jsonname input file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/20/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(EBSDNameListType), intent(inout) :: enl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt Calls proc~~jsonreadebsdnamelist~~CallsGraph proc~jsonreadebsdnamelist JSONreadEBSDNameList proc~jsonreaddouble JSONreadDouble proc~jsonreadebsdnamelist->proc~jsonreaddouble proc~jsonreadstring JSONreadString proc~jsonreadebsdnamelist->proc~jsonreadstring proc~jsonreadinteger JSONreadInteger proc~jsonreadebsdnamelist->proc~jsonreadinteger json_print_error_message json_print_error_message proc~jsonreadebsdnamelist->json_print_error_message proc~jsonreadrealvec JSONreadRealVec proc~jsonreadebsdnamelist->proc~jsonreadrealvec json_initialize json_initialize proc~jsonreadebsdnamelist->json_initialize proc~getebsdnamelist GetEBSDNameList proc~jsonreadebsdnamelist->proc~getebsdnamelist proc~json_failtest JSON_failtest proc~jsonreadebsdnamelist->proc~json_failtest proc~jsonreadreal JSONreadReal proc~jsonreadebsdnamelist->proc~jsonreadreal json_failed json_failed proc~jsonreadebsdnamelist->json_failed sngl sngl proc~jsonreadrealvec->sngl emsoft_tonativepath emsoft_tonativepath proc~getebsdnamelist->emsoft_tonativepath fatalerror fatalerror proc~getebsdnamelist->fatalerror proc~json_failtest->json_print_error_message proc~json_failtest->json_failed proc~jsonreadreal->sngl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONreadEBSDNameList Source Code recursive subroutine JSONreadEBSDNameList ( enl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadEBSDNameList use ISO_C_BINDING use NameListHandlers use error IMPLICIT NONE type ( EBSDNameListType ), INTENT ( INOUT ) :: enl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_file ) :: json !the JSON structure read from the file: type ( EBSDNameListType ) :: defenl logical :: init = . TRUE . character ( fnlen ) :: nmlfile = '' , ep , s , s2 real ( kind = wp ) :: rval character ( kind = jsonCK , len = :), allocatable :: cval real ( wp ), dimension (:), allocatable :: rvec ! first of all, open the file and return an error message if it does not exist error_cnt = 0 call json_initialize (); call JSON_failtest ( error_cnt ) ! populate the json structure call json % load_file ( filename = trim ( jsonname )) if ( json_failed (). eqv .. TRUE .) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! ok, we got here so we need to initialize the namelist first to its default values (set in NameListHandlers) call GetEBSDNameList ( nmlfile , defenl , initonly = init ) ep = 'EBSDdata.stdout' call JSONreadInteger ( json , ep , enl % stdout , defenl % stdout ) ep = 'EBSDdata.numsx' call JSONreadInteger ( json , ep , enl % numsx , defenl % numsx ) ep = 'EBSDdata.numsy' call JSONreadInteger ( json , ep , enl % numsy , defenl % numsy ) ep = 'EBSDdata.binning' call JSONreadInteger ( json , ep , enl % binning , defenl % binning ) ep = 'EBSDdata.nthreads' call JSONreadInteger ( json , ep , enl % nthreads , defenl % nthreads ) ep = 'EBSDdata.energyaverage' call JSONreadInteger ( json , ep , enl % energyaverage , defenl % energyaverage ) ep = 'EBSDdata.L' call JSONreadReal ( json , ep , enl % L , defenl % L ) ep = 'EBSDdata.thetac' call JSONreadReal ( json , ep , enl % thetac , defenl % thetac ) ep = 'EBSDdata.delta' call JSONreadReal ( json , ep , enl % delta , defenl % delta ) ep = 'EBSDdata.xpc' call JSONreadReal ( json , ep , enl % xpc , defenl % xpc ) ep = 'EBSDdata.ypc' call JSONreadReal ( json , ep , enl % ypc , defenl % ypc ) ep = 'EBSDdata.omega' call JSONreadReal ( json , ep , enl % omega , defenl % omega ) ep = 'EBSDdata.energymin' call JSONreadReal ( json , ep , enl % energymin , defenl % energymin ) ep = 'EBSDdata.energymax' call JSONreadReal ( json , ep , enl % energymax , defenl % energymax ) ep = 'EBSDdata.gammavalue' call JSONreadReal ( json , ep , enl % gammavalue , defenl % gammavalue ) ep = 'EBSDdata.axisangle' call JSONreadRealVec ( json , ep , enl % axisangle , defenl % axisangle , size ( enl % axisangle )) ep = 'EBSDdata.beamcurrent' call JSONreadDouble ( json , ep , enl % beamcurrent , defenl % beamcurrent ) ep = 'EBSDdata.dwelltime' call JSONreadDouble ( json , ep , enl % dwelltime , defenl % dwelltime ) ep = 'EBSDdata.maskpattern' s = enl % maskpattern s2 = defenl % maskpattern call JSONreadString ( json , ep , s , s2 ) ep = 'EBSDdata.scalingmode' s = enl % scalingmode s2 = defenl % scalingmode call JSONreadString ( json , ep , s , s2 ) ep = 'EBSDdata.eulerconvention' s = enl % eulerconvention s2 = defenl % eulerconvention call JSONreadString ( json , ep , s , s2 ) ep = 'EBSDdata.outputformat' s = enl % outputformat s2 = defenl % outputformat call JSONreadString ( json , ep , s , s2 ) ep = 'EBSDdata.anglefile' call JSONreadString ( json , ep , enl % anglefile , defenl % anglefile ) ep = 'EBSDdata.masterfile' call JSONreadString ( json , ep , enl % masterfile , defenl % masterfile ) ep = 'EBSDdata.energyfile' call JSONreadString ( json , ep , enl % energyfile , defenl % energyfile ) ep = 'EBSDdata.datafile' call JSONreadString ( json , ep , enl % datafile , defenl % datafile ) end if call json % destroy (); call JSON_failtest ( error_cnt ) end subroutine JSONreadEBSDNameList","tags":"","loc":"proc/jsonreadebsdnamelist.html","title":"JSONreadEBSDNameList – Fortran Program"},{"text":"public recursive subroutine JSONreadEBSDoverlapNameList(enl, jsonname, error_cnt) Uses: iso_c_binding NameListHandlers error proc~~jsonreadebsdoverlapnamelist~~UsesGraph proc~jsonreadebsdoverlapnamelist JSONreadEBSDoverlapNameList iso_c_binding iso_c_binding iso_c_binding->proc~jsonreadebsdoverlapnamelist error error error->proc~jsonreadebsdoverlapnamelist module~namelisthandlers NameListHandlers module~namelisthandlers->proc~jsonreadebsdoverlapnamelist local local local->module~namelisthandlers module~namelisttypedefs NameListTypedefs local->module~namelisttypedefs module~namelisttypedefs->module~namelisthandlers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read jsonfile and fill enl structure (used by EMEBSDoverlap.f90)\n @param enl EBSD name list structure\n @param jsonname input file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/20/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(EBSDoverlapNameListType), intent(inout) :: enl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt Calls proc~~jsonreadebsdoverlapnamelist~~CallsGraph proc~jsonreadebsdoverlapnamelist JSONreadEBSDoverlapNameList proc~getebsdoverlapnamelist GetEBSDoverlapNameList proc~jsonreadebsdoverlapnamelist->proc~getebsdoverlapnamelist proc~jsonreadinteger JSONreadInteger proc~jsonreadebsdoverlapnamelist->proc~jsonreadinteger json_print_error_message json_print_error_message proc~jsonreadebsdoverlapnamelist->json_print_error_message proc~jsonreadrealvec JSONreadRealVec proc~jsonreadebsdoverlapnamelist->proc~jsonreadrealvec json_initialize json_initialize proc~jsonreadebsdoverlapnamelist->json_initialize proc~jsonreadstring JSONreadString proc~jsonreadebsdoverlapnamelist->proc~jsonreadstring proc~jsonreadintegervec JSONreadIntegerVec proc~jsonreadebsdoverlapnamelist->proc~jsonreadintegervec proc~json_failtest JSON_failtest proc~jsonreadebsdoverlapnamelist->proc~json_failtest proc~jsonreadreal JSONreadReal proc~jsonreadebsdoverlapnamelist->proc~jsonreadreal json_failed json_failed proc~jsonreadebsdoverlapnamelist->json_failed emsoft_tonativepath emsoft_tonativepath proc~getebsdoverlapnamelist->emsoft_tonativepath fatalerror fatalerror proc~getebsdoverlapnamelist->fatalerror sngl sngl proc~jsonreadrealvec->sngl proc~json_failtest->json_print_error_message proc~json_failtest->json_failed proc~jsonreadreal->sngl Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code JSONreadEBSDoverlapNameList Source Code recursive subroutine JSONreadEBSDoverlapNameList ( enl , jsonname , error_cnt ) !DEC$ ATTRIBUTES DLLEXPORT :: JSONreadEBSDoverlapNameList use ISO_C_BINDING use NameListHandlers use error IMPLICIT NONE type ( EBSDoverlapNameListType ), INTENT ( INOUT ) :: enl character ( fnlen ), INTENT ( IN ) :: jsonname integer ( kind = irg ), INTENT ( INOUT ) :: error_cnt type ( json_file ) :: json !the JSON structure read from the file: type ( EBSDoverlapNameListType ) :: defenl logical :: init = . TRUE . character ( fnlen ) :: nmlfile = '' , ep , s , s2 real ( kind = wp ) :: rval character ( kind = jsonCK , len = :), allocatable :: cval real ( wp ), dimension (:), allocatable :: rvec ! first of all, open the file and return an error message if it does not exist error_cnt = 0 call json_initialize (); call JSON_failtest ( error_cnt ) ! populate the json structure call json % load_file ( filename = trim ( jsonname )) if ( json_failed (). eqv .. TRUE .) then !if there was an error reading the file call json_print_error_message ( error_unit ) error_cnt = error_cnt + 1 else ! ok, we got here so we need to initialize the namelist first to its default values (set in NameListHandlers) call GetEBSDoverlapNameList ( nmlfile , defenl , initonly = init ) ep = 'EBSDdata.stdout' call JSONreadInteger ( json , ep , enl % stdout , defenl % stdout ) ep = 'EBSDdata.PatternAxisA' call JSONreadIntegerVec ( json , ep , enl % PatternAxisA , defenl % PatternAxisA , size ( defenl % PatternAxisA )) ep = 'EBSDdata.HorizontalAxisA' call JSONreadIntegerVec ( json , ep , enl % HorizontalAxisA , defenl % HorizontalAxisA , size ( defenl % HorizontalAxisA )) ep = 'EBSDdata.tA' call JSONreadRealVec ( json , ep , enl % tA , defenl % tA , size ( enl % tA )) ep = 'EBSDdata.tB' call JSONreadRealVec ( json , ep , enl % tB , defenl % tB , size ( enl % tB )) ep = 'EBSDdata.gA' call JSONreadRealVec ( json , ep , enl % gA , defenl % gA , size ( enl % gA )) ep = 'EBSDdata.gB' call JSONreadRealVec ( json , ep , enl % gB , defenl % gB , size ( enl % gB )) ep = 'EBSDdata.fracA' call JSONreadReal ( json , ep , enl % fracA , defenl % fracA ) ep = 'EBSDdata.masterfileA' call JSONreadString ( json , ep , enl % masterfileA , defenl % masterfileA ) ep = 'EBSDdata.masterfileB' call JSONreadString ( json , ep , enl % masterfileB , defenl % masterfileB ) ep = 'EBSDdata.datafile' call JSONreadString ( json , ep , enl % datafile , defenl % datafile ) end if call json % destroy (); call JSON_failtest ( error_cnt ) end subroutine JSONreadEBSDoverlapNameList","tags":"","loc":"proc/jsonreadebsdoverlapnamelist.html","title":"JSONreadEBSDoverlapNameList – Fortran Program"},{"text":"public recursive function MC_get_basicMuellerMatrix(MMtype) result(res) Uses: io proc~~mc_get_basicmuellermatrix~~UsesGraph proc~mc_get_basicmuellermatrix MC_get_basicMuellerMatrix io io io->proc~mc_get_basicmuellermatrix Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief returns a basic 4x4 Mueller matrix by type\n @param MMtype integer describing the optical element (0 prduces list)\n @date   02/14/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: MMtype Return Value type(MuellerMatrixType) Calls proc~~mc_get_basicmuellermatrix~~CallsGraph proc~mc_get_basicmuellermatrix MC_get_basicMuellerMatrix message message proc~mc_get_basicmuellermatrix->message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code MC_get_basicMuellerMatrix Source Code recursive function MC_get_basicMuellerMatrix ( MMtype ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_get_basicMuellerMatrix use io IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: MMtype type ( MuellerMatrixType ) :: res select case ( MMtype ) case ( 0 ) call Message ( 'The following basic Mueller matrix types are available:' ) call Message ( '1: linear horizontal polarizer (along x)' ) call Message ( '2: linear vertical polarizer (along y)' ) call Message ( '3: linear polarizer at +45°' ) call Message ( '4: linear polarizer at -45°' ) call Message ( '5: quarter-wave plate, fast axis vertical' ) call Message ( '6: quarter-wave plate, fast axis horizontal' ) call Message ( '7: circular polarizer, right-handed' ) call Message ( '8: circular polarizer, left-handed' ) case ( 1 ) res % descriptor = 'linear horizontal polarizer' res % M ( 1 , 1 : 4 ) = ( / 1.D0 , 1.D0 , 0.D0 , 0.D0 / ) res % M ( 2 , 1 : 4 ) = ( / 1.D0 , 1.D0 , 0.D0 , 0.D0 / ) res % M ( 3 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M ( 4 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M = 0.5D0 * res % M case ( 2 ) res % descriptor = 'linear vertical polarizer' res % M ( 1 , 1 : 4 ) = ( / 1.D0 , - 1.D0 , 0.D0 , 0.D0 / ) res % M ( 2 , 1 : 4 ) = ( /- 1.D0 , 1.D0 , 0.D0 , 0.D0 / ) res % M ( 3 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M ( 4 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M = 0.5D0 * res % M case ( 3 ) res % descriptor = 'linear polarizer at +45°' res % M ( 1 , 1 : 4 ) = ( / 1.D0 , 0.D0 , 1.D0 , 0.D0 / ) res % M ( 2 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M ( 3 , 1 : 4 ) = ( / 1.D0 , 0.D0 , 1.D0 , 0.D0 / ) res % M ( 4 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M = 0.5D0 * res % M case ( 4 ) res % descriptor = 'linear polarizer at -45°' res % M ( 1 , 1 : 4 ) = ( / 1.D0 , 0.D0 , - 1.D0 , 0.D0 / ) res % M ( 2 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M ( 3 , 1 : 4 ) = ( /- 1.D0 , 0.D0 , 1.D0 , 0.D0 / ) res % M ( 4 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M = 0.5D0 * res % M case ( 5 ) res % descriptor = 'quarter-wave plate, fast axis vertical' res % M ( 1 , 1 : 4 ) = ( / 1.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M ( 2 , 1 : 4 ) = ( / 0.D0 , 1.D0 , 0.D0 , 0.D0 / ) res % M ( 3 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , - 1.D0 / ) res % M ( 4 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 1.D0 , 0.D0 / ) case ( 6 ) res % descriptor = 'quarter-wave plate, fast axis horizontal' res % M ( 1 , 1 : 4 ) = ( / 1.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M ( 2 , 1 : 4 ) = ( / 0.D0 , 1.D0 , 0.D0 , 0.D0 / ) res % M ( 3 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , 1.D0 / ) res % M ( 4 , 1 : 4 ) = ( / 0.D0 , 0.D0 , - 1.D0 , 0.D0 / ) case ( 7 ) res % descriptor = 'circular polarizer, right-handed' res % M ( 1 , 1 : 4 ) = ( / 1.D0 , 0.D0 , 0.D0 , 1.D0 / ) res % M ( 2 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M ( 3 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M ( 4 , 1 : 4 ) = ( / 1.D0 , 0.D0 , 0.D0 , 1.D0 / ) res % M = 0.5D0 * res % M case ( 8 ) res % descriptor = 'circular polarizer, left-handed' res % M ( 1 , 1 : 4 ) = ( / 1.D0 , 0.D0 , 0.D0 , - 1.D0 / ) res % M ( 2 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M ( 3 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M ( 4 , 1 : 4 ) = ( /- 1.D0 , 0.D0 , 0.D0 , 1.D0 / ) res % M = 0.5D0 * res % M case default end select end function MC_get_basicMuellerMatrix","tags":"","loc":"proc/mc_get_basicmuellermatrix.html","title":"MC_get_basicMuellerMatrix – Fortran Program"},{"text":"public recursive function MC_get_diattenuator(px, py, polar) result(res) @author Marc De Graef, Carnegie Mellon University\n @brief returns a 4x4 Mueller matrix for a diattenuator (polarizer)\n @param px amplitude attenuation coefficient along x or magnitude of vector p\n @param py amplitude attenuation coefficient along y or polar angle of vector p\n @param polar (OPTIONAL) absent/FALSE: cartesian components; TRUE: polar components of px + i py = (p, alpha)\n @date   02/12/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: px real(kind=dbl), intent(in) :: py logical, intent(in), optional :: polar Return Value type(MuellerMatrixType) Calls proc~~mc_get_diattenuator~~CallsGraph proc~mc_get_diattenuator MC_get_diattenuator fatalerror fatalerror proc~mc_get_diattenuator->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code MC_get_diattenuator Source Code recursive function MC_get_diattenuator ( px , py , polar ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_get_diattenuator IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: px real ( kind = dbl ), INTENT ( IN ) :: py logical , OPTIONAL , INTENT ( IN ) :: polar type ( MuellerMatrixType ) :: res logical :: usepolar ! initialize a Mueller matrix for a diattenuator res % descriptor = 'diattenuator' usepolar = . FALSE . if ( present ( polar )) then if ( polar . eqv .. TRUE .) usepolar = . TRUE . end if if ( usepolar ) then if (( px . lt . 0.D0 ). or .( px . gt . 1.D0 )) then call FatalError ( 'MC_get_diattenuator' , 'attenuation magnitude must lie in range [0,1]' ) end if res % M ( 1 , 1 : 4 ) = ( / 1.D0 , cos ( 2.D0 * py ), 0.D0 , 0.D0 / ) res % M ( 2 , 1 : 4 ) = ( / cos ( 2.D0 * py ), 1.D0 , 0.D0 , 0.D0 / ) res % M ( 3 , 1 : 4 ) = ( / 0.D0 , 0.D0 , sin ( 2.D0 * py ), 0.D0 / ) res % M ( 4 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , sin ( 2.D0 * py ) / ) res % M = 0.5D0 * px * px * res % M else if (( minval (( / px , py / )). lt . 0.D0 ). or .( maxval (( / px , py / )). gt . 1.D0 )) then call FatalError ( 'MC_get_diattenuator' , 'attenuation factors must lie in range [0,1]' ) end if res % M ( 1 , 1 : 4 ) = ( / px * px + py * py , px * px - py * py , 0.D0 , 0.D0 / ) res % M ( 2 , 1 : 4 ) = ( / px * px - py * py , px * px + py * py , 0.D0 , 0.D0 / ) res % M ( 3 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 2.D0 * px * py , 0.D0 / ) res % M ( 4 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , 2.D0 * px * py / ) res % M = 0.5D0 * res % M end if end function MC_get_diattenuator","tags":"","loc":"proc/mc_get_diattenuator.html","title":"MC_get_diattenuator – Fortran Program"},{"text":"public recursive function MC_get_rotator(theta) result(res) @author Marc De Graef, Carnegie Mellon University\n @brief returns a 4x4 Mueller matrix for a rotator\n @param theta rotator angle (radians)\n @date   02/12/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: theta Return Value type(MuellerMatrixType) Called By proc~~mc_get_rotator~~CalledByGraph proc~mc_get_rotator MC_get_rotator proc~mc_rotate_muellermatrix MC_rotate_MuellerMatrix proc~mc_rotate_muellermatrix->proc~mc_get_rotator Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code MC_get_rotator Source Code recursive function MC_get_rotator ( theta ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_get_rotator IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: theta type ( MuellerMatrixType ) :: res real ( kind = dbl ) :: ct , st ct = cos ( 2.D0 * theta ) st = sin ( 2.D0 * theta ) ! initialize a Mueller matrix for a rotator res % descriptor = 'rotator' res % M ( 1 , 1 : 4 ) = ( / 1.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M ( 2 , 1 : 4 ) = ( / 0.D0 , ct , st , 0.D0 / ) res % M ( 3 , 1 : 4 ) = ( / 0.D0 , - st , ct , 0.D0 / ) res % M ( 4 , 1 : 4 ) = ( / 0.D0 , 0.D0 , 0.D0 , 1.D0 / ) end function MC_get_rotator","tags":"","loc":"proc/mc_get_rotator.html","title":"MC_get_rotator – Fortran Program"},{"text":"public recursive function MC_get_retarder(phi) result(res) @author Marc De Graef, Carnegie Mellon University\n @brief returns a 4x4 Mueller matrix for a retarder\n @param phi retardation angle (radians)\n @date   02/12/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: phi Return Value type(MuellerMatrixType) Source Code MC_get_retarder Source Code recursive function MC_get_retarder ( phi ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_get_retarder IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: phi type ( MuellerMatrixType ) :: res real ( kind = dbl ) :: cp , sp cp = cos ( phi ) sp = sin ( phi ) ! initialize a Mueller matrix for a retarder res % descriptor = 'retarder' res % M ( 1 , 1 : 4 ) = ( / 1.D0 , 0.D0 , 0.D0 , 0.D0 / ) res % M ( 2 , 1 : 4 ) = ( / 0.D0 , 1.D0 , 0.D0 , 0.D0 / ) res % M ( 3 , 1 : 4 ) = ( / 0.D0 , 0.D0 , cp , - sp / ) res % M ( 4 , 1 : 4 ) = ( / 0.D0 , 0.D0 , sp , cp / ) end function MC_get_retarder","tags":"","loc":"proc/mc_get_retarder.html","title":"MC_get_retarder – Fortran Program"},{"text":"public recursive function MC_rotate_MuellerMatrix(MM, theta) result(res) @author Marc De Graef, Carnegie Mellon University\n @param MM input Mueller matrix\n @param theta rotation angle (radians)\n @date   02/12/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name type(MuellerMatrixType), intent(in) :: MM real(kind=dbl), intent(in) :: theta Return Value type(MuellerMatrixType) Calls proc~~mc_rotate_muellermatrix~~CallsGraph proc~mc_rotate_muellermatrix MC_rotate_MuellerMatrix proc~mc_get_rotator MC_get_rotator proc~mc_rotate_muellermatrix->proc~mc_get_rotator Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code MC_rotate_MuellerMatrix Source Code recursive function MC_rotate_MuellerMatrix ( MM , theta ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_rotate_MuellerMatrix IMPLICIT NONE type ( MuellerMatrixType ), INTENT ( IN ) :: MM real ( kind = dbl ), INTENT ( IN ) :: theta type ( MuellerMatrixType ) :: res type ( MuellerMatrixType ) :: Mrot ! initialize the output Mueller matrix descriptor res % descriptor = trim ( MM % descriptor ) // '-rotated' Mrot = MC_get_rotator ( theta ) res % M = matmul ( transpose ( Mrot % M ), matmul ( MM % M , Mrot % M )) end function MC_rotate_MuellerMatrix","tags":"","loc":"proc/mc_rotate_muellermatrix.html","title":"MC_rotate_MuellerMatrix – Fortran Program"},{"text":"public recursive function MC_propagateStokesVector(MM, SV, descriptor) result(res) @author Marc De Graef, Carnegie Mellon University\n @brief multiplies a Stokes vector by a Mueller matrix \n @param MM Mueller matrix structure\n @param SV Stokes vector structure\n @param descriptor string to describe the state of the Stokes vector\n @date   02/12/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name type(MuellerMatrixType), intent(in) :: MM type(StokesVectorType), intent(in) :: SV character(len=fnlen), intent(in) :: descriptor Return Value type(StokesVectorType) Source Code MC_propagateStokesVector Source Code recursive function MC_propagateStokesVector ( MM , SV , descriptor ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_propagateStokesVector IMPLICIT NONE type ( MuellerMatrixType ), INTENT ( IN ) :: MM type ( StokesVectorType ), INTENT ( IN ) :: SV character ( fnlen ), INTENT ( IN ) :: descriptor type ( StokesVectorType ) :: res res % S = matmul ( MM % M , SV % S ) res % descriptor = trim ( descriptor ) end function MC_propagateStokesVector","tags":"","loc":"proc/mc_propagatestokesvector.html","title":"MC_propagateStokesVector – Fortran Program"},{"text":"public recursive function MC_concatenateMuellerMatrices(MM1, MM2) result(res) @author Marc De Graef, Carnegie Mellon University\n @brief multiplies a Mueller matrix M1 by M2, in the order  M2 x M1\n @param MM1 Mueller matrix structure (earlier in the optical path)\n @param MM2 Mueller matrix structure (later in the optical path)\n @date   02/14/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name type(MuellerMatrixType), intent(in) :: MM1 type(MuellerMatrixType), intent(in) :: MM2 Return Value type(MuellerMatrixType) Source Code MC_concatenateMuellerMatrices Source Code recursive function MC_concatenateMuellerMatrices ( MM1 , MM2 ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_concatenateMuellerMatrices IMPLICIT NONE type ( MuellerMatrixType ), INTENT ( IN ) :: MM1 type ( MuellerMatrixType ), INTENT ( IN ) :: MM2 type ( MuellerMatrixType ) :: res res % M = matmul ( MM2 % M , MM1 % M ) res % descriptor = trim ( MM1 % descriptor ) // '->' // trim ( MM2 % descriptor ) end function MC_concatenateMuellerMatrices","tags":"","loc":"proc/mc_concatenatemuellermatrices.html","title":"MC_concatenateMuellerMatrices – Fortran Program"},{"text":"public recursive function MC_get_EllipticityAngle(SV) result(res) Uses: constants io proc~~mc_get_ellipticityangle~~UsesGraph proc~mc_get_ellipticityangle MC_get_EllipticityAngle io io io->proc~mc_get_ellipticityangle module~constants constants module~constants->proc~mc_get_ellipticityangle local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief extracts the ellipticity angle from a Stokes vector\n @param SV Stokes vector structure\n @date   02/12/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name type(StokesVectorType), intent(in) :: SV Return Value real(kind=dbl) Calls proc~~mc_get_ellipticityangle~~CallsGraph proc~mc_get_ellipticityangle MC_get_EllipticityAngle writevalue writevalue proc~mc_get_ellipticityangle->writevalue fatalerror fatalerror proc~mc_get_ellipticityangle->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~mc_get_ellipticityangle~~CalledByGraph proc~mc_get_ellipticityangle MC_get_EllipticityAngle proc~mc_get_phaseshiftangle MC_get_PhaseShiftAngle proc~mc_get_phaseshiftangle->proc~mc_get_ellipticityangle proc~mc_get_auxiliaryangle MC_get_AuxiliaryAngle proc~mc_get_auxiliaryangle->proc~mc_get_ellipticityangle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code MC_get_EllipticityAngle Source Code recursive function MC_get_EllipticityAngle ( SV ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_get_EllipticityAngle use constants use io IMPLICIT NONE type ( StokesVectorType ), INTENT ( IN ) :: SV real ( kind = dbl ) :: res real ( kind = dbl ) :: p4 , io_double ( 1 ) p4 = cPi * 0.25D0 res = 0.5D0 * asin ( SV % S ( 3 ) / SV % S ( 0 )) if ( abs ( res ). gt . p4 ) then io_double ( 1 ) = res call WriteValue ( 'Ellipticity angle = ' , io_double , 1 ) call FatalError ( 'MC_get_EllipticityAngle' , 'Ellipticity angle does not lie in range [-pi/4,pi/4]' ) end if end function MC_get_EllipticityAngle","tags":"","loc":"proc/mc_get_ellipticityangle.html","title":"MC_get_EllipticityAngle – Fortran Program"},{"text":"public recursive function MC_get_OrientationAngle(SV) result(res) Uses: constants proc~~mc_get_orientationangle~~UsesGraph proc~mc_get_orientationangle MC_get_OrientationAngle module~constants constants module~constants->proc~mc_get_orientationangle local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief extracts the polarization ellipse orientation angle from a Stokes vector\n @param SV Stokes vector structure\n @date   02/12/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name type(StokesVectorType), intent(in) :: SV Return Value real(kind=dbl) Called By proc~~mc_get_orientationangle~~CalledByGraph proc~mc_get_orientationangle MC_get_OrientationAngle proc~mc_get_phaseshiftangle MC_get_PhaseShiftAngle proc~mc_get_phaseshiftangle->proc~mc_get_orientationangle proc~mc_get_auxiliaryangle MC_get_AuxiliaryAngle proc~mc_get_auxiliaryangle->proc~mc_get_orientationangle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code MC_get_OrientationAngle Source Code recursive function MC_get_OrientationAngle ( SV ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_get_OrientationAngle use constants IMPLICIT NONE type ( StokesVectorType ), INTENT ( IN ) :: SV real ( kind = dbl ) :: res res = 0.5D0 * atan2 ( SV % S ( 2 ), SV % S ( 1 )) res = mod ( res + 2.D0 * cPi , cPi ) end function MC_get_OrientationAngle","tags":"","loc":"proc/mc_get_orientationangle.html","title":"MC_get_OrientationAngle – Fortran Program"},{"text":"public recursive function MC_get_AuxiliaryAngle(SV) result(res) Uses: constants io proc~~mc_get_auxiliaryangle~~UsesGraph proc~mc_get_auxiliaryangle MC_get_AuxiliaryAngle io io io->proc~mc_get_auxiliaryangle module~constants constants module~constants->proc~mc_get_auxiliaryangle local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief extracts the auxiliary angle from a Stokes vector\n @param SV Stokes vector structure\n @date   02/13/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name type(StokesVectorType), intent(in) :: SV Return Value real(kind=dbl) Calls proc~~mc_get_auxiliaryangle~~CallsGraph proc~mc_get_auxiliaryangle MC_get_AuxiliaryAngle proc~mc_get_ad_from_eo MC_get_AD_from_EO proc~mc_get_auxiliaryangle->proc~mc_get_ad_from_eo proc~mc_get_ellipticityangle MC_get_EllipticityAngle proc~mc_get_auxiliaryangle->proc~mc_get_ellipticityangle proc~mc_get_orientationangle MC_get_OrientationAngle proc~mc_get_auxiliaryangle->proc~mc_get_orientationangle writevalue writevalue proc~mc_get_ellipticityangle->writevalue fatalerror fatalerror proc~mc_get_ellipticityangle->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code MC_get_AuxiliaryAngle Source Code recursive function MC_get_AuxiliaryAngle ( SV ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_get_AuxiliaryAngle use constants use io IMPLICIT NONE type ( StokesVectorType ), INTENT ( IN ) :: SV real ( kind = dbl ) :: res real ( kind = dbl ) :: psi , chi , alpha , delta chi = MC_get_EllipticityAngle ( SV ) psi = MC_get_OrientationAngle ( SV ) call MC_get_AD_from_EO ( chi , psi , alpha , delta ) res = alpha end function MC_get_AuxiliaryAngle","tags":"","loc":"proc/mc_get_auxiliaryangle.html","title":"MC_get_AuxiliaryAngle – Fortran Program"},{"text":"public recursive function MC_get_PhaseShiftAngle(SV) result(res) Uses: constants io proc~~mc_get_phaseshiftangle~~UsesGraph proc~mc_get_phaseshiftangle MC_get_PhaseShiftAngle io io io->proc~mc_get_phaseshiftangle module~constants constants module~constants->proc~mc_get_phaseshiftangle local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief extracts the phase shift angle from a Stokes vector\n @param SV Stokes vector structure\n @date   02/13/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name type(StokesVectorType), intent(in) :: SV Return Value real(kind=dbl) Calls proc~~mc_get_phaseshiftangle~~CallsGraph proc~mc_get_phaseshiftangle MC_get_PhaseShiftAngle proc~mc_get_ad_from_eo MC_get_AD_from_EO proc~mc_get_phaseshiftangle->proc~mc_get_ad_from_eo proc~mc_get_ellipticityangle MC_get_EllipticityAngle proc~mc_get_phaseshiftangle->proc~mc_get_ellipticityangle proc~mc_get_orientationangle MC_get_OrientationAngle proc~mc_get_phaseshiftangle->proc~mc_get_orientationangle writevalue writevalue proc~mc_get_ellipticityangle->writevalue fatalerror fatalerror proc~mc_get_ellipticityangle->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code MC_get_PhaseShiftAngle Source Code recursive function MC_get_PhaseShiftAngle ( SV ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_get_PhaseShiftAngle use constants use io IMPLICIT NONE type ( StokesVectorType ), INTENT ( IN ) :: SV real ( kind = dbl ) :: res real ( kind = dbl ) :: psi , chi , alpha , delta chi = MC_get_EllipticityAngle ( SV ) psi = MC_get_OrientationAngle ( SV ) call MC_get_AD_from_EO ( chi , psi , alpha , delta ) res = delta end function MC_get_PhaseShiftAngle","tags":"","loc":"proc/mc_get_phaseshiftangle.html","title":"MC_get_PhaseShiftAngle – Fortran Program"},{"text":"public recursive function MC_get_Polarization(SV) result(res) Uses: io proc~~mc_get_polarization~~UsesGraph proc~mc_get_polarization MC_get_Polarization io io io->proc~mc_get_polarization Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief extracts the polarization from a Stokes vector\n @param SV Stokes vector structure\n @date   02/12/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name type(StokesVectorType), intent(in) :: SV Return Value real(kind=dbl) Calls proc~~mc_get_polarization~~CallsGraph proc~mc_get_polarization MC_get_Polarization fatalerror fatalerror proc~mc_get_polarization->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code MC_get_Polarization Source Code recursive function MC_get_Polarization ( SV ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_get_Polarization use io IMPLICIT NONE type ( StokesVectorType ), INTENT ( IN ) :: SV real ( kind = dbl ) :: res if ( SV % S ( 0 ). eq . 0.D0 ) then call FatalError ( 'MC_get_Polarization' , 'Total intensity in Stokes Vector is zero' ) end if res = dsqrt ( sum ( SV % S ( 1 : 3 ) ** 2 )) / SV % S ( 0 ) end function MC_get_Polarization","tags":"","loc":"proc/mc_get_polarization.html","title":"MC_get_Polarization – Fortran Program"},{"text":"public recursive function MC_get_Stokes_EO(chi, psi, descriptor) result(res) @author Marc De Graef, Carnegie Mellon University\n @brief generate a Stokes vector for a given Ellipticity and Orientation angle\n @param chi ellipticity angle (radians)\n @param psi orientation angle (radians)\n @date   02/13/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: chi real(kind=dbl), intent(in) :: psi character(len=fnlen), intent(in) :: descriptor Return Value type(StokesVectorType) Source Code MC_get_Stokes_EO Source Code recursive function MC_get_Stokes_EO ( chi , psi , descriptor ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_get_Stokes_EO IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: chi real ( kind = dbl ), INTENT ( IN ) :: psi character ( fnlen ), INTENT ( IN ) :: descriptor type ( StokesVectorType ) :: res real ( kind = dbl ) :: cp , sp , cc , sc cp = cos ( 2.D0 * psi ) sp = sin ( 2.D0 * psi ) cc = cos ( 2.D0 * chi ) sc = sin ( 2.D0 * chi ) res % descriptor = trim ( descriptor ) res % S = ( / 1.D0 , cc * cp , cc * sp , sc / ) end function MC_get_Stokes_EO","tags":"","loc":"proc/mc_get_stokes_eo.html","title":"MC_get_Stokes_EO – Fortran Program"},{"text":"public recursive function MC_get_Stokes_AD(alpha, delta, descriptor) result(res) @author Marc De Graef, Carnegie Mellon University\n @brief generate a Stokes vector for a given auxiliary and phase shift angle\n @param alpha auxiliary angle (radians)\n @param delta phase shift angle (radians)\n @date   02/13/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: alpha real(kind=dbl), intent(in) :: delta character(len=fnlen), intent(in) :: descriptor Return Value type(StokesVectorType) Source Code MC_get_Stokes_AD Source Code recursive function MC_get_Stokes_AD ( alpha , delta , descriptor ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_get_Stokes_AD IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: alpha real ( kind = dbl ), INTENT ( IN ) :: delta character ( fnlen ), INTENT ( IN ) :: descriptor type ( StokesVectorType ) :: res real ( kind = dbl ) :: ca , sa , cd , sd ca = cos ( 2.D0 * alpha ) sa = sin ( 2.D0 * alpha ) cd = cos ( delta ) sd = sin ( delta ) res % descriptor = trim ( descriptor ) res % S = ( / 1.D0 , ca , sa * cd , sa * sd / ) end function MC_get_Stokes_AD","tags":"","loc":"proc/mc_get_stokes_ad.html","title":"MC_get_Stokes_AD – Fortran Program"},{"text":"public recursive subroutine MC_print_MuellerMatrix(MM) Uses: io proc~~mc_print_muellermatrix~~UsesGraph proc~mc_print_muellermatrix MC_print_MuellerMatrix io io io->proc~mc_print_muellermatrix Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @param MM input Mueller matrix\n @date   02/12/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name type(MuellerMatrixType), intent(in) :: MM Calls proc~~mc_print_muellermatrix~~CallsGraph proc~mc_print_muellermatrix MC_print_MuellerMatrix message message proc~mc_print_muellermatrix->message writevalue writevalue proc~mc_print_muellermatrix->writevalue Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code MC_print_MuellerMatrix Source Code recursive subroutine MC_print_MuellerMatrix ( MM ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_print_MuellerMatrix use io IMPLICIT NONE type ( MuellerMatrixType ), INTENT ( IN ) :: MM real ( kind = dbl ) :: io_double ( 4 ) integer ( kind = irg ) :: i call Message ( 'Mueller Matrix Type : ' // trim ( MM % descriptor )) do i = 1 , 4 io_double ( 1 : 4 ) = MM % M ( i , 1 : 4 ) call WriteValue ( '  --> ' , io_double , 4 ) end do end subroutine MC_print_MuellerMatrix","tags":"","loc":"proc/mc_print_muellermatrix.html","title":"MC_print_MuellerMatrix – Fortran Program"},{"text":"public recursive subroutine MC_get_AD_from_EO(chi, psi, alpha, delta) Uses: constants proc~~mc_get_ad_from_eo~~UsesGraph proc~mc_get_ad_from_eo MC_get_AD_from_EO module~constants constants module~constants->proc~mc_get_ad_from_eo local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief convert auxiliary and phase shift angle to ellipticity and orientation angles\n @details determined using a Mathematica script\n @param chi ellipticity angle (radians)\n @param psi orientation angle (radians)\n @param alpha auxiliary angle (radians)\n @param delta phase shift angle (radians)\n @date   02/13/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: chi real(kind=dbl), intent(in) :: psi real(kind=dbl), intent(out) :: alpha real(kind=dbl), intent(out) :: delta Called By proc~~mc_get_ad_from_eo~~CalledByGraph proc~mc_get_ad_from_eo MC_get_AD_from_EO proc~mc_get_phaseshiftangle MC_get_PhaseShiftAngle proc~mc_get_phaseshiftangle->proc~mc_get_ad_from_eo proc~mc_get_auxiliaryangle MC_get_AuxiliaryAngle proc~mc_get_auxiliaryangle->proc~mc_get_ad_from_eo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code MC_get_AD_from_EO Source Code recursive subroutine MC_get_AD_from_EO ( chi , psi , alpha , delta ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_get_AD_from_EO use constants IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: chi real ( kind = dbl ), INTENT ( IN ) :: psi real ( kind = dbl ), INTENT ( OUT ) :: alpha real ( kind = dbl ), INTENT ( OUT ) :: delta real ( kind = dbl ) :: sc , tp , cp , cc , p2 , p4 , st , tt , ss , ct , sa p2 = cPi * 0.5D0 p4 = cPi * 0.25D0 cc = cos ( 2.D0 * chi ) sc = sin ( 2.D0 * chi ) tp = tan ( 2.D0 * psi ) cp = cos ( 2.D0 * psi ) st = dsqrt ( sc * sc + tp * tp ) tt = dsqrt ( 1.D0 + tp * tp ) ss = dsqrt ( 1.D0 - sc * sc ) ct = cos ( 2.D0 * chi ) * tan ( 2.D0 * psi ) sa = sc / abs ( cp ) ! get alpha if ( abs ( psi - p2 ). ge . p4 ) then alpha = 0.5D0 * atan2 ( st / tt , ss / tt ) else alpha = 0.5D0 * ( cPi - atan2 ( st / tt , ss / tt )) end if ! get delta, such that there is only one cut in the delta surface for chi=0, psi<pi/2 if ( abs ( psi - p2 ). lt . p4 ) then delta = atan2 ( - sa / st , ct / st ) - cPi else delta = atan2 ( sa / st , ct / st ) if ( chi . gt . 0.D0 ) delta = delta - 2.0D0 * cPi end if end subroutine MC_get_AD_from_EO","tags":"","loc":"proc/mc_get_ad_from_eo.html","title":"MC_get_AD_from_EO – Fortran Program"},{"text":"public recursive subroutine MC_get_EO_from_AD(alpha, delta, chi, psi) Uses: constants proc~~mc_get_eo_from_ad~~UsesGraph proc~mc_get_eo_from_ad MC_get_EO_from_AD module~constants constants module~constants->proc~mc_get_eo_from_ad local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief convert ellipticity and orientation angles to auxiliary and phase shift angles\n @details determined using a Mathematica script\n @param alpha auxiliary angle (radians)\n @param delta phase shift angle (radians)\n @param chi ellipticity angle (radians)\n @param psi orientation angle (radians)\n @date   02/13/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: alpha real(kind=dbl), intent(in) :: delta real(kind=dbl), intent(out) :: chi real(kind=dbl), intent(out) :: psi Calls proc~~mc_get_eo_from_ad~~CallsGraph proc~mc_get_eo_from_ad MC_get_EO_from_AD fatalerror fatalerror proc~mc_get_eo_from_ad->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code MC_get_EO_from_AD Source Code recursive subroutine MC_get_EO_from_AD ( alpha , delta , chi , psi ) !DEC$ ATTRIBUTES DLLEXPORT :: MC_get_EO_from_AD use constants IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: alpha real ( kind = dbl ), INTENT ( IN ) :: delta real ( kind = dbl ), INTENT ( OUT ) :: chi real ( kind = dbl ), INTENT ( OUT ) :: psi real ( kind = dbl ) :: p2 , p4 p2 = cPi * 0.5D0 p4 = cPi * 0.25D0 chi = 0.5D0 * asin ( sin ( 2.D0 * alpha ) * sin ( delta )) if ( delta . le . p2 ) then psi = 0.5D0 * atan ( cos ( delta ) * tan ( 2.D0 * alpha )) else psi = cPi - 0.5D0 * atan ( cos ( delta ) * tan ( 2.D0 * alpha )) end if ! make sure chi falls in the range [-pi/4,pi/4] if ( abs ( chi ). gt . p4 ) then call FatalError ( 'MC_get_EO_from_AD' , 'ellipticity angle must be in interval [-pi/4,pi/4]' ) end if ! make sure psi falls in the range [0,pi] if ( psi . lt . 0.D0 ) psi = psi + cPi end subroutine MC_get_EO_from_AD","tags":"","loc":"proc/mc_get_eo_from_ad.html","title":"MC_get_EO_from_AD – Fortran Program"},{"text":"public recursive subroutine GetMultiPhaseNameList(nmlfile, enl, initonly) Uses: error proc~~getmultiphasenamelist~~UsesGraph proc~getmultiphasenamelist GetMultiPhaseNameList error error error->proc~getmultiphasenamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill enl structure (used by EMMultiphase.f90)\n @param nmlfile namelist file name\n @param enl multiphase name list structure\n @param initonly [optional] logical\n @date 02/21/17  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(MultiPhaseNameListType), intent(inout) :: enl logical, intent(in), optional :: initonly Calls proc~~getmultiphasenamelist~~CallsGraph proc~getmultiphasenamelist GetMultiPhaseNameList emsoft_tonativepath emsoft_tonativepath proc~getmultiphasenamelist->emsoft_tonativepath fatalerror fatalerror proc~getmultiphasenamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetMultiPhaseNameList Source Code recursive subroutine GetMultiPhaseNameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetMultiPhaseNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( MultiPhaseNameListType ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: nthreads character ( fnlen ) :: dp1file character ( fnlen ) :: dp2file character ( fnlen ) :: dp3file character ( fnlen ) :: outputfile namelist / multiphaselist / dp1file , dp2file , dp3file , outputfile , nthreads nthreads = 1 dp1file = 'undefined' dp2file = 'undefined' dp3file = 'undefined' outputfile = 'undefined' if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = multiphaselist ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( dp1file ). eq . 'undefined' ) then call FatalError ( 'Emultiphase:' , ' dp1 file name is undefined in ' // nmlfile ) end if if ( trim ( dp2file ). eq . 'undefined' ) then call FatalError ( 'Emultiphase:' , ' dp2 file name is undefined in ' // nmlfile ) end if if ( trim ( dp3file ). eq . 'undefined' ) then call FatalError ( 'Emultiphase:' , ' dp3 file name is undefined in ' // nmlfile ) end if if ( trim ( outputfile ). eq . 'undefined' ) then call FatalError ( 'Emultiphase:' , ' output file name is undefined in ' // nmlfile ) end if end if enl % nthreads = nthreads enl % dp1file = dp1file enl % dp2file = dp2file enl % dp3file = dp3file enl % outputfile = outputfile end subroutine GetMultiPhaseNameList","tags":"","loc":"proc/getmultiphasenamelist.html","title":"GetMultiPhaseNameList – Fortran Program"},{"text":"public recursive subroutine GetKosselNameList(nmlfile, knl, initonly) Uses: error proc~~getkosselnamelist~~UsesGraph proc~getkosselnamelist GetKosselNameList error error error->proc~getkosselnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill knl structure (used by EMKossel.f90)\n @param nmlfile namelist file name\n @param knl Kossel name list structure\n @param initonly [optional] logical\n @date 06/13/14  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(KosselNameListType), intent(inout) :: knl logical, intent(in), optional :: initonly Calls proc~~getkosselnamelist~~CallsGraph proc~getkosselnamelist GetKosselNameList emsoft_tonativepath emsoft_tonativepath proc~getkosselnamelist->emsoft_tonativepath fatalerror fatalerror proc~getkosselnamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~getkosselnamelist~~CalledByGraph proc~getkosselnamelist GetKosselNameList proc~jsonreadkosselnamelist JSONreadKosselNameList proc~jsonreadkosselnamelist->proc~getkosselnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetKosselNameList Source Code recursive subroutine GetKosselNameList ( nmlfile , knl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetKosselNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( KosselNameListType ), INTENT ( INOUT ) :: knl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numthick integer ( kind = irg ) :: npix integer ( kind = irg ) :: maxHOLZ integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: k ( 3 ) integer ( kind = irg ) :: fn ( 3 ) real ( kind = sgl ) :: voltage real ( kind = sgl ) :: dmin real ( kind = sgl ) :: convergence real ( kind = sgl ) :: startthick real ( kind = sgl ) :: thickinc real ( kind = sgl ) :: minten character ( fnlen ) :: xtalname character ( fnlen ) :: outname namelist / Kossellist / stdout , xtalname , voltage , k , fn , dmin , convergence , minten , nthreads , & startthick , thickinc , numthick , outname , npix , maxHOLZ ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 ! standard output numthick = 10 ! number of increments npix = 256 ! output arrays will have size npix x npix maxHOLZ = 3 ! output arrays will have size npix x npix nthreads = 4 ! default number of threads for OpenMP k = ( / 0 , 0 , 1 / ) ! beam direction [direction indices] fn = ( / 0 , 0 , 1 / ) ! foil normal [direction indices] voltage = 20000 0.0 ! acceleration voltage [V] dmin = 0.025 ! smallest d-spacing to include in dynamical matrix [nm] convergence = 2 5.0 ! beam convergence angle [mrad] startthick = 1 0.0 ! starting thickness [nm] thickinc = 1 0.0 ! thickness increment minten = 1.0E-5 ! minimum intensity in diffraction disk to make it into the output file xtalname = 'undefined' ! initial value to check that the keyword is present in the nml file outname = 'Kosselout.data' ! output filename if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = Kossellist ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'EMKossel:' , ' structure file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the knl fields knl % stdout = stdout knl % numthick = numthick knl % npix = npix knl % maxHOLZ = maxHOLZ knl % nthreads = nthreads knl % k = k knl % fn = fn knl % voltage = voltage knl % dmin = dmin knl % convergence = convergence knl % startthick = startthick knl % thickinc = thickinc knl % minten = minten knl % xtalname = xtalname knl % outname = outname end subroutine GetKosselNameList","tags":"","loc":"proc/getkosselnamelist.html","title":"GetKosselNameList – Fortran Program"},{"text":"public recursive subroutine GetKosselMasterNameList(nmlfile, knl, initonly) Uses: error proc~~getkosselmasternamelist~~UsesGraph proc~getkosselmasternamelist GetKosselMasterNameList error error error->proc~getkosselmasternamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill knl structure (used by EMKosselmaster.f90)\n @param nmlfile namelist file name\n @param knl Kossel name list structure\n @date 09/09/14  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(KosselMasterNameListType), intent(inout) :: knl logical, intent(in), optional :: initonly Calls proc~~getkosselmasternamelist~~CallsGraph proc~getkosselmasternamelist GetKosselMasterNameList emsoft_tonativepath emsoft_tonativepath proc~getkosselmasternamelist->emsoft_tonativepath fatalerror fatalerror proc~getkosselmasternamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~getkosselmasternamelist~~CalledByGraph proc~getkosselmasternamelist GetKosselMasterNameList proc~jsonreadkosselmasternamelist JSONreadKosselMasterNameList proc~jsonreadkosselmasternamelist->proc~getkosselmasternamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetKosselMasterNameList Source Code recursive subroutine GetKosselMasterNameList ( nmlfile , knl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetKosselMasterNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( KosselMasterNameListType ), INTENT ( INOUT ) :: knl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numthick integer ( kind = irg ) :: npx integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: voltage real ( kind = sgl ) :: dmin real ( kind = sgl ) :: startthick real ( kind = sgl ) :: thickinc real ( kind = sgl ) :: tfraction character ( 6 ) :: Kosselmode character ( fnlen ) :: xtalname character ( fnlen ) :: outname namelist / Kosselmasterlist / stdout , xtalname , voltage , dmin , nthreads , & startthick , thickinc , numthick , tfraction , outname , npx , Kosselmode ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 ! standard output numthick = 10 ! number of increments npx = 256 ! output arrays will have size npix x npix nthreads = 4 ! default number of threads for OpenMP voltage = 20000 0.0 ! acceleration voltage [V] dmin = 0.025 ! smallest d-spacing to include in dynamical matrix [nm] startthick = 1 0.0 ! starting thickness [nm] thickinc = 1 0.0 ! thickness increment xtalname = 'undefined' ! initial value to check that the keyword is present in the nml file outname = 'Kosselout.data' ! output filename Kosselmode = 'normal' ! 'thicks' for thickness determination, 'normal' for normal plot tfraction = 0.1 ! thickness fraction for 'thicks' mode if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = Kosselmasterlist ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'EMKosselMaster:' , ' structure file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the knl fields knl % stdout = stdout knl % numthick = numthick knl % npx = npx knl % nthreads = nthreads knl % voltage = voltage knl % dmin = dmin knl % startthick = startthick knl % thickinc = thickinc knl % tfraction = tfraction knl % Kosselmode = Kosselmode knl % xtalname = xtalname knl % outname = outname end subroutine GetKosselMasterNameList","tags":"","loc":"proc/getkosselmasternamelist.html","title":"GetKosselMasterNameList – Fortran Program"},{"text":"public recursive subroutine GetMCNameList(nmlfile, mcnl, initonly) Uses: error proc~~getmcnamelist~~UsesGraph proc~getmcnamelist GetMCNameList error error error->proc~getmcnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMMC.f90)\n @param nmlfile namelist file name\n @param mcnl Monte Carloname list structure\n @date 06/18/14  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(MCNameListType), intent(inout) :: mcnl logical, intent(in), optional :: initonly Calls proc~~getmcnamelist~~CallsGraph proc~getmcnamelist GetMCNameList emsoft_tonativepath emsoft_tonativepath proc~getmcnamelist->emsoft_tonativepath fatalerror fatalerror proc~getmcnamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~getmcnamelist~~CalledByGraph proc~getmcnamelist GetMCNameList proc~jsonreadmcnamelist JSONreadMCNameList proc~jsonreadmcnamelist->proc~getmcnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetMCNameList Source Code recursive subroutine GetMCNameList ( nmlfile , mcnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetMCNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( MCNameListType ), INTENT ( INOUT ) :: mcnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numsx integer ( kind = irg ) :: num_el integer ( kind = irg ) :: primeseed integer ( kind = irg ) :: nthreads real ( kind = dbl ) :: sig real ( kind = dbl ) :: omega real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep character ( 4 ) :: MCmode character ( fnlen ) :: xtalname character ( fnlen ) :: dataname ! define the IO namelist to facilitate passing variables to the program. namelist / MCdata / stdout , xtalname , sig , numsx , num_el , primeseed , EkeV , & dataname , nthreads , Ehistmin , Ebinsize , depthmax , depthstep , omega , MCmode ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 numsx = 1501 primeseed = 932117 num_el = 12500000 nthreads = 1 sig = 7 0.D0 omega = 0.D0 EkeV = 3 0.D0 Ehistmin = 5.D0 Ebinsize = 0.5D0 depthmax = 10 0.D0 depthstep = 1.0D0 MCmode = 'CSDA' xtalname = 'undefined' dataname = 'MCoutput.data' if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = MCdata ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'EMMC:' , ' structure file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the mcnl fields mcnl % stdout = stdout mcnl % numsx = numsx mcnl % primeseed = primeseed mcnl % num_el = num_el mcnl % nthreads = nthreads mcnl % sig = sig mcnl % omega = omega mcnl % EkeV = EkeV mcnl % Ehistmin = Ehistmin mcnl % Ebinsize = Ebinsize mcnl % depthmax = depthmax mcnl % depthstep = depthstep mcnl % MCmode = MCmode mcnl % xtalname = xtalname mcnl % dataname = dataname mcnl % stdout = stdout end subroutine GetMCNameList","tags":"","loc":"proc/getmcnamelist.html","title":"GetMCNameList – Fortran Program"},{"text":"public recursive subroutine GetMCLIPSSNameList(nmlfile, mcnl, initonly) Uses: error proc~~getmclipssnamelist~~UsesGraph proc~getmclipssnamelist GetMCLIPSSNameList error error error->proc~getmclipssnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMMC.f90)\n @param nmlfile namelist file name\n @param mcnl Monte Carloname list structure\n @date 12/01/15  PGC 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(MCLIPSSNameListType), intent(inout) :: mcnl logical, intent(in), optional :: initonly Calls proc~~getmclipssnamelist~~CallsGraph proc~getmclipssnamelist GetMCLIPSSNameList emsoft_tonativepath emsoft_tonativepath proc~getmclipssnamelist->emsoft_tonativepath fatalerror fatalerror proc~getmclipssnamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetMCLIPSSNameList Source Code recursive subroutine GetMCLIPSSNameList ( nmlfile , mcnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetMCLIPSSNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( MCLIPSSNameListType ), INTENT ( INOUT ) :: mcnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numsx integer ( kind = irg ) :: num_el integer ( kind = irg ) :: primeseed integer ( kind = irg ) :: nthreads real ( kind = dbl ) :: sig real ( kind = dbl ) :: omega real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep real ( kind = dbl ) :: lipssamp ! lipss amplitude real ( kind = dbl ) :: lipsswave ! lipss wavelength real ( kind = dbl ) :: scaled ! scale factor integer ( kind = irg ) :: npx ! array size of trajectory accumulator integer ( kind = irg ) :: vis ! write large trajectory accumulator (0-no, 1-yes) character ( 4 ) :: MCmode character ( fnlen ) :: xtalname character ( fnlen ) :: dataname ! define the IO namelist to facilitate passing variables to the program. namelist / MCdata / stdout , xtalname , sig , numsx , num_el , primeseed , EkeV , & dataname , nthreads , Ehistmin , Ebinsize , depthmax , depthstep , & lipssamp , lipsswave , scaled , npx , vis , omega , MCmode ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 numsx = 1501 primeseed = 932117 num_el = 12500000 nthreads = 1 sig = 7 0.D0 omega = 0.D0 EkeV = 3 0.D0 Ehistmin = 5.D0 Ebinsize = 0.5D0 depthmax = 10 0.D0 depthstep = 1.0D0 lipssamp = 5 0.D0 lipsswave = 30 0.D0 scaled = 1.0D7 npx = 500 vis = 0 MCmode = 'CSDA' xtalname = 'undefined' dataname = 'MCLIPSSoutput.data' if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = MCdata ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'EMMCLIPSS:' , ' structure file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the mcnl fields mcnl % stdout = stdout mcnl % numsx = numsx mcnl % primeseed = primeseed mcnl % num_el = num_el mcnl % nthreads = nthreads mcnl % sig = sig mcnl % omega = omega mcnl % EkeV = EkeV mcnl % Ehistmin = Ehistmin mcnl % Ebinsize = Ebinsize mcnl % depthmax = depthmax mcnl % depthstep = depthstep mcnl % MCmode = MCmode mcnl % xtalname = xtalname mcnl % dataname = dataname mcnl % stdout = stdout mcnl % lipssamp = lipssamp mcnl % lipsswave = lipsswave mcnl % scaled = scaled mcnl % npx = npx mcnl % vis = vis end subroutine GetMCLIPSSNameList","tags":"","loc":"proc/getmclipssnamelist.html","title":"GetMCLIPSSNameList – Fortran Program"},{"text":"public recursive subroutine GetConvertOrientationsNameList(nmlfile, enl, initonly) Uses: error proc~~getconvertorientationsnamelist~~UsesGraph proc~getconvertorientationsnamelist GetConvertOrientationsNameList error error error->proc~getconvertorientationsnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMConvertOrientations.f90 program)\n @param nmlfile namelist file name\n @param enl name list structure\n @date 01/31/17 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(ConvertOrientationsNameListType), intent(inout) :: enl logical, intent(in), optional :: initonly Calls proc~~getconvertorientationsnamelist~~CallsGraph proc~getconvertorientationsnamelist GetConvertOrientationsNameList emsoft_tonativepath emsoft_tonativepath proc~getconvertorientationsnamelist->emsoft_tonativepath fatalerror fatalerror proc~getconvertorientationsnamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetConvertOrientationsNameList Source Code recursive subroutine GetConvertOrientationsNameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetConvertOrientationsNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( ConvertOrientationsNameListType ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: cnt integer ( kind = irg ) :: reducetoRFZ character ( fnlen ) :: xtalname character ( fnlen ) :: cubochoric character ( fnlen ) :: homochoric character ( fnlen ) :: rodrigues character ( fnlen ) :: stereographic character ( fnlen ) :: eulerangles character ( fnlen ) :: axisangle character ( fnlen ) :: quaternion character ( fnlen ) :: rotationmatrix character ( fnlen ) :: anglefile ! define the IO namelist to facilitate passing variables to the program. namelist / EMConvertOrientations / cubochoric , homochoric , rodrigues , stereographic , eulerangles , & axisangle , quaternion , rotationmatrix , xtalname , anglefile , reducetoRFZ ! initialize reducetoRFZ = 1 cubochoric = 'undefined' homochoric = 'undefined' rodrigues = 'undefined' stereographic = 'undefined' eulerangles = 'undefined' axisangle = 'undefined' quaternion = 'undefined' rotationmatrix = 'undefined' xtalname = 'undefined' anglefile = 'undefined' if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = EMConvertOrientations ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'GetConvertOrientationsNameList:' , ' structure file name is undefined in ' // nmlfile ) end if if ( trim ( anglefile ). eq . 'undefined' ) then call FatalError ( 'GetConvertOrientationsNameList:' , ' angle file name is undefined in ' // nmlfile ) end if ! at least one of the output file strings must be different from 'undefined' cnt = 0 if ( cubochoric . eq . 'undefined' ) cnt = cnt + 1 if ( homochoric . eq . 'undefined' ) cnt = cnt + 1 if ( rodrigues . eq . 'undefined' ) cnt = cnt + 1 if ( stereographic . eq . 'undefined' ) cnt = cnt + 1 if ( eulerangles . eq . 'undefined' ) cnt = cnt + 1 if ( quaternion . eq . 'undefined' ) cnt = cnt + 1 if ( axisangle . eq . 'undefined' ) cnt = cnt + 1 if ( rotationmatrix . eq . 'undefined' ) cnt = cnt + 1 if ( cnt . eq . 8 ) then call FatalError ( 'GetConvertOrientationsNameList' , ' at least one output file name must be defined in ' // nmlfile ) end if end if enl % reducetoRFZ = reducetoRFZ enl % cubochoric = trim ( cubochoric ) enl % homochoric = trim ( homochoric ) enl % rodrigues = trim ( rodrigues ) enl % stereographic = trim ( stereographic ) enl % eulerangles = trim ( eulerangles ) enl % axisangle = trim ( axisangle ) enl % quaternion = trim ( quaternion ) enl % rotationmatrix = trim ( rotationmatrix ) enl % xtalname = trim ( xtalname ) enl % anglefile = trim ( anglefile ) end subroutine GetConvertOrientationsNameList","tags":"","loc":"proc/getconvertorientationsnamelist.html","title":"GetConvertOrientationsNameList – Fortran Program"},{"text":"public recursive subroutine GetOrientationVizNameList(nmlfile, enl, initonly) Uses: error proc~~getorientationviznamelist~~UsesGraph proc~getorientationviznamelist GetOrientationVizNameList error error error->proc~getorientationviznamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMOrientationViz.f90 program)\n @param nmlfile namelist file name\n @param enl name list structure\n @date 01/30/17 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(OrientationVizNameListType), intent(inout) :: enl logical, intent(in), optional :: initonly Calls proc~~getorientationviznamelist~~CallsGraph proc~getorientationviznamelist GetOrientationVizNameList emsoft_tonativepath emsoft_tonativepath proc~getorientationviznamelist->emsoft_tonativepath fatalerror fatalerror proc~getorientationviznamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetOrientationVizNameList Source Code recursive subroutine GetOrientationVizNameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetOrientationVizNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( OrientationVizNameListType ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: cubochoric integer ( kind = irg ) :: homochoric integer ( kind = irg ) :: rodrigues integer ( kind = irg ) :: stereographic integer ( kind = irg ) :: eulerspace integer ( kind = irg ) :: reducetoRFZ integer ( kind = irg ) :: nx integer ( kind = irg ) :: ny integer ( kind = irg ) :: nz integer ( kind = irg ) :: overridepgnum integer ( kind = irg ) :: MacKenzieCell real ( kind = sgl ) :: rgb ( 3 ) real ( kind = sgl ) :: sphrad real ( kind = sgl ) :: distance character ( 3 ) :: scalingmode character ( fnlen ) :: df3file character ( fnlen ) :: xtalname character ( fnlen ) :: povrayfile character ( fnlen ) :: anglefile ! define the IO namelist to facilitate passing variables to the program. namelist / EMOrientationViz / cubochoric , homochoric , rodrigues , stereographic , eulerspace , & xtalname , povrayfile , anglefile , reducetoRFZ , rgb , sphrad , df3file , & nx , ny , nz , distance , scalingmode , overridepgnum , MacKenzieCell ! initialize cubochoric = 0 homochoric = 0 rodrigues = 0 stereographic = 0 eulerspace = 0 reducetoRFZ = 1 overridepgnum = 0 MacKenzieCell = 0 rgb = ( / 0.0 , 0.0 , 1.0 / ) sphrad = 0.015 distance = 4.0 nx = 64 ny = 64 nz = 64 scalingmode = 'lev' ! or 'log' or 'lev' (for equi-level contours) df3file = 'undefined' xtalname = 'undefined' povrayfile = 'undefined' anglefile = 'undefined' if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = EMOrientationViz ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'EMOrientationViz:' , ' structure file name is undefined in ' // nmlfile ) end if if ( trim ( povrayfile ). eq . 'undefined' ) then call FatalError ( 'EMOrientationViz:' , ' povray file name is undefined in ' // nmlfile ) end if if ( trim ( anglefile ). eq . 'undefined' ) then call FatalError ( 'EMOrientationViz:' , ' angle file name is undefined in ' // nmlfile ) end if end if enl % cubochoric = cubochoric enl % homochoric = homochoric enl % rodrigues = rodrigues enl % stereographic = stereographic enl % eulerspace = eulerspace enl % reducetoRFZ = reducetoRFZ enl % nx = nx enl % ny = ny enl % nz = nz enl % overridepgnum = overridepgnum enl % MacKenzieCell = MacKenzieCell enl % rgb = rgb enl % sphrad = sphrad enl % distance = distance enl % scalingmode = scalingmode enl % df3file = df3file enl % xtalname = trim ( xtalname ) enl % povrayfile = trim ( povrayfile ) enl % anglefile = trim ( anglefile ) end subroutine GetOrientationVizNameList","tags":"","loc":"proc/getorientationviznamelist.html","title":"GetOrientationVizNameList – Fortran Program"},{"text":"public recursive subroutine GetMCCLNameList(nmlfile, mcnl, initonly) Uses: error proc~~getmcclnamelist~~UsesGraph proc~getmcclnamelist GetMCCLNameList error error error->proc~getmcclnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh/Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMMCCL.f90 and other programs)\n @param nmlfile namelist file name\n @param mcnl Monte Carloname list structure\n @date 06/18/14  SS 1.0 new routine\n @date 09/09/15 MDG 1.1 added devid (GPU device id) Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(MCCLNameListType), intent(inout) :: mcnl logical, intent(in), optional :: initonly Calls proc~~getmcclnamelist~~CallsGraph proc~getmcclnamelist GetMCCLNameList emsoft_tonativepath emsoft_tonativepath proc~getmcclnamelist->emsoft_tonativepath fatalerror fatalerror proc~getmcclnamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~getmcclnamelist~~CalledByGraph proc~getmcclnamelist GetMCCLNameList proc~jsonreadmcclnamelist JSONreadMCCLNameList proc~jsonreadmcclnamelist->proc~getmcclnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetMCCLNameList Source Code recursive subroutine GetMCCLNameList ( nmlfile , mcnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetMCCLNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( MCCLNameListType ), INTENT ( INOUT ) :: mcnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numsx integer ( kind = irg ) :: globalworkgrpsz integer ( kind = irg ) :: num_el integer ( kind = irg ) :: totnum_el integer ( kind = irg ) :: multiplier integer ( kind = irg ) :: devid integer ( kind = irg ) :: platid real ( kind = dbl ) :: sig real ( kind = dbl ) :: sigstart real ( kind = dbl ) :: sigend real ( kind = dbl ) :: sigstep real ( kind = dbl ) :: omega real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep character ( 4 ) :: MCmode character ( fnlen ) :: xtalname character ( fnlen ) :: dataname character ( fnlen ) :: mode ! define the IO namelist to facilitate passing variables to the program. namelist / MCCLdata / stdout , xtalname , sigstart , numsx , num_el , globalworkgrpsz , EkeV , multiplier , & dataname , totnum_el , Ehistmin , Ebinsize , depthmax , depthstep , omega , MCmode , mode , devid , platid , & sigend , sigstep , sig ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 numsx = 1501 globalworkgrpsz = 100 num_el = 10 totnum_el = 2000000000 multiplier = 1 devid = 1 platid = 1 sig = 7 0.D0 sigstart = 7 0.D0 sigend = 7 0.D0 sigstep = 1.D0 omega = 0.D0 EkeV = 3 0.D0 Ehistmin = 5.D0 Ebinsize = 0.5D0 depthmax = 10 0.D0 depthstep = 1.0D0 MCmode = 'CSDA' xtalname = 'undefined' dataname = 'MCoutput.data' mode = 'full' if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if write ( * , * ) EMsoft_toNativePath ( nmlfile ) if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = MCCLdata ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'EMMC:' , ' structure file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the mcnl fields mcnl % stdout = stdout mcnl % numsx = numsx mcnl % globalworkgrpsz = globalworkgrpsz mcnl % num_el = num_el mcnl % totnum_el = totnum_el mcnl % multiplier = multiplier mcnl % devid = devid mcnl % platid = platid mcnl % sigstart = sigstart mcnl % sigend = sigend mcnl % sigstep = sigstep mcnl % sig = sig mcnl % omega = omega mcnl % EkeV = EkeV mcnl % Ehistmin = Ehistmin mcnl % Ebinsize = Ebinsize mcnl % depthmax = depthmax mcnl % depthstep = depthstep mcnl % MCmode = MCmode mcnl % xtalname = xtalname mcnl % dataname = dataname mcnl % mode = mode end subroutine GetMCCLNameList","tags":"","loc":"proc/getmcclnamelist.html","title":"GetMCCLNameList – Fortran Program"},{"text":"public recursive subroutine GetMCCLMultiLayerNameList(nmlfile, mcnl, initonly) Uses: error proc~~getmcclmultilayernamelist~~UsesGraph proc~getmcclmultilayernamelist GetMCCLMultiLayerNameList error error error->proc~getmcclmultilayernamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh/Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMMCCL.f90)\n @param nmlfile namelist file name\n @param mcnl Monte Carloname list structure\n @date 06/18/14  SS 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(MCCLMultiLayerNameListType), intent(inout) :: mcnl logical, intent(in), optional :: initonly Calls proc~~getmcclmultilayernamelist~~CallsGraph proc~getmcclmultilayernamelist GetMCCLMultiLayerNameList emsoft_tonativepath emsoft_tonativepath proc~getmcclmultilayernamelist->emsoft_tonativepath fatalerror fatalerror proc~getmcclmultilayernamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~getmcclmultilayernamelist~~CalledByGraph proc~getmcclmultilayernamelist GetMCCLMultiLayerNameList proc~jsonreadmcclmultilayernamelist JSONreadMCCLMultiLayerNameList proc~jsonreadmcclmultilayernamelist->proc~getmcclmultilayernamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetMCCLMultiLayerNameList Source Code recursive subroutine GetMCCLMultiLayerNameList ( nmlfile , mcnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetMCCLMultiLayerNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( MCCLMultiLayerNameListType ), INTENT ( INOUT ) :: mcnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numsx integer ( kind = irg ) :: globalworkgrpsz integer ( kind = irg ) :: num_el integer ( kind = irg ) :: totnum_el real ( kind = dbl ) :: sig real ( kind = dbl ) :: omega real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep real ( kind = dbl ) :: filmthickness real ( kind = dbl ) :: filmstep character ( 4 ) :: MCmode character ( fnlen ) :: xtalname_film character ( fnlen ) :: xtalname_subs character ( fnlen ) :: dataname character ( fnlen ) :: mode ! define the IO namelist to facilitate passing variables to the program. namelist / MCCLdata / stdout , sig , numsx , num_el , globalworkgrpsz , EkeV , & dataname , totnum_el , Ehistmin , Ebinsize , depthmax , & depthstep , omega , MCmode , mode , xtalname_film , xtalname_subs , & filmthickness , filmstep ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 numsx = 1501 globalworkgrpsz = 100 num_el = 10 totnum_el = 100000 sig = 7 0.D0 omega = 0.D0 EkeV = 3 0.D0 Ehistmin = 5.D0 Ebinsize = 0.5D0 depthmax = 10 0.D0 depthstep = 1.0D0 MCmode = 'CSDA' xtalname_film = 'undefined' xtalname_subs = 'undefined' dataname = 'MCoutput.data' mode = 'full' filmthickness = 2 0.D0 filmstep = 2.D0 if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = MCCLdata ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if (( trim ( xtalname_film ). eq . 'undefined' ) . or . ( trim ( xtalname_subs ). eq . 'undefined' )) then call FatalError ( 'EMMC:' , ' structure file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the mcnl fields mcnl % stdout = stdout mcnl % numsx = numsx mcnl % globalworkgrpsz = globalworkgrpsz mcnl % num_el = num_el mcnl % totnum_el = totnum_el mcnl % sig = sig mcnl % omega = omega mcnl % EkeV = EkeV mcnl % Ehistmin = Ehistmin mcnl % Ebinsize = Ebinsize mcnl % depthmax = depthmax mcnl % depthstep = depthstep mcnl % MCmode = MCmode mcnl % xtalname_film = xtalname_film mcnl % xtalname_subs = xtalname_subs mcnl % dataname = dataname mcnl % mode = mode mcnl % filmthickness = filmthickness mcnl % filmstep = filmstep end subroutine GetMCCLMultiLayerNameList","tags":"","loc":"proc/getmcclmultilayernamelist.html","title":"GetMCCLMultiLayerNameList – Fortran Program"},{"text":"public recursive subroutine GetDisorientationsNameList(nmlfile, emnl, initonly) Uses: error proc~~getdisorientationsnamelist~~UsesGraph proc~getdisorientationsnamelist GetDisorientationsNameList error error error->proc~getdisorientationsnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMDisorientations.f90)\n @param nmlfile namelist file name\n @param emnl name list structure\n @date 06/24/16  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(DisorientationsNameListType), intent(inout) :: emnl logical, intent(in), optional :: initonly Calls proc~~getdisorientationsnamelist~~CallsGraph proc~getdisorientationsnamelist GetDisorientationsNameList emsoft_tonativepath emsoft_tonativepath proc~getdisorientationsnamelist->emsoft_tonativepath fatalerror fatalerror proc~getdisorientationsnamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetDisorientationsNameList Source Code recursive subroutine GetDisorientationsNameList ( nmlfile , emnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetDisorientationsNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( DisorientationsNameListType ), INTENT ( INOUT ) :: emnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: pgnum integer ( kind = irg ) :: pgnum2 character ( fnlen ) :: inputfile character ( fnlen ) :: outputfile ! define the IO namelist to facilitate passing variables to the program. namelist / Disorientations / pgnum , pgnum2 , inputfile , outputfile ! set the input parameters to default values pgnum = 32 ! pgnum2 = 32 ! inputfile = 'undefined' ! default filename for input file outputfile = 'undefined' ! default filename for input file if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = Disorientations ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( inputfile ). eq . 'undefined' ) then call FatalError ( ' EMDisorientations' , ' input file name is undefined in ' // nmlfile ) end if if ( trim ( outputfile ). eq . 'undefined' ) then call FatalError ( ' EMDisorientations' , ' output file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields emnl % pgnum = pgnum emnl % pgnum2 = pgnum2 emnl % inputfile = inputfile emnl % outputfile = outputfile end subroutine GetDisorientationsNameList","tags":"","loc":"proc/getdisorientationsnamelist.html","title":"GetDisorientationsNameList – Fortran Program"},{"text":"public recursive subroutine GetAverageOrientationNameList(nmlfile, emnl, initonly) Uses: error proc~~getaverageorientationnamelist~~UsesGraph proc~getaverageorientationnamelist GetAverageOrientationNameList error error error->proc~getaverageorientationnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMAverageOrient.f90)\n @param nmlfile namelist file name\n @param emnl name list structure\n @date 06/24/16  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(AverageOrientationNameListType), intent(inout) :: emnl logical, intent(in), optional :: initonly Calls proc~~getaverageorientationnamelist~~CallsGraph proc~getaverageorientationnamelist GetAverageOrientationNameList emsoft_tonativepath emsoft_tonativepath proc~getaverageorientationnamelist->emsoft_tonativepath fatalerror fatalerror proc~getaverageorientationnamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetAverageOrientationNameList Source Code recursive subroutine GetAverageOrientationNameList ( nmlfile , emnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetAverageOrientationNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( AverageOrientationNameListType ), INTENT ( INOUT ) :: emnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: nmuse integer ( kind = irg ) :: reldisx integer ( kind = irg ) :: reldisy logical :: oldformat character ( fnlen ) :: dotproductfile character ( fnlen ) :: averagectffile character ( fnlen ) :: averagetxtfile character ( fnlen ) :: disorientationmap ! define the IO namelist to facilitate passing variables to the program. namelist / AverageOrientation / nmuse , dotproductfile , averagectffile , oldformat , averagetxtfile , & reldisx , reldisy , disorientationmap ! set the input parameters to default values (except for xtalname, which must be present) nmuse = 10 ! number of near-matches to use reldisx = 0 ! x-coordinate for relative disorientation map reldisy = 0 ! y-coordinate for relative disorientation map oldformat = . FALSE . ! switch for older format of dot product files dotproductfile = 'undefined' ! default filename for input dotproduct file (HDF5) averagectffile = 'undefined' ! default filename for output ctf file averagetxtfile = 'undefined' ! default filename for output txt file (only with oldformat=.TRUE. disorientationmap = 'undefined' ! default filename for relative disorientation map file if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = AverageOrientation ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( dotproductfile ). eq . 'undefined' ) then call FatalError ( ' EMAverageOrient' , ' dotproduct file name is undefined in ' // nmlfile ) end if if ( oldformat . eqv .. TRUE .) then if ( trim ( averagetxtfile ). eq . 'undefined' ) then call FatalError ( ' EMAverageOrient' , ' txt output file name is undefined in ' // nmlfile ) end if else if ( trim ( averagectffile ). eq . 'undefined' ) then call FatalError ( ' EMAverageOrient' , ' ctf output file name is undefined in ' // nmlfile ) end if end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields emnl % nmuse = nmuse emnl % reldisx = reldisx emnl % reldisy = reldisy emnl % oldformat = oldformat emnl % dotproductfile = dotproductfile emnl % averagectffile = averagectffile emnl % averagetxtfile = averagetxtfile emnl % disorientationmap = disorientationmap end subroutine GetAverageOrientationNameList","tags":"","loc":"proc/getaverageorientationnamelist.html","title":"GetAverageOrientationNameList – Fortran Program"},{"text":"public recursive subroutine GetOrientationSimilarityNameList(nmlfile, emnl, initonly) Uses: error proc~~getorientationsimilaritynamelist~~UsesGraph proc~getorientationsimilaritynamelist GetOrientationSimilarityNameList error error error->proc~getorientationsimilaritynamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMOrientationSimilarity.f90)\n @param nmlfile namelist file name\n @param emnl name list structure\n @date 07/29/16  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(OrientationSimilarityNameListType), intent(inout) :: emnl logical, intent(in), optional :: initonly Calls proc~~getorientationsimilaritynamelist~~CallsGraph proc~getorientationsimilaritynamelist GetOrientationSimilarityNameList emsoft_tonativepath emsoft_tonativepath proc~getorientationsimilaritynamelist->emsoft_tonativepath fatalerror fatalerror proc~getorientationsimilaritynamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetOrientationSimilarityNameList Source Code recursive subroutine GetOrientationSimilarityNameList ( nmlfile , emnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetOrientationSimilarityNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( OrientationSimilarityNameListType ), INTENT ( INOUT ) :: emnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: nmuse character ( fnlen ) :: dotproductfile character ( fnlen ) :: osmtiff ! define the IO namelist to facilitate passing variables to the program. namelist / OrientationSimilarity / nmuse , dotproductfile , osmtiff ! set the input parameters to default values (except for xtalname, which must be present) nmuse = 10 ! number of near-matches to use dotproductfile = 'undefined' ! default filename for input dotproduct file (HDF5) osmtiff = 'undefined' ! default filename for input dotproduct file (HDF5) if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = OrientationSimilarity ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( dotproductfile ). eq . 'undefined' ) then call FatalError ( ' EMOrientationSimilarity' , ' dotproduct file name is undefined in ' // nmlfile ) end if if ( trim ( osmtiff ). eq . 'undefined' ) then call FatalError ( ' EMOrientationSimilarity' , ' osm.tiff output file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields emnl % nmuse = nmuse emnl % dotproductfile = dotproductfile emnl % osmtiff = osmtiff end subroutine GetOrientationSimilarityNameList","tags":"","loc":"proc/getorientationsimilaritynamelist.html","title":"GetOrientationSimilarityNameList – Fortran Program"},{"text":"public recursive subroutine GetKAMNameList(nmlfile, emnl, initonly) Uses: error proc~~getkamnamelist~~UsesGraph proc~getkamnamelist GetKAMNameList error error error->proc~getkamnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMOrientationSimilarity.f90)\n @param nmlfile namelist file name\n @param emnl name list structure\n @date 07/29/16  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(KAMNameListType), intent(inout) :: emnl logical, intent(in), optional :: initonly Calls proc~~getkamnamelist~~CallsGraph proc~getkamnamelist GetKAMNameList emsoft_tonativepath emsoft_tonativepath proc~getkamnamelist->emsoft_tonativepath fatalerror fatalerror proc~getkamnamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetKAMNameList Source Code recursive subroutine GetKAMNameList ( nmlfile , emnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetKAMNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( KAMNameListType ), INTENT ( INOUT ) :: emnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . real ( kind = sgl ) :: kamcutoff integer ( kind = irg ) :: orav character ( fnlen ) :: dotproductfile character ( fnlen ) :: kamtiff ! define the IO namelist to facilitate passing variables to the program. namelist / KAM / kamcutoff , orav , dotproductfile , kamtiff ! set the input parameters to default values (except for xtalname, which must be present) kamcutoff = 5.0 ! number of near-matches to use orav = 0 ! perform orientation average first ? dotproductfile = 'undefined' ! default filename for input dotproduct file (HDF5) kamtiff = 'undefined' ! default filename for input dotproduct file (HDF5) if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = KAM ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( dotproductfile ). eq . 'undefined' ) then call FatalError ( ' EMKAM' , ' dotproduct file name is undefined in ' // nmlfile ) end if if ( trim ( kamtiff ). eq . 'undefined' ) then call FatalError ( ' EMKAM' , ' kam.tiff output file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields emnl % kamcutoff = kamcutoff emnl % orav = orav emnl % dotproductfile = dotproductfile emnl % kamtiff = kamtiff end subroutine GetKAMNameList","tags":"","loc":"proc/getkamnamelist.html","title":"GetKAMNameList – Fortran Program"},{"text":"public recursive subroutine GetDvsDNameList(nmlfile, emnl, initonly) Uses: error proc~~getdvsdnamelist~~UsesGraph proc~getdvsdnamelist GetDvsDNameList error error error->proc~getdvsdnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMOrientationSimilarity.f90)\n @param nmlfile namelist file name\n @param emnl name list structure\n @date 07/29/16  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(DvsDNameListType), intent(inout) :: emnl logical, intent(in), optional :: initonly Calls proc~~getdvsdnamelist~~CallsGraph proc~getdvsdnamelist GetDvsDNameList emsoft_tonativepath emsoft_tonativepath proc~getdvsdnamelist->emsoft_tonativepath fatalerror fatalerror proc~getdvsdnamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetDvsDNameList Source Code recursive subroutine GetDvsDNameList ( nmlfile , emnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetDvsDNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( DvsDNameListType ), INTENT ( INOUT ) :: emnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: nmuse real ( kind = sgl ) :: maxdis real ( kind = sgl ) :: minang real ( kind = sgl ) :: maxang character ( fnlen ) :: dotproductfile character ( fnlen ) :: outfile character ( fnlen ) :: povfile character ( fnlen ) :: xtalfile ! define the IO namelist to facilitate passing variables to the program. namelist / DvsD / nmuse , maxdis , minang , maxang , dotproductfile , outfile , povfile , xtalfile ! set the input parameters to default values (except for xtalname, which must be present) nmuse = 10 maxdis = 3.0 minang = 1 0.0 maxang = 2 0.0 dotproductfile = 'undefined' ! default filename for input dotproduct file (HDF5) outfile = 'undefined' ! default filename for output file (txt) povfile = 'undefined' ! default filename for output file (txt) xtalfile = 'undefined' ! default filename for output file (txt) if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = DvsD ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalfile ). eq . 'undefined' ) then call FatalError ( ' EMDvsD' , ' xtal file name is undefined in ' // nmlfile ) end if if ( trim ( dotproductfile ). eq . 'undefined' ) then call FatalError ( ' EMDvsD' , ' dotproduct file name is undefined in ' // nmlfile ) end if if ( trim ( outfile ). eq . 'undefined' ) then call FatalError ( ' EMDvsD' , ' outfile output file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields emnl % nmuse = nmuse emnl % maxdis = maxdis emnl % minang = minang emnl % maxang = maxang emnl % dotproductfile = dotproductfile emnl % outfile = outfile emnl % povfile = povfile emnl % xtalfile = xtalfile end subroutine GetDvsDNameList","tags":"","loc":"proc/getdvsdnamelist.html","title":"GetDvsDNameList – Fortran Program"},{"text":"public recursive subroutine GetEBSDMasterNameList(nmlfile, emnl, initonly) Uses: error proc~~getebsdmasternamelist~~UsesGraph proc~getebsdmasternamelist GetEBSDMasterNameList error error error->proc~getebsdmasternamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMEBSDmaster.f90)\n @param nmlfile namelist file name\n @param emnl EBSD master name list structure\n @date 06/19/14  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(EBSDMasterNameListType), intent(inout) :: emnl logical, intent(in), optional :: initonly Calls proc~~getebsdmasternamelist~~CallsGraph proc~getebsdmasternamelist GetEBSDMasterNameList emsoft_tonativepath emsoft_tonativepath proc~getebsdmasternamelist->emsoft_tonativepath fatalerror fatalerror proc~getebsdmasternamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~getebsdmasternamelist~~CalledByGraph proc~getebsdmasternamelist GetEBSDMasterNameList proc~jsonreadebsdmasternamelist JSONreadEBSDMasterNameList proc~jsonreadebsdmasternamelist->proc~getebsdmasternamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetEBSDMasterNameList Source Code recursive subroutine GetEBSDMasterNameList ( nmlfile , emnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetEBSDMasterNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( EBSDMasterNameListType ), INTENT ( INOUT ) :: emnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: npx integer ( kind = irg ) :: Esel integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: dmin character ( fnlen ) :: energyfile logical :: restart logical :: uniform ! define the IO namelist to facilitate passing variables to the program. namelist / EBSDmastervars / dmin , npx , nthreads , energyfile , Esel , restart , uniform ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 npx = 500 ! Nx pixels (total = 2Nx+1) nthreads = 1 Esel = - 1 ! selected energy value for single energy run dmin = 0.025 ! smallest d-spacing to include in dynamical matrix [nm] energyfile = 'undefined' ! default filename for z_0(E_e) data from EMMC Monte Carlo simulations restart = . FALSE . ! when .TRUE. an existing file will be assumed uniform = . FALSE . ! when .TRUE., the output master patterns will contain 1.0 everywhere if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = EBSDmastervars ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( energyfile ). eq . 'undefined' ) then call FatalError ( 'EMEBSDmaster:' , ' energy file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields emnl % stdout = stdout emnl % npx = npx emnl % Esel = Esel emnl % nthreads = nthreads emnl % dmin = dmin emnl % energyfile = energyfile emnl % outname = energyfile ! as off release 3.1, outname must be the same as energyfile emnl % restart = restart emnl % uniform = uniform end subroutine GetEBSDMasterNameList","tags":"","loc":"proc/getebsdmasternamelist.html","title":"GetEBSDMasterNameList – Fortran Program"},{"text":"public recursive subroutine GetTKDMasterNameList(nmlfile, emnl, initonly) Uses: error proc~~gettkdmasternamelist~~UsesGraph proc~gettkdmasternamelist GetTKDMasterNameList error error error->proc~gettkdmasternamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMTKDmaster.f90)\n @param nmlfile namelist file name\n @param emnl TKD master name list structure\n @date 01/16/17  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(TKDMasterNameListType), intent(inout) :: emnl logical, intent(in), optional :: initonly Calls proc~~gettkdmasternamelist~~CallsGraph proc~gettkdmasternamelist GetTKDMasterNameList emsoft_tonativepath emsoft_tonativepath proc~gettkdmasternamelist->emsoft_tonativepath fatalerror fatalerror proc~gettkdmasternamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetTKDMasterNameList Source Code recursive subroutine GetTKDMasterNameList ( nmlfile , emnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetTKDMasterNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( TKDMasterNameListType ), INTENT ( INOUT ) :: emnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: npx integer ( kind = irg ) :: Esel integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: dmin character ( fnlen ) :: energyfile logical :: restart logical :: uniform ! define the IO namelist to facilitate passing variables to the program. namelist / TKDmastervars / dmin , npx , nthreads , energyfile , Esel , restart , uniform ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 npx = 500 ! Nx pixels (total = 2Nx+1) nthreads = 1 Esel = - 1 ! selected energy value for single energy run dmin = 0.025 ! smallest d-spacing to include in dynamical matrix [nm] energyfile = 'undefined' ! default filename for z_0(E_e) data from EMMC Monte Carlo simulations restart = . FALSE . ! when .TRUE. an existing file will be assumed uniform = . FALSE . ! when .TRUE., the output master patterns will contain 1.0 everywhere if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = TKDmastervars ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( energyfile ). eq . 'undefined' ) then call FatalError ( 'EMTKDmaster:' , ' energy file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields emnl % stdout = stdout emnl % npx = npx emnl % Esel = Esel emnl % nthreads = nthreads emnl % dmin = dmin emnl % energyfile = energyfile emnl % outname = energyfile ! as off release 3.1, outname must be the same as energyfile emnl % restart = restart emnl % uniform = uniform end subroutine GetTKDMasterNameList","tags":"","loc":"proc/gettkdmasternamelist.html","title":"GetTKDMasterNameList – Fortran Program"},{"text":"public recursive subroutine GetEBSDMasterOpenCLNameList(nmlfile, emnl, initonly) Uses: error proc~~getebsdmasteropenclnamelist~~UsesGraph proc~getebsdmasteropenclnamelist GetEBSDMasterOpenCLNameList error error error->proc~getebsdmasteropenclnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMEBSDmasterOpenCL.f90)\n @param nmlfile namelist file name\n @param emnl EBSD master name list structure\n @date 12/10/16  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(EBSDMasterOpenCLNameListType), intent(inout) :: emnl logical, intent(in), optional :: initonly Calls proc~~getebsdmasteropenclnamelist~~CallsGraph proc~getebsdmasteropenclnamelist GetEBSDMasterOpenCLNameList emsoft_tonativepath emsoft_tonativepath proc~getebsdmasteropenclnamelist->emsoft_tonativepath fatalerror fatalerror proc~getebsdmasteropenclnamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetEBSDMasterOpenCLNameList Source Code recursive subroutine GetEBSDMasterOpenCLNameList ( nmlfile , emnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetEBSDMasterOpenCLNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( EBSDMasterOpenCLNameListType ), INTENT ( INOUT ) :: emnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: npx integer ( kind = irg ) :: Esel integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: platid integer ( kind = irg ) :: devid integer ( kind = irg ) :: globalworkgrpsz real ( kind = sgl ) :: dmin character ( fnlen ) :: energyfile logical :: restart logical :: uniform ! define the IO namelist to facilitate passing variables to the program. namelist / EBSDmastervars / stdout , dmin , npx , platid , devid , globalworkgrpsz , energyfile , restart , uniform , Esel , nthreads ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 npx = 500 ! Nx pixels (total = 2Nx+1) nthreads = 1 platid = 1 devid = 1 globalworkgrpsz = 150 Esel = - 1 ! selected energy value for single energy run dmin = 0.025 ! smallest d-spacing to include in dynamical matrix [nm] energyfile = 'undefined' ! default filename for z_0(E_e) data from EMMC Monte Carlo simulations restart = . FALSE . ! when .TRUE. an existing file will be assumed uniform = . FALSE . ! when .TRUE., the output master patterns will contain 1.0 everywhere if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = EBSDmastervars ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( energyfile ). eq . 'undefined' ) then call FatalError ( 'EMEBSDmaster:' , ' energy file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields emnl % stdout = stdout emnl % npx = npx emnl % Esel = Esel emnl % nthreads = nthreads emnl % platid = platid emnl % devid = devid emnl % globalworkgrpsz = globalworkgrpsz emnl % dmin = dmin emnl % energyfile = energyfile emnl % restart = restart emnl % uniform = uniform end subroutine GetEBSDMasterOpenCLNameList","tags":"","loc":"proc/getebsdmasteropenclnamelist.html","title":"GetEBSDMasterOpenCLNameList – Fortran Program"},{"text":"public recursive subroutine GetEBSDclusterNameList(nmlfile, emnl, initonly) Uses: error proc~~getebsdclusternamelist~~UsesGraph proc~getebsdclusternamelist GetEBSDclusterNameList error error error->proc~getebsdclusternamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill emnl structure (used by EMEBSDcluster.f90)\n @param nmlfile namelist file name\n @param emnl EBSD master name list structure\n @date 06/19/14  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(EBSDclusterNameListType), intent(inout) :: emnl logical, intent(in), optional :: initonly Calls proc~~getebsdclusternamelist~~CallsGraph proc~getebsdclusternamelist GetEBSDclusterNameList emsoft_tonativepath emsoft_tonativepath proc~getebsdclusternamelist->emsoft_tonativepath fatalerror fatalerror proc~getebsdclusternamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~getebsdclusternamelist~~CalledByGraph proc~getebsdclusternamelist GetEBSDclusterNameList proc~jsonreadebsdclusternamelist JSONreadEBSDclusterNameList proc~jsonreadebsdclusternamelist->proc~getebsdclusternamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetEBSDclusterNameList Source Code recursive subroutine GetEBSDclusterNameList ( nmlfile , emnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetEBSDclusterNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( EBSDclusterNameListType ), INTENT ( INOUT ) :: emnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: NClusters , NIterations , binfactor character ( fnlen ) :: inputfilename , groupname , datasetname ! define the IO namelist to facilitate passing variables to the program. namelist / EBSDclustervars / NClusters , NIterations , binfactor , inputfilename , groupname , datasetname ! set the input parameters to default values (except for xtalname, which must be present) NClusters = 100 ! initial number of clusters to look for NIterations = 50 ! number of iterations in K-means algorithm binfactor = 1 ! no binning by default inputfilename = 'undefined' ! default filename for HDF5 data input file groupname = 'undefined' ! default groupname for EBSD data datasetname = 'undefined' ! default dataset name if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = EBSDclustervars ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( inputfilename ). eq . 'undefined' ) then call FatalError ( 'EMEBSDcluster:' , ' HDF5 input data file name is undefined in ' // nmlfile ) end if if ( trim ( groupname ). eq . 'undefined' ) then call FatalError ( 'EMEBSDcluster:' , ' Data group name is undefined in ' // nmlfile ) end if if ( trim ( datasetname ). eq . 'undefined' ) then call FatalError ( 'EMEBSDcluster:' , ' Data set name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields emnl % NClusters = NClusters emnl % NIterations = NIterations emnl % binfactor = binfactor emnl % inputfilename = inputfilename emnl % groupname = groupname emnl % datasetname = datasetname ! parameters that are not in the nml file emnl % NScanColumns = 0 emnl % NScanRows = 0 end subroutine GetEBSDclusterNameList","tags":"","loc":"proc/getebsdclusternamelist.html","title":"GetEBSDclusterNameList – Fortran Program"},{"text":"public recursive subroutine GetECPMasterNameList(nmlfile, ecpnl, initonly) Uses: error proc~~getecpmasternamelist~~UsesGraph proc~getecpmasternamelist GetECPMasterNameList error error error->proc~getecpmasternamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh/Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMECPmaster.f90)\n @param nmlfile namelist file name\n @param emnl ECP master name list structure\n @date 06/19/14  SS 1.0 new routine\n @date 08/12/15 MDG 1.1 correction of type for startthick and fn(3)\n @date 09/15/15  SS 1.2 clean up of the subroutine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(ECPMasterNameListType), intent(inout) :: ecpnl logical, intent(in), optional :: initonly Calls proc~~getecpmasternamelist~~CallsGraph proc~getecpmasternamelist GetECPMasterNameList emsoft_tonativepath emsoft_tonativepath proc~getecpmasternamelist->emsoft_tonativepath fatalerror fatalerror proc~getecpmasternamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~getecpmasternamelist~~CalledByGraph proc~getecpmasternamelist GetECPMasterNameList proc~jsonreadecpmasternamelist JSONreadECPMasterNameList proc~jsonreadecpmasternamelist->proc~getecpmasternamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetECPMasterNameList Source Code recursive subroutine GetECPMasterNameList ( nmlfile , ecpnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetECPMasterNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( ECPMasterNameListType ), INTENT ( INOUT ) :: ecpnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: npx integer ( kind = irg ) :: Esel integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: dmin character ( fnlen ) :: compmode character ( fnlen ) :: energyfile ! define the IO namelist to facilitate passing variables to the program. namelist / ECPmastervars / stdout , dmin , compmode , & energyfile , Esel , npx , nthreads ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 Esel = - 1 ! selected energy value for single energy run nthreads = 1 dmin = 0.04 ! smallest d-spacing to include in dynamical matrix [nm] npx = 256 compmode = 'Blochwv' energyfile = 'undefined' ! default filename for z_0(E_e) data from EMMC Monte Carlo simulations if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = ECPmastervars ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( energyfile ). eq . 'undefined' ) then call FatalError ( 'EMECPmaster:' , ' energy file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields ecpnl % stdout = stdout ecpnl % Esel = Esel ecpnl % npx = npx ecpnl % nthreads = nthreads ecpnl % dmin = dmin ecpnl % compmode = compmode ecpnl % energyfile = energyfile ecpnl % outname = energyfile end subroutine GetECPMasterNameList","tags":"","loc":"proc/getecpmasternamelist.html","title":"GetECPMasterNameList – Fortran Program"},{"text":"public recursive subroutine GetreflectorNameList(nmlfile, rnl, initonly) Uses: error proc~~getreflectornamelist~~UsesGraph proc~getreflectornamelist GetreflectorNameList error error error->proc~getreflectornamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef\n @brief read reflector namelist for EMreflectors program\n @param nmlfile namelist file name\n @param rnl reflect name list structure\n @date 05/31/16 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(reflectorNameListType), intent(inout) :: rnl logical, intent(in), optional :: initonly Calls proc~~getreflectornamelist~~CallsGraph proc~getreflectornamelist GetreflectorNameList emsoft_tonativepath emsoft_tonativepath proc~getreflectornamelist->emsoft_tonativepath fatalerror fatalerror proc~getreflectornamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~getreflectornamelist~~CalledByGraph proc~getreflectornamelist GetreflectorNameList proc~jsonreadreflectornamelist JSONreadreflectorNameList proc~jsonreadreflectornamelist->proc~getreflectornamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetreflectorNameList Source Code recursive subroutine GetreflectorNameList ( nmlfile , rnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetreflectorNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( reflectorNameListType ), INTENT ( INOUT ) :: rnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: numphi integer ( kind = irg ) :: numtheta real ( kind = sgl ) :: dmin character ( fnlen ) :: masterfile character ( fnlen ) :: energyfile ! define the IO namelist to facilitate passing variables to the program. namelist / EBSDreflectors / numphi , numtheta , dmin , masterfile , energyfile ! set the input parameters to default values (except for xtalname, which must be present) numphi = 360 numtheta = 10 dmin = 0.05 ! smallest d-spacing to include in dynamical matrix [nm] masterfile = 'undefined' ! default filename for z_0(E_e) data from EMMC Monte Carlo simulations energyfile = 'undefined' ! default filename for z_0(E_e) data from EMMC Monte Carlo simulations if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = EBSDreflectors ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( energyfile ). eq . 'undefined' ) then call FatalError ( 'EMreflectors:' , ' energy file name is undefined in ' // nmlfile ) end if if ( trim ( masterfile ). eq . 'undefined' ) then call FatalError ( 'EMreflectors:' , ' master file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields rnl % numphi = numphi rnl % numtheta = numtheta rnl % dmin = dmin rnl % masterfile = masterfile rnl % energyfile = energyfile end subroutine GetreflectorNameList","tags":"","loc":"proc/getreflectornamelist.html","title":"GetreflectorNameList – Fortran Program"},{"text":"public recursive subroutine GetkinematicalNameList(nmlfile, knl, initonly) Uses: error proc~~getkinematicalnamelist~~UsesGraph proc~getkinematicalnamelist GetkinematicalNameList error error error->proc~getkinematicalnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef\n @brief read reflector namelist for EMreflectors program\n @param nmlfile namelist file name\n @param rnl reflect name list structure\n @date 05/31/16 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(kinematicalNameListType), intent(inout) :: knl logical, intent(in), optional :: initonly Calls proc~~getkinematicalnamelist~~CallsGraph proc~getkinematicalnamelist GetkinematicalNameList emsoft_tonativepath emsoft_tonativepath proc~getkinematicalnamelist->emsoft_tonativepath fatalerror fatalerror proc~getkinematicalnamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetkinematicalNameList Source Code recursive subroutine GetkinematicalNameList ( nmlfile , knl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetkinematicalNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( kinematicalNameListType ), INTENT ( INOUT ) :: knl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . real ( kind = sgl ) :: dmin real ( kind = sgl ) :: thr real ( kind = sgl ) :: voltage character ( fnlen ) :: xtalname character ( fnlen ) :: datafile ! define the IO namelist to facilitate passing variables to the program. namelist / EMkinematical / dmin , voltage , thr , xtalname , datafile ! set the input parameters to default values (except for xtalname, which must be present) dmin = 0.05 ! smallest d-spacing to include in dynamical matrix [nm] thr = 1.0 ! smallest |structurefactor|&#94;2 to include voltage = 3000 0.0 ! microscope voltage [V] datafile = 'undefined' ! output file name xtalname = 'undefined' ! structure file name if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = EMkinematical ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'EMkinematical:' , '  crystal structure file name is undefined in ' // nmlfile ) end if if ( trim ( datafile ). eq . 'undefined' ) then call FatalError ( 'EMkinematical:' , ' output file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields knl % dmin = dmin knl % thr = thr knl % voltage = voltage knl % xtalname = xtalname knl % datafile = datafile end subroutine GetkinematicalNameList","tags":"","loc":"proc/getkinematicalnamelist.html","title":"GetkinematicalNameList – Fortran Program"},{"text":"public recursive subroutine GetEBSDdetparmscanNameList(nmlfile, enl, initonly) Uses: error proc~~getebsddetparmscannamelist~~UsesGraph proc~getebsddetparmscannamelist GetEBSDdetparmscanNameList error error error->proc~getebsddetparmscannamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill enl structure (used by EMEBSD.f90)\n @param nmlfile namelist file name\n @param enl EBSD name list structure\n @date 06/23/14  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(EBSDdetparmscanNameListType), intent(inout) :: enl logical, intent(in), optional :: initonly Calls proc~~getebsddetparmscannamelist~~CallsGraph proc~getebsddetparmscannamelist GetEBSDdetparmscanNameList emsoft_tonativepath emsoft_tonativepath proc~getebsddetparmscannamelist->emsoft_tonativepath Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetEBSDdetparmscanNameList Source Code recursive subroutine GetEBSDdetparmscanNameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetEBSDdetparmscanNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( EBSDdetparmscanNameListType ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: numdetparm integer ( kind = irg ) :: numeuler real ( kind = sgl ) :: DetParms ( 3 ) real ( kind = sgl ) :: Eulertriplet ( 3 ) real ( kind = sgl ) :: DetParmstepsize ( 3 ) real ( kind = sgl ) :: Cubochoricstepsize ( 3 ) ! define the IO namelist to facilitate passing variables to the program. namelist / EBSDscandata / numdetparm , numeuler , DetParms , Eulertriplet , DetParmstepsize , Cubochoricstepsize ! set the input parameters to default values (except for xtalname, which must be present) numdetparm = 10 ! number of detector parameter steps (2x+1) numeuler = 10 ! number of Euler angle steps (2x+1) DetParms = ( / 0.0 , 0.0 , 1500 0.0 / ) Eulertriplet = ( / 0.0 , 0.0 , 0.0 / ) DetParmstepsize = ( / 1.0 , 1.0 , 10 0.0 / ) Cubochoricstepsize = ( / 0.01 , 0.01 , 0.01 / ) if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = EBSDscandata ) close ( UNIT = dataunit , STATUS = 'keep' ) end if ! if we get here, then all appears to be ok, and we need to fill in the enl fields enl % numdetparm = numdetparm enl % numeuler = numeuler enl % DetParms = DetParms enl % DetParmstepsize = DetParmstepsize enl % Eulertriplet = Eulertriplet enl % Cubochoricstepsize = Cubochoricstepsize end subroutine GetEBSDdetparmscanNameList","tags":"","loc":"proc/getebsddetparmscannamelist.html","title":"GetEBSDdetparmscanNameList – Fortran Program"},{"text":"public recursive subroutine GetEBSDNameList(nmlfile, enl, initonly) Uses: error proc~~getebsdnamelist~~UsesGraph proc~getebsdnamelist GetEBSDNameList error error error->proc~getebsdnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill enl structure (used by EMEBSD.f90)\n @param nmlfile namelist file name\n @param enl EBSD name list structure\n @date 06/23/14  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(EBSDNameListType), intent(inout) :: enl logical, intent(in), optional :: initonly Calls proc~~getebsdnamelist~~CallsGraph proc~getebsdnamelist GetEBSDNameList emsoft_tonativepath emsoft_tonativepath proc~getebsdnamelist->emsoft_tonativepath fatalerror fatalerror proc~getebsdnamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~getebsdnamelist~~CalledByGraph proc~getebsdnamelist GetEBSDNameList proc~jsonreadebsdnamelist JSONreadEBSDNameList proc~jsonreadebsdnamelist->proc~getebsdnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetEBSDNameList Source Code recursive subroutine GetEBSDNameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetEBSDNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( EBSDNameListType ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numsx integer ( kind = irg ) :: numsy integer ( kind = irg ) :: binning integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: energyaverage real ( kind = sgl ) :: L real ( kind = sgl ) :: thetac real ( kind = sgl ) :: delta real ( kind = sgl ) :: xpc real ( kind = sgl ) :: ypc real ( kind = sgl ) :: omega real ( kind = sgl ) :: energymin real ( kind = sgl ) :: energymax real ( kind = sgl ) :: gammavalue real ( kind = sgl ) :: alphaBD real ( kind = sgl ) :: axisangle ( 4 ) real ( kind = dbl ) :: beamcurrent real ( kind = dbl ) :: dwelltime character ( 1 ) :: maskpattern character ( 1 ) :: spatialaverage character ( 3 ) :: scalingmode character ( 3 ) :: eulerconvention character ( 3 ) :: outputformat character ( fnlen ) :: anglefile character ( fnlen ) :: masterfile character ( fnlen ) :: energyfile character ( fnlen ) :: datafile ! define the IO namelist to facilitate passing variables to the program. namelist / EBSDdata / stdout , L , thetac , delta , numsx , numsy , xpc , ypc , anglefile , eulerconvention , masterfile , & energyfile , datafile , beamcurrent , dwelltime , energymin , energymax , binning , gammavalue , alphaBD , & scalingmode , axisangle , nthreads , outputformat , maskpattern , energyaverage , omega , spatialaverage ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 numsx = 640 ! [dimensionless] numsy = 480 ! [dimensionless] binning = 1 ! binning mode  (1, 2, 4, or 8) L = 2000 0.0 ! [microns] nthreads = 1 ! number of OpenMP threads energyaverage = 0 ! apply energy averaging (1) or not (0); useful for dictionary computations thetac = 0.0 ! [degrees] delta = 2 5.0 ! [microns] xpc = 0.0 ! [pixels] ypc = 0.0 ! [pixels] omega = 0.0 energymin = 1 5.0 ! minimum energy to consider energymax = 3 0.0 ! maximum energy to consider gammavalue = 1.0 ! gamma factor alphaBD = 0.0 ! transfer lens barrel distortion parameter axisangle = ( / 0.0 , 0.0 , 1.0 , 0.0 / ) ! no additional axis angle rotation beamcurrent = 1 4.513D0 ! beam current (actually emission current) in nano ampere dwelltime = 10 0.0D0 ! in microseconds maskpattern = 'n' ! 'y' or 'n' to include a circular mask scalingmode = 'not' ! intensity selector ('lin', 'gam', or 'not') eulerconvention = 'tsl' ! convention for the first Euler angle ['tsl' or 'hkl'] outputformat = 'gui' ! output format for 'bin' or 'gui' use anglefile = 'undefined' ! filename masterfile = 'undefined' ! filename energyfile = 'undefined' ! name of file that contains energy histograms for all scintillator pixels (output from MC program) datafile = 'undefined' ! output file name spatialaverage = 'n' if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = EBSDdata ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( energyfile ). eq . 'undefined' ) then call FatalError ( 'EMEBSD:' , ' energy file name is undefined in ' // nmlfile ) end if if ( trim ( anglefile ). eq . 'undefined' ) then call FatalError ( 'EMEBSD:' , ' angle file name is undefined in ' // nmlfile ) end if if ( trim ( masterfile ). eq . 'undefined' ) then call FatalError ( 'EMEBSD:' , ' master pattern file name is undefined in ' // nmlfile ) end if if ( trim ( datafile ). eq . 'undefined' ) then call FatalError ( 'EMEBSD:' , ' output file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields enl % stdout = stdout enl % numsx = numsx enl % numsy = numsy enl % binning = binning enl % L = L enl % nthreads = nthreads enl % energyaverage = energyaverage enl % thetac = thetac enl % delta = delta enl % xpc = xpc enl % ypc = ypc enl % energymin = energymin enl % energymax = energymax enl % gammavalue = gammavalue enl % alphaBD = alphaBD enl % axisangle = axisangle enl % beamcurrent = beamcurrent enl % dwelltime = dwelltime enl % maskpattern = maskpattern enl % scalingmode = scalingmode enl % eulerconvention = eulerconvention enl % outputformat = outputformat enl % anglefile = anglefile enl % masterfile = masterfile enl % energyfile = energyfile enl % datafile = datafile enl % omega = omega enl % spatialaverage = spatialaverage end subroutine GetEBSDNameList","tags":"","loc":"proc/getebsdnamelist.html","title":"GetEBSDNameList – Fortran Program"},{"text":"public recursive subroutine GetTKDNameList(nmlfile, enl, initonly) Uses: error proc~~gettkdnamelist~~UsesGraph proc~gettkdnamelist GetTKDNameList error error error->proc~gettkdnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill enl structure (used by EMTKD.f90)\n @param nmlfile namelist file name\n @param enl TKD name list structure\n @date 05/09/17  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(TKDNameListType), intent(inout) :: enl logical, intent(in), optional :: initonly Calls proc~~gettkdnamelist~~CallsGraph proc~gettkdnamelist GetTKDNameList emsoft_tonativepath emsoft_tonativepath proc~gettkdnamelist->emsoft_tonativepath fatalerror fatalerror proc~gettkdnamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetTKDNameList Source Code recursive subroutine GetTKDNameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetTKDNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( TKDNameListType ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numsx integer ( kind = irg ) :: numsy integer ( kind = irg ) :: binning integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: energyaverage real ( kind = sgl ) :: L real ( kind = sgl ) :: thetac real ( kind = sgl ) :: delta real ( kind = sgl ) :: xpc real ( kind = sgl ) :: ypc real ( kind = sgl ) :: omega real ( kind = sgl ) :: energymin real ( kind = sgl ) :: energymax real ( kind = sgl ) :: gammavalue real ( kind = sgl ) :: alphaBD real ( kind = sgl ) :: axisangle ( 4 ) real ( kind = dbl ) :: beamcurrent real ( kind = dbl ) :: dwelltime character ( 1 ) :: maskpattern character ( 1 ) :: spatialaverage character ( 3 ) :: scalingmode character ( 3 ) :: eulerconvention character ( 3 ) :: outputformat character ( fnlen ) :: anglefile character ( fnlen ) :: masterfile character ( fnlen ) :: energyfile character ( fnlen ) :: datafile ! define the IO namelist to facilitate passing variables to the program. namelist / TKDdata / stdout , L , thetac , delta , numsx , numsy , xpc , ypc , anglefile , eulerconvention , masterfile , & energyfile , datafile , beamcurrent , dwelltime , energymin , energymax , binning , gammavalue , alphaBD , & scalingmode , axisangle , nthreads , outputformat , maskpattern , energyaverage , omega , spatialaverage ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 numsx = 640 ! [dimensionless] numsy = 480 ! [dimensionless] binning = 1 ! binning mode  (1, 2, 4, or 8) L = 2000 0.0 ! [microns] nthreads = 1 ! number of OpenMP threads energyaverage = 0 ! apply energy averaging (1) or not (0); useful for dictionary computations thetac = 0.0 ! [degrees] delta = 2 5.0 ! [microns] xpc = 0.0 ! [pixels] ypc = 0.0 ! [pixels] omega = 0.0 energymin = 1 5.0 ! minimum energy to consider energymax = 3 0.0 ! maximum energy to consider gammavalue = 1.0 ! gamma factor alphaBD = 0.0 ! transfer lens barrel distortion parameter axisangle = ( / 0.0 , 0.0 , 1.0 , 0.0 / ) ! no additional axis angle rotation beamcurrent = 10 0.0D0 ! beam current (actually emission current) in nano ampere dwelltime = 10 0.0D0 ! in microseconds maskpattern = 'n' ! 'y' or 'n' to include a circular mask scalingmode = 'not' ! intensity selector ('lin', 'gam', or 'not') eulerconvention = 'tsl' ! convention for the first Euler angle ['tsl' or 'hkl'] outputformat = 'gui' ! output format for 'bin' or 'gui' use anglefile = 'undefined' ! filename masterfile = 'undefined' ! filename energyfile = 'undefined' ! name of file that contains energy histograms for all scintillator pixels (output from MC program) datafile = 'undefined' ! output file name spatialaverage = 'n' if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = TKDdata ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( energyfile ). eq . 'undefined' ) then call FatalError ( 'GetTKDNameList:' , ' energy file name is undefined in ' // nmlfile ) end if if ( trim ( anglefile ). eq . 'undefined' ) then call FatalError ( 'GetTKDNameList:' , ' angle file name is undefined in ' // nmlfile ) end if if ( trim ( masterfile ). eq . 'undefined' ) then call FatalError ( 'GetTKDNameList:' , ' master pattern file name is undefined in ' // nmlfile ) end if if ( trim ( datafile ). eq . 'undefined' ) then call FatalError ( 'GetTKDNameList:' , ' output file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields enl % stdout = stdout enl % numsx = numsx enl % numsy = numsy enl % binning = binning enl % L = L enl % nthreads = nthreads enl % energyaverage = energyaverage enl % thetac = thetac enl % delta = delta enl % xpc = xpc enl % ypc = ypc enl % energymin = energymin enl % energymax = energymax enl % gammavalue = gammavalue enl % alphaBD = alphaBD enl % axisangle = axisangle enl % beamcurrent = beamcurrent enl % dwelltime = dwelltime enl % maskpattern = maskpattern enl % scalingmode = scalingmode enl % eulerconvention = eulerconvention enl % outputformat = outputformat enl % anglefile = anglefile enl % masterfile = masterfile enl % energyfile = energyfile enl % datafile = datafile enl % omega = omega enl % spatialaverage = spatialaverage end subroutine GetTKDNameList","tags":"","loc":"proc/gettkdnamelist.html","title":"GetTKDNameList – Fortran Program"},{"text":"public recursive subroutine GetEBSDoverlapNameList(nmlfile, enl, initonly) Uses: error proc~~getebsdoverlapnamelist~~UsesGraph proc~getebsdoverlapnamelist GetEBSDoverlapNameList error error error->proc~getebsdoverlapnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill enl structure (used by EMEBSDoverlap.f90)\n @param nmlfile namelist file name\n @param enl EBSD name list structure\n @date 04/29/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(EBSDoverlapNameListType), intent(inout) :: enl logical, intent(in), optional :: initonly Calls proc~~getebsdoverlapnamelist~~CallsGraph proc~getebsdoverlapnamelist GetEBSDoverlapNameList emsoft_tonativepath emsoft_tonativepath proc~getebsdoverlapnamelist->emsoft_tonativepath fatalerror fatalerror proc~getebsdoverlapnamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~getebsdoverlapnamelist~~CalledByGraph proc~getebsdoverlapnamelist GetEBSDoverlapNameList proc~jsonreadebsdoverlapnamelist JSONreadEBSDoverlapNameList proc~jsonreadebsdoverlapnamelist->proc~getebsdoverlapnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetEBSDoverlapNameList Source Code recursive subroutine GetEBSDoverlapNameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetEBSDoverlapNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( EBSDoverlapNameListType ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: PatternAxisA ( 3 ) integer ( kind = irg ) :: HorizontalAxisA ( 3 ) real ( kind = sgl ) :: tA ( 3 ) real ( kind = sgl ) :: tB ( 3 ) real ( kind = sgl ) :: gA ( 3 ) real ( kind = sgl ) :: gB ( 3 ) real ( kind = sgl ) :: fracA character ( fnlen ) :: masterfileA character ( fnlen ) :: masterfileB character ( fnlen ) :: datafile ! define the IO namelist to facilitate passing variables to the program. namelist / EBSDdata / stdout , PatternAxisA , tA , tB , gA , gB , fracA , masterfileA , masterfileB , datafile , HorizontalAxisA ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 PatternAxisA = ( / 0 , 0 , 1 / ) ! center axis for output pattern HorizontalAxisA = ( / 1 , 0 , 0 / ) ! horizontal axis for output pattern tA = ( / 0.0 , 0.0 , 1.0 / ) ! direction vector in crystal A tB = ( / 0.0 , 0.0 , 1.0 / ) ! direction vector in crystal B gA = ( / 1.0 , 0.0 , 0.0 / ) ! plane normal in crystal A gB = ( / 1.0 , 0.0 , 0.0 / ) ! plane normal in crystal B fracA = 0.5 ! volume fraction of phase A masterfileA = 'undefined' ! filename masterfileB = 'undefined' ! filename datafile = 'undefined' ! output file name if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = EBSDdata ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( masterfileA ). eq . 'undefined' ) then call FatalError ( 'EMEBSD:' , ' master pattern file name A is undefined in ' // nmlfile ) end if if ( trim ( masterfileB ). eq . 'undefined' ) then call FatalError ( 'EMEBSD:' , ' master pattern file name B is undefined in ' // nmlfile ) end if if ( trim ( datafile ). eq . 'undefined' ) then call FatalError ( 'EMEBSD:' , ' output file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields enl % stdout = stdout enl % PatternAxisA = PatternAxisA enl % HorizontalAxisA = HorizontalAxisA enl % tA = tA enl % tB = tB enl % gA = gA enl % gB = gB enl % fracA = fracA enl % masterfileA = masterfileA enl % masterfileB = masterfileB enl % datafile = datafile end subroutine GetEBSDoverlapNameList","tags":"","loc":"proc/getebsdoverlapnamelist.html","title":"GetEBSDoverlapNameList – Fortran Program"},{"text":"public recursive subroutine GetECPZANameList(nmlfile, ecpnl, initonly) Uses: error proc~~getecpzanamelist~~UsesGraph proc~getecpzanamelist GetECPZANameList error error error->proc~getecpzanamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill ecpnl structure (used by EMECPZA.f90)\n @param nmlfile namelist file name\n @param ecpnl name list structure\n @date 01/25/17 MDG 1.0 new structure Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(ECPZANameListType), intent(inout) :: ecpnl logical, intent(in), optional :: initonly Calls proc~~getecpzanamelist~~CallsGraph proc~getecpzanamelist GetECPZANameList emsoft_tonativepath emsoft_tonativepath proc~getecpzanamelist->emsoft_tonativepath fatalerror fatalerror proc~getecpzanamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetECPZANameList Source Code recursive subroutine GetECPZANameList ( nmlfile , ecpnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetECPZANameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( ECPZANameListType ), INTENT ( INOUT ) :: ecpnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: fn ( 3 ) integer ( kind = irg ) :: k ( 3 ) integer ( kind = irg ) :: npix integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: dmin real ( kind = sgl ) :: ktmax character ( 1 ) :: maskpattern character ( fnlen ) :: energyfile character ( fnlen ) :: outname namelist / ECPZAlist / k , fn , dmin , ktmax , npix , outname , nthreads , maskpattern , energyfile ! default values k = ( / 0 , 0 , 1 / ) ! beam direction [direction indices] fn = ( / 0 , 0 , 1 / ) ! foil normal [direction indices] dmin = 0.05 ! smallest d-spacing to include in dynamical matrix [nm] ktmax = 0.0 ! beam convergence in units of |g_a| npix = 256 ! output arrays will have size npix x npix nthreads = 1 maskpattern = 'n' outname = 'undefined' ! output filename energyfile = 'undefined' ! output filename if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = ECPZAlist ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( outname ). eq . 'undefined' ) then call FatalError ( 'EMECPZA:' , ' output file name is undefined in ' // nmlfile ) end if if ( trim ( energyfile ). eq . 'undefined' ) then call FatalError ( 'EMECPZA:' , ' Monte Carlo input file name is undefined in ' // nmlfile ) end if end if ecpnl % fn = fn ecpnl % k = k ecpnl % npix = npix ecpnl % dmin = dmin ecpnl % ktmax = ktmax ecpnl % outname = outname ecpnl % energyfile = energyfile ecpnl % nthreads = nthreads ecpnl % maskpattern = maskpattern end subroutine GetECPZANameList","tags":"","loc":"proc/getecpzanamelist.html","title":"GetECPZANameList – Fortran Program"},{"text":"public recursive subroutine GetECPNameList(nmlfile, ecpnl, initonly) Uses: error proc~~getecpnamelist~~UsesGraph proc~getecpnamelist GetECPNameList error error error->proc~getecpnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill ecpnl structure (used by EMECP.f90)\n @param nmlfile namelist file name\n @param knl Kossel name list structure\n @date 06/13/14  MDG 1.0 new routine\n @date 11/25/14  MDG 2.0 added parameters for film on substrate mode\n @date 10/15/15 SS  1.2 changes for release Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(ECPNameListType), intent(inout) :: ecpnl logical, intent(in), optional :: initonly Calls proc~~getecpnamelist~~CallsGraph proc~getecpnamelist GetECPNameList emsoft_tonativepath emsoft_tonativepath proc~getecpnamelist->emsoft_tonativepath fatalerror fatalerror proc~getecpnamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetECPNameList Source Code recursive subroutine GetECPNameList ( nmlfile , ecpnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetECPNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( ECPNameListType ), INTENT ( INOUT ) :: ecpnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: fn_f ( 3 ) integer ( kind = irg ) :: fn_s ( 3 ) integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: npix integer ( kind = irg ) :: gF ( 3 ) integer ( kind = irg ) :: gS ( 3 ) integer ( kind = irg ) :: tF ( 3 ) integer ( kind = irg ) :: tS ( 3 ) real ( kind = sgl ) :: dmin real ( kind = sgl ) :: thetac real ( kind = sgl ) :: filmthickness character ( fnlen ) :: xtalname character ( fnlen ) :: xtalname2 character ( fnlen ) :: energyfile character ( fnlen ) :: filmfile character ( fnlen ) :: subsfile character ( fnlen ) :: masterfile character ( fnlen ) :: datafile character ( 1 ) :: maskpattern character ( fnlen ) :: anglefile character ( 3 ) :: eulerconvention integer ( kind = irg ) :: numangle_anglefile real ( kind = sgl ) :: gammavalue character ( 3 ) :: outputformat real ( kind = dbl ) :: sampletilt real ( kind = sgl ) :: workingdistance real ( kind = sgl ) :: Rin real ( kind = sgl ) :: Rout ! namelist /ECPlist/ stdout, xtalname, voltage, k, fn, dmin, distort, abcdist, albegadist, ktmax, & namelist / ECPlist / stdout , xtalname , xtalname2 , fn_f , fn_s , dmin , filmthickness , anglefile , & nthreads , thetac , npix , maskpattern , eulerconvention , Rin , Rout , & gF , gS , tF , tS , energyfile , filmfile , subsfile , masterfile , datafile , & numangle_anglefile , gammavalue , outputformat , sampletilt , workingdistance ! default values stdout = 6 ! standard output fn_f = ( / 0 , 0 , 1 / ) ! beam direction [direction indices] fn_s = ( / 0 , 0 , 1 / ) ! foil normal [direction indices] gF = ( / 0 , 0 , 0 / ) ! plane normal in film gS = ( / 0 , 0 , 0 / ) ! plane normal in substrate tF = ( / 0 , 0 , 0 / ) ! direction in film tS = ( / 0 , 0 , 0 / ) ! direction in substrate npix = 200 ! number of pixels in final image (npix x npix) nthreads = 1 ! number of OpenMP threads dmin = 0.04 ! smallest d-spacing to include in dynamical matrix [nm] thetac = 0.0 ! beam convergence in mrad (either ktmax or thetac must be given) filmthickness = 0.0 ! 0.0 if there is no film xtalname = 'undefined' ! initial value to check that the keyword is present in the nml file xtalname2 = 'undefined' ! initial value for substrate structure name energyfile = 'undefined' filmfile = 'undefined' subsfile = 'undefined' masterfile = 'undefined' datafile = 'undefined' maskpattern = 'y' anglefile = 'undefined' eulerconvention = 'hkl' numangle_anglefile = 0 gammavalue = 1.0 outputformat = 'gui' sampletilt = 0.D0 Workingdistance = 1 3.0 Rin = 2.0 Rout = 6.0 if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = ECPlist ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'EMEECP:' , ' crystal file name is undefined in ' // nmlfile ) end if end if ecpnl % stdout = stdout ecpnl % fn_f = fn_f ecpnl % fn_s = fn_s ecpnl % gF = gF ecpnl % gS = gS ecpnl % tF = tF ecpnl % tS = tS ecpnl % npix = npix ecpnl % nthreads = nthreads ecpnl % dmin = dmin ecpnl % thetac = thetac ecpnl % filmthickness = filmthickness ecpnl % datafile = datafile ecpnl % xtalname = xtalname ecpnl % xtalname2 = xtalname2 ecpnl % energyfile = energyfile ecpnl % filmfile = filmfile ecpnl % subsfile = subsfile ecpnl % masterfile = masterfile ecpnl % maskpattern = maskpattern ecpnl % anglefile = anglefile ecpnl % numangle_anglefile = numangle_anglefile ecpnl % eulerconvention = eulerconvention ecpnl % gammavalue = gammavalue ecpnl % outputformat = outputformat ecpnl % sampletilt = sampletilt ecpnl % workingdistance = workingdistance ecpnl % Rin = Rin ecpnl % Rout = Rout end subroutine GetECPNameList","tags":"","loc":"proc/getecpnamelist.html","title":"GetECPNameList – Fortran Program"},{"text":"public recursive subroutine GetLACBEDNameList(nmlfile, lacbednl, initonly) Uses: error proc~~getlacbednamelist~~UsesGraph proc~getlacbednamelist GetLACBEDNameList error error error->proc~getlacbednamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill lacbednl structure (used by EMLACBED.f90)\n @param nmlfile namelist file name\n @param lacbednl LACBED name list structure\n @date 07/01/14  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(LACBEDNameListType), intent(inout) :: lacbednl logical, intent(in), optional :: initonly Calls proc~~getlacbednamelist~~CallsGraph proc~getlacbednamelist GetLACBEDNameList emsoft_tonativepath emsoft_tonativepath proc~getlacbednamelist->emsoft_tonativepath fatalerror fatalerror proc~getlacbednamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetLACBEDNameList Source Code recursive subroutine GetLACBEDNameList ( nmlfile , lacbednl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetLACBEDNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( LACBEDNameListType ), INTENT ( INOUT ) :: lacbednl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: k ( 3 ) integer ( kind = irg ) :: fn ( 3 ) integer ( kind = irg ) :: maxHOLZ integer ( kind = irg ) :: numthick integer ( kind = irg ) :: npix integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: voltage real ( kind = sgl ) :: dmin real ( kind = sgl ) :: convergence real ( kind = sgl ) :: startthick real ( kind = sgl ) :: thickinc real ( kind = sgl ) :: minten character ( fnlen ) :: xtalname character ( fnlen ) :: outname namelist / inputlist / stdout , xtalname , voltage , k , fn , dmin , convergence , minten , & nthreads , startthick , thickinc , numthick , outname , npix , maxHOLZ stdout = 6 ! standard output k = ( / 0 , 0 , 1 / ) ! beam direction [direction indices] fn = ( / 0 , 0 , 1 / ) ! foil normal [direction indices] maxHOLZ = 2 ! maximum HOLZ layer index to be used for the output file; note that his number ! does not affect the actual computations; it only determines which reflection ! families will end up in the output file numthick = 10 ! number of increments npix = 256 ! output arrays will have size npix x npix nthreads = 1 ! number of computational threads voltage = 20000 0.0 ! acceleration voltage [V] dmin = 0.025 ! smallest d-spacing to include in dynamical matrix [nm] convergence = 2 5.0 ! beam convergence angle [mrad] startthick = 1 0.0 ! starting thickness [nm] thickinc = 1 0.0 ! thickness increment minten = 1.0E-5 ! minimum intensity in diffraction disk to make it into the output file xtalname = 'undefined' ! initial value to check that the keyword is present in the nml file outname = 'lacbedout.data' ! output filename if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = inputlist ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'EMLACBED:' , ' structure file name is undefined in ' // nmlfile ) end if end if lacbednl % stdout = stdout lacbednl % k = k lacbednl % fn = fn lacbednl % maxHOLZ = maxHOLZ lacbednl % numthick = numthick lacbednl % npix = npix lacbednl % nthreads = nthreads lacbednl % voltage = voltage lacbednl % dmin = dmin lacbednl % convergence = convergence lacbednl % startthick = startthick lacbednl % thickinc = thickinc lacbednl % minten = minten lacbednl % xtalname = xtalname lacbednl % outname = outname end subroutine GetLACBEDNameList","tags":"","loc":"proc/getlacbednamelist.html","title":"GetLACBEDNameList – Fortran Program"},{"text":"public recursive subroutine GetECPpatternNameList(nmlfile, ecpnl, initonly) Uses: error proc~~getecppatternnamelist~~UsesGraph proc~getecppatternnamelist GetECPpatternNameList error error error->proc~getecppatternnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMECPpattern.f90)\n @param nmlfile namelist file name\n @param emnl ECP name list structure\n @date 06/19/14  SS 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(ECPpatternNameListType), intent(inout) :: ecpnl logical, intent(in), optional :: initonly Calls proc~~getecppatternnamelist~~CallsGraph proc~getecppatternnamelist GetECPpatternNameList emsoft_tonativepath emsoft_tonativepath proc~getecppatternnamelist->emsoft_tonativepath fatalerror fatalerror proc~getecppatternnamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetECPpatternNameList Source Code recursive subroutine GetECPpatternNameList ( nmlfile , ecpnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetECPpatternNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( ECPpatternNameListType ), INTENT ( INOUT ) :: ecpnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: npix real ( kind = sgl ) :: thetac real ( kind = sgl ) :: k ( 3 ) character ( fnlen ) :: masterfile character ( fnlen ) :: outname ! define the IO namelist to facilitate passing variables to the program. namelist / ECPvars / stdout , npix , masterfile , outname , thetac , k ! set the input parameters to default values (except for masterfile, which must be present) stdout = 6 npix = 256 thetac = 5.0 k = ( / 0.0 , 0.0 , 1.0 / ) masterfile = 'undefined' ! default filename for master data from EMECPmaster outname = 'ECP.data' ! default filename for final output if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = ECPvars ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( masterfile ). eq . 'undefined' ) then call FatalError ( 'EMECP:' , ' master file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields ecpnl % stdout = stdout ecpnl % npix = npix ecpnl % thetac = thetac ecpnl % k = k ecpnl % masterfile = masterfile ecpnl % outname = outname end subroutine GetECPpatternNameList","tags":"","loc":"proc/getecppatternnamelist.html","title":"GetECPpatternNameList – Fortran Program"},{"text":"public recursive subroutine GetPEDkinNameList(nmlfile, pednl, initonly) Uses: error proc~~getpedkinnamelist~~UsesGraph proc~getpedkinnamelist GetPEDkinNameList error error error->proc~getpedkinnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill pednl structure (used by EMpedKIN.f90)\n @param nmlfile namelist file name\n @param pednl PED name list structure\n @date 03/02/15 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(PEDkinNameListType), intent(inout) :: pednl logical, intent(in), optional :: initonly Calls proc~~getpedkinnamelist~~CallsGraph proc~getpedkinnamelist GetPEDkinNameList emsoft_tonativepath emsoft_tonativepath proc~getpedkinnamelist->emsoft_tonativepath fatalerror fatalerror proc~getpedkinnamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetPEDkinNameList Source Code recursive subroutine GetPEDkinNameList ( nmlfile , pednl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetPEDkinNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( PEDkinNameListType ), INTENT ( INOUT ) :: pednl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: npix integer ( kind = irg ) :: ncubochoric integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: voltage real ( kind = sgl ) :: thickness real ( kind = sgl ) :: rnmpp real ( kind = sgl ) :: dmin character ( fnlen ) :: xtalname character ( fnlen ) :: outname ! define the IO namelist to facilitate passing variables to the program. namelist / PEDkinNameList / stdout , xtalname , voltage , npix , rnmpp , ncubochoric , nthreads , & thickness , outname , dmin ! set the input parameters to default values (except for xtalname, which must be present) xtalname = 'undefined' ! initial value to check that the keyword is present in the nml file stdout = 6 ! standard output voltage = 20000 0.0 ! acceleration voltage [V] nthreads = 1 ! number of OpenMP threads to start thickness = 1 0.0 ! sample thickness [nm] npix = 256 ! output arrays will have size npix x npix outname = 'pedout.data' ! output filename dmin = 0.04 ! smallest d-spacing [nm] ncubochoric = 100 ! number of samples along the cubochoric edge length rnmpp = 0.2 ! nm&#94;{-1} per pattern pixel if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = PEDkinNameList ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'EMPED:' , ' crystal structure file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the pednl fields pednl % xtalname = xtalname pednl % stdout = stdout pednl % voltage = voltage pednl % thickness = thickness pednl % dmin = dmin pednl % npix = npix pednl % nthreads = nthreads pednl % outname = outname pednl % rnmpp = rnmpp pednl % ncubochoric = ncubochoric end subroutine GetPEDKINNameList","tags":"","loc":"proc/getpedkinnamelist.html","title":"GetPEDkinNameList – Fortran Program"},{"text":"public recursive subroutine GetPEDZANameList(nmlfile, pednl, initonly) Uses: error proc~~getpedzanamelist~~UsesGraph proc~getpedzanamelist GetPEDZANameList error error error->proc~getpedzanamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill pednl structure (used by EMPEDZA.f90)\n @param nmlfile namelist file name\n @param pednl PED name list structure\n @date 07/09/14 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(PEDZANameListType), intent(inout) :: pednl logical, intent(in), optional :: initonly Calls proc~~getpedzanamelist~~CallsGraph proc~getpedzanamelist GetPEDZANameList emsoft_tonativepath emsoft_tonativepath proc~getpedzanamelist->emsoft_tonativepath fatalerror fatalerror proc~getpedzanamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetPEDZANameList Source Code recursive subroutine GetPEDZANameList ( nmlfile , pednl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetPEDZANameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( PEDZANameListType ), INTENT ( INOUT ) :: pednl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: k ( 3 ) integer ( kind = irg ) :: fn ( 3 ) integer ( kind = irg ) :: precsample integer ( kind = irg ) :: precazimuthal integer ( kind = irg ) :: npix integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: voltage real ( kind = sgl ) :: dmin real ( kind = sgl ) :: precangle real ( kind = sgl ) :: prechalfwidth real ( kind = sgl ) :: thickness real ( kind = sgl ) :: camlen character ( 5 ) :: filemode character ( fnlen ) :: xtalname character ( fnlen ) :: outname ! define the IO namelist to facilitate passing variables to the program. namelist / EMPEDZA / stdout , xtalname , voltage , k , fn , dmin , precangle , prechalfwidth , precsample , precazimuthal , & thickness , outname , npix , camlen , filemode , nthreads ! set the input parameters to default values (except for xtalname, which must be present) xtalname = 'undefined' ! initial value to check that the keyword is present in the nml file stdout = 6 ! standard output voltage = 20000 0.0 ! acceleration voltage [V] k = ( / 0 , 0 , 1 / ) ! beam direction [direction indices] fn = ( / 0 , 0 , 1 / ) ! foil normal [direction indices] dmin = 0.025 ! smallest d-spacing to include in dynamical matrix [nm] precangle = 1 0.472 ! beam precession angle [mrad]; default = 0.6 degrees prechalfwidth = 0.25 ! beam half width in the tilt direction [mrad] nthreads = 1 ! number of OpenMP threads to start precsample = 10 ! number of samples (concentric circles) in beam half width (total = 2*precsample + 1) precazimuthal = 360 ! number of azimuthal samples for each precession circle thickness = 1 0.0 ! sample thickness [nm] filemode = 'total' ! 'total' mode or 'eachp' npix = 256 ! output arrays will have size npix x npix outname = 'pedout.data' ! output filename camlen = 100 0.0 ! camera length [mm] if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = EMPEDZA ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'EMPEDZA:' , ' crystal structure file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the pednl fields pednl % xtalname = xtalname pednl % stdout = stdout pednl % voltage = voltage pednl % k = k pednl % fn = fn pednl % dmin = dmin pednl % precangle = precangle pednl % prechalfwidth = prechalfwidth pednl % precsample = precsample pednl % precazimuthal = precazimuthal pednl % thickness = thickness pednl % filemode = filemode pednl % npix = npix pednl % nthreads = nthreads pednl % outname = outname pednl % camlen = camlen end subroutine GetPEDZANameList","tags":"","loc":"proc/getpedzanamelist.html","title":"GetPEDZANameList – Fortran Program"},{"text":"public recursive subroutine GetECCINameList(nmlfile, eccinl, initonly) Uses: error proc~~geteccinamelist~~UsesGraph proc~geteccinamelist GetECCINameList error error error->proc~geteccinamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill eccinl structure (used by EMECCI.f90)\n @param nmlfile namelist file name\n @param eccinl ECCI name list structure\n @date 10/04/14 MDG 1.0 new routine\n @date 11/24/15 MDG 1.1 adapted for new namelist variables Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(ECCINameListType), intent(inout) :: eccinl logical, intent(in), optional :: initonly Calls proc~~geteccinamelist~~CallsGraph proc~geteccinamelist GetECCINameList emsoft_tonativepath emsoft_tonativepath proc~geteccinamelist->emsoft_tonativepath fatalerror fatalerror proc~geteccinamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetECCINameList Source Code recursive subroutine GetECCINameList ( nmlfile , eccinl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetECCINameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( ECCINameListType ), INTENT ( INOUT ) :: eccinl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: i integer ( kind = irg ) :: stdout integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: k ( 3 ) integer ( kind = irg ) :: nktstep integer ( kind = irg ) :: DF_npix integer ( kind = irg ) :: DF_npiy real ( kind = sgl ) :: voltage real ( kind = sgl ) :: dkt real ( kind = sgl ) :: ktmax real ( kind = sgl ) :: lauec ( 2 ) real ( kind = sgl ) :: lauec2 ( 2 ) real ( kind = sgl ) :: dmin real ( kind = sgl ) :: DF_L real ( kind = sgl ) :: DF_slice character ( 4 ) :: dispmode character ( 4 ) :: summode character ( 5 ) :: progmode character ( fnlen ) :: xtalname character ( fnlen ) :: defectfilename character ( fnlen ) :: dispfile character ( fnlen ) :: dataname character ( fnlen ) :: ECPname character ( fnlen ) :: sgname ! define the IO namelist to facilitate passing variables to the program. namelist / ECCIlist / DF_L , DF_npix , DF_npiy , DF_slice , dmin , sgname , stdout , & progmode , dispfile , ktmax , dkt , ECPname , summode , lauec , lauec2 , & dispmode , nthreads , xtalname , voltage , k , nktstep , & dataname , defectfilename ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 nthreads = 1 k = ( / 0 , 0 , 1 / ) nktstep = 20 DF_npix = 256 DF_npiy = 256 voltage = 3000 0. dkt = 0.1 ktmax = 5.0 lauec = ( / 0.0 , 0.0 / ) lauec2 = ( / 0.0 , 0.0 / ) dmin = 0.1 DF_L = 1.0 DF_slice = 1.0 dispmode = 'not' summode = 'diag' progmode = 'array' xtalname = 'undefined' defectfilename = 'undefined' dispfile = 'displacements.data' dataname = 'ECCIout.data' ECPname = 'undefined' sgname = 'nofile' if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = ECCIlist ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'EMECCI:' , ' crystal structure file name is undefined in ' // nmlfile ) end if ! make sure the ECPname variable has been properly defined if ( trim ( ECPname ). eq . 'undefined' ) then call FatalError ( 'EMECCI:' , ' ECP pattern file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields eccinl % stdout = stdout eccinl % nthreads = nthreads eccinl % k = k eccinl % nktstep = nktstep eccinl % DF_npix = DF_npix eccinl % DF_npiy = DF_npiy eccinl % voltage = voltage eccinl % dkt = dkt eccinl % ktmax = ktmax eccinl % lauec = lauec eccinl % lauec2 = lauec2 eccinl % dmin = dmin eccinl % DF_L = DF_L eccinl % DF_slice = DF_slice eccinl % dispmode = dispmode eccinl % summode = summode eccinl % progmode = progmode eccinl % xtalname = xtalname eccinl % defectfilename = defectfilename eccinl % dispfile = dispfile eccinl % dataname = dataname eccinl % ECPname = ECPname eccinl % sgname = sgname end subroutine GetECCINameList","tags":"","loc":"proc/geteccinamelist.html","title":"GetECCINameList – Fortran Program"},{"text":"public recursive subroutine GetRFZNameList(nmlfile, rfznl, initonly) Uses: error proc~~getrfznamelist~~UsesGraph proc~getrfznamelist GetRFZNameList error error error->proc~getrfznamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill rfznl structure (used by EMsampleRFZ.f90)\n @param nmlfile namelist file name\n @param rfznl RFZ name list structure\n @date 12/09/14 MDG 1.0 new routine\n @date 08/18/15 MDG 1.1 added options for all seven representations\n @date 01/17/15 MDG 1.2 added gridtype option\n @date 12/22/16 MDG 1.3 added new sampling mode\n @date 02/01/17 MDG 1.4 added conical sampling mode Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(RFZNameListType), intent(inout) :: rfznl logical, intent(in), optional :: initonly Calls proc~~getrfznamelist~~CallsGraph proc~getrfznamelist GetRFZNameList emsoft_tonativepath emsoft_tonativepath proc~getrfznamelist->emsoft_tonativepath Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetRFZNameList Source Code recursive subroutine GetRFZNameList ( nmlfile , rfznl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetRFZNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( RFZNameListType ), INTENT ( INOUT ) :: rfznl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: pgnum , nsteps , gridtype real ( kind = dbl ) :: rodrigues ( 4 ), maxmisor , conevector ( 3 ), semiconeangle character ( fnlen ) :: samplemode character ( fnlen ) :: euoutname character ( fnlen ) :: cuoutname character ( fnlen ) :: hooutname character ( fnlen ) :: rooutname character ( fnlen ) :: quoutname character ( fnlen ) :: omoutname character ( fnlen ) :: axoutname ! namelist components namelist / RFZlist / pgnum , nsteps , gridtype , euoutname , cuoutname , hooutname , rooutname , quoutname , omoutname , axoutname , & samplemode , rodrigues , maxmisor , conevector , semiconeangle ! initialize to default values pgnum = 32 nsteps = 50 gridtype = 0 rodrigues = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) ! initialize as the identity rotation maxmisor = 5.D0 ! in degrees samplemode = 'RFZ' ! or 'MIS' for sampling inside a ball with constant misorientation w.r.t. rodrigues ! or 'CON' for conical sampling around a unitvector for a cone with semi opening angle semiconangle conevector = ( / 0.D0 , 0.D0 , 1.D0 / ) ! default unit vector for cone axis semiconeangle = 2.0 ! default opening semi-angle (in degrees) euoutname = 'undefined' cuoutname = 'undefined' hooutname = 'undefined' rooutname = 'undefined' quoutname = 'undefined' omoutname = 'undefined' axoutname = 'undefined' if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = RFZlist ) close ( UNIT = dataunit , STATUS = 'keep' ) end if ! and copy the variables to the rfznl variable rfznl % pgnum = pgnum rfznl % nsteps = nsteps rfznl % gridtype = gridtype rfznl % rodrigues = rodrigues rfznl % maxmisor = maxmisor rfznl % samplemode = samplemode rfznl % conevector = conevector rfznl % semiconeangle = semiconeangle rfznl % euoutname = euoutname rfznl % cuoutname = cuoutname rfznl % hooutname = hooutname rfznl % rooutname = rooutname rfznl % quoutname = quoutname rfznl % omoutname = omoutname rfznl % axoutname = axoutname end subroutine GetRFZNameList","tags":"","loc":"proc/getrfznamelist.html","title":"GetRFZNameList – Fortran Program"},{"text":"public recursive subroutine GetDictIndxOpenCLNameList(nmlfile, dictindxnl, initonly) Uses: error local proc~~getdictindxopenclnamelist~~UsesGraph proc~getdictindxopenclnamelist GetDictIndxOpenCLNameList error error error->proc~getdictindxopenclnamelist local local local->proc~getdictindxopenclnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief read namelist file and fill DictIndxOpenCLListType (used by EMDictIndxOpenCL.f90)\n @param nmlfile namelist file name\n @param DictIndxOpenCL name list structure\n @date 13/01/15 SS 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(DictIndxOpenCLListType), intent(inout) :: dictindxnl logical, intent(in), optional :: initonly Calls proc~~getdictindxopenclnamelist~~CallsGraph proc~getdictindxopenclnamelist GetDictIndxOpenCLNameList emsoft_tonativepath emsoft_tonativepath proc~getdictindxopenclnamelist->emsoft_tonativepath fatalerror fatalerror proc~getdictindxopenclnamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetDictIndxOpenCLNameList Source Code recursive subroutine GetDictIndxOpenCLNameList ( nmlfile , dictindxnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetDictIndxOpenCLNameList use error use local IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( DictIndxOpenCLListType ), INTENT ( INOUT ) :: dictindxnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: numexptsingle integer ( kind = irg ) :: numdictsingle integer ( kind = irg ) :: totnumexpt integer ( kind = irg ) :: totnumdict integer ( kind = irg ) :: imght integer ( kind = irg ) :: imgwd integer ( kind = irg ) :: nnk character ( fnlen ) :: exptfile character ( fnlen ) :: dictfile character ( fnlen ) :: eulerfile logical :: MeanSubtraction logical :: patternflip ! define the IO namelist to facilitate passing variables to the program. namelist / DictIndxOpenCLvars / numexptsingle , numdictsingle , totnumexpt , totnumdict ,& imght , imgwd , exptfile , dictfile , eulerfile , nnk , MeanSubtraction , patternflip ! set some of the input parameters to default values numdictsingle = 1024 numexptsingle = 1024 imght = 0 imgwd = 0 nnk = 40 exptfile = 'undefined' dictfile = 'undefined' eulerfile = 'undefined' totnumdict = 0 totnumexpt = 0 MeanSubtraction = . TRUE . patternflip = . TRUE . if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = DictIndxOpenCLvars ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( exptfile ). eq . 'undefined' ) then call FatalError ( 'EMDictIndxOpenCL:' , ' experimental file name is undefined in ' // nmlfile ) end if if ( trim ( dictfile ). eq . 'undefined' ) then call FatalError ( 'EMDictIndxOpenCL:' , ' dictionary file name is undefined in ' // nmlfile ) end if if ( trim ( eulerfile ). eq . 'undefined' ) then call FatalError ( 'EMDictIndxOpenCL:' , ' euler angle file name is undefined in ' // nmlfile ) end if if ( totnumexpt . eq . 0 ) then call FatalError ( 'EMDictIndxOpenCL:' , ' total number of experimental patterns is undefined in ' // nmlfile ) end if if ( totnumdict . eq . 0 ) then call FatalError ( 'EMDictIndxOpenCL:' , ' total number of dictionary patterns is undefined in ' // nmlfile ) end if if ( imght . eq . 0 ) then call FatalError ( 'EMDictIndxOpenCL:' , ' height of single pattern is undefined in ' // nmlfile ) end if if ( imgwd . eq . 0 ) then call FatalError ( 'EMDictIndxOpenCL:' , ' width of single pattern is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields dictindxnl % numexptsingle = numexptsingle dictindxnl % numdictsingle = numdictsingle dictindxnl % imght = imght dictindxnl % imgwd = imgwd dictindxnl % exptfile = exptfile dictindxnl % dictfile = dictfile dictindxnl % eulerfile = eulerfile dictindxnl % totnumdict = totnumdict dictindxnl % totnumexpt = totnumexpt dictindxnl % nnk = nnk dictindxnl % MeanSubtraction = MeanSubtraction dictindxnl % patternflip = patternflip end subroutine GetDictIndxOpenCLNameList","tags":"","loc":"proc/getdictindxopenclnamelist.html","title":"GetDictIndxOpenCLNameList – Fortran Program"},{"text":"public recursive subroutine GetPEDIndxNameList(nmlfile, pednl, initonly) Uses: error local proc~~getpedindxnamelist~~UsesGraph proc~getpedindxnamelist GetPEDIndxNameList error error error->proc~getpedindxnamelist local local local->proc~getpedindxnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief read namelist file and fill PEDKINIndxListType (used by EMPEDIndexing.f90)\n @param nmlfile namelist file name\n @param pednl PEDKINIndx name list structure\n @date 13/01/15 SS 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(PEDKINIndxListType), intent(inout) :: pednl logical, intent(in), optional :: initonly Calls proc~~getpedindxnamelist~~CallsGraph proc~getpedindxnamelist GetPEDIndxNameList emsoft_tonativepath emsoft_tonativepath proc~getpedindxnamelist->emsoft_tonativepath fatalerror fatalerror proc~getpedindxnamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetPEDIndxNameList Source Code recursive subroutine GetPEDIndxNameList ( nmlfile , pednl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetPEDIndxNameList use error use local IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( PEDKINIndxListType ), INTENT ( INOUT ) :: pednl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: npix integer ( kind = irg ) :: ncubochoric real ( kind = sgl ) :: voltage real ( kind = sgl ) :: dmin real ( kind = sgl ) :: thickness real ( kind = sgl ) :: rnmpp ! reciprocal nanometers per pixel character ( fnlen ) :: xtalname integer ( kind = irg ) :: numexptsingle integer ( kind = irg ) :: numdictsingle integer ( kind = irg ) :: ipf_ht integer ( kind = irg ) :: ipf_wd integer ( kind = irg ) :: nnk real ( kind = sgl ) :: sgmax ! maximum sg value for a beam to be considered real ( kind = sgl ) :: ww ! 2*ww+1 is the size of the spot real ( kind = sgl ) :: var ! variance of gaussian peak character ( fnlen ) :: exptfile character ( fnlen ) :: datafile character ( fnlen ) :: ctffile integer ( kind = irg ) :: devid integer ( kind = irg ) :: platid integer ( kind = irg ) :: nthreads ! define the IO namelist to facilitate passing variables to the program. namelist / inputlist / npix , ncubochoric , numexptsingle , numdictsingle , voltage , dmin , thickness , rnmpp , xtalname , & exptfile , nnk , ipf_ht , ipf_wd , nthreads , sgmax , ww , var , devid , platid , datafile , ctffile ! set some of the input parameters to default values npix = 0 ncubochoric = 50 voltage = 20000 0.0 dmin = 0.04 thickness = 5 0.0 rnmpp = 0.20 xtalname = 'undefined' numdictsingle = 1024 numexptsingle = 1024 nnk = 40 exptfile = 'undefined' datafile = 'undefined' ctffile = 'undefined' sgmax = 0.50 ww = 3 var = 0.0020 ipf_ht = 0 ipf_wd = 0 nthreads = 1 platid = 1 devid = 1 if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = inputlist ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( npix . eq . 0 ) then call FatalError ( 'EMPEDIndexing:' , ' size of dictionary pattern not specified or set to 0 in ' // nmlfile ) end if if ( trim ( xtalname ) . eq . 'undefined' ) then call FatalError ( 'EMPEDIndexing:' , ' crystal file undefined in ' // nmlfile ) end if if ( trim ( exptfile ). eq . 'undefined' ) then call FatalError ( 'EMPEDIndexing:' , ' experimental file name is undefined in ' // nmlfile ) end if if ( ipf_ht . eq . 0 ) then call FatalError ( 'EMPEDIndexing:' , ' total number of experimental patterns is either set to 0 or is undefined in ' // nmlfile ) end if if ( ipf_wd . eq . 0 ) then call FatalError ( 'EMPEDIndexing:' , ' total number of experimental patterns is either set to 0 or is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields pednl % npix = npix pednl % ncubochoric = ncubochoric pednl % voltage = voltage pednl % dmin = dmin pednl % thickness = thickness pednl % rnmpp = rnmpp pednl % xtalname = xtalname pednl % numexptsingle = numexptsingle pednl % numdictsingle = numdictsingle pednl % exptfile = exptfile pednl % datafile = datafile pednl % ctffile = ctffile pednl % nnk = nnk pednl % sgmax = sgmax pednl % ww = ww pednl % var = var pednl % ipf_ht = ipf_ht pednl % ipf_wd = ipf_wd pednl % nthreads = nthreads pednl % platid = platid pednl % devid = devid end subroutine GetPEDIndxNameList","tags":"","loc":"proc/getpedindxnamelist.html","title":"GetPEDIndxNameList – Fortran Program"},{"text":"public recursive subroutine GetEBSDIndexingNameList(nmlfile, enl, initonly) Uses: error proc~~getebsdindexingnamelist~~UsesGraph proc~getebsdindexingnamelist GetEBSDIndexingNameList error error error->proc~getebsdindexingnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief read namelist file and fill enl structure (used by EMDynamicEBSDIndeixing.f90)\n @param nmlfile namelist file name\n @param enl EBSD indexing name list structure\n @date 06/10/15  SS 1.0 new routine\n @date 11/19/15  SS 1.1 added new variables\n @date 01/26/16  SS 1.2 adjusted for EBSDIndexing Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(EBSDIndexingNameListType), intent(inout) :: enl logical, intent(in), optional :: initonly Calls proc~~getebsdindexingnamelist~~CallsGraph proc~getebsdindexingnamelist GetEBSDIndexingNameList emsoft_tonativepath emsoft_tonativepath proc~getebsdindexingnamelist->emsoft_tonativepath fatalerror fatalerror proc~getebsdindexingnamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetEBSDIndexingNameList Source Code recursive subroutine GetEBSDIndexingNameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetEBSDIndexingNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( EBSDIndexingNameListType ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: numsx integer ( kind = irg ) :: numsy integer ( kind = irg ) :: binning integer ( kind = irg ) :: energyaverage integer ( kind = irg ) :: devid integer ( kind = irg ) :: platid integer ( kind = irg ) :: nregions real ( kind = sgl ) :: L real ( kind = sgl ) :: thetac real ( kind = sgl ) :: delta real ( kind = sgl ) :: xpc real ( kind = sgl ) :: ypc real ( kind = sgl ) :: gammavalue real ( kind = dbl ) :: beamcurrent real ( kind = dbl ) :: dwelltime real ( kind = dbl ) :: hipassw real ( kind = sgl ) :: omega real ( kind = sgl ) :: stepX real ( kind = sgl ) :: stepY integer ( kind = irg ) :: nthreads character ( 1 ) :: maskpattern character ( 3 ) :: scalingmode character ( fnlen ) :: dotproductfile character ( fnlen ) :: masterfile real ( kind = sgl ) :: energymin real ( kind = sgl ) :: energymax character ( 1 ) :: spatialaverage character ( fnlen ) :: tmpfile character ( fnlen ) :: datafile character ( fnlen ) :: ctffile character ( fnlen ) :: avctffile character ( fnlen ) :: angfile character ( fnlen ) :: eulerfile integer ( kind = irg ) :: ncubochoric integer ( kind = irg ) :: numexptsingle integer ( kind = irg ) :: numdictsingle integer ( kind = irg ) :: ipf_ht integer ( kind = irg ) :: ipf_wd integer ( kind = irg ) :: nnk integer ( kind = irg ) :: nnav integer ( kind = irg ) :: nosm integer ( kind = irg ) :: maskradius character ( fnlen ) :: exptfile character ( fnlen ) :: dictfile character ( fnlen ) :: indexingmode ! define the IO namelist to facilitate passing variables to the program. namelist / EBSDIndexingdata / thetac , delta , numsx , numsy , xpc , ypc , masterfile , devid , platid , & beamcurrent , dwelltime , binning , gammavalue , energymin , spatialaverage , nregions , & scalingmode , maskpattern , energyaverage , L , omega , nthreads , energymax , datafile , angfile , ctffile , & ncubochoric , numexptsingle , numdictsingle , ipf_ht , ipf_wd , nnk , nnav , exptfile , maskradius ,& dictfile , indexingmode , hipassw , stepX , stepY , tmpfile , avctffile , nosm , eulerfile ! set the input parameters to default values (except for xtalname, which must be present) ncubochoric = 50 numexptsingle = 1024 numdictsingle = 1024 platid = 1 devid = 1 nregions = 10 nnk = 50 nnav = 20 nosm = 20 exptfile = 'undefined' numsx = 640 ! [dimensionless] numsy = 480 ! [dimensionless] maskradius = 240 binning = 1 ! binning mode  (1, 2, 4, or 8) L = 2000 0.0 ! [microns] energyaverage = 1 ! apply energy averaging (1) or not (0); useful for dictionary computations thetac = 0.0 ! [degrees] delta = 2 5.0 ! [microns] xpc = 0.0 ! [pixels] ypc = 0.0 ! [pixels] gammavalue = 1.0 ! gamma factor beamcurrent = 1 4.513D0 ! beam current (actually emission current) in nano ampere dwelltime = 10 0.0D0 ! in microseconds hipassw = 0.05D0 ! hi pass inverted Gaussian mask parameter stepX = 1.0 ! sampling step size along X stepY = 1.0 ! sampling step size along Y maskpattern = 'n' ! 'y' or 'n' to include a circular mask scalingmode = 'not' ! intensity selector ('lin', 'gam', or 'not') masterfile = 'undefined' ! filename dotproductfile = 'undefined' energymin = 1 0.0 energymax = 2 0.0 ipf_ht = 100 ipf_wd = 100 nthreads = 1 spatialaverage = 'n' datafile = 'undefined' ctffile = 'undefined' avctffile = 'undefined' angfile = 'undefined' eulerfile = 'undefined' omega = 0.0 tmpfile = 'EMEBSDDict_tmp.data' dictfile = 'undefined' indexingmode = 'dynamic' if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = EBSDIndexingdata ) close ( UNIT = dataunit , STATUS = 'keep' ) if ( trim ( indexingmode ) . eq . 'static' ) then if ( trim ( dictfile ) . eq . 'undefined' ) then call FatalError ( 'EMEBSDIndexing:' , ' dictionary file name is undefined in ' // nmlfile ) end if end if ! check for required entries if ( trim ( indexingmode ) . eq . 'dynamic' ) then if ( trim ( masterfile ). eq . 'undefined' ) then call FatalError ( 'EMEBSDIndexing:' , ' master pattern file name is undefined in ' // nmlfile ) end if end if if ( trim ( exptfile ). eq . 'undefined' ) then call FatalError ( 'EMEBSDIndexing:' , ' experimental file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the enl fields enl % devid = devid enl % platid = platid enl % nregions = nregions enl % maskpattern = maskpattern enl % exptfile = exptfile enl % nnk = nnk enl % nnav = nnav enl % nosm = nosm enl % ipf_ht = ipf_ht enl % ipf_wd = ipf_wd enl % nthreads = nthreads enl % datafile = datafile enl % tmpfile = tmpfile enl % ctffile = ctffile enl % avctffile = avctffile enl % angfile = angfile enl % eulerfile = eulerfile enl % maskradius = maskradius enl % numdictsingle = numdictsingle enl % numexptsingle = numexptsingle enl % hipassw = hipassw enl % masterfile = masterfile enl % energyfile = enl % masterfile enl % StepX = stepX enl % StepY = stepY enl % indexingmode = trim ( indexingmode ) if ( trim ( indexingmode ) . eq . 'dynamic' ) then enl % L = L enl % numsx = numsx enl % numsy = numsy enl % binning = binning enl % energyaverage = energyaverage enl % thetac = thetac enl % delta = delta enl % xpc = xpc enl % ypc = ypc enl % gammavalue = gammavalue enl % beamcurrent = beamcurrent enl % dwelltime = dwelltime enl % scalingmode = scalingmode enl % ncubochoric = ncubochoric enl % omega = omega enl % energymin = energymin enl % energymax = energymax enl % spatialaverage = spatialaverage enl % dictfile = 'undefined' else if ( trim ( indexingmode ) . eq . 'static' ) then enl % dictfile = dictfile enl % ncubochoric = 0 else call FatalError ( 'EMEBSDIndexing:' , ' indexingmode is not known in ' // nmlfile ) end if end subroutine GetEBSDIndexingNameList","tags":"","loc":"proc/getebsdindexingnamelist.html","title":"GetEBSDIndexingNameList – Fortran Program"},{"text":"public recursive subroutine GetTKDIndexingNameList(nmlfile, enl, initonly) Uses: error proc~~gettkdindexingnamelist~~UsesGraph proc~gettkdindexingnamelist GetTKDIndexingNameList error error error->proc~gettkdindexingnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef , Carnegie Mellon University\n @brief read namelist file and fill enl structure (used by EMTKDDI.f90)\n @param nmlfile namelist file name\n @param enl TKD indexing name list structure\n @date 05/07/17 MDG 1.0 new routine, based on EBSD routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(TKDIndexingNameListType), intent(inout) :: enl logical, intent(in), optional :: initonly Calls proc~~gettkdindexingnamelist~~CallsGraph proc~gettkdindexingnamelist GetTKDIndexingNameList emsoft_tonativepath emsoft_tonativepath proc~gettkdindexingnamelist->emsoft_tonativepath fatalerror fatalerror proc~gettkdindexingnamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetTKDIndexingNameList Source Code recursive subroutine GetTKDIndexingNameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetTKDIndexingNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( TKDIndexingNameListType ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: numsx integer ( kind = irg ) :: numsy integer ( kind = irg ) :: binning integer ( kind = irg ) :: energyaverage integer ( kind = irg ) :: devid integer ( kind = irg ) :: platid integer ( kind = irg ) :: nregions real ( kind = sgl ) :: L real ( kind = sgl ) :: thetac real ( kind = sgl ) :: delta real ( kind = sgl ) :: xpc real ( kind = sgl ) :: ypc real ( kind = sgl ) :: gammavalue real ( kind = dbl ) :: beamcurrent real ( kind = dbl ) :: dwelltime real ( kind = dbl ) :: hipassw real ( kind = sgl ) :: omega real ( kind = sgl ) :: stepX real ( kind = sgl ) :: stepY integer ( kind = irg ) :: nthreads character ( 1 ) :: maskpattern character ( 3 ) :: scalingmode character ( fnlen ) :: dotproductfile character ( fnlen ) :: masterfile real ( kind = sgl ) :: energymin real ( kind = sgl ) :: energymax character ( 1 ) :: spatialaverage character ( fnlen ) :: tmpfile character ( fnlen ) :: datafile character ( fnlen ) :: ctffile character ( fnlen ) :: avctffile character ( fnlen ) :: angfile character ( fnlen ) :: eulerfile integer ( kind = irg ) :: ncubochoric integer ( kind = irg ) :: numexptsingle integer ( kind = irg ) :: numdictsingle integer ( kind = irg ) :: ipf_ht integer ( kind = irg ) :: ipf_wd integer ( kind = irg ) :: nnk integer ( kind = irg ) :: nnav integer ( kind = irg ) :: nosm integer ( kind = irg ) :: maskradius character ( fnlen ) :: exptfile character ( fnlen ) :: dictfile character ( fnlen ) :: indexingmode ! define the IO namelist to facilitate passing variables to the program. namelist / TKDIndexingdata / thetac , delta , numsx , numsy , xpc , ypc , masterfile , devid , platid , & beamcurrent , dwelltime , binning , gammavalue , energymin , spatialaverage , nregions , & scalingmode , maskpattern , energyaverage , L , omega , nthreads , energymax , datafile , angfile , ctffile , & ncubochoric , numexptsingle , numdictsingle , ipf_ht , ipf_wd , nnk , nnav , exptfile , maskradius ,& dictfile , indexingmode , hipassw , stepX , stepY , tmpfile , avctffile , nosm , eulerfile ! set the input parameters to default values (except for xtalname, which must be present) ncubochoric = 50 numexptsingle = 1024 numdictsingle = 1024 platid = 1 devid = 1 nregions = 10 nnk = 50 nnav = 20 nosm = 20 exptfile = 'undefined' numsx = 640 ! [dimensionless] numsy = 480 ! [dimensionless] maskradius = 240 binning = 1 ! binning mode  (1, 2, 4, or 8) L = 2000 0.0 ! [microns] energyaverage = 1 ! apply energy averaging (1) or not (0); useful for dictionary computations thetac = 0.0 ! [degrees] delta = 2 5.0 ! [microns] xpc = 0.0 ! [pixels] ypc = 0.0 ! [pixels] gammavalue = 1.0 ! gamma factor beamcurrent = 1 4.513D0 ! beam current (actually emission current) in nano ampere dwelltime = 10 0.0D0 ! in microseconds hipassw = 0.05D0 ! hi pass inverted Gaussian mask parameter stepX = 1.0 ! sampling step size along X stepY = 1.0 ! sampling step size along Y maskpattern = 'n' ! 'y' or 'n' to include a circular mask scalingmode = 'not' ! intensity selector ('lin', 'gam', or 'not') masterfile = 'undefined' ! filename dotproductfile = 'undefined' energymin = 1 0.0 energymax = 2 0.0 ipf_ht = 100 ipf_wd = 100 nthreads = 1 spatialaverage = 'n' datafile = 'undefined' ctffile = 'undefined' avctffile = 'undefined' angfile = 'undefined' eulerfile = 'undefined' omega = 0.0 tmpfile = 'EMEBSDDict_tmp.data' dictfile = 'undefined' indexingmode = 'dynamic' if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = TKDIndexingdata ) close ( UNIT = dataunit , STATUS = 'keep' ) if ( trim ( indexingmode ) . eq . 'static' ) then if ( trim ( dictfile ) . eq . 'undefined' ) then call FatalError ( 'EMTKDIndexing:' , ' dictionary file name is undefined in ' // nmlfile ) end if end if ! check for required entries if ( trim ( indexingmode ) . eq . 'dynamic' ) then if ( trim ( masterfile ). eq . 'undefined' ) then call FatalError ( 'EMTKDIndexing:' , ' master pattern file name is undefined in ' // nmlfile ) end if end if if ( trim ( exptfile ). eq . 'undefined' ) then call FatalError ( 'EMTKDIndexing:' , ' experimental file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the enl fields enl % devid = devid enl % platid = platid enl % nregions = nregions enl % maskpattern = maskpattern enl % exptfile = exptfile enl % nnk = nnk enl % nnav = nnav enl % nosm = nosm enl % ipf_ht = ipf_ht enl % ipf_wd = ipf_wd enl % nthreads = nthreads enl % datafile = datafile enl % tmpfile = tmpfile enl % ctffile = ctffile enl % avctffile = avctffile enl % angfile = angfile enl % eulerfile = eulerfile enl % maskradius = maskradius enl % numdictsingle = numdictsingle enl % numexptsingle = numexptsingle enl % hipassw = hipassw enl % masterfile = masterfile enl % energyfile = enl % masterfile enl % StepX = stepX enl % StepY = stepY enl % indexingmode = trim ( indexingmode ) if ( trim ( indexingmode ) . eq . 'dynamic' ) then enl % L = L enl % numsx = numsx enl % numsy = numsy enl % binning = binning enl % energyaverage = energyaverage enl % thetac = thetac enl % delta = delta enl % xpc = xpc enl % ypc = ypc enl % gammavalue = gammavalue enl % beamcurrent = beamcurrent enl % dwelltime = dwelltime enl % scalingmode = scalingmode enl % ncubochoric = ncubochoric enl % omega = omega enl % energymin = energymin enl % energymax = energymax enl % spatialaverage = spatialaverage enl % dictfile = 'undefined' else if ( trim ( indexingmode ) . eq . 'static' ) then enl % dictfile = dictfile enl % ncubochoric = 0 else call FatalError ( 'EMTKDIndexing:' , ' indexingmode is not known in ' // nmlfile ) end if end subroutine GetTKDIndexingNameList","tags":"","loc":"proc/gettkdindexingnamelist.html","title":"GetTKDIndexingNameList – Fortran Program"},{"text":"public recursive subroutine GetZAdefectNameList(nmlfile, ZAdefect, initonly) Uses: error proc~~getzadefectnamelist~~UsesGraph proc~getzadefectnamelist GetZAdefectNameList error error error->proc~getzadefectnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief read namelist file and fill ZAdefect structure (used by CTEMDefect.f90)\n @param nmlfile namelist file name\n @param ZAdefect Zone Axis defect simulation name list structure\n @date 06/24/15  SS 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(ZAdefectnameListType), intent(inout) :: ZAdefect logical, intent(in), optional :: initonly Calls proc~~getzadefectnamelist~~CallsGraph proc~getzadefectnamelist GetZAdefectNameList emsoft_tonativepath emsoft_tonativepath proc~getzadefectnamelist->emsoft_tonativepath fatalerror fatalerror proc~getzadefectnamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetZAdefectNameList Source Code recursive subroutine GetZAdefectNameList ( nmlfile , ZAdefect , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetZAdefectNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( ZAdefectnameListType ), INTENT ( INOUT ) :: ZAdefect logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . character ( fnlen ) :: xtalname real ( kind = sgl ) :: voltage integer ( kind = irg ) :: kk ( 3 ) real ( kind = sgl ) :: lauec ( 2 ) real ( kind = sgl ) :: dmin ! EM or STEM ? character ( fnlen ) :: progmode character ( fnlen ) :: STEMnmlfile character ( fnlen ) :: foilnmlfile ! column approximation parameters and image parameters real ( kind = sgl ) :: DF_L real ( kind = sgl ) :: DF_npix real ( kind = sgl ) :: DF_npiy real ( kind = sgl ) :: DF_slice integer ( kind = irg ) :: dinfo character ( fnlen ) :: sgname ! defect parameters integer ( kind = irg ) :: numdisl integer ( kind = irg ) :: numsf integer ( kind = irg ) :: numinc integer ( kind = irg ) :: numvoids character ( fnlen ) :: voidname character ( fnlen ) :: dislname character ( fnlen ) :: sfname character ( fnlen ) :: incname character ( fnlen ) :: dispfile character ( fnlen ) :: dispmode ! output parameters character ( fnlen ) :: dataname integer ( kind = irg ) :: t_interval ! define the IO namelist to facilitate passing variables to the program. namelist / rundata / xtalname , voltage , kk , lauec , dmin , progmode , STEMnmlfile , foilnmlfile ,& DF_L , DF_npix , DF_npiy , DF_slice , dinfo , sgname , numdisl , numsf , numinc ,& numvoids , voidname , dislname , sfname , incname , dispfile , dispmode , dataname , t_interval ! set the input parameters to default values (except for xtalname, which must be present) xtalname = 'undefined' voltage = 20000 0.0 kk = ( / 0.0 , 0.0 , 1.0 / ) lauec = ( / 0.0 , 0.0 / ) dmin = 0.04 progmode = 'CTEM' STEMnmlfile = 'STEM_rundata.nml' foilnmlfile = 'FOIL_rundata.nml' DF_L = 1.0 DF_npix = 256 DF_npiy = 256 DF_slice = 1.0 dinfo = 0 sgname = 'undefined' numdisl = 0 numsf = 0 numinc = 0 numvoids = 0 voidname = 'void.nml' dislname = 'dislocation.nml' sfname = 'stackingfault.nml' incname = 'inclusion.nml' dispfile = 'undefined' dispmode = 'undefined' dataname = 'undefined' t_interval = 10 if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = rundata ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'CTEMDefect:' , ' xtal file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the emnl fields ZAdefect % xtalname = xtalname ZAdefect % voltage = voltage ZAdefect % kk = kk ZAdefect % lauec = lauec ZAdefect % dmin = dmin ZAdefect % progmode = progmode ZAdefect % STEMnmlfile = STEMnmlfile ZAdefect % foilnmlfile = foilnmlfile ZAdefect % DF_L = DF_L ZAdefect % DF_npix = DF_npix ZAdefect % DF_npiy = DF_npiy ZAdefect % DF_slice = DF_slice ZAdefect % dinfo = dinfo ZAdefect % sgname = sgname ZAdefect % numdisl = numdisl ZAdefect % numsf = numsf ZAdefect % numinc = numinc ZAdefect % numvoids = numvoids ZAdefect % voidname = voidname ZAdefect % dislname = dislname ZAdefect % sfname = sfname ZAdefect % incname = incname ZAdefect % dispfile = dispfile ZAdefect % dispmode = dispmode ZAdefect % dataname = dataname ZAdefect % t_interval = t_interval end subroutine GetZADefectNameList","tags":"","loc":"proc/getzadefectnamelist.html","title":"GetZAdefectNameList – Fortran Program"},{"text":"public recursive subroutine GetECPIndexingNameList(nmlfile, enl, initonly) Uses: error proc~~getecpindexingnamelist~~UsesGraph proc~getecpindexingnamelist GetECPIndexingNameList error error error->proc~getecpindexingnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief read namelist file and fill enl structure (used by EMDynamicECPIndeixing.f90)\n @param nmlfile namelist file name\n @param enl ECP indexing name list structure\n @date 11/19/15  SS 1.0 original\n @date 01/26/16  SS 1.1 modified for EMsoft3.1 indexing code Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(ECPIndexingNameListType), intent(inout) :: enl logical, intent(in), optional :: initonly Calls proc~~getecpindexingnamelist~~CallsGraph proc~getecpindexingnamelist GetECPIndexingNameList emsoft_tonativepath emsoft_tonativepath proc~getecpindexingnamelist->emsoft_tonativepath fatalerror fatalerror proc~getecpindexingnamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetECPIndexingNameList Source Code recursive subroutine GetECPIndexingNameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetECPIndexingNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( ECPIndexingNameListType ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: ncubochoric integer ( kind = irg ) :: numexptsingle integer ( kind = irg ) :: numdictsingle integer ( kind = irg ) :: totnumexpt integer ( kind = irg ) :: maskradius integer ( kind = irg ) :: nnk integer ( kind = irg ) :: platid integer ( kind = irg ) :: devid integer ( kind = irg ) :: nregions character ( fnlen ) :: exptfile integer ( kind = irg ) :: stdout integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: npix real ( kind = sgl ) :: thetac character ( 1 ) :: maskpattern character ( fnlen ) :: masterfile character ( fnlen ) :: tmpfile character ( fnlen ) :: datafile character ( fnlen ) :: ctffile real ( kind = sgl ) :: gammavalue real ( kind = dbl ) :: sampletilt real ( kind = sgl ) :: workingdistance real ( kind = sgl ) :: Rin real ( kind = sgl ) :: Rout namelist / ECPIndexingdata / ncubochoric , numexptsingle , numdictsingle , totnumexpt , nnk , exptfile , & stdout , nthreads , npix , thetac , maskpattern , masterfile , datafile , gammavalue , platid , & sampletilt , workingdistance , Rin , Rout , maskradius , devid , nregions , ctffile , tmpfile ncubochoric = 100 numexptsingle = 1024 numdictsingle = 1024 totnumexpt = 10 nregions = 10 nnk = 2 platid = 1 devid = 1 exptfile = 'undefined' nthreads = 1 npix = 256 thetac = 1 0.0 maskpattern = 'y' masterfile = 'undefined' datafile = 'undefined' tmpfile = 'EMECPDict_tmp.data' ctffile = 'undefined' gammavalue = 1.0 sampletilt = 0.0 workingdistance = 1 0.0 Rin = 3.0 Rout = 5.0 maskradius = 128 if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = ECPIndexingdata ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( masterfile ). eq . 'undefined' ) then call FatalError ( 'EMECPIndexing:' , ' master pattern file name is undefined in ' // nmlfile ) end if if ( trim ( exptfile ). eq . 'undefined' ) then call FatalError ( 'EMECPIndexing:' , ' experimental file name is undefined in ' // nmlfile ) end if end if enl % ncubochoric = ncubochoric enl % numexptsingle = numexptsingle enl % numdictsingle = numdictsingle enl % totnumexpt = totnumexpt enl % nnk = nnk enl % devid = devid enl % platid = platid enl % nregions = nregions enl % exptfile = exptfile enl % nthreads = nthreads enl % npix = npix enl % thetac = thetac enl % maskpattern = maskpattern enl % masterfile = masterfile enl % energyfile = enl % masterfile enl % datafile = datafile enl % gammavalue = gammavalue enl % sampletilt = sampletilt enl % workingdistance = workingdistance enl % Rin = Rin enl % Rout = Rout enl % maskradius = maskradius enl % ctffile = ctffile enl % tmpfile = tmpfile end subroutine GetECPIndexingNameList","tags":"","loc":"proc/getecpindexingnamelist.html","title":"GetECPIndexingNameList – Fortran Program"},{"text":"public recursive subroutine GetEMDPFit4NameList(nmlfile, enl, initonly) Uses: error proc~~getemdpfit4namelist~~UsesGraph proc~getemdpfit4namelist GetEMDPFit4NameList error error error->proc~getemdpfit4namelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief read namelist file and fill enl structure (used by EMDPFit.f90)\n @param nmlfile namelist file name\n @param enl DPFit name list structure\n @date 02/22/16  SS 1.0 original Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(EMDPFit4ListType), intent(inout) :: enl logical, intent(in), optional :: initonly Calls proc~~getemdpfit4namelist~~CallsGraph proc~getemdpfit4namelist GetEMDPFit4NameList fatalerror fatalerror proc~getemdpfit4namelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetEMDPFit4NameList Source Code recursive subroutine GetEMDPFit4NameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetEMDPFit4NameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( EMDPFit4ListType ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . character ( fnlen ) :: masterfile character ( fnlen ) :: modalityname character ( fnlen ) :: exptfile_pat1 character ( fnlen ) :: exptfile_pat2 character ( fnlen ) :: exptfile_pat3 character ( fnlen ) :: exptfile_pat4 real ( kind = dbl ) :: rhobeg , rhoend logical :: verbose , mask real ( kind = sgl ) :: gammavalue real ( kind = sgl ) :: phi_pat1 , phi1_pat1 , phi2_pat1 real ( kind = sgl ) :: phi_pat2 , phi1_pat2 , phi2_pat2 real ( kind = sgl ) :: phi_pat3 , phi1_pat3 , phi2_pat3 real ( kind = sgl ) :: phi_pat4 , phi1_pat4 , phi2_pat4 real ( kind = sgl ) :: L real ( kind = sgl ) :: thetac real ( kind = sgl ) :: delta real ( kind = sgl ) :: omega integer ( kind = irg ) :: numsx integer ( kind = irg ) :: numsy integer ( kind = irg ) :: binning real ( kind = sgl ) :: xpc real ( kind = sgl ) :: ypc real ( kind = sgl ) :: beamcurrent real ( kind = sgl ) :: dwelltime integer ( kind = irg ) :: npix real ( kind = sgl ) :: Rin real ( kind = sgl ) :: Rout real ( kind = sgl ) :: thetacone real ( kind = sgl ) :: sampletilt real ( kind = sgl ) :: workingdistance real ( kind = sgl ) :: maskradius real ( kind = sgl ) :: step_xpc real ( kind = sgl ) :: step_ypc real ( kind = sgl ) :: step_L real ( kind = sgl ) :: step_phi1 real ( kind = sgl ) :: step_phi real ( kind = sgl ) :: step_phi2 real ( kind = sgl ) :: step_thetacone integer ( kind = irg ) :: nrun integer ( kind = irg ) :: pixx_pat1 , pixx_pat2 , pixx_pat3 , pixx_pat4 integer ( kind = irg ) :: pixy_pat1 , pixy_pat2 , pixy_pat3 , pixy_pat4 real ( kind = sgl ) :: stepx real ( kind = sgl ) :: stepy namelist / DPFitdata / masterfile , modalityname , exptfile_pat1 , rhobeg , rhoend , verbose , mask , & phi1_pat1 , phi_pat1 , phi2_pat1 , L , thetac , delta , omega , numsx , numsy , binning , xpc , ypc , beamcurrent , & dwelltime , npix , Rin , Rout , thetacone , sampletilt , workingdistance , gammavalue , maskradius , & phi1_pat2 , phi_pat2 , phi2_pat2 , phi1_pat3 , phi_pat3 , phi2_pat3 , phi1_pat4 , phi_pat4 , phi2_pat4 , & exptfile_pat2 , exptfile_pat3 , exptfile_pat4 , step_xpc , step_ypc , step_L , step_phi1 , step_phi , step_phi2 ,& step_thetacone , nrun , pixx_pat1 , pixy_pat1 , stepx , stepy , pixx_pat2 , pixy_pat2 , pixx_pat3 , pixy_pat3 ,& pixx_pat4 , pixy_pat4 masterfile = 'undefined' modalityname = 'undefined' exptfile_pat1 = 'undefined' exptfile_pat2 = 'undefined' exptfile_pat3 = 'undefined' exptfile_pat4 = 'undefined' rhobeg = 1.0D-2 rhoend = 1.0D-7 verbose = . TRUE . mask = . TRUE . phi1_pat1 = 0.0 phi_pat1 = 0.0 phi2_pat1 = 0.0 phi1_pat2 = 0.0 phi_pat2 = 0.0 phi2_pat2 = 0.0 phi1_pat3 = 0.0 phi_pat3 = 0.0 phi2_pat3 = 0.0 phi1_pat4 = 0.0 phi_pat4 = 0.0 phi2_pat4 = 0.0 step_phi1 = 2.0 step_phi = 2.0 step_phi2 = 2.0 L = 1500 0.0 thetac = 1 0.0 delta = 5 0.0 omega = 0.0 numsx = 640 numsy = 480 binning = 1 xpc = 0.0 ypc = 0.0 beamcurrent = 100 0.0 dwelltime = 100 0.0 npix = 512 Rin = 2.0 Rout = 5.0 thetacone = 5.0 sampletilt = 0.0 workingdistance = 7.0 gammavalue = 1.0 maskradius = 25 6.0 step_xpc = 5.0 step_ypc = 5.0 step_L = 5.0 step_thetacone = 1.0 pixx_pat1 = 0 pixy_pat1 = 0 pixx_pat2 = 0 pixy_pat2 = 0 pixx_pat3 = 0 pixy_pat3 = 0 pixx_pat4 = 0 pixy_pat4 = 0 stepx = 5.0 stepy = 5.0 nrun = 2 if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( nmlfile ), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = DPFitdata ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( masterfile ). eq . 'undefined' ) then call FatalError ( 'EMDPFit:' , ' master pattern file name is undefined in ' // nmlfile ) end if if ( trim ( modalityname ). eq . 'undefined' ) then call FatalError ( 'EMDPFit:' , ' modality name is undefined in ' // nmlfile ) end if if ( trim ( exptfile_pat1 ). eq . 'undefined' ) then call FatalError ( 'EMDPFit:' , ' experimental file name is undefined in ' // nmlfile ) end if end if enl % masterfile = masterfile enl % modalityname = modalityname enl % exptfile_pat1 = exptfile_pat1 enl % exptfile_pat2 = exptfile_pat2 enl % exptfile_pat3 = exptfile_pat3 enl % exptfile_pat4 = exptfile_pat4 enl % rhobeg = rhobeg enl % rhoend = rhoend enl % verbose = verbose enl % mask = mask enl % phi1_pat1 = phi1_pat1 enl % phi_pat1 = phi_pat1 enl % phi2_pat1 = phi2_pat1 enl % phi1_pat2 = phi1_pat2 enl % phi_pat2 = phi_pat2 enl % phi2_pat2 = phi2_pat2 enl % phi1_pat3 = phi1_pat3 enl % phi_pat3 = phi_pat3 enl % phi2_pat3 = phi2_pat3 enl % phi1_pat4 = phi1_pat4 enl % phi_pat4 = phi_pat4 enl % phi2_pat4 = phi2_pat4 enl % L = L enl % thetac = thetac enl % omega = omega enl % numsx = numsx enl % numsy = numsy enl % binning = binning enl % xpc = xpc enl % ypc = ypc enl % beamcurrent = beamcurrent enl % dwelltime = dwelltime enl % npix = npix enl % Rin = Rin enl % Rout = Rout enl % thetacone = thetacone enl % sampletilt = sampletilt enl % workingdistance = workingdistance enl % gammavalue = gammavalue enl % maskradius = maskradius enl % delta = delta enl % step_xpc = step_xpc enl % step_ypc = step_ypc enl % step_L = step_L enl % step_phi1 = step_phi1 enl % step_phi = step_phi enl % step_phi2 = step_phi2 enl % step_thetacone = step_thetacone enl % nrun = nrun enl % stepx = stepx enl % stepy = stepy enl % pixx_pat1 = pixx_pat1 enl % pixy_pat1 = pixy_pat1 enl % pixx_pat2 = pixx_pat2 enl % pixy_pat2 = pixy_pat2 enl % pixx_pat3 = pixx_pat3 enl % pixy_pat3 = pixy_pat3 enl % pixx_pat4 = pixx_pat4 enl % pixy_pat4 = pixy_pat4 end subroutine GetEMDPFit4NameList","tags":"","loc":"proc/getemdpfit4namelist.html","title":"GetEMDPFit4NameList – Fortran Program"},{"text":"public recursive subroutine GetEMDPFitNameList(nmlfile, enl, initonly) Uses: error proc~~getemdpfitnamelist~~UsesGraph proc~getemdpfitnamelist GetEMDPFitNameList error error error->proc~getemdpfitnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief read namelist file and fill enl structure (used by EMDPFit.f90)\n @param nmlfile namelist file name\n @param enl DPFit name list structure\n @date 02/22/16  SS 1.0 original Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(EMDPFitListType), intent(inout) :: enl logical, intent(in), optional :: initonly Calls proc~~getemdpfitnamelist~~CallsGraph proc~getemdpfitnamelist GetEMDPFitNameList fatalerror fatalerror proc~getemdpfitnamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetEMDPFitNameList Source Code recursive subroutine GetEMDPFitNameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetEMDPFitNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( EMDPFitListType ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . character ( fnlen ) :: masterfile character ( fnlen ) :: modalityname character ( fnlen ) :: exptfile real ( kind = dbl ) :: rhobeg , rhoend logical :: verbose , mask real ( kind = sgl ) :: gammavalue real ( kind = sgl ) :: phi , phi1 , phi2 real ( kind = sgl ) :: L real ( kind = sgl ) :: thetac real ( kind = sgl ) :: delta real ( kind = sgl ) :: omega integer ( kind = irg ) :: numsx integer ( kind = irg ) :: numsy integer ( kind = irg ) :: binning real ( kind = sgl ) :: xpc real ( kind = sgl ) :: ypc real ( kind = sgl ) :: beamcurrent real ( kind = sgl ) :: dwelltime integer ( kind = irg ) :: npix real ( kind = sgl ) :: Rin real ( kind = sgl ) :: Rout real ( kind = sgl ) :: thetacone real ( kind = sgl ) :: sampletilt real ( kind = sgl ) :: workingdistance real ( kind = sgl ) :: maskradius real ( kind = sgl ) :: step_xpc real ( kind = sgl ) :: step_ypc real ( kind = sgl ) :: step_L real ( kind = sgl ) :: step_phi1 real ( kind = sgl ) :: step_phi real ( kind = sgl ) :: step_phi2 real ( kind = sgl ) :: step_thetacone integer ( kind = irg ) :: nrun integer ( kind = irg ) :: nregions character ( 2 ) :: metric namelist / DPFitdata / masterfile , modalityname , exptfile , rhobeg , rhoend , verbose , mask , & phi1 , phi , phi2 , L , thetac , delta , omega , numsx , numsy , binning , xpc , ypc , beamcurrent , & dwelltime , npix , Rin , Rout , thetacone , sampletilt , workingdistance , gammavalue , maskradius , & step_xpc , step_ypc , step_L , step_phi1 , step_phi , step_phi2 , step_thetacone , nrun , nregions , metric masterfile = 'undefined' modalityname = 'undefined' exptfile = 'undefined' rhobeg = 1.0D-2 rhoend = 1.0D-7 verbose = . TRUE . mask = . TRUE . phi1 = 0.0 phi = 0.0 phi2 = 0.0 step_phi1 = 2.0 step_phi = 2.0 step_phi2 = 2.0 L = 1500 0.0 thetac = 1 0.0 delta = 5 0.0 omega = 0.0 numsx = 640 numsy = 480 binning = 1 xpc = 0.0 ypc = 0.0 beamcurrent = 100 0.0 dwelltime = 100 0.0 npix = 512 Rin = 2.0 Rout = 5.0 thetacone = 5.0 sampletilt = 0.0 workingdistance = 7.0 gammavalue = 1.0 maskradius = 25 6.0 step_xpc = 5.0 step_ypc = 5.0 step_L = 5.0 step_thetacone = 1.0 nrun = 2 nregions = 8 metric = 'DP' if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( nmlfile ), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = DPFitdata ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( masterfile ). eq . 'undefined' ) then call FatalError ( 'EMDPFit:' , ' master pattern file name is undefined in ' // nmlfile ) end if if ( trim ( modalityname ). eq . 'undefined' ) then call FatalError ( 'EMDPFit:' , ' modality name is undefined in ' // nmlfile ) end if if ( trim ( exptfile ). eq . 'undefined' ) then call FatalError ( 'EMDPFit:' , ' experimental file name is undefined in ' // nmlfile ) end if end if enl % masterfile = masterfile enl % modalityname = modalityname enl % metric = metric enl % nregions = nregions enl % exptfile = exptfile enl % rhobeg = rhobeg enl % rhoend = rhoend enl % verbose = verbose enl % mask = mask enl % phi1 = phi1 enl % phi = phi enl % phi2 = phi2 enl % L = L enl % thetac = thetac enl % omega = omega enl % numsx = numsx enl % numsy = numsy enl % binning = binning enl % xpc = xpc enl % ypc = ypc enl % beamcurrent = beamcurrent enl % dwelltime = dwelltime enl % npix = npix enl % Rin = Rin enl % Rout = Rout enl % thetacone = thetacone enl % sampletilt = sampletilt enl % workingdistance = workingdistance enl % gammavalue = gammavalue enl % maskradius = maskradius enl % delta = delta enl % step_xpc = step_xpc enl % step_ypc = step_ypc enl % step_L = step_L enl % step_phi1 = step_phi1 enl % step_phi = step_phi enl % step_phi2 = step_phi2 enl % step_thetacone = step_thetacone enl % nrun = nrun end subroutine GetEMDPFitNameList","tags":"","loc":"proc/getemdpfitnamelist.html","title":"GetEMDPFitNameList – Fortran Program"},{"text":"public recursive subroutine GetECPSingleNameList(nmlfile, enl, initonly) Uses: error proc~~getecpsinglenamelist~~UsesGraph proc~getecpsinglenamelist GetECPSingleNameList error error error->proc~getecpsinglenamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief read namelist file and fill enl structure (used by EMDPFit.f90)\n @param nmlfile namelist file name\n @param enl ECP single name list structure\n @date 02/22/16  SS 1.0 original Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(ECPSingleNameListType), intent(inout) :: enl logical, intent(in), optional :: initonly Calls proc~~getecpsinglenamelist~~CallsGraph proc~getecpsinglenamelist GetECPSingleNameList fatalerror fatalerror proc~getecpsinglenamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetECPSingleNameList Source Code recursive subroutine GetECPSingleNameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetECPSingleNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( ECPSingleNameListType ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: npix real ( kind = sgl ) :: thetac character ( 1 ) :: maskpattern character ( fnlen ) :: energyfile character ( fnlen ) :: datafile character ( 3 ) :: eulerconvention real ( kind = sgl ) :: gammavalue real ( kind = dbl ) :: sampletilt real ( kind = sgl ) :: workingdistance real ( kind = sgl ) :: Rin real ( kind = sgl ) :: Rout real ( kind = dbl ) :: phi1 , phi , phi2 real ( kind = sgl ) :: dmin namelist / ECPSinglelist / nthreads , npix , thetac , maskpattern , energyfile , datafile , eulerconvention , & gammavalue , sampletilt , workingdistance , Rin , Rout , phi1 , phi , phi2 , dmin nthreads = 1 npix = 512 thetac = 5.0 maskpattern = 'n' energyfile = 'undefined' datafile = 'undefined' eulerconvention = 'tsl' gammavalue = 1.0 sampletilt = 0.D0 workingdistance = 7.0 Rin = 2.0 Rout = 5.0 phi1 = 0.D0 phi = 0.D0 phi2 = 0.D0 dmin = 0.03 if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( nmlfile ), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = ECPSinglelist ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( energyfile ). eq . 'undefined' ) then call FatalError ( 'EMDPFit:' , ' energy file name is undefined in ' // nmlfile ) end if end if enl % nthreads = nthreads enl % npix = npix enl % thetac = thetac enl % maskpattern = maskpattern enl % energyfile = energyfile enl % datafile = datafile enl % eulerconvention = eulerconvention enl % gammavalue = gammavalue enl % sampletilt = sampletilt enl % workingdistance = workingdistance enl % Rin = Rin enl % Rout = Rout enl % phi1 = phi1 enl % phi = phi enl % phi2 = phi2 enl % dmin = dmin end subroutine GetECPSingleNameList","tags":"","loc":"proc/getecpsinglenamelist.html","title":"GetECPSingleNameList – Fortran Program"},{"text":"public recursive subroutine GetSTEMDCINameList(nmlfile, dcinl, initonly) Uses: error proc~~getstemdcinamelist~~UsesGraph proc~getstemdcinamelist GetSTEMDCINameList error error error->proc~getstemdcinamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Patrick Callahan\n @brief read namelist file for EMSTEMDCI\n @param nmlfile namelist file name\n @date 11/01/16  PGC 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(STEMDCINameListType), intent(inout) :: dcinl logical, intent(in), optional :: initonly Calls proc~~getstemdcinamelist~~CallsGraph proc~getstemdcinamelist GetSTEMDCINameList emsoft_tonativepath emsoft_tonativepath proc~getstemdcinamelist->emsoft_tonativepath fatalerror fatalerror proc~getstemdcinamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetSTEMDCINameList Source Code recursive SUBROUTINE GetSTEMDCINameList ( nmlfile , dcinl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetSTEMDCINameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( STEMDCINameListType ), INTENT ( INOUT ) :: dcinl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: nthreads real ( kind = sgl ) :: voltage character ( 4 ) :: progmode character ( fnlen ) :: xtalname integer ( kind = irg ) :: kk ( 3 ) real ( kind = sgl ) :: lauec ( 2 ) character ( fnlen ) :: STEMnmlfile character ( fnlen ) :: dataname character ( fnlen ) :: defectfilename character ( 3 ) :: dispmode character ( fnlen ) :: dispfile integer ( kind = irg ) :: output integer ( kind = irg ) :: dinfo integer ( kind = irg ) :: t_interval real ( kind = sgl ) :: DF_L integer ( kind = irg ) :: DF_npix integer ( kind = irg ) :: DF_npiy real ( kind = sgl ) :: DF_slice real ( kind = sgl ) :: dmin ! DEFINE THE IO NAMELIST FOR VARIABLE PASSING namelist / STEMDCIdata / nthreads , voltage , progmode , xtalname , kk , lauec , STEMnmlfile , & dataname , defectfilename , dispmode , dispfile , output , dinfo , t_interval , DF_L , & DF_npix , DF_npiy , DF_slice , dmin ! SET INPUT PARAMETERS TO DEFAULT VALUES (EXCEPT XTALNAME, WHICH MUST BE PRESENT) nthreads = 6 voltage = 200000 progmode = 'STEM' xtalname = 'undefined' kk = ( / 0.0 , 0.0 , 1.0 / ) lauec = ( / 0.0 , 0.0 / ) STEMnmlfile = 'STEM_rundata.nml' defectfilename = 'EMdefec/dispt.json' dataname = '/folder/to/trialbinary.data' dispmode = 'not' dispfile = 'test_ZA.data' output = 6 ! screen output dinfo = 0 ! 1 is verbose t_interval = 5 ! update every x steps DF_L = 1.0 DF_npix = 256 DF_npiy = 256 DF_slice = 1.0 ! slice thickness for scattering matrix approach (nmu) dmin = 0.03 if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = STEMDCIdata ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'STEMDCI:' , ' crystal structure file name is undefined in ' // nmlfile ) end if end if dcinl % nthreads = nthreads dcinl % voltage = voltage dcinl % progmode = progmode dcinl % xtalname = xtalname dcinl % kk = kk dcinl % lauec = lauec dcinl % STEMnmlfile = STEMnmlfile dcinl % dataname = dataname dcinl % defectfilename = defectfilename dcinl % dispmode = dispmode dcinl % dispfile = dispfile dcinl % output = output dcinl % dinfo = dinfo dcinl % t_interval = t_interval dcinl % DF_L = DF_L dcinl % DF_npix = DF_npix dcinl % DF_npiy = DF_npiy dcinl % DF_slice = DF_slice dcinl % dmin = dmin END SUBROUTINE GetSTEMDCINameList","tags":"","loc":"proc/getstemdcinamelist.html","title":"GetSTEMDCINameList – Fortran Program"},{"text":"public recursive subroutine GetRefineOrientationNameList(nmlfile, enl, initonly) Uses: error proc~~getrefineorientationnamelist~~UsesGraph proc~getrefineorientationnamelist GetRefineOrientationNameList error error error->proc~getrefineorientationnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief read namelist file and fill enl structure (used by EMRefineOrientation.f90)\n @param nmlfile namelist file name\n @param enl single name list structure\n @date 02/22/16  SS 1.0 original Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(RefineOrientationtype), intent(inout) :: enl logical, intent(in), optional :: initonly Calls proc~~getrefineorientationnamelist~~CallsGraph proc~getrefineorientationnamelist GetRefineOrientationNameList fatalerror fatalerror proc~getrefineorientationnamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetRefineOrientationNameList Source Code recursive subroutine GetRefineOrientationNameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetRefineOrientationNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( RefineOrientationtype ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: nthreads character ( fnlen ) :: dotproductfile character ( fnlen ) :: ctffile integer ( kind = irg ) :: nmis integer ( kind = irg ) :: niter real ( kind = sgl ) :: step namelist / RefineOrientations / nthreads , dotproductfile , ctffile , nmis , niter , step nthreads = 1 dotproductfile = 'undefined' ctffile = 'undefined' nmis = 1 niter = 1 step = 1.0 if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( nmlfile ), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = RefineOrientations ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( dotproductfile ). eq . 'undefined' ) then call FatalError ( 'EMRefineOrientation:' , ' dotproduct file name is undefined in ' // nmlfile ) end if if ( trim ( dotproductfile ). eq . 'undefined' ) then call FatalError ( 'EMRefineOrientation:' , ' ctf file name is undefined in ' // nmlfile ) end if end if enl % nthreads = nthreads enl % dotproductfile = dotproductfile enl % ctffile = ctffile enl % nmis = nmis enl % niter = niter enl % step = step end subroutine GetRefineOrientationNameList","tags":"","loc":"proc/getrefineorientationnamelist.html","title":"GetRefineOrientationNameList – Fortran Program"},{"text":"public recursive subroutine GetFitOrientationPSNameList(nmlfile, enl, initonly) Uses: error constants proc~~getfitorientationpsnamelist~~UsesGraph proc~getfitorientationpsnamelist GetFitOrientationPSNameList error error error->proc~getfitorientationpsnamelist module~constants constants module~constants->proc~getfitorientationpsnamelist local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief read namelist file and fill enl structure (used by EMFitOrientationPS.f90)\n @param nmlfile namelist file name\n @param enl single name list structure\n @date 02/22/16  SS 1.0 original Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(FitOrientationPStype), intent(inout) :: enl logical, intent(in), optional :: initonly Calls proc~~getfitorientationpsnamelist~~CallsGraph proc~getfitorientationpsnamelist GetFitOrientationPSNameList fatalerror fatalerror proc~getfitorientationpsnamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetFitOrientationPSNameList Source Code recursive subroutine GetFitOrientationPSNameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetFitOrientationPSNameList use error use constants IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( FitOrientationPStype ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: nthreads character ( fnlen ) :: dotproductfile character ( fnlen ) :: ctffile real ( kind = sgl ) :: step real ( kind = sgl ) :: angleaxis ( 4 ) namelist / FitOrientationPS / nthreads , dotproductfile , ctffile , step , angleaxis nthreads = 1 dotproductfile = 'undefined' ctffile = 'undefined' step = 1.0 angleaxis = ( / 1.0 , 1.0 , 1.0 , 12 0.0 / ) if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( nmlfile ), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = FitOrientationPS ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( dotproductfile ). eq . 'undefined' ) then call FatalError ( 'EMRefineOrientation:' , ' dotproduct file name is undefined in ' // nmlfile ) end if if ( trim ( dotproductfile ). eq . 'undefined' ) then call FatalError ( 'EMRefineOrientation:' , ' ctf file name is undefined in ' // nmlfile ) end if if ( NORM2 ( angleaxis ( 1 : 3 )) . eq . 0.0 ) then call FatalError ( 'GetFitOrientationPSNameList:' , 'The angle axis for pseudosymmetric variant has norm 0' ) end if end if enl % nthreads = nthreads enl % dotproductfile = dotproductfile enl % ctffile = ctffile enl % step = step enl % angleaxis = angleaxis end subroutine GetFitOrientationPSNameList","tags":"","loc":"proc/getfitorientationpsnamelist.html","title":"GetFitOrientationPSNameList – Fortran Program"},{"text":"public recursive subroutine GetMCCLsphereNameList(nmlfile, mcnl, initonly) Uses: error proc~~getmcclspherenamelist~~UsesGraph proc~getmcclspherenamelist GetMCCLsphereNameList error error error->proc~getmcclspherenamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh/Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMMCCL.f90)\n @param nmlfile namelist file name\n @param mcnl Monte Carloname list structure\n @date 10/20/16  SS 1.0 new routine; adapted from GetMCCLNameList Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(MCCLNameListType), intent(inout) :: mcnl logical, intent(in), optional :: initonly Calls proc~~getmcclspherenamelist~~CallsGraph proc~getmcclspherenamelist GetMCCLsphereNameList emsoft_tonativepath emsoft_tonativepath proc~getmcclspherenamelist->emsoft_tonativepath fatalerror fatalerror proc~getmcclspherenamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetMCCLsphereNameList Source Code recursive subroutine GetMCCLsphereNameList ( nmlfile , mcnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetMCCLsphereNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( MCCLNameListType ), INTENT ( INOUT ) :: mcnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numsx integer ( kind = irg ) :: globalworkgrpsz integer ( kind = irg ) :: num_el integer ( kind = irg ) :: totnum_el integer ( kind = irg ) :: multiplier integer ( kind = irg ) :: devid integer ( kind = irg ) :: platid real ( kind = dbl ) :: sig real ( kind = dbl ) :: sigstart real ( kind = dbl ) :: sigend real ( kind = dbl ) :: sigstep real ( kind = dbl ) :: omega real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep character ( 4 ) :: MCmode character ( fnlen ) :: xtalname character ( fnlen ) :: dataname character ( fnlen ) :: mode real ( kind = dbl ) :: incloc real ( kind = dbl ) :: radius ! define the IO namelist to facilitate passing variables to the program. namelist / MCCLdata / stdout , xtalname , sigstart , numsx , num_el , globalworkgrpsz , EkeV , multiplier , & dataname , totnum_el , Ehistmin , Ebinsize , depthstep , omega , MCmode , mode , devid , platid , & sigend , sigstep , sig , radius , incloc ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 numsx = 1501 globalworkgrpsz = 100 num_el = 10 totnum_el = 2000000000 multiplier = 1 devid = 1 platid = 1 sig = 7 0.D0 sigstart = 7 0.D0 sigend = 7 0.D0 sigstep = 1.D0 omega = 0.D0 EkeV = 3 0.D0 Ehistmin = 5.D0 Ebinsize = 0.5D0 depthstep = 1.0D0 MCmode = 'CSDA' xtalname = 'undefined' dataname = 'MCoutput.data' mode = 'full' radius = 10 0.D0 incloc = 0.D0 if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = MCCLdata ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'EMMC:' , ' structure file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the mcnl fields mcnl % stdout = stdout mcnl % numsx = numsx mcnl % globalworkgrpsz = globalworkgrpsz mcnl % num_el = num_el mcnl % totnum_el = totnum_el mcnl % multiplier = multiplier mcnl % devid = devid mcnl % platid = platid mcnl % sigstart = sigstart mcnl % sigend = sigend mcnl % sigstep = sigstep mcnl % sig = sig mcnl % omega = omega mcnl % EkeV = EkeV mcnl % Ehistmin = Ehistmin mcnl % Ebinsize = Ebinsize mcnl % depthstep = depthstep mcnl % MCmode = MCmode mcnl % xtalname = xtalname mcnl % dataname = dataname mcnl % mode = mode mcnl % radius = radius mcnl % incloc = incloc end subroutine GetMCCLsphereNameList","tags":"","loc":"proc/getmcclspherenamelist.html","title":"GetMCCLsphereNameList – Fortran Program"},{"text":"public recursive subroutine GetMCCLfoilNameList(nmlfile, mcnl, initonly) Uses: error proc~~getmcclfoilnamelist~~UsesGraph proc~getmcclfoilnamelist GetMCCLfoilNameList error error error->proc~getmcclfoilnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh/Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMMCfoil.f90)\n @param nmlfile namelist file name\n @param mcnl Monte Carloname list structure\n @date 01/15/17 MDG 1.0 new routine; adapted from GetMCCLNameList Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(MCCLNameListType), intent(inout) :: mcnl logical, intent(in), optional :: initonly Calls proc~~getmcclfoilnamelist~~CallsGraph proc~getmcclfoilnamelist GetMCCLfoilNameList emsoft_tonativepath emsoft_tonativepath proc~getmcclfoilnamelist->emsoft_tonativepath fatalerror fatalerror proc~getmcclfoilnamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetMCCLfoilNameList Source Code recursive subroutine GetMCCLfoilNameList ( nmlfile , mcnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetMCCLfoilNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( MCCLNameListType ), INTENT ( INOUT ) :: mcnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: stdout integer ( kind = irg ) :: numsx integer ( kind = irg ) :: globalworkgrpsz integer ( kind = irg ) :: num_el integer ( kind = irg ) :: totnum_el integer ( kind = irg ) :: multiplier integer ( kind = irg ) :: devid integer ( kind = irg ) :: platid real ( kind = dbl ) :: sig real ( kind = dbl ) :: omega real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep real ( kind = dbl ) :: thickness character ( 4 ) :: MCmode character ( fnlen ) :: xtalname character ( fnlen ) :: dataname ! define the IO namelist to facilitate passing variables to the program. namelist / MCCLfoildata / stdout , xtalname , numsx , num_el , globalworkgrpsz , EkeV , multiplier , & dataname , totnum_el , Ehistmin , Ebinsize , depthstep , depthmax , omega , MCmode , devid , platid , & sig , thickness ! set the input parameters to default values (except for xtalname, which must be present) stdout = 6 numsx = 501 globalworkgrpsz = 100 num_el = 10 totnum_el = 2000000000 multiplier = 1 devid = 1 platid = 1 sig = 2 0.D0 omega = 0.D0 EkeV = 3 0.D0 Ehistmin = 1 0.D0 Ebinsize = 1.0D0 depthmax = 10 0.0D0 depthstep = 1.0D0 MCmode = 'CSDA' xtalname = 'undefined' dataname = 'MCoutput.data' thickness = 20 0.0 if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = MCCLfoildata ) close ( UNIT = dataunit , STATUS = 'keep' ) write ( * , NML = MCCLfoildata ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'EMMC:' , ' structure file name is undefined in ' // nmlfile ) end if end if ! if we get here, then all appears to be ok, and we need to fill in the mcnl fields mcnl % stdout = stdout mcnl % numsx = numsx mcnl % globalworkgrpsz = globalworkgrpsz mcnl % num_el = num_el mcnl % totnum_el = totnum_el mcnl % multiplier = multiplier mcnl % devid = devid mcnl % platid = platid mcnl % sig = sig mcnl % omega = omega mcnl % EkeV = EkeV mcnl % Ehistmin = Ehistmin mcnl % Ebinsize = Ebinsize mcnl % depthmax = depthmax mcnl % depthstep = depthstep mcnl % MCmode = MCmode mcnl % xtalname = xtalname mcnl % dataname = dataname mcnl % thickness = thickness end subroutine GetMCCLfoilNameList","tags":"","loc":"proc/getmcclfoilnamelist.html","title":"GetMCCLfoilNameList – Fortran Program"},{"text":"public recursive subroutine GetEBSDFullNameList(nmlfile, enl, initonly) Uses: error proc~~getebsdfullnamelist~~UsesGraph proc~getebsdfullnamelist GetEBSDFullNameList error error error->proc~getebsdfullnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief read namelist file and fill enl structure (used by EMEBSDFull.f90)\n @param nmlfile namelist file name\n @param enl EBSD name list structure\n @date 01/24/17  SS 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(EBSDNameListType), intent(inout) :: enl logical, intent(in), optional :: initonly Calls proc~~getebsdfullnamelist~~CallsGraph proc~getebsdfullnamelist GetEBSDFullNameList emsoft_tonativepath emsoft_tonativepath proc~getebsdfullnamelist->emsoft_tonativepath fatalerror fatalerror proc~getebsdfullnamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetEBSDFullNameList Source Code recursive subroutine GetEBSDFullNameList ( nmlfile , enl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetEBSDFullNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( EBSDNameListType ), INTENT ( INOUT ) :: enl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . character ( fnlen ) :: xtalname real ( kind = dbl ) :: dmin integer ( kind = irg ) :: totnum_el real ( kind = dbl ) :: EkeV real ( kind = dbl ) :: Ehistmin real ( kind = dbl ) :: Ebinsize real ( kind = dbl ) :: depthmax real ( kind = dbl ) :: depthstep real ( kind = dbl ) :: beamcurrent real ( kind = dbl ) :: dwelltime real ( kind = dbl ) :: sig real ( kind = dbl ) :: omega real ( kind = sgl ) :: L real ( kind = sgl ) :: xpc real ( kind = sgl ) :: ypc real ( kind = sgl ) :: thetac real ( kind = sgl ) :: delta integer ( kind = irg ) :: numsx integer ( kind = irg ) :: numsy integer ( kind = irg ) :: binning character ( 3 ) :: scalingmode real ( kind = sgl ) :: gammavalue character ( 1 ) :: maskpattern integer ( kind = irg ) :: nthreads integer ( kind = irg ) :: platid integer ( kind = irg ) :: devid integer ( kind = irg ) :: globalworkgrpsz character ( 3 ) :: eulerconvention character ( fnlen ) :: anglefile character ( fnlen ) :: datafile integer ( kind = irg ) :: multiplier ! define the IO namelist to facilitate passing variables to the program. namelist / EBSDFulldata / xtalname , dmin , totnum_el , EkeV , Ehistmin , Ebinsize , depthmax , depthstep , beamcurrent ,& dwelltime , sig , omega , L , xpc , ypc , thetac , delta , numsx , numsy , binning , scalingmode , gammavalue , maskpattern ,& nthreads , platid , devid , globalworkgrpsz , eulerconvention , anglefile , datafile , multiplier ! set the input parameters to default values (except for xtalname, anglefile and datafile, which must be present) xtalname = 'undefined' ! name of xtal dmin = 0.04D0 ! maximum g vector used in computation totnum_el = 2000000000 ! number of electrons for MC run EkeV = 2 0.D0 ! incident electron energy [kV] Ehistmin = 1 0.D0 ! cutoff energy [kV] Ebinsize = 1.D0 ! energy step size [kV] depthmax = 10 0.D0 ! depth cutoff [nm] depthstep = 1.D0 ! depth bin size [nm] beamcurrent = 100 0.D0 ! [nA] dwelltime = 100 0.D0 ! [micro seconds] sig = 7 0.D0 ! sample tilt angle [degrees] omega = 0.D0 ! tilt about RD axis [degrees] L = 1500 0.0 ! scintillator to sample distance [micro m] xpc = 0.0 ! units of pixel [dimensionless] ypc = 0.0 ! units of pixel [dimensionless] thetac = 1 0.0 ! camera elevation [degrees] delta = 5 9.2 ! physical size of detector pixel [micro m] numsx = 480 ! number of pixel is x direction of scintillator numsy = 480 ! number of pixel is y direction of scintillator binning = 1 ! detector binning scalingmode = 'not' ! intensity scaling in detector gammavalue = 0.34 ! intensity scaling factor maskpattern = 'n' ! circular mask or not nthreads = 1 ! number of CPU threads for computation platid = 2 ! platform id for GPU devid = 1 ! device id for GPU globalworkgrpsz = 256 ! work group size eulerconvention = 'tsl' ! euler angle convention anglefile = 'undefined' ! list of euler angles for which simulation is done datafile = 'undefined' ! output HDF5 file multiplier = 1 if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = EBSDFulldata ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( anglefile ). eq . 'undefined' ) then call FatalError ( 'EMEBSD:' , ' angle file name is undefined in ' // nmlfile ) end if if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'EMEBSD:' , ' xtal file is undefined in ' // nmlfile ) end if if ( trim ( datafile ). eq . 'undefined' ) then call FatalError ( 'EMEBSD:' , ' output file name is undefined in ' // nmlfile ) end if end if enl % MCxtalname = xtalname ! name of xtal enl % dmin = dmin ! maximum g vector used in computation enl % totnum_el = totnum_el ! number of electrons for MC run enl % EkeV = EkeV ! incident electron energy [kV] enl % Ehistmin = Ehistmin ! cutoff energy [kV] enl % Ebinsize = Ebinsize ! energy step size [kV] enl % depthmax = depthmax ! depth cutoff [nm] enl % depthstep = depthstep ! depth bin size [nm] enl % beamcurrent = beamcurrent ! [nA] enl % dwelltime = dwelltime ! [micro seconds] enl % MCsig = sig ! sample tilt angle [degrees] enl % MComega = omega ! tilt about RD axis [degrees] enl % L = L ! scintillator to sample distance [micro m] enl % xpc = xpc ! units of pixel [dimensionless] enl % ypc = ypc ! units of pixel [dimensionless] enl % thetac = thetac ! camera elevation [degrees] enl % delta = delta ! physical size of detector pixel [micro m] enl % numsx = numsx ! number of pixel is x direction of scintillator enl % numsy = numsy ! number of pixel is y direction of scintillator enl % binning = binning ! detector binning enl % scalingmode = scalingmode ! intensity scaling in detector enl % gammavalue = gammavalue ! intensity scaling factor enl % maskpattern = maskpattern ! circular mask or not enl % nthreads = nthreads ! number of CPU threads for computation enl % platid = platid ! platform id for GPU enl % devid = devid ! device id for GPU enl % globalworkgrpsz = globalworkgrpsz ! work group size enl % eulerconvention = eulerconvention ! euler angle convention enl % anglefile = anglefile ! list of euler angles for which simulation is done enl % datafile = datafile ! output HDF5 file enl % multiplier = multiplier ! fill other namelist variables in the ebsd namelist; will be used to write the HDF5 files etc. enl % energyaverage = 0 enl % spatialaverage = 'n' enl % alphaBD = 0.0 enl % energyfile = 'undefined' enl % masterfile = 'undefined' enl % nsx = enl % numsx enl % nsy = enl % numsy enl % num_el = 10 ! this is variable in the MCOpenCL program, here we keep it to a fixed value enl % MCnthreads = enl % nthreads enl % npx = enl % numsx enl % npy = enl % numsy enl % MCmode = 'full' enl % numEbins = int (( enl % EkeV - enl % Ehistmin ) / enl % Ebinsize ) + 1 enl % numzbins = int ( enl % depthmax / enl % depthstep ) + 1 end subroutine GetEBSDFullNameList","tags":"","loc":"proc/getebsdfullnamelist.html","title":"GetEBSDFullNameList – Fortran Program"},{"text":"public recursive subroutine GetSRdefectNameList(nmlfile, srdnl, initonly) Uses: error proc~~getsrdefectnamelist~~UsesGraph proc~getsrdefectnamelist GetSRdefectNameList error error error->proc~getsrdefectnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Patrick Callahan\n @brief read namelist file for EMSRdefect\n @param nmlfile namelist file name\n @date 02/10/17  PGC 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(SRdefectNameListType), intent(inout) :: srdnl logical, intent(in), optional :: initonly Calls proc~~getsrdefectnamelist~~CallsGraph proc~getsrdefectnamelist GetSRdefectNameList emsoft_tonativepath emsoft_tonativepath proc~getsrdefectnamelist->emsoft_tonativepath fatalerror fatalerror proc~getsrdefectnamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetSRdefectNameList Source Code recursive SUBROUTINE GetSRdefectNameList ( nmlfile , srdnl , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetSRdefectNameList use error IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( SRdefectNameListType ), INTENT ( INOUT ) :: srdnl logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . real ( kind = sgl ) :: DF_L integer ( kind = irg ) :: DF_npix integer ( kind = irg ) :: DF_npiy real ( kind = sgl ) :: DF_slice real ( kind = sgl ) :: dmin character ( 4 ) :: progmode integer ( kind = irg ) :: dinfo character ( 3 ) :: outputformat integer ( kind = irg ) :: output character ( fnlen ) :: dataname integer ( kind = irg ) :: t_interval character ( fnlen ) :: dispfile integer ( kind = irg ) :: nthreads character ( 3 ) :: dispmode character ( fnlen ) :: xtalname real ( kind = sgl ) :: voltage integer ( kind = irg ) :: SRG ( 3 ) integer ( kind = irg ) :: Grange real ( kind = sgl ) :: GLaue character ( fnlen ) :: STEMnmlfile character ( fnlen ) :: defectfilename ! DEFINE THE IO NAMELIST FOR VARIABLE PASSING namelist / SRdefectdata / DF_L , DF_npix , DF_npiy , DF_slice , dmin , progmode ,& dinfo , outputformat , output , dataname , t_interval , dispfile , & nthreads , dispmode , xtalname , voltage , SRG , Grange , GLaue , & STEMnmlfile , defectfilename !nthreads, voltage, progmode, xtalname, SRG, lauec, STEMnmlfile, & !                         dataname, defectfilename, dispmode, dispfile, output, dinfo, t_interval, DF_L, & !                         DF_npix, DF_npiy, DF_slice, dmin ! SET INPUT PARAMETERS TO DEFAULT VALUES (EXCEPT XTALNAME, WHICH MUST BE PRESENT) nthreads = 6 voltage = 200000 progmode = 'STEM' xtalname = 'undefined' SRG = ( / 0.0 , 0.0 , 1.0 / ) Grange = 4 GLaue = 0.5 !lauec = (/ 0.0, 0.0 /) STEMnmlfile = 'STEM_rundata.nml' defectfilename = 'EMdefec/dispt.json' dataname = '/folder/to/trialbinary.data' dispmode = 'not' dispfile = 'test_ZA.data' output = 6 ! screen output dinfo = 0 ! 1 is verbose t_interval = 5 ! update every x steps DF_L = 1.0 DF_npix = 256 DF_npiy = 256 DF_slice = 1.0 ! slice thickness for scattering matrix approach (nmu) dmin = 0.03 if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( nmlfile )), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = SRdefectdata ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'SRdefect:' , ' crystal structure file name is undefined in ' // nmlfile ) end if end if srdnl % DF_L = DF_L srdnl % DF_npix = DF_npix srdnl % DF_npiy = DF_npiy srdnl % DF_slice = DF_slice srdnl % dmin = dmin srdnl % progmode = progmode srdnl % dinfo = dinfo srdnl % outputformat = outputformat srdnl % output = output srdnl % dataname = dataname srdnl % t_interval = t_interval srdnl % dispfile = dispfile srdnl % nthreads = nthreads srdnl % dispmode = dispmode srdnl % xtalname = xtalname srdnl % voltage = voltage srdnl % SRG = SRG srdnl % Grange = Grange srdnl % GLaue = GLaue srdnl % STEMnmlfile = STEMnmlfile srdnl % defectfilename = defectfilename !srdnl%nthreads = nthreads !srdnl%voltage = voltage !srdnl%progmode = progmode !srdnl%xtalname = xtalname !srdnl%SRG = SRG !srdnl%lauec = lauec !srdnl%STEMnmlfile = STEMnmlfile !srdnl%dataname = dataname !srdnl%defectfilename = defectfilename !srdnl%dispmode = dispmode !srdnl%dispfile = dispfile !srdnl%output = output !srdnl%dinfo = dinfo !srdnl%t_interval = t_interval !srdnl%DF_L = DF_L !srdnl%DF_npix = DF_npix !srdnl%DF_npiy = DF_npiy !srdnl%DF_slice = DF_slice !srdnl%dmin = dmin END SUBROUTINE GetSRdefectNameList","tags":"","loc":"proc/getsrdefectnamelist.html","title":"GetSRdefectNameList – Fortran Program"},{"text":"public recursive subroutine GetPFInversionNameList(nmlfile, epf, initonly) Uses: error constants proc~~getpfinversionnamelist~~UsesGraph proc~getpfinversionnamelist GetPFInversionNameList error error error->proc~getpfinversionnamelist module~constants constants module~constants->proc~getpfinversionnamelist local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief read namelist file and fill enl structure (used by PFInversionSIRT.f90)\n @param nmlfile namelist file name\n @param epf single name list structure\n @date 04/02/17  SS 1.0 original Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(PFInversionNameListType), intent(inout) :: epf logical, intent(in), optional :: initonly Calls proc~~getpfinversionnamelist~~CallsGraph proc~getpfinversionnamelist GetPFInversionNameList fatalerror fatalerror proc~getpfinversionnamelist->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GetPFInversionNameList Source Code recursive subroutine GetPFInversionNameList ( nmlfile , epf , initonly ) !DEC$ ATTRIBUTES DLLEXPORT :: GetPFInversionNameList use error use constants IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: nmlfile type ( PFInversionNameListType ), INTENT ( INOUT ) :: epf logical , OPTIONAL , INTENT ( IN ) :: initonly logical :: skipread = . FALSE . integer ( kind = irg ) :: nLam , nfiles , nSIRT , ncub character ( fnlen ) :: xtalname character ( fnlen ) :: datafile , flist ( 10 ) namelist / PFInversion / nLam , xtalname , datafile , nfiles , flist , nSIRT , ncub nLam = 20 xtalname = 'undefined' flist ( 1 : 10 ) = 'undefined' nfiles = 1 datafile = 'undefined' nSIRT = 20 ncub = 40 if ( present ( initonly )) then if ( initonly ) skipread = . TRUE . end if if (. not . skipread ) then ! read the namelist file open ( UNIT = dataunit , FILE = trim ( nmlfile ), DELIM = 'apostrophe' , STATUS = 'old' ) read ( UNIT = dataunit , NML = PFInversion ) close ( UNIT = dataunit , STATUS = 'keep' ) ! check for required entries if ( trim ( xtalname ). eq . 'undefined' ) then call FatalError ( 'PFForwardTest:' , ' xtal file name is undefined in ' // nmlfile ) end if if ( trim ( datafile ). eq . 'undefined' ) then call FatalError ( 'PFForwardTest:' , ' datafile name is undefined in ' // nmlfile ) end if end if epf % xtalname = xtalname epf % nfiles = nfiles epf % flist ( 1 : nfiles ) = flist ( 1 : nfiles ) epf % nLam = nLam epf % datafile = datafile epf % nSIRT = nSIRT epf % ncub = ncub end subroutine GetPFInversionNameList","tags":"","loc":"proc/getpfinversionnamelist.html","title":"GetPFInversionNameList – Fortran Program"},{"text":"public recursive function alogam(x, ifault) ALOGAM computes the logarithm of the Gamma function. Arguments Type Intent Optional Attributes Name real(kind=8) :: x integer(kind=4) :: ifault Return Value real(kind=8) Called By proc~~alogam~~CalledByGraph proc~alogam alogam proc~poidev POIDEV proc~poidev->proc~alogam Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code alogam Source Code recursive function alogam ( x , ifault ) !DEC$ ATTRIBUTES DLLEXPORT :: alogam ! this function can be used to compute the volume of a super ellipsoid. !*****************************************************************************80 ! !! ALOGAM computes the logarithm of the Gamma function. ! !  Modified: ! !    28 March 1999 ! !  Author: ! !    Malcolm Pike, David Hill !    FORTRAN90 version by John Burkardt ! !  Reference: ! !    Malcolm Pike, David Hill, !    Algorithm 291: !    Logarithm of Gamma Function, !    Communications of the ACM, !    Volume 9, Number 9, September 1966, page 684. ! !  Parameters: ! !    Input, real ( kind = 8 ) X, the argument of the Gamma function. !    X should be greater than 0. ! !    Output, integer ( kind = 4 ) IFAULT, error flag. !    0, no error. !    1, X <= 0. ! !    Output, real ( kind = 8 ) ALOGAM, the logarithm of the Gamma !    function of X. ! implicit none real ( kind = 8 ) alogam real ( kind = 8 ) f integer ( kind = 4 ) ifault real ( kind = 8 ) x real ( kind = 8 ) y real ( kind = 8 ) z if ( x <= 0.0D+00 ) then ifault = 1 alogam = 0.0D+00 return end if ifault = 0 y = x if ( x < 7.0D+00 ) then f = 1.0D+00 z = y do while ( z < 7.0D+00 ) f = f * z z = z + 1.0D+00 end do y = z f = - log ( f ) else f = 0.0D+00 end if z = 1.0D+00 / y / y alogam = f + ( y - 0.5D+00 ) * log ( y ) - y & + 0.918938533204673D+00 + & ((( & - 0.000595238095238D+00 * z & + 0.000793650793651D+00 ) * z & - 0.002777777777778D+00 ) * z & + 0.083333333333333D+00 ) / y return end function alogam","tags":"","loc":"proc/alogam.html","title":"alogam – Fortran Program"},{"text":"public function ran(idum) Arguments Type Intent Optional Attributes Name integer(kind=K4B), intent(inout) :: idum Return Value real(kind=sgl)","tags":"","loc":"proc/ran.html","title":"ran – Fortran Program"},{"text":"public function POIDEV(XM, IDUM) Uses: local proc~~poidev~~UsesGraph proc~poidev POIDEV local local local->proc~poidev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real(kind=sgl), intent(in) :: XM integer(kind=K4B), intent(inout) :: IDUM Return Value real(kind=sgl) Calls proc~~poidev~~CallsGraph proc~poidev POIDEV alog alog proc~poidev->alog proc~alogam alogam proc~poidev->proc~alogam Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/poidev.html","title":"POIDEV – Fortran Program"},{"text":"public recursive function FSCATT(G, UL, Z, SYMBOL, ACCVLT, ABSFLG, ACCFLG, DWFLG) Uses: error proc~~fscatt~~UsesGraph proc~fscatt FSCATT error error error->proc~fscatt Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @author A. Weickenmeier, original f77 code\n @brief computes the complex scattering amplitude\n @details 'use's error and local modules; Weickenmeier's original comments\n and notes are left unchanged in the source code.\n @date 5/21/01 MDG 1.0 original f90 translation\n @date 3/21/13 MDG 2.0 updated IO statements Arguments Type Intent Optional Attributes Name real :: G real :: UL integer(kind=irg) :: Z character(len=2) :: SYMBOL real :: ACCVLT integer(kind=irg) :: ABSFLG logical :: ACCFLG logical :: DWFLG Return Value complex Calls proc~~fscatt~~CallsGraph proc~fscatt FSCATT proc~weko WEKO proc~fscatt->proc~weko proc~fphon FPHON proc~fscatt->proc~fphon fatalerror fatalerror proc~fscatt->fatalerror proc~fcore FCORE proc~fscatt->proc~fcore proc~getwk GETWK proc~fscatt->proc~getwk proc~ri2 RI2 proc~fphon->proc~ri2 proc~ri1 RI1 proc~fphon->proc~ri1 proc~fcore->fatalerror proc~rih1 RIH1 proc~ri2->proc~rih1 proc~ei EI proc~ri2->proc~ei proc~ri1->proc~rih1 proc~ri1->proc~ei proc~rih1->proc~ei proc~rih2 RIH2 proc~rih1->proc~rih2 proc~ei->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/fscatt.html","title":"FSCATT – Fortran Program"},{"text":"public function WEKO(A, B, S) Arguments Type Intent Optional Attributes Name real(kind=sgl) :: A (4) real(kind=sgl) :: B (4) real :: S Return Value real Called By proc~~weko~~CalledByGraph proc~weko WEKO proc~fscatt FSCATT proc~fscatt->proc~weko Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/weko.html","title":"WEKO – Fortran Program"},{"text":"public function FPHON(G, UL, A, B) Arguments Type Intent Optional Attributes Name real :: G real :: UL real(kind=sgl) :: A (4) real(kind=sgl) :: B (4) Return Value real Calls proc~~fphon~~CallsGraph proc~fphon FPHON proc~ri2 RI2 proc~fphon->proc~ri2 proc~ri1 RI1 proc~fphon->proc~ri1 proc~rih1 RIH1 proc~ri2->proc~rih1 proc~ei EI proc~ri2->proc~ei proc~ri1->proc~rih1 proc~ri1->proc~ei proc~rih1->proc~ei proc~rih2 RIH2 proc~rih1->proc~rih2 fatalerror fatalerror proc~ei->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~fphon~~CalledByGraph proc~fphon FPHON proc~fscatt FSCATT proc~fscatt->proc~fphon Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/fphon.html","title":"FPHON – Fortran Program"},{"text":"public function RI1(BI, BJ, G) Arguments Type Intent Optional Attributes Name real :: BI real :: BJ real :: G Return Value real Calls proc~~ri1~~CallsGraph proc~ri1 RI1 proc~rih1 RIH1 proc~ri1->proc~rih1 proc~ei EI proc~ri1->proc~ei proc~rih1->proc~ei proc~rih2 RIH2 proc~rih1->proc~rih2 fatalerror fatalerror proc~ei->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~ri1~~CalledByGraph proc~ri1 RI1 proc~fphon FPHON proc~fphon->proc~ri1 proc~fscatt FSCATT proc~fscatt->proc~fphon Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/ri1.html","title":"RI1 – Fortran Program"},{"text":"public function RI2(BI, BJ, G, U) Arguments Type Intent Optional Attributes Name real :: BI real :: BJ real :: G real :: U Return Value real Calls proc~~ri2~~CallsGraph proc~ri2 RI2 proc~rih1 RIH1 proc~ri2->proc~rih1 proc~ei EI proc~ri2->proc~ei proc~rih1->proc~ei proc~rih2 RIH2 proc~rih1->proc~rih2 fatalerror fatalerror proc~ei->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~ri2~~CalledByGraph proc~ri2 RI2 proc~fphon FPHON proc~fphon->proc~ri2 proc~fscatt FSCATT proc~fscatt->proc~fphon Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/ri2.html","title":"RI2 – Fortran Program"},{"text":"public function RIH1(X1, X2, X3) Arguments Type Intent Optional Attributes Name real :: X1 real :: X2 real :: X3 Return Value real Calls proc~~rih1~~CallsGraph proc~rih1 RIH1 proc~rih2 RIH2 proc~rih1->proc~rih2 proc~ei EI proc~rih1->proc~ei fatalerror fatalerror proc~ei->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~rih1~~CalledByGraph proc~rih1 RIH1 proc~ri2 RI2 proc~ri2->proc~rih1 proc~ri1 RI1 proc~ri1->proc~rih1 proc~fphon FPHON proc~fphon->proc~ri2 proc~fphon->proc~ri1 proc~fscatt FSCATT proc~fscatt->proc~fphon Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/rih1.html","title":"RIH1 – Fortran Program"},{"text":"public function RIH2(X) Arguments Type Intent Optional Attributes Name real :: X Return Value real Called By proc~~rih2~~CalledByGraph proc~rih2 RIH2 proc~rih1 RIH1 proc~rih1->proc~rih2 proc~rih3 RIH3 proc~rih3->proc~rih2 proc~ri2 RI2 proc~ri2->proc~rih1 proc~ri1 RI1 proc~ri1->proc~rih1 proc~fphon FPHON proc~fphon->proc~ri2 proc~fphon->proc~ri1 proc~fscatt FSCATT proc~fscatt->proc~fphon Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/rih2.html","title":"RIH2 – Fortran Program"},{"text":"public function RIH3(X) Arguments Type Intent Optional Attributes Name real :: X Return Value real Calls proc~~rih3~~CallsGraph proc~rih3 RIH3 proc~rih2 RIH2 proc~rih3->proc~rih2 proc~ei EI proc~rih3->proc~ei fatalerror fatalerror proc~ei->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/rih3.html","title":"RIH3 – Fortran Program"},{"text":"public function EI(X) Uses: io error proc~~ei~~UsesGraph proc~ei EI io io io->proc~ei error error error->proc~ei Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real :: X Return Value real Calls proc~~ei~~CallsGraph proc~ei EI fatalerror fatalerror proc~ei->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~ei~~CalledByGraph proc~ei EI proc~rih1 RIH1 proc~rih1->proc~ei proc~rih3 RIH3 proc~rih3->proc~ei proc~ri1 RI1 proc~ri1->proc~ei proc~ri1->proc~rih1 proc~ri2 RI2 proc~ri2->proc~ei proc~ri2->proc~rih1 proc~fphon FPHON proc~fphon->proc~ri1 proc~fphon->proc~ri2 proc~fscatt FSCATT proc~fscatt->proc~fphon Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/ei.html","title":"EI – Fortran Program"},{"text":"public function FCORE(G, Z, ACCVLT) Uses: io error proc~~fcore~~UsesGraph proc~fcore FCORE io io io->proc~fcore error error error->proc~fcore Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name real :: G integer :: Z real :: ACCVLT Return Value real Calls proc~~fcore~~CallsGraph proc~fcore FCORE fatalerror fatalerror proc~fcore->fatalerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~fcore~~CalledByGraph proc~fcore FCORE proc~fscatt FSCATT proc~fscatt->proc~fcore Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/fcore.html","title":"FCORE – Fortran Program"},{"text":"public subroutine GETWK(Z, SYMBOL, A, B) Arguments Type Intent Optional Attributes Name integer :: Z character(len=2) :: SYMBOL real(kind=sgl) :: A (4) real(kind=sgl) :: B (4) Called By proc~~getwk~~CalledByGraph proc~getwk GETWK proc~fscatt FSCATT proc~fscatt->proc~getwk Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs.","tags":"","loc":"proc/getwk.html","title":"GETWK – Fortran Program"},{"text":"public subroutine SSORT(X, Y, N, KFLAG) @author Taken from http://www.personal.psu.edu/jhm/f90/examples/sort/sorthalf.f\n @brief sort the array\n Parameters described in the program Arguments Type Intent Optional Attributes Name real :: X (*) integer :: Y (*) integer :: N integer :: KFLAG","tags":"","loc":"proc/ssort.html","title":"SSORT – Fortran Program"},{"text":"public subroutine qsortd(x, ind, n) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: x (n) integer, intent(out) :: ind (n) integer, intent(in) :: n Called By proc~~qsortd~~CalledByGraph proc~qsortd qsortd proc~senzaderglob SENZADERGLOB proc~senzaderglob->proc~qsortd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code qsortd Source Code SUBROUTINE qsortd ( x , ind , n ) ! Code converted using TO_F90 by Alan Miller ! Date: 2002-12-18  Time: 11:55:47 IMPLICIT NONE INTEGER , INTENT ( IN ) :: n REAL * 8 , INTENT ( IN ) :: x ( n ) INTEGER , INTENT ( OUT ) :: ind ( n ) !*************************************************************************** !                                                         ROBERT RENKA !                                                 OAK RIDGE NATL. LAB. !   THIS SUBROUTINE USES AN ORDER N*LOG(N) QUICK SORT TO SORT A REAL (dp) ! ARRAY X INTO INCREASING ORDER.  THE ALGORITHM IS AS FOLLOWS.  IND IS ! INITIALIZED TO THE ORDERED SEQUENCE OF INDICES 1,...,N, AND ALL INTERCHANGES ! ARE APPLIED TO IND.  X IS DIVIDED INTO TWO PORTIONS BY PICKING A CENTRAL ! ELEMENT T.  THE FIRST AND LAST ELEMENTS ARE COMPARED WITH T, AND ! INTERCHANGES ARE APPLIED AS NECESSARY SO THAT THE THREE VALUES ARE IN ! ASCENDING ORDER.  INTERCHANGES ARE THEN APPLIED SO THAT ALL ELEMENTS ! GREATER THAN T ARE IN THE UPPER PORTION OF THE ARRAY AND ALL ELEMENTS ! LESS THAN T ARE IN THE LOWER PORTION.  THE UPPER AND LOWER INDICES OF ONE ! OF THE PORTIONS ARE SAVED IN LOCAL ARRAYS, AND THE PROCESS IS REPEATED ! ITERATIVELY ON THE OTHER PORTION.  WHEN A PORTION IS COMPLETELY SORTED, ! THE PROCESS BEGINS AGAIN BY RETRIEVING THE INDICES BOUNDING ANOTHER ! UNSORTED PORTION. ! INPUT PARAMETERS -   N - LENGTH OF THE ARRAY X. !                      X - VECTOR OF LENGTH N TO BE SORTED. !                    IND - VECTOR OF LENGTH >= N. ! N AND X ARE NOT ALTERED BY THIS ROUTINE. ! OUTPUT PARAMETER - IND - SEQUENCE OF INDICES 1,...,N PERMUTED IN THE SAME !                          FASHION AS X WOULD BE.  THUS, THE ORDERING ON !                          X IS DEFINED BY Y(I) = X(IND(I)). !********************************************************************* ! NOTE -- IU AND IL MUST BE DIMENSIONED >= LOG(N) WHERE LOG HAS BASE 2. !********************************************************************* INTEGER :: iu ( 21 ), il ( 21 ) INTEGER :: m , i , j , k , l , ij , it , itt , indx REAL :: r REAL * 8 :: t ! LOCAL PARAMETERS - ! IU,IL =  TEMPORARY STORAGE FOR THE UPPER AND LOWER !            INDICES OF PORTIONS OF THE ARRAY X ! M =      INDEX FOR IU AND IL ! I,J =    LOWER AND UPPER INDICES OF A PORTION OF X ! K,L =    INDICES IN THE RANGE I,...,J ! IJ =     RANDOMLY CHOSEN INDEX BETWEEN I AND J ! IT,ITT = TEMPORARY STORAGE FOR INTERCHANGES IN IND ! INDX =   TEMPORARY INDEX FOR X ! R =      PSEUDO RANDOM NUMBER FOR GENERATING IJ ! T =      CENTRAL ELEMENT OF X IF ( n <= 0 ) RETURN ! INITIALIZE IND, M, I, J, AND R DO i = 1 , n ind ( i ) = i END DO m = 1 i = 1 j = n r = . 375 ! TOP OF LOOP 20 IF ( i >= j ) GO TO 70 IF ( r <= . 5898437 ) THEN r = r + . 0390625 ELSE r = r - . 21875 END IF ! INITIALIZE K 30 k = i ! SELECT A CENTRAL ELEMENT OF X AND SAVE IT IN T ij = i + r * ( j - i ) it = ind ( ij ) t = x ( it ) ! IF THE FIRST ELEMENT OF THE ARRAY IS GREATER THAN T, !   INTERCHANGE IT WITH T indx = ind ( i ) IF ( x ( indx ) > t ) THEN ind ( ij ) = indx ind ( i ) = it it = indx t = x ( it ) END IF ! INITIALIZE L l = j ! IF THE LAST ELEMENT OF THE ARRAY IS LESS THAN T, !   INTERCHANGE IT WITH T indx = ind ( j ) IF ( x ( indx ) >= t ) GO TO 50 ind ( ij ) = indx ind ( j ) = it it = indx t = x ( it ) ! IF THE FIRST ELEMENT OF THE ARRAY IS GREATER THAN T, !   INTERCHANGE IT WITH T indx = ind ( i ) IF ( x ( indx ) <= t ) GO TO 50 ind ( ij ) = indx ind ( i ) = it it = indx t = x ( it ) GO TO 50 ! INTERCHANGE ELEMENTS K AND L 40 itt = ind ( l ) ind ( l ) = ind ( k ) ind ( k ) = itt ! FIND AN ELEMENT IN THE UPPER PART OF THE ARRAY WHICH IS !   NOT LARGER THAN T 50 l = l - 1 indx = ind ( l ) IF ( x ( indx ) > t ) GO TO 50 ! FIND AN ELEMENT IN THE LOWER PART OF THE ARRAY WHCIH IS NOT SMALLER THAN T 60 k = k + 1 indx = ind ( k ) IF ( x ( indx ) < t ) GO TO 60 ! IF K <= L, INTERCHANGE ELEMENTS K AND L IF ( k <= l ) GO TO 40 ! SAVE THE UPPER AND LOWER SUBSCRIPTS OF THE PORTION OF THE !   ARRAY YET TO BE SORTED IF ( l - i > j - k ) THEN il ( m ) = i iu ( m ) = l i = k m = m + 1 GO TO 80 END IF il ( m ) = k iu ( m ) = j j = l m = m + 1 GO TO 80 ! BEGIN AGAIN ON ANOTHER UNSORTED PORTION OF THE ARRAY 70 m = m - 1 IF ( m == 0 ) RETURN i = il ( m ) j = iu ( m ) 80 IF ( j - i >= 11 ) GO TO 30 IF ( i == 1 ) GO TO 20 i = i - 1 ! SORT ELEMENTS I+1,...,J.  NOTE THAT 1 <= I < J AND J-I < 11. 90 i = i + 1 IF ( i == j ) GO TO 70 indx = ind ( i + 1 ) t = x ( indx ) it = indx indx = ind ( i ) IF ( x ( indx ) <= t ) GO TO 90 k = i 100 ind ( k + 1 ) = ind ( k ) k = k - 1 indx = ind ( k ) IF ( t < x ( indx )) GO TO 100 ind ( k + 1 ) = it GO TO 90 END SUBROUTINE qsortd","tags":"","loc":"proc/qsortd.html","title":"qsortd – Fortran Program"},{"text":"public recursive subroutine CalcKINPEDPatternSingle(pednl, cell, reflistarray, sanglearray, nref, qu, pedpattern) Uses: NameListTypedefs typedefs quaternions constants diffraction proc~~calckinpedpatternsingle~~UsesGraph proc~calckinpedpatternsingle CalcKINPEDPatternSingle module~constants constants module~constants->proc~calckinpedpatternsingle typedefs typedefs typedefs->proc~calckinpedpatternsingle diffraction diffraction diffraction->proc~calckinpedpatternsingle module~namelisttypedefs NameListTypedefs module~namelisttypedefs->proc~calckinpedpatternsingle quaternions quaternions quaternions->proc~calckinpedpatternsingle local local local->module~constants local->module~namelisttypedefs Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief calculate single PED pattern; used in the EMPEDDI program\n @param pednl PED name list structure\n @param cell cell structure\n @param reflist list of possible reflections\n @param nref number of reflections in master list\n @param qu orientation of xtal\n @param pedpattern calculated kinematic ped pattern\n @date 06/24/14  SS 1.0 original\n @date 04/28/16  SS 1.1 corrected array bound error Arguments Type Intent Optional Attributes Name type(PEDKINIndxListType), intent(in) :: pednl type(unitcell), pointer :: cell integer(kind=irg), intent(in) :: reflistarray (3,nref) real(kind=sgl), intent(in) :: sanglearray (nref) integer(kind=irg), intent(in) :: nref real(kind=sgl), intent(in) :: qu (4) real(kind=sgl), intent(out) :: pedpattern (1:pednl%npix,1:pednl%npix) Calls proc~~calckinpedpatternsingle~~CallsGraph proc~calckinpedpatternsingle CalcKINPEDPatternSingle float float proc~calckinpedpatternsingle->float sngl sngl proc~calckinpedpatternsingle->sngl calcsg calcsg proc~calckinpedpatternsingle->calcsg quat_lp quat_lp proc~calckinpedpatternsingle->quat_lp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code CalcKINPEDPatternSingle Source Code recursive subroutine CalcKINPEDPatternSingle ( pednl , cell , reflistarray , sanglearray , nref , qu , pedpattern ) !DEC$ ATTRIBUTES DLLEXPORT :: CalcKINPEDPatternSingle use NameListTypedefs use typedefs use quaternions use constants use diffraction IMPLICIT NONE type ( PEDKINIndxListType ), INTENT ( IN ) :: pednl type ( unitcell ), pointer :: cell integer ( kind = irg ), INTENT ( IN ) :: reflistarray ( 3 , nref ) real ( kind = sgl ), INTENT ( IN ) :: sanglearray ( nref ) !type(reflisttype), pointer                   :: reflist, rltmpa, nexts integer ( kind = irg ), INTENT ( IN ) :: nref real ( kind = sgl ), INTENT ( IN ) :: qu ( 4 ) real ( kind = sgl ), INTENT ( OUT ) :: pedpattern ( 1 : pednl % npix , 1 : pednl % npix ) integer ( kind = irg ) :: io_int ( 6 ), i , j , sx , sy , ww , tdp , nsize , gg ( 3 ), nns , counter real ( kind = sgl ) :: sgmax , k ( 3 ), ku ( 3 ), FN ( 3 ), kp ( 3 ), w , x , y real ( kind = sgl ) :: dx , dy , rnmpp , Ig , Igmax real ( kind = sgl ), allocatable :: xx (:,:), yy (:,:), line (:), dot (:,:), image (:,:) real ( kind = sgl ), allocatable :: sgarray (:), sanglearraystrong (:), sgarraystrong (:) integer ( kind = irg ), allocatable :: reflistarraystrong (:,:) sgmax = pednl % sgmax Igmax = pednl % Igmax rnmpp = 1.0 / pednl % rnmpp ww = pednl % ww tdp = 2 * ww + 1 nsize = pednl % npix / 2 + ww allocate ( image ( - nsize : nsize , - nsize : nsize ), xx ( - ww : ww , - ww : ww ), yy ( - ww : ww , - ww : ww ), line ( - ww : ww ), dot ( - ww : ww , - ww : ww )) line = ( / ( float ( i ), i =- ww , ww ) / ) * rnmpp xx = spread ( line , dim = 1 , ncopies = 2 * ww + 1 ) yy = transpose ( xx ) image = 0.0 ! multiplication with (0,0,1) produces the normalized beam direction in a ! cartesian reference frame; so now we can compute the excitation errors ! for every reflection and keep only the ones that are sufficiently small k = ( / 0.0 , 0.0 , 1.0 / ) ku = quat_LP ( qu , k ) FN = ku k = ku / sngl ( cell % mLambda ) ! first we go through the entire reflection list and compute the excitation errors ! those points that satisfy the cutoff are linked via the nexts pointers allocate ( sgarray ( nref )) sgarray = 0.0 ! counter for number of strong beams nns = 0 do j = 1 , nref gg = reflistarray ( 1 : 3 , j ) sgarray ( j ) = Calcsg ( cell , float ( gg ), k , FN ) ! should we consider this point any further ? If so, increase strong reflection list counter if ( abs ( sgarray ( j )). le . sgmax ) then nns = nns + 1 end if end do allocate ( sgarraystrong ( nns ), sanglearraystrong ( nns ), reflistarraystrong ( 3 , nns )) counter = 1 do j = 1 , nref if ( abs ( sgarray ( j )) . le . sgmax ) then reflistarraystrong ( 1 : 3 , counter ) = reflistarray ( 1 : 3 , j ) sgarraystrong ( counter ) = sgarray ( j ) sanglearraystrong ( counter ) = sanglearray ( j ) counter = counter + 1 end if end do ! then, for each point in the nexts list, we compute the components of k' = k+g+s ! and place them in the proper reference frame; we skip the incident beam since it is ! meaningless in the kinematical approximation ! strat from 2 to exclude the transmitted beam do j = 2 , nns ! determine the vector k' kp = k + reflistarraystrong ( 1 : 3 , j ) + sgarraystrong ( j ) * ku kp = quat_LP ( conjg ( qu ), kp ) ! get the intensity for each point w = sngl ( cPi ) * sgarraystrong ( j ) * pednl % thickness if ( abs ( w ). lt . 1.0e-6 ) then Ig = sanglearraystrong ( j ) ! * (sngl(cPi)*pednl%thickness/nexts%xg)**2 else Ig = sanglearraystrong ( j ) * ( sin ( w ) / w ) ** 2 ! * (sngl(cPi)*pednl%thickness/nexts%xg)**2 end if ! determine the spot coordinates on the detector x = rnmpp * kp ( 1 ) y = rnmpp * kp ( 2 ) ! and plot that spot as a small Gaussian in the pedpattern array, assuming it falls on the detector. if (( abs ( x ). le . nsize - ww ). and .( abs ( y ). le . nsize - ww )) then sx = nint ( x ) sy = nint ( y ) dx = x - sx dy = y - sy dot = ( Ig / Igmax ) ** 0.2 * exp ( - (( xx - dx ) ** 2 + ( yy - dy ) ** 2 ) * 0.0022 ) image ( sx - ww : sx + ww , sy - ww : sy + ww ) = image ( sx - ww : sx + ww , sy - ww : sy + ww ) + dot ( - ww : ww , - ww : ww ) end if end do pedpattern ( 1 : pednl % npix , 1 : pednl % npix ) = image ( - nsize + ww : nsize - ww - 1 , - nsize + ww : nsize - ww - 1 ) deallocate ( image , xx , yy , line , dot ) deallocate ( sgarray , sgarraystrong , sanglearraystrong , reflistarraystrong ) end subroutine CalcKINPEDPatternSingle","tags":"","loc":"proc/calckinpedpatternsingle.html","title":"CalcKINPEDPatternSingle – Fortran Program"},{"text":"public recursive subroutine Denoise_PED(pednl, img_in, img_out) Uses: local iso_c_binding NameListTypedefs proc~~denoise_ped~~UsesGraph proc~denoise_ped Denoise_PED iso_c_binding iso_c_binding iso_c_binding->proc~denoise_ped local local local->proc~denoise_ped module~namelisttypedefs NameListTypedefs local->module~namelisttypedefs module~namelisttypedefs->proc~denoise_ped Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief Denoise a kinematical PED pattern\n @param pednl namelist file for PED\n @date 11/23/15  SS 1.0 original Arguments Type Intent Optional Attributes Name type(PEDKINIndxListType), intent(in) :: pednl real(kind=sgl), intent(in), target :: img_in (1:pednl%npix**2) real(kind=sgl), intent(out) :: img_out (1:pednl%npix**2) Source Code Denoise_PED Source Code recursive subroutine Denoise_PED ( pednl , img_in , img_out ) !DEC$ ATTRIBUTES DLLEXPORT :: Denoise_PED use local use ISO_C_BINDING use NameListTypedefs interface type ( C_PTR ) recursive function denoise ( lx , ly , pf , powp , sigma_w , prinf , noisinf , & icd , mbike ) bind ( C , name = 'denoise' ) use ISO_C_BINDING IMPLICIT NONE integer ( C_INT ) :: lx integer ( C_INT ) :: ly real ( C_FLOAT ) :: pf real ( C_FLOAT ) :: powp real ( C_FLOAT ) :: sigma_w real ( C_FLOAT ) :: prinf real ( C_FLOAT ) :: noisinf integer ( C_INT ) :: icd real ( C_DOUBLE ) :: mbike end function denoise end interface type ( PEDKINIndxListType ), INTENT ( IN ) :: pednl real ( kind = sgl ), INTENT ( IN ), target :: img_in ( 1 : pednl % npix ** 2 ) real ( kind = sgl ), INTENT ( OUT ) :: img_out ( 1 : pednl % npix ** 2 ) integer ( C_INT ) :: retval real ( C_FLOAT ), target :: pf , powp , sigma_w , prinf , noisinf integer ( C_INT ), target :: lx , ly , icd , length integer ( kind = irg ) :: istat real ( C_DOUBLE ), pointer :: output (:) type ( C_PTR ) :: out_ptr real ( C_DOUBLE ), allocatable , target :: aux_img (:) lx = pednl % npix ly = pednl % npix ! these values will remain fixed pf = 1.0 powp = 1.2 sigma_w = 1 5.0 prinf = 1.0 noisinf = 0.2 icd = 15 allocate ( aux_img ( 1 : lx * ly ), stat = istat ) aux_img ( 1 : lx * ly ) = img_in ( 1 : lx * ly ) out_ptr = denoise ( lx , ly , pf , powp , sigma_w , prinf , noisinf , icd , aux_img ( 1 )) call C_F_POINTER ( out_ptr , output , ( / lx * ly / )) img_out ( 1 : lx * ly ) = output ( 1 : lx * ly ) deallocate ( aux_img ) deallocate ( output ) end subroutine Denoise_PED","tags":"","loc":"proc/denoise_ped.html","title":"Denoise_PED – Fortran Program"},{"text":"public recursive subroutine Denoise_Pattern(flx, fly, fpf, fpowp, fsigma_w, fprinf, fnoisinf, ficd, img_in, img_out) bind(C, name = \"0\") Uses: local iso_c_binding proc~~denoise_pattern~~UsesGraph proc~denoise_pattern Denoise_Pattern iso_c_binding iso_c_binding iso_c_binding->proc~denoise_pattern local local local->proc~denoise_pattern Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief Denoise an arbitrary pattern\n @param pednl namelist file for PED\n @date 11/23/15  SS 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: flx integer(kind=irg), intent(in) :: fly real(kind=sgl), intent(in) :: fpf real(kind=sgl), intent(in) :: fpowp real(kind=sgl), intent(in) :: fsigma_w real(kind=sgl), intent(in) :: fprinf real(kind=sgl), intent(in) :: fnoisinf integer(kind=irg), intent(in) :: ficd real(kind=sgl), intent(in), target :: img_in (1:flx*fly) real(kind=sgl), intent(out) :: img_out (1:flx*fly) Source Code Denoise_Pattern Source Code recursive subroutine Denoise_Pattern ( flx , fly , fpf , fpowp , fsigma_w , fprinf , fnoisinf , ficd , img_in , & img_out ) bind ( C , name = 'Denoise_Pattern' ) !DEC$ ATTRIBUTES DLLEXPORT :: Denoise_Pattern use local use , INTRINSIC :: ISO_C_BINDING interface type ( C_PTR ) recursive function denoise ( lx , ly , pf , powp , sigma_w , prinf , noisinf , & icd , mbike ) bind ( C , name = 'denoise' ) use ISO_C_BINDING IMPLICIT NONE integer ( C_INT ) :: lx integer ( C_INT ) :: ly real ( C_FLOAT ) :: pf real ( C_FLOAT ) :: powp real ( C_FLOAT ) :: sigma_w real ( C_FLOAT ) :: prinf real ( C_FLOAT ) :: noisinf integer ( C_INT ) :: icd real ( C_DOUBLE ) :: mbike end function denoise end interface integer ( kind = irg ), INTENT ( IN ) :: flx integer ( kind = irg ), INTENT ( IN ) :: fly real ( kind = sgl ), INTENT ( IN ) :: fpf , fpowp , fsigma_w , fprinf , fnoisinf integer ( kind = irg ), INTENT ( IN ) :: ficd real ( kind = sgl ), INTENT ( IN ), target :: img_in ( 1 : flx * fly ) real ( kind = sgl ), INTENT ( OUT ) :: img_out ( 1 : flx * fly ) integer ( C_INT ) :: retval real ( C_FLOAT ), target :: pf , powp , sigma_w , prinf , noisinf integer ( C_INT ), target :: lx , ly , icd , length integer ( kind = irg ) :: istat real ( C_DOUBLE ), pointer :: output (:) type ( C_PTR ) :: out_ptr real ( C_DOUBLE ), allocatable , target :: aux_img (:) lx = flx ly = fly ! these values will remain fixed pf = fpf ! = 1.0 powp = fpowp ! = 1.2 sigma_w = fsigma_w ! = 15.0 prinf = fprinf ! = 1.0 noisinf = fnoisinf ! = 0.2 icd = ficd ! = 15 allocate ( aux_img ( 1 : lx * ly ), stat = istat ) aux_img ( 1 : lx * ly ) = img_in ( 1 : lx * ly ) out_ptr = denoise ( lx , ly , pf , powp , sigma_w , prinf , noisinf , icd , aux_img ( 1 )) call C_F_POINTER ( out_ptr , output , ( / lx * ly / )) img_out ( 1 : lx * ly ) = output ( 1 : lx * ly ) deallocate ( aux_img ) deallocate ( output ) end subroutine Denoise_Pattern","tags":"","loc":"proc/denoise_pattern.html","title":"Denoise_Pattern – Fortran Program"},{"text":"public recursive subroutine ctfped_writeFile(pednl, ipar, indexmain, eulerarray, resultmain) Uses: local NameListTypedefs proc~~ctfped_writefile~~UsesGraph proc~ctfped_writefile ctfped_writeFile local local local->proc~ctfped_writefile module~namelisttypedefs NameListTypedefs local->module~namelisttypedefs module~namelisttypedefs->proc~ctfped_writefile Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief subroutine to write ctf file for ped indexing program\n @param pednl namelist file for PED\n @param ipar  some integer parameters passed to the subroutine\n @param indexmain indices for top nnk match\n @param eulerarray main euler angle list for the RFZ sampling\n @param resultmain list of dot products for all nnk matches \n @date 04/27/16  SS 1.0 original Arguments Type Intent Optional Attributes Name type(PEDKINIndxListType), intent(inout) :: pednl integer(kind=irg), intent(in) :: ipar (10) integer(kind=irg), intent(in) :: indexmain (ipar(1),ipar(2)) real(kind=sgl), intent(in) :: eulerarray (3,ipar(4)) real(kind=sgl), intent(in) :: resultmain (ipar(1),ipar(2)) Calls proc~~ctfped_writefile~~CallsGraph proc~ctfped_writefile ctfped_writeFile float float proc~ctfped_writefile->float emsoft_tonativepath emsoft_tonativepath proc~ctfped_writefile->emsoft_tonativepath emsoft_getemdatapathname emsoft_getemdatapathname proc~ctfped_writefile->emsoft_getemdatapathname emsoft_getusername emsoft_getusername proc~ctfped_writefile->emsoft_getusername Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code ctfped_writeFile Source Code recursive subroutine ctfped_writeFile ( pednl , ipar , indexmain , eulerarray , resultmain ) !DEC$ ATTRIBUTES DLLEXPORT :: ctfped_writeFile use local use NameListTypedefs IMPLICIT NONE type ( PEDKINIndxListType ), INTENT ( INOUT ) :: pednl integer ( kind = irg ), INTENT ( IN ) :: ipar ( 10 ) integer ( kind = irg ), INTENT ( IN ) :: indexmain ( ipar ( 1 ), ipar ( 2 )) real ( kind = sgl ), INTENT ( IN ) :: eulerarray ( 3 , ipar ( 4 )) real ( kind = sgl ), INTENT ( IN ) :: resultmain ( ipar ( 1 ), ipar ( 2 )) integer ( kind = irg ) :: ierr , ii , indx character ( fnlen ) :: ctfname character :: TAB = CHAR ( 9 ) character ( fnlen ) :: str1 , str2 , str3 , str4 , str5 , str6 , str7 , str8 , str9 , str10 real ( kind = sgl ) :: euler ( 3 ) ! open the file (overwrite old one if it exists) ctfname = trim ( EMsoft_getEMdatapathname ()) // trim ( pednl % ctffile ) ctfname = EMsoft_toNativePath ( ctfname ) open ( unit = dataunit2 , file = trim ( ctfname ), status = 'unknown' , action = 'write' , iostat = ierr ) write ( dataunit2 , '(A)' ), 'Channel Text File' write ( dataunit2 , '(A)' ), 'Prj Test' write ( dataunit2 , '(A)' ), 'Author\t' // trim ( EMsoft_getUsername ()) write ( dataunit2 , '(A)' ), 'JobMode\tGrid' write ( dataunit2 , '(2A,I5)' ), 'XCells' , TAB , pednl % ipf_wd write ( dataunit2 , '(2A,I5)' ), 'YCells' , TAB , pednl % ipf_ht write ( dataunit2 , '(3A)' ), 'XStep' , TAB , '1.0' write ( dataunit2 , '(3A)' ), 'YStep' , TAB , '1.0' write ( dataunit2 , '(A)' ), 'AcqE1\t0' write ( dataunit2 , '(A)' ), 'AcqE2\t0' write ( dataunit2 , '(A)' ), 'AcqE3\t0' write ( dataunit2 , '(A,A,$)' ), 'Euler angles refer to Sample Coordinate system (CS0)!' , TAB ! the following line would need some work to do it properly... write ( dataunit2 , '(A)' ) 'Mag\t30\tCoverage\t100\tDevice\t0\tKV\t288.9\tTiltAngle\t-1\tTiltAxis\t0' write ( dataunit2 , '(A)' ), 'Phases\t1' ! here we need to read the .xtal file and extract the lattice parameters, Laue group and space group numbers write ( dataunit2 , '(A)' ), '3.524;3.524;3.524\t90;90;90\tNickel\t11\t225' ! this is the table header write ( dataunit2 , '(A)' ), 'Phase\tX\tY\tBands\tError\tEuler1\tEuler2\tEuler3\tMAD\tBC\tBS' ! go through the entire array and write one line per sampling point do ii = 1 , ipar ( 3 ) indx = indexmain ( 1 , ii ) euler = eulerarray ( 1 : 3 , indx ) write ( str1 , '(F12.3)' ) float ( MODULO ( ii - 1 , pednl % ipf_wd )) write ( str2 , '(F12.3)' ) float ( floor ( float ( ii - 1 ) / float ( pednl % ipf_wd ))) write ( str3 , '(I2)' ) 10 write ( str4 , '(F12.6)' ) resultmain ( 1 , ii ) write ( str5 , '(F12.3)' ) euler ( 1 ) write ( str6 , '(F12.3)' ) euler ( 2 ) write ( str7 , '(F12.3)' ) euler ( 3 ) write ( str8 , '(I8)' ) indx write ( str9 , '(I3)' ) 255 write ( str10 , '(I3)' ) 255 write ( dataunit2 , '(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)' ) '1' , TAB , trim ( adjustl ( str1 )), TAB ,& trim ( adjustl ( str2 )), TAB , trim ( adjustl ( str3 )), TAB , trim ( adjustl ( str4 )), TAB , trim ( adjustl ( str5 )),& TAB , trim ( adjustl ( str6 )), TAB , trim ( adjustl ( str7 )), TAB , trim ( adjustl ( str8 )), TAB , trim ( adjustl ( str9 )),& TAB , trim ( adjustl ( str10 )) end do close ( dataunit2 , status = 'keep' ) end subroutine ctfped_writeFile","tags":"","loc":"proc/ctfped_writefile.html","title":"ctfped_writeFile – Fortran Program"},{"text":"public recursive subroutine ForwardProjection(ncub, ODF, PFhkl, nLam, PFLam, pgnum) bind(c, name=\"0\") Uses: local constants Lambert rotations error io dictmod typedefs quaternions symmetry iso_c_binding proc~~forwardprojection~~UsesGraph proc~forwardprojection ForwardProjection error error error->proc~forwardprojection iso_c_binding iso_c_binding iso_c_binding->proc~forwardprojection local local local->proc~forwardprojection module~constants constants local->module~constants quaternions quaternions quaternions->proc~forwardprojection io io io->proc~forwardprojection symmetry symmetry symmetry->proc~forwardprojection module~dictmod dictmod module~dictmod->proc~forwardprojection Lambert Lambert Lambert->proc~forwardprojection rotations rotations rotations->proc~forwardprojection typedefs typedefs typedefs->proc~forwardprojection module~constants->proc~forwardprojection Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief forward projection from ODF in cubochoric space to IPF in Lambert space\n @param ODF         orientation distribution function\n @param ncub        number of bins in semi-edge in x,y and z directions\n @param PFhkl       hkl indices of the specific pole figure\n @param nLam        bins in the output along semi-edge in Lambert projection\n @out PFLam         Pole figure in Lambert projection\n @date 11/07/16     SS 1.0 original\n @date 11/10/16     SS 1.1 added symmetry; all integration done in FZ\n @date 12/08/16     SS 1.2 all computations in quaternions to avoid infinity problem Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: ncub real(kind=dbl), intent(in) :: ODF (-ncub:ncub,-ncub:ncub,-ncub:ncub) integer(kind=irg), intent(in) :: PFhkl (3) integer(kind=irg), intent(in) :: nLam real(kind=dbl), intent(out) :: PFLam (-nLam:nLam,-nLam:nLam) integer(kind=irg), intent(in) :: pgnum Calls proc~~forwardprojection~~CallsGraph proc~forwardprojection ForwardProjection float float proc~forwardprojection->float fatalerror fatalerror proc~forwardprojection->fatalerror proc~reduceorientationtorfz ReduceOrientationtoRFZ proc~forwardprojection->proc~reduceorientationtorfz eu2cu eu2cu proc~forwardprojection->eu2cu lambertsquaretosphere lambertsquaretosphere proc~forwardprojection->lambertsquaretosphere ax2qu ax2qu proc~forwardprojection->ax2qu fzoarray fzoarray proc~forwardprojection->fzoarray qu2eu qu2eu proc~forwardprojection->qu2eu quat_mult quat_mult proc~forwardprojection->quat_mult proc~di_init DI_Init proc~forwardprojection->proc~di_init fztarray fztarray proc~forwardprojection->fztarray proc~reduceorientationtorfz->quat_mult proc~isinsidefz IsinsideFZ proc~reduceorientationtorfz->proc~isinsidefz eu2qu eu2qu proc~reduceorientationtorfz->eu2qu qu2ro qu2ro proc~reduceorientationtorfz->qu2ro ro2eu ro2eu proc~reduceorientationtorfz->ro2eu proc~isinsidemfz IsinsideMFZ proc~reduceorientationtorfz->proc~isinsidemfz proc~di_init->fatalerror besselin besselin proc~di_init->besselin besseli1 besseli1 proc~di_init->besseli1 sym_qsymop sym_qsymop proc~di_init->sym_qsymop besseli0 besseli0 proc~di_init->besseli0 pgrot pgrot proc~di_init->pgrot proc~insidecubicfz insideCubicFZ proc~isinsidefz->proc~insidecubicfz proc~insidecubehexfz insideCubeHexFZ proc~isinsidefz->proc~insidecubehexfz proc~insidecyclicfz insideCyclicFZ proc~isinsidefz->proc~insidecyclicfz proc~insidedihedralfz insideDihedralFZ proc~isinsidefz->proc~insidedihedralfz proc~isinsidemfz->proc~insidecyclicfz proc~insidecubicmfz insideCubicMFZ proc~isinsidemfz->proc~insidecubicmfz proc~insidedihedralmfz insideDihedralMFZ proc~isinsidemfz->proc~insidedihedralmfz proc~insidecubicmfz->proc~insidecubicfz proc~insidedihedralmfz->proc~insidedihedralfz var panprocforwardprojectionCallsGraph = svgPanZoom('#procforwardprojectionCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code ForwardProjection Source Code recursive subroutine ForwardProjection ( ncub , ODF , PFhkl , nLam , PFLam , pgnum ) & bind ( c , name = 'ForwardProjection' ) !DEC$ ATTRIBUTES DLLEXPORT :: ForwardProjection use local use constants use Lambert use rotations use error use io use dictmod use typedefs , only : dicttype use quaternions use symmetry , only : CalcFamily use ISO_C_BINDING IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: ncub real ( kind = dbl ), INTENT ( IN ) :: ODF ( - ncub : ncub , - ncub : ncub , - ncub : ncub ) integer ( kind = irg ), INTENT ( IN ) :: PFhkl ( 3 ) integer ( kind = irg ), INTENT ( IN ) :: nLam real ( kind = dbl ), INTENT ( OUT ) :: PFLam ( - nLam : nLam , - nLam : nLam ) integer ( kind = irg ), INTENT ( IN ) :: pgnum real ( kind = dbl ) :: lamx ( - nlam : nlam ), lamy ( - nlam : nlam ) real ( kind = dbl ) :: lam ( 2 ), xyz ( 3 ), hcrossy ( 3 ), PFhkl_f ( 3 ) integer ( kind = irg ) :: ii , jj , kk , ierr , nth real ( kind = dbl ) :: cth , sth , rod ( 4 ), rod2 ( 4 ), r ( 3 ), r2 ( 4 ), cu ( 3 ), eu ( 3 ), eu2 ( 3 ) real ( kind = dbl ) :: qu ( 4 ), qu2 ( 4 ), qures ( 4 ) real ( kind = dbl ), allocatable :: dth (:) integer ( kind = irg ) :: nix , niy , niz , nixp , niyp , nizp real ( kind = dbl ) :: nbx , nby , nbz , dx , dy , dz , dxm , dym , dzm type ( dicttype ), pointer :: dict integer ( kind = irg ) :: Pmdims , FZtype , FZorder !integer(kind=irg),INTENT(OUT)       :: itmp(48,3) ! allocate the dict structure allocate ( dict ) dict % Num_of_init = 3 dict % Num_of_iterations = 30 dict % pgnum = pgnum ! initialize the symmetry matrices call DI_Init ( dict , 'nil' ) Pmdims = dict % Nqsym FZtype = FZtarray ( dict % pgnum ) FZorder = FZoarray ( dict % pgnum ) lamx = ( / ( dble ( ii ) / dble ( nLam ), ii = - nLam , nLam ) / ) lamy = ( / ( dble ( ii ) / dble ( nLam ), ii = - nLam , nLam ) / ) ! only valid for cubic/tetragonal/orthorhombic symmetry ! normalize the input pole figure PFhkl_f = dble ( PFhkl ) PFhkl_f = PFhkl_f / NORM2 ( PFhkl_f ) nth = 101 allocate ( dth ( 1 : nth )) dth = 0.D0 dth = ( / ( 2.D0 * cPi * float ( ii - 1 ) / ( float ( nth - 1 )), ii = 1 , nth ) / ) do ii = - nLam , nLam do jj = - nLam , nLam lam = ( / lamx ( ii ), lamy ( jj ) / ) xyz = LambertSquareToSphere ( lam , ierr ) if ( ierr . eq . 0 ) then xyz = xyz / NORM2 ( xyz ) else call FatalError ( 'LambertSquareToSphere:' , 'Coulnd not convert lambert square to sphere' ) end if !       hcrossy =  PFhkl_f x xyz; !       only valid for cubic/tetragonal/orthorhombic symmetry !       general case will be dealt with later hcrossy = ( / PFhkl_f ( 2 ) * xyz ( 3 ) - PFhkl_f ( 3 ) * xyz ( 2 ),& PFhkl_f ( 3 ) * xyz ( 1 ) - PFhkl_f ( 1 ) * xyz ( 3 ),& PFhkl_f ( 1 ) * xyz ( 2 ) - PFhkl_f ( 2 ) * xyz ( 1 ) / ) if ( sum ( abs ( hcrossy )) . ne . 0 ) hcrossy = hcrossy / NORM2 ( hcrossy ) cth = sum ( PFhkl_f * xyz ) qu = ax2qu (( / hcrossy ( 1 ), hcrossy ( 2 ), hcrossy ( 3 ), acos ( cth ) / )) do kk = 1 , nth qu2 = ax2qu (( / xyz ( 1 ), xyz ( 2 ), xyz ( 3 ), dth ( kk ) / )) qures = quat_mult ( qu2 , qu ) eu = qu2eu ( qures ) call ReduceOrientationtoRFZ ( eu , dict , FZtype , FZorder , eu2 ) cu = eu2cu ( eu2 ) nbx = cu ( 1 ) / LPs % ap * ncub nby = cu ( 2 ) / LPs % ap * ncub nbz = cu ( 3 ) / LPs % ap * ncub nix = floor ( nbx ) niy = floor ( nby ) niz = floor ( nbz ) if ( nix < - ncub ) nix = - ncub if ( niy < - ncub ) niy = - ncub if ( niz < - ncub ) niz = - ncub nixp = nix + 1 niyp = niy + 1 nizp = niz + 1 if ( nixp > ncub ) nixp = ncub if ( niyp > ncub ) niyp = ncub if ( nizp > ncub ) nizp = ncub dx = nbx - nix dy = nby - niy dz = nbz - niz dxm = 1.D0 - dx dym = 1.D0 - dy dzm = 1.D0 - dz ! trilinear interpolation of the ODF PFLam ( ii , jj ) = PFLam ( ii , jj ) + & ( ODF ( nix , niy , niz ) * dxm * dym + ODF ( nixp , niy , niz ) * dx * dym + & ODF ( nix , niyp , niz ) * dxm * dy + ODF ( nixp , niyp , niz ) * dx * dy ) * dzm + & ( ODF ( nix , niy , nizp ) * dxm * dym + ODF ( nixp , niy , nizp ) * dx * dym + & ODF ( nix , niyp , nizp ) * dxm * dy + ODF ( nixp , niyp , nizp ) * dx * dy ) * dz end do end do end do end subroutine ForwardProjection","tags":"","loc":"proc/forwardprojection.html","title":"ForwardProjection – Fortran Program"},{"text":"public recursive subroutine BackProjection(ncub, ODF, PFhkl, nLam, PFLam, pgnum) bind(c, name = \"0\") Uses: local constants Lambert rotations error dictmod typedefs symmetry iso_c_binding proc~~backprojection~~UsesGraph proc~backprojection BackProjection error error error->proc~backprojection iso_c_binding iso_c_binding iso_c_binding->proc~backprojection local local local->proc~backprojection module~constants constants local->module~constants symmetry symmetry symmetry->proc~backprojection module~dictmod dictmod module~dictmod->proc~backprojection Lambert Lambert Lambert->proc~backprojection rotations rotations rotations->proc~backprojection typedefs typedefs typedefs->proc~backprojection module~constants->proc~backprojection Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief back projection from PF in Lambert space to ODF in cubochoric space\n @param ncub     number of bins in semi-edge in x,y and z directions\n @param PFhkl    hkl indices of the specific pole figure\n @param nLam     bins in the output along semi-edge in Lambert projection\n @param PFLam    Pole figure in Lambert projection\n @out ODF        orientation distribution function\n @date 11/07/16  SS 1.0 original\n @date 11/10/16  SS 1.1 added symmetry; all integration done in FZ\n @date 12/08/16  SS 1.2 all computations in quaternion to avoid infinity problem Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: ncub real(kind=dbl), intent(out) :: ODF (-ncub:ncub,-ncub:ncub,-ncub:ncub) integer(kind=irg), intent(in) :: PFhkl (3) integer(kind=irg), intent(in) :: nLam real(kind=dbl), intent(in) :: PFLam (-nLam:nLam,-nLam:nLam) integer(kind=irg), intent(in) :: pgnum Calls proc~~backprojection~~CallsGraph proc~backprojection BackProjection float float proc~backprojection->float fatalerror fatalerror proc~backprojection->fatalerror proc~reduceorientationtorfz ReduceOrientationtoRFZ proc~backprojection->proc~reduceorientationtorfz eu2cu eu2cu proc~backprojection->eu2cu lambertsquaretosphere lambertsquaretosphere proc~backprojection->lambertsquaretosphere ax2qu ax2qu proc~backprojection->ax2qu fzoarray fzoarray proc~backprojection->fzoarray qu2eu qu2eu proc~backprojection->qu2eu quat_mult quat_mult proc~backprojection->quat_mult proc~di_init DI_Init proc~backprojection->proc~di_init fztarray fztarray proc~backprojection->fztarray proc~reduceorientationtorfz->quat_mult proc~isinsidefz IsinsideFZ proc~reduceorientationtorfz->proc~isinsidefz eu2qu eu2qu proc~reduceorientationtorfz->eu2qu qu2ro qu2ro proc~reduceorientationtorfz->qu2ro ro2eu ro2eu proc~reduceorientationtorfz->ro2eu proc~isinsidemfz IsinsideMFZ proc~reduceorientationtorfz->proc~isinsidemfz proc~di_init->fatalerror besselin besselin proc~di_init->besselin besseli1 besseli1 proc~di_init->besseli1 sym_qsymop sym_qsymop proc~di_init->sym_qsymop besseli0 besseli0 proc~di_init->besseli0 pgrot pgrot proc~di_init->pgrot proc~insidecubicfz insideCubicFZ proc~isinsidefz->proc~insidecubicfz proc~insidecubehexfz insideCubeHexFZ proc~isinsidefz->proc~insidecubehexfz proc~insidecyclicfz insideCyclicFZ proc~isinsidefz->proc~insidecyclicfz proc~insidedihedralfz insideDihedralFZ proc~isinsidefz->proc~insidedihedralfz proc~isinsidemfz->proc~insidecyclicfz proc~insidecubicmfz insideCubicMFZ proc~isinsidemfz->proc~insidecubicmfz proc~insidedihedralmfz insideDihedralMFZ proc~isinsidemfz->proc~insidedihedralmfz proc~insidecubicmfz->proc~insidecubicfz proc~insidedihedralmfz->proc~insidedihedralfz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code BackProjection Source Code recursive subroutine BackProjection ( ncub , ODF , PFhkl , nLam , PFLam , pgnum ) & bind ( c , name = 'BackProjection' ) !DEC$ ATTRIBUTES DLLEXPORT :: BackProjection use local use constants use Lambert use rotations use error use dictmod use typedefs , only : dicttype use symmetry , only : CalcFamily use ISO_C_BINDING IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: ncub real ( kind = dbl ), INTENT ( OUT ) :: ODF ( - ncub : ncub , - ncub : ncub , - ncub : ncub ) integer ( kind = irg ), INTENT ( IN ) :: PFhkl ( 3 ) integer ( kind = irg ), INTENT ( IN ) :: nLam real ( kind = dbl ), INTENT ( IN ) :: PFLam ( - nLam : nLam , - nLam : nLam ) integer ( kind = irg ), INTENT ( IN ) :: pgnum real ( kind = dbl ) :: xy ( 2 ), PFhkl_f ( 3 ), xyz ( 3 ), hcrossy ( 3 ) integer ( kind = irg ) :: ii , jj , kk , ll , ierr , nth real ( kind = dbl ) :: cth , sth , rod ( 4 ), rod2 ( 4 ), r ( 3 ), r2 ( 4 ), cu ( 3 ), qu ( 4 ), qu2 ( 4 ), & eu ( 3 ), eu2 ( 3 ), qures ( 4 ) real ( kind = dbl ), allocatable :: dth (:) integer ( kind = irg ) :: nix , niy , niz , nixp , niyp , nizp real ( kind = dbl ) :: nbx , nby , nbz , dx , dy , dz , dxm , dym , dzm , dconst type ( dicttype ), pointer :: dict integer ( kind = irg ) :: Pmdims , FZtype , FZorder ! allocate the dict structure allocate ( dict ) dict % Num_of_init = 3 dict % Num_of_iterations = 30 dict % pgnum = pgnum ! initialize the symmetry matrices call DI_Init ( dict , 'nil' ) Pmdims = dict % Nqsym FZtype = FZtarray ( dict % pgnum ) FZorder = FZoarray ( dict % pgnum ) ! only valid for cubic/tetragonal/orthorhombic symmetry ! normalize the input pole figure PFhkl_f = dble ( PFhkl ) PFhkl_f = PFhkl_f / NORM2 ( PFhkl_f ) nth = 101 allocate ( dth ( 1 : nth )) dth = 0.D0 dth = ( / ( 2.D0 * cPi * float ( ii - 1 ) / ( float ( nth - 1 )), ii = 1 , nth ) / ) dconst = 1.D0 / dble ( nth ) do ii = - nLam , nLam do jj = - nLam , nLam xy = ( / dble ( ii ) / dble ( nLam ), dble ( jj ) / dble ( nLam ) / ) xyz = LambertSquareToSphere ( xy , ierr ) if ( ierr . eq . 0 ) then xyz = xyz / NORM2 ( xyz ) else call FatalError ( 'LambertSquareToSphere:' , 'Coulnd not convert lambert square to sphere' ) end if !       hcrossy =  PFhkl_f x xyz; !       only valid for cubic/tetragonal/orthorhombic symmetry !       general case will be dealt with later hcrossy = ( / PFhkl_f ( 2 ) * xyz ( 3 ) - PFhkl_f ( 3 ) * xyz ( 2 ),& PFhkl_f ( 3 ) * xyz ( 1 ) - PFhkl_f ( 1 ) * xyz ( 3 ),& PFhkl_f ( 1 ) * xyz ( 2 ) - PFhkl_f ( 2 ) * xyz ( 1 ) / ) if ( sum ( abs ( hcrossy )) . ne . 0 ) hcrossy = hcrossy / NORM2 ( hcrossy ) ! rotation by -omega about cross(h,y) cth = sum ( PFhkl_f * xyz ) qu = ax2qu (( / hcrossy ( 1 ), hcrossy ( 2 ), hcrossy ( 3 ), acos ( cth ) / )) do kk = 1 , nth qu2 = ax2qu (( / xyz ( 1 ), xyz ( 2 ), xyz ( 3 ), dth ( kk ) / )) qures = quat_mult ( qu2 , qu ) eu = qu2eu ( qures ) call ReduceOrientationtoRFZ ( eu , dict , FZtype , FZorder , eu2 ) cu = eu2cu ( eu2 ) nbx = cu ( 1 ) / LPs % ap * ncub nby = cu ( 2 ) / LPs % ap * ncub nbz = cu ( 3 ) / LPs % ap * ncub nix = floor ( nbx ) niy = floor ( nby ) niz = floor ( nbz ) if ( nix < - ncub ) nix = - ncub if ( niy < - ncub ) niy = - ncub if ( niz < - ncub ) niz = - ncub nixp = nix + 1 niyp = niy + 1 nizp = niz + 1 if ( nixp > ncub ) nixp = ncub if ( niyp > ncub ) niyp = ncub if ( nizp > ncub ) nizp = ncub dx = nbx - nix dy = nby - niy dz = nbz - niz dxm = 1.D0 - dx dym = 1.D0 - dy dzm = 1.D0 - dz ! assign intensity in ODF according to how close to each cell the resultant orientation is ! sort of like tri-linear interpolation ODF ( nix , niy , niz ) = ODF ( nix , niy , niz ) + PFLam ( ii , jj ) * dxm * dym * dzm * dconst ODF ( nixp , niy , niz ) = ODF ( nixp , niy , niz ) + PFLam ( ii , jj ) * dx * dym * dzm * dconst ODF ( nix , niyp , niz ) = ODF ( nix , niyp , niz ) + PFLam ( ii , jj ) * dxm * dy * dzm * dconst ODF ( nix , niy , nizp ) = ODF ( nix , niy , nizp ) + PFLam ( ii , jj ) * dxm * dym * dz * dconst ODF ( nixp , niyp , niz ) = ODF ( nixp , niyp , niz ) + PFLam ( ii , jj ) * dx * dy * dzm * dconst ODF ( nixp , niy , nizp ) = ODF ( nixp , niy , nizp ) + PFLam ( ii , jj ) * dx * dym * dz * dconst ODF ( nix , niyp , nizp ) = ODF ( nix , niyp , nizp ) + PFLam ( ii , jj ) * dxm * dy * dz * dconst ODF ( nixp , niyp , nizp ) = ODF ( nixp , niyp , nizp ) + PFLam ( ii , jj ) * dx * dy * dz * dconst end do end do end do end subroutine BackProjection","tags":"","loc":"proc/backprojection.html","title":"BackProjection – Fortran Program"},{"text":"public recursive subroutine PGM_Write_File(fname, nx, ny, image) Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: fname integer(kind=irg), intent(in) :: nx integer(kind=irg), intent(in) :: ny integer(kind=irg), intent(in) :: image (nx,ny) Calls proc~~pgm_write_file~~CallsGraph proc~pgm_write_file PGM_Write_File emsoft_tonativepath emsoft_tonativepath proc~pgm_write_file->emsoft_tonativepath message message proc~pgm_write_file->message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code PGM_Write_File Source Code recursive subroutine PGM_Write_File ( fname , nx , ny , image ) !DEC$ ATTRIBUTES DLLEXPORT :: PGM_Write_File character ( fnlen ), INTENT ( IN ) :: fname integer ( kind = irg ), INTENT ( IN ) :: image ( nx , ny ) integer ( kind = irg ), INTENT ( IN ) :: nx , ny integer ( kind = irg ) :: j , stl stl = len ( trim ( fname )) call Message ( 'Creating PGM file : ' // fname ( 1 : stl ), frm = \"(A)\" ) open ( unit = dataunit , file = trim ( EMsoft_toNativePath ( fname )), status = 'unknown' , action = 'write' , form = 'formatted' ) write ( unit = dataunit , fmt = \"(A3)\" ) 'P2 ' write ( unit = dataunit , fmt = \"(A)\" ) '# PGM file generated by EMsoft' write ( unit = dataunit , fmt = \"(I5,I5)\" ) nx , ny write ( unit = dataunit , fmt = \"(I5)\" ) maxval ( image ) do j = ny , 1 , - 1 write ( unit = dataunit , fmt = \"(I3)\" ) image ( 1 : nx , j ) end do close ( unit = dataunit , status = 'keep' ) end subroutine PGM_Write_File","tags":"","loc":"proc/pgm_write_file.html","title":"PGM_Write_File – Fortran Program"},{"text":"public recursive subroutine PoVRay_openFile(dunit, povray_filename, nmlfile) @author Marc De Graef, Carnegie Mellon University\n @brief  add the camera command to the current PoVRay file\n @param dunit output unit number\n @param locationline string that defines the camera position\n @date    09/08/16 MDG 1.0 original\n @date    01/30/17 MDG 1.1 added optional name list file variable Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit character(len=fnlen), intent(in) :: povray_filename character(len=fnlen), intent(in), optional :: nmlfile Calls proc~~povray_openfile~~CallsGraph proc~povray_openfile PoVRay_openFile emsoft_tonativepath emsoft_tonativepath proc~povray_openfile->emsoft_tonativepath Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code PoVRay_openFile Source Code recursive subroutine PoVRay_openFile ( dunit , povray_filename , nmlfile ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_openFile IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit character ( fnlen ), INTENT ( IN ) :: povray_filename character ( fnlen ), INTENT ( IN ), OPTIONAL :: nmlfile character ( fnlen ) :: fname , line , cwd integer ( kind = irg ) :: io open ( unit = dunit , file = trim ( povray_filename ), form = 'formatted' , status = 'unknown' ) write ( dunit , \"(A)\" ) \"//Persistence of Vision Ray Tracer Scene Description File\" write ( dunit , \"(A)\" ) \"//Created by EMsoft package\" ! should we copy the complete namelist file as a comment at this point ? if ( PRESENT ( nmlfile )) then call getcwd ( cwd ) fname = trim ( cwd ) // '/' // trim ( nmlfile ) fname = EMsoft_toNativePath ( fname ) write ( dunit , \"(A)\" ) \"// \" write ( dunit , \"(A)\" ) \"// contents of the namelist used to create this file \" // trim ( fname ) open ( unit = 88 , file = trim ( fname ), status = 'unknown' , form = 'formatted' ) do read ( 88 , \"(A)\" , iostat = io ) line if ( io . eq . 0 ) then write ( dunit , \"(A)\" ) \"// \" // trim ( line ) else EXIT end if end do close ( unit = 88 , status = 'keep' ) write ( dunit , \"(A)\" ) \"// \" end if ! and write the include statements to the file write ( dunit , \"(A)\" ) \"#include \"\"colors.inc\"\"\" write ( dunit , \"(A)\" ) \"#include \"\"textures.inc\"\"\" write ( dunit , \"(A)\" ) \"#include \"\"glass.inc\"\"\" write ( dunit , \"(A)\" ) \"// \" write ( dunit , \"(A)\" ) \"global_settings\" write ( dunit , \"(A)\" ) \"{  ambient_light <1,1,1>\" write ( dunit , \"(A)\" ) \"   assumed_gamma 1\" write ( dunit , \"(A)\" ) \"}\" end subroutine PoVRay_openFile","tags":"","loc":"proc/povray_openfile.html","title":"PoVRay_openFile – Fortran Program"},{"text":"public recursive subroutine PoVRay_setCamera(dunit, locationline, skyline) @author Marc De Graef, Carnegie Mellon University\n @brief  add the camera command to the current PoVRay file\n @param dunit output unit number\n @param locationline string that defines the camera position\n @date    09/08/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit character(len=fnlen), intent(in) :: locationline character(len=fnlen), intent(in), optional :: skyline Source Code PoVRay_setCamera Source Code recursive subroutine PoVRay_setCamera ( dunit , locationline , skyline ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_setCamera IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit character ( fnlen ), INTENT ( IN ) :: locationline character ( fnlen ), INTENT ( IN ), OPTIONAL :: skyline write ( dunit , \"(A)\" ) \" \" write ( dunit , \"(A)\" ) \"camera {\" write ( dunit , \"(A)\" ) \"perspective \" write ( dunit , \"(A)\" ) trim ( locationline ) if ( PRESENT ( skyline )) then write ( dunit , \"(A)\" ) trim ( skyline ) else write ( dunit , \"(A)\" ) \"sky < 0.0, 0.0, 1.0>\" end if write ( dunit , \"(A)\" ) \"right y * 1\" write ( dunit , \"(A)\" ) \"up z\" write ( dunit , \"(A)\" ) \"angle 50\" write ( dunit , \"(A)\" ) \"look_at < 0.0, 0.0, 0.0>\" write ( dunit , \"(A)\" ) \"}\" end subroutine PoVRay_setCamera","tags":"","loc":"proc/povray_setcamera.html","title":"PoVRay_setCamera – Fortran Program"},{"text":"public recursive subroutine PoVRay_setLightSource(dunit, lightline, nobackground) @author Marc De Graef, Carnegie Mellon University\n @brief  add a light command to the current PoVRay file\n @param dunit output unit number\n @param lightline string that defines the camera position\n @date    09/08/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit character(len=fnlen), intent(in) :: lightline logical, intent(in), optional :: nobackground Source Code PoVRay_setLightSource Source Code recursive subroutine PoVRay_setLightSource ( dunit , lightline , nobackground ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_setLightSource IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit character ( fnlen ), INTENT ( IN ) :: lightline logical , OPTIONAL , INTENT ( IN ) :: nobackground write ( dunit , \"(A)\" ) \" \" write ( dunit , \"(A)\" ) \"light_source {\" write ( dunit , \"(A)\" ) trim ( lightline ) write ( dunit , \"(A)\" ) \"color White\" write ( dunit , \"(A)\" ) \"media_interaction on\" write ( dunit , \"(A)\" ) \"media_attenuation on\" write ( dunit , \"(A)\" ) \"shadowless\" write ( dunit , \"(A)\" ) \"}\" if (. not . PRESENT ( nobackground )) then write ( dunit , \"(A)\" ) \"background { color White }\" write ( dunit , \"(A)\" ) \" \" end if end subroutine PoVRay_setLightSource","tags":"","loc":"proc/povray_setlightsource.html","title":"PoVRay_setLightSource – Fortran Program"},{"text":"public recursive subroutine PoVRay_addEulerBox(dunit) @author Marc De Graef, Carnegie Mellon University\n @brief  add a wireframe Euler Box to the current PoVRay file\n @param dunit output unit number\n @param sphereRadius radius of sphere\n @date    11/23/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit Called By proc~~povray_addeulerbox~~CalledByGraph proc~povray_addeulerbox PoVRay_addEulerBox proc~povray_drawfz PoVRay_drawFZ proc~povray_drawfz->proc~povray_addeulerbox Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code PoVRay_addEulerBox Source Code recursive subroutine PoVRay_addEulerBox ( dunit ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_addEulerBox IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit write ( dunit , \"(A)\" ) \"cylinder {<-3.141593,-1.570796,-3.141593>,<-3.141593, 1.570796,-3.141593>, 0.005 pigment {color Green*0.7}}\" write ( dunit , \"(A)\" ) \"cylinder {<-3.141593,-1.570796, 3.141593>,<-3.141593, 1.570796, 3.141593>, 0.005 pigment {color Green*0.7}}\" write ( dunit , \"(A)\" ) \"cylinder {< 3.141593,-1.570796,-3.141593>,< 3.141593, 1.570796,-3.141593>, 0.005 pigment {color Green*0.7}}\" write ( dunit , \"(A)\" ) \"cylinder {< 3.141593,-1.570796, 3.141593>,< 3.141593, 1.570796, 3.141593>, 0.005 pigment {color Green*0.7}}\" write ( dunit , \"(A)\" ) \"cylinder {<-3.141593,-1.570796,-3.141593>,<-3.141593,-1.570796, 3.141593>, 0.005 pigment {color Green*0.7}}\" write ( dunit , \"(A)\" ) \"cylinder {<-3.141593,-1.570796, 3.141593>,< 3.141593,-1.570796, 3.141593>, 0.005 pigment {color Green*0.7}}\" write ( dunit , \"(A)\" ) \"cylinder {< 3.141593,-1.570796, 3.141593>,< 3.141593,-1.570796,-3.141593>, 0.005 pigment {color Green*0.7}}\" write ( dunit , \"(A)\" ) \"cylinder {< 3.141593,-1.570796,-3.141593>,<-3.141593,-1.570796,-3.141593>, 0.005 pigment {color Green*0.7}}\" write ( dunit , \"(A)\" ) \"cylinder {<-3.141593, 1.570796,-3.141593>,<-3.141593, 1.570796, 3.141593>, 0.005 pigment {color Green*0.7}}\" write ( dunit , \"(A)\" ) \"cylinder {<-3.141593, 1.570796, 3.141593>,< 3.141593, 1.570796, 3.141593>, 0.005 pigment {color Green*0.7}}\" write ( dunit , \"(A)\" ) \"cylinder {< 3.141593, 1.570796, 3.141593>,< 3.141593, 1.570796,-3.141593>, 0.005 pigment {color Green*0.7}}\" write ( dunit , \"(A)\" ) \"cylinder {< 3.141593, 1.570796,-3.141593>,<-3.141593, 1.570796,-3.141593>, 0.005 pigment {color Green*0.7}}\" end subroutine PoVRay_addEulerBox","tags":"","loc":"proc/povray_addeulerbox.html","title":"PoVRay_addEulerBox – Fortran Program"},{"text":"public recursive subroutine PoVRay_declare_DF3file(dunit, df3name, levelset) @author Marc De Graef, Carnegie Mellon University\n @brief set up the code to include a 3D density field (df3) file\n @param dunit output unit number\n @param df3 file name\n @param levelset if TRUE, then different colors are used for level contours\n @date    11/23/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit character(len=fnlen), intent(in) :: df3name logical, intent(in), optional :: levelset Source Code PoVRay_declare_DF3file Source Code recursive subroutine PoVRay_declare_DF3file ( dunit , df3name , levelset ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_declare_DF3file IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit character ( fnlen ), INTENT ( IN ) :: df3name logical , OPTIONAL , INTENT ( IN ) :: levelset logical :: levels write ( dunit , \"(A)\" ) '' write ( dunit , \"(A)\" ) '#declare DENS = interior' write ( dunit , \"(A)\" ) '  {  media' write ( dunit , \"(A)\" ) '    {  intervals 100                   // number of ray-intervals' write ( dunit , \"(A)\" ) '      ratio 0.5' write ( dunit , \"(A)\" ) '      samples 4,4                     // maximum,minimum of samples per voxel' write ( dunit , \"(A)\" ) '      method 2                        // 1, 2 or 3 (3 requires samples 3,3)' write ( dunit , \"(A)\" ) '      emission 20*<1,1,1>' write ( dunit , \"(A)\" ) '      absorption <1,1,1>' write ( dunit , \"(A)\" ) '      scattering { 1, <0,0,0> }' write ( dunit , \"(A)\" ) '      confidence 0.9                // default: 0.9' write ( dunit , \"(A)\" ) '      variance 1/100                // default: 1/128' write ( dunit , \"(A)\" ) '      density' write ( dunit , \"('      {  density_file df3 \"\"',A,'\"\"')\" ) trim ( df3name ) write ( dunit , \"(A)\" ) '        interpolate 1' write ( dunit , \"(A)\" ) '        color_map                    // colour map with (smooth) linear transition(s)' levels = . FALSE . if ( PRESENT ( levelset )) then if ( levelset . eqv .. TRUE .) then levels = . TRUE . end if end if if ( levels . eqv .. TRUE .) then write ( dunit , \"(A)\" ) '        {  [0.0 rgb <0.0,0.0,0.0>] ' write ( dunit , \"(A)\" ) '           [0.1 rgb <0.6,0.0,0.0>]' write ( dunit , \"(A)\" ) '           [0.2 rgb <0.0,0.6,0.0>]' write ( dunit , \"(A)\" ) '           [0.4 rgb <0.2,0.3,0.8>]' write ( dunit , \"(A)\" ) '           [0.6 rgb <0.6,0.5,0.8>]' write ( dunit , \"(A)\" ) '           [1.0 rgb <1.0,1.0,1.0>]' else write ( dunit , \"(A)\" ) '        {  [0.1 rgb <0.0,0.0,0.0>] ' write ( dunit , \"(A)\" ) '           [0.2 rgb <0.5,0.0,0.0>]' write ( dunit , \"(A)\" ) '           [0.3 rgb <1.0,0.0,0.0>]' write ( dunit , \"(A)\" ) '           [0.4 rgb <1.0,0.3,0.0>]' write ( dunit , \"(A)\" ) '           [0.5 rgb <1.0,0.6,0.0>]' write ( dunit , \"(A)\" ) '           [0.6 rgb <1.0,1.0,0.0>]' write ( dunit , \"(A)\" ) '           [0.7 rgb <1.0,1.0,0.3>]' write ( dunit , \"(A)\" ) '           [0.8 rgb <1.0,1.0,0.6>]' write ( dunit , \"(A)\" ) '           [0.9 rgb <1.0,1.0,1.0>]' end if write ( dunit , \"(A)\" ) '        }' write ( dunit , \"(A)\" ) '      }' write ( dunit , \"(A)\" ) '    }' write ( dunit , \"(A)\" ) '  }' write ( dunit , \"(A)\" ) '' write ( dunit , \"(A)\" ) '#declare renderbox = box' write ( dunit , \"(A)\" ) '  {  <0,0,0>, <1,1,1>' write ( dunit , \"(A)\" ) '     pigment { rgbt <0,0,0,1> }' write ( dunit , \"(A)\" ) '     hollow' write ( dunit , \"(A)\" ) '     interior { DENS }' write ( dunit , \"(A)\" ) '  }' end subroutine PoVRay_declare_DF3file","tags":"","loc":"proc/povray_declare_df3file.html","title":"PoVRay_declare_DF3file – Fortran Program"},{"text":"public recursive subroutine PoVRay_write_DF3file(dunit, df3name, volume, ndims, scalingmode) @author Marc De Graef, Carnegie Mellon University\n @brief set up the code to include a 3D density field (df3) file\n @param dunit output unit number\n @param df3 file name\n @param volume the volume array to be written to the file\n @param ndims dimensions of the volume array\n @param scalingmode  'lin' or 'log' or 'lev'\n @date    11/23/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit character(len=fnlen), intent(in) :: df3name real(kind=sgl), intent(inout) :: volume (-ndims(1):ndims(1),-ndims(2):ndims(2),-ndims(3):ndims(3)) integer(kind=irg), intent(in) :: ndims (3) character(len=3), intent(in) :: scalingmode Calls proc~~povray_write_df3file~~CallsGraph proc~povray_write_df3file PoVRay_write_DF3file alog10 alog10 proc~povray_write_df3file->alog10 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code PoVRay_write_DF3file Source Code recursive subroutine PoVRay_write_DF3file ( dunit , df3name , volume , ndims , scalingmode ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_write_DF3file IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit character ( fnlen ), INTENT ( IN ) :: df3name integer ( kind = irg ), INTENT ( IN ) :: ndims ( 3 ) real ( kind = sgl ), INTENT ( INOUT ) :: volume ( - ndims ( 1 ): ndims ( 1 ), - ndims ( 2 ): ndims ( 2 ), - ndims ( 3 ): ndims ( 3 )) character ( 3 ), INTENT ( IN ) :: scalingmode integer ( kind = ish ) :: ivol ( - ndims ( 1 ): ndims ( 1 ), - ndims ( 2 ): ndims ( 2 ), - ndims ( 3 ): ndims ( 3 )) integer ( kind = ish ) :: idims ( 3 ), mval real ( kind = sgl ) :: mi , ma , levels ( 6 ) integer ( kind = irg ) :: recno , i , j , k ! This format is described on the following web pages: ! http://wwwmpa.mpa-garching.mpg.de/~mselig/povray/povray.html ! http://www.povray.org/documentation/view/3.6.1/374/ ! ! Essentially, this is a binary file with first 3 2-byte integers ! with the array dimensions, and then the array itself as 4-byte integers. ! Note that this file *must* be written in big-endian format (most significant ! byte first).  This can be achieved by using the CONVERT='BIG_ENDIAN' qualifier ! when the file is opened. ! we will write this as a file of 16 bit integers, so we need to rescale them all ! to the correct range mval = int ( 2 ** 15 - 1 , kind = ish ) if (( scalingmode . eq . 'log' ). or .( scalingmode . eq . 'lev' )) volume = alog10 ( volume + 1.0 ) mi = minval ( volume ) ma = maxval ( volume ) volume = ( volume - mi ) / ( ma - mi ) write ( * , * ) 'volume range ' , mi , ma if ( scalingmode . eq . 'lev' ) then ! we discretize the logarithmic values into bins (levels) which are then displayed ! as nested contour surfaces (ideally) by PoVRay's Density_field routine... ! Since we are testing this capability, we'll only include 5 different contour levels ! for now; this can be modified later on... levels = ( / 0.0 , 0.4 , 0.6 , 0.8 , 0.9 , 1.0 / ) ! levels = (/ 0.1, 0.2, 0.4, 0.6, 0.8, 1.0 /) do i = 2 , 6 where (( volume . ge . levels ( i - 1 )). and .( volume . lt . levels ( i ))) volume = levels ( i - 1 ) end do endif volume = volume * mval ivol = int ( volume , kind = ish ) ! open the file and write the rescaled integer data open ( unit = dunit , file = trim ( df3name ), status = 'unknown' , access = \"DIRECT\" , action = \"WRITE\" , & recl = 2 , form = 'unformatted' , convert = 'big_endian' ) idims = 2 * ndims + 1 recno = 1 do i = 1 , 3 write ( dunit , rec = recno ) idims ( i ) recno = recno + 1 end do do k =- ndims ( 3 ), ndims ( 3 ) do j =- ndims ( 2 ), ndims ( 2 ) do i =- ndims ( 1 ), ndims ( 1 ) write ( dunit , rec = recno ) ivol ( i , j , k ) recno = recno + 1 end do end do end do close ( dunit , status = 'keep' ) end subroutine PoVRay_write_DF3file","tags":"","loc":"proc/povray_write_df3file.html","title":"PoVRay_write_DF3file – Fortran Program"},{"text":"public recursive subroutine PoVRay_addWireFrameSphere(dunit, sphereRadius) @author Marc De Graef, Carnegie Mellon University\n @brief  add a wireframe sphere to the current PoVRay file\n @param dunit output unit number\n @param sphereRadius radius of sphere\n @date    09/08/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit real(kind=dbl), intent(in) :: sphereRadius Called By proc~~povray_addwireframesphere~~CalledByGraph proc~povray_addwireframesphere PoVRay_addWireFrameSphere proc~povray_initfz6 PoVRay_initFZ6 proc~povray_initfz6->proc~povray_addwireframesphere proc~povray_initfz3 PoVRay_initFZ3 proc~povray_initfz3->proc~povray_addwireframesphere proc~povray_initfz4 PoVRay_initFZ4 proc~povray_initfz4->proc~povray_addwireframesphere proc~povray_drawfz PoVRay_drawFZ proc~povray_drawfz->proc~povray_addwireframesphere proc~povray_initfz2 PoVRay_initFZ2 proc~povray_initfz2->proc~povray_addwireframesphere Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code PoVRay_addWireFrameSphere Source Code recursive subroutine PoVRay_addWireFrameSphere ( dunit , sphereRadius ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_addWireFrameSphere IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit real ( kind = dbl ), INTENT ( IN ) :: sphereRadius character ( 12 ) :: px write ( dunit , \"(A)\" ) \"#macro WireFrameSphere(NrLongitudes, NrLatitudes, Rmaj, Rmin)\" write ( dunit , \"(A)\" ) \"\" write ( dunit , \"(A)\" ) \"  #local dLongitude = 360/NrLongitudes;\" write ( dunit , \"(A)\" ) \"  #local dLatitude = 180/NrLatitudes;\" write ( dunit , \"(A)\" ) \"  #local Cnt = 0;\" write ( dunit , \"(A)\" ) \"  #while (Cnt < NrLongitudes)\" write ( dunit , \"(A)\" ) \"    #local Longitude = Cnt*dLongitude;\" write ( dunit , \"(A)\" ) \"    difference {\" write ( dunit , \"(A)\" ) \"      torus { Rmaj, Rmin }\" write ( dunit , \"(A)\" ) \"      plane { -z, 0 }\" write ( dunit , \"(A)\" ) \"      rotate -90*z\" write ( dunit , \"(A)\" ) \"      rotate Longitude*y\" write ( dunit , \"(A)\" ) \"    }\" write ( dunit , \"(A)\" ) \"    #local Cnt = Cnt + 1;\" write ( dunit , \"(A)\" ) \"  #end // while\" write ( dunit , \"(A)\" ) \"\" write ( dunit , \"(A)\" ) \"  #local Cnt = 1;\" write ( dunit , \"(A)\" ) \"  #while (Cnt < NrLatitudes)\" write ( dunit , \"(A)\" ) \"    #local Latitude = radians(Cnt*dLatitude - 90);\" write ( dunit , \"(A)\" ) \"    torus {\" write ( dunit , \"(A)\" ) \"      Rmaj*cos(Latitude), Rmin\" write ( dunit , \"(A)\" ) \"      translate Rmaj*sin(Latitude)*y\" write ( dunit , \"(A)\" ) \"    }\" write ( dunit , \"(A)\" ) \"    #local Cnt = Cnt + 1;\" write ( dunit , \"(A)\" ) \"  #end // while\" write ( dunit , \"(A)\" ) \"\" write ( dunit , \"(A)\" ) \"#end // macro WireFrameSphere\" write ( dunit , \"(A)\" ) \"\" write ( px , \"(F12.6)\" ) sphereRadius write ( dunit , \"(A)\" ) \"#declare Rglobe = \" // px // \";\" write ( dunit , \"(A)\" ) \"#declare Rwireframe = 0.0033;\" write ( dunit , \"(A)\" ) \"#declare Rspheres = Rwireframe*2;\" write ( dunit , \"(A)\" ) \"\" write ( dunit , \"(A)\" ) \"// Number of longitude intervals\" write ( dunit , \"(A)\" ) \"#declare Longitudes = 12;\" write ( dunit , \"(A)\" ) \"\" write ( dunit , \"(A)\" ) \"// Number of latitude intervals\" write ( dunit , \"(A)\" ) \"#declare Latitudes = 6;\" write ( dunit , \"(A)\" ) \"\" write ( dunit , \"(A)\" ) \"\" write ( dunit , \"(A)\" ) \"union {\" write ( dunit , \"(A)\" ) \"  WireFrameSphere(Longitudes, Latitudes, Rglobe, Rwireframe)\" write ( dunit , \"(A)\" ) \"  rotate 90.0*x\" write ( dunit , \"(A)\" ) \"  pigment { color Black*0.7 }\" write ( dunit , \"(A)\" ) \"}\" end subroutine PoVRay_addWireFrameSphere","tags":"","loc":"proc/povray_addwireframesphere.html","title":"PoVRay_addWireFrameSphere – Fortran Program"},{"text":"public recursive subroutine PoVRay_addReferenceFrame(dunit, ac, cylr) @author Marc De Graef, Carnegie Mellon University\n @brief  add a reference frame to the current PoVRay file\n @param dunit output unit number\n @param ac maximum semi-length of axis\n @date    09/08/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit real(kind=dbl), intent(in) :: ac real(kind=dbl), intent(in), optional :: cylr Called By proc~~povray_addreferenceframe~~CalledByGraph proc~povray_addreferenceframe PoVRay_addReferenceFrame proc~povray_initfz6 PoVRay_initFZ6 proc~povray_initfz6->proc~povray_addreferenceframe proc~povray_initfz3 PoVRay_initFZ3 proc~povray_initfz3->proc~povray_addreferenceframe proc~povray_initfz4 PoVRay_initFZ4 proc~povray_initfz4->proc~povray_addreferenceframe proc~povray_drawfz PoVRay_drawFZ proc~povray_drawfz->proc~povray_addreferenceframe proc~povray_initfz2 PoVRay_initFZ2 proc~povray_initfz2->proc~povray_addreferenceframe Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code PoVRay_addReferenceFrame Source Code recursive subroutine PoVRay_addReferenceFrame ( dunit , ac , cylr ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_addReferenceFrame IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit real ( kind = dbl ), INTENT ( IN ) :: ac real ( kind = dbl ), OPTIONAL , INTENT ( IN ) :: cylr real ( kind = dbl ) :: cc if ( present ( cylr ). eqv .. TRUE .) then cc = cylr else cc = 0.005D0 end if write ( dunit , \"('cylinder { <',2(F9.6,','),F9.6,'>,<',2(F9.6,','),F9.6,'>,',F9.6,' pigment { color Red*0.7 } }')\" ) & - ac , 0.0 , 0.0 , ac , 0.0 , 0.0 , cc write ( dunit , \"('cylinder { <',2(F9.6,','),F9.6,'>,<',2(F9.6,','),F9.6,'>,',F9.6,' pigment { color Green*0.7 } }')\" ) & 0.0 , - ac , 0.0 , 0.0 , ac , 0.0 , cc write ( dunit , \"('cylinder { <',2(F9.6,','),F9.6,'>,<',2(F9.6,','),F9.6,'>,',F9.6,' pigment { color Blue*0.7 } }')\" ) & 0.0 , 0.0 , - ac , 0.0 , 0.0 , ac , cc end subroutine PoVRay_addReferenceFrame","tags":"","loc":"proc/povray_addreferenceframe.html","title":"PoVRay_addReferenceFrame – Fortran Program"},{"text":"public recursive subroutine PoVRay_addSphere(dunit, ctr, radius, rgb) @author Marc De Graef, Carnegie Mellon University\n @brief  add a sphere to the current PoVRay file\n @param dunit output unit number\n @param ctr center coordinates of the sphere\n @param radius sphere radius\n @param rgb color triplet (RGB)\n @date    09/08/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit real(kind=dbl), intent(in) :: ctr (3) real(kind=dbl), intent(in) :: radius real(kind=sgl), intent(in) :: rgb (3) Source Code PoVRay_addSphere Source Code recursive subroutine PoVRay_addSphere ( dunit , ctr , radius , rgb ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_addSphere IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit real ( kind = dbl ), INTENT ( IN ) :: ctr ( 3 ) real ( kind = dbl ), INTENT ( IN ) :: radius real ( kind = sgl ), INTENT ( IN ) :: rgb ( 3 ) write ( dataunit , \"('sphere { <',2(F9.6,','),F9.6,'>,',F9.6,'  pigment { rgb <', & 2(F9.6,','),F9.6,'>}}')\" ), ctr ( 1 : 3 ), radius , rgb ( 1 : 3 ) end subroutine PoVRay_addSphere","tags":"","loc":"proc/povray_addsphere.html","title":"PoVRay_addSphere – Fortran Program"},{"text":"public recursive subroutine PoVRay_addCylinder(dunit, p1, p2, radius, rgb) @author Marc De Graef, Carnegie Mellon University\n @brief  add a cylinder to the current PoVRay file\n @param dunit output unit number\n @param p1 starting point of cylinder (on axis)\n @param p2 end point of cylinder (on axis)\n @param radius cylinder radius\n @param rgb color triplet (RGB)\n @date    09/08/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit real(kind=dbl), intent(in) :: p1 (3) real(kind=dbl), intent(in) :: p2 (3) real(kind=dbl), intent(in) :: radius real(kind=sgl), intent(in) :: rgb (3) Called By proc~~povray_addcylinder~~CalledByGraph proc~povray_addcylinder PoVRay_addCylinder proc~povray_initfz4 PoVRay_initFZ4 proc~povray_initfz4->proc~povray_addcylinder proc~povray_addcubochoriccube PoVRay_addCubochoricCube proc~povray_initfz4->proc~povray_addcubochoriccube proc~povray_initfz6 PoVRay_initFZ6 proc~povray_initfz6->proc~povray_addcylinder proc~povray_initfz6->proc~povray_addcubochoriccube proc~povray_drawfz PoVRay_drawFZ proc~povray_drawfz->proc~povray_addcylinder proc~povray_drawfz->proc~povray_addcubochoriccube proc~povray_initfz2 PoVRay_initFZ2 proc~povray_initfz2->proc~povray_addcylinder proc~povray_initfz2->proc~povray_addcubochoriccube proc~povray_initfz3 PoVRay_initFZ3 proc~povray_initfz3->proc~povray_addcylinder proc~povray_initfz3->proc~povray_addcubochoriccube proc~povray_addcubochoriccube->proc~povray_addcylinder Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code PoVRay_addCylinder Source Code recursive subroutine PoVRay_addCylinder ( dunit , p1 , p2 , radius , rgb ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_addCylinder IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit real ( kind = dbl ), INTENT ( IN ) :: p1 ( 3 ), p2 ( 3 ) real ( kind = dbl ), INTENT ( IN ) :: radius real ( kind = sgl ), INTENT ( IN ) :: rgb ( 3 ) write ( dunit , \"('cylinder { <',2(F9.6,','),F9.6,'>,<',2(F9.6,','),F9.6,'>,', F9.6,' pigment { ', & 'rgb <',2(F9.6,','),F9.6,'>}}')\" ), p1 ( 1 : 3 ), p2 ( 1 : 3 ), radius , rgb ( 1 : 3 ) end subroutine PoVRay_addCylinder","tags":"","loc":"proc/povray_addcylinder.html","title":"PoVRay_addCylinder – Fortran Program"},{"text":"public recursive subroutine PoVRay_addCubochoricCube(dunit) @author Marc De Graef, Carnegie Mellon University\n @brief  add a reference frame to the current PoVRay file\n @param dunit output unit number\n @date    09/08/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit Calls proc~~povray_addcubochoriccube~~CallsGraph proc~povray_addcubochoriccube PoVRay_addCubochoricCube proc~povray_addcylinder PoVRay_addCylinder proc~povray_addcubochoriccube->proc~povray_addcylinder Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~povray_addcubochoriccube~~CalledByGraph proc~povray_addcubochoriccube PoVRay_addCubochoricCube proc~povray_initfz6 PoVRay_initFZ6 proc~povray_initfz6->proc~povray_addcubochoriccube proc~povray_initfz3 PoVRay_initFZ3 proc~povray_initfz3->proc~povray_addcubochoriccube proc~povray_initfz4 PoVRay_initFZ4 proc~povray_initfz4->proc~povray_addcubochoriccube proc~povray_drawfz PoVRay_drawFZ proc~povray_drawfz->proc~povray_addcubochoriccube proc~povray_initfz2 PoVRay_initFZ2 proc~povray_initfz2->proc~povray_addcubochoriccube Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code PoVRay_addCubochoricCube Source Code recursive subroutine PoVRay_addCubochoricCube ( dunit ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_addCubochoricCube IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit real ( kind = dbl ) :: ac ! create the cubochoric cube ac = 0.5 * LPs % ap call PoVRay_addCylinder ( dunit ,( / - ac , ac , ac / ), ( / ac , ac , ac / ), 0.005D0 , ( / 0.7 , 0.7 , 0.7 / )) call PoVRay_addCylinder ( dunit ,( / - ac , ac , - ac / ), ( / ac , ac , - ac / ), 0.005D0 , ( / 0.7 , 0.7 , 0.7 / )) call PoVRay_addCylinder ( dunit ,( / - ac , - ac , ac / ), ( / ac , - ac , ac / ), 0.005D0 , ( / 0.7 , 0.7 , 0.7 / )) call PoVRay_addCylinder ( dunit ,( / - ac , - ac , - ac / ), ( / ac , - ac , - ac / ), 0.005D0 , ( / 0.7 , 0.7 , 0.7 / )) call PoVRay_addCylinder ( dunit ,( / ac , - ac , ac / ), ( / ac , ac , ac / ), 0.005D0 , ( / 0.7 , 0.7 , 0.7 / )) call PoVRay_addCylinder ( dunit ,( / - ac , - ac , ac / ), ( /- ac , ac , ac / ), 0.005D0 , ( / 0.7 , 0.7 , 0.7 / )) call PoVRay_addCylinder ( dunit ,( / ac , - ac , - ac / ), ( / ac , ac , - ac / ), 0.005D0 , ( / 0.7 , 0.7 , 0.7 / )) call PoVRay_addCylinder ( dunit ,( / - ac , - ac , - ac / ), ( /- ac , ac , - ac / ), 0.005D0 , ( / 0.7 , 0.7 , 0.7 / )) call PoVRay_addCylinder ( dunit ,( / ac , ac , - ac / ), ( / ac , ac , ac / ), 0.005D0 , ( / 0.7 , 0.7 , 0.7 / )) call PoVRay_addCylinder ( dunit ,( / - ac , ac , - ac / ), ( /- ac , ac , ac / ), 0.005D0 , ( / 0.7 , 0.7 , 0.7 / )) call PoVRay_addCylinder ( dunit ,( / ac , - ac , - ac / ), ( / ac , - ac , ac / ), 0.005D0 , ( / 0.7 , 0.7 , 0.7 / )) call PoVRay_addCylinder ( dunit ,( / - ac , - ac , - ac / ), ( /- ac , - ac , ac / ), 0.005D0 , ( / 0.7 , 0.7 , 0.7 / )) end subroutine PoVRay_addCubochoricCube","tags":"","loc":"proc/povray_addcubochoriccube.html","title":"PoVRay_addCubochoricCube – Fortran Program"},{"text":"public recursive subroutine PoVRay_getpos_FZ432(dims, cpos, s_edge, t_edge, ns, d, nt, MFZ) @author Marc De Graef, Carnegie Mellon University\n @brief initialize the PoVRay output for rotational group 432\n @param dims dimensions for subsequent arrays\n @param cpos vertex coordinates\n @param s_edge first set of edge connectivities\n @param t_edge second set of edge connectivities\n @param ns, d, nt  auxiliary parameters\n @param MFZ (optional) return coordinates for Mackenzie FZ instead of regular FZ\n @date    09/10/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dims (3) real(kind=dbl), intent(inout) :: cpos (3,dims(1)) integer(kind=irg), intent(inout) :: s_edge (2,dims(2)) integer(kind=irg), intent(inout) :: t_edge (2,dims(3)) integer(kind=irg), intent(out) :: ns real(kind=dbl), intent(out) :: d integer(kind=irg), intent(out) :: nt logical, intent(in), optional :: MFZ Called By proc~~povray_getpos_fz432~~CalledByGraph proc~povray_getpos_fz432 PoVRay_getpos_FZ432 proc~povray_drawfz PoVRay_drawFZ proc~povray_drawfz->proc~povray_getpos_fz432 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code PoVRay_getpos_FZ432 Source Code recursive subroutine PoVRay_getpos_FZ432 ( dims , cpos , s_edge , t_edge , ns , d , nt , MFZ ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_getpos_FZ432 IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dims ( 3 ) real ( kind = dbl ), INTENT ( INOUT ) :: cpos ( 3 , dims ( 1 )) integer ( kind = irg ), INTENT ( INOUT ) :: s_edge ( 2 , dims ( 2 )) integer ( kind = irg ), INTENT ( INOUT ) :: t_edge ( 2 , dims ( 3 )) integer ( kind = irg ), INTENT ( OUT ) :: ns real ( kind = dbl ), INTENT ( OUT ) :: d integer ( kind = irg ), INTENT ( OUT ) :: nt logical , OPTIONAL , INTENT ( IN ) :: MFZ real ( kind = dbl ) :: a = 0.41421356237D0 , c = 0.17157287525D0 , dt = 0.34314575050D0 , ds = 0.6340506711D0 , & dd , e = 0.29289323D0 , f = 0.333333333D0 d = 0.610395774912 if ( present ( MFZ )) then if ( MFZ ) then ! define the coordinates of the cubic Mackenzie FZ in Rodrigues Space cpos ( 1 : 3 , 1 ) = ( / 0.D0 , 0.D0 , 0.D0 / ) cpos ( 1 : 3 , 2 ) = ( / a , 0.D0 , 0.D0 / ) cpos ( 1 : 3 , 3 ) = ( / a , a , 0.D0 / ) cpos ( 1 : 3 , 4 ) = ( / a , a , c / ) cpos ( 1 : 3 , 5 ) = ( / f , f , f / ) cpos ( 1 : 3 , 6 ) = ( / a , e , e / ) cpos = cpos / d ns = 200 nt = nint ( ns * dt / ds ) ! define the connectivity of all the edges s_edge ( 1 : 2 , 1 ) = ( / 1 , 2 / ) s_edge ( 1 : 2 , 2 ) = ( / 1 , 3 / ) s_edge ( 1 : 2 , 3 ) = ( / 1 , 5 / ) s_edge ( 1 : 2 , 4 ) = ( / 2 , 3 / ) s_edge ( 1 : 2 , 5 ) = ( / 2 , 6 / ) s_edge ( 1 : 2 , 6 ) = ( / 3 , 4 / ) s_edge ( 1 : 2 , 7 ) = ( / 4 , 5 / ) s_edge ( 1 : 2 , 8 ) = ( / 4 , 6 / ) s_edge ( 1 : 2 , 9 ) = ( / 5 , 6 / ) end if ! define the coordinates of the cubic FZ in Rodrigues Space else cpos ( 1 : 3 , 1 ) = ( / a , a , c / ) cpos ( 1 : 3 , 2 ) = ( / c , a , a / ) cpos ( 1 : 3 , 3 ) = ( / a , c , a / ) cpos ( 1 : 3 , 4 ) = ( / - a , a , c / ) cpos ( 1 : 3 , 5 ) = ( / - c , a , a / ) cpos ( 1 : 3 , 6 ) = ( / - a , c , a / ) cpos ( 1 : 3 , 7 ) = ( / - a , - a , c / ) cpos ( 1 : 3 , 8 ) = ( / - c , - a , a / ) cpos ( 1 : 3 , 9 ) = ( / - a , - c , a / ) cpos ( 1 : 3 , 10 ) = ( / a , - a , c / ) cpos ( 1 : 3 , 11 ) = ( / c , - a , a / ) cpos ( 1 : 3 , 12 ) = ( / a , - c , a / ) cpos ( 1 : 3 , 13 ) = ( / a , a , - c / ) cpos ( 1 : 3 , 14 ) = ( / a , c , - a / ) cpos ( 1 : 3 , 15 ) = ( / c , a , - a / ) cpos ( 1 : 3 , 16 ) = ( / - a , a , - c / ) cpos ( 1 : 3 , 17 ) = ( / - a , c , - a / ) cpos ( 1 : 3 , 18 ) = ( / - c , a , - a / ) cpos ( 1 : 3 , 19 ) = ( / - a , - a , - c / ) cpos ( 1 : 3 , 20 ) = ( / - a , - c , - a / ) cpos ( 1 : 3 , 21 ) = ( / - c , - a , - a / ) cpos ( 1 : 3 , 22 ) = ( / a , - a , - c / ) cpos ( 1 : 3 , 23 ) = ( / a , - c , - a / ) cpos ( 1 : 3 , 24 ) = ( / c , - a , - a / ) cpos = cpos / d ns = 200 nt = nint ( ns * dt / ds ) ! define the connectivity of all the edges s_edge ( 1 : 2 , 1 ) = ( / 3 , 12 / ) s_edge ( 1 : 2 , 2 ) = ( / 10 , 22 / ) s_edge ( 1 : 2 , 3 ) = ( / 14 , 23 / ) s_edge ( 1 : 2 , 4 ) = ( / 1 , 13 / ) s_edge ( 1 : 2 , 5 ) = ( / 2 , 5 / ) s_edge ( 1 : 2 , 6 ) = ( / 8 , 11 / ) s_edge ( 1 : 2 , 7 ) = ( / 21 , 24 / ) s_edge ( 1 : 2 , 8 ) = ( / 15 , 18 / ) s_edge ( 1 : 2 , 9 ) = ( / 6 , 9 / ) s_edge ( 1 : 2 , 10 ) = ( / 7 , 19 / ) s_edge ( 1 : 2 , 11 ) = ( / 17 , 20 / ) s_edge ( 1 : 2 , 12 ) = ( / 4 , 16 / ) t_edge ( 1 : 2 , 1 ) = ( / 1 , 2 / ) t_edge ( 1 : 2 , 2 ) = ( / 2 , 3 / ) t_edge ( 1 : 2 , 3 ) = ( / 3 , 1 / ) t_edge ( 1 : 2 , 4 ) = ( / 4 , 5 / ) t_edge ( 1 : 2 , 5 ) = ( / 5 , 6 / ) t_edge ( 1 : 2 , 6 ) = ( / 6 , 4 / ) t_edge ( 1 : 2 , 7 ) = ( / 7 , 8 / ) t_edge ( 1 : 2 , 8 ) = ( / 8 , 9 / ) t_edge ( 1 : 2 , 9 ) = ( / 9 , 7 / ) t_edge ( 1 : 2 , 10 ) = ( / 10 , 11 / ) t_edge ( 1 : 2 , 11 ) = ( / 11 , 12 / ) t_edge ( 1 : 2 , 12 ) = ( / 12 , 10 / ) t_edge ( 1 : 2 , 13 ) = ( / 13 , 14 / ) t_edge ( 1 : 2 , 14 ) = ( / 14 , 15 / ) t_edge ( 1 : 2 , 15 ) = ( / 15 , 13 / ) t_edge ( 1 : 2 , 16 ) = ( / 16 , 17 / ) t_edge ( 1 : 2 , 17 ) = ( / 17 , 18 / ) t_edge ( 1 : 2 , 18 ) = ( / 18 , 16 / ) t_edge ( 1 : 2 , 19 ) = ( / 19 , 20 / ) t_edge ( 1 : 2 , 20 ) = ( / 20 , 21 / ) t_edge ( 1 : 2 , 21 ) = ( / 21 , 19 / ) t_edge ( 1 : 2 , 22 ) = ( / 22 , 23 / ) t_edge ( 1 : 2 , 23 ) = ( / 23 , 24 / ) t_edge ( 1 : 2 , 24 ) = ( / 24 , 22 / ) end if end subroutine PoVRay_getpos_FZ432","tags":"","loc":"proc/povray_getpos_fz432.html","title":"PoVRay_getpos_FZ432 – Fortran Program"},{"text":"public recursive subroutine PoVRay_getpos_FZ23(dims, cpos, s_edge, t_edge, ns, d, nt, MFZ) @author Marc De Graef, Carnegie Mellon University\n @brief initialize the PoVRay output for rotational group 23\n @param dims dimensions for subsequent arrays\n @param cpos vertex coordinates\n @param s_edge first set of edge connectivities\n @param t_edge second set of edge connectivities\n @param ns, d, nt  auxiliary parameters\n @param MFZ (optional) return coordinates for Mackenzie FZ instead of regular FZ\n @date    09/10/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dims (3) real(kind=dbl), intent(inout) :: cpos (3,dims(1)) integer(kind=irg), intent(inout) :: s_edge (2,dims(2)) integer(kind=irg), intent(inout) :: t_edge (2,dims(3)) integer(kind=irg), intent(out) :: ns real(kind=dbl), intent(out) :: d integer(kind=irg), intent(out) :: nt logical, intent(in), optional :: MFZ Called By proc~~povray_getpos_fz23~~CalledByGraph proc~povray_getpos_fz23 PoVRay_getpos_FZ23 proc~povray_drawfz PoVRay_drawFZ proc~povray_drawfz->proc~povray_getpos_fz23 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code PoVRay_getpos_FZ23 Source Code recursive subroutine PoVRay_getpos_FZ23 ( dims , cpos , s_edge , t_edge , ns , d , nt , MFZ ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_getpos_FZ23 IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dims ( 3 ) real ( kind = dbl ), INTENT ( INOUT ) :: cpos ( 3 , dims ( 1 )) integer ( kind = irg ), INTENT ( INOUT ) :: s_edge ( 2 , dims ( 2 )) integer ( kind = irg ), INTENT ( INOUT ) :: t_edge ( 2 , dims ( 3 )) integer ( kind = irg ), INTENT ( OUT ) :: ns real ( kind = dbl ), INTENT ( OUT ) :: d integer ( kind = irg ), INTENT ( OUT ) :: nt logical , OPTIONAL , INTENT ( IN ) :: MFZ real ( kind = dbl ) :: a = 1.D0 , b = 0.0D0 , c = 0.5773502692D0 , e = 0.333333333D0 , & ds = 0.6340506711D0 , dt = 1.4142135623730D0 , dd , zz = 0.D0 , oo = 1.D0 d = 1.0 if ( present ( MFZ )) then if ( MFZ ) then ! define the coordinates of the cubic Mackenzie FZ in Rodrigues Space cpos ( 1 : 3 , 1 ) = ( / b , b , b / ) cpos ( 1 : 3 , 2 ) = ( / a , b , b / ) cpos ( 1 : 3 , 3 ) = ( / b , a , b / ) cpos ( 1 : 3 , 4 ) = ( / e , e , e / ) cpos = cpos / d ns = 200 nt = nint ( ns * dt / ds ) ! define the connectivity of all the edges s_edge ( 1 : 2 , 1 ) = ( / 1 , 2 / ) s_edge ( 1 : 2 , 2 ) = ( / 1 , 3 / ) s_edge ( 1 : 2 , 3 ) = ( / 1 , 4 / ) s_edge ( 1 : 2 , 4 ) = ( / 2 , 3 / ) s_edge ( 1 : 2 , 5 ) = ( / 2 , 4 / ) s_edge ( 1 : 2 , 6 ) = ( / 3 , 4 / ) end if ! define the coordinates of the cubic FZ in Rodrigues Space else ! define the coordinates of the cubic D3 FZ in Rodrigues Space cpos ( 1 : 3 , 1 ) = ( / a , b , b / ) cpos ( 1 : 3 , 2 ) = ( / b , a , b / ) cpos ( 1 : 3 , 3 ) = ( / - a , b , b / ) cpos ( 1 : 3 , 4 ) = ( / b , - a , b / ) cpos ( 1 : 3 , 5 ) = ( / b , b , a / ) cpos ( 1 : 3 , 6 ) = ( / b , b , - a / ) cpos = cpos / d ns = 200 nt = nint ( ns * dt / ds ) ! define the connectivity of all the edges s_edge ( 1 : 2 , 1 ) = ( / 1 , 2 / ) s_edge ( 1 : 2 , 2 ) = ( / 2 , 3 / ) s_edge ( 1 : 2 , 3 ) = ( / 3 , 4 / ) s_edge ( 1 : 2 , 4 ) = ( / 4 , 1 / ) s_edge ( 1 : 2 , 5 ) = ( / 1 , 5 / ) s_edge ( 1 : 2 , 6 ) = ( / 2 , 5 / ) s_edge ( 1 : 2 , 7 ) = ( / 3 , 5 / ) s_edge ( 1 : 2 , 8 ) = ( / 4 , 5 / ) s_edge ( 1 : 2 , 9 ) = ( / 1 , 6 / ) s_edge ( 1 : 2 , 10 ) = ( / 2 , 6 / ) s_edge ( 1 : 2 , 11 ) = ( / 3 , 6 / ) s_edge ( 1 : 2 , 12 ) = ( / 4 , 6 / ) end if end subroutine PoVRay_getpos_FZ23","tags":"","loc":"proc/povray_getpos_fz23.html","title":"PoVRay_getpos_FZ23 – Fortran Program"},{"text":"public recursive subroutine PoVRay_getpos_FZ622(dims, cpos, s_edge, t_edge, ns, d, nt, MFZ) @author Marc De Graef, Carnegie Mellon University\n @brief initialize the PoVRay output for rotational group 622\n @param dims dimensions for subsequent arrays\n @param cpos vertex coordinates\n @param s_edge first set of edge connectivities\n @param t_edge second set of edge connectivities\n @param ns, d, nt  auxiliary parameters\n @param MFZ (optional) return coordinates for Mackenzie FZ instead of regular FZ\n @date    09/10/16 MDG 1.0 original\n @date    02/05/17 MDG 1.1 correction of d parameter Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dims (3) real(kind=dbl), intent(inout) :: cpos (3,dims(1)) integer(kind=irg), intent(inout) :: s_edge (2,dims(2)) integer(kind=irg), intent(inout) :: t_edge (2,dims(3)) integer(kind=irg), intent(out) :: ns real(kind=dbl), intent(out) :: d integer(kind=irg), intent(out) :: nt logical, intent(in), optional :: MFZ Called By proc~~povray_getpos_fz622~~CalledByGraph proc~povray_getpos_fz622 PoVRay_getpos_FZ622 proc~povray_drawfz PoVRay_drawFZ proc~povray_drawfz->proc~povray_getpos_fz622 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code PoVRay_getpos_FZ622 Source Code recursive subroutine PoVRay_getpos_FZ622 ( dims , cpos , s_edge , t_edge , ns , d , nt , MFZ ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_getpos_FZ622 IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dims ( 3 ) real ( kind = dbl ), INTENT ( INOUT ) :: cpos ( 3 , dims ( 1 )) integer ( kind = irg ), INTENT ( INOUT ) :: s_edge ( 2 , dims ( 2 )) integer ( kind = irg ), INTENT ( INOUT ) :: t_edge ( 2 , dims ( 3 )) integer ( kind = irg ), INTENT ( OUT ) :: ns real ( kind = dbl ), INTENT ( OUT ) :: d integer ( kind = irg ), INTENT ( OUT ) :: nt logical , OPTIONAL , INTENT ( IN ) :: MFZ real ( kind = dbl ) :: a = 1.0D0 , b = 0.267949192431D0 , c = 0.732050807569D0 , & dt = 0.5358983848622454D0 , ds = 0.5358983848622454D0 , di = 1.069389330154823D0 , dd , & z = 0.D0 , o = 0.86602540378443D0 , p = 0.5D0 d = 1.0693893290743279D0 if ( present ( MFZ )) then if ( MFZ ) then ! define the coordinates of the hexagonal Mackenzie FZ in Rodrigues Space cpos ( 1 : 3 , 1 ) = ( / z , z , z / ) cpos ( 1 : 3 , 2 ) = ( / z , z , b / ) cpos ( 1 : 3 , 3 ) = ( / a , z , z / ) cpos ( 1 : 3 , 4 ) = ( / a , z , b / ) cpos ( 1 : 3 , 5 ) = ( / a , b , z / ) cpos ( 1 : 3 , 6 ) = ( / a , b , b / ) cpos ( 1 : 3 , 7 ) = ( / o , p , z / ) cpos ( 1 : 3 , 8 ) = ( / o , p , b / ) cpos = cpos / d ns = 200 nt = nint ( ns * dt / ds ) ! define the connectivity of all the edges s_edge ( 1 : 2 , 1 ) = ( / 1 , 2 / ) s_edge ( 1 : 2 , 2 ) = ( / 1 , 3 / ) s_edge ( 1 : 2 , 3 ) = ( / 1 , 7 / ) s_edge ( 1 : 2 , 4 ) = ( / 2 , 4 / ) s_edge ( 1 : 2 , 5 ) = ( / 2 , 8 / ) s_edge ( 1 : 2 , 6 ) = ( / 3 , 4 / ) s_edge ( 1 : 2 , 7 ) = ( / 3 , 5 / ) s_edge ( 1 : 2 , 8 ) = ( / 4 , 6 / ) s_edge ( 1 : 2 , 9 ) = ( / 5 , 6 / ) s_edge ( 1 : 2 , 10 ) = ( / 5 , 7 / ) s_edge ( 1 : 2 , 11 ) = ( / 6 , 8 / ) s_edge ( 1 : 2 , 12 ) = ( / 7 , 8 / ) end if else ! define the coordinates of the hexagonal FZ in Rodrigues Space cpos ( 1 : 3 , 1 ) = ( / a , b , b / ) cpos ( 1 : 3 , 2 ) = ( / c , c , b / ) cpos ( 1 : 3 , 3 ) = ( / b , a , b / ) cpos ( 1 : 3 , 4 ) = ( / - b , a , b / ) cpos ( 1 : 3 , 5 ) = ( / - c , c , b / ) cpos ( 1 : 3 , 6 ) = ( / - a , b , b / ) cpos ( 1 : 3 , 7 ) = ( / - a , - b , b / ) cpos ( 1 : 3 , 8 ) = ( / - c , - c , b / ) cpos ( 1 : 3 , 9 ) = ( / - b , - a , b / ) cpos ( 1 : 3 , 10 ) = ( / b , - a , b / ) cpos ( 1 : 3 , 11 ) = ( / c , - c , b / ) cpos ( 1 : 3 , 12 ) = ( / a , - b , b / ) cpos ( 1 : 3 , 13 ) = ( / a , b , - b / ) cpos ( 1 : 3 , 14 ) = ( / c , c , - b / ) cpos ( 1 : 3 , 15 ) = ( / b , a , - b / ) cpos ( 1 : 3 , 16 ) = ( / - b , a , - b / ) cpos ( 1 : 3 , 17 ) = ( / - c , c , - b / ) cpos ( 1 : 3 , 18 ) = ( / - a , b , - b / ) cpos ( 1 : 3 , 19 ) = ( / - a , - b , - b / ) cpos ( 1 : 3 , 20 ) = ( / - c , - c , - b / ) cpos ( 1 : 3 , 21 ) = ( / - b , - a , - b / ) cpos ( 1 : 3 , 22 ) = ( / b , - a , - b / ) cpos ( 1 : 3 , 23 ) = ( / c , - c , - b / ) cpos ( 1 : 3 , 24 ) = ( / a , - b , - b / ) cpos = cpos / d ns = 200 nt = nint ( ns * dt / ds ) ! define the connectivity of all the edges s_edge ( 1 : 2 , 1 ) = ( / 1 , 2 / ) s_edge ( 1 : 2 , 2 ) = ( / 2 , 3 / ) s_edge ( 1 : 2 , 3 ) = ( / 3 , 4 / ) s_edge ( 1 : 2 , 4 ) = ( / 4 , 5 / ) s_edge ( 1 : 2 , 5 ) = ( / 5 , 6 / ) s_edge ( 1 : 2 , 6 ) = ( / 6 , 7 / ) s_edge ( 1 : 2 , 7 ) = ( / 7 , 8 / ) s_edge ( 1 : 2 , 8 ) = ( / 8 , 9 / ) s_edge ( 1 : 2 , 9 ) = ( / 9 , 10 / ) s_edge ( 1 : 2 , 10 ) = ( / 10 , 11 / ) s_edge ( 1 : 2 , 11 ) = ( / 11 , 12 / ) s_edge ( 1 : 2 , 12 ) = ( / 12 , 1 / ) s_edge ( 1 : 2 , 13 ) = ( / 13 , 14 / ) s_edge ( 1 : 2 , 14 ) = ( / 14 , 15 / ) s_edge ( 1 : 2 , 15 ) = ( / 15 , 16 / ) s_edge ( 1 : 2 , 16 ) = ( / 16 , 17 / ) s_edge ( 1 : 2 , 17 ) = ( / 17 , 18 / ) s_edge ( 1 : 2 , 18 ) = ( / 18 , 19 / ) s_edge ( 1 : 2 , 19 ) = ( / 19 , 20 / ) s_edge ( 1 : 2 , 20 ) = ( / 20 , 21 / ) s_edge ( 1 : 2 , 21 ) = ( / 21 , 22 / ) s_edge ( 1 : 2 , 22 ) = ( / 22 , 23 / ) s_edge ( 1 : 2 , 23 ) = ( / 23 , 24 / ) s_edge ( 1 : 2 , 24 ) = ( / 24 , 13 / ) t_edge ( 1 : 2 , 1 ) = ( / 1 , 13 / ) t_edge ( 1 : 2 , 2 ) = ( / 2 , 14 / ) t_edge ( 1 : 2 , 3 ) = ( / 3 , 15 / ) t_edge ( 1 : 2 , 4 ) = ( / 4 , 16 / ) t_edge ( 1 : 2 , 5 ) = ( / 5 , 17 / ) t_edge ( 1 : 2 , 6 ) = ( / 6 , 18 / ) t_edge ( 1 : 2 , 7 ) = ( / 7 , 19 / ) t_edge ( 1 : 2 , 8 ) = ( / 8 , 20 / ) t_edge ( 1 : 2 , 9 ) = ( / 9 , 21 / ) t_edge ( 1 : 2 , 10 ) = ( / 10 , 22 / ) t_edge ( 1 : 2 , 11 ) = ( / 11 , 23 / ) t_edge ( 1 : 2 , 12 ) = ( / 12 , 24 / ) end if end subroutine PoVRay_getpos_FZ622","tags":"","loc":"proc/povray_getpos_fz622.html","title":"PoVRay_getpos_FZ622 – Fortran Program"},{"text":"public recursive subroutine PoVRay_getpos_FZ422(dims, cpos, s_edge, t_edge, ns, d, nt, MFZ) @author Marc De Graef, Carnegie Mellon University\n @brief initialize the PoVRay output for rotational group 422\n @param dims dimensions for subsequent arrays\n @param cpos vertex coordinates\n @param s_edge first set of edge connectivities\n @param t_edge second set of edge connectivities\n @param ns, d, nt  auxiliary parameters\n @param MFZ (optional) return coordinates for Mackenzie FZ instead of regular FZ\n @date    09/10/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dims (3) real(kind=dbl), intent(inout) :: cpos (3,dims(1)) integer(kind=irg), intent(inout) :: s_edge (2,dims(2)) integer(kind=irg), intent(inout) :: t_edge (2,dims(3)) integer(kind=irg), intent(out) :: ns real(kind=dbl), intent(out) :: d integer(kind=irg), intent(out) :: nt logical, intent(in), optional :: MFZ Called By proc~~povray_getpos_fz422~~CalledByGraph proc~povray_getpos_fz422 PoVRay_getpos_FZ422 proc~povray_drawfz PoVRay_drawFZ proc~povray_drawfz->proc~povray_getpos_fz422 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code PoVRay_getpos_FZ422 Source Code recursive subroutine PoVRay_getpos_FZ422 ( dims , cpos , s_edge , t_edge , ns , d , nt , MFZ ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_getpos_FZ422 IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dims ( 3 ) real ( kind = dbl ), INTENT ( INOUT ) :: cpos ( 3 , dims ( 1 )) integer ( kind = irg ), INTENT ( INOUT ) :: s_edge ( 2 , dims ( 2 )) integer ( kind = irg ), INTENT ( INOUT ) :: t_edge ( 2 , dims ( 3 )) integer ( kind = irg ), INTENT ( OUT ) :: ns real ( kind = dbl ), INTENT ( OUT ) :: d integer ( kind = irg ), INTENT ( OUT ) :: nt logical , OPTIONAL , INTENT ( IN ) :: MFZ real ( kind = dbl ) :: a = 1.0D0 , b = 0.41421354D0 , c = 0.41421354D0 , dt = 0.8284270763397216D0 , & ds = 0.8284270763397216D0 , dd , z = 0.D0 , o = 0.70710678118654746D0 d = 1.158941651036677D0 if ( present ( MFZ )) then if ( MFZ ) then ! define the coordinates of the tetragonal Mackenzie FZ in Rodrigues Space cpos ( 1 : 3 , 1 ) = ( / z , z , z / ) cpos ( 1 : 3 , 2 ) = ( / z , z , c / ) cpos ( 1 : 3 , 3 ) = ( / a , z , z / ) cpos ( 1 : 3 , 4 ) = ( / a , z , c / ) cpos ( 1 : 3 , 5 ) = ( / a , b , z / ) cpos ( 1 : 3 , 6 ) = ( / a , b , c / ) cpos ( 1 : 3 , 7 ) = ( / o , o , z / ) cpos ( 1 : 3 , 8 ) = ( / o , o , c / ) cpos = cpos / d ns = 200 nt = nint ( ns * dt / ds ) ! define the connectivity of all the edges s_edge ( 1 : 2 , 1 ) = ( / 1 , 2 / ) s_edge ( 1 : 2 , 2 ) = ( / 1 , 3 / ) s_edge ( 1 : 2 , 3 ) = ( / 1 , 7 / ) s_edge ( 1 : 2 , 4 ) = ( / 2 , 4 / ) s_edge ( 1 : 2 , 5 ) = ( / 2 , 8 / ) s_edge ( 1 : 2 , 6 ) = ( / 3 , 4 / ) s_edge ( 1 : 2 , 7 ) = ( / 3 , 5 / ) s_edge ( 1 : 2 , 8 ) = ( / 4 , 6 / ) s_edge ( 1 : 2 , 9 ) = ( / 5 , 6 / ) s_edge ( 1 : 2 , 10 ) = ( / 5 , 7 / ) s_edge ( 1 : 2 , 11 ) = ( / 6 , 8 / ) s_edge ( 1 : 2 , 12 ) = ( / 7 , 8 / ) end if ! define the coordinates of the cubic FZ in Rodrigues Space else ! define the coordinates of the tetragonal 422 FZ in Rodrigues Space cpos ( 1 : 3 , 1 ) = ( / a , b , c / ) cpos ( 1 : 3 , 2 ) = ( / b , a , c / ) cpos ( 1 : 3 , 3 ) = ( / - b , a , c / ) cpos ( 1 : 3 , 4 ) = ( / - a , b , c / ) cpos ( 1 : 3 , 5 ) = ( / - a , - b , c / ) cpos ( 1 : 3 , 6 ) = ( / - b , - a , c / ) cpos ( 1 : 3 , 7 ) = ( / b , - a , c / ) cpos ( 1 : 3 , 8 ) = ( / a , - b , c / ) cpos ( 1 : 3 , 9 ) = ( / a , b , - c / ) cpos ( 1 : 3 , 10 ) = ( / b , a , - c / ) cpos ( 1 : 3 , 11 ) = ( / - b , a , - c / ) cpos ( 1 : 3 , 12 ) = ( / - a , b , - c / ) cpos ( 1 : 3 , 13 ) = ( / - a , - b , - c / ) cpos ( 1 : 3 , 14 ) = ( / - b , - a , - c / ) cpos ( 1 : 3 , 15 ) = ( / b , - a , - c / ) cpos ( 1 : 3 , 16 ) = ( / a , - b , - c / ) cpos = cpos / d ns = 200 nt = nint ( ns * dt / ds ) ! define the connectivity of all the edges s_edge ( 1 : 2 , 1 ) = ( / 1 , 2 / ) s_edge ( 1 : 2 , 2 ) = ( / 2 , 3 / ) s_edge ( 1 : 2 , 3 ) = ( / 3 , 4 / ) s_edge ( 1 : 2 , 4 ) = ( / 4 , 5 / ) s_edge ( 1 : 2 , 5 ) = ( / 5 , 6 / ) s_edge ( 1 : 2 , 6 ) = ( / 6 , 7 / ) s_edge ( 1 : 2 , 7 ) = ( / 7 , 8 / ) s_edge ( 1 : 2 , 8 ) = ( / 8 , 1 / ) s_edge ( 1 : 2 , 9 ) = ( / 9 , 10 / ) s_edge ( 1 : 2 , 10 ) = ( / 10 , 11 / ) s_edge ( 1 : 2 , 11 ) = ( / 11 , 12 / ) s_edge ( 1 : 2 , 12 ) = ( / 12 , 13 / ) s_edge ( 1 : 2 , 13 ) = ( / 13 , 14 / ) s_edge ( 1 : 2 , 14 ) = ( / 14 , 15 / ) s_edge ( 1 : 2 , 15 ) = ( / 15 , 16 / ) s_edge ( 1 : 2 , 16 ) = ( / 16 , 9 / ) t_edge ( 1 : 2 , 1 ) = ( / 1 , 9 / ) t_edge ( 1 : 2 , 2 ) = ( / 2 , 10 / ) t_edge ( 1 : 2 , 3 ) = ( / 3 , 11 / ) t_edge ( 1 : 2 , 4 ) = ( / 4 , 12 / ) t_edge ( 1 : 2 , 5 ) = ( / 5 , 13 / ) t_edge ( 1 : 2 , 6 ) = ( / 6 , 14 / ) t_edge ( 1 : 2 , 7 ) = ( / 7 , 15 / ) t_edge ( 1 : 2 , 8 ) = ( / 8 , 16 / ) end if end subroutine PoVRay_getpos_FZ422","tags":"","loc":"proc/povray_getpos_fz422.html","title":"PoVRay_getpos_FZ422 – Fortran Program"},{"text":"public recursive subroutine PoVRay_getpos_FZ32(dims, cpos, s_edge, t_edge, ns, d, nt, MFZ) @author Marc De Graef, Carnegie Mellon University\n @brief initialize the PoVRay output for rotational group 32\n @param dims dimensions for subsequent arrays\n @param cpos vertex coordinates\n @param s_edge first set of edge connectivities\n @param t_edge second set of edge connectivities\n @param ns, d, nt  auxiliary parameters\n @param MFZ (optional) return coordinates for Mackenzie FZ instead of regular FZ\n @date    09/10/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dims (3) real(kind=dbl), intent(inout) :: cpos (3,dims(1)) integer(kind=irg), intent(inout) :: s_edge (2,dims(2)) integer(kind=irg), intent(inout) :: t_edge (2,dims(3)) integer(kind=irg), intent(out) :: ns real(kind=dbl), intent(out) :: d integer(kind=irg), intent(out) :: nt logical, intent(in), optional :: MFZ Called By proc~~povray_getpos_fz32~~CalledByGraph proc~povray_getpos_fz32 PoVRay_getpos_FZ32 proc~povray_drawfz PoVRay_drawFZ proc~povray_drawfz->proc~povray_getpos_fz32 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code PoVRay_getpos_FZ32 Source Code recursive subroutine PoVRay_getpos_FZ32 ( dims , cpos , s_edge , t_edge , ns , d , nt , MFZ ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_getpos_FZ32 IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dims ( 3 ) real ( kind = dbl ), INTENT ( INOUT ) :: cpos ( 3 , dims ( 1 )) integer ( kind = irg ), INTENT ( INOUT ) :: s_edge ( 2 , dims ( 2 )) integer ( kind = irg ), INTENT ( INOUT ) :: t_edge ( 2 , dims ( 3 )) integer ( kind = irg ), INTENT ( OUT ) :: ns real ( kind = dbl ), INTENT ( OUT ) :: d integer ( kind = irg ), INTENT ( OUT ) :: nt logical , OPTIONAL , INTENT ( IN ) :: MFZ real ( kind = dbl ) :: a = 0.8660254038D0 , b = 0.5D0 , c = 0.5773502692D0 , dt = 0.34314575050D0 , & ds = 0.6340506711D0 , dd , z = 0.D0 , oo = 1.D0 , o = 0.86602540378443D0 , p = 0.5D0 d = 1.1547005384D0 if ( present ( MFZ )) then if ( MFZ ) then ! define the coordinates of the tetragonal Mackenzie FZ in Rodrigues Space cpos ( 1 : 3 , 1 ) = ( / z , z , z / ) cpos ( 1 : 3 , 2 ) = ( / z , z , c / ) cpos ( 1 : 3 , 3 ) = ( / a , - p , z / ) cpos ( 1 : 3 , 4 ) = ( / a , - p , c / ) cpos ( 1 : 3 , 5 ) = ( / a , p , z / ) cpos ( 1 : 3 , 6 ) = ( / a , p , c / ) cpos = cpos / d ns = 200 nt = nint ( ns * dt / ds ) ! define the connectivity of all the edges s_edge ( 1 : 2 , 1 ) = ( / 1 , 2 / ) s_edge ( 1 : 2 , 2 ) = ( / 1 , 3 / ) s_edge ( 1 : 2 , 3 ) = ( / 1 , 5 / ) s_edge ( 1 : 2 , 4 ) = ( / 2 , 4 / ) s_edge ( 1 : 2 , 5 ) = ( / 2 , 6 / ) s_edge ( 1 : 2 , 6 ) = ( / 3 , 4 / ) s_edge ( 1 : 2 , 7 ) = ( / 3 , 5 / ) s_edge ( 1 : 2 , 8 ) = ( / 4 , 6 / ) s_edge ( 1 : 2 , 9 ) = ( / 5 , 6 / ) end if else ! define the coordinates of the cubic FZ in Rodrigues Space cpos ( 1 : 3 , 1 ) = ( / a , b , c / ) cpos ( 1 : 3 , 2 ) = ( / z , oo , c / ) cpos ( 1 : 3 , 3 ) = ( / - a , b , c / ) cpos ( 1 : 3 , 4 ) = ( / - a , - b , c / ) cpos ( 1 : 3 , 5 ) = ( / z , - oo , c / ) cpos ( 1 : 3 , 6 ) = ( / a , - b , c / ) cpos ( 1 : 3 , 7 ) = ( / a , b , - c / ) cpos ( 1 : 3 , 8 ) = ( / z , oo , - c / ) cpos ( 1 : 3 , 9 ) = ( / - a , b , - c / ) cpos ( 1 : 3 , 10 ) = ( / - a , - b , - c / ) cpos ( 1 : 3 , 11 ) = ( / z , - oo , - c / ) cpos ( 1 : 3 , 12 ) = ( / a , - b , - c / ) cpos = cpos / d ns = 200 nt = nint ( ns * dt / ds ) ! define the connectivity of all the edges s_edge ( 1 : 2 , 1 ) = ( / 1 , 2 / ) s_edge ( 1 : 2 , 2 ) = ( / 2 , 3 / ) s_edge ( 1 : 2 , 3 ) = ( / 3 , 4 / ) s_edge ( 1 : 2 , 4 ) = ( / 4 , 5 / ) s_edge ( 1 : 2 , 5 ) = ( / 5 , 6 / ) s_edge ( 1 : 2 , 6 ) = ( / 6 , 1 / ) s_edge ( 1 : 2 , 7 ) = ( / 7 , 8 / ) s_edge ( 1 : 2 , 8 ) = ( / 8 , 9 / ) s_edge ( 1 : 2 , 9 ) = ( / 9 , 10 / ) s_edge ( 1 : 2 , 10 ) = ( / 10 , 11 / ) s_edge ( 1 : 2 , 11 ) = ( / 11 , 12 / ) s_edge ( 1 : 2 , 12 ) = ( / 12 , 7 / ) t_edge ( 1 : 2 , 1 ) = ( / 1 , 7 / ) t_edge ( 1 : 2 , 2 ) = ( / 2 , 8 / ) t_edge ( 1 : 2 , 3 ) = ( / 3 , 9 / ) t_edge ( 1 : 2 , 4 ) = ( / 4 , 10 / ) t_edge ( 1 : 2 , 5 ) = ( / 5 , 11 / ) t_edge ( 1 : 2 , 6 ) = ( / 6 , 12 / ) end if end subroutine PoVRay_getpos_FZ32","tags":"","loc":"proc/povray_getpos_fz32.html","title":"PoVRay_getpos_FZ32 – Fortran Program"},{"text":"public recursive subroutine PoVRay_getpos_FZ222(dims, cpos, s_edge, t_edge, ns, d, nt, MFZ) @author Marc De Graef, Carnegie Mellon University\n @brief initialize the PoVRay output for rotational group 222\n @param dims dimensions for subsequent arrays\n @param cpos vertex coordinates\n @param s_edge first set of edge connectivities\n @param t_edge second set of edge connectivities\n @param ns, d, nt  auxiliary parameters\n @param MFZ (optional) return coordinates for Mackenzie FZ instead of regular FZ\n @date    09/10/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dims (3) real(kind=dbl), intent(inout) :: cpos (3,dims(1)) integer(kind=irg), intent(inout) :: s_edge (2,dims(2)) integer(kind=irg), intent(inout) :: t_edge (2,dims(3)) integer(kind=irg), intent(out) :: ns real(kind=dbl), intent(out) :: d integer(kind=irg), intent(out) :: nt logical, intent(in), optional :: MFZ Called By proc~~povray_getpos_fz222~~CalledByGraph proc~povray_getpos_fz222 PoVRay_getpos_FZ222 proc~povray_drawfz PoVRay_drawFZ proc~povray_drawfz->proc~povray_getpos_fz222 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code PoVRay_getpos_FZ222 Source Code recursive subroutine PoVRay_getpos_FZ222 ( dims , cpos , s_edge , t_edge , ns , d , nt , MFZ ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_getpos_FZ222 IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dims ( 3 ) real ( kind = dbl ), INTENT ( INOUT ) :: cpos ( 3 , dims ( 1 )) integer ( kind = irg ), INTENT ( INOUT ) :: s_edge ( 2 , dims ( 2 )) integer ( kind = irg ), INTENT ( INOUT ) :: t_edge ( 2 , dims ( 3 )) integer ( kind = irg ), INTENT ( OUT ) :: ns real ( kind = dbl ), INTENT ( OUT ) :: d integer ( kind = irg ), INTENT ( OUT ) :: nt logical , OPTIONAL , INTENT ( IN ) :: MFZ real ( kind = dbl ) :: a = 1.0D0 , b = 1.0D0 , c = 1 D0 , dt = 2.0D0 , & ds = 2.0D0 , dd , z = 0.D0 , oo = 1.D0 d = 1.7320508075688772D0 if ( present ( MFZ )) then if ( MFZ ) then ! define the coordinates of the tetragonal Mackenzie FZ in Rodrigues Space cpos ( 1 : 3 , 1 ) = ( / z , - a , z / ) cpos ( 1 : 3 , 2 ) = ( / z , - a , c / ) cpos ( 1 : 3 , 3 ) = ( / a , - a , z / ) cpos ( 1 : 3 , 4 ) = ( / a , - a , c / ) cpos ( 1 : 3 , 5 ) = ( / a , a , z / ) cpos ( 1 : 3 , 6 ) = ( / a , a , c / ) cpos ( 1 : 3 , 7 ) = ( / z , a , z / ) cpos ( 1 : 3 , 8 ) = ( / z , a , c / ) cpos = cpos / d ns = 200 nt = nint ( ns * dt / ds ) ! define the connectivity of all the edges s_edge ( 1 : 2 , 1 ) = ( / 1 , 2 / ) s_edge ( 1 : 2 , 2 ) = ( / 1 , 3 / ) s_edge ( 1 : 2 , 3 ) = ( / 1 , 7 / ) s_edge ( 1 : 2 , 4 ) = ( / 2 , 4 / ) s_edge ( 1 : 2 , 5 ) = ( / 2 , 8 / ) s_edge ( 1 : 2 , 6 ) = ( / 3 , 4 / ) s_edge ( 1 : 2 , 7 ) = ( / 3 , 5 / ) s_edge ( 1 : 2 , 8 ) = ( / 4 , 6 / ) s_edge ( 1 : 2 , 9 ) = ( / 5 , 6 / ) s_edge ( 1 : 2 , 10 ) = ( / 5 , 7 / ) s_edge ( 1 : 2 , 11 ) = ( / 6 , 8 / ) s_edge ( 1 : 2 , 12 ) = ( / 7 , 8 / ) end if ! define the coordinates of the cubic FZ in Rodrigues Space else ! define the coordinates of the FZ in Rodrigues Space cpos ( 1 : 3 , 1 ) = ( / a , b , c / ) cpos ( 1 : 3 , 2 ) = ( / - a , b , c / ) cpos ( 1 : 3 , 3 ) = ( / - a , - b , c / ) cpos ( 1 : 3 , 4 ) = ( / a , - b , c / ) cpos ( 1 : 3 , 5 ) = ( / a , b , - c / ) cpos ( 1 : 3 , 6 ) = ( / - a , b , - c / ) cpos ( 1 : 3 , 7 ) = ( / - a , - b , - c / ) cpos ( 1 : 3 , 8 ) = ( / a , - b , - c / ) cpos = cpos / d ns = 200 nt = nint ( ns * dt / ds ) ! define the connectivity of all the edges s_edge ( 1 : 2 , 1 ) = ( / 1 , 2 / ) s_edge ( 1 : 2 , 2 ) = ( / 2 , 3 / ) s_edge ( 1 : 2 , 3 ) = ( / 3 , 4 / ) s_edge ( 1 : 2 , 4 ) = ( / 4 , 1 / ) s_edge ( 1 : 2 , 5 ) = ( / 5 , 6 / ) s_edge ( 1 : 2 , 6 ) = ( / 6 , 7 / ) s_edge ( 1 : 2 , 7 ) = ( / 7 , 8 / ) s_edge ( 1 : 2 , 8 ) = ( / 8 , 5 / ) t_edge ( 1 : 2 , 1 ) = ( / 1 , 5 / ) t_edge ( 1 : 2 , 2 ) = ( / 2 , 6 / ) t_edge ( 1 : 2 , 3 ) = ( / 3 , 7 / ) t_edge ( 1 : 2 , 4 ) = ( / 4 , 8 / ) end if end subroutine PoVRay_getpos_FZ222","tags":"","loc":"proc/povray_getpos_fz222.html","title":"PoVRay_getpos_FZ222 – Fortran Program"},{"text":"public recursive subroutine PoVRay_drawFZ(dunit, rmode, cylr, FZtype, FZorder, MFZ) @author Marc De Graef, Carnegie Mellon University\n @brief initialize the PoVRay output for any rotation group\n @details This routine draws the outline of either the Rodrigues Fundamental\n zone, or the Mackenzie Fundamental Zone (if MFZ is set and true).\n @param dunit output unit number\n @param rmode  1(cubochoric)|2(homochoric)|3(stereographic)|4(Rodrigues)|5(Euler)\n @param cylr cylinder radius\n @param FZtype  Fundamental zone type \n @param FZorder order of the FZ point group\n @param MFZ (optional) Mackenzie FZ instead of regular FZ\n @date    09/10/16 MDG 1.0 original\n @date    11/23/16 MDG 1.1 added Euler representation Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit integer(kind=irg), intent(in) :: rmode real(kind=dbl), intent(in) :: cylr integer(kind=irg), intent(in) :: FZtype integer(kind=irg), intent(in) :: FZorder logical, intent(in), optional :: MFZ Calls proc~~povray_drawfz~~CallsGraph proc~povray_drawfz PoVRay_drawFZ ro2eu ro2eu proc~povray_drawfz->ro2eu ro2qu ro2qu proc~povray_drawfz->ro2qu proc~povray_getpos_fz23 PoVRay_getpos_FZ23 proc~povray_drawfz->proc~povray_getpos_fz23 proc~povray_addeulerbox PoVRay_addEulerBox proc~povray_drawfz->proc~povray_addeulerbox proc~povray_addcubochoriccube PoVRay_addCubochoricCube proc~povray_drawfz->proc~povray_addcubochoriccube proc~povray_getpos_fz622 PoVRay_getpos_FZ622 proc~povray_drawfz->proc~povray_getpos_fz622 proc~povray_getpos_fz32 PoVRay_getpos_FZ32 proc~povray_drawfz->proc~povray_getpos_fz32 proc~povray_addwireframesphere PoVRay_addWireFrameSphere proc~povray_drawfz->proc~povray_addwireframesphere proc~povray_getpos_fz422 PoVRay_getpos_FZ422 proc~povray_drawfz->proc~povray_getpos_fz422 proc~povray_addreferenceframe PoVRay_addReferenceFrame proc~povray_drawfz->proc~povray_addreferenceframe ro2cu ro2cu proc~povray_drawfz->ro2cu ro2ho ro2ho proc~povray_drawfz->ro2ho proc~povray_addcylinder PoVRay_addCylinder proc~povray_drawfz->proc~povray_addcylinder proc~povray_getpos_fz432 PoVRay_getpos_FZ432 proc~povray_drawfz->proc~povray_getpos_fz432 proc~povray_getpos_fz222 PoVRay_getpos_FZ222 proc~povray_drawfz->proc~povray_getpos_fz222 proc~povray_addcubochoriccube->proc~povray_addcylinder Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code PoVRay_drawFZ Source Code recursive subroutine PoVRay_drawFZ ( dunit , rmode , cylr , FZtype , FZorder , MFZ ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_drawFZ IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit integer ( kind = irg ), INTENT ( IN ) :: rmode real ( kind = dbl ), INTENT ( IN ) :: cylr integer ( kind = irg ), INTENT ( IN ) :: FZtype integer ( kind = irg ), INTENT ( IN ) :: FZorder logical , OPTIONAL , INTENT ( IN ) :: MFZ real ( kind = dbl ) :: eul ( 3 ), axang ( 4 ), rv ( 3 ), qu ( 4 ), h ( 3 ), rmax , dx , r , xmax , x , y , z , ho ( 3 ), cu ( 3 ), zsmall , & eyepos ( 3 ), ac , sh ( 3 ), ron ( 4 ) real ( kind = dbl ) :: euld ( 3 ), om ( 3 , 3 ), ro1 ( 4 ), ro2 ( 4 ), culast ( 3 ), holast ( 3 ), ro ( 4 ), rolast ( 4 ), splast ( 3 ), sp ( 3 ), & eu ( 3 ), eulast ( 3 ), xx type ( orientationtype ) :: ot type ( orientationtyped ) :: otd integer ( kind = irg ), allocatable :: s_edge (:,:), t_edge (:,:) real ( kind = dbl ), allocatable :: cpos (:,:) logical :: doMFZ , twostep integer ( kind = irg ) :: i , j , k , icnt , imax , nt , ns , dims ( 3 ) real ( kind = dbl ) :: d , dd , tpi , hpi tpi = 2.D0 * cPi hpi = 0.5D0 * cPi doMFZ = . FALSE . if ( present ( MFZ )) doMFZ = . TRUE . write ( * , * ) 'inside PoVRay_drawFZ; MFZ = ' , doMFZ , dunit , rmode , cylr , FZtype , FZorder if ( FZtype . eq . 2 ) then if ( FZorder . eq . 6 ) then if ( doMFZ ) then twostep = . FALSE . dims = ( / 8 , 12 , 1 / ) allocate ( cpos ( 3 , dims ( 1 )), s_edge ( 2 , dims ( 2 )), t_edge ( 2 , dims ( 3 ))) call PoVRay_getpos_FZ622 ( dims , cpos , s_edge , t_edge , ns , d , nt , MFZ ) else twostep = . TRUE . dims = ( / 24 , 24 , 12 / ) allocate ( cpos ( 3 , dims ( 1 )), s_edge ( 2 , dims ( 2 )), t_edge ( 2 , dims ( 3 ))) call PoVRay_getpos_FZ622 ( dims , cpos , s_edge , t_edge , ns , d , nt ) end if end if if ( FZorder . eq . 4 ) then if ( doMFZ ) then twostep = . FALSE . dims = ( / 8 , 12 , 1 / ) allocate ( cpos ( 3 , dims ( 1 )), s_edge ( 2 , dims ( 2 )), t_edge ( 2 , dims ( 3 ))) call PoVRay_getpos_FZ422 ( dims , cpos , s_edge , t_edge , ns , d , nt , MFZ ) else twostep = . TRUE . dims = ( / 16 , 16 , 8 / ) allocate ( cpos ( 3 , dims ( 1 )), s_edge ( 2 , dims ( 2 )), t_edge ( 2 , dims ( 3 ))) call PoVRay_getpos_FZ422 ( dims , cpos , s_edge , t_edge , ns , d , nt ) end if end if if ( FZorder . eq . 3 ) then if ( doMFZ ) then twostep = . FALSE . dims = ( / 6 , 9 , 1 / ) allocate ( cpos ( 3 , dims ( 1 )), s_edge ( 2 , dims ( 2 )), t_edge ( 2 , dims ( 3 ))) call PoVRay_getpos_FZ32 ( dims , cpos , s_edge , t_edge , ns , d , nt , MFZ ) else twostep = . TRUE . dims = ( / 12 , 12 , 6 / ) allocate ( cpos ( 3 , dims ( 1 )), s_edge ( 2 , dims ( 2 )), t_edge ( 2 , dims ( 3 ))) call PoVRay_getpos_FZ32 ( dims , cpos , s_edge , t_edge , ns , d , nt ) end if end if if ( FZorder . eq . 2 ) then if ( doMFZ ) then twostep = . FALSE . dims = ( / 8 , 12 , 1 / ) allocate ( cpos ( 3 , dims ( 1 )), s_edge ( 2 , dims ( 2 )), t_edge ( 2 , dims ( 3 ))) call PoVRay_getpos_FZ222 ( dims , cpos , s_edge , t_edge , ns , d , nt , MFZ ) else twostep = . TRUE . dims = ( / 8 , 8 , 4 / ) allocate ( cpos ( 3 , dims ( 1 )), s_edge ( 2 , dims ( 2 )), t_edge ( 2 , dims ( 3 ))) call PoVRay_getpos_FZ222 ( dims , cpos , s_edge , t_edge , ns , d , nt ) end if end if end if if ( FZtype . eq . 3 ) then ! rotational group 23 if ( doMFZ ) then twostep = . FALSE . dims = ( / 4 , 6 , 1 / ) allocate ( cpos ( 3 , dims ( 1 )), s_edge ( 2 , dims ( 2 )), t_edge ( 2 , dims ( 3 ))) call PoVRay_getpos_FZ23 ( dims , cpos , s_edge , t_edge , ns , d , nt , MFZ ) else twostep = . FALSE . dims = ( / 6 , 12 , 1 / ) allocate ( cpos ( 3 , dims ( 1 )), s_edge ( 2 , dims ( 2 )), t_edge ( 2 , dims ( 3 ))) call PoVRay_getpos_FZ23 ( dims , cpos , s_edge , t_edge , ns , d , nt ) end if end if if ( FZtype . eq . 4 ) then ! rotational group 432 if ( doMFZ ) then twostep = . FALSE . dims = ( / 6 , 9 , 1 / ) allocate ( cpos ( 3 , dims ( 1 )), s_edge ( 2 , dims ( 2 )), t_edge ( 2 , dims ( 3 ))) call PoVRay_getpos_FZ432 ( dims , cpos , s_edge , t_edge , ns , d , nt , MFZ ) else twostep = . TRUE . dims = ( / 24 , 12 , 24 / ) allocate ( cpos ( 3 , dims ( 1 )), s_edge ( 2 , dims ( 2 )), t_edge ( 2 , dims ( 3 ))) call PoVRay_getpos_FZ432 ( dims , cpos , s_edge , t_edge , ns , d , nt ) end if end if ! add the reference frame and any necessary wireframes if ( rmode . eq . 1 ) then ac = 0.5D0 * LPs % ap call PoVRay_addReferenceFrame ( dunit , ac , cylr ) call PoVRay_addCubochoricCube ( dunit ) end if if ( rmode . eq . 2 ) then ac = 1.33067D0 call PoVRay_addReferenceFrame ( dunit , ac , cylr ) call PoVRay_addWireFrameSphere ( dunit , ac ) end if if ( rmode . eq . 3 ) then ac = 1.0D0 call PoVRay_addReferenceFrame ( dunit , ac , cylr ) call PoVRay_addWireFrameSphere ( dunit , ac ) end if if ( rmode . eq . 4 ) then ac = 1.0D0 call PoVRay_addReferenceFrame ( dunit , ac , cylr ) end if if ( rmode . eq . 5 ) then call PoVRay_addEulerBox ( dunit ) end if ! and next, draw the outline of the FZ or MFZ if (( rmode . eq . 1 ). or .( rmode . eq . 2 )) then ! create the square edges first dx = 1.D0 / dble ( ns ) do i = 1 , dims ( 2 ) ro1 ( 1 : 3 ) = cpos ( 1 : 3 , s_edge ( 1 , i )) ro1 ( 4 ) = d ro2 ( 1 : 3 ) = cpos ( 1 : 3 , s_edge ( 2 , i )) ro2 ( 4 ) = d culast = ro2cu ( ro1 ) holast = ro2ho ( ro1 ) do j = 1 , ns + 1 ro ( 1 : 3 ) = d * ro1 ( 1 : 3 ) + d * ( ro2 ( 1 : 3 ) - ro1 ( 1 : 3 )) * j * dx xx = dsqrt ( sum ( ro ( 1 : 3 ) ** 2 ) ) ro ( 1 : 3 ) = ro ( 1 : 3 ) / xx ro ( 4 ) = xx cu = ro2cu ( ro ) ho = ro2ho ( ro ) ! and create a cylinder with these points if ( rmode . eq . 1 ) then call PoVRay_addCylinder ( dunit , culast ( 1 : 3 ), cu ( 1 : 3 ), cylr ,( / 0.0 , 0.0 , 1.0 / )) else call PoVRay_addCylinder ( dunit , holast ( 1 : 3 ), ho ( 1 : 3 ), cylr ,( / 0.0 , 0.0 , 1.0 / )) end if culast = cu holast = ho end do end do if ( twostep ) then dx = 1.D0 / dble ( nt ) do i = 1 , dims ( 3 ) ro1 ( 1 : 3 ) = cpos ( 1 : 3 , t_edge ( 1 , i )) ro1 ( 4 ) = d ro2 ( 1 : 3 ) = cpos ( 1 : 3 , t_edge ( 2 , i )) ro2 ( 4 ) = d culast = ro2cu ( ro1 ) holast = ro2ho ( ro1 ) do j = 1 , nt + 1 ro ( 1 : 3 ) = d * ro1 ( 1 : 3 ) + d * ( ro2 ( 1 : 3 ) - ro1 ( 1 : 3 )) * j * dx xx = dsqrt ( sum ( ro ( 1 : 3 ) ** 2 ) ) ro ( 1 : 3 ) = ro ( 1 : 3 ) / xx ro ( 4 ) = xx cu = ro2cu ( ro ) ho = ro2ho ( ro ) ! and create a cylinder with these points if ( rmode . eq . 1 ) then call PoVRay_addCylinder ( dunit , culast ( 1 : 3 ), cu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) else call PoVRay_addCylinder ( dunit , holast ( 1 : 3 ), ho ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) end if culast = cu holast = ho end do end do end if end if if (( rmode . eq . 3 ). or .( rmode . eq . 4 )) then dx = 1.D0 / dble ( ns ) do i = 1 , dims ( 2 ) ro1 ( 1 : 3 ) = cpos ( 1 : 3 , s_edge ( 1 , i )) ro1 ( 4 ) = d ro2 ( 1 : 3 ) = cpos ( 1 : 3 , s_edge ( 2 , i )) ro2 ( 4 ) = d rolast = ro1 qu = ro2qu ( ro1 ) splast ( 1 : 3 ) = qu ( 2 : 4 ) / ( 1.D0 + qu ( 1 )) do j = 1 , ns + 1 ro ( 1 : 3 ) = d * ro1 ( 1 : 3 ) + d * ( ro2 ( 1 : 3 ) - ro1 ( 1 : 3 )) * j * dx xx = dsqrt ( sum ( ro ( 1 : 3 ) ** 2 ) ) ro ( 1 : 3 ) = ro ( 1 : 3 ) / xx ro ( 4 ) = xx qu = ro2qu ( ro ) sp ( 1 : 3 ) = qu ( 2 : 4 ) / ( 1.D0 + qu ( 1 )) ! and create a cylinder with these points if ( rmode . eq . 3 ) then call PoVRay_addCylinder ( dunit , splast ( 1 : 3 ), sp ( 1 : 3 ), cylr ,( / 0.0 , 0.0 , 1.0 / )) else call PoVRay_addCylinder ( dunit , rolast ( 1 : 3 ) * rolast ( 4 ), ro ( 1 : 3 ) * ro ( 4 ), cylr ,( / 0.0 , 0.0 , 1.0 / )) end if rolast = ro splast = sp end do end do if ( twostep ) then dx = 1.D0 / dble ( nt ) do i = 1 , dims ( 3 ) ro1 ( 1 : 3 ) = cpos ( 1 : 3 , t_edge ( 1 , i )) ro1 ( 4 ) = d ro2 ( 1 : 3 ) = cpos ( 1 : 3 , t_edge ( 2 , i )) ro2 ( 4 ) = d rolast = ro1 qu = ro2qu ( ro1 ) splast ( 1 : 3 ) = qu ( 2 : 4 ) / ( 1.D0 + qu ( 1 )) do j = 1 , nt + 1 ro ( 1 : 3 ) = d * ro1 ( 1 : 3 ) + d * ( ro2 ( 1 : 3 ) - ro1 ( 1 : 3 )) * j * dx xx = dsqrt ( sum ( ro ( 1 : 3 ) ** 2 ) ) ro ( 1 : 3 ) = ro ( 1 : 3 ) / xx ro ( 4 ) = xx qu = ro2qu ( ro ) sp ( 1 : 3 ) = qu ( 2 : 4 ) / ( 1.D0 + qu ( 1 )) ! and create a cylinder with these points if ( rmode . eq . 3 ) then call PoVRay_addCylinder ( dunit , splast ( 1 : 3 ), sp ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) else call PoVRay_addCylinder ( dunit , rolast ( 1 : 3 ) * rolast ( 4 ), ro ( 1 : 3 ) * ro ( 4 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) end if rolast = ro splast = sp end do end do end if end if ! and next, draw the outline of the FZ or MFZ if ( rmode . eq . 5 ) then sh = ( / cPi , cPi / 2.D0 , cPi / ) ! create the square edges first dx = 1.D0 / dble ( ns ) do i = 1 , dims ( 2 ) ro1 ( 1 : 3 ) = cpos ( 1 : 3 , s_edge ( 1 , i )) ro1 ( 4 ) = d ro2 ( 1 : 3 ) = cpos ( 1 : 3 , s_edge ( 2 , i )) ro2 ( 4 ) = d eulast = ro2eu ( ro1 ) eulast ( 1 ) = mod ( eulast ( 1 ) + 1 0.D0 * cPi , 2.D0 * cPi ) eulast ( 2 ) = mod ( eulast ( 2 ) + 1 0.D0 * cPi , cPi ) eulast ( 3 ) = mod ( eulast ( 3 ) + 1 0.D0 * cPi , 2.D0 * cPi ) eulast = eulast - sh do j = 1 , ns + 1 ro ( 1 : 3 ) = d * ro1 ( 1 : 3 ) + d * ( ro2 ( 1 : 3 ) - ro1 ( 1 : 3 )) * j * dx xx = dsqrt ( sum ( ro ( 1 : 3 ) ** 2 ) ) ro ( 1 : 3 ) = ro ( 1 : 3 ) / xx ro ( 4 ) = xx eu = ro2eu ( ro ) eu ( 1 ) = mod ( eu ( 1 ) + 1 0.D0 * cPi , 2.D0 * cPi ) eu ( 2 ) = mod ( eu ( 2 ) + 1 0.D0 * cPi , cPi ) eu ( 3 ) = mod ( eu ( 3 ) + 1 0.D0 * cPi , 2.D0 * cPi ) eu = eu - sh ! and create a cylinder with these points if ( maxval ( abs ( eulast - eu )). lt . cPi ) then call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 0.0 , 0.0 , 1.0 / )) end if eulast = eu end do end do if ( twostep ) then dx = 1.D0 / dble ( nt ) do i = 1 , dims ( 3 ) ro1 ( 1 : 3 ) = cpos ( 1 : 3 , t_edge ( 1 , i )) ro1 ( 4 ) = d ro2 ( 1 : 3 ) = cpos ( 1 : 3 , t_edge ( 2 , i )) ro2 ( 4 ) = d eulast = ro2eu ( ro1 ) eulast ( 1 ) = mod ( eulast ( 1 ) + 1 0.D0 * cPi , 2.D0 * cPi ) eulast ( 2 ) = mod ( eulast ( 2 ) + 1 0.D0 * cPi , cPi ) eulast ( 3 ) = mod ( eulast ( 3 ) + 1 0.D0 * cPi , 2.D0 * cPi ) eulast = eulast - sh do j = 1 , nt + 1 ro ( 1 : 3 ) = d * ro1 ( 1 : 3 ) + d * ( ro2 ( 1 : 3 ) - ro1 ( 1 : 3 )) * j * dx xx = dsqrt ( sum ( ro ( 1 : 3 ) ** 2 ) ) ro ( 1 : 3 ) = ro ( 1 : 3 ) / xx ro ( 4 ) = xx eu = ro2eu ( ro ) eu ( 1 ) = mod ( eu ( 1 ) + 1 0.D0 * cPi , 2.D0 * cPi ) eu ( 2 ) = mod ( eu ( 2 ) + 1 0.D0 * cPi , cPi ) eu ( 3 ) = mod ( eu ( 3 ) + 1 0.D0 * cPi , 2.D0 * cPi ) eu = eu - sh ! and create a cylinder with these points if ( maxval ( abs ( eulast - eu )). lt . cPi ) then call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) end if eulast = eu end do end do end if ! for the Euler representation of the Rodrigues fundamental zones we also need to draw ! a few additional lines to complete the volume appearance of the FZ; this depends on ! the order of the FZ, naturally, so we have a couple of possible cases... ! the diagonal lines in the Phi=0 plane are the most important lines; they should be drawn ! for all the rotation groups except for the identity if (( FZtype . ge . 1 ). and .( FZtype . le . 2 )) then if ( FZorder . ne . 0 ) then ! we have cyclic or dihedral xx = cPi / dble ( FZorder ) ! draw four diagonal lines eu ( 1 : 3 ) = ( / xx , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , 0.D0 , xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi - xx , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , 0.D0 , tpi - xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , xx / ) - sh eulast ( 1 : 3 ) = ( / xx , 0.D0 , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , tpi - xx / ) - sh eulast ( 1 : 3 ) = ( / tpi - xx , 0.D0 , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) ! for cyclic groups we also need to draw the diagonals in the top surface ! and the vertical lines connecting bottom and top planes if ( FZtype . eq . 1 ) then ! top plane eu ( 1 : 3 ) = ( / xx , cPi , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , cPi , xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi - xx , cPi , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , cPi , tpi - xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , cPi , xx / ) - sh eulast ( 1 : 3 ) = ( / xx , cPi , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , cPi , tpi - xx / ) - sh eulast ( 1 : 3 ) = ( / tpi - xx , cPi , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) ! verticals eu ( 1 : 3 ) = ( / xx , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / xx , cPi , 0.D0 / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / 0.D0 , 0.D0 , xx / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , cPi , xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi - xx , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / tpi - xx , cPi , 0.D0 / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / 0.D0 , 0.D0 , tpi - xx / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , cPi , tpi - xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , xx / ) - sh eulast ( 1 : 3 ) = ( / tpi , cPi , xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / xx , 0.D0 , tpi / ) - sh eulast ( 1 : 3 ) = ( / xx , cPi , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , tpi - xx / ) - sh eulast ( 1 : 3 ) = ( / tpi , cPi , tpi - xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi - xx , 0.D0 , tpi / ) - sh eulast ( 1 : 3 ) = ( / tpi - xx , cPi , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) end if if ( FZtype . eq . 2 ) then ! in this case, the verticals need to be drawn but only up to the level of the FZ surface eu ( 1 : 3 ) = ( / xx , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / xx , hPi , 0.D0 / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / 0.D0 , 0.D0 , xx / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , hPi , xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi - xx , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / tpi - xx , hPi , 0.D0 / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / 0.D0 , 0.D0 , tpi - xx / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , hPi , tpi - xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , xx / ) - sh eulast ( 1 : 3 ) = ( / tpi , hPi , xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / xx , 0.D0 , tpi / ) - sh eulast ( 1 : 3 ) = ( / xx , hPi , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , tpi - xx / ) - sh eulast ( 1 : 3 ) = ( / tpi , hPi , tpi - xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi - xx , 0.D0 , tpi / ) - sh eulast ( 1 : 3 ) = ( / tpi - xx , hPi , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) end if end if end if if ( FZtype . eq . 4 ) then xx = cPi / dble ( 4 ) ! draw four diagonal lines eu ( 1 : 3 ) = ( / xx , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , 0.D0 , xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi - xx , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , 0.D0 , tpi - xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , xx / ) - sh eulast ( 1 : 3 ) = ( / xx , 0.D0 , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , tpi - xx / ) - sh eulast ( 1 : 3 ) = ( / tpi - xx , 0.D0 , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) ! and verticals hPi = hPi * 0.5D0 eu ( 1 : 3 ) = ( / xx , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / xx , hPi , 0.D0 / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / 0.D0 , 0.D0 , xx / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , hPi , xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi - xx , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / tpi - xx , hPi , 0.D0 / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / 0.D0 , 0.D0 , tpi - xx / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , hPi , tpi - xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , xx / ) - sh eulast ( 1 : 3 ) = ( / tpi , hPi , xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / xx , 0.D0 , tpi / ) - sh eulast ( 1 : 3 ) = ( / xx , hPi , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , tpi - xx / ) - sh eulast ( 1 : 3 ) = ( / tpi , hPi , tpi - xx / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi - xx , 0.D0 , tpi / ) - sh eulast ( 1 : 3 ) = ( / tpi - xx , hPi , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) ! and the closing segments eu ( 1 : 3 ) = ( / xx , hPi , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , hPi , 0.D0 / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / 0.D0 , hPi , xx / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , hPi , 0.D0 / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi - xx , hPi , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / tpi , hPi , 0.D0 / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / 0.D0 , hPi , tpi - xx / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , hPi , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , hPi , xx / ) - sh eulast ( 1 : 3 ) = ( / tpi , hPi , 0.D0 / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / xx , hPi , tpi / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , hPi , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , hPi , tpi - xx / ) - sh eulast ( 1 : 3 ) = ( / tpi , hPi , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi - xx , hPi , tpi / ) - sh eulast ( 1 : 3 ) = ( / tpi , hPi , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) ! and finally the corner posts eu ( 1 : 3 ) = ( / 0.D0 , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / hPi , 0.D0 , 0.D0 / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / 0.D0 , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , hPi , 0.D0 / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / 0.D0 , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , 0.D0 , hPi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / tpi - hPi , 0.D0 , 0.D0 / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / tpi , hPi , 0.D0 / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , 0.D0 / ) - sh eulast ( 1 : 3 ) = ( / tpi , 0.D0 , hPi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , tpi / ) - sh eulast ( 1 : 3 ) = ( / tpi - hPi , 0.D0 , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , tpi / ) - sh eulast ( 1 : 3 ) = ( / tpi , hPi , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / tpi , 0.D0 , tpi / ) - sh eulast ( 1 : 3 ) = ( / tpi , 0.D0 , tpi - hPi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / 0.D0 , 0.D0 , tpi / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 + hPi , 0.D0 , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / 0.D0 , 0.D0 , tpi / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , hPi , tpi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) eu ( 1 : 3 ) = ( / 0.D0 , 0.D0 , tpi / ) - sh eulast ( 1 : 3 ) = ( / 0.D0 , 0.D0 , tpi - hPi / ) - sh call PoVRay_addCylinder ( dunit , eulast ( 1 : 3 ), eu ( 1 : 3 ), cylr ,( / 1.0 , 0.0 , 0.0 / )) end if end if end subroutine PoVRay_drawFZ","tags":"","loc":"proc/povray_drawfz.html","title":"PoVRay_drawFZ – Fortran Program"},{"text":"public recursive subroutine PoVRay_initFZ2(dunit, rmode) @author Marc De Graef, Carnegie Mellon University\n @brief initialize the PoVRay output for rotational group 2\n @param dunit output unit number\n @param rmode  1(cubochoric)|2(homochoric)|3(stereographic)|4(Rodrigues)\n @date    09/09/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit integer(kind=irg), intent(in) :: rmode Calls proc~~povray_initfz2~~CallsGraph proc~povray_initfz2 PoVRay_initFZ2 float float proc~povray_initfz2->float ro2qu ro2qu proc~povray_initfz2->ro2qu proc~povray_addcylinder PoVRay_addCylinder proc~povray_initfz2->proc~povray_addcylinder proc~povray_addreferenceframe PoVRay_addReferenceFrame proc~povray_initfz2->proc~povray_addreferenceframe proc~povray_addwireframesphere PoVRay_addWireFrameSphere proc~povray_initfz2->proc~povray_addwireframesphere proc~povray_addcubochoriccube PoVRay_addCubochoricCube proc~povray_initfz2->proc~povray_addcubochoriccube ro2cu ro2cu proc~povray_initfz2->ro2cu ro2ho ro2ho proc~povray_initfz2->ro2ho dtan dtan proc~povray_initfz2->dtan proc~povray_addcubochoriccube->proc~povray_addcylinder Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code PoVRay_initFZ2 Source Code recursive subroutine PoVRay_initFZ2 ( dunit , rmode ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_initFZ2 IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit integer ( kind = irg ), INTENT ( IN ) :: rmode real ( kind = dbl ) :: eul ( 3 ), axang ( 4 ), rv ( 3 ), qu ( 4 ), h ( 3 ), rmax , dx , r , xmax , x , y , z , ho ( 3 ), cu ( 3 ), zsmall , & eyepos ( 3 ), ac , dpos ( 200 ), tmp real ( kind = dbl ) :: euld ( 3 ), om ( 3 , 3 ), ro1 ( 4 ), ro2 ( 4 ), culast ( 3 ), holast ( 3 ), ro ( 4 ), rolast ( 4 ), splast ( 3 ), sp ( 3 ), xx type ( orientationtype ) :: ot type ( orientationtyped ) :: otd integer ( kind = irg ) :: i , j , k , icnt , imax , nt , ns , h_edge ( 2 , 100 ) ! the parameter a represents infinity as tan(178°/2) real ( kind = dbl ) :: a = 57 0.289922125538D0 , b = 1.0D0 , c = 1.0D0 , cpos ( 3 , 200 ), dt = 11 4.57984425107713D0 , & ds = 2.0D0 , d = 1.7320508075688772D0 , dd , zz = 0.D0 , oo = 1.D0 , dtor = 0.017453292D0 ! define the coordinates of the monoclinic C2 (2) FZ in Rodrigues Space do i =- 12 , 12 if ( abs ( i ). ne . 12 ) then cpos ( 1 : 3 , 13 + i ) = ( / - a , dtan ( dble ( i ) * 1 5.D0 * dtor * 0.5D0 ) , c / ) else cpos ( 1 : 3 , 13 + i ) = ( / - a , a , c / ) if ( i . lt . 0 ) cpos ( 2 , 13 + i ) = - cpos ( 2 , 13 + i ) end if end do do i = 1 , 25 cpos ( 1 : 3 , 25 + i ) = cpos ( 1 : 3 , i ) cpos ( 1 , 25 + i ) = - cpos ( 1 , 25 + i ) end do do i = 1 , 50 cpos ( 1 : 3 , 50 + i ) = cpos ( 1 : 3 , i ) tmp = cpos ( 1 , 50 + i ) cpos ( 1 , 50 + i ) = cpos ( 2 , 50 + i ) cpos ( 2 , 50 + i ) = tmp end do do i = 1 , 100 cpos ( 1 : 3 , 100 + i ) = cpos ( 1 : 3 , i ) cpos ( 3 , 100 + i ) = - cpos ( 3 , 100 + i ) end do ! and normalize do i = 1 , 200 dpos ( i ) = dsqrt ( sum ( cpos ( 1 : 3 , i ) * cpos ( 1 : 3 , i ))) end do ns = 2000 dx = dt / float ( ns - 1 ) ! define the connectivity of all the edges do i = 1 , 25 h_edge ( 1 : 2 , i ) = ( / i , 25 + i / ) h_edge ( 1 : 2 , 25 + i ) = ( / 50 + i , 75 + i / ) h_edge ( 1 : 2 , 50 + i ) = ( / 100 + i , 125 + i / ) h_edge ( 1 : 2 , 75 + i ) = ( / 150 + i , 175 + i / ) end do ! first add the reference frame and any necessary wireframe diagrams if ( rmode . eq . 1 ) then ac = 0.5D0 * LPs % ap call PoVRay_addReferenceFrame ( dunit , ac ) call PoVRay_addCubochoricCube ( dunit ) end if if ( rmode . eq . 2 ) then ac = 1.33067D0 call PoVRay_addReferenceFrame ( dunit , ac ) call PoVRay_addWireFrameSphere ( dunit , ac ) end if if ( rmode . eq . 3 ) then ac = 1.0D0 call PoVRay_addReferenceFrame ( dunit , ac ) call PoVRay_addWireFrameSphere ( dunit , ac ) end if if ( rmode . eq . 4 ) then ac = 1.0D0 call PoVRay_addReferenceFrame ( dunit , ac ) end if if (( rmode . eq . 1 ). or .( rmode . eq . 2 )) then ! create the top and bottom planes first dx = 1.D0 / dble ( ns ) do i = 1 , 100 ro1 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 1 , i )) / dpos ( i ) ro1 ( 4 ) = dpos ( i ) ro2 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 2 , i )) / dpos ( i ) ro2 ( 4 ) = dpos ( i ) culast = ro2cu ( ro1 ) holast = ro2ho ( ro1 ) do j = 1 , ns + 1 ro ( 1 : 3 ) = dpos ( i ) * ro1 ( 1 : 3 ) + dpos ( i ) * ( ro2 ( 1 : 3 ) - ro1 ( 1 : 3 )) * j * dx xx = dsqrt ( sum ( ro ( 1 : 3 ) ** 2 ) ) ro ( 1 : 3 ) = ro ( 1 : 3 ) / xx ro ( 4 ) = xx cu = ro2cu ( ro ) ho = ro2ho ( ro ) ! and create a cylinder with these points if ( rmode . eq . 1 ) then call PoVRay_addCylinder ( dunit , culast ( 1 : 3 ), cu ( 1 : 3 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) else call PoVRay_addCylinder ( dunit , holast ( 1 : 3 ), ho ( 1 : 3 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) end if culast = cu holast = ho end do end do end if if (( rmode . eq . 3 ). or .( rmode . eq . 4 )) then ! create the square edges first dx = 1.D0 / dble ( ns ) do i = 1 , 100 ro1 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 1 , i )) / dpos ( i ) ro1 ( 4 ) = dpos ( i ) ro2 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 2 , i )) / dpos ( i ) ro2 ( 4 ) = dpos ( i ) rolast = ro1 qu = ro2qu ( ro1 ) splast ( 1 : 3 ) = qu ( 2 : 4 ) / ( 1.D0 + qu ( 1 )) do j = 1 , ns + 1 ro ( 1 : 3 ) = dpos ( i ) * ro1 ( 1 : 3 ) + dpos ( i ) * ( ro2 ( 1 : 3 ) - ro1 ( 1 : 3 )) * j * dx xx = dsqrt ( sum ( ro ( 1 : 3 ) ** 2 ) ) ro ( 1 : 3 ) = ro ( 1 : 3 ) / xx ro ( 4 ) = xx qu = ro2qu ( ro ) sp ( 1 : 3 ) = qu ( 2 : 4 ) / ( 1.D0 + qu ( 1 )) ! and create a cylinder with these points if ( rmode . eq . 3 ) then call PoVRay_addCylinder ( dunit , splast ( 1 : 3 ), sp ( 1 : 3 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) else call PoVRay_addCylinder ( dunit , rolast ( 1 : 3 ) * rolast ( 4 ), ro ( 1 : 3 ) * ro ( 4 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) end if rolast = ro splast = sp end do end do end if end subroutine PoVRay_initFZ2","tags":"","loc":"proc/povray_initfz2.html","title":"PoVRay_initFZ2 – Fortran Program"},{"text":"public recursive subroutine PoVRay_initFZ3(dunit, rmode) @author Marc De Graef, Carnegie Mellon University\n @brief initialize the PoVRay output for rotational group 3\n @param dunit output unit number\n @param rmode  1(cubochoric)|2(homochoric)|3(stereographic)|4(Rodrigues)\n @date    09/09/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit integer(kind=irg), intent(in) :: rmode Calls proc~~povray_initfz3~~CallsGraph proc~povray_initfz3 PoVRay_initFZ3 float float proc~povray_initfz3->float ro2qu ro2qu proc~povray_initfz3->ro2qu proc~povray_addcylinder PoVRay_addCylinder proc~povray_initfz3->proc~povray_addcylinder proc~povray_addreferenceframe PoVRay_addReferenceFrame proc~povray_initfz3->proc~povray_addreferenceframe proc~povray_addwireframesphere PoVRay_addWireFrameSphere proc~povray_initfz3->proc~povray_addwireframesphere proc~povray_addcubochoriccube PoVRay_addCubochoricCube proc~povray_initfz3->proc~povray_addcubochoriccube ro2cu ro2cu proc~povray_initfz3->ro2cu ro2ho ro2ho proc~povray_initfz3->ro2ho dtan dtan proc~povray_initfz3->dtan proc~povray_addcubochoriccube->proc~povray_addcylinder Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code PoVRay_initFZ3 Source Code recursive subroutine PoVRay_initFZ3 ( dunit , rmode ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_initFZ3 IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit integer ( kind = irg ), INTENT ( IN ) :: rmode real ( kind = dbl ) :: eul ( 3 ), axang ( 4 ), rv ( 3 ), qu ( 4 ), h ( 3 ), rmax , dx , r , xmax , x , y , z , ho ( 3 ), cu ( 3 ), zsmall , & eyepos ( 3 ), ac , dpos ( 208 ), tmp real ( kind = dbl ) :: euld ( 3 ), om ( 3 , 3 ), ro1 ( 4 ), ro2 ( 4 ), culast ( 3 ), holast ( 3 ), ro ( 4 ), rolast ( 4 ), splast ( 3 ), sp ( 3 ), xx type ( orientationtype ) :: ot type ( orientationtyped ) :: otd integer ( kind = irg ) :: i , j , k , icnt , imax , nt , ns , h_edge ( 2 , 104 ) ! the parameter a represents infinity as tan(178°/2) real ( kind = dbl ) :: a = 5 7.289922125538D0 , b = 1.0D0 , c = 0.577350269120D0 , cpos ( 3 , 208 ), dt = 11 4.57984425107713D0 , & ds = 2.0D0 , d = 1.7320508075688772D0 , dd , zz = 0.D0 , oo = 1.D0 , dtor = 0.017453292D0 , & c2 = 1.7320508075688767D0 ! define the coordinates of the trigonal C3 (3) FZ in Rodrigues Space do i =- 6 , 6 if ( abs ( i ). ne . 6 ) then cpos ( 1 : 3 , 7 + i ) = ( / - a , dtan ( dble ( i ) * 3 0.D0 * dtor * 0.5D0 ) , c / ) else cpos ( 1 : 3 , 7 + i ) = ( / - a , a , c / ) if ( i . lt . 0 ) cpos ( 2 , 7 + i ) = - cpos ( 2 , 7 + i ) end if end do do i = 1 , 13 cpos ( 1 : 3 , 13 + i ) = cpos ( 1 : 3 , i ) cpos ( 1 , 13 + i ) = - cpos ( 1 , 13 + i ) end do do i = 1 , 26 cpos ( 1 : 3 , 26 + i ) = cpos ( 1 : 3 , i ) tmp = cpos ( 1 , 26 + i ) cpos ( 1 , 26 + i ) = cpos ( 2 , 26 + i ) cpos ( 2 , 26 + i ) = tmp end do do i = 1 , 52 cpos ( 1 : 3 , 52 + i ) = cpos ( 1 : 3 , i ) cpos ( 3 , 52 + i ) = - cpos ( 3 , 52 + i ) end do do i = 1 , 104 cpos ( 1 : 3 , 104 + i ) = cpos ( 1 : 3 , i ) if ( cpos ( 3 , 104 + i ). lt . 0.D0 ) then cpos ( 3 , 104 + i ) = - c2 else cpos ( 3 , 104 + i ) = c2 end if end do ! and normalize do i = 1 , 208 dpos ( i ) = dsqrt ( sum ( cpos ( 1 : 3 , i ) * cpos ( 1 : 3 , i ))) end do ns = 200 dx = dt / float ( ns - 1 ) ! define the connectivity of all the edges do i = 1 , 13 h_edge ( 1 : 2 , i ) = ( / i , 13 + i / ) h_edge ( 1 : 2 , 13 + i ) = ( / 26 + i , 39 + i / ) h_edge ( 1 : 2 , 26 + i ) = ( / 52 + i , 65 + i / ) h_edge ( 1 : 2 , 39 + i ) = ( / 78 + i , 91 + i / ) h_edge ( 1 : 2 , 52 + i ) = ( / 104 + i , 117 + i / ) h_edge ( 1 : 2 , 65 + i ) = ( / 130 + i , 143 + i / ) h_edge ( 1 : 2 , 78 + i ) = ( / 156 + i , 169 + i / ) h_edge ( 1 : 2 , 91 + i ) = ( / 182 + i , 195 + i / ) end do ! first add the reference frame and any necessary wireframe diagrams if ( rmode . eq . 1 ) then ac = 0.5D0 * LPs % ap call PoVRay_addReferenceFrame ( dunit , ac ) call PoVRay_addCubochoricCube ( dunit ) end if if ( rmode . eq . 2 ) then ac = 1.33067D0 call PoVRay_addReferenceFrame ( dunit , ac ) call PoVRay_addWireFrameSphere ( dunit , ac ) end if if ( rmode . eq . 3 ) then ac = 1.0D0 call PoVRay_addReferenceFrame ( dunit , ac ) call PoVRay_addWireFrameSphere ( dunit , ac ) end if if ( rmode . eq . 4 ) then ac = 1.0D0 call PoVRay_addReferenceFrame ( dunit , ac ) end if if (( rmode . eq . 1 ). or .( rmode . eq . 2 )) then ! create the top and bottom planes first dx = 1.D0 / dble ( ns ) do i = 1 , 104 ro1 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 1 , i )) / dpos ( i ) ro1 ( 4 ) = dpos ( i ) ro2 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 2 , i )) / dpos ( i ) ro2 ( 4 ) = dpos ( i ) culast = ro2cu ( ro1 ) holast = ro2ho ( ro1 ) do j = 1 , ns + 1 ro ( 1 : 3 ) = dpos ( i ) * ro1 ( 1 : 3 ) + dpos ( i ) * ( ro2 ( 1 : 3 ) - ro1 ( 1 : 3 )) * j * dx xx = dsqrt ( sum ( ro ( 1 : 3 ) ** 2 ) ) ro ( 1 : 3 ) = ro ( 1 : 3 ) / xx ro ( 4 ) = xx cu = ro2cu ( ro ) ho = ro2ho ( ro ) ! and create a cylinder with these points if ( rmode . eq . 1 ) then call PoVRay_addCylinder ( dunit , culast ( 1 : 3 ), cu ( 1 : 3 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) else call PoVRay_addCylinder ( dunit , holast ( 1 : 3 ), ho ( 1 : 3 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) end if culast = cu holast = ho end do end do end if if (( rmode . eq . 3 ). or .( rmode . eq . 4 )) then ! create the square edges first dx = 1.D0 / dble ( ns ) do i = 1 , 104 ro1 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 1 , i )) / dpos ( i ) ro1 ( 4 ) = dpos ( i ) ro2 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 2 , i )) / dpos ( i ) ro2 ( 4 ) = dpos ( i ) rolast = ro1 qu = ro2qu ( ro1 ) splast ( 1 : 3 ) = qu ( 2 : 4 ) / ( 1.D0 + qu ( 1 )) do j = 1 , ns + 1 ro ( 1 : 3 ) = dpos ( i ) * ro1 ( 1 : 3 ) + dpos ( i ) * ( ro2 ( 1 : 3 ) - ro1 ( 1 : 3 )) * j * dx xx = dsqrt ( sum ( ro ( 1 : 3 ) ** 2 ) ) ro ( 1 : 3 ) = ro ( 1 : 3 ) / xx ro ( 4 ) = xx qu = ro2qu ( ro ) sp ( 1 : 3 ) = qu ( 2 : 4 ) / ( 1.D0 + qu ( 1 )) ! and create a cylinder with these points if ( rmode . eq . 3 ) then call PoVRay_addCylinder ( dunit , splast ( 1 : 3 ), sp ( 1 : 3 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) else call PoVRay_addCylinder ( dunit , rolast ( 1 : 3 ) * rolast ( 4 ), ro ( 1 : 3 ) * ro ( 4 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) end if rolast = ro splast = sp end do end do end if end subroutine PoVRay_initFZ3","tags":"","loc":"proc/povray_initfz3.html","title":"PoVRay_initFZ3 – Fortran Program"},{"text":"public recursive subroutine PoVRay_initFZ4(dunit, rmode) @author Marc De Graef, Carnegie Mellon University\n @brief initialize the PoVRay output for rotational group 4\n @param dunit output unit number\n @param rmode  1(cubochoric)|2(homochoric)|3(stereographic)|4(Rodrigues)\n @date    09/09/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit integer(kind=irg), intent(in) :: rmode Calls proc~~povray_initfz4~~CallsGraph proc~povray_initfz4 PoVRay_initFZ4 float float proc~povray_initfz4->float ro2qu ro2qu proc~povray_initfz4->ro2qu proc~povray_addcylinder PoVRay_addCylinder proc~povray_initfz4->proc~povray_addcylinder proc~povray_addreferenceframe PoVRay_addReferenceFrame proc~povray_initfz4->proc~povray_addreferenceframe proc~povray_addwireframesphere PoVRay_addWireFrameSphere proc~povray_initfz4->proc~povray_addwireframesphere proc~povray_addcubochoriccube PoVRay_addCubochoricCube proc~povray_initfz4->proc~povray_addcubochoriccube ro2cu ro2cu proc~povray_initfz4->ro2cu ro2ho ro2ho proc~povray_initfz4->ro2ho dtan dtan proc~povray_initfz4->dtan proc~povray_addcubochoriccube->proc~povray_addcylinder Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code PoVRay_initFZ4 Source Code recursive subroutine PoVRay_initFZ4 ( dunit , rmode ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_initFZ4 IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit integer ( kind = irg ), INTENT ( IN ) :: rmode real ( kind = dbl ) :: eul ( 3 ), axang ( 4 ), rv ( 3 ), qu ( 4 ), h ( 3 ), rmax , dx , r , xmax , x , y , z , ho ( 3 ), cu ( 3 ), zsmall , & eyepos ( 3 ), ac , dpos ( 104 ), tmp real ( kind = dbl ) :: euld ( 3 ), om ( 3 , 3 ), ro1 ( 4 ), ro2 ( 4 ), culast ( 3 ), holast ( 3 ), ro ( 4 ), rolast ( 4 ), splast ( 3 ), sp ( 3 ), xx type ( orientationtype ) :: ot type ( orientationtyped ) :: otd integer ( kind = irg ) :: i , j , k , icnt , imax , nt , ns , h_edge ( 2 , 52 ) ! the parameter a represents infinity as tan(178°/2) real ( kind = dbl ) :: a = 5 7.289922125538D0 , b = 1.0D0 , c = 1.0D0 , cpos ( 3 , 104 ), dt = 11 4.57984425107713D0 , & ds = 2.0D0 , d = 1.7320508075688772D0 , dd , zz = 0.D0 , oo = 1.D0 , dtor = 0.017453292D0 ! define the coordinates of the tetragonal C4 (4) FZ in Rodrigues Space do i =- 6 , 6 if ( abs ( i ). ne . 6 ) then cpos ( 1 : 3 , 7 + i ) = ( / - a , dtan ( dble ( i ) * 3 0.D0 * dtor * 0.5D0 ) , c / ) else cpos ( 1 : 3 , 7 + i ) = ( / - a , a , c / ) if ( i . lt . 0 ) cpos ( 2 , 7 + i ) = - cpos ( 2 , 7 + i ) end if end do do i = 1 , 13 cpos ( 1 : 3 , 13 + i ) = cpos ( 1 : 3 , i ) cpos ( 1 , 13 + i ) = - cpos ( 1 , 13 + i ) end do do i = 1 , 26 cpos ( 1 : 3 , 26 + i ) = cpos ( 1 : 3 , i ) tmp = cpos ( 1 , 26 + i ) cpos ( 1 , 26 + i ) = cpos ( 2 , 26 + i ) cpos ( 2 , 26 + i ) = tmp end do do i = 1 , 52 cpos ( 1 : 3 , 52 + i ) = cpos ( 1 : 3 , i ) cpos ( 3 , 52 + i ) = - cpos ( 3 , 52 + i ) end do ! and normalize do i = 1 , 104 dpos ( i ) = dsqrt ( sum ( cpos ( 1 : 3 , i ) * cpos ( 1 : 3 , i ))) end do ns = 200 dx = dt / float ( ns - 1 ) ! define the connectivity of all the edges do i = 1 , 13 h_edge ( 1 : 2 , i ) = ( / i , 13 + i / ) h_edge ( 1 : 2 , 13 + i ) = ( / 26 + i , 39 + i / ) h_edge ( 1 : 2 , 26 + i ) = ( / 52 + i , 65 + i / ) h_edge ( 1 : 2 , 39 + i ) = ( / 78 + i , 91 + i / ) end do ! first add the reference frame and any necessary wireframe diagrams if ( rmode . eq . 1 ) then ac = 0.5D0 * LPs % ap call PoVRay_addReferenceFrame ( dunit , ac ) call PoVRay_addCubochoricCube ( dunit ) end if if ( rmode . eq . 2 ) then ac = 1.33067D0 call PoVRay_addReferenceFrame ( dunit , ac ) call PoVRay_addWireFrameSphere ( dunit , ac ) end if if ( rmode . eq . 3 ) then ac = 1.0D0 call PoVRay_addReferenceFrame ( dunit , ac ) call PoVRay_addWireFrameSphere ( dunit , ac ) end if if ( rmode . eq . 4 ) then ac = 1.0D0 call PoVRay_addReferenceFrame ( dunit , ac ) end if if (( rmode . eq . 1 ). or .( rmode . eq . 2 )) then ! create the top and bottom planes first dx = 1.D0 / dble ( ns ) do i = 1 , 52 ro1 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 1 , i )) / dpos ( i ) ro1 ( 4 ) = dpos ( i ) ro2 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 2 , i )) / dpos ( i ) ro2 ( 4 ) = dpos ( i ) culast = ro2cu ( ro1 ) holast = ro2ho ( ro1 ) do j = 1 , ns + 1 ro ( 1 : 3 ) = dpos ( i ) * ro1 ( 1 : 3 ) + dpos ( i ) * ( ro2 ( 1 : 3 ) - ro1 ( 1 : 3 )) * j * dx xx = dsqrt ( sum ( ro ( 1 : 3 ) ** 2 ) ) ro ( 1 : 3 ) = ro ( 1 : 3 ) / xx ro ( 4 ) = xx cu = ro2cu ( ro ) ho = ro2ho ( ro ) ! and create a cylinder with these points if ( rmode . eq . 1 ) then call PoVRay_addCylinder ( dunit , culast ( 1 : 3 ), cu ( 1 : 3 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) else call PoVRay_addCylinder ( dunit , holast ( 1 : 3 ), ho ( 1 : 3 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) end if culast = cu holast = ho end do end do end if if (( rmode . eq . 3 ). or .( rmode . eq . 4 )) then ! create the square edges first dx = 1.D0 / dble ( ns ) do i = 1 , 52 ro1 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 1 , i )) / dpos ( i ) ro1 ( 4 ) = dpos ( i ) ro2 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 2 , i )) / dpos ( i ) ro2 ( 4 ) = dpos ( i ) rolast = ro1 qu = ro2qu ( ro1 ) splast ( 1 : 3 ) = qu ( 2 : 4 ) / ( 1.D0 + qu ( 1 )) do j = 1 , ns + 1 ro ( 1 : 3 ) = dpos ( i ) * ro1 ( 1 : 3 ) + dpos ( i ) * ( ro2 ( 1 : 3 ) - ro1 ( 1 : 3 )) * j * dx xx = dsqrt ( sum ( ro ( 1 : 3 ) ** 2 ) ) ro ( 1 : 3 ) = ro ( 1 : 3 ) / xx ro ( 4 ) = xx qu = ro2qu ( ro ) sp ( 1 : 3 ) = qu ( 2 : 4 ) / ( 1.D0 + qu ( 1 )) ! and create a cylinder with these points if ( rmode . eq . 3 ) then call PoVRay_addCylinder ( dunit , splast ( 1 : 3 ), sp ( 1 : 3 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) else call PoVRay_addCylinder ( dunit , rolast ( 1 : 3 ) * rolast ( 4 ), ro ( 1 : 3 ) * ro ( 4 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) end if rolast = ro splast = sp end do end do end if end subroutine PoVRay_initFZ4","tags":"","loc":"proc/povray_initfz4.html","title":"PoVRay_initFZ4 – Fortran Program"},{"text":"public recursive subroutine PoVRay_initFZ6(dunit, rmode) @author Marc De Graef, Carnegie Mellon University\n @brief initialize the PoVRay output for rotational group 6\n @param dunit output unit number\n @param rmode  1(cubochoric)|2(homochoric)|3(stereographic)|4(Rodrigues)\n @date    09/09/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit integer(kind=irg), intent(in) :: rmode Calls proc~~povray_initfz6~~CallsGraph proc~povray_initfz6 PoVRay_initFZ6 float float proc~povray_initfz6->float ro2qu ro2qu proc~povray_initfz6->ro2qu proc~povray_addcylinder PoVRay_addCylinder proc~povray_initfz6->proc~povray_addcylinder proc~povray_addreferenceframe PoVRay_addReferenceFrame proc~povray_initfz6->proc~povray_addreferenceframe proc~povray_addwireframesphere PoVRay_addWireFrameSphere proc~povray_initfz6->proc~povray_addwireframesphere proc~povray_addcubochoriccube PoVRay_addCubochoricCube proc~povray_initfz6->proc~povray_addcubochoriccube ro2cu ro2cu proc~povray_initfz6->ro2cu ro2ho ro2ho proc~povray_initfz6->ro2ho dtan dtan proc~povray_initfz6->dtan proc~povray_addcubochoriccube->proc~povray_addcylinder Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code PoVRay_initFZ6 Source Code recursive subroutine PoVRay_initFZ6 ( dunit , rmode ) !DEC$ ATTRIBUTES DLLEXPORT :: PoVRay_initFZ6 IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: dunit integer ( kind = irg ), INTENT ( IN ) :: rmode real ( kind = dbl ) :: eul ( 3 ), axang ( 4 ), rv ( 3 ), qu ( 4 ), h ( 3 ), rmax , dx , r , xmax , x , y , z , ho ( 3 ), cu ( 3 ), zsmall , & eyepos ( 3 ), ac , dpos ( 104 ), tmp real ( kind = dbl ) :: euld ( 3 ), om ( 3 , 3 ), ro1 ( 4 ), ro2 ( 4 ), culast ( 3 ), holast ( 3 ), ro ( 4 ), rolast ( 4 ), splast ( 3 ), sp ( 3 ), xx type ( orientationtype ) :: ot type ( orientationtyped ) :: otd integer ( kind = irg ) :: i , j , k , icnt , imax , nt , ns , h_edge ( 2 , 52 ) ! the parameter a represents infinity as tan(178°/2) real ( kind = dbl ) :: a = 5 7.289922125538D0 , b = 1.0D0 , c = 1.0D0 , cpos ( 3 , 104 ), dt = 11 4.57984425107713D0 , & ds = 2.0D0 , d = 1.7320508075688772D0 , dd , zz = 0.D0 , oo = 1.D0 , dtor = 0.017453292D0 ! define the coordinates of the hexagonal C6 (6) FZ in Rodrigues Space do i =- 6 , 6 if ( abs ( i ). ne . 6 ) then cpos ( 1 : 3 , 7 + i ) = ( / - a , dtan ( dble ( i ) * 3 0.D0 * dtor * 0.5D0 ) , c / ) else cpos ( 1 : 3 , 7 + i ) = ( / - a , a , c / ) if ( i . lt . 0 ) cpos ( 2 , 7 + i ) = - cpos ( 2 , 7 + i ) end if end do do i = 1 , 13 cpos ( 1 : 3 , 13 + i ) = cpos ( 1 : 3 , i ) cpos ( 1 , 13 + i ) = - cpos ( 1 , 13 + i ) end do do i = 1 , 26 cpos ( 1 : 3 , 26 + i ) = cpos ( 1 : 3 , i ) tmp = cpos ( 1 , 26 + i ) cpos ( 1 , 26 + i ) = cpos ( 2 , 26 + i ) cpos ( 2 , 26 + i ) = tmp end do do i = 1 , 52 cpos ( 1 : 3 , 52 + i ) = cpos ( 1 : 3 , i ) cpos ( 3 , 52 + i ) = - cpos ( 3 , 52 + i ) end do ! and normalize do i = 1 , 104 dpos ( i ) = dsqrt ( sum ( cpos ( 1 : 3 , i ) * cpos ( 1 : 3 , i ))) end do ns = 200 dx = dt / float ( ns - 1 ) ! define the connectivity of all the edges do i = 1 , 13 h_edge ( 1 : 2 , i ) = ( / i , 13 + i / ) h_edge ( 1 : 2 , 13 + i ) = ( / 26 + i , 39 + i / ) h_edge ( 1 : 2 , 26 + i ) = ( / 52 + i , 65 + i / ) h_edge ( 1 : 2 , 39 + i ) = ( / 78 + i , 91 + i / ) end do ! first add the reference frame and any necessary wireframe diagrams if ( rmode . eq . 1 ) then ac = 0.5D0 * LPs % ap call PoVRay_addReferenceFrame ( dunit , ac ) call PoVRay_addCubochoricCube ( dunit ) end if if ( rmode . eq . 2 ) then ac = 1.33067D0 call PoVRay_addReferenceFrame ( dunit , ac ) call PoVRay_addWireFrameSphere ( dunit , ac ) end if if ( rmode . eq . 3 ) then ac = 1.0D0 call PoVRay_addReferenceFrame ( dunit , ac ) call PoVRay_addWireFrameSphere ( dunit , ac ) end if if ( rmode . eq . 4 ) then ac = 1.0D0 call PoVRay_addReferenceFrame ( dunit , ac ) end if if (( rmode . eq . 1 ). or .( rmode . eq . 2 )) then ! create the top and bottom planes first dx = 1.D0 / dble ( ns ) do i = 1 , 52 ro1 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 1 , i )) / dpos ( i ) ro1 ( 4 ) = dpos ( i ) ro2 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 2 , i )) / dpos ( i ) ro2 ( 4 ) = dpos ( i ) culast = ro2cu ( ro1 ) holast = ro2ho ( ro1 ) do j = 1 , ns + 1 ro ( 1 : 3 ) = dpos ( i ) * ro1 ( 1 : 3 ) + dpos ( i ) * ( ro2 ( 1 : 3 ) - ro1 ( 1 : 3 )) * j * dx xx = dsqrt ( sum ( ro ( 1 : 3 ) ** 2 ) ) ro ( 1 : 3 ) = ro ( 1 : 3 ) / xx ro ( 4 ) = xx cu = ro2cu ( ro ) ho = ro2ho ( ro ) ! and create a cylinder with these points if ( rmode . eq . 1 ) then call PoVRay_addCylinder ( dunit , culast ( 1 : 3 ), cu ( 1 : 3 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) else call PoVRay_addCylinder ( dunit , holast ( 1 : 3 ), ho ( 1 : 3 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) end if culast = cu holast = ho end do end do end if if (( rmode . eq . 3 ). or .( rmode . eq . 4 )) then ! create the square edges first dx = 1.D0 / dble ( ns ) do i = 1 , 52 ro1 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 1 , i )) / dpos ( i ) ro1 ( 4 ) = dpos ( i ) ro2 ( 1 : 3 ) = cpos ( 1 : 3 , h_edge ( 2 , i )) / dpos ( i ) ro2 ( 4 ) = dpos ( i ) rolast = ro1 qu = ro2qu ( ro1 ) splast ( 1 : 3 ) = qu ( 2 : 4 ) / ( 1.D0 + qu ( 1 )) do j = 1 , ns + 1 ro ( 1 : 3 ) = dpos ( i ) * ro1 ( 1 : 3 ) + dpos ( i ) * ( ro2 ( 1 : 3 ) - ro1 ( 1 : 3 )) * j * dx xx = dsqrt ( sum ( ro ( 1 : 3 ) ** 2 ) ) ro ( 1 : 3 ) = ro ( 1 : 3 ) / xx ro ( 4 ) = xx qu = ro2qu ( ro ) sp ( 1 : 3 ) = qu ( 2 : 4 ) / ( 1.D0 + qu ( 1 )) ! and create a cylinder with these points if ( rmode . eq . 3 ) then call PoVRay_addCylinder ( dunit , splast ( 1 : 3 ), sp ( 1 : 3 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) else call PoVRay_addCylinder ( dunit , rolast ( 1 : 3 ) * rolast ( 4 ), ro ( 1 : 3 ) * ro ( 4 ), 0.005D0 ,( / 0.0 , 0.0 , 1.0 / )) end if rolast = ro splast = sp end do end do end if end subroutine PoVRay_initFZ6","tags":"","loc":"proc/povray_initfz6.html","title":"PoVRay_initFZ6 – Fortran Program"},{"text":"public recursive function rng_uniform(self) result(u) Arguments Type Intent Optional Attributes Name type( rng_t ), intent(inout) :: self Return Value real Source Code rng_uniform Source Code recursive function rng_uniform ( self ) result ( u ) !DEC$ ATTRIBUTES DLLEXPORT :: rng_uniform type ( rng_t ), intent ( inout ) :: self real :: u integer :: imz imz = self % state ( 1 ) - self % state ( 3 ) if ( imz < 0 ) imz = imz + 2147483579 self % state ( 1 ) = self % state ( 2 ) self % state ( 2 ) = self % state ( 3 ) self % state ( 3 ) = imz self % state ( 4 ) = 69069 * self % state ( 4 ) + 1013904243 imz = imz + self % state ( 4 ) u = 0.5d0 + 0.23283064d-9 * imz end function rng_uniform","tags":"","loc":"proc/rng_uniform.html","title":"rng_uniform – Fortran Program"},{"text":"public recursive subroutine rng_seed(self, seed) Arguments Type Intent Optional Attributes Name type( rng_t ), intent(inout) :: self integer, intent(in) :: seed Source Code rng_seed Source Code recursive subroutine rng_seed ( self , seed ) !DEC$ ATTRIBUTES DLLEXPORT :: rng_seed type ( rng_t ), intent ( inout ) :: self integer , intent ( in ) :: seed self % state ( 1 ) = seed self % state ( 2 : ns ) = default_seed ( 2 : ns ) end subroutine rng_seed","tags":"","loc":"proc/rng_seed.html","title":"rng_seed – Fortran Program"},{"text":"public recursive subroutine linesearchbox_cont(n, x, f, d, alfa, alfa_d, z, fz, i_corr, num_fal, alfa_max, iprint, bl, bu, ipar, fparebsd, initmeanval, ninit, nipar, nfpar, expt, accum_e, mLPNH, mLPSH, verbose, calfun) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: x (n) real(kind=8) :: f real(kind=8) :: d (n) real(kind=8) :: alfa real(kind=8) :: alfa_d (n) real(kind=8) :: z (n) real(kind=8) :: fz integer :: i_corr integer :: num_fal real(kind=8) :: alfa_max integer :: iprint real(kind=8) :: bl (n) real(kind=8) :: bu (n) integer(kind=8), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fparebsd (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) integer(kind=irg), intent(in) :: ninit integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar real(kind=sgl), intent(in) :: expt (ipar(2)*ipar(3)) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) logical, intent(in), optional :: verbose procedure( func ) :: calfun Called By proc~~linesearchbox_cont~~CalledByGraph proc~linesearchbox_cont linesearchbox_cont proc~mainbox1 MAINBOX1 proc~mainbox1->proc~linesearchbox_cont proc~mainbox2 MAINBOX2 proc~mainbox2->proc~linesearchbox_cont proc~ricerca_lungo_assi RICERCA_LUNGO_ASSI proc~ricerca_lungo_assi->proc~mainbox1 proc~senzaderglob SENZADERGLOB proc~senzaderglob->proc~ricerca_lungo_assi proc~interfaccia INTERFACCIA proc~senzaderglob->proc~interfaccia proc~interfaccia->proc~mainbox2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Common Blocks NUMNEW Common Blocks common /NUMNEW/ Type Attributes Name Initial integer :: NF $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/linesearchbox_cont.html","title":"linesearchbox_cont – Fortran Program"},{"text":"public subroutine SENZADERGLOB(ipar, fparebsd, initmeanval, ninit, nipar, nfpar, expt, accum_e, mLPNH, mLPSH, verbose, calfun, N, XSUP, XINF) Uses: typedefs proc~~senzaderglob~~UsesGraph proc~senzaderglob SENZADERGLOB typedefs typedefs typedefs->proc~senzaderglob Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name integer(kind=8), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fparebsd (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) integer(kind=irg), intent(in) :: ninit integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar real(kind=sgl), intent(in) :: expt (ipar(2)*ipar(3)) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) logical, intent(in), optional :: verbose procedure( func ) :: calfun integer :: N double precision, intent(in) :: XSUP (N) double precision, intent(in) :: XINF (N) Calls proc~~senzaderglob~~CallsGraph proc~senzaderglob SENZADERGLOB proc~qsortd qsortd proc~senzaderglob->proc~qsortd proc~genera_punto_sa GENERA_PUNTO_SA proc~senzaderglob->proc~genera_punto_sa 3 3 proc~senzaderglob->3 dexp dexp proc~senzaderglob->dexp proc~aggiorno_ottimo AGGIORNO_OTTIMO proc~senzaderglob->proc~aggiorno_ottimo proc~ricerca_lungo_assi RICERCA_LUNGO_ASSI proc~senzaderglob->proc~ricerca_lungo_assi proc~interfaccia INTERFACCIA proc~senzaderglob->proc~interfaccia proc~genera_punto_sa->dexp proc~mainbox1 MAINBOX1 proc~ricerca_lungo_assi->proc~mainbox1 proc~mainbox2 MAINBOX2 proc~interfaccia->proc~mainbox2 proc~linesearchbox_cont linesearchbox_cont proc~mainbox1->proc~linesearchbox_cont dfloat dfloat proc~mainbox1->dfloat proc~mainbox2->proc~linesearchbox_cont Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Common Blocks NUMNEW2 CALFANR2 Source Code SENZADERGLOB Common Blocks common /NUMNEW2/ Type Attributes Name Initial integer :: NF common /CALFANR2/ Type Attributes Name Initial integer :: NORMADUE $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      }) Source Code SUBROUTINE SENZADERGLOB ( ipar , fparebsd , initmeanval , ninit , nipar , nfpar ,& expt , accum_e , mLPNH , mLPSH , verbose , calfun , N , XSUP , XINF ) !USE IMSLF90 use typedefs IMPLICIT NONE INTEGER , PARAMETER :: IRUNS = 10 PROCEDURE ( func ) :: calfun integer ( 8 ), intent ( in ) :: ipar ( nipar ) real ( sgl ), intent ( inout ) :: fparebsd ( nfpar ) real ( sgl ), intent ( in ) :: initmeanval ( ninit ) integer ( irg ), intent ( in ) :: ninit integer ( irg ), intent ( in ) :: nipar integer ( irg ), intent ( in ) :: nfpar real ( sgl ), intent ( in ) :: expt ( ipar ( 2 ) * ipar ( 3 )) real ( sgl ), intent ( in ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( sgl ), intent ( in ) :: mLPNH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) real ( sgl ), intent ( in ) :: mLPSH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) logical , intent ( in ), optional :: verbose DOUBLE PRECISION , INTENT ( IN ) :: XINF ( N ), XSUP ( N ) !\tINCLUDE 'TYPEDECL.FI' INTEGER :: N , NF , NFAILS , IDIMWKS , NUMFAL , IOTT , ISTOP INTEGER :: VECTNF ( IRUNS ), VECTNFOTT ( IRUNS ) INTEGER :: LSTOT , NFTOT , NPCTOT , NLMTOT , IT , IMAX INTEGER :: LS , NPC , NLM , ICONTFAL , IDFAL , NUMITER INTEGER :: NUMCAS , K , I , J , MAXLS , MODLS INTEGER :: MAXITER , MAXNF , PRINT_LEVEL , nfott , SUMNF INTEGER * 4 :: IVAR , IVAR2 TYPE ( COMP_WKS_TYP ), ALLOCATABLE :: WKS (:) DOUBLE PRECISION , ALLOCATABLE :: X (:), XOTT (:), DOLDALFA (:) DOUBLE PRECISION , ALLOCATABLE :: Z (:), VETT (:), XPROP (:), D (:) DOUBLE PRECISION , ALLOCATABLE :: RA (:), RB (:) INTEGER , ALLOCATABLE :: IPERM (:) DOUBLE PRECISION :: VECTFVAL ( IRUNS ), VECTF_OTT ( IRUNS ) DOUBLE PRECISION :: TOL , FMAX_EFF , fglob DOUBLE PRECISION :: RFAL , RNUMFAL , RMED , RMED2 , f_ott , FOTT , F , ALFAMAX , ALFAOTT DOUBLE PRECISION :: FPROP , VAR2 , VAR1 , ALFA , ZETA , TRES , DIFF DOUBLE PRECISION :: FSTOP , FSTOPTOL , FFSTOP DOUBLE PRECISION :: TEMPERATURA , SUMITER , SUMTIME DOUBLE PRECISION :: F_MIN , F_MIN1 , F_MAX , F_MINTOT , F_MINOTT , TCOEFF , FMIN , FMAX REAL :: RRAND LOGICAL :: L_F_DISTANTI , L_F_VICINI , NON_MINIMIZZ , SOLOSULPEGG , NORMADUE LOGICAL , ALLOCATABLE :: MASCH (:) CHARACTER ( LEN = 40 ) :: nomefun CHARACTER ( LEN = 2 ) :: CSTEP COMMON / NUMNEW2 / NF COMMON / CALFANR2 / NORMADUE NFOTT = 0 !\tCALL     NINIT(N) !\tCALL FUNCTINIT(N,XINF,XSUP,nomefun,fglob) fglob = 0.D0 !----------------------------------------------- !\tSETTA LE TOLLERANZE E I MASSIMI !----------------------------------------------- TOL = 1.0D-4 FSTOPTOL = 1.0D-15 MAXITER = 100000000 MAXNF = 1000 * n NUMFAL = 0 PRINT_LEVEL = 0 TCOEFF = 1.0D0 !-------------------------------------------------------- !\tmodificato il 23/9/2003 !-------------------------------------------------------- !\tIDIMWKS     = 20 !MIN(10*N,10) !\tIDIMWKS     = MAX(10,N) IDIMWKS = MIN ( 20 , MAX ( 10 , N )) !-------------------------------------------------------- SOLOSULPEGG = . FALSE . NORMADUE = . FALSE . !----------------------------------------------- ALLOCATE ( X ( N ), XOTT ( N ), Z ( N ), VETT ( N ), XPROP ( N )) ALLOCATE ( DOLDALFA ( N ), D ( N )) ALLOCATE ( RA ( IDIMWKS ), RB ( IDIMWKS ), IPERM ( IDIMWKS )) ! !\t------- !\t Iniz. !\t------- ! LSTOT = 0 NFTOT = 0 NFOTT = 0 NPCTOT = 0 NLMTOT = 0 CALL RANDOM_SEED () DO 171 IT = 1 , IRUNS ALLOCATE ( WKS ( IDIMWKS ), MASCH ( IDIMWKS )) DO I = 1 , IDIMWKS ALLOCATE ( WKS ( I )% X ( N )) ALLOCATE ( WKS ( I )% D ( N )) ALLOCATE ( WKS ( I )% DOLDALFA ( N )) ENDDO MASCH = . FALSE . LS = 0 NF = 0 NFOTT = 0 NPC = 0 NLM = 0 RFAL = 0.0D0 RNUMFAL = 0.0D0 ICONTFAL = 0 IDFAL = 0 NUMITER = 0 ivar = 2 * it + 3 * ( it + 7 ) ivar2 = 3 * it + 2 * ( it + 9 ) - 5 RMED = 0.D0 RMED2 = 0.D0 !\t------------------------------------- !\t  Generazione del campione originale !\t------------------------------------- FOTT = 1.D+32 !-------------------------------------------------------- !\tmodificato il 23/9/2003 !-------------------------------------------------------- NUMCAS = 30 !\t\tNUMCAS   = 1 !-------------------------------------------------------- IF ( PRINT_LEVEL >= 0 ) THEN WRITE ( * , 2070 ) WRITE ( * , 2080 ) WRITE ( 1 , 2070 ) WRITE ( 1 , 2080 ) ENDIF DO K = 1 , NUMCAS 3000 CONTINUE DO I = 1 , N CALL RANDOM_NUMBER ( RRAND ) VETT ( I ) = DBLE ( RRAND ) !RAN(IVAR2) !VETT(I)=RAN(IVAR2) XPROP ( I ) = XINF ( I ) + VETT ( I ) * ( XSUP ( I ) - XINF ( I )) ENDDO if ( K . eq . 1 ) then XPROP = 0.5D0 end if !CALL FUNCT(XPROP,N,FPROP) call calfun ( nipar , nfpar , ninit , ipar , fparebsd , initmeanval , expt , accum_e , mLPNH , mLPSH , & N , XPROP , FPROP , verbose ) NPC = NPC + 1 NF = NF + 1 RMED = (( NPC - 1.0D0 ) * RMED + FPROP ) / NPC IF ( NPC . LE . 2 ) THEN RMED2 = RMED2 + FPROP ** 2 ELSE RMED2 = (( NPC - 2. ) * RMED2 + FPROP ** 2 ) / ( NPC - 1.0D0 ) ENDIF IF ( FPROP . LT . FOTT ) THEN CALL AGGIORNO_OTTIMO ( N , XPROP , FPROP , XOTT , FOTT ) ENDIF IF ( PRINT_LEVEL >= 0 ) THEN WRITE ( * , 2130 ) NUMITER , NF , FPROP , '--' WRITE ( 1 , 2130 ) NUMITER , NF , FPROP , '--' ENDIF ENDDO IF ( PRINT_LEVEL >= 2 ) THEN write ( * , * ) 'fine generazione random iniziale nf = ' , nf write ( 1 , * ) 'fine generazione random iniziale nf = ' , nf ENDIF VAR2 = RMED2 - ( RMED ** 2 ) * ( NPC / ( NPC - 1. )) !--------------------------------------------------------- !\tRIEMPIO IL WKS DI IDIMWKS PUNTI !\tCHE SODDISFANO IL TEST DEL S.A. !--------------------------------------------------------- !\talfa     = 1.0d0 !\tDOLDALFA = ALFA DO I = 1 , N DOLDALFA ( I ) = 1.0D0 * DMAX1 ( 1.D-3 , DMIN1 ( 1.D+3 ,. 5 D0 * DABS ( XPROP ( I )))) !\t\tDOLDALFA(I)=1.D0 END DO D = 1.0D0 xprop = xott fprop = fott !\tfmax_eff = fott if ( print_level >= 2 ) then write ( * , * ) 'ricerca lungo assi' endif CALL RICERCA_LUNGO_ASSI ( N , XPROP , FPROP , ALFA , DOLDALFA , D , FSTOP , XINF , XSUP , Fmax_eff ,& ipar , fparebsd , initmeanval , ninit , nipar , nfpar , expt , accum_e , mLPNH , mLPSH , verbose , calfun ) if ( print_level >= 2 ) then write ( * , * ) 'fine ricerca lungo assi' endif WKS ( 1 )% X = XPROP WKS ( 1 )% FOB = FPROP WKS ( 1 )% ALFAMAX = ALFA WKS ( 1 )% DOLDALFA = DOLDALFA if ( DOT_PRODUCT ( DOLDALFA , DOLDALFA ) < 0.0d0 ) then write ( * , * ) '---- 1 ----' endif WKS ( 1 )% ALFANR2 = DSQRT ( DOT_PRODUCT ( DOLDALFA , DOLDALFA )) WKS ( 1 )% D = D WKS ( 1 )% FSTOP = FSTOP WKS ( 1 )% NUMCOST = 0 IF ( FPROP . LT . FOTT ) THEN CALL AGGIORNO_OTTIMO ( N , XPROP , FPROP , XOTT , FOTT ) ENDIF IF ( PRINT_LEVEL >= 0 ) THEN WRITE ( * , 2130 ) NUMITER , NF , FOTT , 'IN' WRITE ( 1 , 2130 ) NUMITER , NF , FOTT , 'IN' ENDIF DO I = 2 , IDIMWKS ZETA = 1.0D0 TRES = 0.0D0 DO WHILE ( ZETA . GT . TRES ) CALL RANDOM_NUMBER ( RRAND ) ZETA = DBLE ( RRAND ) !RAN(IVAR) !ZETA=RAN(IVAR) 3010 CONTINUE DO J = 1 , N CALL RANDOM_NUMBER ( RRAND ) VETT ( J ) = DBLE ( RRAND ) !RAN(IVAR2) !VETT(J)=RAN(IVAR2) XPROP ( J ) = XINF ( J ) + VETT ( J ) * ( XSUP ( J ) - XINF ( J )) ENDDO !CALL FUNCT(XPROP,N,FPROP) call calfun ( nipar , nfpar , ninit , ipar , fparebsd , initmeanval , expt , accum_e , mLPNH , mLPSH , & N , XPROP , FPROP , verbose ) NPC = NPC + 1 NF = NF + 1 RMED = (( NPC - 1. ) * RMED + FPROP ) / NPC RMED2 = (( NPC - 2. ) * RMED2 + FPROP ** 2 ) / ( NPC - 1. ) VAR2 = RMED2 - ( RMED ** 2 ) * ( NPC / ( NPC - 1. )) DIFF = RMED - FOTT TRES = DEXP ( - TCOEFF * ( RFAL / DIFF ) * ( FPROP - FOTT )) !-------------------------------------------------------- !\tmodificato il 23/9/2003 !-------------------------------------------------------- IF ( FPROP . LE . FOTT ) THEN TRES = 1.0D0 ENDIF !\t\t\tTRES = 1.0D0 !-------------------------------------------------------- ENDDO !\t\tDO J=1,N !\t\t\tDOLDALFA(J)=1.0D0*DMAX1(1.D-3,DMIN1(1.D+3,.5D0*DABS(XPROP(J)))) !\t\t\tDOLDALFA(J)=1.0D0 !\t\tEND DO ALFA = WKS ( 1 )% ALFAMAX DOLDALFA = WKS ( 1 )% DOLDALFA DO J = 2 , I - 1 IF ( ALFA . LT . WKS ( J )% ALFAMAX ) THEN ALFA = WKS ( J )% ALFAMAX DOLDALFA = WKS ( J )% DOLDALFA ENDIF ENDDO !\t\tDO K = 1,N !\t\t\tALFA=WKS(1)%DOLDALFA(K) !\t\t\tDO J = 2,I-1 !\t\t\t   IF(ALFA.LT.WKS(J)%DOLDALFA(K)) THEN !\t\t\t\t   ALFA      =  WKS(J)%DOLDALFA(K) !\t\t\t   ENDIF !\t\t\tENDDO !\t\t\tDOLDALFA(K) = ALFA !\t\tENDDO D = 1.0D0 !\t\tfmax_eff = fprop CALL RICERCA_LUNGO_ASSI ( N , Xprop , Fprop , ALFA , DOLDALFA , D , FSTOP , XINF , XSUP , Fmax_eff ,& ipar , fparebsd , initmeanval , ninit , nipar , nfpar , expt , accum_e , mLPNH , mLPSH , verbose , calfun ) WKS ( I )% X = XPROP WKS ( I )% FOB = FPROP WKS ( I )% ALFAMAX = ALFA WKS ( I )% DOLDALFA = DOLDALFA if ( DOT_PRODUCT ( DOLDALFA , DOLDALFA ) < 0.0d0 ) then write ( * , * ) '---- 2 ----' endif WKS ( I )% ALFANR2 = DSQRT ( DOT_PRODUCT ( DOLDALFA , DOLDALFA )) WKS ( I )% D = D WKS ( I )% FSTOP = FSTOP WKS ( I )% NUMCOST = 0 IF ( FPROP . LT . FOTT ) THEN CALL AGGIORNO_OTTIMO ( N , XPROP , FPROP , XOTT , FOTT ) ENDIF IF ( PRINT_LEVEL >= 0 ) THEN WRITE ( * , 2130 ) NUMITER , NF , FOTT , 'IN' WRITE ( 1 , 2130 ) NUMITER , NF , FOTT , 'IN' ENDIF ENDDO !-------------------------------------------------------- !\tmodificato il 23/9/2003 !-------------------------------------------------------- !\tOPEN(99,FILE='MIN_LOCALI.txt',STATUS='REPLACE') !\tDO I = 1,IDIMWKS !\t\tWRITE(99,*) WKS(I)%X !\t\tWRITE(99,*) 'FOB = ',WKS(I)%FOB !\t\tWRITE(99,*) '--------------------------------' !\tENDDO !\tCLOSE(99) !\tSTOP !-------------------------------------------------------- DO I = 1 , N X ( I ) = XOTT ( I ) ENDDO MAXLS = 100000000 MODLS = 1 !\t-------------------- !\t  Ciclo principale !\t-------------------- IF ( PRINT_LEVEL >= 0 ) THEN WRITE ( * , 2070 ) WRITE ( * , 2080 ) WRITE ( 1 , 2070 ) WRITE ( 1 , 2080 ) ENDIF 2070 FORMAT ( '    ITER      NFTOT       FOTT      SALTO       ALFA       FMIN        FMAX' ) 2080 FORMAT ( '-----------------------------------------------------------------------------' ) !              123456  123456789012  +1.2345E-02    OK     +1.2345E-02 +1.2345E-02 +1.2345E-02 2090 FORMAT ( 1 X , I6 , 2 X , I12 , 2 X , ES11 . 4 , 4 X , A2 , 5 X , ES11 . 4 , 1 X , ES11 . 4 , 1 X , ES11 . 4 ) 2130 FORMAT ( 1 X , I6 , 2 X , I12 , 2 X , ES11 . 4 , 4 X , A2 ) 100 FORMAT ( / , 1 X , ' GENERAZ.  N = ' , I9 , / ) 101 FORMAT ( / , 1 X , '  Attuale valore ottimo = ' , D13 . 6 , / ) 102 FORMAT ( 3 (:, 1 X , 'XOTT(' , I1 , ') =' , D13 . 6 , 1 X )) 109 FORMAT ( 3 (:, 1 X , 'XOTT(' , I2 , ') =' , D13 . 6 , 1 X )) 6 FORMAT ( / , 1 X , ' NF=' , I15 , 4 X , ' NPC=' , I7 , 4 X , ' NLM=' , I7 , 4 X , ' LS=' , I7 , / ) 96 FORMAT ( / , 1 X , '   MED = ' , D13 . 6 , '    VAR = ' , D13 . 6 , / ) CSTEP = '  ' 7 CONTINUE 8 CONTINUE !-------------------------------------- !\tstopping criterion !-------------------------------------- !\tcalcola il max tra gli alfamax !   o alfanr2 a seconda che normadue !\tsia falso o veroo !-------------------------------------- ALFA = 0.0D0 FSTOP = 0.0D0 FMIN = 1.0D+30 FMAX =- 1.0D+30 DO I = 1 , IDIMWKS IF (. NOT . MASCH ( I )) THEN IF ( WKS ( I )% FSTOP > FSTOP ) FSTOP = WKS ( I )% FSTOP IF ( NORMADUE ) THEN IF ( ALFA . LT . WKS ( I )% ALFANR2 ) THEN ALFA = WKS ( I )% ALFANR2 ENDIF ELSE IF ( ALFA . LT . WKS ( I )% ALFAMAX ) THEN ALFA = WKS ( I )% ALFAMAX ENDIF ENDIF !\t\t\tIF(WKS(I)%FOB > FMAX) FMAX = WKS(I)%FOB ENDIF IF ( WKS ( I )% FOB > FMAX ) FMAX = WKS ( I )% FOB IF ( WKS ( I )% FOB < FMIN ) THEN FMIN = WKS ( I )% FOB IF ( NORMADUE ) THEN ALFAOTT = WKS ( I )% ALFANR2 ELSE ALFAOTT = WKS ( I )% ALFAMAX ENDIF ENDIF ENDDO ALFAMAX = ALFA IF ( PRINT_LEVEL >= 1 ) THEN WRITE ( * , 2070 ) WRITE ( * , 2080 ) WRITE ( 1 , 2070 ) WRITE ( 1 , 2080 ) ENDIF IF ( PRINT_LEVEL >= 0 ) THEN WRITE ( * , 2090 ) NUMITER , NF , FOTT , CSTEP , ALFA , FMIN , FMAX WRITE ( 1 , 2090 ) NUMITER , NF , FOTT , CSTEP , ALFA , FMIN , FMAX ENDIF IF (( ALFAMAX <= TOL ). OR .( FSTOP <= FSTOPTOL ). OR . & (( FOTT - FGLOB ) / max ( 1.0d0 , abs ( fglob )) < tol )) THEN IF ( NFOTT == 0 ) THEN NFOTT = NF F_OTT = FOTT ENDIF ENDIF !IF(NF >= MAXNF) THEN IF (( ALFAMAX <= TOL ). OR .( FSTOP <= FSTOPTOL ). OR .( NUMITER >= MAXITER ). OR .( NF >= MAXNF )) THEN IF ( PRINT_LEVEL >= 0 ) THEN write ( * , * ) 'alfamax = ' , alfamax write ( 1 , * ) 'alfamax = ' , alfamax write ( * , * ) '  fstop = ' , fstop write ( 1 , * ) '  fstop = ' , fstop WRITE ( 1 , 100 ) NUMITER WRITE ( * , 100 ) NUMITER WRITE ( 1 , * ) FOTT WRITE ( * , * ) FOTT WRITE ( 1 , 101 ) FOTT WRITE ( * , 101 ) FOTT IF ( N . LT . 10 ) WRITE ( 1 , 102 ) ( J , XOTT ( J ), J = 1 , N ) IF ( N . LT . 10 ) WRITE ( * , 102 ) ( J , XOTT ( J ), J = 1 , N ) IF (( N . GT . 9 ). AND .( N . LT . 100 )) WRITE ( 1 , 109 ) ( J , XOTT ( J ), J = 1 , N ) IF (( N . GT . 9 ). AND .( N . LT . 100 )) WRITE ( * , 109 ) ( J , XOTT ( J ), J = 1 , N ) WRITE ( 1 , 6 ) NF , NPC , NLM , LS WRITE ( 6 , 6 ) NF , NPC , NLM , LS if ( var2 < 0.0d0 ) then write ( * , * ) '---- 3 ----' endif VAR1 = DSQRT ( VAR2 ) WRITE ( 6 , 96 ) RMED , VAR1 WRITE ( 1 , 96 ) RMED , VAR1 ENDIF GO TO 170 ENDIF !IF (FMIN /= FOTT) PAUSE IF ( PRINT_LEVEL >= 1 ) THEN WRITE ( * , * ) '/---------------------------------\\' WRITE(1,*)' /--------------------------------- \\ ' WRITE(*,*)' ALFAOTT = ',ALFAOTT,' FOTT = ',FOTT WRITE(1,*)' ALFAOTT = ',ALFAOTT,' FOTT = ',FOTT !\t\tWRITE(*,*) XOTT !\t\tWRITE(1,*) XOTT WRITE(*,*)' \\ ---------------------------------/ ' WRITE(1,*)' \\ ---------------------------------/ ' WRITE(*,*) WRITE(1,*) ENDIF !-------------------------------------- NUMITER = NUMITER + 1 IF(PRINT_LEVEL >= 0) THEN IF(MOD(NUMITER,30)==0) THEN WRITE(*,2070) WRITE(*,2080) WRITE(1,2070) WRITE(1,2080) ENDIF ENDIF !-------------------------------------- !\tgenera zeta random tra 0 e 1 !\te un punto xprop su cui calcolare !\tla f.ob. !-------------------------------------- CALL RANDOM_NUMBER(RRAND) ZETA=DBLE(RRAND) !RAN(IVAR) !ZETA=RAN(IVAR) 3020 CONTINUE DO I=1,N CALL RANDOM_NUMBER(RRAND) VETT(I)=DBLE(RRAND) !RAN(IVAR2) !VETT(I)=RAN(IVAR2) XPROP(I)=XINF(I)+VETT(I)*(XSUP(I)-XINF(I)) ENDDO !CALL FUNCT(XPROP,N,FPROP) call  calfun(nipar, nfpar, ninit, ipar, fparebsd, initmeanval, expt, accum_e, mLPNH, mLPSH, & N, XPROP, FPROP, verbose) NPC=NPC+1 NF=NF+1 103\tFORMAT(/,1X,' Proposta di salto ') 105\tFORMAT(/,1X,' Zeta = ',D13.6,' Tres = ',D13.6,/) !\t---------------------------- !\t  Calcolo media, varianza e !\t  la temperatura del SA !\t---------------------------- RMED  = ((NPC-1.)*RMED+FPROP)/NPC RMED2 = ((NPC-2.)*RMED2+FPROP**2)/(NPC-1.) VAR2  = RMED2-(RMED**2)*(NPC/(NPC-1.)) DIFF  = RMED-FOTT TRES  = DEXP(-TCOEFF*(RFAL/DIFF)*(FPROP-FOTT)) temperatura = diff/rfal IF(FPROP.LE.FOTT) TRES=1.0D0 !-------------------------------------- !\tse zeta e' minore o uguale a tres !\tallora accetta il punto e fa !\tpartire una min. locale !-------------------------------------- !\tIF(.FALSE.) THEN IF ( ZETA . LE . TRES ) THEN NUMFAL = 0 IF ( PRINT_LEVEL >= 2 ) THEN WRITE ( 1 , 405 ) WRITE ( * , 405 ) ENDIF 405 FORMAT ( 1 X , '    Proposta di salto accettata ' , / ) DO I = 1 , N X ( I ) = XPROP ( I ) ENDDO NLM = NLM + 1 !-------------------------------------- !\t\tcalcola l'indice imax della !\t\tcomponente di wks contenente !\t\til valore di fob piu' alto !-------------------------------------- FMAX =- 1.0D+30 DO I = 1 , IDIMWKS !\t\t\tIF((WKS(I)%FOB > FMAX)) THEN IF (( WKS ( I )% FOB > FMAX ) . AND . (. NOT . MASCH ( I ))) THEN FMAX = WKS ( I )% FOB IMAX = I ENDIF ENDDO ALFA = WKS ( 1 )% ALFAMAX FSTOP = WKS ( 1 )% FSTOP DO J = 2 , IDIMWKS IF ( FSTOP . LT . WKS ( J )% FSTOP ) FSTOP = WKS ( J )% FSTOP IF ( ALFA . LT . WKS ( J )% ALFAMAX ) THEN ALFA = WKS ( J )% ALFAMAX DOLDALFA = WKS ( J )% DOLDALFA ENDIF ENDDO !\t\tDO K = 1,N !\t\t\tALFA=WKS(1)%DOLDALFA(K) !\t\t\tDO J = 1,IDIMWKS !\t\t\t   IF(ALFA.LT.WKS(J)%DOLDALFA(K)) THEN !\t\t\t\t   ALFA      =  WKS(J)%DOLDALFA(K) !\t\t\t   ENDIF !\t\t\tENDDO !\t\t\tDOLDALFA(K) = ALFA !\t\tENDDO ALFA = ALFAMAX !\t\tIF(NORMADUE) THEN !\t\t\tALFA = WKS(IMAX)%ALFANR2 !\t\tELSETABELLA !\t\t\tALFA = WKS(IMAX)%ALFAMAX !\t\tENDIF CALL INTERFACCIA ( N , X , F , ALFA , DOLDALFA , D , FFSTOP , FSTOP , XINF , XSUP , FOTT , ALFAMAX , ALFAOTT , XOTT , WKS , IDIMWKS , ISTOP , MASCH , MAXNF , fglob ,& ipar , fparebsd , initmeanval , ninit , nipar , nfpar , expt , accum_e , mLPNH , mLPSH , verbose , calfun ) IF ( F . LT . FOTT ) THEN CALL AGGIORNO_OTTIMO ( N , X , F , XOTT , FOTT ) ISTOP = 1 ENDIF IF (( F . LT . WKS ( IMAX )% FOB ). AND .( ISTOP . NE . 2 )) THEN !-------------------------------------- !\t\t\tse la min. produce un punto !\t\t\tmigliore del peggiore !\t\t\tlo sostituisce !-------------------------------------- WKS ( IMAX )% X = X WKS ( IMAX )% FOB = F WKS ( IMAX )% ALFAMAX = ALFA WKS ( IMAX )% DOLDALFA = DOLDALFA WKS ( IMAX )% D = D WKS ( IMAX )% FSTOP = FFSTOP if ( DOT_PRODUCT ( DOLDALFA , DOLDALFA ) < 0.0d0 ) then write ( * , * ) '---- 4 ----' endif WKS ( IMAX )% ALFANR2 = DSQRT ( DOT_PRODUCT ( DOLDALFA , DOLDALFA )) WKS ( IMAX )% NUMCOST = 0 CSTEP = 'OK' MASCH ( IMAX ) = . FALSE . GO TO 7 ELSE !-------------------------------------- !\t\t\tnon accetta il punto !\t\t\tprodotto dalla minimizzazione !-------------------------------------- RNUMFAL = RNUMFAL + 1.0D0 ICONTFAL = ICONTFAL + 1 RFAL = RFAL + 1.0D0 / RNUMFAL IDFAL = 1 CSTEP = 'NO' ENDIF ELSE !-------------------------------------- !\taltrimenti (zeta > tres) scarta !\til punto proposto e aggiorna !\til cont. numfal !-------------------------------------- NUMFAL = NUMFAL + 1 !\t\tRNUMFAL  = RNUMFAL  + 1.0D0 !\t\tICONTFAL = ICONTFAL + 1 !\t\tRFAL     = RFAL     + 1.0D0/RNUMFAL !\t\tIDFAL    = 1 ENDIF !==================================================== !   QUI DEVO FARE UNA RICERCA LUNGO GLI ASSI !\tSU I PUNTI DEL WKS. !   SOLOSULPEGG = .TRUE.  --> LA FA SOLO SU QUELLO !\t\t\t\t\t\t \t  CON ALFA PEGGIORE !\t\t\t\t= .FALSE. --> LA FA SU TUTTI !==================================================== if (. NOT . SOLOSULPEGG ) then !fai la ricerca lungo gli assi per tutti !i punti dell'array IF ( NUMFAL >= 0 ) THEN NUMFAL = 0 FMAX_EFF =- 1.0D+30 DO J = 1 , IDIMWKS !\t\t\t\tIF(.NOT.MASCH(J)) THEN IF ( WKS ( J )% FOB > FMAX_EFF ) THEN FMAX_EFF = WKS ( J )% FOB ENDIF !\t\t\t\tENDIF IF ( WKS ( J )% FOB <= FOTT ) IOTT = J RA ( J ) = WKS ( J )% FOB IPERM ( J ) = J ENDDO !------------------------------------------------- ! ORDINO RA E RESTITUISCE RB ORDINATO ! IN IPERM CI SONO LE POSIZIONI DEGLI ELEMENTI ! DI RB IN RA !------------------------------------------------- call qsortd ( RA , IPERM , IDIMWKS ) DO I = 1 , IDIMWKS RB ( I ) = RA ( IPERM ( I )) ENDDO !CALL DSVRGP(IDIMWKS,RA,RB,IPERM) !\t\t\tMASCH = .FALSE. I = 1 J = 2 DO WHILE ( J <= IDIMWKS ) !CONFRONTO J,I --> MASCH IF (. NOT . MASCH ( IPERM ( J ))) THEN L_F_VICINI = ( DABS ( RB ( I ) - RB ( J )) / ( DMAX1 ( 1.D-8 , DABS ( RB ( J )) )) ). LE . 1.D-1 !\t\t\t\t\tL_F_VICINI = L_F_VICINI.AND.((DSQRT(\t\t\t\t\t\t\t\t\t\t\t\t\t& !\t\t\t\t\t\tDOT_PRODUCT(WKS(IPERM(I))%X-WKS(IPERM(J))%X,WKS(IPERM(I))%X-WKS(IPERM(J))%X)) <= 1.D-2)& !ERA 1.D-1 !\t\t\t\t\t\t.OR. (WKS(IPERM(J))%ALFAMAX.LE.1.D-1*WKS(IPERM(I))%ALFAMAX) ) L_F_VICINI = L_F_VICINI . AND .(( DSQRT ( & DOT_PRODUCT ( WKS ( IPERM ( I ))% X - WKS ( IPERM ( J ))% X , WKS ( IPERM ( I ))% X - WKS ( IPERM ( J ))% X )) <= 1.D-1 )) !\t\t\t\tMASCH(IPERM(J)) = MASCH(IPERM(J)).OR.L_F_VICINI IF ( L_F_VICINI ) THEN IF ( ( WKS ( IPERM ( J ))% ALFAMAX <= WKS ( IPERM ( I ))% ALFAMAX ) . OR . ( I == 1 ) ) THEN MASCH ( IPERM ( J )) = . TRUE . J = J + 1 ELSE MASCH ( IPERM ( I )) = . TRUE . I = J J = J + 1 ENDIF ELSE I = J J = J + 1 ENDIF ELSE J = J + 1 ENDIF ENDDO DO I = 1 , IDIMWKS IF ( NORMADUE ) THEN ALFA = WKS ( I )% ALFANR2 ELSE ALFA = WKS ( I )% ALFAMAX ENDIF DOLDALFA = WKS ( I )% DOLDALFA D = WKS ( I )% D X = WKS ( I )% X F = WKS ( I )% FOB IF ( I . NE . IOTT ) THEN RA ( I ) = ( F - FOTT ) / DMAX1 ( 1.D-3 , DMIN1 ( DABS ( F ), DABS ( FOTT )) ) RB ( I ) = DSQRT ( DOT_PRODUCT ( X - XOTT , X - XOTT )) L_F_DISTANTI = (( F - FOTT ) / DMAX1 ( 1.D-3 , DMIN1 ( DABS ( F ), DABS ( FOTT )) ) ). GE . 1.D+1 !\t\t\t\t\tL_F_DISTANTI = L_F_DISTANTI.AND.(ALFA <= 1.D-4) L_F_DISTANTI = L_F_DISTANTI . AND .( ALFA <= 1.D+1 * ALFAOTT ) L_F_VICINI = (( F - FOTT ) / DMAX1 ( 1.D-3 , DABS ( FOTT ) ) ). LE . 1.D-1 !\t\t\t\t\tL_F_VICINI = L_F_VICINI.AND.( (DSQRT(DOT_PRODUCT(X-XOTT,X-XOTT)) <= 1.D-1) & !\t\t\t\t\t\t\t\t.OR. (ALFA.LE.1.D-1*ALFAOTT)) L_F_VICINI = L_F_VICINI . AND .( ( DSQRT ( DOT_PRODUCT ( X - XOTT , X - XOTT )) <= 1.D-1 )) NON_MINIMIZZ = L_F_DISTANTI . OR . L_F_VICINI !\t\t\t\t\tNON_MINIMIZZ = L_F_DISTANTI.AND.(ALFA.LE.1.D-4) ELSE NON_MINIMIZZ = . FALSE . RA ( I ) = - 1.D0 RB ( I ) = - 1.D0 ENDIF MASCH ( I ) = MASCH ( I ) . OR . NON_MINIMIZZ !\t\t\tENDDO !-------------------------------------------- !\tapro il file per fare i controlli !\tsull'alfamax !-------------------------------------------- IF ( PRINT_LEVEL >= 1 ) THEN open ( 99 , FILE = 'alfamax.txt' , STATUS = 'REPLACE' ) DO J = 1 , IDIMWKS write ( 99 , 1999 ) J , wks ( J )% alfamax , wks ( J )% fob , masch ( J ), RA ( J ), RB ( J ) write ( * , 1999 ) J , wks ( J )% alfamax , wks ( J )% fob , masch ( J ), RA ( J ), RB ( J ) enddo 1999 format ( 1 x , i3 , 1 x , es18 . 10 , 1 x , es18 . 10 , 1 x , l1 , 1 x , es9 . 2 , 1 x , es9 . 2 ) !-------------------------------------------- !\tapro il file per fare i controlli !\tsull'alfamax !-------------------------------------------- close ( 99 ) !pause ENDIF !\t\t\tDO I = 1,IDIMWKS IF ( NORMADUE ) THEN ALFA = WKS ( I )% ALFANR2 ELSE ALFA = WKS ( I )% ALFAMAX ENDIF DOLDALFA = WKS ( I )% DOLDALFA D = WKS ( I )% D X = WKS ( I )% X F = WKS ( I )% FOB !\t\t\t\tIF(.TRUE.) THEN !\t\t\t\tIF(\t  (ALFA.GT.TOL).AND..NOT.MASCH(I)\t)\tTHEN !\t\t\t\tIF(\t  (ALFA.GT.TOL).AND..NOT.MASCH(I).AND. (ALFA.GT.1.D-3*ALFAMAX)\t)\tTHEN IF ( (( ALFA . GT . TOL ). AND .. NOT . MASCH ( I ). AND . ( ALFA . GT . 1.D-1 * ALFAMAX )). OR . & (( ALFA . GT . TOL ). AND .. NOT . MASCH ( I ). AND . ( I == IOTT ))) THEN MASCH ( I ) = . FALSE . !\t\t\t\t\tFMAX_EFF = F !\t\t\t\t\tWRITE(*,*)'X=',X !\t\t\t\t\tWRITE(*,*)'F=',F CALL RICERCA_LUNGO_ASSI ( N , X , F , ALFA , DOLDALFA , D , FSTOP , XINF , XSUP , FMAX_EFF ,& ipar , fparebsd , initmeanval , ninit , nipar , nfpar , expt , accum_e , mLPNH , mLPSH , verbose , calfun ) if ( f > fmax_eff ) then write ( * , * ) '---> 1 <--- diff = ' , f - fmax_eff !\t\t\t\t\t\tpause endif !\t\t\t\t\tWRITE(*,*)'X=',X !\t\t\t\t\tWRITE(*,*)'F=',F WKS ( I )% X = X WKS ( I )% FOB = F !\t\t\t\t\tPAUSE !IF(WKS(I)%ALFAMAX > ALFA) THEN !\tWRITE(*,*) '\\/\\/\\/\\/\\/ ',F,' \\/\\/\\/\\/\\/\\ ',FMAX_EFF !/\\/\\/\\/\\/', I !ENDIF IF ( ALFA >= WKS ( I )% ALFAMAX ) THEN WKS ( I )% NUMCOST = WKS ( I )% NUMCOST + 1 ELSE WKS ( I )% NUMCOST = 0 ENDIF WKS ( I )% ALFAMAX = ALFA WKS ( I )% DOLDALFA = DOLDALFA WKS ( I )% D = D WKS ( I )% FSTOP = FSTOP if ( DOT_PRODUCT ( DOLDALFA , DOLDALFA ) < 0.0d0 ) then write ( * , * ) '---- 5 ----' endif WKS ( I )% ALFANR2 = DSQRT ( DOT_PRODUCT ( DOLDALFA , DOLDALFA )) IF ( F . LT . FOTT ) THEN CALL AGGIORNO_OTTIMO ( N , X , F , XOTT , FOTT ) ENDIF IF ( WKS ( I )% NUMCOST <= - 1 ) THEN DO WHILE ( ALFA >= WKS ( I )% ALFAMAX ) CALL RICERCA_LUNGO_ASSI ( N , X , F , ALFA , DOLDALFA , D , FSTOP , XINF , XSUP , FMAX_EFF ,& ipar , fparebsd , initmeanval , ninit , nipar , nfpar , expt , accum_e , mLPNH , mLPSH , verbose , calfun ) if ( f > fmax_eff ) then write ( * , * ) '---> 2 <---' !\t\t\t\t\t\t\t\tpause endif WKS ( I )% X = X WKS ( I )% FOB = F WKS ( I )% ALFAMAX = ALFA WKS ( I )% DOLDALFA = DOLDALFA WKS ( I )% D = D WKS ( I )% FSTOP = FSTOP if ( DOT_PRODUCT ( DOLDALFA , DOLDALFA ) < 0.0d0 ) then write ( * , * ) '---- 6 ----' endif WKS ( I )% ALFANR2 = DSQRT ( DOT_PRODUCT ( DOLDALFA , DOLDALFA )) WRITE ( * , * ) ALFA , F ENDDO WKS ( I )% NUMCOST = 0 ENDIF ELSE IF (. FALSE .) THEN !\t\t\t\t\tIF(NON_MINIMIZZ) THEN IF ( PRINT_LEVEL >= 10 ) THEN WRITE ( 1 , * ) 'SOSTITUISCO IL PUNTO ' , I ENDIF CALL GENERA_PUNTO_SA ( N , XPROP , FPROP , XINF , XSUP , FOTT , TCOEFF , IVAR , IVAR2 , & VAR2 , RMED , RMED2 , NLM , NUMFAL , RFAL , RNUMFAL , ICONTFAL , IDFAL , NPC , NF ,& ipar , fparebsd , initmeanval , ninit , nipar , nfpar , expt , accum_e , mLPNH , mLPSH , verbose ,& calfun ) ALFA = 0.0D0 FSTOP = 0.0D0 DO J = 1 , IDIMWKS IF (. NOT . MASCH ( J )) THEN IF ( WKS ( J )% FSTOP > FSTOP ) FSTOP = WKS ( J )% FSTOP IF ( NORMADUE ) THEN IF ( ALFA . LT . WKS ( J )% ALFANR2 ) THEN ALFA = WKS ( J )% ALFANR2 ENDIF ELSE IF ( ALFA . LT . WKS ( J )% ALFAMAX ) THEN ALFA = WKS ( J )% ALFAMAX ENDIF ENDIF ENDIF ENDDO !\t\t\t\t\t\tALFAMAX = ALFA ALFA = ALFAMAX CALL INTERFACCIA ( N , XPROP , FPROP , ALFA , DOLDALFA , D , FFSTOP , FSTOP , XINF , & XSUP , FOTT , ALFAMAX , ALFAOTT , XOTT , WKS , IDIMWKS , ISTOP , MASCH , MAXNF , fglob ,& ipar , fparebsd , initmeanval , ninit , nipar , nfpar , expt , accum_e , mLPNH , mLPSH , verbose ,& calfun ) WKS ( I )% X = XPROP WKS ( I )% FOB = FPROP WKS ( I )% ALFAMAX = ALFA WKS ( I )% DOLDALFA = DOLDALFA WKS ( I )% D = D WKS ( I )% FSTOP = FFSTOP if ( DOT_PRODUCT ( DOLDALFA , DOLDALFA ) < 0.0d0 ) then write ( * , * ) '---- 7 ----' endif WKS ( I )% ALFANR2 = DSQRT ( DOT_PRODUCT ( DOLDALFA , DOLDALFA )) IF ( FPROP . LT . FOTT ) THEN CALL AGGIORNO_OTTIMO ( N , XPROP , FPROP , XOTT , FOTT ) ENDIF MASCH ( I ) = . FALSE . ELSE MASCH ( I ) = . TRUE . ENDIF ENDIF ENDDO ENDIF else !fai la ricerca lungo gli assi solo per !il punto con l'alfa maggiore ALFA = 0.0D0 FMIN = 1.0D+30 FMAX =- 1.0D+30 DO I = 1 , IDIMWKS IF (. NOT . MASCH ( I )) THEN IF ( NORMADUE ) THEN IF ( ALFA . LT . WKS ( I )% ALFANR2 ) THEN ALFA = WKS ( I )% ALFANR2 DOLDALFA = WKS ( I )% DOLDALFA IMAX = I ENDIF ELSE IF ( ALFA . LT . WKS ( I )% ALFAMAX ) THEN ALFA = WKS ( I )% ALFAMAX DOLDALFA = WKS ( I )% DOLDALFA IMAX = I ENDIF ENDIF IF ( WKS ( I )% FOB < FMIN ) FMIN = WKS ( I )% FOB IF ( WKS ( I )% FOB > FMAX ) FMAX = WKS ( I )% FOB ENDIF ENDDO D = WKS ( IMAX )% D X = WKS ( IMAX )% X F = WKS ( IMAX )% FOB CALL RICERCA_LUNGO_ASSI ( N , X , F , ALFA , DOLDALFA , D , FSTOP , XINF , XSUP , FMAX_EFF ,& ipar , fparebsd , initmeanval , ninit , nipar , nfpar , expt , accum_e , mLPNH , mLPSH , verbose , calfun ) if ( f > fmax_eff ) then write ( * , * ) '---> 3 <---' !\t\t\tpause endif WKS ( IMAX )% X = X WKS ( IMAX )% FOB = F WKS ( IMAX )% ALFAMAX = ALFA WKS ( IMAX )% DOLDALFA = DOLDALFA WKS ( IMAX )% D = D WKS ( IMAX )% FSTOP = FSTOP if ( DOT_PRODUCT ( DOLDALFA , DOLDALFA ) < 0.0d0 ) then write ( * , * ) '---- 8 ----' endif WKS ( IMAX )% ALFANR2 = DSQRT ( DOT_PRODUCT ( DOLDALFA , DOLDALFA )) IF ( F . LT . FOTT ) THEN CALL AGGIORNO_OTTIMO ( N , X , F , XOTT , FOTT ) ENDIF endif IF ( CSTEP . NE . 'NO' ) CSTEP = 'KO' GO TO 8 170 CONTINUE IF ( NFOTT == 0 ) THEN NFOTT = NF F_OTT = FOTT ENDIF LSTOT = LSTOT + LS NFTOT = NFTOT + NF NPCTOT = NPCTOT + NPC NLMTOT = NLMTOT + NLM VECTNF ( IT ) = NF VECTFVAL ( IT ) = FOTT VECTNFOTT ( IT ) = NFOTT VECTF_OTT ( IT ) = F_OTT DO I = 1 , IDIMWKS DEALLOCATE ( WKS ( I )% X ) DEALLOCATE ( WKS ( I )% DOLDALFA ) DEALLOCATE ( WKS ( I )% D ) ENDDO DEALLOCATE ( WKS , MASCH ) 171 CONTINUE sumiter = 0.D0 ; sumnf = 0 ; sumtime = 0.0D0 f_min1 = 1.D+30 f_minott = 0.D0 f_min = 1.D+30 f_mintot = 0.D0 f_max = - 1.D+30 DO IT = 1 , Iruns SUMNF = SUMNF + VECTNFOTT ( IT ) f_mintot = f_mintot + vectfVAL ( IT ) f_minott = f_minott + vectf_ott ( IT ) IF ( f_min . GT . vectfVAL ( IT )) f_min = vectfVAL ( IT ) IF ( f_min1 . GT . vectf_ott ( IT )) f_min1 = vectf_ott ( IT ) IF ( f_max . LT . vectfVAL ( IT )) f_max = vectfVAL ( IT ) END DO !write(TABELLA,2030) nomefun, n, NFTOT/IRUNS, SUMNF/IRUNS F_MINTOT = F_MINTOT / IRUNS F_MINOTT = F_MINOTT / IRUNS !IF (DABS(F_MIN).LT.1.D-3) THEN !\t\tWRITE(TABELLA,2110) F_MIN !\tELSE !\t\tWRITE(TABELLA,2100) F_MIN !\tENDIF !\tIF (DABS(F_MINTOT).LT.1.D-3) THEN !\t\tWRITE(TABELLA,2110) F_MINTOT !\tELSE !\t\tWRITE(TABELLA,2100) F_MINTOT !\tENDIF !\tIF (DABS(F_MIN1).LT.1.D-3) THEN !\t\tWRITE(TABELLA,2110) F_MIN1 !\tELSE !\t\tWRITE(TABELLA,2100) F_MIN1 !\tENDIF !\tIF (DABS(F_MINOTT).LT.1.D-3) THEN !\t\tWRITE(TABELLA,2110) F_MINOTT !\tELSE !\t\tWRITE(TABELLA,2100) F_MINOTT !\tENDIF !\tWRITE(TABELLA,2110) (F_MINOTT-fglob)/max(1.0d0,abs(fglob)) ! !if((F_MINOTT-fglob)/max(1.0d0,abs(fglob))<1.d-4) then !\t\tiok = 1 !\telse !\t\tiok = 0 !\tendif NFAILS = 0 DO IT = 1 , IRUNS IF ( DABS ( VECTFVAL ( IT ) - F_MIN ). GT . 1.0d-2 ) NFAILS = NFAILS + 1 ENDDO !WRITE(TABELLA,2120) NFAILS !\tWRITE(TABELLA,2180) !\tDEALLOCATE(XINF,XSUP) DEALLOCATE ( X , XOTT , Z , VETT , XPROP , DOLDALFA , D ) DEALLOCATE ( RA , RB , IPERM ) 2100 FORMAT ( ' & ' , ES12 . 5 , $ ) 2110 FORMAT ( ' & ' , D10 . 3 , $ ) 2030 FORMAT ( A40 , ' & ' , I2 , ' & ' , I6 , ' & ' , I6 , $ ) !2100 FORMAT(' & ',F13.4,$) !2110 FORMAT(' & ',D9.3,$) 2120 FORMAT ( ' & ' , I4 , '\\\\' ) 2180 FORMAT ( ' \\\\ ' ) 2140 FORMAT ( I3 , '  ' , $ ) 2150 FORMAT ( ES11 . 4 , '  ' , $ ) 2160 FORMAT ( I6 , '  ' , $ ) 2170 FORMAT ( I6 , '  ' , I3 ) 691 FORMAT ( / , 1 X , ' NFTOT=' , I7 , 4 X , ' NPCTOT=' , I7 , 4 X , ' NLMTOT=' , I7 , 4 X , ' LSTOT=' , I7 , / ) END SUBROUTINE SENZADERGLOB","tags":"","loc":"proc/senzaderglob.html","title":"SENZADERGLOB – Fortran Program"},{"text":"public subroutine AGGIORNO_OTTIMO(N, XPROP, FPROP, XOTT, FOTT) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N double precision, intent(in) :: XPROP (N) double precision, intent(in) :: FPROP double precision, intent(out) :: XOTT (N) double precision, intent(out) :: FOTT Called By proc~~aggiorno_ottimo~~CalledByGraph proc~aggiorno_ottimo AGGIORNO_OTTIMO proc~senzaderglob SENZADERGLOB proc~senzaderglob->proc~aggiorno_ottimo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code AGGIORNO_OTTIMO Source Code SUBROUTINE AGGIORNO_OTTIMO ( N , XPROP , FPROP , XOTT , FOTT ) IMPLICIT NONE INTEGER , INTENT ( IN ) :: N DOUBLE PRECISION , INTENT ( IN ) :: XPROP ( N ), FPROP DOUBLE PRECISION , INTENT ( OUT ) :: XOTT ( N ), FOTT INTEGER :: I XOTT = XPROP FOTT = FPROP RETURN OPEN ( 99 , FILE = 'OttimoCorrente.txt' , STATUS = 'REPLACE' ) DO I = 1 , N WRITE ( 99 , 1000 ) I , XOTT ( I ) ENDDO WRITE ( 99 , 1010 ) FOTT CLOSE ( 99 ) 1000 FORMAT ( 1 X , 'XOTT(' , I3 , ') = ' , ES11 . 4 ) 1010 FORMAT ( 1 X , 'FOTT      = ' , ES11 . 4 ) RETURN END SUBROUTINE AGGIORNO_OTTIMO","tags":"","loc":"proc/aggiorno_ottimo.html","title":"AGGIORNO_OTTIMO – Fortran Program"},{"text":"public subroutine RICERCA_LUNGO_ASSI(N, X, FF, ALFA, DOLDALFA, D, FFSTOP, XINF, XSUP, FMAX_EFF, ipar, fparebsd, initmeanval, ninit, nipar, nfpar, expt, accum_e, mLPNH, mLPSH, verbose, calfun) Arguments Type Intent Optional Attributes Name integer :: N real(kind=8) :: X (N) real(kind=8) :: FF real(kind=8) :: ALFA real(kind=8) :: DOLDALFA (N) real(kind=8) :: D (N) real(kind=8) :: FFSTOP real(kind=8) :: XINF (N) real(kind=8) :: XSUP (N) real(kind=8) :: FMAX_EFF integer(kind=8), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fparebsd (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) integer(kind=irg), intent(in) :: ninit integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar real(kind=sgl), intent(in) :: expt (ipar(2)*ipar(3)) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) logical, intent(in), optional :: verbose procedure( func ) :: calfun Calls proc~~ricerca_lungo_assi~~CallsGraph proc~ricerca_lungo_assi RICERCA_LUNGO_ASSI proc~mainbox1 MAINBOX1 proc~ricerca_lungo_assi->proc~mainbox1 proc~linesearchbox_cont linesearchbox_cont proc~mainbox1->proc~linesearchbox_cont dfloat dfloat proc~mainbox1->dfloat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~ricerca_lungo_assi~~CalledByGraph proc~ricerca_lungo_assi RICERCA_LUNGO_ASSI proc~senzaderglob SENZADERGLOB proc~senzaderglob->proc~ricerca_lungo_assi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Common Blocks NUM NUMNEW2 NUMNEW Source Code RICERCA_LUNGO_ASSI Common Blocks common /NUM/ Type Attributes Name Initial real :: F common /NUMNEW2/ Type Attributes Name Initial integer :: NUM_FUNCT common /NUMNEW/ Type Attributes Name Initial integer :: NF $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      }) Source Code SUBROUTINE RICERCA_LUNGO_ASSI ( N , X , FF , ALFA , DOLDALFA , D , FFSTOP , XINF , XSUP , FMAX_EFF , ipar , fparebsd ,& initmeanval , ninit , nipar , nfpar , expt , accum_e , mLPNH , mLPSH , verbose , calfun ) IMPLICIT NONE INTEGER N , NN , nf INTEGER I , J , IDIR_CORR , NUM_FUNCT , NUM_ITER , NUM_NOTFAL ( N ) INTEGER MAX_NOTFAL , NUM_FAL , ISTOP INTEGER IPUNT , NUM_PARAM INTEGER IPRINT INTEGER ENV , LINK PROCEDURE ( func ) calfun integer ( 8 ), intent ( in ) :: ipar ( nipar ) real ( sgl ), intent ( inout ) :: fparebsd ( nfpar ) real ( sgl ), intent ( in ) :: initmeanval ( ninit ) integer ( irg ), intent ( in ) :: ninit integer ( irg ), intent ( in ) :: nipar integer ( irg ), intent ( in ) :: nfpar real ( sgl ), intent ( in ) :: expt ( ipar ( 2 ) * ipar ( 3 )) real ( sgl ), intent ( in ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( sgl ), intent ( in ) :: mLPNH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) real ( sgl ), intent ( in ) :: mLPSH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) logical , intent ( in ), optional :: verbose REAL * 8 FMAX_EFF REAL * 8 X ( N ), DIREZIONI ( N ), Z ( N ), Z1 ( N ), D ( N ), XOLD ( N ) REAL * 8 GAMMA , RHO , ALFA , F , FF , FZ , FTAR , F0 , DSTOP , FFSTOP REAL * 8 DOLDALFA ( N ), DCONV ( N ), FINIT ( N , 2 ) REAL * 8 FSTOP ( N + 1 ), XFSTOP ( N , N + 1 ), XINF ( N ), XSUP ( N ), ALFA_MIN ( N ) COMMON / NUM / F COMMON / NUMNEW2 / NUM_FUNCT COMMON / NUMNEW / NF F = FF IPRINT =- 1 !call funct(x,n,ff) call calfun ( nipar , nfpar , ninit , ipar , fparebsd , initmeanval , expt , accum_e , mLPNH , mLPSH , & n , x , ff , verbose ) !\twrite(*,*) '/--------------------------------------\\' !\twrite(*,*) 'ric.assi: ff = ',ff,' f = ',f !\tCALL MAINBOX1(N,X,D,DIREZIONI,Z,Z1,XOLD,NUM_ITER,DOLDALFA,IPRINT,DCONV,FSTOP,XFSTOP,FINIT,XINF,XSUP,ALFA_MIN,FFSTOP,FMAX_EFF) CALL MAINBOX1 ( N , X , D , DIREZIONI , Z , Z1 , XOLD , NUM_ITER , DOLDALFA , IPRINT , DCONV , FSTOP , XFSTOP , FINIT , FFSTOP , XINF , XSUP ,& ipar , fparebsd , initmeanval , ninit , nipar , nfpar , expt , accum_e , mLPNH , mLPSH , verbose , calfun ) ALFA = MAXVAL ( DOLDALFA ) num_funct = num_funct + nf !\tcall funct(x,n,ff) call calfun ( nipar , nfpar , ninit , ipar , fparebsd , initmeanval , expt , accum_e , mLPNH , mLPSH , & n , x , ff , verbose ) if ( f . ne . ff ) then write ( * , * ) 'ric.assi: ff = ' , ff , ' f = ' , f write ( * , * ) x write ( * , * ) '\\--------------------------------------/' !\t\tpause endif FF = F RETURN END SUBROUTINE RICERCA_LUNGO_ASSI","tags":"","loc":"proc/ricerca_lungo_assi.html","title":"RICERCA_LUNGO_ASSI – Fortran Program"},{"text":"public subroutine INTERFACCIA(N, X, FF, ALFA, DOLDALFA, D, FFSTOP, FFSTOPTOL, XINF, XSUP, FOTT, ALFAMAX, ALFAOTT, XOTT, WKS, IDIMWKS, ISTOP, MASCH, MAXNF, fglob, ipar, fparebsd, initmeanval, ninit, nipar, nfpar, expt, accum_e, mLPNH, mLPSH, verbose, calfun) Uses: typedefs proc~~interfaccia~~UsesGraph proc~interfaccia INTERFACCIA typedefs typedefs typedefs->proc~interfaccia Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name integer :: N real(kind=8) :: X (N) real(kind=8) :: FF real(kind=8) :: ALFA real(kind=8) :: DOLDALFA (N) real(kind=8) :: D (N) real(kind=8) :: FFSTOP real(kind=8) :: FFSTOPTOL real(kind=8) :: XINF (N) real(kind=8) :: XSUP (N) real(kind=8) :: FOTT real(kind=8) :: ALFAMAX real(kind=8) :: ALFAOTT real(kind=8) :: XOTT (N) type(COMP_WKS_TYP) :: WKS (IDIMWKS) integer :: IDIMWKS integer :: ISTOP logical :: MASCH (IDIMWKS) integer :: MAXNF real(kind=8) :: fglob integer(kind=8), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fparebsd (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) integer(kind=irg), intent(in) :: ninit integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar real(kind=sgl), intent(in) :: expt (ipar(2)*ipar(3)) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) logical, intent(in), optional :: verbose procedure( func ) :: calfun Calls proc~~interfaccia~~CallsGraph proc~interfaccia INTERFACCIA proc~mainbox2 MAINBOX2 proc~interfaccia->proc~mainbox2 proc~linesearchbox_cont linesearchbox_cont proc~mainbox2->proc~linesearchbox_cont Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~interfaccia~~CalledByGraph proc~interfaccia INTERFACCIA proc~senzaderglob SENZADERGLOB proc~senzaderglob->proc~interfaccia Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Common Blocks NUM NUMNEW2 NUMNEW Source Code INTERFACCIA Common Blocks common /NUM/ Type Attributes Name Initial real :: F common /NUMNEW2/ Type Attributes Name Initial integer :: NUM_FUNCT common /NUMNEW/ Type Attributes Name Initial integer :: NF $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      }) Source Code SUBROUTINE INTERFACCIA ( N , X , FF , ALFA , DOLDALFA , D , FFSTOP , FFSTOPTOL , XINF , XSUP , FOTT , ALFAMAX , ALFAOTT , & XOTT , WKS , IDIMWKS , ISTOP , MASCH , MAXNF , fglob , ipar , fparebsd , initmeanval , ninit ,& nipar , nfpar , expt , accum_e , mLPNH , mLPSH , verbose , calfun ) use typedefs IMPLICIT NONE !\tINCLUDE 'TYPEDECL.FI' INTEGER N , NN , nf INTEGER I , J , IDIR_CORR , NUM_FUNCT , NUM_ITER , NUM_NOTFAL ( N ), IDIMWKS , MAXNF INTEGER MAX_NOTFAL , NUM_FAL , ISTOP INTEGER IPUNT , NUM_PARAM INTEGER IPRINT INTEGER ENV , LINK integer ( 8 ), intent ( in ) :: ipar ( nipar ) real ( sgl ), intent ( inout ) :: fparebsd ( nfpar ) real ( sgl ), intent ( in ) :: initmeanval ( ninit ) integer ( irg ), intent ( in ) :: ninit integer ( irg ), intent ( in ) :: nipar integer ( irg ), intent ( in ) :: nfpar real ( sgl ), intent ( in ) :: expt ( ipar ( 2 ) * ipar ( 3 )) real ( sgl ), intent ( in ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( sgl ), intent ( in ) :: mLPNH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) real ( sgl ), intent ( in ) :: mLPSH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) logical , intent ( in ), optional :: verbose procedure ( func ) :: calfun REAL * 8 X ( N ), DIREZIONI ( N ), Z ( N ), Z1 ( N ), D ( N ), XOLD ( N ), XOTT ( N ), fglob REAL * 8 GAMMA , RHO , ALFA , F , FF , FZ , FTAR , F0 , DSTOP , ALFAOTT REAL * 8 FFSTOP , FFSTOPTOL , FOTT , ALFAMAX REAL * 8 DOLDALFA ( N ), DCONV ( N ), FINIT ( N , 2 ) REAL * 8 FSTOP ( N + 1 ), XFSTOP ( N , N + 1 ), XINF ( N ), XSUP ( N ), ALFA_MIN ( N ) TYPE ( COMP_WKS_TYP ) :: WKS ( IDIMWKS ) LOGICAL MASCH ( IDIMWKS ) COMMON / NUM / F COMMON / NUMNEW2 / NUM_FUNCT COMMON / NUMNEW / NF F = FF IPRINT =- 1 !\tCALL MAINBOX2(N,X,D,DIREZIONI,Z,Z1,XOLD,NUM_ITER,DOLDALFA,ALFA,IPRINT,DCONV,FSTOP,XFSTOP,FINIT,XINF,XSUP,ALFA_MIN,FFSTOP,FFSTOPTOL,FOTT,ALFAMAX) CALL MAINBOX2 ( N , X , D , DIREZIONI , Z , Z1 , XOLD , NUM_ITER , DOLDALFA , ALFA , IPRINT , DCONV , FSTOP , XFSTOP , FINIT , FFSTOP , FFSTOPTOL ,& FOTT , ALFAOTT , XOTT , WKS , IDIMWKS , ISTOP , MASCH , MAXNF , fglob , XINF , XSUP ,& ipar , fparebsd , initmeanval , ninit , nipar , nfpar , expt , accum_e , mLPNH , mLPSH , verbose , calfun ) ALFA = MAXVAL ( DOLDALFA ) num_funct = num_funct + nf !call funct(x,n,ff) call calfun ( nipar , nfpar , ninit , ipar , fparebsd , initmeanval , expt , accum_e , mLPNH , mLPSH , & n , x , ff , verbose ) !\twrite(*,*) 'ric.alfa: ff = ',ff,' f = ',f FF = F IPRINT =- 1 IF ( IPRINT >= 1 ) THEN WRITE ( * , * ) X ENDIF RETURN END SUBROUTINE INTERFACCIA","tags":"","loc":"proc/interfaccia.html","title":"INTERFACCIA – Fortran Program"},{"text":"public subroutine GENERA_PUNTO_SA(N, XPROP, FPROP, XINF, XSUP, FOTT, TCOEFF, IVAR, IVAR2, VAR2, RMED, RMED2, NLM, NUMFAL, RFAL, RNUMFAL, ICONTFAL, IDFAL, NPC, NF, ipar, fparebsd, initmeanval, ninit, nipar, nfpar, expt, accum_e, mLPNH, mLPSH, verbose, calfun) Arguments Type Intent Optional Attributes Name integer :: N double precision :: XPROP (N) double precision :: FPROP double precision :: XINF (N) double precision :: XSUP (N) double precision :: FOTT double precision :: TCOEFF integer(kind=4) :: IVAR integer(kind=4) :: IVAR2 double precision :: VAR2 double precision :: RMED double precision :: RMED2 integer :: NLM integer :: NUMFAL double precision :: RFAL double precision :: RNUMFAL integer :: ICONTFAL integer :: IDFAL integer :: NPC integer :: NF integer(kind=8), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fparebsd (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) integer(kind=irg), intent(in) :: ninit integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar real(kind=sgl), intent(in) :: expt (ipar(2)*ipar(3)) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) logical, intent(in), optional :: verbose procedure( func ) :: calfun Calls proc~~genera_punto_sa~~CallsGraph proc~genera_punto_sa GENERA_PUNTO_SA dexp dexp proc~genera_punto_sa->dexp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~genera_punto_sa~~CalledByGraph proc~genera_punto_sa GENERA_PUNTO_SA proc~senzaderglob SENZADERGLOB proc~senzaderglob->proc~genera_punto_sa Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code GENERA_PUNTO_SA Source Code SUBROUTINE GENERA_PUNTO_SA ( N , XPROP , FPROP , XINF , XSUP , FOTT , TCOEFF , IVAR , IVAR2 , & VAR2 , RMED , RMED2 , NLM , NUMFAL , RFAL , RNUMFAL , ICONTFAL , IDFAL , NPC , NF ,& ipar , fparebsd , initmeanval , ninit , nipar , nfpar , expt , accum_e , mLPNH ,& mLPSH , verbose , calfun ) IMPLICIT NONE INTEGER :: N , NLM , NUMFAL , ICONTFAL , IDFAL INTEGER :: NPC , NF INTEGER * 4 :: IVAR , IVAR2 DOUBLE PRECISION :: XPROP ( N ), XINF ( N ), XSUP ( N ), FPROP , FOTT , TCOEFF DOUBLE PRECISION :: VAR2 , RMED , RMED2 , RFAL , RNUMFAL DOUBLE PRECISION :: ZETA , TRES , DIFF DOUBLE PRECISION :: VETT ( N ) LOGICAL :: TROVATO INTEGER :: I REAL :: RRAND PROCEDURE ( func ) :: calfun integer ( 8 ), intent ( in ) :: ipar ( nipar ) real ( sgl ), intent ( inout ) :: fparebsd ( nfpar ) real ( sgl ), intent ( in ) :: initmeanval ( ninit ) integer ( irg ), intent ( in ) :: ninit integer ( irg ), intent ( in ) :: nipar integer ( irg ), intent ( in ) :: nfpar real ( sgl ), intent ( in ) :: expt ( ipar ( 2 ) * ipar ( 3 )) real ( sgl ), intent ( in ) :: accum_e ( ipar ( 4 ), - ipar ( 5 ): ipar ( 5 ), - ipar ( 5 ): ipar ( 5 )) real ( sgl ), intent ( in ) :: mLPNH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) real ( sgl ), intent ( in ) :: mLPSH ( - ipar ( 6 ): ipar ( 6 ), - ipar ( 6 ): ipar ( 6 ), ipar ( 10 ), ipar ( 7 )) logical , intent ( in ), optional :: verbose TROVATO = . FALSE . DO WHILE (. NOT . TROVATO ) CALL RANDOM_NUMBER ( RRAND ) ZETA = DBLE ( RRAND ) !RAN(IVAR) !ZETA=RAN(IVAR) 100 CONTINUE DO I = 1 , N CALL RANDOM_NUMBER ( RRAND ) VETT ( I ) = DBLE ( RRAND ) !RAN(IVAR2) !VETT(I)=RAN(IVAR2) XPROP ( I ) = XINF ( I ) + VETT ( I ) * ( XSUP ( I ) - XINF ( I )) ENDDO call calfun ( nipar , nfpar , ninit , ipar , fparebsd , initmeanval , expt , accum_e , mLPNH , mLPSH , & N , XPROP , FPROP , verbose ) NPC = NPC + 1 NF = NF + 1 !\t---------------------------- !\t  Calcolo media e varianza !\t---------------------------- RMED = (( NPC - 1. ) * RMED + FPROP ) / NPC RMED2 = (( NPC - 2. ) * RMED2 + FPROP ** 2 ) / ( NPC - 1. ) VAR2 = RMED2 - ( RMED ** 2 ) * ( NPC / ( NPC - 1. )) DIFF = RMED - FOTT TRES = DEXP ( - TCOEFF * ( RFAL / DIFF ) * ( FPROP - FOTT )) IF ( FPROP . LE . FOTT ) TRES = 1. IF ( ZETA . LE . TRES ) THEN NUMFAL = 0 NLM = NLM + 1 TROVATO = . TRUE . ELSE NUMFAL = NUMFAL + 1 RNUMFAL = RNUMFAL + 1. ICONTFAL = ICONTFAL + 1 RFAL = RFAL + 1. / RNUMFAL IDFAL = 1 ENDIF ENDDO RETURN END SUBROUTINE GENERA_PUNTO_SA","tags":"","loc":"proc/genera_punto_sa.html","title":"GENERA_PUNTO_SA – Fortran Program"},{"text":"public subroutine MAINBOX1(N, X, D, D1, Z, Z1, XOLD, NUM_ITER, DOLDALFA, IPRINT, DCONV, FSTOP, XFSTOP, FINIT, FFSTOP, BL, BU, ipar, fparebsd, initmeanval, ninit, nipar, nfpar, expt, accum_e, mLPNH, mLPSH, verbose, calfun) Arguments Type Intent Optional Attributes Name integer :: N real(kind=8) :: X (N) real(kind=8) :: D (N) real(kind=8) :: D1 (N) real(kind=8) :: Z (N) real(kind=8) :: Z1 (N) real(kind=8) :: XOLD (N) integer :: NUM_ITER real(kind=8) :: DOLDALFA (N) integer :: IPRINT real(kind=8) :: DCONV (N) real(kind=8) :: FSTOP (N+1) real(kind=8) :: XFSTOP (N,N+1) real(kind=8) :: FINIT (N,2) real(kind=8) :: FFSTOP real(kind=8) :: BL (N) real(kind=8) :: BU (N) integer(kind=8), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fparebsd (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) integer(kind=irg), intent(in) :: ninit integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar real(kind=sgl), intent(in) :: expt (ipar(2)*ipar(3)) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) logical, intent(in), optional :: verbose procedure( func ) :: calfun Calls proc~~mainbox1~~CallsGraph proc~mainbox1 MAINBOX1 proc~linesearchbox_cont linesearchbox_cont proc~mainbox1->proc~linesearchbox_cont dfloat dfloat proc~mainbox1->dfloat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~mainbox1~~CalledByGraph proc~mainbox1 MAINBOX1 proc~ricerca_lungo_assi RICERCA_LUNGO_ASSI proc~ricerca_lungo_assi->proc~mainbox1 proc~senzaderglob SENZADERGLOB proc~senzaderglob->proc~ricerca_lungo_assi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Common Blocks NUM NUMNEW Common Blocks common /NUM/ Type Attributes Name Initial real :: F common /NUMNEW/ Type Attributes Name Initial integer :: NUM_FUNCT $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/mainbox1.html","title":"MAINBOX1 – Fortran Program"},{"text":"public subroutine MAINBOX2(N, X, D, D1, Z, Z1, XOLD, NUM_ITER, DOLDALFA, ALFA_STOP, IPRINT, DCONV, FSTOP, XFSTOP, FINIT, FFSTOP, FFSTOPTOL, FOTT, ALFAOTT, XOTT, WKS, IDIMWKS, ISTOP, MASCH, MAXNF, fglob, BL, BU, ipar, fparebsd, initmeanval, ninit, nipar, nfpar, expt, accum_e, mLPNH, mLPSH, verbose, calfun) Uses: typedefs proc~~mainbox2~~UsesGraph proc~mainbox2 MAINBOX2 typedefs typedefs typedefs->proc~mainbox2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name integer :: N real(kind=8) :: X (N) real(kind=8) :: D (N) real(kind=8) :: D1 (N) real(kind=8) :: Z (N) real(kind=8) :: Z1 (N) real(kind=8) :: XOLD (N) integer :: NUM_ITER real(kind=8) :: DOLDALFA (N) real(kind=8) :: ALFA_STOP integer :: IPRINT real(kind=8) :: DCONV (N) real(kind=8) :: FSTOP (N+1) real(kind=8) :: XFSTOP (N,N+1) real(kind=8) :: FINIT (N,2) real(kind=8) :: FFSTOP real(kind=8) :: FFSTOPTOL real(kind=8) :: FOTT real(kind=8) :: ALFAOTT real(kind=8) :: XOTT (N) type(COMP_WKS_TYP) :: WKS (IDIMWKS) integer :: IDIMWKS integer :: ISTOP logical :: MASCH (IDIMWKS) integer :: MAXNF real(kind=8) :: fglob real(kind=8) :: BL (N) real(kind=8) :: BU (N) integer(kind=8), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fparebsd (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) integer(kind=irg), intent(in) :: ninit integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar real(kind=sgl), intent(in) :: expt (ipar(2)*ipar(3)) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) logical, intent(in), optional :: verbose procedure( func ) :: calfun Calls proc~~mainbox2~~CallsGraph proc~mainbox2 MAINBOX2 proc~linesearchbox_cont linesearchbox_cont proc~mainbox2->proc~linesearchbox_cont Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~mainbox2~~CalledByGraph proc~mainbox2 MAINBOX2 proc~interfaccia INTERFACCIA proc~interfaccia->proc~mainbox2 proc~senzaderglob SENZADERGLOB proc~senzaderglob->proc~interfaccia Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Common Blocks NUM NUMNEW Common Blocks common /NUM/ Type Attributes Name Initial real :: F common /NUMNEW/ Type Attributes Name Initial integer :: NUM_FUNCT $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/mainbox2.html","title":"MAINBOX2 – Fortran Program"},{"text":"public subroutine STOP(N, DOLDALFA, ISTOP, DALFAMAX, NUM_FUNCT, FSTOP, ALFA_STOP, FFSTOPTOL, FFSTOP, FOTT, X, XOTT, ALFAOTT, WKS, IDIMWKS, MASCH, MAXNF, fglob) Uses: typedefs proc~~stop~~UsesGraph proc~stop STOP typedefs typedefs typedefs->proc~stop Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Arguments Type Intent Optional Attributes Name integer :: N real(kind=8) :: DOLDALFA (N) integer :: ISTOP real(kind=8) :: DALFAMAX integer :: NUM_FUNCT real(kind=8) :: FSTOP (N+1) real(kind=8) :: ALFA_STOP real(kind=8) :: FFSTOPTOL real(kind=8) :: FFSTOP real(kind=8) :: FOTT real(kind=8) :: X (N) real(kind=8) :: XOTT (N) real(kind=8) :: ALFAOTT type(COMP_WKS_TYP) :: WKS (IDIMWKS) integer :: IDIMWKS logical :: MASCH (IDIMWKS) integer :: MAXNF real(kind=8) :: fglob Calls proc~~stop~~CallsGraph proc~stop STOP dfloat dfloat proc~stop->dfloat Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Common Blocks CALFANR2 NUM Common Blocks common /CALFANR2/ Type Attributes Name Initial integer :: NORMADUE common /NUM/ Type Attributes Name Initial real :: F $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/stop.html","title":"STOP – Fortran Program"},{"text":"public subroutine LINESEARCH_INVERTI(N, X, F, D, ALFA, DOLDALFA, Z, FZ, I_CORR, NUM_FAL, DALFAMAX, IPRINT, ipar, fparebsd, initmeanval, ninit, nipar, nfpar, expt, accum_e, mLPNH, mLPSH, verbose, calfun) Arguments Type Intent Optional Attributes Name integer :: N real(kind=8) :: X (N) real(kind=8) :: F real(kind=8) :: D (N) real(kind=8) :: ALFA real(kind=8) :: DOLDALFA (N) real(kind=8) :: Z (N) real(kind=8) :: FZ integer :: I_CORR integer :: NUM_FAL real(kind=8) :: DALFAMAX integer :: IPRINT integer(kind=8), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fparebsd (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) integer(kind=irg), intent(in) :: ninit integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar real(kind=sgl), intent(in) :: expt (ipar(2)*ipar(3)) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) logical, intent(in), optional :: verbose procedure( func ) :: calfun Common Blocks NUM NUMNEW Common Blocks common /NUM/ Type Attributes Name Initial real :: FCOMMON common /NUMNEW/ Type Attributes Name Initial integer :: NUM_FUNCT $(function () {\n      $('[data-toggle=\"popover\"]').popover()\n      })","tags":"","loc":"proc/linesearch_inverti.html","title":"LINESEARCH_INVERTI – Fortran Program"},{"text":"public recursive function IsinsideFZ(rod, FZtype, FZorder) result(insideFZ) Uses: constants proc~~isinsidefz~~UsesGraph proc~isinsidefz IsinsideFZ module~constants constants module~constants->proc~isinsidefz local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief does Rodrigues point lie inside the relevant FZ\n @param rod Rodrigues coordinates  (double precision)\n @param FZtype FZ type\n @param FZorder FZ order\n @date 01/01/15 MDG 1.0 new routine, needed for dictionary indexing approach\n @date 06/04/15 MDG 1.1 corrected infty to inftyd (double precision infinity)\n @date 04/02/17 MDG 1.2 expanded FZ types to include misorientation FZs and icosahedral Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: rod (4) integer(kind=irg), intent(in) :: FZtype integer(kind=irg), intent(in) :: FZorder Return Value logical Calls proc~~isinsidefz~~CallsGraph proc~isinsidefz IsinsideFZ proc~insidecubicfz insideCubicFZ proc~isinsidefz->proc~insidecubicfz proc~insidecubehexfz insideCubeHexFZ proc~isinsidefz->proc~insidecubehexfz proc~insidecyclicfz insideCyclicFZ proc~isinsidefz->proc~insidecyclicfz proc~insidedihedralfz insideDihedralFZ proc~isinsidefz->proc~insidedihedralfz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~isinsidefz~~CalledByGraph proc~isinsidefz IsinsideFZ proc~reduceorientationtorfz ReduceOrientationtoRFZ proc~reduceorientationtorfz->proc~isinsidefz proc~samplerfztwin SampleRFZtwin proc~samplerfztwin->proc~isinsidefz proc~sample_cone sample_Cone proc~sample_cone->proc~isinsidefz proc~samplerfz SampleRFZ proc~samplerfz->proc~isinsidefz proc~forwardprojection ForwardProjection proc~forwardprojection->proc~reduceorientationtorfz proc~backprojection BackProjection proc~backprojection->proc~reduceorientationtorfz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code IsinsideFZ Source Code recursive function IsinsideFZ ( rod , FZtype , FZorder ) result ( insideFZ ) !DEC$ ATTRIBUTES DLLEXPORT :: IsinsideFZ use constants IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: rod ( 4 ) integer ( kind = irg ), INTENT ( IN ) :: FZtype integer ( kind = irg ), INTENT ( IN ) :: FZorder logical :: insideFZ insideFZ = . FALSE . ! dealing with 180 rotations is needed only for ! FZtypes 0 and 1; the other FZs are always finite. select case ( FZtype ) case ( 0 ) insideFZ = . TRUE . ! all points are inside the FZ case ( 1 ) insideFZ = insideCyclicFZ ( rod , FZtype , FZorder ) ! infinity is checked inside this function case ( 2 ) if ( rod ( 4 ). ne . inftyd ) insideFZ = insideDihedralFZ ( rod , FZorder ) case ( 3 ) if ( rod ( 4 ). ne . inftyd ) insideFZ = insideCubicFZ ( rod , 'tet' ) case ( 4 ) if ( rod ( 4 ). ne . inftyd ) insideFZ = insideCubicFZ ( rod , 'oct' ) case ( 5 ) ! icosahedral symmetry !     if (rod(4).ne.inftyd) insideFZ = insideCubicFZ(rod,'oct') case ( 6 ) ! cubic-hexagonal misorientation FZ if ( rod ( 4 ). ne . inftyd ) insideFZ = insideCubeHexFZ ( rod ) case ( 7 ) !     if (rod(4).ne.inftyd) insideFZ = insideCubicFZ(rod,'oct') case ( 8 ) !     if (rod(4).ne.inftyd) insideFZ = insideCubicFZ(rod,'oct') end select end function IsinsideFZ","tags":"","loc":"proc/isinsidefz.html","title":"IsinsideFZ – Fortran Program"},{"text":"public recursive function insideCyclicFZ(rod, FZtype, FZorder) result(res) Uses: constants proc~~insidecyclicfz~~UsesGraph proc~insidecyclicfz insideCyclicFZ module~constants constants module~constants->proc~insidecyclicfz local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief does Rodrigues point lie inside cyclic FZ (for 2, 3, 4, and 6-fold)?\n @param rod Rodrigues coordinates  (double precision)\n @param FZtype symmetry type\n @param FZorder depending on main symmetry axis\n @date 05/12/14 MDG 1.0 original\n @date 10/02/14 MDG 2.0 rewrite\n @date 06/04/15 MDG 2.1 corrected infty to inftyd (double precision infinity) Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: rod (4) integer(kind=irg), intent(in) :: FZtype integer(kind=irg), intent(in) :: FZorder Return Value logical Called By proc~~insidecyclicfz~~CalledByGraph proc~insidecyclicfz insideCyclicFZ proc~isinsidemfz IsinsideMFZ proc~isinsidemfz->proc~insidecyclicfz proc~isinsidefz IsinsideFZ proc~isinsidefz->proc~insidecyclicfz proc~reduceorientationtorfz ReduceOrientationtoRFZ proc~reduceorientationtorfz->proc~isinsidemfz proc~reduceorientationtorfz->proc~isinsidefz proc~reducedisorientationtomfz ReduceDisorientationtoMFZ proc~reducedisorientationtomfz->proc~isinsidemfz proc~forwardprojection ForwardProjection proc~forwardprojection->proc~reduceorientationtorfz proc~backprojection BackProjection proc~backprojection->proc~reduceorientationtorfz proc~samplerfztwin SampleRFZtwin proc~samplerfztwin->proc~isinsidefz proc~sample_cone sample_Cone proc~sample_cone->proc~isinsidefz proc~samplerfz SampleRFZ proc~samplerfz->proc~isinsidefz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code insideCyclicFZ Source Code recursive function insideCyclicFZ ( rod , FZtype , FZorder ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: insideCyclicFZ use constants IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: rod ( 4 ) integer ( kind = irg ), INTENT ( IN ) :: FZtype integer ( kind = irg ), INTENT ( IN ) :: FZorder logical :: res res = . FALSE . if ( rod ( 4 ). ne . inftyd ) then if (( FZtype . eq . 1. ). and .( FZorder . eq . 2 )) then ! check the y-component vs. tan(pi/2n) res = dabs ( rod ( 2 ) * rod ( 4 )). le . LPs % BP ( FZorder ) else ! check the z-component vs. tan(pi/2n) res = dabs ( rod ( 3 ) * rod ( 4 )). le . LPs % BP ( FZorder ) end if else if (( FZtype . eq . 1. ). and .( FZorder . eq . 2 )) then if ( rod ( 2 ) . eq . 0.D0 ) res = . TRUE . else if ( rod ( 3 ). eq . 0.D0 ) res = . TRUE . end if endif end function insideCyclicFZ","tags":"","loc":"proc/insidecyclicfz.html","title":"insideCyclicFZ – Fortran Program"},{"text":"public recursive function insideDihedralFZ(rod, order) result(res) Uses: constants proc~~insidedihedralfz~~UsesGraph proc~insidedihedralfz insideDihedralFZ module~constants constants module~constants->proc~insidedihedralfz local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief does Rodrigues point lie inside dihedral FZ (for 2, 3, 4, and 6-fold)?\n @param rod Rodrigues coordinates (double precision)\n @param order depending on main symmetry axis Todo for now, we ignore here the fact that, among others, the 3m point group can be oriented in two ways;\n @todo this should be fixable in the future with an additional optional argument\n @date 05/12/14  MDG 1.0 original\n @date 10/02/14  MDG 2.0 rewrite Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: rod (4) integer(kind=irg), intent(in) :: order Return Value logical Called By proc~~insidedihedralfz~~CalledByGraph proc~insidedihedralfz insideDihedralFZ proc~insidedihedralmfz insideDihedralMFZ proc~insidedihedralmfz->proc~insidedihedralfz proc~isinsidefz IsinsideFZ proc~isinsidefz->proc~insidedihedralfz proc~isinsidemfz IsinsideMFZ proc~isinsidemfz->proc~insidedihedralmfz proc~reduceorientationtorfz ReduceOrientationtoRFZ proc~reduceorientationtorfz->proc~isinsidefz proc~reduceorientationtorfz->proc~isinsidemfz proc~reducedisorientationtomfz ReduceDisorientationtoMFZ proc~reducedisorientationtomfz->proc~isinsidemfz proc~forwardprojection ForwardProjection proc~forwardprojection->proc~reduceorientationtorfz proc~backprojection BackProjection proc~backprojection->proc~reduceorientationtorfz proc~samplerfztwin SampleRFZtwin proc~samplerfztwin->proc~isinsidefz proc~sample_cone sample_Cone proc~sample_cone->proc~isinsidefz proc~samplerfz SampleRFZ proc~samplerfz->proc~isinsidefz var panprocinsidedihedralfzCalledByGraph = svgPanZoom('#procinsidedihedralfzCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code insideDihedralFZ Source Code recursive function insideDihedralFZ ( rod , order ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: insideDihedralFZ use constants IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: rod ( 4 ) integer ( kind = irg ), INTENT ( IN ) :: order logical :: res , c1 , c2 real ( kind = dbl ) :: r ( 3 ) real ( kind = dbl ), parameter :: r1 = 1.00D0 if ( rod ( 4 ). gt . 1.5 ) then res = . FALSE . else r ( 1 : 3 ) = rod ( 1 : 3 ) * rod ( 4 ) ! first, check the z-component vs. tan(pi/2n)  (same as insideCyclicFZ) c1 = dabs ( r ( 3 )). le . LPs % BP ( order ) res = . FALSE . ! check the square boundary planes if c1=.TRUE. if ( c1 ) then select case ( order ) case ( 2 ) c2 = ( dabs ( r ( 1 )). le . r1 ). and .( dabs ( r ( 2 )). le . r1 ) case ( 3 ) c2 = dabs ( LPs % srt * r ( 1 ) + 0.5D0 * r ( 2 )). le . r1 c2 = c2 . and .( dabs ( LPs % srt * r ( 1 ) - 0.5D0 * r ( 2 )). le . r1 ) c2 = c2 . and .( dabs ( r ( 2 )). le . r1 ) case ( 4 ) c2 = ( dabs ( r ( 1 )). le . r1 ). and .( dabs ( r ( 2 )). le . r1 ) c2 = c2 . and .(( LPs % r22 * dabs ( r ( 1 ) + r ( 2 )). le . r1 ). and .( LPs % r22 * dabs ( r ( 1 ) - r ( 2 )). le . r1 )) case ( 6 ) c2 = dabs ( 0.5D0 * r ( 1 ) + LPs % srt * r ( 2 )). le . r1 c2 = c2 . and .( dabs ( LPs % srt * r ( 1 ) + 0.5D0 * r ( 2 )). le . r1 ) c2 = c2 . and .( dabs ( LPs % srt * r ( 1 ) - 0.5D0 * r ( 2 )). le . r1 ) c2 = c2 . and .( dabs ( 0.5D0 * r ( 1 ) - LPs % srt * r ( 2 )). le . r1 ) c2 = c2 . and .( dabs ( r ( 2 )). le . r1 ) c2 = c2 . and .( dabs ( r ( 1 )). le . r1 ) end select res = c2 end if end if end function insideDihedralFZ","tags":"","loc":"proc/insidedihedralfz.html","title":"insideDihedralFZ – Fortran Program"},{"text":"public recursive function insideCubicFZ(rod, ot) result(res) Uses: constants proc~~insidecubicfz~~UsesGraph proc~insidecubicfz insideCubicFZ module~constants constants module~constants->proc~insidecubicfz local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief does Rodrigues point lie inside cubic FZ (octahedral or tetrahedral)?\n @param rod Rodrigues coordinates  (double precision)\n @param ot 'oct' or 'tet', depending on symmetry\n @date 05/12/14 MDG 1.0 original\n @date 10/02/14 MDG 2.0 rewrite\n @date 01/03/15 MDG 2.1 correction of boundary error; simplification of octahedral planes\n @date 06/04/15 MDG 2.2 simplified handling of components of r Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: rod (4) character(len=3), intent(in) :: ot Return Value logical Called By proc~~insidecubicfz~~CalledByGraph proc~insidecubicfz insideCubicFZ proc~insidecubicmfz insideCubicMFZ proc~insidecubicmfz->proc~insidecubicfz proc~isinsidefz IsinsideFZ proc~isinsidefz->proc~insidecubicfz proc~isinsidemfz IsinsideMFZ proc~isinsidemfz->proc~insidecubicmfz proc~reduceorientationtorfz ReduceOrientationtoRFZ proc~reduceorientationtorfz->proc~isinsidefz proc~reduceorientationtorfz->proc~isinsidemfz proc~reducedisorientationtomfz ReduceDisorientationtoMFZ proc~reducedisorientationtomfz->proc~isinsidemfz proc~forwardprojection ForwardProjection proc~forwardprojection->proc~reduceorientationtorfz proc~backprojection BackProjection proc~backprojection->proc~reduceorientationtorfz proc~samplerfztwin SampleRFZtwin proc~samplerfztwin->proc~isinsidefz proc~sample_cone sample_Cone proc~sample_cone->proc~isinsidefz proc~samplerfz SampleRFZ proc~samplerfz->proc~isinsidefz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code insideCubicFZ Source Code recursive function insideCubicFZ ( rod , ot ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: insideCubicFZ use constants IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: rod ( 4 ) character ( 3 ), INTENT ( IN ) :: ot logical :: res , c1 , c2 real ( kind = dbl ) :: r ( 3 ) real ( kind = dbl ), parameter :: r1 = 1.0D0 real ( kind = dbl ), parameter :: eps = 1.0D-6 r ( 1 : 3 ) = rod ( 1 : 3 ) * rod ( 4 ) res = . FALSE . ! primary cube planes (only needed for octahedral case) if ( ot . eq . 'oct' ) then c1 = ( maxval ( dabs ( r )) - LPS % BP ( 4 ) . le . eps ) else c1 = . TRUE . end if ! octahedral truncation planes, both for tetrahedral and octahedral point groups c2 = (( dabs ( r ( 1 )) + dabs ( r ( 2 )) + dabs ( r ( 3 ))) - r1 . le . eps ) ! if both c1 and c2, then the point is inside if ( c1 . and . c2 ) res = . TRUE . end function insideCubicFZ","tags":"","loc":"proc/insidecubicfz.html","title":"insideCubicFZ – Fortran Program"},{"text":"public recursive function insideCubeHexFZ(rod) result(res) Uses: constants proc~~insidecubehexfz~~UsesGraph proc~insidecubehexfz insideCubeHexFZ module~constants constants module~constants->proc~insidecubehexfz local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief does Rodrigues point lie inside combined cubic-hexagonal FZ? Note For details on this test, see section 8 in \"Representation of Orientation and\n Disorientation data for Cubic, Hexagonal, Tetragonal, and Orthorhombic Crystals\", A. Heinz\n and P. Neumann, Acta Cryst. A47, 780-789 (1991)\n @param rod Rodrigues coordinates  (double precision)\n @date 04/01/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: rod (4) Return Value logical Called By proc~~insidecubehexfz~~CalledByGraph proc~insidecubehexfz insideCubeHexFZ proc~isinsidefz IsinsideFZ proc~isinsidefz->proc~insidecubehexfz proc~reduceorientationtorfz ReduceOrientationtoRFZ proc~reduceorientationtorfz->proc~isinsidefz proc~samplerfztwin SampleRFZtwin proc~samplerfztwin->proc~isinsidefz proc~sample_cone sample_Cone proc~sample_cone->proc~isinsidefz proc~samplerfz SampleRFZ proc~samplerfz->proc~isinsidefz proc~forwardprojection ForwardProjection proc~forwardprojection->proc~reduceorientationtorfz proc~backprojection BackProjection proc~backprojection->proc~reduceorientationtorfz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code insideCubeHexFZ Source Code recursive function insideCubeHexFZ ( rod ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: insideCubeHexFZ use constants IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: rod ( 4 ) logical :: res real ( kind = dbl ) :: r ( 3 ) real ( kind = dbl ), parameter :: r1 = 0.414213562373095D0 , r2 = 0.131652497587396D0 , & alpha = 0.267949192431123D0 , beta = 0.464101615137755D0 real ( kind = dbl ), parameter :: eps = 1.0D-6 r ( 1 : 3 ) = rod ( 1 : 3 ) * rod ( 4 ) res = . FALSE . if ( ( r ( 2 ). ge . 0.D0 ). and .( r ( 3 ). ge . 0.D0 ) ) then if ( (( alpha * ( r ( 1 ) + r ( 3 )) + r ( 2 )) - beta . le . eps ). and .( ( alpha * ( r ( 2 ) - r ( 3 )) + r ( 1 )) - beta . le . eps ) ) then if ( ( r ( 1 ) - r1 . le . eps ) . and . ( r ( 2 ) - r1 . le . eps ) . and . ( r ( 3 ) - r2 . le . eps ) ) res = . TRUE . end if end if end function insideCubeHexFZ","tags":"","loc":"proc/insidecubehexfz.html","title":"insideCubeHexFZ – Fortran Program"},{"text":"public recursive function IsinsideMFZ(rod, MFZtype, MFZorder) result(insideMFZ) Uses: constants proc~~isinsidemfz~~UsesGraph proc~isinsidemfz IsinsideMFZ module~constants constants module~constants->proc~isinsidemfz local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief does Rodrigues point lie inside the relevant Mackenzie (disorientation) FZ\n @param rod Rodrigues coordinates  (double precision)\n @param MFZtype MFZ type\n @param MFZorder MFZ order\n @date 09/09/16 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: rod (4) integer(kind=irg), intent(in) :: MFZtype integer(kind=irg), intent(in) :: MFZorder Return Value logical Calls proc~~isinsidemfz~~CallsGraph proc~isinsidemfz IsinsideMFZ proc~insidecubicmfz insideCubicMFZ proc~isinsidemfz->proc~insidecubicmfz proc~insidecyclicfz insideCyclicFZ proc~isinsidemfz->proc~insidecyclicfz proc~insidedihedralmfz insideDihedralMFZ proc~isinsidemfz->proc~insidedihedralmfz proc~insidecubicfz insideCubicFZ proc~insidecubicmfz->proc~insidecubicfz proc~insidedihedralfz insideDihedralFZ proc~insidedihedralmfz->proc~insidedihedralfz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~isinsidemfz~~CalledByGraph proc~isinsidemfz IsinsideMFZ proc~reduceorientationtorfz ReduceOrientationtoRFZ proc~reduceorientationtorfz->proc~isinsidemfz proc~reducedisorientationtomfz ReduceDisorientationtoMFZ proc~reducedisorientationtomfz->proc~isinsidemfz proc~forwardprojection ForwardProjection proc~forwardprojection->proc~reduceorientationtorfz proc~backprojection BackProjection proc~backprojection->proc~reduceorientationtorfz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code IsinsideMFZ Source Code recursive function IsinsideMFZ ( rod , MFZtype , MFZorder ) result ( insideMFZ ) !DEC$ ATTRIBUTES DLLEXPORT :: IsinsideMFZ use constants IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: rod ( 4 ) integer ( kind = irg ), INTENT ( IN ) :: MFZtype integer ( kind = irg ), INTENT ( IN ) :: MFZorder logical :: insideMFZ select case ( MFZtype ) case ( 0 ) insideMFZ = . TRUE . ! all points are inside the FZ case ( 1 ) insideMFZ = insideCyclicFZ ( rod , MFZtype , MFZorder ) ! infinity is checked inside this function case ( 2 ) if ( rod ( 4 ). ne . inftyd ) insideMFZ = insideDihedralMFZ ( rod , MFZorder ) case ( 3 ) if ( rod ( 4 ). ne . inftyd ) insideMFZ = insideCubicMFZ ( rod , 'tet' ) case ( 4 ) if ( rod ( 4 ). ne . inftyd ) insideMFZ = insideCubicMFZ ( rod , 'oct' ) end select end function IsinsideMFZ","tags":"","loc":"proc/isinsidemfz.html","title":"IsinsideMFZ – Fortran Program"},{"text":"public recursive function insideCubicMFZ(rod, ot) result(res) Uses: constants proc~~insidecubicmfz~~UsesGraph proc~insidecubicmfz insideCubicMFZ module~constants constants module~constants->proc~insidecubicmfz local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief does Rodrigues point lie inside cubic MacKenzie FZ (octahedral or tetrahedral)?\n @param rod Rodrigues coordinates  (double precision)\n @param ot 'oct' or 'tet', depending on symmetry\n @date 09/09/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: rod (4) character(len=3), intent(in) :: ot Return Value logical Calls proc~~insidecubicmfz~~CallsGraph proc~insidecubicmfz insideCubicMFZ proc~insidecubicfz insideCubicFZ proc~insidecubicmfz->proc~insidecubicfz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~insidecubicmfz~~CalledByGraph proc~insidecubicmfz insideCubicMFZ proc~isinsidemfz IsinsideMFZ proc~isinsidemfz->proc~insidecubicmfz proc~reduceorientationtorfz ReduceOrientationtoRFZ proc~reduceorientationtorfz->proc~isinsidemfz proc~reducedisorientationtomfz ReduceDisorientationtoMFZ proc~reducedisorientationtomfz->proc~isinsidemfz proc~forwardprojection ForwardProjection proc~forwardprojection->proc~reduceorientationtorfz proc~backprojection BackProjection proc~backprojection->proc~reduceorientationtorfz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code insideCubicMFZ Source Code recursive function insideCubicMFZ ( rod , ot ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: insideCubicMFZ use constants IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: rod ( 4 ) character ( 3 ), INTENT ( IN ) :: ot logical :: res , c0 , c1 , c2 , c3 real ( kind = dbl ) :: r ( 3 ) res = . FALSE . ! first of all, we need to be inside the regular FZ c0 = insideCubicFz ( rod , ot ) r ( 1 : 3 ) = rod ( 1 : 3 ) * rod ( 4 ) if ( ot . eq . 'oct' ) then c1 = ( c0 . and .( r ( 3 ). ge . 0.D0 )) c2 = ( c1 . and .( r ( 2 ). ge . r ( 3 ))) c3 = ( c2 . and .( r ( 1 ). ge . r ( 2 ))) else c1 = ( c0 . and .( minval ( r ). ge . 0.D0 )) ! in the first octant if ( r ( 1 ). le . r ( 2 )) then c3 = ( c1 . and .( r ( 3 ). le . r ( 1 ))) else c3 = ( c1 . and .( r ( 3 ). le . r ( 2 ))) end if end if res = c3 end function insideCubicMFZ","tags":"","loc":"proc/insidecubicmfz.html","title":"insideCubicMFZ – Fortran Program"},{"text":"public recursive function insideDihedralMFZ(rod, MFZorder) result(res) Uses: constants proc~~insidedihedralmfz~~UsesGraph proc~insidedihedralmfz insideDihedralMFZ module~constants constants module~constants->proc~insidedihedralmfz local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief does Rodrigues point lie inside cubic MacKenzie FZ (octahedral or tetrahedral)?\n @param rod Rodrigues coordinates  (double precision)\n @param ot 'oct' or 'tet', depending on symmetry\n @date 09/09/16 MDG 1.0 original\n @date 09/15/16 MDG 1.0 completed all orders Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: rod (4) integer, intent(in) :: MFZorder Return Value logical Calls proc~~insidedihedralmfz~~CallsGraph proc~insidedihedralmfz insideDihedralMFZ proc~insidedihedralfz insideDihedralFZ proc~insidedihedralmfz->proc~insidedihedralfz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~insidedihedralmfz~~CalledByGraph proc~insidedihedralmfz insideDihedralMFZ proc~isinsidemfz IsinsideMFZ proc~isinsidemfz->proc~insidedihedralmfz proc~reduceorientationtorfz ReduceOrientationtoRFZ proc~reduceorientationtorfz->proc~isinsidemfz proc~reducedisorientationtomfz ReduceDisorientationtoMFZ proc~reducedisorientationtomfz->proc~isinsidemfz proc~forwardprojection ForwardProjection proc~forwardprojection->proc~reduceorientationtorfz proc~backprojection BackProjection proc~backprojection->proc~reduceorientationtorfz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code insideDihedralMFZ Source Code recursive function insideDihedralMFZ ( rod , MFZorder ) result ( res ) !DEC$ ATTRIBUTES DLLEXPORT :: insideDihedralMFZ use constants IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: rod ( 4 ) integer , INTENT ( IN ) :: MFZorder logical :: res , c0 , c1 , c2 , c3 real ( kind = dbl ) :: r ( 3 ) real ( kind = dbl ), parameter :: v = 0.57735026918962584D0 ! v = 1.0/dsqrt(3.D0) res = . FALSE . ! first of all, we need to be inside the regular FZ c0 = insideDihedralFZ ( rod , MFZorder ) r ( 1 : 3 ) = rod ( 1 : 3 ) * rod ( 4 ) if ( c0 ) then select case ( MFZorder ) case ( 2 ) c2 = ( minval ( r ). ge . 0.D0 ) case ( 3 ) c1 = ( minval ( ( / r ( 1 ), r ( 3 ) / ) ). ge . 0.D0 ) c2 = ( c1 . and .( r ( 1 ). ge . dabs ( r ( 2 )) * v )) case ( 4 ) c1 = ( minval ( r ). ge . 0.D0 ) c2 = ( c1 . and .( r ( 1 ). ge . r ( 2 ))) case ( 6 ) c1 = ( minval ( r ). ge . 0.D0 ) c2 = ( c1 . and .( r ( 1 ). ge . r ( 2 ) * v )) end select end if res = c2 end function insideDihedralMFZ","tags":"","loc":"proc/insidedihedralmfz.html","title":"insideDihedralMFZ – Fortran Program"},{"text":"public recursive subroutine getFZtypeandorder(pgnum1, FZtype, FZorder, pgnum2) Uses: typedefs constants proc~~getfztypeandorder~~UsesGraph proc~getfztypeandorder getFZtypeandorder typedefs typedefs typedefs->proc~getfztypeandorder module~constants constants module~constants->proc~getfztypeandorder local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief does Rodrigues point lie inside the relevant FZ\n @param pgnum1 point group number for phase 1\n @param FZtype FZ type\n @param FZorder FZ order\n @param pgnum2 point group number for phase 2 (optional)\n @date 04/02/17 MDG 1.0 new routine, needed for two-phase disorientations Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: pgnum1 integer(kind=irg), intent(out) :: FZtype integer(kind=irg), intent(out) :: FZorder integer(kind=irg), intent(in), optional :: pgnum2 Calls proc~~getfztypeandorder~~CallsGraph proc~getfztypeandorder getFZtypeandorder fztypetable fztypetable proc~getfztypeandorder->fztypetable fztarray fztarray proc~getfztypeandorder->fztarray fzoarray fzoarray proc~getfztypeandorder->fzoarray Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getFZtypeandorder Source Code recursive subroutine getFZtypeandorder ( pgnum1 , FZtype , FZorder , pgnum2 ) !DEC$ ATTRIBUTES DLLEXPORT :: getFZtypeandorder use typedefs use constants IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: pgnum1 integer ( kind = irg ), INTENT ( OUT ) :: FZtype integer ( kind = irg ), INTENT ( OUT ) :: FZorder integer ( kind = irg ), INTENT ( IN ), OPTIONAL :: pgnum2 integer ( kind = irg ) :: thisFZType logical :: twophase ! 0 -> x  (no symmetry or unbounded FZ for the cyclic symmetries) ! 1 -> a  mixed cubic-hexagonal FZ  -> FZtype = 6 ! 2 -> b  mixed FZ -> FZtype = 7 ! 3 -> c  octahedral FZ ! 4 -> d  tetrahedral FZ ! 5 -> e  24-sided prismatic FZ -> FZtype = 8 ! 6 -> f  622 hexagonal dihedral FZ ! 7 -> g  422 octagonal dihedral FZ ! 8 -> h  32 trigonal dihedral FZ ! 9 -> i  222 dihedral FZ ! we reserve FZtype = 5 for icosahedral symmetry, which is under development on a separate code branch twophase = . FALSE . if ( present ( pgnum2 )) twophase = . TRUE . if ( twophase . eqv .. TRUE .) then thisFZtype = FZtypeTable ( pgnum1 , pgnum2 ) select case ( thisFZtype ) case ( 0 ) ! this needs some more work since we need to properly handle the cyclic groups of FZtype = 1 ... FZtype = 0 FZorder = 0 case ( 1 ) FZtype = 6 FZorder = 0 case ( 2 ) FZtype = 7 FZorder = 0 case ( 3 ) FZtype = 4 FZorder = 0 case ( 4 ) FZtype = 3 FZorder = 0 case ( 5 ) FZtype = 8 FZorder = 0 case ( 6 ) FZtype = 2 FZorder = 6 case ( 7 ) FZtype = 2 FZorder = 4 case ( 8 ) FZtype = 2 FZorder = 3 case ( 9 ) FZtype = 2 FZorder = 2 end select else ! single phase so use the old way of doing things... FZtype = FZtarray ( pgnum1 ) FZorder = FZoarray ( pgnum1 ) end if end subroutine getFZtypeandorder","tags":"","loc":"proc/getfztypeandorder.html","title":"getFZtypeandorder – Fortran Program"},{"text":"public recursive subroutine delete_FZlist(top) Uses: typedefs proc~~delete_fzlist~~UsesGraph proc~delete_fzlist delete_FZlist typedefs typedefs typedefs->proc~delete_fzlist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief delete a linked list of rodrigues vectors\n @param FZlist linked list\n @date 02/20/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name type(FZpointd), intent(inout), pointer :: top Source Code delete_FZlist Source Code recursive subroutine delete_FZlist ( top ) !DEC$ ATTRIBUTES DLLEXPORT :: delete_FZlist use typedefs IMPLICIT NONE type ( FZpointd ), pointer , INTENT ( INOUT ) :: top type ( FZpointd ), pointer :: ltail , ltmp ! deallocate the entire linked list before returning, to prevent memory leaks ltail => top ltmp => ltail % next do deallocate ( ltail ) if (. not . associated ( ltmp )) EXIT ltail => ltmp ltmp => ltail % next end do end subroutine delete_FZlist","tags":"","loc":"proc/delete_fzlist.html","title":"delete_FZlist – Fortran Program"},{"text":"public recursive subroutine SampleRFZ(nsteps, pgnum, gridtype, FZcnt, FZlist) Uses: typedefs constants rotations proc~~samplerfz~~UsesGraph proc~samplerfz SampleRFZ typedefs typedefs typedefs->proc~samplerfz module~constants constants module~constants->proc~samplerfz rotations rotations rotations->proc~samplerfz local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief Generate a uniform sampling of a Rodriguess FZ Note This routine fills in a linked list FZlist of Rodrigues points that \n are inside a specific fundamental zone determined by the sample point group;\n this list can then be further dealt with in the calling program. Here's how you would use this routine in a main program: use so3 integer(kind=irg)       :: FZcnt, nsteps, pgnum\n type(FZpointd),pointer  :: FZlist, FZtmp nullify(FZlist)\n FZcnt = 0\n nsteps = 10\n pgnum = 32\n call sampleRFZ(nsteps, pgnum, FZcnt, FZlist) Then you can access all the entries in the list and, for instance, convert them to Euler angles... FZtmp => FZlist                        ! point to the top of the list\n do i = 1, FZcnt                        ! loop over all entries\n   eu = ro2eu(FZtmp%rod)                ! convert to Euler angles\n   do something with eu                 ! for instance, write eu to a file\n   FZtmp => FZtmp%next                  ! point to the next entry\n end do If you just want to look at the first 10 entries on the list and show all other orientation representations: type(orientationtyped):: ot FZtmp => FZlist\n do i = 1,10\n   ot = init_orientation(FZtmp%rod,'ro')\n   call print_orientation(ot)\n   FZtmp => FZtmp%next\n end do\n @param nsteps number of steps along semi-edge in cubochoric grid\n @param pgnum point group number to determine the appropriate Rodrigues fundamental zone\n @param gridtype (input) 0 for origin-centered grid; 1 for grid with origin at box center\n @param FZcnt (output) number of points inside fundamental zone\n @param FZlist (output) linked list of points inside fundamental zone\n @date 05/12/14 MDG 1.0 original\n @date 10/02/14 MDG 2.0 rewrite, removed all globals, added function arguments\n @date 09/15/15 MDG 2.1 removed explicit origin allocation; changed while to do loops.\n @date 01/17/15 MDG 2.2 added gridtype option\n @date 05/22/16 MDG 2.3 correction for monoclinic symmetry with twofold axis along b, not c !!! Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nsteps integer(kind=irg), intent(in) :: pgnum integer(kind=irg), intent(in) :: gridtype integer(kind=irg), intent(out) :: FZcnt type(FZpointd), intent(out), pointer :: FZlist Calls proc~~samplerfz~~CallsGraph proc~samplerfz SampleRFZ proc~isinsidefz IsinsideFZ proc~samplerfz->proc~isinsidefz cu2ro cu2ro proc~samplerfz->cu2ro fztarray fztarray proc~samplerfz->fztarray fzoarray fzoarray proc~samplerfz->fzoarray proc~insidecubicfz insideCubicFZ proc~isinsidefz->proc~insidecubicfz proc~insidecubehexfz insideCubeHexFZ proc~isinsidefz->proc~insidecubehexfz proc~insidecyclicfz insideCyclicFZ proc~isinsidefz->proc~insidecyclicfz proc~insidedihedralfz insideDihedralFZ proc~isinsidefz->proc~insidedihedralfz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code SampleRFZ Source Code recursive subroutine SampleRFZ ( nsteps , pgnum , gridtype , FZcnt , FZlist ) !DEC$ ATTRIBUTES DLLEXPORT :: SampleRFZ use typedefs use constants use rotations IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: nsteps integer ( kind = irg ), INTENT ( IN ) :: pgnum integer ( kind = irg ), INTENT ( IN ) :: gridtype integer ( kind = irg ), INTENT ( OUT ) :: FZcnt ! counts number of entries in linked list type ( FZpointd ), pointer , INTENT ( OUT ) :: FZlist ! pointers real ( kind = dbl ) :: x , y , z , rod ( 4 ), delta , shift , sedge , ztmp type ( FZpointd ), pointer :: FZtmp , FZtmp2 integer ( kind = irg ) :: FZtype , FZorder , i , j , k logical :: b ! cube semi-edge length s = 0.5D0 * LPs%ap ! step size for sampling of grid; total number of samples = (2*nsteps+1)**3 sedge = 0.5D0 * LPs % ap delta = sedge / dble ( nsteps ) if ( gridtype . eq . 0 ) then shift = 0.0D0 else shift = 0.5D0 end if ! set the counter to zero FZcnt = 0 ! make sure the linked lists are empty if ( associated ( FZlist )) then FZtmp => FZlist % next FZtmp2 => FZlist do deallocate ( FZtmp2 ) if (. not . associated ( FZtmp ) ) EXIT FZtmp2 => FZtmp FZtmp => FZtmp % next end do nullify ( FZlist ) else nullify ( FZlist ) end if ! determine which function we should call for this point group symmetry FZtype = FZtarray ( pgnum ) FZorder = FZoarray ( pgnum ) ! note that when FZtype is cyclic (1) and FZorder is 2, then we must rotate the ! rotation axis to lie along the b (y) direction, not z !!!! ! loop over the cube of volume pi&#94;2; note that we do not want to include ! the opposite edges/facets of the cube, to avoid double counting rotations ! with a rotation angle of 180 degrees.  This only affects the cyclic groups. do i =- nsteps + 1 , nsteps x = ( dble ( i ) + shift ) * delta do j =- nsteps + 1 , nsteps y = ( dble ( j ) + shift ) * delta do k =- nsteps + 1 , nsteps z = ( dble ( k ) + shift ) * delta ! make sure that this point lies inside the cubochoric cell if ( maxval ( ( / abs ( x ), abs ( y ), abs ( z ) / ) ). le . sedge ) then ! convert to Rodrigues representation rod = cu2ro ( ( / x , y , z / ) ) ! If insideFZ=.TRUE., then add this point to the linked list FZlist and keep ! track of how many points there are on this list b = IsinsideFZ ( rod , FZtype , FZorder ) if ( b ) then if (. not . associated ( FZlist )) then allocate ( FZlist ) FZtmp => FZlist ! in DEBUG mode, there is a strange error here ... ! if gridtype = 0 then we must add the identity rotation here ! currently, the identity is not automatically recognized since the ! returns from several rotation routines also equal the identity when ! the point is actually invalid... !          if (gridtype.eq.0) then !            FZcnt = 1 !            FZtmp%rod = (/ 0.D0, 0.D0, 1.D0, 0.D0 /) !            allocate(FZtmp%next) !            FZtmp => FZtmp%next !            nullify(FZtmp%next) !          end if else allocate ( FZtmp % next ) FZtmp => FZtmp % next end if nullify ( FZtmp % next ) ! if monoclinic, then reorder the components !!! !        if ((FZtype.eq.1).and.(FZorder.eq.2)) then !          ztmp = rod(3) !          rod(3) = rod(1) !          rod(1) = rod(2) !          rod(2) = ztmp !        end if FZtmp % rod = rod FZcnt = FZcnt + 1 end if end if end do end do end do end subroutine SampleRFZ","tags":"","loc":"proc/samplerfz.html","title":"SampleRFZ – Fortran Program"},{"text":"public recursive subroutine CubochoricNeighbors(cubneighbor, nn, cub, stepsize) Uses: constants proc~~cubochoricneighbors~~UsesGraph proc~cubochoricneighbors CubochoricNeighbors module~constants constants module~constants->proc~cubochoricneighbors local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief find the nearest neighbors of a point in s03 space, given the point\n and the step size used in the previous meshing. to be used in multi resolution\n indexing programs, specifically the PED, ECP and EBSD indexing. we're not worrying\n about keeping the neighbors in the FZ. that can just be done later.\n @param cub cubochoric coordinates  (double precision)\n @param stepsize stepsize of last mesh. the mesh will be stepsize/2\n @date 04/07/15 SS 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(out) :: cubneighbor (3,(2*nn+1)**3) integer(kind=irg), intent(in) :: nn real(kind=dbl), intent(in) :: cub (3) real(kind=dbl), intent(in) :: stepsize Source Code CubochoricNeighbors Source Code recursive subroutine CubochoricNeighbors ( cubneighbor , nn , cub , stepsize ) !DEC$ ATTRIBUTES DLLEXPORT :: CubochoricNeighbors use constants IMPLICIT NONE real ( kind = dbl ), INTENT ( OUT ) :: cubneighbor ( 3 ,( 2 * nn + 1 ) ** 3 ) integer ( kind = irg ), INTENT ( IN ) :: nn ! number of nearest neighbor in each direction (should be an odd number for symmetric meshing) real ( kind = dbl ), INTENT ( IN ) :: cub ( 3 ) real ( kind = dbl ), INTENT ( IN ) :: stepsize integer ( kind = irg ) :: ii , jj , kk , ll , idx if ( dabs ( stepsize ) . gt . LPs % ap ) then write ( * , * ) \"ERROR in subroutine CubochoricNeighbors: Step size is larger than edge length of the cube\" stop end if do ii = - nn , nn do jj = - nn , nn do kk = - nn , nn idx = ( ii + nn ) * ( 2 * nn + 1 ) ** 2 + ( jj + nn ) * ( 2 * nn + 1 ) + ( kk + nn + 1 ) cubneighbor ( 1 : 3 , idx ) = cub + stepsize / 2.D0 * ( / ii , jj , kk / ) do ll = 1 , 3 if ( cubneighbor ( ll , idx ) . lt . - 0.5D0 * LPs % ap ) then cubneighbor ( ll , idx ) = cubneighbor ( ll , idx ) + LPs % ap else if ( cubneighbor ( ll , idx ) . gt . 0.5D0 * LPs % ap ) then cubneighbor ( ll , idx ) = cubneighbor ( ll , idx ) - LPs % ap end if end do end do end do end do end subroutine CubochoricNeighbors","tags":"","loc":"proc/cubochoricneighbors.html","title":"CubochoricNeighbors – Fortran Program"},{"text":"public recursive subroutine SamplefcctwinRFZ(nsteps, FZcnt, FZlist) Uses: local constants typedefs rotations quaternions proc~~samplefcctwinrfz~~UsesGraph proc~samplefcctwinrfz SamplefcctwinRFZ typedefs typedefs typedefs->proc~samplefcctwinrfz rotations rotations rotations->proc~samplefcctwinrfz local local local->proc~samplefcctwinrfz module~constants constants local->module~constants quaternions quaternions quaternions->proc~samplefcctwinrfz module~constants->proc~samplefcctwinrfz Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief uniformly sample the 32-based FZ for an fcc twin.\n @param nsteps number of steps along semi-edge in cubochoric grid\n @param FZcnt (output) number of points inside fundamental zone\n @param FZlist (output) linked list of points inside fundamental zone\n @date 09/17/16 MDG 1.0 fcc twin FZ for 60@[111] (also MacKenzie cell) Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nsteps integer(kind=irg), intent(out) :: FZcnt type(FZpointd), intent(out), pointer :: FZlist Calls proc~~samplefcctwinrfz~~CallsGraph proc~samplefcctwinrfz SamplefcctwinRFZ cu2ro cu2ro proc~samplefcctwinrfz->cu2ro Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code SamplefcctwinRFZ Source Code recursive subroutine SamplefcctwinRFZ ( nsteps , FZcnt , FZlist ) !DEC$ ATTRIBUTES DLLEXPORT :: SamplefcctwinRFZ use local use constants use typedefs use rotations use quaternions IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: nsteps integer ( kind = irg ), INTENT ( OUT ) :: FZcnt ! counts number of entries in linked list type ( FZpointd ), pointer , INTENT ( OUT ) :: FZlist ! pointers real ( kind = dbl ), allocatable :: vertex (:,:), normals (:,:) integer ( kind = irg ), allocatable :: faces (:,:) real ( kind = dbl ) :: r21 ( 3 ), r23 ( 3 ), rv ( 3 ) integer ( kind = irg ) :: i , j , nv , nf , nn real ( kind = dbl ) :: x , y , z , s , rod ( 4 ), rodt ( 4 ), delta , rval , ro ( 3 ), dp type ( FZpointd ), pointer :: FZtmp , FZtmp2 logical :: inside ! a point is inside a polyhedron if the dot product of a vector from that ! point to any vertex of each face with the face normal is positive ! this routine is specifically written for the fcc twin 60°@[111]; the FZ in ! that case has the following vertex positions with respect to the standard ! 432 rfz (determined with the EMRFZ program): nv = 14 nf = 18 nn = 18 allocate ( vertex ( 3 , nv ), faces ( 4 , nf ), normals ( 3 , nn )) vertex ( 1 : 3 , 1 ) = ( / 0.3333334 , 0.3333333 , 0.3333333 / ); vertex ( 1 : 3 , 2 ) = ( / 0.0906927 , 0.0906927 , 0.3333333 / ); vertex ( 1 : 3 , 3 ) = ( / 0.0098125 , 0.2524531 , 0.2524532 / ); vertex ( 1 : 3 , 4 ) = ( / 0.0906928 , 0.3333333 , 0.0906928 / ); vertex ( 1 : 3 , 5 ) = ( / 0.2524532 , 0.2524531 , 0.0098125 / ); vertex ( 1 : 3 , 6 ) = ( / 0.3333334 , 0.0906927 , 0.0906927 / ); vertex ( 1 : 3 , 7 ) = ( / 0.2524532 , 0.0098125 , 0.2524531 / ); vertex ( 1 : 3 , 8 ) = ( /- 0.2524531 , - 0.2524531 , - 0.0098124 / ); vertex ( 1 : 3 , 9 ) = ( /- 0.3333333 , - 0.0906927 , - 0.0906926 / ); vertex ( 1 : 3 , 10 ) = ( /- 0.2524531 , - 0.0098124 , - 0.2524531 / ); vertex ( 1 : 3 , 11 ) = ( /- 0.0906926 , - 0.0906926 , - 0.3333333 / ); vertex ( 1 : 3 , 12 ) = ( /- 0.0098124 , - 0.2524531 , - 0.2524530 / ); vertex ( 1 : 3 , 13 ) = ( /- 0.0906926 , - 0.3333333 , - 0.0906926 / ); vertex ( 1 : 3 , 14 ) = ( /- 0.3333333 , - 0.3333333 , - 0.3333333 / ); ! next, get the face vertex numbers (triangles and squares) in counterclockwise ! order when looking towards the origin; triangle faces first, then the rectangles faces ( 1 : 4 , 1 ) = ( / 1 , 3 , 2 , 0 / ) faces ( 1 : 4 , 2 ) = ( / 1 , 4 , 3 , 0 / ) faces ( 1 : 4 , 3 ) = ( / 1 , 5 , 4 , 0 / ) faces ( 1 : 4 , 4 ) = ( / 1 , 6 , 5 , 0 / ) faces ( 1 : 4 , 5 ) = ( / 1 , 7 , 6 , 0 / ) faces ( 1 : 4 , 6 ) = ( / 1 , 2 , 7 , 0 / ) faces ( 1 : 4 , 7 ) = ( / 14 , 8 , 9 , 0 / ) faces ( 1 : 4 , 8 ) = ( / 14 , 9 , 10 , 0 / ) faces ( 1 : 4 , 9 ) = ( / 14 , 10 , 11 , 0 / ) faces ( 1 : 4 , 10 ) = ( / 14 , 11 , 12 , 0 / ) faces ( 1 : 4 , 11 ) = ( / 14 , 12 , 13 , 0 / ) faces ( 1 : 4 , 12 ) = ( / 14 , 13 , 8 , 0 / ) faces ( 1 : 4 , 13 ) = ( / 2 , 3 , 9 , 8 / ) faces ( 1 : 4 , 14 ) = ( / 3 , 4 , 10 , 9 / ) faces ( 1 : 4 , 15 ) = ( / 4 , 5 , 11 , 10 / ) faces ( 1 : 4 , 16 ) = ( / 5 , 6 , 12 , 11 / ) faces ( 1 : 4 , 17 ) = ( / 6 , 7 , 13 , 12 / ) faces ( 1 : 4 , 18 ) = ( / 7 , 2 , 8 , 13 / ) ! next we get the outward normal for each of the faces ! we'll get the outward normal by computing the cross product of 2-1 and 2-3 do i = 1 , nn r21 ( 1 : 3 ) = vertex ( 1 : 3 , faces ( 3 , i )) - vertex ( 1 : 3 , faces ( 2 , i )) r23 ( 1 : 3 ) = vertex ( 1 : 3 , faces ( 1 , i )) - vertex ( 1 : 3 , faces ( 2 , i )) normals ( 1 : 3 , i ) = ( / r21 ( 2 ) * r23 ( 3 ) - r21 ( 3 ) * r23 ( 2 ), r21 ( 3 ) * r23 ( 1 ) - r21 ( 1 ) * r23 ( 3 ), r21 ( 1 ) * r23 ( 2 ) - r21 ( 2 ) * r23 ( 1 ) / ) write ( * , * ) i , dot_product ( vertex ( 1 : 3 , faces ( 3 , i )), normals ( 1 : 3 , i )) end do ! here we do the regular cubochoric sampling, but use the dot product test to ! determine whether or not the point is inside the twin RFZ ! cube semi-edge length s = 0.5D0 * LPs % ap ! step size for sampling of grid; total number of samples = (2*nsteps+1)**3 delta = s / dble ( nsteps ) ! set the counter to zero FZcnt = 0 ! make sure the linked lists are empty if ( associated ( FZlist )) then FZtmp => FZlist % next FZtmp2 => FZlist do deallocate ( FZtmp2 ) if (. not . associated ( FZtmp ) ) EXIT FZtmp2 => FZtmp FZtmp => FZtmp % next end do nullify ( FZlist ) end if ! we always want the identity rotation to be the first one on the list ! it is automatically skipped later on... allocate ( FZlist ) FZtmp => FZlist nullify ( FZtmp % next ) FZtmp % rod = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) FZcnt = 1 ! loop over the cube of volume pi&#94;2; note that we do not want to include ! the opposite edges/facets of the cube, to avoid double counting rotations ! with a rotation angle of 180 degrees.  This only affects the cyclic groups. x = - s do while ( x . lt . s ) y = - s do while ( y . lt . s ) z = - s do while ( z . lt . s ) if (( x . ne . 0.D0 ). and .( y . ne . 0.D0 ). and .( z . ne . 0.D0 )) then ! convert to Rodrigues representation rod = cu2ro ( ( / x , y , z / ) ) ro ( 1 : 3 ) = rod ( 1 : 3 ) * rod ( 4 ) ! assume the point is inside and start the tests for each of the face normals inside = . TRUE . FACELOOP : do i = 1 , nn rv ( 1 : 3 ) = vertex ( 1 : 3 , faces ( 1 , i )) - ro ( 1 : 3 ) dp = DOT_PRODUCT ( rv , normals ( 1 : 3 , i )) if ( dp . lt . 0.D0 ) then inside = . FALSE . exit FACELOOP end if end do FACELOOP ! If inside=.TRUE., then add this point to the linked list FZlist and keep ! track how many points there are on this list if ( inside ) then allocate ( FZtmp % next ) FZtmp => FZtmp % next nullify ( FZtmp % next ) FZtmp % rod = rod FZcnt = FZcnt + 1 end if end if z = z + delta end do y = y + delta end do x = x + delta end do ! that's it. write ( * , * ) 'nsteps, delta, s = ' , nsteps , delta , s write ( * , * ) 'FZcnt = ' , FZcnt end subroutine SamplefcctwinRFZ","tags":"","loc":"proc/samplefcctwinrfz.html","title":"SamplefcctwinRFZ – Fortran Program"},{"text":"public recursive subroutine SampleRFZtwin(nsteps, pgnum, qt, FZcnt, FZlist) Uses: local constants typedefs rotations quaternions proc~~samplerfztwin~~UsesGraph proc~samplerfztwin SampleRFZtwin typedefs typedefs typedefs->proc~samplerfztwin rotations rotations rotations->proc~samplerfztwin local local local->proc~samplerfztwin module~constants constants local->module~constants quaternions quaternions quaternions->proc~samplerfztwin module~constants->proc~samplerfztwin Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief use a quaternion to rotate the fundamental zone, then sample it \n this is useful for twins etc, hence the name of the routine...\n @param nsteps number of steps along semi-edge in cubochoric grid\n @param pgnum point group number to determine the appropriate Rodrigues fundamental zone\n @param qt rotation quaternion\n @param FZcnt (output) number of points inside fundamental zone\n @param FZlist (output) linked list of points inside fundamental zone\n @date 04/07/15 SS  1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nsteps integer(kind=irg), intent(in) :: pgnum real(kind=sgl), intent(in) :: qt (4) integer(kind=irg), intent(out) :: FZcnt type(FZpointd), intent(out), pointer :: FZlist Calls proc~~samplerfztwin~~CallsGraph proc~samplerfztwin SampleRFZtwin proc~isinsidefz IsinsideFZ proc~samplerfztwin->proc~isinsidefz cu2ro cu2ro proc~samplerfztwin->cu2ro quat_lp quat_lp proc~samplerfztwin->quat_lp fztarray fztarray proc~samplerfztwin->fztarray fzoarray fzoarray proc~samplerfztwin->fzoarray proc~insidecubicfz insideCubicFZ proc~isinsidefz->proc~insidecubicfz proc~insidecubehexfz insideCubeHexFZ proc~isinsidefz->proc~insidecubehexfz proc~insidecyclicfz insideCyclicFZ proc~isinsidefz->proc~insidecyclicfz proc~insidedihedralfz insideDihedralFZ proc~isinsidefz->proc~insidedihedralfz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code SampleRFZtwin Source Code recursive subroutine SampleRFZtwin ( nsteps , pgnum , qt , FZcnt , FZlist ) !DEC$ ATTRIBUTES DLLEXPORT :: SampleRFZtwin use local use constants use typedefs use rotations use quaternions IMPLICIT NONE integer ( kind = irg ), INTENT ( IN ) :: nsteps integer ( kind = irg ), INTENT ( IN ) :: pgnum real ( kind = sgl ), INTENT ( IN ) :: qt ( 4 ) integer ( kind = irg ), INTENT ( OUT ) :: FZcnt ! counts number of entries in linked list type ( FZpointd ), pointer , INTENT ( OUT ) :: FZlist ! pointers real ( kind = dbl ) :: x , y , z , s , rod ( 4 ), rodt ( 4 ), delta , rval , ro ( 3 ) type ( FZpointd ), pointer :: FZtmp , FZtmp2 integer ( kind = irg ) :: FZtype , FZorder ! cube semi-edge length s = 0.5D0 * LPs % ap ! step size for sampling of grid; total number of samples = (2*nsteps+1)**3 delta = s / dble ( nsteps ) ! set the counter to zero FZcnt = 0 ! make sure the linked lists are empty if ( associated ( FZlist )) then FZtmp => FZlist % next FZtmp2 => FZlist do deallocate ( FZtmp2 ) if (. not . associated ( FZtmp ) ) EXIT FZtmp2 => FZtmp FZtmp => FZtmp % next end do nullify ( FZlist ) end if ! we always want the identity rotation to be the first one on the list ! it is automatically skipped later on... allocate ( FZlist ) FZtmp => FZlist nullify ( FZtmp % next ) FZtmp % rod = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) FZcnt = 1 ! determine which function we should call for this point group symmetry FZtype = FZtarray ( pgnum ) FZorder = FZoarray ( pgnum ) ! loop over the cube of volume pi&#94;2; note that we do not want to include ! the opposite edges/facets of the cube, to avoid double counting rotations ! with a rotation angle of 180 degrees.  This only affects the cyclic groups. x = - s do while ( x . lt . s ) y = - s do while ( y . lt . s ) z = - s do while ( z . lt . s ) if (( x . ne . 0.D0 ). and .( y . ne . 0.D0 ). and .( z . ne . 0.D0 )) then ! convert to Rodrigues representation rod = cu2ro ( ( / x , y , z / ) ) ! convert to an actual vector ro ( 1 : 3 ) = rod ( 1 : 3 ) ! then apply the twinning quaternion ro = quat_Lp ( dble ( qt ), ro ) ! convert back to a Rodrigues vector rodt = rod rodt ( 1 : 3 ) = ro ( 1 : 3 ) ! If insideFZ=.TRUE., then add this point to the linked list FZlist and keep ! track of how many points there are on this list if ( IsinsideFZ ( rodt , FZtype , FZorder )) then allocate ( FZtmp % next ) FZtmp => FZtmp % next nullify ( FZtmp % next ) FZtmp % rod = rod FZcnt = FZcnt + 1 end if end if z = z + delta end do y = y + delta end do x = x + delta end do ! that's it. write ( * , * ) 'pgnum, nsteps, delta, s = ' , pgnum , nsteps , delta , s write ( * , * ) 'FZtype, FZorder = ' , FZtype , FZorder write ( * , * ) 'FZcnt = ' , FZcnt end subroutine SampleRFZtwin","tags":"","loc":"proc/samplerfztwin.html","title":"SampleRFZtwin – Fortran Program"},{"text":"public recursive subroutine sample_isoCube(misang, N, CMcnt, CMlist) Uses: constants typedefs rotations proc~~sample_isocube~~UsesGraph proc~sample_isocube sample_isoCube typedefs typedefs typedefs->proc~sample_isocube module~constants constants module~constants->proc~sample_isocube rotations rotations rotations->proc~sample_isocube local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief sample a centered cube surface inside the Cubochoric cube for a given misorientation angle\n @details linked list wil have a length of 6(N-1)&#94;2+2 entries\n @param misang the misorientation angle [degrees]\n @param N number of points along cube semi-edge\n @param CMcnt the number of components in the returned linked list\n @param CMlist (output) linked list of Rodrigues vectors\n @date 03/03/16 MDG 1.0 original\n @date 04/19/16 MDG 1.1 changed value of N to be along the semi-edge instead of the edge Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: misang integer(kind=irg), intent(in) :: N integer(kind=irg), intent(inout) :: CMcnt type(FZpointd), pointer :: CMlist Calls proc~~sample_isocube~~CallsGraph proc~sample_isocube sample_isoCube cu2ro cu2ro proc~sample_isocube->cu2ro Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code sample_isoCube Source Code recursive subroutine sample_isoCube ( misang , N , CMcnt , CMlist ) ! CM = Constant Misorientation !DEC$ ATTRIBUTES DLLEXPORT :: sample_isoCube use constants use typedefs use rotations IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: misang ! desired misorientation angle (degrees) integer ( kind = irg ), INTENT ( IN ) :: N ! desired number of sampling points along cube edge integer ( kind = irg ), INTENT ( INOUT ) :: CMcnt ! number of entries in linked list type ( FZpointd ), pointer :: CMlist ! pointer to start of linked list type ( FZpointd ), pointer :: CMtmp , CMtmp2 real ( kind = dbl ) :: edge , misangr , dx , cu ( 3 ), x , y , z integer ( kind = irg ) :: i , j , k ! initialize parameters CMcnt = 0 ! convert the misorientation angle to radians misangr = misang * cPi / 18 0.D0 ! make sure the linked list is empty if ( associated ( CMlist )) then CMtmp => CMlist % next CMtmp2 => CMlist do deallocate ( CMtmp2 ) if (. not . associated ( CMtmp ) ) EXIT CMtmp2 => CMtmp CMtmp => CMtmp % next end do nullify ( CMlist ) end if ! allocate the linked list allocate ( CMlist ) CMtmp => CMlist ! set the cube edge length based on the misorientation angle edge = ( cPi * ( misangr - sin ( misangr ))) ** ( 1.D0 / 3.D0 ) * 0.5D0 dx = edge / dble ( N ) write ( * , * ) ' edge = ' , edge , '; delta = ' , dx ! and generate the linked list of surface points ! do the x-y bottom and top planes first (each have N&#94;2 points) do i =- N , N x = dble ( i ) * dx do j =- N , N y = dble ( j ) * dx ! add the point to the list cu = ( / x , y , edge / ) CMtmp % rod = cu2ro ( cu ) CMcnt = CMcnt + 1 allocate ( CMtmp % next ) CMtmp => CMtmp % next nullify ( CMtmp % next ) ! and its mirror image in the top plane cu = ( / x , y , - edge / ) CMtmp % rod = cu2ro ( cu ) CMcnt = CMcnt + 1 allocate ( CMtmp % next ) CMtmp => CMtmp % next nullify ( CMtmp % next ) end do end do ! then we do the y-z planes; each have N*(N-2) points do j =- N , N y = dble ( j ) * dx do k =- N + 1 , N - 1 z = dble ( k ) * dx ! add the point to the list cu = ( / edge , y , z / ) CMtmp % rod = cu2ro ( cu ) CMcnt = CMcnt + 1 allocate ( CMtmp % next ) CMtmp => CMtmp % next nullify ( CMtmp % next ) ! and its mirror image in the top plane cu = ( / - edge , y , z / ) CMtmp % rod = cu2ro ( cu ) CMcnt = CMcnt + 1 allocate ( CMtmp % next ) CMtmp => CMtmp % next nullify ( CMtmp % next ) end do end do ! and finally the x-z planes, with (N-2)&#94;2 points each do i =- N + 1 , N - 1 x = dble ( i ) * dx do k =- N + 1 , N - 1 z = dble ( k ) * dx ! add the point to the list cu = ( / x , edge , z / ) CMtmp % rod = cu2ro ( cu ) CMcnt = CMcnt + 1 allocate ( CMtmp % next ) CMtmp => CMtmp % next nullify ( CMtmp % next ) ! and its mirror image in the top plane cu = ( / x , - edge , z / ) CMtmp % rod = cu2ro ( cu ) CMcnt = CMcnt + 1 allocate ( CMtmp % next ) CMtmp => CMtmp % next nullify ( CMtmp % next ) end do end do end subroutine sample_isoCube","tags":"","loc":"proc/sample_isocube.html","title":"sample_isoCube – Fortran Program"},{"text":"public recursive subroutine sample_isoCubeFilled(misang, N, CMcnt, CMlist) Uses: constants typedefs rotations proc~~sample_isocubefilled~~UsesGraph proc~sample_isocubefilled sample_isoCubeFilled typedefs typedefs typedefs->proc~sample_isocubefilled module~constants constants module~constants->proc~sample_isocubefilled rotations rotations rotations->proc~sample_isocubefilled local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief sample a centered cube inside the Cubochoric cube for a given misorientation angle\n @details This routine is different from the sample_isoCube routine in that it \n generates ALL the points inside the centered cube instead of just the points on\n the outer surface.  This can be useful to uniformly sample a small volume of orientation\n space around some point out to a given misorientation angle.  Since the sampling has concentric\n cubes, all the samples can be subdivided into discrete misorientation classes.\n The linked list wil have a length of N&#94;3\n @param misang the misorientation angle [degrees]\n @param N number of points along cube edge\n @param CMcnt the number of components in the returned linked list\n @param CMlist (output) linked list of Rodrigues vectors\n @date 04/08/16 MDG 1.0 original\n @date 04/19/16 MDG 1.1 changed value of N to be along the semi-edge instead of the edge Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: misang integer(kind=irg), intent(in) :: N integer(kind=irg), intent(inout) :: CMcnt type(FZpointd), pointer :: CMlist Calls proc~~sample_isocubefilled~~CallsGraph proc~sample_isocubefilled sample_isoCubeFilled cu2ro cu2ro proc~sample_isocubefilled->cu2ro Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code sample_isoCubeFilled Source Code recursive subroutine sample_isoCubeFilled ( misang , N , CMcnt , CMlist ) ! CM = Constant Misorientation !DEC$ ATTRIBUTES DLLEXPORT :: sample_isoCubeFilled use constants use typedefs use rotations IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: misang ! desired misorientation angle (degrees) integer ( kind = irg ), INTENT ( IN ) :: N ! desired number of sampling points along cube edge integer ( kind = irg ), INTENT ( INOUT ) :: CMcnt ! number of entries in linked list type ( FZpointd ), pointer :: CMlist ! pointer to start of linked list type ( FZpointd ), pointer :: CMtmp , CMtmp2 real ( kind = dbl ) :: edge , misangr , dx , cu ( 3 ), x , y , z , xc , yc , zc integer ( kind = irg ) :: i , j , k ! initialize parameters CMcnt = 0 ! convert the misorientation angle to radians misangr = misang * cPi / 18 0.D0 ! make sure the linked list is empty if ( associated ( CMlist )) then CMtmp => CMlist % next CMtmp2 => CMlist do deallocate ( CMtmp2 ) if (. not . associated ( CMtmp ) ) EXIT CMtmp2 => CMtmp CMtmp => CMtmp % next end do nullify ( CMlist ) end if ! allocate the linked list allocate ( CMlist ) CMtmp => CMlist ! set the cube edge length based on the misorientation angle edge = ( cPi * ( misangr - sin ( misangr ))) ** ( 1.D0 / 3.D0 ) * 0.5D0 dx = edge / dble ( N ) ! and generate the linked list of surface points ! loop over the (2N+1)&#94;3 points do i =- N , N x = dble ( i ) * dx do j =- N , N y = dble ( j ) * dx do k =- N , N z = dble ( k ) * dx ! add the point to the list cu = ( / x , y , z / ) CMtmp % rod = cu2ro ( cu ) CMcnt = CMcnt + 1 allocate ( CMtmp % next ) CMtmp => CMtmp % next nullify ( CMtmp % next ) end do end do end do end subroutine sample_isoCubeFilled","tags":"","loc":"proc/sample_isocubefilled.html","title":"sample_isoCubeFilled – Fortran Program"},{"text":"public recursive subroutine sample_Cone(unitvector, dpmax, N, FZtype, FZorder, cnt, list) Uses: constants typedefs rotations proc~~sample_cone~~UsesGraph proc~sample_cone sample_Cone typedefs typedefs typedefs->proc~sample_cone module~constants constants module~constants->proc~sample_cone rotations rotations rotations->proc~sample_cone local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief sample a cone centered on a unit vector with apex in the origin and given opening angle\n @param unitvector  unit vector describing the cone axis\n @param dpmax = cosine of half the cone angle\n @param N number of points along cube edge\n @param CMcnt the number of components in the returned linked list\n @param CMlist (output) linked list of Rodrigues vectors\n @date 02/01/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: unitvector (3) real(kind=dbl), intent(in) :: dpmax integer(kind=irg), intent(in) :: N integer(kind=irg), intent(in) :: FZtype integer(kind=irg), intent(in) :: FZorder integer(kind=irg), intent(inout) :: cnt type(FZpointd), pointer :: list Calls proc~~sample_cone~~CallsGraph proc~sample_cone sample_Cone cu2ro cu2ro proc~sample_cone->cu2ro proc~isinsidefz IsinsideFZ proc~sample_cone->proc~isinsidefz proc~insidecubicfz insideCubicFZ proc~isinsidefz->proc~insidecubicfz proc~insidecubehexfz insideCubeHexFZ proc~isinsidefz->proc~insidecubehexfz proc~insidecyclicfz insideCyclicFZ proc~isinsidefz->proc~insidecyclicfz proc~insidedihedralfz insideDihedralFZ proc~isinsidefz->proc~insidedihedralfz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code sample_Cone Source Code recursive subroutine sample_Cone ( unitvector , dpmax , N , FZtype , FZorder , cnt , list ) !DEC$ ATTRIBUTES DLLEXPORT :: sample_Cone use constants use typedefs use rotations IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: unitvector ( 3 ) ! axis of cone real ( kind = dbl ), INTENT ( IN ) :: dpmax ! maximum dot product integer ( kind = irg ), INTENT ( IN ) :: N ! number of sampling points along cube semi edge integer ( kind = irg ), INTENT ( IN ) :: FZtype integer ( kind = irg ), INTENT ( IN ) :: FZorder integer ( kind = irg ), INTENT ( INOUT ) :: cnt ! number of entries in linked list type ( FZpointd ), pointer :: list ! pointer to start of linked list type ( FZpointd ), pointer :: tmp , tmp2 real ( kind = dbl ) :: dx , rod ( 4 ), x , y , z , s , delta , dp , r ( 3 ) ! initialize parameters cnt = 0 ! cube semi-edge length s = 0.5D0 * LPs % ap ! step size for sampling of grid; total number of samples = (2*nsteps+1)**3 delta = s / dble ( N ) ! make sure the linked list is empty if ( associated ( list )) then tmp => list % next tmp2 => list do deallocate ( tmp2 ) if (. not . associated ( tmp ) ) EXIT tmp2 => tmp tmp => tmp % next end do nullify ( list ) end if ! allocate the linked list and insert the origin allocate ( list ) tmp => list nullify ( tmp % next ) tmp % rod = ( / 0.D0 , 0.D0 , 0.D0 , 0.D0 / ) cnt = 1 ! and generate the linked list of points inside the cone x = - s do while ( x . lt . s ) y = - s do while ( y . lt . s ) z = - s do while ( z . lt . s ) if (( x . ne . 0.D0 ). and .( y . ne . 0.D0 ). and .( z . ne . 0.D0 )) then ! convert to Rodrigues representation rod = cu2ro ( ( / x , y , z / ) ) r = rod ( 1 : 3 ) / sqrt ( sum ( rod ( 1 : 3 ) ** 2 )) ! compute the dot product of this vector and the unitvector dp = unitvector ( 1 ) * r ( 1 ) + unitvector ( 2 ) * r ( 2 ) + unitvector ( 3 ) * r ( 3 ) ! conditionally add the point to the list if it lies inside the cone (dpmax <= dp) if (( dp . ge . dpmax ). and .( IsinsideFZ ( rod , FZtype , FZorder ))) then allocate ( tmp % next ) tmp => tmp % next nullify ( tmp % next ) tmp % trod = rod cnt = cnt + 1 end if end if z = z + delta end do y = y + delta end do x = x + delta end do end subroutine sample_Cone","tags":"","loc":"proc/sample_cone.html","title":"sample_Cone – Fortran Program"},{"text":"public recursive subroutine SampleIsoMisorientation(rhozero, misang, CMcnt, CMlist) Uses: constants typedefs math proc~~sampleisomisorientation~~UsesGraph proc~sampleisomisorientation SampleIsoMisorientation typedefs typedefs typedefs->proc~sampleisomisorientation module~constants constants module~constants->proc~sampleisomisorientation math math math->proc~sampleisomisorientation local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief Constant Misorientation sampling routine; input list must be generated by sampleCubeSurface\n @param rhozero central Rodrigues point around which constant misorientation sample is requested\n @param misang the misorientation angle [degrees]\n @param CMcnt the number of components in the returned linked list\n @param CMlist (output) linked list of Rodrigues vectors, with transformed vectors in trod(4) entries\n @date 03/03/16 SS/MDG 1.0 original (merged from two separate implementations) Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: rhozero (4) real(kind=dbl), intent(in) :: misang integer(kind=irg), intent(inout) :: CMcnt type(FZpointd), pointer :: CMlist Calls proc~~sampleisomisorientation~~CallsGraph proc~sampleisomisorientation SampleIsoMisorientation cross3 cross3 proc~sampleisomisorientation->cross3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code SampleIsoMisorientation Source Code recursive subroutine SampleIsoMisorientation ( rhozero , misang , CMcnt , CMlist ) ! CM = Constant Misorientation !DEC$ ATTRIBUTES DLLEXPORT :: SampleIsoMisorientation use constants use typedefs use math IMPLICIT NONE real ( kind = dbl ), INTENT ( IN ) :: rhozero ( 4 ) ! center Rodrigues vector real ( kind = dbl ), INTENT ( IN ) :: misang ! desired misorientation angle (degrees) integer ( kind = irg ), INTENT ( INOUT ) :: CMcnt ! number of entries in linked list type ( FZpointd ), pointer :: CMlist ! pointer to start of linked list type ( FZpointd ), pointer :: CMtmp real ( kind = dbl ) :: rhovec ( 3 ), s , vv ( 3 ) integer ( kind = irg ) :: i ! go through the list and transform all points to the spheroid misorientation surface ! the resulting Rodrigues vectors are stored in the trod(4) entry. rhovec ( 1 : 3 ) = rhozero ( 1 : 3 ) * rhozero ( 4 ) CMtmp => CMlist do i = 1 , CMcnt ! get the actual Rodrigues vector vv ( 1 : 3 ) = CMtmp % rod ( 1 : 3 ) * CMtmp % rod ( 4 ) ! apply the Rodrigues transformation formula vv = ( - vv + rhovec + cross3 ( rhovec , vv )) / ( 1.D0 + DOT_PRODUCT ( vv , rhovec )) ! and convert back to the 4-component format s = dsqrt ( sum ( vv * vv )) if ( s . gt . 0.D0 ) then CMtmp % trod = ( / vv ( 1 ) / s , vv ( 2 ) / s , vv ( 3 ) / s , s / ) else CMtmp % trod = ( / 0.D0 , 0.D0 , 1.D0 , 0.D0 / ) end if CMtmp => CMtmp % next end do end subroutine SampleIsoMisorientation","tags":"","loc":"proc/sampleisomisorientation.html","title":"SampleIsoMisorientation – Fortran Program"},{"text":"public recursive subroutine getEulersfromFile(eulerfile, FZcnt, FZlist) Uses: constants typedefs rotations proc~~geteulersfromfile~~UsesGraph proc~geteulersfromfile getEulersfromFile typedefs typedefs typedefs->proc~geteulersfromfile module~constants constants module~constants->proc~geteulersfromfile rotations rotations rotations->proc~geteulersfromfile local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read a list of Euler angles from a text file and insert them in a linked list\n @param eulerfile name of the Euler angle file (with usual path handling)\n @param FZcnt the number of components in the returned linked list\n @param FZlist (output) linked list of Rodrigues vectors, with transformed vectors in trod(4) entries\n @date 12/22/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: eulerfile integer(kind=irg), intent(inout) :: FZcnt type(FZpointd), pointer :: FZlist Calls proc~~geteulersfromfile~~CallsGraph proc~geteulersfromfile getEulersfromFile emsoft_tonativepath emsoft_tonativepath proc~geteulersfromfile->emsoft_tonativepath emsoft_getemdatapathname emsoft_getemdatapathname proc~geteulersfromfile->emsoft_getemdatapathname eu2ro eu2ro proc~geteulersfromfile->eu2ro Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code getEulersfromFile Source Code recursive subroutine getEulersfromFile ( eulerfile , FZcnt , FZlist ) !DEC$ ATTRIBUTES DLLEXPORT :: getEulersfromFile use constants use typedefs use rotations IMPLICIT NONE character ( fnlen ), INTENT ( IN ) :: eulerfile integer ( kind = irg ), INTENT ( INOUT ) :: FZcnt ! number of entries in linked list type ( FZpointd ), pointer :: FZlist ! pointer to start of linked list character ( fnlen ) :: filepath character ( 2 ) :: anglemode integer ( kind = irg ) :: numang , i real ( kind = dbl ) :: eu ( 3 ), dtor type ( FZpointd ), pointer :: FZtmp , FZtmp2 dtor = cPi / 18 0.D0 ! set the file path filepath = trim ( EMsoft_getEMdatapathname ()) // trim ( eulerfile ) filepath = EMsoft_toNativePath ( filepath ) open ( unit = 53 , file = trim ( filepath ), status = 'old' , action = 'read' ) read ( 53 , * ) anglemode read ( 53 , * ) numang ! make sure the linked list is empty if ( associated ( FZlist )) then FZtmp => FZlist % next FZtmp2 => FZlist do deallocate ( FZtmp2 ) if (. not . associated ( FZtmp ) ) EXIT FZtmp2 => FZtmp FZtmp => FZtmp % next end do nullify ( FZlist ) end if ! allocate the linked list allocate ( FZlist ) FZtmp => FZlist do i = 1 , numang read ( 53 , * ) eu ( 1 : 3 ) FZtmp % rod = eu2ro ( eu * dtor ) FZcnt = FZcnt + 1 allocate ( FZtmp % next ) FZtmp => FZtmp % next nullify ( FZtmp % next ) end do close ( unit = 53 , status = 'keep' ) end subroutine getEulersfromFile","tags":"","loc":"proc/geteulersfromfile.html","title":"getEulersfromFile – Fortran Program"},{"text":"public recursive subroutine init_STEM(STEM, cell, nn, g) Uses: io crystal diffraction proc~~init_stem~~UsesGraph proc~init_stem init_STEM io io io->proc~init_stem diffraction diffraction diffraction->proc~init_stem crystal crystal crystal->proc~init_stem Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief initialize the weight factors for the systematic row case.\n @param STEM STEM structure\n @param cell unit cell pointer\n @param nn number of beams\n @param g systematic row basic vector\n @date   04/29/11 MDG 1.0 original\n @date   06/12/13 MDG 2.0 rewrite \n @date   06/09/14 MDG 3.0 added STEM and cell arguments Arguments Type Intent Optional Attributes Name type(STEMtype), intent(inout) :: STEM type(unitcell), pointer :: cell integer(kind=irg), intent(in) :: nn integer(kind=irg), intent(in) :: g (3) Calls proc~~init_stem~~CallsGraph proc~init_stem init_STEM calcdiffangle calcdiffangle proc~init_stem->calcdiffangle message message proc~init_stem->message float float proc~init_stem->float calclength calclength proc~init_stem->calclength Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~init_stem~~CalledByGraph proc~init_stem init_STEM proc~read_stem_data read_STEM_data proc~read_stem_data->proc~init_stem Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code init_STEM Source Code recursive subroutine init_STEM ( STEM , cell , nn , g ) !DEC$ ATTRIBUTES DLLEXPORT :: init_STEM use io use crystal use diffraction IMPLICIT NONE type ( STEMtype ), INTENT ( INOUT ) :: STEM type ( unitcell ), pointer :: cell integer ( kind = irg ), INTENT ( IN ) :: nn integer ( kind = irg ), INTENT ( IN ) :: g ( 3 ) integer ( kind = irg ) :: i , j , n , ira , jj , k , kk , iCL real ( kind = sgl ) :: glen , thb , alp , omega_c , omega_min , omega_max , omega , a , b , c , th , dom , p , q , dr , dx real ( kind = sgl ), parameter :: cPi = 3.141592654 ! these are only used to debug this routine real ( kind = sgl ), allocatable :: thetar (:), outar (:,:,:) logical :: debug = . FALSE ., diffappresent = . FALSE ., apinBF = . FALSE . , apinADF = . FALSE . ! this routine initializes the excitation error arrays and the weight-factor arrays for systematic row STEM signals ! we'll assume that the central beam is centered on the BF detector; then we can ! compute the complete geometry by working in mrad units throughout. ! allocate the excitation error array areal(1..nn,1..STEM%numberofsvalues) allocate ( STEM % sgarray ( nn , STEM % numberofsvalues )) ! determine the lower and upper bounds of the excitation error for the fundamental reflection G thb = CalcDiffAngle ( cell , g ( 1 ), g ( 2 ), g ( 3 )) * 0.5 ! Bragg angle in radians ! convert k_t to the alp and omega angles (in radians) glen = CalcLength ( cell , float ( g ), 'r' ) alp = - 2.0 * STEM % kt * thb omega_c = cPi * 0.5 + alp omega_min = omega_c - STEM % beamconvergence / 100 0.0 omega_max = omega_c + STEM % beamconvergence / 100 0.0 ! step size dom = ( omega_max - omega_min ) / float ( STEM % numberofsvalues - 1 ) ! and for each value in between, compute each reflection's excitation error ira = ( nn + 1 ) / 2 do j = 1 , STEM % numberofsvalues ! set omega angle omega = omega_min + float ( j - 1 ) * dom do i = 1 , nn n = - ira + i ! excitation error STEM % sgarray ( nn + 1 - i , j ) = - n * glen * cos ( omega ) - ( 1.0 - sqrt ( 1.0 - ( n * cell % mLambda * glen * sin ( omega )) ** 2 )) / cell % mLambda end do end do if ( debug ) then allocate ( thetar ( 25 )) thetar = 0.0 thetar ( 1 : 7 ) = ( / a , b , c , th , dom , dr , dx / ) end if ! next, we compute the weightfactors, i.e., how much does each excitation error value contribute ! to the BF or ADF signal?  The weight factor is basically the length of the chord across the overlap ! area of the diffraction disk and the detector, which requires a little bit of math to figure out; ! the math employs the concept of the radical line (see mathworld.com section on circle-circle intersections) ! this computation is carried out in mrad units ! allocate ( STEM % BFweightsarray ( nn , STEM % numberofsvalues , STEM % numCL ), STEM % ADFweightsarray ( nn , STEM % numberofsvalues , STEM % numCL )) STEM % BFweightsarray = 0.0 STEM % ADFweightsarray = 0.0 outerCLloop : do iCL = 1 , STEM % numCL ! this is the outer loop over the microscope camera lengths (very long loop !!!) ! fist, convert the detector parameters to mrad units STEM % BFmrad = atan ( STEM % BFradius / STEM % CLarray ( iCL )) * 100 0.0 STEM % ADFimrad = atan ( STEM % ADFinnerradius / STEM % CLarray ( iCL )) * 100 0.0 STEM % ADFomrad = atan ( STEM % ADFouterradius / STEM % CLarray ( iCL )) * 100 0.0 if ( STEM % diffapmrad . ne . 0.0 ) diffappresent = . TRUE . ! then, for each point inside each diffraction disk, determine where it falls with respect to ! the BD and ADF detectors ... Also, look for disk overlaps as they might require amplitudes ! to be added in instead of intensities (for starters, we could just not allow that to happen...) ! rename some variables to short symbols a = STEM % ADFimrad b = STEM % ADFomrad c = STEM % BFmrad th = STEM % beamconvergence n = STEM % numberofsvalues if ( diffappresent ) then dr = STEM % diffapmrad dx = STEM % diffapmcenter end if omega_min = - th omega_max = th dom = 2.0 * th / float ( n - 1 ) if (. not . diffappresent ) then ! there is no diffraction aperture, so compute the regular weight factors ! first, do the math for the g=0 disk  (we're dropping common factors of 2 for the weights) i = ira do j = ( n + 1 ) / 2 , n omega = omega_min + float ( j - 1 ) * dom if ( th . gt . c ) then ! the zero disk is larger than the BF detector, so it (potentially) gives two signals if ( omega . le . c ) STEM % BFweightsarray ( i , j , iCL ) = sqrt ( c ** 2 - omega ** 2 ) if ( th . ge . a ) then ! there's overlap with the ADF detector if ( omega . le . a ) then ! the first part needs to have a bit subtracted STEM % ADFweightsarray ( i , j , iCL ) = sqrt (( th ** 2 - omega ** 2 )) - sqrt (( a ** 2 - omega ** 2 )) else ! the second part does not STEM % ADFweightsarray ( i , j , iCL ) = sqrt (( th ** 2 - omega ** 2 )) end if end if else ! the zero disk is smaller than the BF detector, so only a BF signal STEM % BFweightsarray ( i , j , iCL ) = sqrt (( th ** 2 - omega ** 2 )) end if ! then apply symmetry for the other half of the g=0 disk if ( j . ne .( n + 1 ) / 2 ) then jj = n + 1 - j STEM % BFweightsarray ( i , jj , iCL ) = STEM % BFweightsarray ( i , j , iCL ) STEM % ADFweightsarray ( i , jj , iCL ) = STEM % ADFweightsarray ( i , j , iCL ) end if end do ! that completes the central disk weight factors ! the other disks are quite a bit more difficult to deal with ... there are a lot of possible cases to consider ... do i = ira + 1 , nn ! loop over the positive reflections of the systematic row (the rest follows by symmetry) ! redefine a couple of parameters j = i - ira thb = CalcDiffAngle ( cell , j * g ( 1 ), j * g ( 2 ), j * g ( 3 )) * 100 0.0 ! diffraction angle in mrad omega_min = thb - th omega_max = thb + th ! only used for debugging if ( debug ) thetar ( 7 + j ) = thb ! first check if a part of this disk lies inside the BF detector if ( omega_min . lt . c ) then ! yes, it does, so determine the BF weight factors for this disk if ( omega_max . le . c ) then ! does it lie completely inside the BF detector? do j = 1 , n ! yes it does, so compute all weight factors omega = omega_min + float ( j - 1 ) * dom STEM % BFweightsarray ( i , j , iCL ) = sqrt ( th ** 2 - ( thb - omega ) ** 2 ) STEM % BFweightsarray ( 2 * ira - i , n + 1 - j , iCL ) = STEM % BFweightsarray ( i , j , iCL ) end do else ! no, there's some potential overlap with the ADF detector do j = 1 , n ! once again, there are a few cases omega = omega_min + float ( j - 1 ) * dom ! this is the position p = ( thb ** 2 - th ** 2 + a ** 2 ) * 0.5 / thb ! this is the location of the radical line for the ADF detector q = ( thb ** 2 - th ** 2 + c ** 2 ) * 0.5 / thb ! this is the location of the radical line for the BF detector if ( omega . le . q ) then ! this point contributes to the BF detector STEM % BFweightsarray ( i , j , iCL ) = sqrt ( th ** 2 - ( thb - omega ) ** 2 ) end if if (( omega . gt . q ). and .( omega . le . c )) then ! this point contributes to the BF detector STEM % BFweightsarray ( i , j , iCL ) = sqrt ( c ** 2 - omega ** 2 ) end if if (( omega_max . ge . a ). and .( omega . ge . p ). and .( omega . le . a )) then ! this point contributes to the ADF detector (using radical line position) STEM % ADFweightsarray ( i , j , iCL ) = sqrt ( th ** 2 - ( thb - omega ) ** 2 ) - sqrt ( a ** 2 - omega ** 2 ) end if if (( omega_max . ge . a ). and .( omega . gt . a )) then ! this point lies on the ADF detector STEM % ADFweightsarray ( i , j , iCL ) = sqrt ( th ** 2 - ( thb - omega ) ** 2 ) end if STEM % BFweightsarray ( 2 * ira - i , n + 1 - j , iCL ) = STEM % BFweightsarray ( i , j , iCL ) STEM % ADFweightsarray ( 2 * ira - i , n + 1 - j , iCL ) = STEM % ADFweightsarray ( i , j , iCL ) end do end if else ! no, it does not intersect the BF detector, so this disk can only contribute to the ADF weight factors ! once more there are several cases which we'll treat in increasing value of the position... do j = 1 , n omega = omega_min + float ( j - 1 ) * dom ! this is the position p = ( thb ** 2 - th ** 2 + a ** 2 ) * 0.5 / thb ! this is the location of the radical line for the inner ADF detector edge q = ( thb ** 2 - th ** 2 + b ** 2 ) * 0.5 / thb ! this is the location of the radical line for the outer ADF detector edge if (( omega . lt . a ). and .( omega . ge . p )) then ! inside the inner ADF edge, but close enough to contribute STEM % ADFweightsarray ( i , j , iCL ) = sqrt ( th ** 2 - ( thb - omega ) ** 2 ) - sqrt ( a ** 2 - omega ** 2 ) end if if (( omega . ge . a ). and .( omega_max . le . b )) then ! this point lies on the ADF detector STEM % ADFweightsarray ( i , j , iCL ) = sqrt ( th ** 2 - ( thb - omega ) ** 2 ) end if if (( omega_max . gt . b ). and .( omega . le . q )) then ! this point lies on the ADF detector STEM % ADFweightsarray ( i , j , iCL ) = sqrt ( th ** 2 - ( thb - omega ) ** 2 ) end if if (( omega_max . gt . b ). and .( omega . gt . q ). and .( omega . le . b )) then ! this point contributes to the ADF detector STEM % ADFweightsarray ( i , j , iCL ) = sqrt ( b ** 2 - omega ** 2 ) end if STEM % ADFweightsarray ( 2 * ira - i , n + 1 - j , iCL ) = STEM % ADFweightsarray ( i , j , iCL ) end do end if end do end if ! end of regular weight factors without a diffraction aperture if ( diffappresent ) then ! there is a diffraction aperture, so revisit the weight factors. ! once again, there are many different cases that need to be addressed... ! we do not allow for a diffraction aperture that overlaps the boundary between BF and ADF detectors, ! nor an aperture that lies entirely beyond the ADF detector ! first the BF test if ( (( dx - dr ). gt . - c ). and .(( dx + dr ). lt . c )) apinBF = . TRUE . ! then the ADF detector if ( ((( dx - dr ). gt . - b ). and .(( dx + dr ). lt . - c )) . or .((( dx - dr ). gt . a ). and .(( dx + dr ). lt . b )) ) apinADF = . TRUE . ! if the aperture is outside the ADF detector, or it overlaps the space between the detectors, then abort if ( . not . apinBF . and . . not . apinADF ) then call Message ( 'Please fix input: Diffraction aperture outside BF detector disk or ADF ring !' , frm = \"(A)\" ) stop end if if ( apinBF ) then ! figure out which diffraction disk(s) contribute to the BF detector do i = 1 , nn ! loop over all reflections of the systematic row ! redefine a couple of parameters j = - ( nn - 1 ) / 2 - 1 + i if ( j . ne . 0 ) then thb = ( j / abs ( j )) * CalcDiffAngle ( cell , j * g ( 1 ), j * g ( 2 ), j * g ( 3 )) * 100 0.0 ! diffraction angle in mrad else thb = 0.0 end if ! only used for debugging if ( debug ) thetar ( 7 + i ) = thb omega_min = thb - th omega_max = thb + th ! check whether or not there is any overlap between this disk and the diffraction aperture opening if (( omega_max . lt .( dx - dr )). or .( omega_min . gt .( dx + dr ))) then ! this disks does not fall inside the diffraction aperture STEM % BFweightsarray ( i , 1 : n , iCL ) = 0.0 else ! case 1: dx-dr < omega_min < omega_max < dx+dr if (( omega_max . lt .( dx + dr )). and .( omega_min . gt .( dx - dr ))) then do k = 1 , n omega = omega_min + float ( k - 1 ) * dom kk = k if ( j . lt . 0 ) kk = n + 1 - k STEM % BFweightsarray ( i , kk , iCL ) = sqrt (( th ** 2 - ( thb - omega ) ** 2 )) end do end if ! case 2: omega_min < dx-dr  < dx+dr < omega_max if (( omega_max . gt .( dx + dr )). and .( omega_min . lt .( dx - dr ))) then do k = 1 , n omega = omega_min + float ( k - 1 ) * dom kk = k if ( j . lt . 0 ) kk = n + 1 - k if (( omega . gt . dx - dr ). and .( omega . lt . dx + dr )) then STEM % BFweightsarray ( i , kk , iCL ) = sqrt (( dr ** 2 - ( omega - dx ) ** 2 )) end if end do end if ! case 3: omega_min < dx-dr   < omega_max < dx+dr if (( omega_min . lt .( dx - dr )). and .( omega_max . lt .( dx + dr ))) then p = (( dx - thb ) ** 2 - dr ** 2 + th ** 2 ) / 2.0 / ( dx - thb ) + thb do k = 1 , n omega = omega_min + float ( k - 1 ) * dom kk = k !         if (j.lt.0) kk = n+1-k if (( omega . gt . dx - dr ). and .( omega . le . p )) then STEM % BFweightsarray ( i , kk , iCL ) = sqrt ( dr ** 2 - ( omega - dx ) ** 2 ) end if if (( omega . gt . p ). and .( omega . le . omega_max )) then STEM % BFweightsarray ( i , kk , iCL ) = sqrt (( th ** 2 - ( thb - omega ) ** 2 )) end if end do end if ! case 4:  dx-dr   < omega_min < dx+dr < omega_max if (( omega_min . gt .( dx - dr )). and .( omega_max . gt .( dx + dr ))) then p = (( dx - thb ) ** 2 - th ** 2 + dr ** 2 ) / 2.0 / ( thb - dx ) + dx do k = 1 , n omega = omega_min + float ( k - 1 ) * dom kk = k !        if (j.lt.0) kk = n+1-k if (( omega . gt . p ). and .( omega . le . dx + dr )) then STEM % BFweightsarray ( i , kk , iCL ) = sqrt (( dr ** 2 - ( omega - dx ) ** 2 )) end if if (( omega . gt . omega_min ). and .( omega . le . p )) then STEM % BFweightsarray ( i , kk , iCL ) = sqrt (( th ** 2 - ( thb - omega ) ** 2 )) end if end do end if end if end do ! this completes the BF weight factors when a diffraction aperture is present and apinBF=.TRUE. end if ! next determine the ADF weight factors in the presence of an aperture if ( apinADF ) then ! figure out which diffraction disk(s) contribute to the ADF detector do i = 1 , nn ! loop over all reflections of the systematic row ! redefine a couple of parameters j = - ( nn - 1 ) / 2 - 1 + i if ( j . ne . 0 ) then thb = ( j / abs ( j )) * CalcDiffAngle ( cell , j * g ( 1 ), j * g ( 2 ), j * g ( 3 )) * 100 0.0 ! diffraction angle in mrad else thb = 0.0 end if ! only used for debugging if ( debug ) thetar ( 7 + i ) = thb omega_min = thb - th omega_max = thb + th ! check whether or not there is any overlap between this disk and the diffraction aperture opening if (( omega_max . lt .( dx - dr )). or .( omega_min . gt .( dx + dr ))) then ! this disks does not fall inside the diffraction aperture STEM % ADFweightsarray ( i , 1 : n , iCL ) = 0.0 else ! case 1: dx-dr < omega_min < omega_max < dx+dr if (( omega_max . lt .( dx + dr )). and .( omega_min . gt .( dx - dr ))) then do k = 1 , n omega = omega_min + float ( k - 1 ) * dom kk = k if ( j . lt . 0 ) kk = n + 1 - k STEM % ADFweightsarray ( i , kk , iCL ) = sqrt (( th ** 2 - ( thb - omega ) ** 2 )) end do end if ! case 2: omega_min < dx-dr  < dx+dr < omega_max if (( omega_max . gt .( dx + dr )). and .( omega_min . lt .( dx - dr ))) then do k = 1 , n omega = omega_min + float ( k - 1 ) * dom kk = k if ( j . lt . 0 ) kk = n + 1 - k if (( omega . gt . dx - dr ). and .( omega . lt . dx + dr )) then STEM % ADFweightsarray ( i , kk , iCL ) = sqrt (( dr ** 2 - ( omega - dx ) ** 2 )) end if end do end if ! case 3: omega_min < dx-dr   < omega_max < dx+dr if (( omega_min . lt .( dx - dr )). and .( omega_max . lt .( dx + dr ))) then p = (( dx - thb ) ** 2 - dr ** 2 + th ** 2 ) / 2.0 / ( dx - thb ) + thb do k = 1 , n omega = omega_min + float ( k - 1 ) * dom kk = k !         if (j.lt.0) kk = n+1-k if (( omega . gt . dx - dr ). and .( omega . le . p )) then STEM % ADFweightsarray ( i , kk , iCL ) = sqrt ( dr ** 2 - ( omega - dx ) ** 2 ) end if if (( omega . gt . p ). and .( omega . le . omega_max )) then STEM % ADFweightsarray ( i , kk , iCL ) = sqrt (( th ** 2 - ( thb - omega ) ** 2 )) end if end do end if ! case 4:  dx-dr   < omega_min < dx+dr < omega_max if (( omega_min . gt .( dx - dr )). and .( omega_max . gt .( dx + dr ))) then p = (( dx - thb ) ** 2 - th ** 2 + dr ** 2 ) / 2.0 / ( thb - dx ) + dx do k = 1 , n omega = omega_min + float ( k - 1 ) * dom kk = k !        if (j.lt.0) kk = n+1-k if (( omega . gt . p ). and .( omega . le . dx + dr )) then STEM % ADFweightsarray ( i , kk , iCL ) = sqrt (( dr ** 2 - ( omega - dx ) ** 2 )) end if if (( omega . gt . omega_min ). and .( omega . le . p )) then STEM % ADFweightsarray ( i , kk , iCL ) = sqrt (( th ** 2 - ( thb - omega ) ** 2 )) end if end do end if end if end do ! this completes the ADF weight factors when a diffraction aperture is present and apinADF=.TRUE. end if end if ! if aperture is present end do outerCLloop ! see line 146 ! and the rest is also only used for debugging purposes if ( debug ) then allocate ( outar ( 2 * nn , STEM % numberofsvalues , STEM % numCL )) outar ( 1 : nn , 1 : STEM % numberofsvalues , 1 : STEM % numCL ) = STEM % BFweightsarray ( 1 : nn , 1 : STEM % numberofsvalues , 1 : STEM % numCL ) outar ( nn + 1 : 2 * nn , 1 : STEM % numberofsvalues , 1 : STEM % numCL ) = STEM % ADFweightsarray ( 1 : nn , 1 : STEM % numberofsvalues , 1 : STEM % numCL ) ! to make sure that everything is correct, let's export this array so that we can display it in IDL open ( unit = dataunit , file = 'STEMprofiles.data' , status = 'unknown' , form = 'unformatted' ) write ( unit = dataunit ) nn , STEM % numberofsvalues , STEM % numCL write ( unit = dataunit ) thetar write ( unit = dataunit ) outar close ( unit = dataunit , status = 'keep' ) end if end subroutine init_STEM","tags":"","loc":"proc/init_stem.html","title":"init_STEM – Fortran Program"},{"text":"public recursive subroutine init_STEM_ZA(STEM, cell, F, Dyn, khead, reflist, nn) Uses: crystal diffraction kvectors gvectors proc~~init_stem_za~~UsesGraph proc~init_stem_za init_STEM_ZA crystal crystal crystal->proc~init_stem_za diffraction diffraction diffraction->proc~init_stem_za gvectors gvectors gvectors->proc~init_stem_za kvectors kvectors kvectors->proc~init_stem_za Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief initialize weight factors for zone-axis STEM case Note This will need to be reconsidered when we implement sectored detectors ... \n @param STEM STEM structure\n @param cell unit cell pointer\n @param F foil normal\n @param khead top of kvector list\n @param reflist top of reflection list\n @param nn number of reflections\n @date   04/29/11 MDG 1.0 original\n @date   06/12/13 MDG 2.0 rewrite \n @date   06/09/14 MDG 3.0 added STEM and cell structures and khead+reflist linked lists\n @date   06/10/14 MDG 3.1 added F, Dyn argument Arguments Type Intent Optional Attributes Name type(STEMtype), intent(inout) :: STEM type(unitcell), pointer :: cell real(kind=dbl), intent(inout) :: F (3) type(DynType), intent(inout) :: Dyn type(kvectorlist), pointer :: khead type(reflisttype), pointer :: reflist integer(kind=irg), intent(in) :: nn Calls proc~~init_stem_za~~CallsGraph proc~init_stem_za init_STEM_ZA float float proc~init_stem_za->float transspace transspace proc~init_stem_za->transspace calclength calclength proc~init_stem_za->calclength sngl sngl proc~init_stem_za->sngl calcsg calcsg proc~init_stem_za->calcsg normvec normvec proc~init_stem_za->normvec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~init_stem_za~~CalledByGraph proc~init_stem_za init_STEM_ZA proc~read_stem_data read_STEM_data proc~read_stem_data->proc~init_stem_za Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code init_STEM_ZA Source Code recursive subroutine init_STEM_ZA ( STEM , cell , F , Dyn , khead , reflist , nn ) !DEC$ ATTRIBUTES DLLEXPORT :: init_STEM_ZA use crystal use diffraction use kvectors use gvectors IMPLICIT NONE type ( STEMtype ), INTENT ( INOUT ) :: STEM type ( unitcell ), pointer :: cell real ( kind = dbl ), INTENT ( INOUT ) :: F ( 3 ) type ( DynType ), INTENT ( INOUT ) :: Dyn type ( kvectorlist ), pointer :: khead type ( reflisttype ), pointer :: reflist integer ( kind = irg ), INTENT ( IN ) :: nn integer ( kind = irg ) :: ik , ig , iCL real ( kind = sgl ) :: ll ( 3 ), lpg ( 3 ), gg ( 3 ), glen , gplen , kpg type ( kvectorlist ), pointer :: ktmp type ( reflisttype ), pointer :: rltmpa ! this routine initializes the excitation error arrays and the weight-factor arrays for zone axis STEM signals ! the weightfactors are quite a bit different from the ones for the systematic row case; ! they are simpler in principle, since each point in the diffracted disk can only lie in one ! place, and hence only contributes to one detector.  However, not all points in a disk ! contribute to the same detector...  The length of the vector k_t+g, expressed in mrad, ! is what needs to be compared to the radii of the BF and ADF detectors.  For each incident ! beam direction, we take the tangential component of the wave vector and loop over all ! reflections to compute the relevant angle; this then allows us to assign the weight factors ! which are now either 1 or 0 (so they can be stored as logicals). ! allocate the excitation error array areal(1..nn,1..STEM%numk) allocate ( STEM % sgarray ( nn , STEM % numk )) ! transform the foil normal to real space and normalize call TransSpace ( cell , sngl ( F ), Dyn % FN , 'd' , 'r' ) call NormVec ( cell , Dyn % FN , 'r' ) ! allocate the weight factor arrays, one entry for each beam direction, reflection, and camera length allocate ( STEM % ZABFweightsarray ( nn , STEM % numk , STEM % numCL ), STEM % ZAADFweightsarray ( nn , STEM % numk , STEM % numCL )) STEM % ZABFweightsarray = . FALSE . STEM % ZAADFweightsarray = . FALSE . ! loop over the wave vector linked list ktmp => khead beamloopCL : do ik = 1 , STEM % numk ll = ktmp % kt ! this is the tangential component of the wave vector ! and loop over all reflections rltmpa => reflist % next reflectionloopCL : do ig = 1 , nn gg = float ( rltmpa % hkl ) glen = CalcLength ( cell , gg , 'r' ) lpg = ll + gg ! Laue + g gplen = CalcLength ( cell , lpg , 'r' ) kpg = 200 0.0 * asin ( 0.50 * sngl ( cell % mLambda ) * gplen ) ! 2theta in mrad do iCL = 1 , STEM % numCL STEM % BFmrad = atan ( STEM % BFradius / STEM % CLarray ( iCL )) * 100 0.0 STEM % ADFimrad = atan ( STEM % ADFinnerradius / STEM % CLarray ( iCL )) * 100 0.0 STEM % ADFomrad = atan ( STEM % ADFouterradius / STEM % CLarray ( iCL )) * 100 0.0 if ( kpg . le . STEM % BFmrad ) STEM % ZABFweightsarray ( ig , ik , iCL ) = . TRUE . if (( kpg . ge . STEM % ADFimrad ). AND .( kpg . le . STEM % ADFomrad )) STEM % ZAADFweightsarray ( ig , ik , iCL ) = . TRUE . end do ! loop over camera lengths STEM % sgarray ( ig , ik ) = Calcsg ( cell , gg , sngl ( ktmp % k ), Dyn % FN ) ! and we move to the next reflection in the list rltmpa => rltmpa % next end do reflectionloopCL ktmp => ktmp % next end do beamloopCL ! that's it folks! end subroutine init_STEM_ZA","tags":"","loc":"proc/init_stem_za.html","title":"init_STEM_ZA – Fortran Program"},{"text":"public recursive subroutine read_STEM_data(STEM, cell, F, Dyn, STEMnmlfile, khead, reflist, geometry, nn, g, kt, numk, beamdiv) Uses: io files kvectors gvectors proc~~read_stem_data~~UsesGraph proc~read_stem_data read_STEM_data io io io->proc~read_stem_data files files files->proc~read_stem_data gvectors gvectors gvectors->proc~read_stem_data kvectors kvectors kvectors->proc~read_stem_data Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief read detector and other parameters for the STEM case\n @param STEM STEM structure\n @param cell unit cell pointer\n @param F foil normal\n @param Dyn dynamical scattering structure\n @param STEMnmlfile filename of the namelist file\n @param khead top of kvector list\n @param reflist top of reflection list\n @param geometry 'SR' for systematic row or 'ZA' for zone axis\n @param nn number of reflections\n @param g fundamental g-vector for systematic row\n @param kt tangential wave vector component\n @param numk number of distinct wave vectors (optional)\n @param beamdiv beam divergence parameter (optional)\n @date   04/29/11 MDG 1.0 original\n @date   06/12/13 MDG 2.0 rewrite \n @date   11/26/13 MDG 2.1 made geometry an input parameter instead of part of the STEMdata namelist\n @date   06/10/14 MDG 3.0 added STEM, cell, foil, and Dyn arguments Arguments Type Intent Optional Attributes Name type(STEMtype), intent(inout) :: STEM type(unitcell), pointer :: cell real(kind=dbl), intent(inout) :: F (3) type(DynType), intent(inout) :: Dyn character(len=fnlen), intent(in) :: STEMnmlfile type(kvectorlist), pointer :: khead type(reflisttype), pointer :: reflist character(len=2), intent(in) :: geometry integer(kind=irg), intent(in) :: nn integer(kind=irg), intent(in) :: g (3) real(kind=sgl), intent(in) :: kt integer(kind=irg), intent(in), optional :: numk real(kind=sgl), intent(out), optional :: beamdiv Calls proc~~read_stem_data~~CallsGraph proc~read_stem_data read_STEM_data emsoft_tonativepath emsoft_tonativepath proc~read_stem_data->emsoft_tonativepath message message proc~read_stem_data->message proc~init_stem_za init_STEM_ZA proc~read_stem_data->proc~init_stem_za proc~init_stem init_STEM proc~read_stem_data->proc~init_stem float float proc~init_stem_za->float transspace transspace proc~init_stem_za->transspace calclength calclength proc~init_stem_za->calclength sngl sngl proc~init_stem_za->sngl calcsg calcsg proc~init_stem_za->calcsg normvec normvec proc~init_stem_za->normvec proc~init_stem->message proc~init_stem->float proc~init_stem->calclength calcdiffangle calcdiffangle proc~init_stem->calcdiffangle Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code read_STEM_data Source Code recursive subroutine read_STEM_data ( STEM , cell , F , Dyn , STEMnmlfile , khead , reflist , geometry , nn , g , kt , numk , beamdiv ) !DEC$ ATTRIBUTES DLLEXPORT :: read_STEM_data use io use files use kvectors use gvectors IMPLICIT NONE type ( STEMtype ), INTENT ( INOUT ) :: STEM type ( unitcell ), pointer :: cell real ( kind = dbl ), INTENT ( INOUT ) :: F ( 3 ) type ( DynType ), INTENT ( INOUT ) :: Dyn character ( fnlen ), INTENT ( IN ) :: STEMnmlfile type ( kvectorlist ), pointer :: khead type ( reflisttype ), pointer :: reflist character ( 2 ), INTENT ( IN ) :: geometry ! 'SR' or 'ZA' integer ( kind = irg ), INTENT ( IN ) :: nn integer ( kind = irg ), INTENT ( IN ) :: g ( 3 ) real ( kind = sgl ), INTENT ( IN ) :: kt integer ( kind = irg ), INTENT ( IN ), OPTIONAL :: numk real ( kind = sgl ), INTENT ( OUT ), OPTIONAL :: beamdiv integer ( kind = irg ) :: numberofsvalues , numCL real ( kind = sgl ) :: BFradius , ADFinnerradius , ADFouterradius , beamconvergence , cameralength , & diffaprad , diffapcenter , CLarray ( 20 ) character ( fnlen ) :: weightoutput namelist / STEMdata / BFradius , ADFinnerradius , ADFouterradius , cameralength , numCL , & beamconvergence , numberofsvalues , diffaprad , diffapcenter , weightoutput , CLarray ! set default values (based on OSU Tecnai F20) BFradius = 3.5 ! mm ADFinnerradius = 3.5 ! mm ADFouterradius = 1 0.0 ! mm cameralength = 10 0.0 ! mm numCL = 0 ! number of camera lengths to be used  (if zero, then use cameralength instead) CLarray = 0.0 ! values for the camera lengths beamconvergence = 2.0 ! mrad numberofsvalues = 33 ! integer diffaprad = 0.0 ! diffraction aperture radius in mrad, 0.0 if no aperture is present diffapcenter = 0.0 ! position of center of diffraction aperture in mrad along systematic row weightoutput = '' ! string with filename root for graphical output of weight profiles, empty if not needed ! read the namelist file call Message ( 'opening ' // trim ( STEMnmlfile ), frm = \"(/A)\" ) open ( UNIT = dataunit , FILE = trim ( EMsoft_toNativePath ( STEMnmlfile )), DELIM = 'APOSTROPHE' ) read ( UNIT = dataunit , NML = STEMdata ) close ( UNIT = dataunit ) if ( PRESENT ( beamdiv )) beamdiv = beamconvergence ! set the parameters STEM % BFradius = BFradius STEM % ADFinnerradius = ADFinnerradius STEM % ADFouterradius = ADFouterradius STEM % kt = kt STEM % cameralength = cameralength STEM % beamconvergence = beamconvergence if ( numCL . ne . 0 ) then STEM % numCL = numCL STEM % CLarray = CLarray else STEM % numCL = 1 STEM % CLarray = cameralength end if ! make sure the number of s values is an odd number if ( mod ( numberofsvalues , 2 ). eq . 0 ) numberofsvalues = numberofsvalues + 1 STEM % numberofsvalues = numberofsvalues STEM % diffapmrad = diffaprad STEM % diffapmcenter = diffapcenter STEM % weightoutput = weightoutput STEM % geometry = geometry if ( PRESENT ( numk )) then STEM % numk = numk else STEM % numk = STEM % numberofsvalues end if ! and initialize all other STEM related arrays if (. not . PRESENT ( beamdiv )) then if ( geometry . eq . 'SR' ) then call init_STEM ( STEM , cell , nn , g ) else call init_STEM_ZA ( STEM , cell , F , Dyn , khead , reflist , nn ) end if end if end subroutine read_STEM_data","tags":"","loc":"proc/read_stem_data.html","title":"read_STEM_data – Fortran Program"},{"text":"public recursive function Time_tock(t) result(tock) @author Marc De Graef, Carnegie Mellon University\n @brief stop time recording using system_clock\n @date   03/17/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: t Return Value integer(kind=irg) Called By proc~~time_tock~~CalledByGraph proc~time_tock Time_tock proc~emsoftcgetmcopencl EMsoftCgetMCOpenCL proc~emsoftcgetmcopencl->proc~time_tock Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code Time_tock Source Code recursive function Time_tock ( t ) result ( tock ) !DEC$ ATTRIBUTES DLLEXPORT :: Time_tock IMPLICIT NONE integer ( kind = irg ), intent ( in ) :: t integer ( kind = irg ) :: now , clock_rate integer ( kind = irg ) :: tock call system_clock ( now , clock_rate ) tock = real ( now - t ) / real ( clock_rate ) end function Time_tock","tags":"","loc":"proc/time_tock.html","title":"Time_tock – Fortran Program"},{"text":"public recursive subroutine Time_tick(t) @author Marc De Graef, Carnegie Mellon University\n @brief start time recording using system_clock\n @date   03/17/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer, intent(out) :: t Called By proc~~time_tick~~CalledByGraph proc~time_tick Time_tick proc~emsoftcgetmcopencl EMsoftCgetMCOpenCL proc~emsoftcgetmcopencl->proc~time_tick Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code Time_tick Source Code recursive subroutine Time_tick ( t ) !DEC$ ATTRIBUTES DLLEXPORT :: Time_tick IMPLICIT NONE integer , intent ( OUT ) :: t call system_clock ( t ) end subroutine Time_tick","tags":"","loc":"proc/time_tick.html","title":"Time_tick – Fortran Program"},{"text":"public recursive subroutine Time_reset(TT) @author Marc De Graef, Carnegie Mellon University\n @brief reset time recording\n @date   06/04/01 MDG 1.0 original\n @date   06/04/13 MDG 2.0 rewrite\n @date   06/05/14 MDG 3.0 added TT as argument Arguments Type Intent Optional Attributes Name type(timetype), intent(inout) :: TT Called By proc~~time_reset~~CalledByGraph proc~time_reset Time_reset proc~calcrlocal CalcRLocal proc~calcrlocal->proc~time_reset proc~time_start Time_start proc~calcrlocal->proc~time_start proc~time_start->proc~time_reset program~dispfield dispfield program~dispfield->proc~calcrlocal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code Time_reset Source Code recursive subroutine Time_reset ( TT ) !DEC$ ATTRIBUTES DLLEXPORT :: Time_reset IMPLICIT NONE type ( timetype ), INTENT ( INOUT ) :: TT TT % TIME_t_count = 0.0 TT % TIME_unit_count = 0.0 TT % TIME_count = 0 TT % TIME_newcount = 0 TT % TIME_count_rate = 0 TT % TIME_count_max = HUGE ( 0 ) TT % TIME_old = 0 TT % TIME_loops = 0 end subroutine Time_reset","tags":"","loc":"proc/time_reset.html","title":"Time_reset – Fortran Program"},{"text":"public recursive subroutine Time_report(TT, interval, stdout) @author Marc De Graef, Carnegie Mellon University\n @brief report time recording\n @param TT time structure\n @param interval interval for reporting\n @param stdout optional output unit identifier\n @date   06/04/01 MDG 1.0 original\n @date   06/04/13 MDG 2.0 rewrite\n @date   06/05/14 MDG 3.0 added TT as argument Arguments Type Intent Optional Attributes Name type(timetype), intent(inout) :: TT real(kind=sgl), intent(in) :: interval integer(kind=irg), intent(in), optional :: stdout Calls proc~~time_report~~CallsGraph proc~time_report Time_report message message proc~time_report->message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~time_report~~CalledByGraph proc~time_report Time_report proc~calcrlocal CalcRLocal proc~calcrlocal->proc~time_report program~dispfield dispfield program~dispfield->proc~calcrlocal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code Time_report Source Code recursive subroutine Time_report ( TT , interval , stdout ) !DEC$ ATTRIBUTES DLLEXPORT :: Time_report IMPLICIT NONE type ( timetype ), INTENT ( INOUT ) :: TT real ( kind = sgl ), intent ( IN ) :: interval integer ( kind = irg ), OPTIONAL , INTENT ( IN ) :: stdout integer ( kind = irg ) :: std std = 6 if ( PRESENT ( stdout )) std = stdout TT % TIME_interval = interval TT % TIME_fraction = TT % TIME_interval call Message ( 'Starting computation' , frm = \"(/A)\" , stdout = std ) end subroutine Time_report","tags":"","loc":"proc/time_report.html","title":"Time_report – Fortran Program"},{"text":"public recursive subroutine Time_start(TT) @author Marc De Graef, Carnegie Mellon University\n @brief start time recording\n @date   06/04/01 MDG 1.0 original\n @date   06/04/13 MDG 2.0 rewrite\n @date   06/05/14 MDG 3.0 added TT as argument Arguments Type Intent Optional Attributes Name type(timetype), intent(inout) :: TT Calls proc~~time_start~~CallsGraph proc~time_start Time_start proc~time_reset Time_reset proc~time_start->proc~time_reset Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~time_start~~CalledByGraph proc~time_start Time_start proc~calcrlocal CalcRLocal proc~calcrlocal->proc~time_start program~dispfield dispfield program~dispfield->proc~calcrlocal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code Time_start Source Code recursive subroutine Time_start ( TT ) !DEC$ ATTRIBUTES DLLEXPORT :: Time_start IMPLICIT NONE type ( timetype ), INTENT ( INOUT ) :: TT ! start the timing of the computation call Time_reset ( TT ) call system_clock ( TT % TIME_count , TT % TIME_count_rate , TT % TIME_count_max ) end subroutine Time_start","tags":"","loc":"proc/time_start.html","title":"Time_start – Fortran Program"},{"text":"public recursive subroutine Time_estimate(TT, numk, stdout) @author Marc De Graef, Carnegie Mellon University\n @brief estimare remaining time\n @param TT time structure\n @param numk number of idividual computations\n @param stdout optional output unit identifier\n @date   06/04/01 MDG 1.0 original\n @date   06/04/13 MDG 2.0 rewrite\n @date   06/05/14 MDG 3.0 added TT as argument Arguments Type Intent Optional Attributes Name type(timetype), intent(inout) :: TT integer(kind=irg), intent(in) :: numk integer(kind=irg), intent(in), optional :: stdout Calls proc~~time_estimate~~CallsGraph proc~time_estimate Time_estimate float float proc~time_estimate->float proc~printtime PrintTime proc~time_estimate->proc~printtime writevalue writevalue proc~time_estimate->writevalue message message proc~time_estimate->message proc~printtime->writevalue Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code Time_estimate Source Code recursive subroutine Time_estimate ( TT , numk , stdout ) !DEC$ ATTRIBUTES DLLEXPORT :: Time_estimate IMPLICIT NONE type ( timetype ), INTENT ( INOUT ) :: TT integer ( kind = irg ), intent ( IN ) :: numk integer ( kind = irg ), INTENT ( IN ), OPTIONAL :: stdout integer ( kind = irg ) :: TIME_nc , std real ( kind = sgl ) :: io_real ( 1 ) std = 6 if ( PRESENT ( stdout )) std = stdout ! get the current time call system_clock ( TIME_nc , TT % TIME_count_rate , TT % TIME_count_max ) TT % TIME_newcount = TIME_nc TT % TIME_t_count = float ( TT % TIME_newcount - TT % TIME_count ) / float ( TT % TIME_count_rate ) TT % TIME_unit_count = TT % TIME_t_count io_real ( 1 ) = TT % TIME_unit_count call WriteValue ( ' Time for first computation step [s, typically overestimate] :' , io_real , 1 , frm = \"(F10.5)\" , stdout = std ) call Message ( '  Anticipated total computation time :' , frm = \"(A$)\" , stdout = std ) call PrintTime ( TT % TIME_unit_count * float ( numk ), stdout = std ) end subroutine Time_estimate","tags":"","loc":"proc/time_estimate.html","title":"Time_estimate – Fortran Program"},{"text":"public recursive subroutine Time_remaining(TT, ik, numk, stdout) @author Marc De Graef, Carnegie Mellon University\n @brief estimate remaining time\n @param TT time structure\n @param ik current computation\n @param numk number of idividual computations\n @param stdout optional output unit identifier\n @date   06/04/01 MDG 1.0 original\n @date   06/04/13 MDG 2.0 rewrite\n @date   06/05/14 MDG 3.0 added TT as argument Arguments Type Intent Optional Attributes Name type(timetype), intent(inout) :: TT integer(kind=irg), intent(in) :: ik integer(kind=irg), intent(in) :: numk integer(kind=irg), intent(in), optional :: stdout Calls proc~~time_remaining~~CallsGraph proc~time_remaining Time_remaining float float proc~time_remaining->float proc~printtime PrintTime proc~time_remaining->proc~printtime writevalue writevalue proc~time_remaining->writevalue message message proc~time_remaining->message proc~printtime->writevalue Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~time_remaining~~CalledByGraph proc~time_remaining Time_remaining proc~calcrlocal CalcRLocal proc~calcrlocal->proc~time_remaining program~dispfield dispfield program~dispfield->proc~calcrlocal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code Time_remaining Source Code recursive subroutine Time_remaining ( TT , ik , numk , stdout ) !DEC$ ATTRIBUTES DLLEXPORT :: Time_remaining IMPLICIT NONE type ( timetype ), INTENT ( INOUT ) :: TT integer ( kind = irg ), intent ( IN ) :: ik integer ( kind = irg ), intent ( IN ) :: numk integer ( kind = irg ), INTENT ( IN ), OPTIONAL :: stdout integer ( kind = irg ) :: TIME_nc , io_int ( 1 ), std real ( kind = sgl ) :: io_real ( 1 ) std = 6 if ( PRESENT ( stdout )) std = stdout TT % TIME_fraction = TT % TIME_fraction + TT % TIME_interval ! get the current time call system_clock ( TIME_nc , TT % TIME_count_rate , TT % TIME_count_max ) ! correct for the resetting of TIME_nc when TIME_count_max is reached if ( TIME_nc . lt . TT % TIME_newcount ) then ! we've looped through the entire cycle TT % TIME_loops = TT % TIME_loops + 1 TT % TIME_count = 0 end if TT % TIME_newcount = TIME_nc ! and print it TT % TIME_t_count = ( float ( TT % TIME_loops ) * float ( TT % TIME_count_max ) + float ( TT % TIME_newcount - TT % TIME_count )) / float ( TT % TIME_count_rate ) ! reset the time per unit TT % TIME_unit_count = TT % TIME_t_count / float ( ik ) ! print estimated remaining time io_int ( 1 ) = nint ( 10 0.0 * TT % TIME_t_count / ( TT % TIME_t_count + TT % TIME_unit_count * ( float ( numk ) - float ( ik )))) call WriteValue ( ' ' , io_int , 1 , frm = \"(1x,I3,' % completed; '$)\" , stdout = std ) io_real ( 1 ) = TT % TIME_t_count call WriteValue ( ' Total computation time [s] ' , io_real , 1 , frm = \"(F$)\" , stdout = std ) call Message ( ';  Estimated remaining time : ' , frm = \"(A$)\" , stdout = std ) call PrintTime ( TT % TIME_unit_count * ( float ( numk ) - float ( ik )), stdout = std ) ! end subroutine Time_remaining","tags":"","loc":"proc/time_remaining.html","title":"Time_remaining – Fortran Program"},{"text":"public recursive subroutine PrintTime(tm, stdout) @author Marc De Graef, Carnegie Mellon University\n @brief print  time\n @param tm time variable\n @param stdout optional output unit identifier\n @date   06/04/01 MDG 1.0 original\n @date   06/04/13 MDG 2.0 rewrite\n @date   06/05/14 MDG 3.0 changed IO Arguments Type Intent Optional Attributes Name real(kind=sgl), intent(in) :: tm integer(kind=irg), intent(in), optional :: stdout Calls proc~~printtime~~CallsGraph proc~printtime PrintTime writevalue writevalue proc~printtime->writevalue Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~printtime~~CalledByGraph proc~printtime PrintTime proc~time_estimate Time_estimate proc~time_estimate->proc~printtime proc~time_remaining Time_remaining proc~time_remaining->proc~printtime proc~time_stop Time_stop proc~time_stop->proc~printtime proc~calcrlocal CalcRLocal proc~calcrlocal->proc~time_remaining proc~calcrlocal->proc~time_stop program~dispfield dispfield program~dispfield->proc~calcrlocal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code PrintTime Source Code recursive subroutine PrintTime ( tm , stdout ) !DEC$ ATTRIBUTES DLLEXPORT :: PrintTime IMPLICIT NONE real ( kind = sgl ), INTENT ( IN ) :: tm integer ( kind = irg ), INTENT ( IN ), OPTIONAL :: stdout integer ( kind = irg ) :: days , hours , minutes , seconds , io_int ( 4 ), std real ( kind = sgl ) :: secs std = 6 if ( PRESENT ( stdout )) std = stdout secs = tm days = 0 hours = 0 minutes = 0 if ( secs . gt . 8640 0.0 ) then days = int ( secs ) / 86400 secs = mod ( secs , 8640 0.0 ) end if if ( secs . gt . 360 0.0 ) then hours = int ( secs ) / 3600 secs = mod ( secs , 360 0.0 ) end if if ( secs . gt . 6 0.0 ) then minutes = int ( secs ) / 60 secs = mod ( secs , 6 0.0 ) end if seconds = int ( secs ) io_int ( 1 : 4 ) = ( / days , hours , minutes , seconds / ) call WriteValue ( ' ' , io_int , 4 , frm = \"(1x,I3,' d,',I3,' h,',I3,' m,',I3,' s')\" , stdout = std ) end subroutine PrintTime","tags":"","loc":"proc/printtime.html","title":"PrintTime – Fortran Program"},{"text":"public recursive subroutine Time_stop(TT, numk, stdout) @author Marc De Graef, Carnegie Mellon University\n @brief stop time recording\n @param TT time structure\n @param numk total number of computations\n @param stdout optional output unit identifier\n @date   06/04/01 MDG 1.0 original\n @date   06/04/13 MDG 2.0 rewrite\n @date   06/05/14 MDG 3.0 added TT; changed IO Arguments Type Intent Optional Attributes Name type(timetype), intent(inout) :: TT integer(kind=irg), intent(in) :: numk integer(kind=irg), intent(in), optional :: stdout Calls proc~~time_stop~~CallsGraph proc~time_stop Time_stop writevalue writevalue proc~time_stop->writevalue proc~printtime PrintTime proc~time_stop->proc~printtime message message proc~time_stop->message float float proc~time_stop->float proc~printtime->writevalue Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called By proc~~time_stop~~CalledByGraph proc~time_stop Time_stop proc~calcrlocal CalcRLocal proc~calcrlocal->proc~time_stop program~dispfield dispfield program~dispfield->proc~calcrlocal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Source Code Time_stop Source Code recursive subroutine Time_stop ( TT , numk , stdout ) !DEC$ ATTRIBUTES DLLEXPORT :: Time_stop IMPLICIT NONE type ( timetype ), INTENT ( INOUT ) :: TT integer ( kind = irg ), INTENT ( IN ) :: numk integer ( kind = irg ), INTENT ( IN ), OPTIONAL :: stdout real ( kind = sgl ) :: io_real ( 1 ) integer ( kind = irg ) :: std std = 6 if ( PRESENT ( stdout )) std = stdout call system_clock ( TT % TIME_newcount , TT % TIME_count_rate , TT % TIME_count_max ) call Message ( '  Total computation time [s] ' , frm = \"(A$)\" , stdout = std ) call PrintTime (( float ( TT % TIME_loops ) * float ( TT % TIME_count_max ) + float ( TT % TIME_newcount - TT % TIME_count )) / float ( TT % TIME_count_rate )) io_real ( 1 ) = float ( TT % TIME_loops ) * float ( TT % TIME_count_max ) + float ( TT % TIME_newcount - TT % TIME_count ) io_real ( 1 ) = io_real ( 1 ) / float ( TT % TIME_count_rate ) / float ( numk ) call WriteValue ( ' Time per step/pixel [s] ' , io_real , 1 , frm = \"(F)\" , stdout = std ) end subroutine Time_stop","tags":"","loc":"proc/time_stop.html","title":"Time_stop – Fortran Program"},{"text":"Uses: local typedefs module~~apb~~UsesGraph module~apb apb typedefs typedefs typedefs->module~apb local local local->module~apb Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief Provides routines to deal with cylindrical APBs\n @date   02/10/14 MDG 1.0 original Subroutines read_apb_data Subroutines public recursive subroutine read_apb_data (defects, cell, DF_L, DF_npix, DF_npiy, dinfo) @author Marc De Graef, Carnegie Mellon University\n @brief  read apb parameters from file\n @param defects defect structure\n @param cell unit cell pointer\n @param foil foil structure\n @param DF_L column edge length \n @param DF_npix number of x-pixels\n @param DF_npiy number of y-pixels\n @param dinfo logical to trigger verbose output\n @date   02/10/14 MDG 1.0 new code\n @date   06/10/14 MDG 2.0 removed all global variables; added defect, foil arguments Arguments Type Intent Optional Attributes Name type(defecttype), intent(inout) :: defects type(unitcell), pointer :: cell real(kind=sgl), intent(in) :: DF_L integer(kind=irg), intent(in) :: DF_npix integer(kind=irg), intent(in) :: DF_npiy integer(kind=irg), intent(in) :: dinfo","tags":"","loc":"module/apb.html","title":"apb – Fortran Program"},{"text":"Uses: local iso_c_binding module~~bobyqa_module~~UsesGraph module~bobyqa_module bobyqa_module iso_c_binding iso_c_binding iso_c_binding->module~bobyqa_module local local local->module~bobyqa_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Abstract Interfaces func Subroutines bobyqa bobyqb altmov prelim rescue trsbox update Abstract Interfaces abstract interface public recursive subroutine func (nipar, nfpar, ninit, ipar, fpar, initmeanval, expt1, accum_e, mLPNH, mLPSH, n, x, f, nstep, stepsize, verbose) calfun interface Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar integer(kind=irg), intent(in) :: ninit integer(kind=c_size_t), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fpar (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) real(kind=c_float), intent(in) :: expt1 (ipar(2)*ipar(3)/ipar(12)**2) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) integer(kind=irg), intent(in) :: n real(kind=dbl), intent(in), dimension(:) :: x real(kind=dbl), intent(out) :: f integer(kind=irg), intent(in) :: nstep real(kind=sgl), intent(in) :: stepsize (nstep) logical, intent(in), optional :: verbose Subroutines public recursive subroutine bobyqa (nipar, nfpar, ninit, ipar, fpar, initmeanval, expt1, n, npt, x, xl, xu, rhobeg, rhoend, iprint, maxfun, calfun, accum_e, mLPNH, mLPSH, nstep, stepsize, verbose) Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar integer(kind=irg), intent(in) :: ninit integer(kind=8), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fpar (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) real(kind=c_float), intent(in) :: expt1 (ipar(2)*ipar(3)/ipar(12)**2) integer, intent(in) :: n number of variables (must be at least two) integer, intent(in) :: npt number of interpolation conditions. Its value must be in\n the interval [N+2,(N+1)(N+2)/2]. Choices that exceed 2*N+1 are not\n recommended. real(kind=dbl), intent(inout), dimension(:) :: x Initial values of the variables must be set in X(1),X(2),...,X(N). They\n will be changed to the values that give the least calculated F. real(kind=dbl), intent(in), dimension(:) :: xl lower bounds on x. The construction of quadratic models\n requires XL(I) to be strictly less than XU(I) for each I. Further,\n the contribution to a model from changes to the I-th variable is\n damaged severely by rounding errors if XU(I)-XL(I) is too small. real(kind=dbl), intent(in), dimension(:) :: xu upper bounds on x. The construction of quadratic models\n requires XL(I) to be strictly less than XU(I) for each I. Further,\n the contribution to a model from changes to the I-th variable is\n damaged severely by rounding errors if XU(I)-XL(I) is too small. real(kind=dbl), intent(in) :: rhobeg RHOBEG must be set to the initial value of a trust region radius. It must be positive, and typically should be about one tenth of the greatest\n expected change to a variable.  An error return occurs if any of \n the differences XU(I)-XL(I), I=1,...,N, is less than 2*RHOBEG. real(kind=dbl), intent(in) :: rhoend RHOEND must be set to the final value of a trust\n region radius. It must be positive with RHOEND no greater than\n RHOBEG. Typically, RHOEND should indicate the\n accuracy that is required in the final values of the variables. integer, intent(in) :: iprint IPRINT should be set to 0, 1, 2 or 3, which controls the\n amount of printing. Specifically, there is no output if IPRINT=0 and\n there is output only at the return if IPRINT=1. Otherwise, each new\n value of RHO is printed, with the best vector of variables so far and\n the corresponding value of the objective function. Further, each new\n value of F with its variables are output if IPRINT=3. integer, intent(in) :: maxfun an upper bound on the number of calls of CALFUN. procedure( func ) :: calfun SUBROUTINE CALFUN (N,X,F) has to be provided by the user. It must set\n F to the value of the objective function for the current values of the\n variables X(1),X(2),...,X(N), which are generated automatically in a\n way that satisfies the bounds given in XL and XU. real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) integer(kind=irg), intent(in) :: nstep real(kind=sgl), intent(in) :: stepsize (nstep) logical, intent(in), optional :: verbose public recursive subroutine bobyqb (nipar, nfpar, ninit, ipar, fpar, initmeanval, expt1, n, npt, x, xl, xu, rhobeg, rhoend, iprint, maxfun, xbase, xpt, fval, xopt, gopt, hq, pq, bmat, zmat, ndim, sl, su, xnew, xalt, d, vlag, w, calfun, accum_e, mLPNH, mLPSH, nstep, stepsize, verbose) Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar integer(kind=irg), intent(in) :: ninit integer(kind=8), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fpar (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) real(kind=c_float), intent(in) :: expt1 (ipar(2)*ipar(3)/ipar(12)**2) integer :: n integer :: npt real :: x real :: xl real :: xu real :: rhobeg real :: rhoend integer :: iprint integer :: maxfun real :: xbase real :: xpt real :: fval real :: xopt real :: gopt real :: hq real :: pq real :: bmat real :: zmat integer :: ndim real :: sl real :: su real :: xnew real :: xalt real :: d real :: vlag real :: w procedure( func ) :: calfun real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) integer(kind=irg), intent(in) :: nstep real(kind=sgl), intent(in) :: stepsize (nstep) logical, intent(in), optional :: verbose public recursive subroutine altmov (n, npt, xpt, xopt, bmat, zmat, ndim, sl, su, kopt, knew, adelt, xnew, xalt, alpha, cauchy, glag, hcol, w) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: xpt real :: xopt real :: bmat real :: zmat integer :: ndim real :: sl real :: su integer :: kopt integer :: knew real :: adelt real :: xnew real :: xalt real :: alpha real :: cauchy real :: glag real :: hcol real :: w public recursive subroutine prelim (nipar, nfpar, ninit, ipar, fpar, initmeanval, expt1, n, npt, x, xl, xu, rhobeg, iprint, maxfun, xbase, xpt, fval, gopt, hq, pq, bmat, zmat, ndim, sl, su, nf, kopt, calfun, accum_e, mLPNH, mLPSH, nstep, stepsize, verbose) Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar integer(kind=irg), intent(in) :: ninit integer(kind=8), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fpar (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) real(kind=c_float), intent(in) :: expt1 (ipar(2)*ipar(3)/ipar(12)**2) integer :: n integer :: npt real :: x real :: xl real :: xu real :: rhobeg integer :: iprint integer :: maxfun real :: xbase real :: xpt real :: fval real :: gopt real :: hq real :: pq real :: bmat real :: zmat integer :: ndim real :: sl real :: su integer :: nf integer :: kopt procedure( func ) :: calfun real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) integer(kind=irg), intent(in) :: nstep real(kind=sgl), intent(in) :: stepsize (nstep) logical, intent(in), optional :: verbose public recursive subroutine rescue (nipar, nfpar, ninit, ipar, fpar, initmeanval, expt1, n, npt, xl, xu, iprint, maxfun, xbase, xpt, fval, xopt, gopt, hq, pq, bmat, zmat, ndim, sl, su, nf, delta, kopt, vlag, ptsaux, ptsid, w, calfun, accum_e, mLPNH, mLPSH, nstep, stepsize, verbose) Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar integer(kind=irg), intent(in) :: ninit integer(kind=8), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fpar (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) real(kind=c_float), intent(in) :: expt1 (ipar(2)*ipar(3)/ipar(12)**2) integer :: n integer :: npt real :: xl real :: xu integer :: iprint integer :: maxfun real :: xbase real :: xpt real :: fval real :: xopt real :: gopt real :: hq real :: pq real :: bmat real :: zmat integer :: ndim real :: sl real :: su integer :: nf real :: delta integer :: kopt real :: vlag real :: ptsaux real :: ptsid real :: w procedure( func ) :: calfun real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) integer(kind=irg), intent(in) :: nstep real(kind=sgl), intent(in) :: stepsize (nstep) logical, intent(in), optional :: verbose public recursive subroutine trsbox (n, npt, xpt, xopt, gopt, hq, pq, sl, su, delta, xnew, d, gnew, xbdi, s, hs, hred, dsq, crvmin) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: xpt real :: xopt real :: gopt real :: hq real :: pq real :: sl real :: su real :: delta real :: xnew real :: d real :: gnew real :: xbdi real :: s real :: hs real :: hred real :: dsq real :: crvmin public recursive subroutine update (n, npt, bmat, zmat, ndim, vlag, beta, denom, knew, w) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: bmat real :: zmat integer :: ndim real :: vlag real :: beta real :: denom integer :: knew real :: w","tags":"","loc":"module/bobyqa_module.html","title":"bobyqa_module – Fortran Program"},{"text":"Uses: local iso_c_binding module~~bobyqa_refinement~~UsesGraph module~bobyqa_refinement bobyqa_refinement iso_c_binding iso_c_binding iso_c_binding->module~bobyqa_refinement local local local->module~bobyqa_refinement Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Abstract Interfaces func2 Subroutines bobyqa bobyqb altmov prelim rescue trsbox update Abstract Interfaces abstract interface public recursive subroutine func2 (ipar, initmeanval, expt, accum, mLPNH, mLPSH, n, x, f, mask, prefactor, rgx, rgy, rgz, stepsize, verbose) calfun interface Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in) :: ipar (9) real(kind=sgl), intent(in) :: initmeanval (3) real(kind=c_float), intent(in) :: expt (ipar(2)*ipar(3)/ipar(1)**2) real(kind=sgl), intent(in) :: accum (ipar(6),ipar(2),ipar(3)) real(kind=sgl), intent(in) :: mLPNH (-ipar(4):ipar(4),-ipar(5):ipar(5),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(4):ipar(4),-ipar(5):ipar(5),ipar(7)) integer(kind=irg), intent(in) :: n real(kind=dbl), intent(in), dimension(:) :: x real(kind=dbl), intent(out) :: f real(kind=sgl), intent(in) :: mask (ipar(2)/ipar(1),ipar(3)/ipar(1)) real(kind=dbl), intent(in) :: prefactor real(kind=sgl), intent(in) :: rgx (ipar(2),ipar(3)) real(kind=sgl), intent(in) :: rgy (ipar(2),ipar(3)) real(kind=sgl), intent(in) :: rgz (ipar(2),ipar(3)) real(kind=sgl), intent(in) :: stepsize (3) logical, intent(in), optional :: verbose Subroutines public recursive subroutine bobyqa (ipar, initmeanval, expt, n, npt, x, xl, xu, rhobeg, rhoend, iprint, maxfun, calfun, accum, mLPNH, mLPSH, mask, prefactor, rgx, rgy, rgz, stepsize, verbose) Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in) :: ipar (9) real(kind=sgl), intent(in) :: initmeanval (3) real(kind=sgl), intent(in) :: expt (ipar(2)*ipar(3)/ipar(1)**2) integer, intent(in) :: n number of variables (must be at least two) integer, intent(in) :: npt number of interpolation conditions. Its value must be in\n the interval [N+2,(N+1)(N+2)/2]. Choices that exceed 2*N+1 are not\n recommended. real(kind=dbl), intent(inout), dimension(:) :: x Initial values of the variables must be set in X(1),X(2),...,X(N). They\n will be changed to the values that give the least calculated F. real(kind=dbl), intent(in), dimension(:) :: xl lower bounds on x. The construction of quadratic models\n requires XL(I) to be strictly less than XU(I) for each I. Further,\n the contribution to a model from changes to the I-th variable is\n damaged severely by rounding errors if XU(I)-XL(I) is too small. real(kind=dbl), intent(in), dimension(:) :: xu upper bounds on x. The construction of quadratic models\n requires XL(I) to be strictly less than XU(I) for each I. Further,\n the contribution to a model from changes to the I-th variable is\n damaged severely by rounding errors if XU(I)-XL(I) is too small. real(kind=dbl), intent(in) :: rhobeg RHOBEG must be set to the initial value of a trust region radius. It must be positive, and typically should be about one tenth of the greatest\n expected change to a variable.  An error return occurs if any of \n the differences XU(I)-XL(I), I=1,...,N, is less than 2*RHOBEG. real(kind=dbl), intent(in) :: rhoend RHOEND must be set to the final value of a trust\n region radius. It must be positive with RHOEND no greater than\n RHOBEG. Typically, RHOEND should indicate the\n accuracy that is required in the final values of the variables. integer, intent(in) :: iprint IPRINT should be set to 0, 1, 2 or 3, which controls the\n amount of printing. Specifically, there is no output if IPRINT=0 and\n there is output only at the return if IPRINT=1. Otherwise, each new\n value of RHO is printed, with the best vector of variables so far and\n the corresponding value of the objective function. Further, each new\n value of F with its variables are output if IPRINT=3. integer, intent(in) :: maxfun an upper bound on the number of calls of CALFUN. procedure( func2 ) :: calfun SUBROUTINE CALFUN has to be provided by the user. It must set\n F to the value of the objective function for the current values of the\n variables X(1),X(2),...,X(N), which are generated automatically in a\n way that satisfies the bounds given in XL and XU. real(kind=sgl), intent(in) :: accum (ipar(6),ipar(2),ipar(3)) real(kind=sgl), intent(in) :: mLPNH (-ipar(4):ipar(4),-ipar(5):ipar(5),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(4):ipar(4),-ipar(5):ipar(5),ipar(7)) real(kind=sgl), intent(in) :: mask (ipar(2)/ipar(1),ipar(3)/ipar(1)) real(kind=dbl) :: prefactor real(kind=sgl), intent(in) :: rgx (ipar(2),ipar(3)) real(kind=sgl), intent(in) :: rgy (ipar(2),ipar(3)) real(kind=sgl), intent(in) :: rgz (ipar(2),ipar(3)) real(kind=sgl), intent(in) :: stepsize (3) logical, intent(in), optional :: verbose public recursive subroutine bobyqb (ipar, initmeanval, expt1, n, npt, x, xl, xu, rhobeg, rhoend, iprint, maxfun, xbase, xpt, fval, xopt, gopt, hq, pq, bmat, zmat, ndim, sl, su, xnew, xalt, d, vlag, w, calfun, accum, mLPNH, mLPSH, mask, prefactor, rgx, rgy, rgz, stepsize, verbose) Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in) :: ipar (9) real(kind=sgl), intent(in) :: initmeanval (3) real(kind=sgl), intent(in) :: expt1 (ipar(2)*ipar(3)/ipar(1)**2) integer :: n integer :: npt real :: x real :: xl real :: xu real :: rhobeg real :: rhoend integer :: iprint integer :: maxfun real :: xbase real :: xpt real :: fval real :: xopt real :: gopt real :: hq real :: pq real :: bmat real :: zmat integer :: ndim real :: sl real :: su real :: xnew real :: xalt real :: d real :: vlag real :: w procedure( func2 ) :: calfun real(kind=sgl), intent(in) :: accum (ipar(6),ipar(2),ipar(3)) real(kind=sgl), intent(in) :: mLPNH (-ipar(4):ipar(4),-ipar(5):ipar(5),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(4):ipar(4),-ipar(5):ipar(5),ipar(7)) real(kind=sgl), intent(in) :: mask (ipar(2)/ipar(1),ipar(3)/ipar(1)) real(kind=dbl) :: prefactor real(kind=sgl), intent(in) :: rgx (ipar(2),ipar(3)) real(kind=sgl), intent(in) :: rgy (ipar(2),ipar(3)) real(kind=sgl), intent(in) :: rgz (ipar(2),ipar(3)) real(kind=sgl), intent(in) :: stepsize (3) logical, intent(in), optional :: verbose public recursive subroutine altmov (n, npt, xpt, xopt, bmat, zmat, ndim, sl, su, kopt, knew, adelt, xnew, xalt, alpha, cauchy, glag, hcol, w) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: xpt real :: xopt real :: bmat real :: zmat integer :: ndim real :: sl real :: su integer :: kopt integer :: knew real :: adelt real :: xnew real :: xalt real :: alpha real :: cauchy real :: glag real :: hcol real :: w public recursive subroutine prelim (ipar, initmeanval, expt1, n, npt, x, xl, xu, rhobeg, iprint, maxfun, xbase, xpt, fval, gopt, hq, pq, bmat, zmat, ndim, sl, su, nf, kopt, calfun, accum, mLPNH, mLPSH, mask, prefactor, rgx, rgy, rgz, stepsize, verbose) Arguments Type Intent Optional Attributes Name integer(kind=8), intent(in) :: ipar (9) real(kind=sgl), intent(in) :: initmeanval (3) real(kind=sgl), intent(in) :: expt1 (ipar(2)*ipar(3)/ipar(1)**2) integer :: n integer :: npt real :: x real :: xl real :: xu real :: rhobeg integer :: iprint integer :: maxfun real :: xbase real :: xpt real :: fval real :: gopt real :: hq real :: pq real :: bmat real :: zmat integer :: ndim real :: sl real :: su integer :: nf integer :: kopt procedure( func2 ) :: calfun real(kind=sgl), intent(in) :: accum (ipar(6),ipar(2),ipar(3)) real(kind=sgl), intent(in) :: mLPNH (-ipar(4):ipar(4),-ipar(5):ipar(5),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(4):ipar(4),-ipar(5):ipar(5),ipar(7)) real(kind=sgl), intent(in) :: mask (ipar(2)/ipar(1),ipar(3)/ipar(1)) real(kind=dbl) :: prefactor real(kind=sgl), intent(in) :: rgx (ipar(2),ipar(3)) real(kind=sgl), intent(in) :: rgy (ipar(2),ipar(3)) real(kind=sgl), intent(in) :: rgz (ipar(2),ipar(3)) real(kind=sgl), intent(in) :: stepsize (3) logical, intent(in), optional :: verbose public recursive subroutine rescue (ipar, initmeanval, expt1, n, npt, xl, xu, iprint, maxfun, xbase, xpt, fval, xopt, gopt, hq, pq, bmat, zmat, ndim, sl, su, nf, delta, kopt, vlag, ptsaux, ptsid, w, calfun, accum, mLPNH, mLPSH, mask, prefactor, rgx, rgy, rgz, stepsize, verbose) Arguments Type Intent Optional Attributes Name integer(kind=8), intent(in) :: ipar (9) real(kind=sgl), intent(in) :: initmeanval (3) real(kind=sgl), intent(in) :: expt1 (ipar(2)*ipar(3)/ipar(1)**2) integer :: n integer :: npt real :: xl real :: xu integer :: iprint integer :: maxfun real :: xbase real :: xpt real :: fval real :: xopt real :: gopt real :: hq real :: pq real :: bmat real :: zmat integer :: ndim real :: sl real :: su integer :: nf real :: delta integer :: kopt real :: vlag real :: ptsaux real :: ptsid real :: w procedure( func2 ) :: calfun real(kind=sgl), intent(in) :: accum (ipar(6),ipar(2),ipar(3)) real(kind=sgl), intent(in) :: mLPNH (-ipar(4):ipar(4),-ipar(5):ipar(5),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(4):ipar(4),-ipar(5):ipar(5),ipar(7)) real(kind=sgl), intent(in) :: mask (ipar(2)/ipar(1),ipar(3)/ipar(1)) real(kind=dbl) :: prefactor real(kind=sgl), intent(in) :: rgx (ipar(2),ipar(3)) real(kind=sgl), intent(in) :: rgy (ipar(2),ipar(3)) real(kind=sgl), intent(in) :: rgz (ipar(2),ipar(3)) real(kind=sgl), intent(in) :: stepsize (3) logical, intent(in), optional :: verbose public recursive subroutine trsbox (n, npt, xpt, xopt, gopt, hq, pq, sl, su, delta, xnew, d, gnew, xbdi, s, hs, hred, dsq, crvmin) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: xpt real :: xopt real :: gopt real :: hq real :: pq real :: sl real :: su real :: delta real :: xnew real :: d real :: gnew real :: xbdi real :: s real :: hs real :: hred real :: dsq real :: crvmin public recursive subroutine update (n, npt, bmat, zmat, ndim, vlag, beta, denom, knew, w) Arguments Type Intent Optional Attributes Name integer :: n integer :: npt real :: bmat real :: zmat integer :: ndim real :: vlag real :: beta real :: denom integer :: knew real :: w","tags":"","loc":"module/bobyqa_refinement.html","title":"bobyqa_refinement – Fortran Program"},{"text":"Uses: local clfortran module~~clsupport~~UsesGraph module~clsupport CLsupport local local local->module~clsupport clfortran clfortran clfortran->module~clsupport Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used By module~~clsupport~~UsedByGraph module~clsupport CLsupport proc~emsoftcgetmcopencl EMsoftCgetMCOpenCL module~clsupport->proc~emsoftcgetmcopencl proc~innerprodgpu InnerProdGPU module~clsupport->proc~innerprodgpu Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Subroutines CLquery_platform_info CLread_source_file CLinit_PDCCQ CLerror_check Subroutines public recursive subroutine CLquery_platform_info (platform_id) @author Marc De Graef, Carnegie Mellon University\n @brief display information about an OpenCL device (based on (clfortran's query_platforms_devices.f90)\n @param platform_id id number of platform\n @date 02/18/16 MDG 1.0 modification of clfortran's original routine\n @date 05/21/16 MDG 1.1 split CPU and GPU device information into separate blocks Arguments Type Intent Optional Attributes Name integer(kind=c_intptr_t), intent(in) :: platform_id public recursive subroutine CLread_source_file (sourcefile, csource, slength) @author Marc De Graef, Carnegie Mellon University\n @brief read an OpenCL source file and return the source properly formatted\n @param sourcefile filename for the OpenCL source code\n @param source c_str containing the source, NULL-terminated\n @param slength source string length\n @date 02/18/16  MDG 1.0 original\n @date 01/15/17  MDG 1.1 added functionality for second opencl folder for developers... Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: sourcefile character(kind=len=source_length,c_char), intent(out) :: csource integer(kind=c_size_t), intent(out) :: slength public recursive subroutine CLinit_PDCCQ (platform, nump, selnump, device, numd, selnumd, devinfo, context, command_queue) @author Marc De Graef, Carnegie Mellon University\n @brief initalize a CL platform, device, context, and command queue\n @param \n @date 02/23/16  MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=c_intptr_t), allocatable, target :: platform (:) integer(kind=irg), intent(out) :: nump integer(kind=irg), intent(in) :: selnump integer(kind=c_intptr_t), allocatable, target :: device (:) integer(kind=irg), intent(out) :: numd integer(kind=irg), intent(in) :: selnumd character(len=fnlen), intent(out) :: devinfo integer(kind=c_intptr_t), target :: context integer(kind=c_intptr_t), target :: command_queue public recursive subroutine CLerror_check (routine, ierr, nonfatal) @author Marc De Graef, Carnegie Mellon University\n @brief checks whether or not there was a CL 1.2 error and returns the error message.\n @param ierr error number (0 is no error) \n @date 06/06/16  MDG 1.0 original Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: routine integer(kind=c_int32_t), intent(in) :: ierr logical, intent(in), optional :: nonfatal","tags":"","loc":"module/clsupport.html","title":"CLsupport – Fortran Program"},{"text":"Uses: local module~~constants~~UsesGraph module~constants constants local local local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief \n Definition of constants and constant arrays used by other routines\n @details physical and mathematical constants used by various programs; periodic\n  table information; atomic weights; \n @date 1/5/99   MDG 1.0 original\n @date 5/18/01  MDG 2.0 f90\n @date 11/27/01 MDG 2.1 added kind support\n @date 03/19/13 MDG 3.0 added atomic weights \n @date 01/10/14 MDG 4.0 new version\n @date 04/29/14 MDG 4.1 constants updated from NIST physical constants tables\n @date 07/06/14 MDG 4.2 added omegamax to Lambert constant type\n @date 08/11/14 MDG 4.3 added infty for handling of +Infinity in rotations module\n @date 08/11/14 MDG 4.4 added epsijk option to package\n @date 09/30/14 MDG 4.5 added some additional comments about epsijk\n @date 10/02/14 MDG 4.6 removed omegamax again, since we now have properly dealt with 180 degree rotations\n @date 03/11/15 MDG 4.7 added some additional comments about epsijk \n @date 04/02/17 MDG 4.8 modified definition of fundamental zones types and orders to accomodate two-phase disorientations Used By module~~constants~~UsedByGraph module~constants constants proc~insidecubicfz insideCubicFZ module~constants->proc~insidecubicfz proc~insidecyclicfz insideCyclicFZ module~constants->proc~insidecyclicfz proc~insidecubehexfz insideCubeHexFZ module~constants->proc~insidecubehexfz proc~yshdisp~2 YSHDisp module~constants->proc~yshdisp~2 proc~insidecubicmfz insideCubicMFZ module~constants->proc~insidecubicmfz proc~getkosselpatterns getKosselPatterns module~constants->proc~getkosselpatterns proc~getfitorientationpsnamelist GetFitOrientationPSNameList module~constants->proc~getfitorientationpsnamelist proc~getebsdpatterns2 getEBSDPatterns2 module~constants->proc~getebsdpatterns2 proc~insidedihedralfz insideDihedralFZ module~constants->proc~insidedihedralfz proc~sample_cone sample_Cone module~constants->proc~sample_cone proc~butterflymask9x9 ButterflyMask9x9 module~constants->proc~butterflymask9x9 proc~sample_isocubefilled sample_isoCubeFilled module~constants->proc~sample_isocubefilled proc~ebsd4calfun EBSD4calfun module~constants->proc~ebsd4calfun proc~initialize_reflectionlist Initialize_ReflectionList module~constants->proc~initialize_reflectionlist proc~insidedihedralmfz insideDihedralMFZ module~constants->proc~insidedihedralmfz proc~init_foil_data init_foil_data module~constants->proc~init_foil_data proc~calcr CalcR module~constants->proc~calcr proc~mc_get_phaseshiftangle MC_get_PhaseShiftAngle module~constants->proc~mc_get_phaseshiftangle proc~sample_isocube sample_isoCube module~constants->proc~sample_isocube proc~makedislocation makedislocation module~constants->proc~makedislocation proc~initialize_foil_geometry initialize_foil_geometry module~constants->proc~initialize_foil_geometry proc~yshdisp YSHDisp module~constants->proc~yshdisp proc~getebsdpatterns getEBSDPatterns module~constants->proc~getebsdpatterns proc~isinsidefz IsinsideFZ module~constants->proc~isinsidefz proc~ecpcalfun ECPcalfun module~constants->proc~ecpcalfun proc~getfztypeandorder getFZtypeandorder module~constants->proc~getfztypeandorder proc~mc_get_ellipticityangle MC_get_EllipticityAngle module~constants->proc~mc_get_ellipticityangle proc~geteulersfromfile getEulersfromFile module~constants->proc~geteulersfromfile proc~reduceorientationtocubicefz ReduceOrientationtoCubicEFZ module~constants->proc~reduceorientationtocubicefz proc~calcrlocal CalcRLocal module~constants->proc~calcrlocal proc~mc_get_eo_from_ad MC_get_EO_from_AD module~constants->proc~mc_get_eo_from_ad proc~mc_get_orientationangle MC_get_OrientationAngle module~constants->proc~mc_get_orientationangle proc~samplerfztwin SampleRFZtwin module~constants->proc~samplerfztwin program~dispfield dispfield module~constants->program~dispfield proc~makestackingfault makestackingfault module~constants->proc~makestackingfault proc~isinsidemfz IsinsideMFZ module~constants->proc~isinsidemfz proc~getecpatterns getECPatterns module~constants->proc~getecpatterns proc~samplefcctwinrfz SamplefcctwinRFZ module~constants->proc~samplefcctwinrfz proc~reduceorientationtorfz ReduceOrientationtoRFZ module~constants->proc~reduceorientationtorfz proc~logcp logCp module~constants->proc~logcp proc~emsoftcgetebsdpatterns EMsoftCgetEBSDPatterns module~constants->proc~emsoftcgetebsdpatterns proc~calchoughlut CalcHoughLUT module~constants->proc~calchoughlut proc~initializeeshelbyinclusion InitializeEshelbyInclusion module~constants->proc~initializeeshelbyinclusion proc~mc_get_auxiliaryangle MC_get_AuxiliaryAngle module~constants->proc~mc_get_auxiliaryangle proc~watsonmeandirdensity WatsonMeanDirDensity module~constants->proc~watsonmeandirdensity proc~emsoftcgetecpatterns EMsoftCgetECPatterns module~constants->proc~emsoftcgetecpatterns proc~ebsdcalfun EBSDcalfun module~constants->proc~ebsdcalfun proc~eccicalcsgh ECCICalcSgh module~constants->proc~eccicalcsgh proc~makeyshdislocation~2 makeYSHdislocation module~constants->proc~makeyshdislocation~2 proc~calckinpedpatternsingle CalcKINPEDPatternSingle module~constants->proc~calckinpedpatternsingle proc~makestackingfaultecci makestackingfaultECCI module~constants->proc~makestackingfaultecci proc~forwardprojection ForwardProjection module~constants->proc~forwardprojection proc~emsoftcgetmcopencl EMsoftCgetMCOpenCL module~constants->proc~emsoftcgetmcopencl proc~vmfmeandirdensity VMFMeanDirDensity module~constants->proc~vmfmeandirdensity proc~sampleisomisorientation SampleIsoMisorientation module~constants->proc~sampleisomisorientation proc~emsoftcgetebsdmaster EMsoftCgetEBSDmaster module~constants->proc~emsoftcgetebsdmaster proc~di_emfordd DI_EMforDD module~constants->proc~di_emfordd proc~cubochoricneighbors CubochoricNeighbors module~constants->proc~cubochoricneighbors proc~initialize_reflectionlist_ewaldsweep Initialize_ReflectionList_EwaldSweep module~constants->proc~initialize_reflectionlist_ewaldsweep proc~mc_get_ad_from_eo MC_get_AD_from_EO module~constants->proc~mc_get_ad_from_eo module~povray povray module~constants->module~povray proc~makeyshdislocation makeYSHdislocation module~constants->proc~makeyshdislocation proc~getpfinversionnamelist GetPFInversionNameList module~constants->proc~getpfinversionnamelist proc~samplerfz SampleRFZ module~constants->proc~samplerfz proc~backprojection BackProjection module~constants->proc~backprojection Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Variables epsijk epsijkd infty inftyd cPi cLight cPlanck cBoltzmann cPermea cPermit cCharge cRestmass cMoment cJ2eV cAvogadro ATOM_sym ATOM_SPradii ATOM_MTradii ATOM_color ATOM_weights LPs FZtarray FZoarray Butterfly9x9 Derived Types LambertParametersType Variables Type Visibility Attributes Name Initial real(kind=sgl), public, parameter :: epsijk = 1.0 real(kind=dbl), public, parameter :: epsijkd = 1.D0 real(kind=sgl), public :: infty = HUGE(0.0_sgl) real(kind=dbl), public :: inftyd = HUGE(0.0_dbl) real(kind=dbl), public, parameter :: cPi = 3.141592653589793238D0 cPi        = pi [dimensionless]\n cLight = velocity of light [m/s]\n cPlanck    = Planck''s constant [Js]\n cBoltzmann = Boltmann constant [J/K]\n cPermea    = permeability of vacuum [dimensionless]\n cPermit    = permittivity of vacuum [F/m]\n cCharge    = electron charge [C]\n cRestmass  = electron rest mass [kg]\n cMoment    = electron magnetic moment [J/T]\n cJ2eV  = Joules per eV\n cAvogadro  = Avogadro's constant [mol&#94;-1] real(kind=dbl), public, parameter :: cLight = 299792458.D0 cPi        = pi [dimensionless]\n cLight = velocity of light [m/s]\n cPlanck    = Planck''s constant [Js]\n cBoltzmann = Boltmann constant [J/K]\n cPermea    = permeability of vacuum [dimensionless]\n cPermit    = permittivity of vacuum [F/m]\n cCharge    = electron charge [C]\n cRestmass  = electron rest mass [kg]\n cMoment    = electron magnetic moment [J/T]\n cJ2eV  = Joules per eV\n cAvogadro  = Avogadro's constant [mol&#94;-1] real(kind=dbl), public, parameter :: cPlanck = 6.62606957D-34 cPi        = pi [dimensionless]\n cLight = velocity of light [m/s]\n cPlanck    = Planck''s constant [Js]\n cBoltzmann = Boltmann constant [J/K]\n cPermea    = permeability of vacuum [dimensionless]\n cPermit    = permittivity of vacuum [F/m]\n cCharge    = electron charge [C]\n cRestmass  = electron rest mass [kg]\n cMoment    = electron magnetic moment [J/T]\n cJ2eV  = Joules per eV\n cAvogadro  = Avogadro's constant [mol&#94;-1] real(kind=dbl), public, parameter :: cBoltzmann = 1.3806488D-23 cPi        = pi [dimensionless]\n cLight = velocity of light [m/s]\n cPlanck    = Planck''s constant [Js]\n cBoltzmann = Boltmann constant [J/K]\n cPermea    = permeability of vacuum [dimensionless]\n cPermit    = permittivity of vacuum [F/m]\n cCharge    = electron charge [C]\n cRestmass  = electron rest mass [kg]\n cMoment    = electron magnetic moment [J/T]\n cJ2eV  = Joules per eV\n cAvogadro  = Avogadro's constant [mol&#94;-1] real(kind=dbl), public, parameter :: cPermea = 1.2566370614D-6 cPi        = pi [dimensionless]\n cLight = velocity of light [m/s]\n cPlanck    = Planck''s constant [Js]\n cBoltzmann = Boltmann constant [J/K]\n cPermea    = permeability of vacuum [dimensionless]\n cPermit    = permittivity of vacuum [F/m]\n cCharge    = electron charge [C]\n cRestmass  = electron rest mass [kg]\n cMoment    = electron magnetic moment [J/T]\n cJ2eV  = Joules per eV\n cAvogadro  = Avogadro's constant [mol&#94;-1] real(kind=dbl), public, parameter :: cPermit = 8.854187817D-12 cPi        = pi [dimensionless]\n cLight = velocity of light [m/s]\n cPlanck    = Planck''s constant [Js]\n cBoltzmann = Boltmann constant [J/K]\n cPermea    = permeability of vacuum [dimensionless]\n cPermit    = permittivity of vacuum [F/m]\n cCharge    = electron charge [C]\n cRestmass  = electron rest mass [kg]\n cMoment    = electron magnetic moment [J/T]\n cJ2eV  = Joules per eV\n cAvogadro  = Avogadro's constant [mol&#94;-1] real(kind=dbl), public, parameter :: cCharge = 1.602176565D-19 cPi        = pi [dimensionless]\n cLight = velocity of light [m/s]\n cPlanck    = Planck''s constant [Js]\n cBoltzmann = Boltmann constant [J/K]\n cPermea    = permeability of vacuum [dimensionless]\n cPermit    = permittivity of vacuum [F/m]\n cCharge    = electron charge [C]\n cRestmass  = electron rest mass [kg]\n cMoment    = electron magnetic moment [J/T]\n cJ2eV  = Joules per eV\n cAvogadro  = Avogadro's constant [mol&#94;-1] real(kind=dbl), public, parameter :: cRestmass = 9.10938291D-31 cPi        = pi [dimensionless]\n cLight = velocity of light [m/s]\n cPlanck    = Planck''s constant [Js]\n cBoltzmann = Boltmann constant [J/K]\n cPermea    = permeability of vacuum [dimensionless]\n cPermit    = permittivity of vacuum [F/m]\n cCharge    = electron charge [C]\n cRestmass  = electron rest mass [kg]\n cMoment    = electron magnetic moment [J/T]\n cJ2eV  = Joules per eV\n cAvogadro  = Avogadro's constant [mol&#94;-1] real(kind=dbl), public, parameter :: cMoment = 9.28476430D-24 cPi        = pi [dimensionless]\n cLight = velocity of light [m/s]\n cPlanck    = Planck''s constant [Js]\n cBoltzmann = Boltmann constant [J/K]\n cPermea    = permeability of vacuum [dimensionless]\n cPermit    = permittivity of vacuum [F/m]\n cCharge    = electron charge [C]\n cRestmass  = electron rest mass [kg]\n cMoment    = electron magnetic moment [J/T]\n cJ2eV  = Joules per eV\n cAvogadro  = Avogadro's constant [mol&#94;-1] real(kind=dbl), public, parameter :: cJ2eV = 1.602176565D-19 cPi        = pi [dimensionless]\n cLight = velocity of light [m/s]\n cPlanck    = Planck''s constant [Js]\n cBoltzmann = Boltmann constant [J/K]\n cPermea    = permeability of vacuum [dimensionless]\n cPermit    = permittivity of vacuum [F/m]\n cCharge    = electron charge [C]\n cRestmass  = electron rest mass [kg]\n cMoment    = electron magnetic moment [J/T]\n cJ2eV  = Joules per eV\n cAvogadro  = Avogadro's constant [mol&#94;-1] real(kind=dbl), public, parameter :: cAvogadro = 6.02214129D23 cPi        = pi [dimensionless]\n cLight = velocity of light [m/s]\n cPlanck    = Planck''s constant [Js]\n cBoltzmann = Boltmann constant [J/K]\n cPermea    = permeability of vacuum [dimensionless]\n cPermit    = permittivity of vacuum [F/m]\n cCharge    = electron charge [C]\n cRestmass  = electron rest mass [kg]\n cMoment    = electron magnetic moment [J/T]\n cJ2eV  = Joules per eV\n cAvogadro  = Avogadro's constant [mol&#94;-1] character(len=2), public, parameter :: ATOM_sym (98) = (/' H', 'He', 'Li', 'Be', ' B', ' C', ' N', ' O', ' F', 'Ne', 'Na', 'Mg', 'Al', 'Si', ' P', ' S', 'Cl', 'Ar', ' K', 'Ca', 'Sc', 'Ti', ' V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', ' Y', 'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', ' I', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu', 'Hf', 'Ta', ' W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th', 'Pa', ' U', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf'/) element symbols (we'll do 1-98 for all parameter lists) real(kind=sgl), public, parameter :: ATOM_SPradii (98) = (/0.010, 0.010, 0.680, 0.300, 0.160, 0.150, 0.148, 0.146, 0.133, 0.500, 0.098, 0.065, 0.450, 0.380, 0.340, 0.190, 0.181, 0.500, 0.133, 0.940, 0.068, 0.060, 0.740, 0.690, 0.670, 0.640, 0.630, 0.620, 0.720, 0.740, 0.113, 0.073, 0.580, 0.202, 0.196, 0.500, 0.148, 0.110, 0.880, 0.770, 0.067, 0.068, 0.500, 0.500, 0.500, 0.860, 0.126, 0.970, 0.132, 0.930, 0.076, 0.222, 0.219, 0.500, 0.167, 0.129, 0.104, 0.111, 0.500, 0.108, 0.050, 0.104, 0.500, 0.970, 0.500, 0.990, 0.500, 0.960, 0.500, 0.940, 0.050, 0.050, 0.680, 0.600, 0.520, 0.500, 0.500, 0.500, 0.137, 0.112, 0.140, 0.132, 0.740, 0.230, 0.227, 0.500, 0.175, 0.137, 0.111, 0.990, 0.090, 0.083, 0.500, 0.108, 0.500, 0.500, 0.500, 0.500/) Shannon-Prewitt ionic radii in nanometer real(kind=sgl), public, parameter :: ATOM_MTradii (98) = (/0.100, 0.100, 0.156, 0.112, 0.100, 0.100, 0.100, 0.100, 0.100, 0.100, 0.191, 0.160, 0.142, 0.100, 0.100, 0.100, 0.100, 0.100, 0.238, 0.196, 0.160, 0.146, 0.135, 0.128, 0.136, 0.127, 0.125, 0.124, 0.128, 0.137, 0.135, 0.139, 0.125, 0.116, 0.100, 0.100, 0.253, 0.215, 0.181, 0.160, 0.147, 0.140, 0.135, 0.133, 0.134, 0.137, 0.144, 0.152, 0.167, 0.158, 0.161, 0.143, 0.100, 0.100, 0.270, 0.224, 0.187, 0.182, 0.182, 0.181, 0.100, 0.100, 0.204, 0.178, 0.177, 0.175, 0.176, 0.173, 0.174, 0.193, 0.173, 0.158, 0.147, 0.141, 0.137, 0.135, 0.135, 0.138, 0.144, 0.155, 0.171, 0.174, 0.182, 0.168, 0.100, 0.100, 0.100, 0.100, 0.100, 0.180, 0.163, 0.154, 0.150, 0.164, 0.100, 0.100, 0.100, 0.100/) atomic (metallic) radii in nanometer (0.100 if not known/applicable) character(len=3), public, parameter :: ATOM_color (98) = (/'blu', 'grn', 'blu', 'blu', 'red', 'bro', 'blu', 'red', 'grn', 'grn', 'blu', 'pnk', 'grn', 'red', 'pnk', 'cyn', 'blu', 'blu', 'grn', 'grn', 'blu', 'blu', 'grn', 'red', 'pnk', 'cyn', 'blu', 'blu', 'grn', 'grn', 'blu', 'blu', 'grn', 'red', 'pnk', 'cyn', 'blu', 'blu', 'grn', 'grn', 'blu', 'blu', 'grn', 'red', 'pnk', 'cyn', 'blu', 'blu', 'grn', 'grn', 'blu', 'blu', 'grn', 'red', 'pnk', 'cyn', 'blu', 'blu', 'grn', 'grn', 'blu', 'blu', 'grn', 'red', 'pnk', 'cyn', 'blu', 'blu', 'grn', 'grn', 'blu', 'blu', 'grn', 'red', 'pnk', 'cyn', 'blu', 'blu', 'grn', 'grn', 'blu', 'blu', 'grn', 'red', 'pnk', 'cyn', 'blu', 'blu', 'grn', 'grn', 'blu', 'blu', 'grn', 'red', 'pnk', 'cyn', 'blu', 'grn'/) atom colors for PostScript drawings real(kind=sgl), public, parameter :: ATOM_weights (98) = (/1.00794, 4.002602, 6.941, 9.012182, 10.811, 12.0107, 14.0067, 15.9994, 18.9984032, 20.1797, 22.98976928, 24.3050, 26.9815386, 28.0855, 30.973762, 32.065, 35.453, 39.948, 39.0983, 40.078, 44.955912, 47.867, 50.9415, 51.9961, 54.938045, 55.845, 58.933195, 58.6934, 63.546, 65.38, 69.723, 72.64, 74.92160, 78.96, 79.904, 83.798, 85.4678, 87.62, 88.90585, 91.224, 92.90638, 95.96, 98.9062, 101.07, 102.90550, 106.42, 107.8682, 112.411, 114.818, 118.710, 121.760, 127.60, 126.90447, 131.293, 132.9054519, 137.327, 138.90547, 140.116, 140.90765, 144.242, 145.0, 150.36, 151.964, 157.25, 158.92535, 162.500, 164.93032, 167.259, 168.93421, 173.054, 174.9668, 178.49, 180.94788, 183.84, 186.207, 190.23, 192.217, 195.084, 196.966569, 200.59, 204.3833, 207.2, 208.98040, 209.0, 210.0, 222.0, 223.0, 226.0, 227.0, 232.03806, 231.03588, 238.02891, 237.0, 244.0, 243.0, 247.0, 251.0, 252.0/) atomic weights for things like density computations (from NIST elemental data base) type( LambertParametersType ), public :: LPs integer(kind=irg), public, parameter :: FZtarray (32) = (/0, 0, 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 2, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 3, 4/) integer(kind=irg), public, parameter :: FZoarray (32) = (/0, 0, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0/) real(kind=sgl), public :: Butterfly9x9 (81) = (/-10.0, -15.0, -22.0, -22.0, -22.0, -22.0, -22.0, -15.0, -10.0, -1.0, -6.0, -13.0, -22.0, -22.0, -22.0, -13.0, -6.0, -1.0, 3.0, 6.0, 4.0, -3.0, -22.0, -3.0, 4.0, 6.0, 3.0, 3.0, 11.0, 19.0, 28.0, 42.0, 28.0, 19.0, 11.0, 3.0, 3.0, 11.0, 27.0, 42.0, 42.0, 42.0, 27.0, 11.0, 3.0, 3.0, 11.0, 19.0, 28.0, 42.0, 28.0, 19.0, 11.0, 3.0, 3.0, 6.0, 4.0, -3.0, -22.0, -3.0, 4.0, 6.0, 3.0, -1.0, -6.0, -13.0, -22.0, -22.0, -22.0, -13.0, -6.0, -1.0, -10.0, -15.0, -22.0, -22.0, -22.0, -22.0, -22.0, -15.0, -10.0/) Derived Types type, public :: LambertParametersType Components Type Visibility Attributes Name Initial real(kind=dbl), public :: Pi = 3.141592653589793D0 real(kind=dbl), public :: iPi = 0.318309886183791D0 real(kind=dbl), public :: sPi = 1.772453850905516D0 real(kind=dbl), public :: sPio2 = 1.253314137315500D0 real(kind=dbl), public :: sPi2 = 0.886226925452758D0 real(kind=dbl), public :: srt = 0.86602540378D0 real(kind=dbl), public :: isrt = 0.57735026919D0 real(kind=dbl), public :: alpha = 1.346773687088598D0 real(kind=dbl), public :: rtt = 1.732050807568877D0 real(kind=dbl), public :: prea = 0.525037567904332D0 real(kind=dbl), public :: preb = 1.050075135808664D0 real(kind=dbl), public :: prec = 0.906899682117109D0 real(kind=dbl), public :: pred = 2.094395102393195D0 real(kind=dbl), public :: pree = 0.759835685651593D0 real(kind=dbl), public :: pref = 1.381976597885342D0 real(kind=dbl), public :: preg = 1.5551203015562141D0 real(kind=dbl), public :: a = 1.925749019958253D0 real(kind=dbl), public :: ap = 2.145029397111025D0 real(kind=dbl), public :: sc = 0.897772786961286D0 real(kind=dbl), public :: beta = 0.962874509979126D0 real(kind=dbl), public :: R1 = 1.330670039491469D0 real(kind=dbl), public :: r2 = 1.414213562373095D0 real(kind=dbl), public :: r22 = 0.707106781186547D0 real(kind=dbl), public :: pi12 = 0.261799387799149D0 real(kind=dbl), public :: pi8 = 0.392699081698724D0 real(kind=dbl), public :: prek = 1.643456402972504D0 real(kind=dbl), public :: r24 = 4.898979485566356D0 real(kind=dbl), public :: tfit (21) = (/0.9999999999999968D0, -0.49999999999986866D0, -0.025000000000632055D0, -0.003928571496460683D0, -0.0008164666077062752D0, -0.00019411896443261646D0, -0.00004985822229871769D0, -0.000014164962366386031D0, -1.9000248160936107D-6, -5.72184549898506D-6, 7.772149920658778D-6, -0.00001053483452909705D0, 9.528014229335313D-6, -5.660288876265125D-6, 1.2844901692764126D-6, 1.1255185726258763D-6, -1.3834391419956455D-6, 7.513691751164847D-7, -2.401996891720091D-7, 4.386887017466388D-8, -3.5917775353564864D-9/) real(kind=dbl), public :: BP (6) = (/0.D0, 1.D0, 0.577350269189626D0, 0.414213562373095D0, 0.D0, 0.267949192431123D0/)","tags":"","loc":"module/constants.html","title":"constants – Fortran Program"},{"text":"Uses: local quaternions typedefs module~~defectmodule~~UsesGraph module~defectmodule defectmodule quaternions quaternions quaternions->module~defectmodule local local local->module~defectmodule typedefs typedefs typedefs->module~defectmodule Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief Provides a routine to compute the displacement vector for an array of defects.\n @date 04/29/11 MDG 1.0 original\n @date 06/04/13 MDG 2.0 rewrite + quaternions instead of rotations\n @date 11/13/13 MDG 2.1 fixed error with coordinate transformations (after very long bug search!)\n @date 11/17/15 MDG 3.0 start of complete rewrite; this mod will now include a routine to read all defect info from a json file\n @date 11/23/15 MDG 3.1 inserted all defect mods into this file instead of separate files\n @date 12/08/15 MDG 3.2 added artificial distortion to inclusion field to mimic ellipsoidal shape (needs Eshelby for correct field)\n @date 12/11/15 MDG 3.3 gave up on previous item and implemented full isotropic Eshelby ellipsoidal inclusion Used By module~~defectmodule~~UsedByGraph module~defectmodule defectmodule proc~calcrlocal CalcRLocal module~defectmodule->proc~calcrlocal program~dispfield dispfield module~defectmodule->program~dispfield Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Functions YSHDisp Eshelby_disp Subroutines InitializeDefects init_foil_data init_dislocation_data init_stacking_fault_data init_YSH_dislocation_data init_void_data init_inclusion_data init_Einclusion_data initialize_foil_geometry makedislocation makestackingfault makestackingfaultECCI makeYSHdislocation InitializeEshelbyInclusion CalcR Functions public recursive function YSHDisp (defects, x, y, z, ii) result(res) @author Marc De Graef, Carnegie Mellon University\n @brief  compute the displacement field of an inclined dislocation intersecting the foil surface\n @details compute the displacement field of an inclined dislocation intersecting the top surface of \n the foil, taking into account surface relaxations for the isotropic elastic case (cubic only) ... Arguments Type Intent Optional Attributes Name type(defecttype), intent(inout) :: defects real(kind=dbl), intent(in) :: x real(kind=dbl), intent(in) :: y real(kind=dbl), intent(in) :: z integer(kind=irg), intent(in) :: ii Return Value real(kind=dbl)\n  (3) public recursive function Eshelby_disp (defects, i, xyz) result(u) @author Marc De Graef, Carnegie Mellon University\n @brief compute the actual displacement vector for an isotropic Eshelby ellipsoidal inclusion\n We implemented the Eshelby expressions based on Mura's 1987 book.\n @param defects defects structure\n @param i Einclusion number\n @param xyz coordinate triplet\n @date 12/11/15 MDG 1.0 initial version based on trial IDL script\n @date 12/13/15 MDG 1.1 corrections to some of the auxiliary expressions; sphere limit is now correct Arguments Type Intent Optional Attributes Name type(defecttype), intent(in) :: defects integer(kind=irg), intent(in) :: i real(kind=dbl), intent(in) :: xyz (3) Return Value real(kind=dbl)\n  (3) Subroutines public recursive subroutine InitializeDefects (cell, defects, jsonname, npix, npiy, L, gf, error_cnt, verbose) @author Marc De Graef, Carnegie Mellon University\n @brief read defect information, and generate all data that can be precomputed for each defect\n @date  11/22/15 MDG 1.0 original\n @date  11/24/15 MDG 1.1 added Ydislocations, stacking faults, inclusions and voids Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(defecttype), intent(inout) :: defects character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(in) :: npix integer(kind=irg), intent(in) :: npiy real(kind=sgl), intent(in) :: L real(kind=sgl), intent(in) :: gf (3) integer(kind=irg), intent(inout) :: error_cnt logical, intent(in), optional :: verbose public recursive subroutine init_foil_data (cell, defects, npix, npiy, L, dinfo) @author Marc De Graef, Carnegie Mellon University\n @brief  initializes the foil geometry data\n @param cell unit cell pointer\n @param defects defects structure\n @param npix number of x image pixels\n @param npiy number of y image pixels\n @param L pixel size for column approximation\n @param dinfo flag to print information\n @date 11/22/15 MDG 1.0 new routine in Release 3.1; read portion replaced with JSONreadFoilData in JSONsupport Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(defecttype), intent(inout) :: defects integer(kind=irg), intent(in) :: npix integer(kind=irg), intent(in) :: npiy real(kind=sgl), intent(in) :: L integer(kind=irg), intent(in) :: dinfo public recursive subroutine init_dislocation_data (cell, defects, DF_npix, DF_npiy, DF_gf, L, dinfo) @author Marc De Graef, Carnegie Mellon University\n @brief  init dislocation namelist files\n @param cell unit cell pointer\n @param defects defect structure\n @param DF_npix number of x-pixels\n @param DF_npiy number of y-pixels\n @param DF_gf \n @param L \n @param dinfo logical to trigger verbose output\n @date 01/05/99 MDG 1.0 original\n @date 05/19/01 MDG 2.0 f90 version\n @date 11/27/01 MDG 2.1 added kind support\n @date 06/04/13 MDG 3.0 rewrite\n @date 06/09/14 MDG 4.0 added cell, DL argument\n @date 11/22/15 MDG 4.1 old routine obsolete with Release 3.1; replaced by JsonreadDefectFile\n @date 11/23/15 MDG 4.2 moved from dislocation.f90 to defectmodule.f90 Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(defecttype), intent(inout) :: defects integer(kind=irg), intent(in) :: DF_npix integer(kind=irg), intent(in) :: DF_npiy real(kind=sgl), intent(in) :: DF_gf (3) real(kind=sgl), intent(in) :: L integer(kind=irg), intent(in) :: dinfo public recursive subroutine init_stacking_fault_data (cell, defects, DF_L, DF_npix, DF_npiy, DF_g, dinfo, ECCI) @author Marc De Graef, Carnegie Mellon University\n @brief  read stacking fault namelist files\n @param cell unit cell pointer\n @param defects defect structure\n @param DF_L \n @param DF_npix number of x-pixels\n @param DF_npiy number of y-pixels\n @param DF_gf \n @param dinfo logical to trigger verbose output\n @param ECCI logical optional to indicate ECCI formatting rather than regular TEM\n @date    1/5/99  MDG 1.0 original\n @date    5/19/01 MDG 2.0 f90 version\n @date   11/27/01 MDG 2.1 added kind support\n @date   06/04/13 MDG 3.0 rewrite\n @date   12/17/13 MDG 3.1 added ECCI mode\n @date   06/09/14 MDG 4.0 added cell, defects arguments\n @date   06/10/14 MDG 4.1 added foil argument Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(defecttype), intent(inout) :: defects real(kind=sgl), intent(in) :: DF_L integer(kind=irg), intent(in) :: DF_npix integer(kind=irg), intent(in) :: DF_npiy real(kind=sgl), intent(in) :: DF_g (3) integer(kind=irg), intent(in) :: dinfo logical, intent(in), optional :: ECCI public recursive subroutine init_YSH_dislocation_data (cell, defects, DF_npix, DF_npiy, DF_gf, L, dinfo) @author Marc De Graef, Carnegie Mellon University\n @brief init Yoffe dislocation \n @param cell unit cell pointer\n @param defects defects structure\n @param DF_npix number of x-pixels\n @param DF_npiy number of y-pixels\n @param DF_gf \n @param L \n @param dinfo logical to trigger verbose output\n @date  1/5/99  MDG 1.0 original\n @date  5/19/01 MDG 2.0 f90 version\n @date 11/27/01 MDG 2.1 added kind support\n @date 03/25/13 MDG 3.0 updated IO\n @date 11/21/13 MDG 3.1 verification\n @date 06/10/14 MDG 4.0 added defects, cell and foil arguments\n @date 11/23/15 MDG 4.1 made foil part of defects Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(defecttype), intent(inout) :: defects integer(kind=irg), intent(in) :: DF_npix integer(kind=irg), intent(in) :: DF_npiy real(kind=sgl), intent(in) :: DF_gf (3) real(kind=sgl), intent(in) :: L integer(kind=irg), intent(in) :: dinfo public recursive subroutine init_void_data (defects, DF_L, DF_npix, DF_npiy, dinfo) @author Marc De Graef, Carnegie Mellon University\n @brief  init void parameters \n @param defects defects structure\n @param DF_L column edge length \n @param DF_npix number of x-pixels\n @param DF_npiy number of y-pixels\n @param dinfo logical to trigger verbose output\n @date 01/05/99 MDG 1.0 original\n @date 05/19/01 MDG 2.0 f90 version\n @date 11/27/01 MDG 2.1 added kind support\n @date 03/25/13 MDG 3.0 updated IO\n @date 06/09/14 MDG 4.0 added defects argument\n @date 06/10/14 MDG 4.1 added foil argument\n @date 11/23/15 MDG 4.2 removed foil and put it inside defects Arguments Type Intent Optional Attributes Name type(defecttype), intent(inout) :: defects real(kind=sgl), intent(in) :: DF_L integer(kind=irg), intent(in) :: DF_npix integer(kind=irg), intent(in) :: DF_npiy integer(kind=irg), intent(in) :: dinfo public recursive subroutine init_inclusion_data (defects, DF_L, DF_npix, DF_npiy, dinfo) @author Marc De Graef, Carnegie Mellon University\n @brief  init inclusion parameters \n @param defects defect structure\n @param DF_L column edge length \n @param DF_npix number of x-pixels\n @param DF_npiy number of y-pixels\n @param dinfo logical to trigger verbose output\n @date  01/05/99 MDG 1.0 original\n @date  05/19/01 MDG 2.0 f90 version\n @date  11/27/01 MDG 2.1 added kind support\n @date  03/25/13 MDG 3.0 updated IO\n @date  06/09/14 MDG 4.0 added defects argument\n @date  06/10/14 MDG 4.1 added foil argument\n @date  11/23/15 MDG 4.2 made foil part of defects Arguments Type Intent Optional Attributes Name type(defecttype), intent(inout) :: defects real(kind=sgl), intent(in) :: DF_L integer(kind=irg), intent(in) :: DF_npix integer(kind=irg), intent(in) :: DF_npiy integer(kind=irg), intent(in) :: dinfo public recursive subroutine init_Einclusion_data (cell, defects, DF_L, DF_npix, DF_npiy, dinfo) @author Marc De Graef, Carnegie Mellon University\n @brief  init inclusion parameters \n @param cell cell structure pointer\n @param defects defect structure\n @param DF_L column edge length \n @param DF_npix number of x-pixels\n @param DF_npiy number of y-pixels\n @param dinfo logical to trigger verbose output\n @date  01/05/99 MDG 1.0 original\n @date  05/19/01 MDG 2.0 f90 version\n @date  11/27/01 MDG 2.1 added kind support\n @date  03/25/13 MDG 3.0 updated IO\n @date  06/09/14 MDG 4.0 added defects argument\n @date  06/10/14 MDG 4.1 added foil argument\n @date  11/23/15 MDG 4.2 made foil part of defects\n @date  12/08/15 MDG 4.3 forked from init_inclusion_data\n @date  12/11/15 MDG 4.4 reworked based on IDL ellipsoid.pro script Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(defecttype), intent(inout) :: defects real(kind=sgl), intent(in) :: DF_L integer(kind=irg), intent(in) :: DF_npix integer(kind=irg), intent(in) :: DF_npiy integer(kind=irg), intent(in) :: dinfo public recursive subroutine initialize_foil_geometry (cell, foil, dinfo) @author Marc De Graef, Carnegie Mellon University\n @brief  Initializes the foil geometry\n @details This new implementation uses quaternions for all rotations. \n @param cell unit cell pointer\n @param dinfo\n @date  1/ 5/99 MDG 1.0 original\n @date  1/11/10 MDG 2.0 rewrite of beam direction part\n @date  3/28/11 MDG 2.1 code verified\n @date  4/23/11 MDG 2.2 redefined origin to be at center of image\n @date  6/03/13 MDG 3.0 replaced rotation matrices by quaternions throughout\n @date 10/30/13 MDG 3.1 complete debug of quaternion and rotation implementation \n @date 06/09/14 MDG 4.0 added cell and foil as argument Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(foiltype), intent(inout) :: foil integer(kind=sgl), intent(in) :: dinfo public recursive subroutine makedislocation (cell, defects, inum, dinfo, DF_L) @author Marc De Graef, Carnegie Mellon University\n @brief  Compute the dismat displacement matrix for a given dislocation\n @details This subroutine computes the matrix dismat that describes the displacement field\n of a dislocation.  The routine needs the elastic moduli tensor, the transformation\n matrix between the crystal and dislocation reference frames, and the dislocation\n Burgers vector.  The routine computes the arrays dismat and pa, which should be used as follows: Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(defecttype), intent(inout) :: defects integer(kind=irg), intent(in) :: inum integer(kind=irg), intent(in) :: dinfo real(kind=sgl), intent(in) :: DF_L public recursive subroutine makestackingfault (cell, defects, inum, DF_L, nx, ny, DF_g, dinfo) @author Marc De Graef, Carnegie Mellon University\n @brief compute parameters for a stacking fault\n @details  This subroutine computes the geometrical parameters for a \n stacking fault.  It computes, among others, the coordinates of the \n centers of the partial dislocations, the intersections of each dislocation\n line with the top and bottom foil surface, and an array that indicates, for\n each image pixel, whether or not the corresponding integration column \n contains this fault; if it does not, the  value in the array is set to \n -10000; if it does, then the value is equal to the point where the fault\n plane intersects with the column, measured from the top surface.\n In short, anything that is needed in the CalcR routine and can be computed \n ahead of time, is computed here.  The routine also calls the makedislocation \n routine to create the partials.\n @param cell unit cell pointer\n @param defects defect structure\n @param inum\n @param DF_L column edge length\n @param nx\n @param ny\n @param DF_g\n @param ndl\n @param dinfo trigger for verbose output\n @date   11/05/13 MDG 1.0 new attempt to replace faulty original routine\n @date   11/13/13 MDG 1.1 traced error to problem with transformations in defectmodule\n @date   11/13/13 MDG 1.2 changed SF normal transformation for zpos array computation (to be tested)\n @date   06/09/14 MDG 2.0 added defects and cell as arguments\n @date   06/10/14 MDG 2.1 added foil as argument Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(defecttype), intent(inout) :: defects integer(kind=irg), intent(in) :: inum real(kind=sgl), intent(in) :: DF_L integer(kind=irg), intent(in) :: nx integer(kind=irg), intent(in) :: ny real(kind=sgl), intent(in) :: DF_g (3) integer(kind=irg), intent(in) :: dinfo public recursive subroutine makestackingfaultECCI (cell, defects, inum, DF_L, nx, ny, DF_g, dinfo) @author Marc De Graef, Carnegie Mellon University\n @brief compute parameters for a stacking fault in ECCI mode\n @details  This subroutine computes the geometrical parameters for a \n stacking fault.  It computes, among others, the coordinates of the surface\n intersections of the partial dislocations, and an array that indicates, for\n each image pixel, whether or not the corresponding integration column \n contains this fault; if it does not, the  value in the array is set to \n -10000; if it does, then the value is equal to the point where the fault\n plane intersects with the column, measured from the top surface.\n In short, anything that is needed in the CalcR routine and can be computed \n ahead of time, is computed here.  The routine also calls the makedislocation \n routine to create the partials.\n @param cell unit cell pointer\n @param defects defect structure\n @param inum\n @param DF_L column edge length\n @param nx\n @param ny\n @param DF_g\n @param ndl\n @param dinfo trigger for verbose output\n @date   11/05/13 MDG 1.0 new attempt to replace faulty original routine\n @date   11/13/13 MDG 1.1 traced error to problem with transformations in defectmodule\n @date   11/13/13 MDG 1.2 changed SF normal transformation for zpos array computation (to be tested)\n @date   12/17/13 MDG 1.3 branch from original routine to deal with different ECCI geometry\n @date   12/18/13 MDG 1.4 debug of stacking fault location array\n @date   06/09/14 MDG 2.0 added cell, SF, YD arguments\n @date   06/10/14 MDG 2.1 added foil argument Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(defecttype), intent(inout) :: defects integer(kind=irg), intent(in) :: inum real(kind=sgl), intent(in) :: DF_L integer(kind=irg), intent(in) :: nx integer(kind=irg), intent(in) :: ny real(kind=sgl), intent(in) :: DF_g (3) integer(kind=irg), intent(in) :: dinfo public recursive subroutine makeYSHdislocation (cell, defects, i, dinfo, L) @author Marc De Graef, Carnegie Mellon University\n @brief pre-compute geometrical parametersf or the Yoffe&Shaibani&Hazzledine (YSH) \n surface-relaxed dislocation in an elastically isotropic matrix. \n @details These parameters are then used in the CalcR routine. Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(defecttype), intent(inout) :: defects integer(kind=irg), intent(in) :: i integer(kind=irg), intent(in) :: dinfo real(kind=sgl), intent(in) :: L public recursive subroutine InitializeEshelbyInclusion (cell, defects, i, dinfo, L, npix, npiy) @author Marc De Graef, Carnegie Mellon University\n @brief pre-compute all parameters for an isotropic Eshelby ellipsoidal inclusion\n @details These parameters are then used in the CalcR routine. Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(defecttype), intent(inout) :: defects integer(kind=irg), intent(in) :: i integer(kind=irg), intent(in) :: dinfo real(kind=sgl), intent(in) :: L integer(kind=irg), intent(in) :: npix integer(kind=irg), intent(in) :: npiy public recursive subroutine CalcR (cell, defects, i, j) @author Marc De Graef, Carnegie Mellon University\n @brief returns the total displacement vector for each slice in a column\n @details Note that the end result MUST be expressed in the cartesian reference frame !\n @param cell unit cell pointer\n @param defects defect structure\n @param i integer x coordinate \n @param j integer y coordinate Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(defecttype), intent(inout) :: defects integer(kind=irg), intent(in) :: i integer(kind=irg), intent(in) :: j","tags":"","loc":"module/defectmodule.html","title":"defectmodule – Fortran Program"},{"text":"@author Marc De Graef, Carnegie Mellon University\n @brief Dictionary indexing routines\n @details This module contains all the routines that deal with the dictionary\n indexing approach, both in terms of computing all the dot products (which uses\n OpenCL kernels) and in terms of the subsequent indexing on the symmetrized \n quaternion unit sphere using the modified von Mises-Fisher distribution, or the\n modified mixture of axial Watson distributinos.  All\n the details for this approach can be found in two papers: \"A dictionary based approach for EBSD indexing\", Yu Hui Chen, Se Un Park, Dennis Wei, \n Greg Newstadt, Michael Jackson, Jeff Simmons, Alfred Hero, and Marc De Graef, \n Microscopy & Microanalysis, under review (2015). \"Parameter estimation in spherical symmetry groups\", Yu Hui Chen, Dennis Wei,\n Gregory Newstadt, Marc De Graef, Jeff Simmons, and Al Hero, IEEE Signal Processing \n Letters, in print (2015) Here is an example program showing how the routines can be called: program t use local\n use typedefs\n use dictmod\n use quaternions\n use constants integer(kind=irg)               :: nums, seed\n real(kind=dbl),allocatable      :: samples(:,:)\n type(dicttype)                  :: dict\n real(kind=dbl)                  :: muhat(4), kappahat ! this is a test of the dictionary indexing portion that deals with the \n ! modified von Mises-Fisher distribution; the results must be the same \n ! as those produced by the original Matlab code... seed = 432514\n nums = 1000\n allocate(samples(4,nums)) allocate(dict)\n dict%Num_of_init = 3\n dict%Num_of_iterations = 30\n dict%pgnum = 32 ! read a bunch of quaternions from a file... and store them in samples call DI_Init(dict,'VMF') ! replace 'VMF' by 'WAT' to use the axial Watson distribution do i=1,10\n   call DI_EMforDD(samples, dict, nums, seed, muhat, kappahat,'VMF')  ! replace 'VMF' by 'WAT' to use the Watson distribution write ( , ) '  '\n   write ( , ) 'mu    = ',muhat\n   write ( , ) 'kappa = ',kappahat\n   write ( , ) 'equivalent angular precision : ',180.D0*dacos(1.D0-1.D0/kappahat)/cPi\n end do end program @date 12/31/14 MDG 1.0 original (based on UMich Matlab code and IDL intermediate version)\n @date 01/02/15 MDG 1.1 debug of code; produces same result as Matlab code\n @date 01/04/15 MDG 1.2 trial implementation of model using hyperbolic functions instead of exponential\n @date 01/06/15 MDG 1.3 changed public routine names with DI_ in front\n @date 01/07/15 MDG 1.4 added VMF sampling routines \n @date 01/09/15 MDG 1.5 replaced several computations by numerically more stable versions\n @date 02/05/15 MDG 1.6 added sampling for axial Watson distribution\n @date 02/06/15 MDG 1.7 streamlined sampling code by removing duplications; VMF vs. Watson is now an argument \n @date 02/06/15 MDG 1.8 general rewrite and removal of duplications in indexing routines; some name changes Used By module~~dictmod~~UsedByGraph module~dictmod dictmod proc~forwardprojection ForwardProjection module~dictmod->proc~forwardprojection proc~backprojection BackProjection module~dictmod->proc~backprojection Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Interfaces getDisorientationAngle Functions DI_RotateToMu randUniformSphere DI_SampleDD randDDMarginal getDDDensityLBM VMFMeanDirDensity WatsonMeanDirDensity DD_Estep DD_Mstep DD_Density logCp Subroutines DI_Init DI_EMforDD DD_getQandL DI_Similarity_Classifier CardIntersection ReduceDisorientationtoMFZ ReduceOrientationtoCubicEFZ ReduceOrientationtoRFZ getDisorientationAngleDouble getDisorientationAngleSingle getDisorientationAngleAxis getDisorientationAngleAxisTwoPhases Interfaces public interface getDisorientationAngle public recursive subroutine getDisorientationAngleSingle (eu1, eu2, dict, disang, ax) @author Marc De Graef, Carnegie Mellon University\n @brief Determine the disorientation angle between two orientations (in radians, single precision)\n @param eu1 first Euler triplet (in radians)\n @param eu2 first Euler triplet (in radians)\n @param dict dict structure\n @param Pmdims number of symmetry operators to consider\n @date 07/29/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=sgl), intent(in) :: eu1 (3) real(kind=sgl), intent(in) :: eu2 (3) type(dicttype), intent(inout) :: dict real(kind=sgl), intent(out) :: disang real(kind=dbl), intent(out), optional :: ax (3) public recursive subroutine getDisorientationAngleDouble (eu1, eu2, dict, disang, ax) @author Marc De Graef, Carnegie Mellon University\n @brief Determine the disorientation angle between two orientations (in radians)\n @param eu1 first Euler triplet (in radians)\n @param eu2 first Euler triplet (in radians)\n @param dict dict structure\n @param Pmdims number of symmetry operators to consider\n @date 07/29/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: eu1 (3) real(kind=dbl), intent(in) :: eu2 (3) type(dicttype), intent(in) :: dict real(kind=dbl), intent(out) :: disang real(kind=dbl), intent(out), optional :: ax (3) Functions private recursive function DI_RotateToMu (N, lmu, y) result(ymu) @author Marc De Graef, Carnegie Mellon University \n @brief Rotate an array of quaternions to an average direction lmu using the null space approach\n @param N number of samples to return\n @param seed random number generator seed value\n @param mu mean direction (unit quaternion)\n @param kappa concentration\n @date 02/05/15 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: N real(kind=dbl), intent(in) :: lmu (4) real(kind=dbl), intent(in) :: y (4,N) Return Value real(kind=dbl)\n  (4,N) private recursive function randUniformSphere (N, seed) result(ranSphere) @author Marc De Graef, Carnegie Mellon University / Yu-Hui Chen, U. Michigan\n @brief Return a set of random vectors on the sphere S&#94;2 using normal random sampling\n @param N number of samples to return\n @param seed random number generator seed value\n @date 01/07/15 MDG 1.0 original, based on Yu-Hui's Matlab code, output transposed Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: N integer(kind=irg), intent(inout) :: seed Return Value real(kind=dbl)\n  (3,N) public recursive function DI_SampleDD (N, seed, mu, kappa, Dtype) result(sDD) @author Marc De Graef, Carnegie Mellon University / Yu-Hui Chen, U. Michigan\n @brief Sample a directional distribution (VMF or WAT) on the quaternion unit sphere\n @param N number of samples to return\n @param seed random number generator seed value\n @param mu mean direction (unit quaternion)\n @param kappa concentration\n @param Dtype 'VMF' for von-Mises-Fisher  or 'WAT' for axial Watson\n @date 01/07/15 MDG 1.0 original, based on Yu-Hui's Matlab code Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: N integer(kind=irg), intent(inout) :: seed real(kind=dbl), intent(in) :: mu (4) real(kind=dbl), intent(in) :: kappa character(len=3), intent(in) :: Dtype Return Value real(kind=dbl)\n  (4,N) private recursive function randDDMarginal (N, k, seed, Dtype) result(t) @author Marc De Graef, Carnegie Mellon University / Yu-Hui Chen, U. Michigan\n @brief rejection sampling for the t parameter for the marginal directional distribution\n @details This algorithm samples the parameter t from a marginal distribution f(t), which\n by itself is the VMF or Watson distribution integrated around the mean direction.  These\n expressions were derived by Yu-Hui and verified by MDG [02/05/15] and then implemented;\n there are some typographical errors in the literature, and the versions documented here\n are correct [numerical verification].\n @param N number of samples to return\n @param k concentration\n @param seed random number generator seed value\n @param Dtype 'VMF' or 'WAT'\n @date 01/07/15 MDG 1.0 original, based on Yu-Hui's Matlab code\n @date 02/05/15 MDG 1.1 consolidated routines for VMF and WAT distributions Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: N real(kind=dbl), intent(in) :: k integer(kind=irg), intent(inout) :: seed character(len=3), intent(in) :: Dtype Return Value real(kind=dbl)\n  (N) private recursive function getDDDensityLBM (k, C, Dtype) result(LBM) @author Marc De Graef, Carnegie Mellon University / Yu-Hui Chen, U. Michigan\n @brief determines the left bound and maximum for rejection sampling\n @param k concentration\n @param C constant prefactor of distribution function\n @param Dtype 'VMF' or 'WAT'\n @date 01/07/15 MDG 1.0 original, based on Yu-Hui's Matlab code\n @date 02/05/15 MDG 1.1 consolidated routines for VMF and WAT distributions Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: k real(kind=dbl), intent(inout) :: C character(len=3), intent(in) :: Dtype Return Value real(kind=dbl)\n  (2) private recursive function VMFMeanDirDensity (x, k, C) result(y) @author Marc De Graef, Carnegie Mellon University / Yu-Hui Chen, U. Michigan\n @brief function to be sampled for VMF random sampling; we're using a close approximation\n @param x argument value\n @param k concentration\n @param C constant prefactor\n @date 01/07/15 MDG 1.0 original, based on Yu-Hui's Matlab code Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: x real(kind=dbl), intent(in) :: k real(kind=dbl), intent(inout) :: C Return Value real(kind=dbl) private recursive function WatsonMeanDirDensity (x, k, C) result(y) @author Marc De Graef, Carnegie Mellon University\n @brief function to be sampled for Watson random sampling; we're using a close approximation\n @param x argument value\n @param k concentration\n @param C constant prefactor\n @date 02/05/15 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: x real(kind=dbl), intent(in) :: k real(kind=dbl), intent(inout) :: C Return Value real(kind=dbl) private recursive function DD_Estep (X, dict, Pmdims, nums, Mu, Kappa, Dtype) result(R) @author Marc De Graef, Carnegie Mellon University / Yu-Hui Chen, U. Michigan\n @brief computes the E step of the EM process, verified against Matlab code on 01/02/15\n @param X list of input quaternions\n @param dict dictionary type\n @param Pmdims number of quaternion symmetry operators\n @param nums number of samples\n @param Mu current guess for mean quaternion\n @param Kappa input parameter\n @date 01/01/15 MDG 1.0 original\n @date 01/06/15 MDG 1.1 added optional argument full\n @date 01/09/15 MDG 1.2 removed optional argument full (incorporated in dicttype)\n @date 02/06/15 MDG 1.3 removed full handling after extensive checking\n @date 02/06/15 MDG 1.4 merged VMF and Watson Esteps into a single routine and renamed Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: X (4,nums) type(dicttype), intent(in) :: dict integer(kind=irg), intent(in) :: Pmdims integer(kind=irg), intent(in) :: nums real(kind=dbl), intent(in) :: Mu (4) real(kind=dbl), intent(in) :: Kappa character(len=3), intent(in) :: Dtype Return Value real(kind=dbl)\n  (nums,Pmdims) private recursive function DD_Mstep (X, dict, Pmdims, nums, R, Dtype) result(MuKa) @author Marc De Graef, Carnegie Mellon University / Yu-Hui Chen, U. Michigan\n @brief computes the M step of the EM process\n @param X list of input quaternions\n @param dict dictionary type\n @param Pmdims number of quaternion symmetry operators\n @param nums number of samples\n @param R weight factors form the E step\n @param Dtype 'VMF' or 'WAT'\n @date 01/01/15 MDG 1.0 original\n @date 01/06/15 MDG 1.1 added optional full parameter\n @date 01/09/15 MDG 1.2 removed optional argument full (incorporated in dicttype)\n @date 01/09/15 MDG 1.3 introduced accurate numerical approximation for kappa determination\n @date 02/06/15 MDG 1.4 removed full handling after extensive checking\n @date 02/06/15 MDG 1.5 merged Msteps for VMF and WAT and renamed Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: X (4,nums) type(dicttype), intent(in) :: dict integer(kind=irg), intent(in) :: Pmdims integer(kind=irg), intent(in) :: nums real(kind=dbl), intent(in) :: R (nums,Pmdims) character(len=3), intent(in) :: Dtype Return Value real(kind=dbl)\n  (5) public recursive function DD_Density (X, nums, mu, kappa, C, Dtype) result(y) @author Marc De Graef, Carnegie Mellon University / Yu-Hui Chen, U. Michigan\n @brief computes the VMF or Watson density function\n @details \n original in Matlab by Yu-Hui Chen, U. Michigan\n converted to IDL by MDG, 12/18/14, simplified arguments\n converted to f90 by MDG, 12/31/14, further simplifications\n output validated against Matlab output on 12/31/14\n @param X input quaternion samples\n @param nums number of samples\n @param mu mean direction\n @param kappa concentration\n @param C logCp(kappa) or exp(logCp(kappa) (precomputed in calling routine)\n @param Dtype 'VMF' or 'WAT'\n @date 01/01/15 MDG 1.0 original\n @date 01/06/15 MDG 1.1 added C and full parameters\n @date 02/06/15 MDG 1.2 removed full handling\n @date 02/06/15 MDG 1.3 merged 'VMF' and 'WAT' routines and renamed Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: X (4,nums) integer(kind=irg), intent(in) :: nums real(kind=dbl), intent(in) :: mu (4) real(kind=dbl), intent(in) :: kappa real(kind=dbl), intent(in) :: C character(len=3), intent(in) :: Dtype Return Value real(kind=dbl)\n  (nums) private recursive function logCp (kappa, Dtype) result(lCp) @author Marc De Graef, Carnegie Mellon University / Yu-Hui Chen, U. Michigan\n @brief computes the logarithm of Cp for VMF and Watson distributions\n @details \n original in Matlab by Yu-Hui Chen, U. Michigan\n converted to IDL by MDG, 12/18/14, simplified arguments\n converted to f90 by MDG, 12/31/14, further simplifications\n output validated against Matlab output on 12/31/14\n @param kappa input parameter\n @param Dtype 'VMF' or 'WAT'\n @date 12/31/14 MDG 1.0 original\n @date 01/09/14 MDG 1.1 introduced more accurate numerical approximation for Cp\n @date 01/09/14 MDG 1.2 moved some of the constants in front of the logarithm\n @date 02/06/15 MDG 1.3 merged VMF and WAT routines Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: kappa character(len=3), intent(in) :: Dtype Return Value real(kind=dbl) Subroutines public recursive subroutine DI_Init (dict, Dtype) @author Marc De Graef, Carnegie Mellon University / Yu-Hui Chen, U. Michigan\n @brief initialize the dictionary indexing parameters (symmetry operators and precomputed Ap lookup table)\n @details For all details, see following paper:\n @param dict dictionary parameter (must be declared in calling routine)\n @param Dtype  'VMF' or 'WAT' for von Mises-Fisher and Watson distributions, respectively.\n @date 12/31/14 MDG 1.0 original\n @date 01/06/15 MDG 1.1 added optional argument full\n @date 02/06/15 MDG 1.2 removed full again after extensive testing; no need to use 2M operators Arguments Type Intent Optional Attributes Name type(dicttype), intent(inout) :: dict character(len=3), intent(in) :: Dtype public recursive subroutine DI_EMforDD (X, dict, nums, seed, muhat, kappahat, Dtype) @author Yu-Hui Chen, U. Michigan / Marc De Graef, Carnegie Mellon University\n @brief Expectation maximization approach to maximum likelihood problem for mu and kappa\n @details For all details, see following paper:\n @param X list of input quaternions\n @param dict dictionary parameter (must be declared in calling routine)\n @param nums number of input quaternions\n @param seed for normal random number generator \n @param muhat output mean orientation\n @param kappahat output concentration parameter\n @param Dtype 'VMF' or 'WAT'\n @date 01/01/15 MDG 1.0 original, based on Chen's Matlab version + simplifications\n @date 01/06/15 MDG 1.1 added optional argument full\n @date 02/06/15 MDG 1.2 removed full again, added Dtype and streamlined code; removed duplications Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: X (4,nums) type(dicttype), intent(inout) :: dict integer(kind=irg), intent(in) :: nums integer(kind=irg), intent(inout) :: seed real(kind=dbl), intent(out) :: muhat (4) real(kind=dbl), intent(out) :: kappahat character(len=3), intent(in) :: Dtype private recursive subroutine DD_getQandL (X, dict, Pmdims, nums, MuKa, R, Q, L, Dtype) @author Yu-Hui Chen, U. Michigan / Marc De Graef, Carnegie Mellon University\n @brief Computes the Q array and the log-likelihood array\n @details For all details, see following paper:\n @param X list of input quaternions\n @param dict dictionary parameter (must be declared in calling routine)\n @param Pmdims number of quaternion symmetry operators to consider\n @param number of input quaternions\n @param MuKa  vector with Mu and Kappa\n @param R output from the E step\n @param Q output Q \n @param L output L \n @param Dtype 'VMF' or 'WAT'\n @date 01/01/15 MDG 1.0 original, based on Chen's Matlab version + simplifications\n @date 01.06/15 MDG 1.1 added optional full parameter\n @date 01/09/15 MDG 1.2 removed optional argument full (incorporated in dicttype)\n @date 02/06/15 MDG 1.3 removed full handling after extensive checking\n @date 02/06/15 MDG 1.4 merged VMF and WAT routines and renamed\n @date 12/05/16 MDG 1.5 intercepted case when Phi becomes zero for a VERY sharp texture... Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: X (4,nums) type(dicttype), intent(inout) :: dict integer(kind=irg), intent(in) :: Pmdims integer(kind=irg), intent(in) :: nums real(kind=dbl), intent(in) :: MuKa (5) real(kind=dbl), intent(in) :: R (nums,Pmdims) real(kind=dbl), intent(inout) :: Q real(kind=dbl), intent(inout) :: L character(len=3), intent(in) :: Dtype public recursive subroutine DI_Similarity_Classifier (array, k, npx, npy, returnarr) @author Saransh Singh, Carnegie Mellon University / Yu-Hui Chen, U. Michigan\n @brief classify the point as grain interior or anomalous point\n @details takes the kNN neighbor information as input and returns the \n @param array input array\n @param k number of top matches for each pixel\n @param npx number of pixels in the x direction\n @param npy number of pixels in the y direction\n @date 01/05/15 SS 1.0 original\n @date 01/06/15 MDG 1.1 simplified summation loop and renamed routine Arguments Type Intent Optional Attributes Name integer(kind=sgl), intent(in) :: array (npx,npy,k) integer(kind=irg), intent(in) :: k integer(kind=irg), intent(in) :: npx integer(kind=irg), intent(in) :: npy real(kind=sgl), intent(out) :: returnarr (npx,npy) private recursive subroutine CardIntersection (set1, set2, k, res) @author Saransh Singh, Carnegie Mellon University / Yu-Hui Chen, U. Michigan\n @brief calculate the cardinality of the intersection of two sets\n @param set1\n @param set2\n @param k number of elements in each set\n @date 01/05/15 SS 1.0 original\n @date MDG 1.1 changed types to integer Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: set1 (k) integer(kind=irg), intent(in) :: set2 (k) integer(kind=irg), intent(in) :: k integer(kind=irg), intent(out) :: res public recursive subroutine ReduceDisorientationtoMFZ (ro, cell, FZtype, FZorder, roMFZ) @author Marc De Graef, Carnegie Mellon University\n @brief Reduce a disorientation (Rodrigues) to the Mackenzie Fundamental Zone\n @details This requires the symmetry operations of the Rodrigues FZ, which \n includes mirrors and inversion symmetry, i.e., the regular (full) point group\n symmetry of the shape of the RFZ.  We already have those implemented in the \n regular symmetry module, and we assume that those symmetry matrices have been\n initialized and are present in the cell structure.  Then we just call the regular\n CalcStar routine to generate the equivalents and pick the one that is inside\n the MFZ.\n @param ro Rodrigues vector\n @param cell cell pointer\n @param FZtype Fundamental Zone type\n @param FZorder Fundamental Zone order\n @param euFZ Euler triplet in fundamental zone (in radians)\n @date 07/29/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: ro (4) type(unitcell), intent(in), pointer :: cell integer(kind=irg), intent(in) :: FZtype integer(kind=irg), intent(in) :: FZorder real(kind=dbl), intent(out) :: roMFZ (4) public recursive subroutine ReduceOrientationtoCubicEFZ (eu, dict, euFZ) @author Marc De Graef, Carnegie Mellon University\n @brief Reduce an orientation (Euler angles) to the cubic FZ in Euler space\n @param eu Euler triplet (in radians)\n @param dict dict structure\n @param euFZ Euler triplet in Euler fundamental zone (in radians)\n @date 07/29/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: eu (3) type(dicttype), intent(in) :: dict real(kind=dbl), intent(out) :: euFZ (3) public recursive subroutine ReduceOrientationtoRFZ (eu, dict, FZtype, FZorder, euFZ, MFZ) @author Marc De Graef, Carnegie Mellon University\n @brief Reduce an orientation (Euler angles) to the Rodrigues Fundamental Zone\n @param eu Euler triplet (in radians)\n @param dict dict structure\n @param FZtype Fundamental Zone type\n @param FZorder Fundamental Zone order\n @param euFZ Euler triplet in fundamental zone (in radians)\n @param MFZ (optonal) apply MacKenzie cell\n @date 07/29/16 MDG 1.0 original\n @date 03/27/17 MDG 1.1 added checking of MacKenzie cell Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: eu (3) type(dicttype), intent(in) :: dict integer(kind=irg), intent(in) :: FZtype integer(kind=irg), intent(in) :: FZorder real(kind=dbl), intent(out) :: euFZ (3) logical, intent(in), optional :: MFZ public recursive subroutine getDisorientationAngleDouble (eu1, eu2, dict, disang, ax) @author Marc De Graef, Carnegie Mellon University\n @brief Determine the disorientation angle between two orientations (in radians)\n @param eu1 first Euler triplet (in radians)\n @param eu2 first Euler triplet (in radians)\n @param dict dict structure\n @param Pmdims number of symmetry operators to consider\n @date 07/29/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: eu1 (3) real(kind=dbl), intent(in) :: eu2 (3) type(dicttype), intent(in) :: dict real(kind=dbl), intent(out) :: disang real(kind=dbl), intent(out), optional :: ax (3) public recursive subroutine getDisorientationAngleSingle (eu1, eu2, dict, disang, ax) @author Marc De Graef, Carnegie Mellon University\n @brief Determine the disorientation angle between two orientations (in radians, single precision)\n @param eu1 first Euler triplet (in radians)\n @param eu2 first Euler triplet (in radians)\n @param dict dict structure\n @param Pmdims number of symmetry operators to consider\n @date 07/29/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=sgl), intent(in) :: eu1 (3) real(kind=sgl), intent(in) :: eu2 (3) type(dicttype), intent(inout) :: dict real(kind=sgl), intent(out) :: disang real(kind=dbl), intent(out), optional :: ax (3) public recursive subroutine getDisorientationAngleAxis (eu1, eu2, dict, disax) @author Saransh Singh, Carnegie Mellon University\n @brief Determine the disorientation angle and axis between two orientations (in radians)\n @param eu1 first Euler triplet (in radians)\n @param eu2 first Euler triplet (in radians)\n @param dict dict structure\n @date 02/14/17 SS 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: eu1 (3) real(kind=dbl), intent(in) :: eu2 (3) type(dicttype), intent(in) :: dict real(kind=dbl), intent(out) :: disax (4) public recursive subroutine getDisorientationAngleAxisTwoPhases (eu1, eu2, dict1, dict2, disax) @author Saransh Singh, Carnegie Mellon University\n @brief Determine the disorientation angle and axis between two orientations (in radians)\n @param eu1 first Euler triplet (in radians)\n @param eu2 first Euler triplet (in radians)\n @param dict1 dict1 structure\n @param dict2 dict2 structure\n @param disax smallest rotation angle disorientation axis-angle pair\n @date 02/14/17 SS 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: eu1 (3) real(kind=dbl), intent(in) :: eu2 (3) type(dicttype), intent(in) :: dict1 type(dicttype), intent(in) :: dict2 real(kind=dbl), intent(out) :: disax (4)","tags":"","loc":"module/dictmod.html","title":"dictmod – Fortran Program"},{"text":"Uses: local module~~yshmodule~~UsesGraph module~yshmodule YSHModule local local local->module~yshmodule Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used By module~~yshmodule~~UsedByGraph module~yshmodule YSHModule proc~calcrlocal CalcRLocal module~yshmodule->proc~calcrlocal program~dispfield dispfield module~yshmodule->program~dispfield Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Variables YD Derived Types YDtype Functions YSHDisp Subroutines makeYSHdislocation read_YSH_dislocation_data Variables Type Visibility Attributes Name Initial type( YDtype ), public, allocatable :: YD (:) Derived Types type, public :: YDtype Components Type Visibility Attributes Name Initial real(kind=sgl), public :: burg (3) real(kind=sgl), public :: burgd (3) real(kind=sgl), public :: u (3) real(kind=sgl), public :: un (3) real(kind=sgl), public :: g (3) real(kind=sgl), public :: gn (3) real(kind=sgl), public :: id real(kind=sgl), public :: jd real(kind=sgl), public :: zu real(kind=sgl), public :: bs real(kind=sgl), public :: be real(kind=sgl), public :: bx real(kind=sgl), public :: beta real(kind=sgl), public :: alpha real(kind=sgl), public :: ca real(kind=sgl), public :: sa real(kind=sgl), public :: ta real(kind=sgl), public :: cota real(kind=sgl), public :: a_dc (3,3) real(kind=sgl), public :: a_id (3,3) real(kind=sgl), public :: a_di (3,3) real(kind=sgl), public :: top (3) real(kind=sgl), public :: bottom (3) real(kind=sgl), public :: sig Functions public recursive function YSHDisp (x, y, z, ii) Arguments Type Intent Optional Attributes Name real(kind=dbl) :: x real(kind=dbl) :: y real(kind=dbl) :: z integer(kind=irg) :: ii Return Value real(kind=dbl)\n  (3) Subroutines public recursive subroutine makeYSHdislocation (i, dinfo, L) Arguments Type Intent Optional Attributes Name integer(kind=irg) :: i integer(kind=irg) :: dinfo real(kind=sgl) :: L public recursive subroutine read_YSH_dislocation_data (dislYname, numYdisl, DF_npix, DF_npiy, DF_gf, L, dinfo) Arguments Type Intent Optional Attributes Name character(len=50) :: dislYname (3*maxdefects) integer(kind=irg) :: numYdisl integer(kind=irg) :: DF_npix integer(kind=irg) :: DF_npiy real(kind=sgl) :: DF_gf (3) real(kind=sgl) :: L integer(kind=irg) :: dinfo","tags":"","loc":"module/yshmodule.html","title":"YSHModule – Fortran Program"},{"text":"Uses: local module~~distortion~~UsesGraph module~distortion distortion local local local->module~distortion Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief \n Everything to do with distortion in electron microscopy\n @details this module takes care of distortions in electron microscopy modalities due to imperfect lenses\n @date 1/18/16 SS 1.0 original Used By module~~distortion~~UsedByGraph module~distortion distortion proc~getecpatterns getECPatterns module~distortion->proc~getecpatterns proc~ecpcalfun ECPcalfun module~distortion->proc~ecpcalfun proc~ebsdcalfun EBSDcalfun module~distortion->proc~ebsdcalfun proc~ebsd4calfun EBSD4calfun module~distortion->proc~ebsd4calfun Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Subroutines BarrelDistortion Subroutines public recursive subroutine BarrelDistortion (D, img, nnx, nny) @author Saransh Singh, Carnegie Mellon University\n @brief barrel distortion observed in TESCAN MIRA microscope\n @param D     complex distortion coefficient\n @param img   Input=undistorted image/output = distorted image\n @param nnx   size of image in x\n @param nny   size of image in y\n @date 06/24/14  SS 1.0 original\n @date 01/25/16 MDG 1.1 minor mods to make routine more efficient Arguments Type Intent Optional Attributes Name complex(kind=dbl), intent(in) :: D real(kind=sgl), intent(inout) :: img (nnx,nny) integer(kind=irg), intent(in) :: nnx integer(kind=irg), intent(in) :: nny","tags":"","loc":"module/distortion.html","title":"distortion – Fortran Program"},{"text":"Uses: local module~~eccimod~~UsesGraph module~eccimod ECCImod local local local->module~eccimod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief EMECCI helper routines\n @date 11/25/15 MDG 1.0 original C            DNANCHK(X) - tests REAL 8 value X against NaN\nC            INFCHK(X) - tests REAL 4 value X against INF\nC            DINFCHK(X) - test REAL*8 value X against INF Functions NANCHK Subroutines Calckvectorcone Calckvectortrace ECCICalcSgh Functions public recursive function NANCHK (X) Arguments Type Intent Optional Attributes Name real, intent(in) :: X Return Value logical Subroutines public recursive subroutine Calckvectorcone (cell, khead, k, ga, ktxy, ktrad, ktstep, numk) @author Marc De Graef, Carnegie Mellon University\n @brief compute a set of incident beam directions for single image ECCI mode\n @param cell unit cell pointer\n @param khead head of kvector linked list\n @param k incident wave vector (zone axis)\n @param ga principal g vector\n @param ktxy tangential components\n @param ktrad cone opening angle\n @param ktstep number of steps along cone radius\n @param numk resulting number of incident beam directions\n @date 11/29/01 MDG 1.0 original\n @date 12/05/13 MDG 2.0 adapted for ECCI simulations \n @date 12/01/15 MDG 2.1 simplification of input parameters Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(kvectorlist), pointer :: khead integer(kind=irg), intent(in) :: k (3) integer(kind=irg), intent(in) :: ga (3) real(kind=sgl), intent(in) :: ktxy (2) real(kind=sgl), intent(in) :: ktrad integer(kind=irg), intent(in) :: ktstep integer(kind=irg), intent(out) :: numk public recursive subroutine Calckvectortrace (cell, khead, k, ga, ktxy, ktxy2, ktrad, ktstep, numk) @author Marc De Graef, Carnegie Mellon University\n @brief compute a set of incident beam directions for line scan ECCI mode\n @param cell unit cell pointer\n @param khead head of k-vector list\n @param k incident wave vector (zone axis)\n @param ga principal g vector\n @param ktxy tangential components of trace start point\n @param ktxy2 tangential components of trace end point\n @param ktrad cone opening angle\n @param ktstep number of steps along cone radius\n @param numk resulting number of incident beam directions\n @date 12/08/13 MDG 1.0 original\n @date 12/01/15 MDG 1.1 simplifcation of input variables Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(kvectorlist), pointer :: khead integer(kind=irg), intent(in) :: k (3) integer(kind=irg), intent(in) :: ga (3) real(kind=sgl), intent(in) :: ktxy (2) real(kind=sgl), intent(in) :: ktxy2 (2) real(kind=sgl), intent(in) :: ktrad integer(kind=irg), intent(in) :: ktstep integer(kind=irg), intent(out) :: numk public recursive subroutine ECCICalcSgh (cell, nn, Sgh, nat) @author Marc De Graef, Carnegie Mellon University\n @brief compute structure factor-like array for ECCI and ECP simulations\n @param nn dimension of array\n @param Sgh output array\n @param nat normalization array\n @date 03/05/14  MDG 1.0 original (used to be in-line in ECP and ECCI programs)\n @date 03/11/14  MDG 1.1 converted to diagonal Sgh array only\n @date 10/22/14  MDG 1.2 corrected definition of Sgh and simplified loops; resolves issue #3 Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell integer(kind=irg), intent(in) :: nn complex(kind=dbl), intent(inout) :: Sgh (nn) integer(kind=irg), intent(inout) :: nat (100)","tags":"","loc":"module/eccimod.html","title":"ECCImod – Fortran Program"},{"text":"@author Marc De Graef, Carnegie Mellon University\n @brief routines that can be called by external code; all routines requiring HDF are in EMdymodHDF.f90\n @date  10/16/15 MDG 1.0 original\n @date  01/11/16 MDG 2.0 split into this file and EMdymodHDF.f90\n @date  01/12/16 MDG 2.1 added functionality for DREAM.3D progress callback and cancel option\n @date  01/13/16 MDG 2.2 name change of SingleEBSDPattern routine and split into two versions (C and other)\n @date  01/14/16 MDG 2.3 added EMsoftCgetECPatterns routine\n @date  01/25/16 MDG 2.4 several routine name changes\n @date  04/28/16 MDG 2.5 unified the ipar and fpar arrays for all C-callable routines Used By module~~emdymod~~UsedByGraph module~emdymod EMdymod module~simann SimAnn module~emdymod->module~simann Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Abstract Interfaces ProgressCallBack ProgressCallBack2 ProgressCallBack3 Functions getEBSDPatternsWrapper getECPatternsWrapper getKosselPatternsWrapper efitECPWrapper efitEBSDWrapper Subroutines EMsoftCgetEBSDPatterns EMsoftCgetECPatterns EMsoftCgetMCOpenCL EMsoftCgetEBSDmaster getEBSDPatterns getEBSDPatterns2 getECPatterns getKosselPatterns EBSD4calfun EBSDcalfun ECPcalfun Abstract Interfaces abstract interface public subroutine ProgressCallBack (objAddress, patternCompleted) Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in), VALUE :: objAddress integer(kind=4), intent(in), VALUE :: patternCompleted abstract interface public subroutine ProgressCallBack2 (objAddress, loopCompleted, totalLoops, bseYield) Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in), VALUE :: objAddress integer(kind=4), intent(in), VALUE :: loopCompleted integer(kind=4), intent(in), VALUE :: totalLoops real(kind=4), intent(in), VALUE :: bseYield abstract interface public subroutine ProgressCallBack3 (objAddress, loopCompleted, totalLoops, EloopCompleted, totalELoops) Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in), VALUE :: objAddress integer(kind=4), intent(in), VALUE :: loopCompleted integer(kind=4), intent(in), VALUE :: totalLoops integer(kind=4), intent(in), VALUE :: EloopCompleted integer(kind=4), intent(in), VALUE :: totalELoops Functions public recursive function getEBSDPatternsWrapper (argc, argv) bind(c, name='getEBSDPatternsWrapper') @author Marc De Graef, Carnegie Mellon University\n @brief wrapper routine for getEBSDPatterns Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in), VALUE :: argc type(c_ptr), intent(inout), dimension(argc) :: argv Return Value real(kind=c_float) public recursive function getECPatternsWrapper (argc, argv) bind(c, name='getECPatternsWrapper') @author Saransh Singh, Carnegie Mellon University\n @brief wrapper routine for SingleECPPattern; based on Marc's routine above Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in), VALUE :: argc type(c_ptr), intent(inout), dimension(argc) :: argv Return Value real(kind=c_float) public recursive function getKosselPatternsWrapper (argc, argv) bind(c, name='getKosselPatternsWrapper') @author Marc De Graef, Carnegie Mellon University\n @brief wrapper routine for SingleKosselPattern; nearly identical to ECP case Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in), VALUE :: argc type(c_ptr), intent(inout), dimension(argc) :: argv Return Value real(kind=c_float) public recursive function efitECPWrapper (argc, argv) bind(c, name='efitECPWrapper') @author Saransh Singh, Carnegie Mellon University\n @brief wrapper routine for fitting ECP pattern Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in), VALUE :: argc type(c_ptr), intent(inout), dimension(argc) :: argv Return Value real(kind=c_float) public recursive function efitEBSDWrapper (argc, argv) bind(c, name='efitEBSDWrapper') @author Saransh Singh, Carnegie Mellon University\n @brief wrapper routine for fitting EBSD pattern Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in), VALUE :: argc type(c_ptr), intent(inout), dimension(argc) :: argv Return Value real(kind=c_float) Subroutines public recursive subroutine EMsoftCgetEBSDPatterns (ipar, fpar, EBSDpattern, quats, accum_e, mLPNH, mLPSH, cproc, objAddress, cancel) bind(c, name=\"0\") @author Marc De Graef, Carnegie Mellon University\n @brief This subroutine can be called by a C/C++ program as a standalone function to compute EBSD patterns\n @details This subroutine provides a method to compute a series of EBSD patterns and\n can be called from an external C/C++ program; the routine provides a callback mechanism to\n update the calling program about computational progress, as well as a cancel option.\n The routine is intended to be called form a C/C++ program, e.g., DREAM.3D.  This routine is a simplified version\n of the core of the EMEBSD program. Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in) :: ipar (nipar) real(kind=sgl), intent(in) :: fpar (nfpar) real(kind=sgl), intent(out) :: EBSDpattern (ipar(23),ipar(24),ipar(21)) real(kind=sgl), intent(in) :: quats (nq,ipar(21)) integer(kind=c_int32_t), intent(in) :: accum_e (ipar(12),-ipar(1):ipar(1),-ipar(1):ipar(1)) real(kind=sgl), intent(in) :: mLPNH (-ipar(17):ipar(17),-ipar(17):ipar(17),ipar(12),ipar(9)) real(kind=sgl), intent(in) :: mLPSH (-ipar(17):ipar(17),-ipar(17):ipar(17),ipar(12),ipar(9)) type(C_FUNPTR), intent(in), VALUE :: cproc integer(kind=c_size_t), intent(in), VALUE :: objAddress character(len=1), intent(in) :: cancel public recursive subroutine EMsoftCgetECPatterns (ipar, fpar, ECpattern, quats, accum_e, mLPNH, mLPSH, cproc, objAddress, cancel) bind(c, name=\"0\") @author Saransh Singh/Marc De Graef, Carnegie Mellon University\n @brief This subroutine can be called by a C/C++ program as a standalone function to compute ECPs\n @details This subroutine provides a method to compute a series of ECPs and\n can be called from an external C/C++ program; the routine provides a callback mechanism to\n update the calling program about computational progress, as well as a cancel option.\n The routine is intended to be called form a C/C++ program, e.g., DREAM.3D.  This routine is a simplified version\n of the core of the EMECP program. Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in) :: ipar (nipar) real(kind=sgl), intent(in) :: fpar (nfpar) real(kind=sgl), intent(out) :: ECpattern (ipar(1),ipar(1),ipar(6)) real(kind=sgl), intent(in) :: quats (nq,ipar(6)) real(kind=sgl), intent(in) :: accum_e (ipar(2),-ipar(3):ipar(3),-ipar(3):ipar(3)) real(kind=sgl), intent(in) :: mLPNH (-ipar(5):ipar(5),-ipar(5):ipar(5),ipar(4)) real(kind=sgl), intent(in) :: mLPSH (-ipar(5):ipar(5),-ipar(5):ipar(5),ipar(4)) type(C_FUNPTR), intent(in), VALUE :: cproc integer(kind=c_size_t), intent(in), VALUE :: objAddress character(len=1), intent(in) :: cancel public recursive subroutine EMsoftCgetMCOpenCL (ipar, fpar, atompos, atomtypes, latparm, accum_e, accum_z, cproc, objAddress, cancel) bind(c, name=\"0\") @author Marc De Graef, Carnegie Mellon University\n @brief This subroutine can be called by a C/C++ program as a standalone routine to compute Monte Carlo data\n @details This subroutine provides a method to compute a Monte Carlo data set, normally computed\n with the EMMCOpenCL.f90 program.  The routine can be called from an external C/C++ program; \n the routine provides a callback mechanism to update the calling program about computational \n progress, as well as a cancel option. Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in) :: ipar (nipar) real(kind=sgl), intent(in) :: fpar (nfpar) real(kind=sgl), intent(in) :: atompos (ipar(9),5) integer(kind=irg), intent(in) :: atomtypes (ipar(9)) real(kind=sgl), intent(in) :: latparm (6) integer(kind=irg), intent(out) :: accum_e (ipar(12),-ipar(1):ipar(1),-ipar(1):ipar(1)) integer(kind=irg), intent(out) :: accum_z (ipar(12),ipar(13),-ipar(16):ipar(16),-ipar(16):ipar(16)) type(C_FUNPTR), intent(in), VALUE :: cproc integer(kind=c_size_t), intent(in), VALUE :: objAddress character(len=1), intent(in) :: cancel public recursive subroutine EMsoftCgetEBSDmaster (ipar, fpar, atompos, atomtypes, latparm, accum_z, mLPNH, mLPSH, cproc, objAddress, cancel) bind(c, name=\"0\") @author Marc De Graef, Carnegie Mellon University\n @brief This subroutine can be called by a C/C++ program as a standalone routine to compute EBSD master patterns\n @details This subroutine provides a method to compute an EBSD master pattern for the northern and southern\n hemispheres, i.e., it implements the EMEBSDmaster.f90 program.  The routine can be called from an external C/C++ program; \n the routine provides a callback mechanism to update the calling program about computational \n progress, as well as a cancel option. Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in) :: ipar (nipar) real(kind=sgl), intent(in) :: fpar (nfpar) real(kind=sgl), intent(in) :: atompos (ipar(9),5) integer(kind=irg), intent(in) :: atomtypes (ipar(9)) real(kind=sgl), intent(in) :: latparm (6) integer(kind=irg), intent(in) :: accum_z (ipar(12),ipar(13),-ipar(16):ipar(16),-ipar(16):ipar(16)) real(kind=sgl), intent(out) :: mLPNH (-ipar(17):ipar(17),-ipar(17):ipar(17),1:ipar(12),1:ipar(9)) real(kind=sgl), intent(out) :: mLPSH (-ipar(17):ipar(17),-ipar(17):ipar(17),1:ipar(12),1:ipar(9)) type(C_FUNPTR), intent(in), VALUE :: cproc integer(kind=c_size_t), intent(in), VALUE :: objAddress character(len=1), intent(in) :: cancel public recursive subroutine getEBSDPatterns (ipar, fpar, EBSDpattern, quats, accum_e, mLPNH, mLPSH) @author Marc De Graef, Carnegie Mellon University\n @brief This function can be called as a standalone function to compute an EBSD pattern\n @etails The main purpose of this routine and its accompanying wrapper routine is to\n provide a way for an external program to compute a channeling pattern.  The idea is that \n all the necessary arrays and variables are passed in by reference as arguments, without\n the need for the routine to fetch any other data from files etc...  The initial goal is\n to have a function that can be called with the CALL_EXTERNAL mechanism in IDL or MatLab.\n This routine should be called via the getEBSDPatternsWrapper routine!  For calls from\n a C/C++ program, use the EMsoftCgetEBSDPatterns routine instead.\n @param ipar array with integer input parameters\n @param fpar array with float input parameters\n @param EBSDpattern output array\n @param quats quaternion input array\n @param accum_e array with Monte Carlo histogram\n @param mLPNH Northern hemisphere master pattern\n @param mLPSH Southern hemisphere master pattern\n @date 10/16/15 MDG 1.0 original\n @date 11/02/15 MDG 1.1 simplification of the input variables\n @date 11/04/15 MDG 1.2 added array of quaternions as input parameter; used complete mLPNH/SH arrays with local sum\n @date 01/12/15 MDG 1.3 added arguments and functionality for interface with DREAM.3D and other calling programs\n @date 01/13/15 MDG 1.4 after split with EMsoftCgetEBSDPatterns subroutine, removed DREAM.3D interfacing stuff\n @date 07/10/16 MDG 1.5 added energy min/max parameters\n @date 08/03/16 MDG 1.6 corrected normalizing issue in rgx,y,z arrays that causes NANs to be returned from Lambert projection routines\n @date 08/R2516 MDG 1.7 added transfer optics barrel distortion to rgx,y,z arrays. Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in) :: ipar (nipar) real(kind=sgl), intent(in) :: fpar (nfpar) real(kind=sgl), intent(out) :: EBSDpattern (ipar(2),ipar(3),ipar(8)) real(kind=sgl), intent(in) :: quats (nq,ipar(8)) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(4),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(4),ipar(7)) public recursive subroutine getEBSDPatterns2 (ipar, fpar, EBSDpattern, quats, accum_e, mLPNHsum, mLPSHsum) @author Marc De Graef, Carnegie Mellon University\n @brief This function can be called as a standalone function to compute an EBSD pattern\n @etails The main purpose of this routine and its accompanying wrapper routine is to\n provide a way for an external program to compute a channeling pattern.  The idea is that \n all the necessary arrays and variables are passed in by reference as arguments, without\n the need for the routine to fetch any other data from files etc...  The initial goal is\n to have a function that can be called with the CALL_EXTERNAL mechanism in IDL or MatLab.\n This routine should be called via the getEBSDPatternsWrapper routine!  For calls from\n a C/C++ program, use the EMsoftCgetEBSDPatterns routine instead.  This routine is a slightly\n modified version of the regular getEBSDPatterns routine and does not SAVE any variables.\n @param ipar array with integer input parameters\n @param fpar array with float input parameters\n @param EBSDpattern output array\n @param quats quaternion input array\n @param accum_e array with Monte Carlo histogram\n @param mLPNH Northern hemisphere master pattern\n @param mLPSH Southern hemisphere master pattern\n @date 10/16/15 MDG 1.0 original\n @date 11/02/15 MDG 1.1 simplification of the input variables\n @date 11/04/15 MDG 1.2 added array of quaternions as input parameter; used complete mLPNH/SH arrays with local sum\n @date 01/12/15 MDG 1.3 added arguments and functionality for interface with DREAM.3D and other calling programs\n @date 01/13/15 MDG 1.4 after split with EMsoftCgetEBSDPatterns subroutine, removed DREAM.3D interfacing stuff\n @date 07/10/16 MDG 1.5 added energy min/max parameters\n @date 08/03/16 MDG 1.6 corrected normalizing issue in rgx,y,z arrays that causes NANs to be returned from Lambert projection routines\n @date 08/25/16 MDG 1.7 added transfer optics barrel distortion to rgx,y,z arrays.\n @date 04/24/17 MDG 1.8 forked from original routine without SAVEd variables Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in) :: ipar (nipar) real(kind=sgl), intent(in) :: fpar (nfpar) real(kind=sgl), intent(out) :: EBSDpattern (ipar(2),ipar(3),ipar(8)) real(kind=sgl), intent(in) :: quats (nq,ipar(8)) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNHsum (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(4)) real(kind=sgl), intent(in) :: mLPSHsum (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(4)) public recursive subroutine getECPatterns (ipar, fpar, ECpattern, quats, accum_e, mLPNH, mLPSH) @author Saransh Singh, Carnegie Mellon University\n @brief This function can be called as a standalone function to compute an electron channeling pattern\n based on Marc's code above\n @etails The main purpose of this routine and its accompanying wrapper routine is to\n provide a way for an external program to compute an EC pattern.  The idea is that \n all the necessary arrays and variables are passed in by reference as arguments, without\n the need for the routine to fetch any other data from files etc...  The initial goal is\n to have a function that can be called with the CALL_EXTERNAL mechanism in IDL, but \n in the long run this will also be the approach for calling the routine from C/C++, which\n is an essential part of integration with DREAM.3D.  This routine is a simplified version\n of the core of the EMECP program. Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in) :: ipar (nipar) real(kind=sgl), intent(in) :: fpar (nfpar) real(kind=sgl), intent(out) :: ECpattern (ipar(2),ipar(3),ipar(8)) real(kind=sgl), intent(in) :: quats (nq,ipar(8)) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(7):ipar(7),-ipar(7):ipar(7),ipar(6)) real(kind=sgl), intent(in) :: mLPSH (-ipar(7):ipar(7),-ipar(7):ipar(7),ipar(6)) public recursive subroutine getKosselPatterns (ipar, fpar, Kosselpattern, quats, mLPNH, mLPSH) @author Marc De Graef, Carnegie Mellon University\n @brief This function can be called as a standalone function to compute a Kossel pattern\n @etails The main purpose of this routine and its accompanying wrapper routine is to\n provide a way for an external program to compute a Kossel pattern.  The idea is that \n all the necessary arrays and variables are passed in by reference as arguments, without\n the need for the routine to fetch any other data from files etc...  The initial goal is\n to have a function that can be called with the CALL_EXTERNAL mechanism in IDL, but \n in the long run this will also be the approach for calling the routine from C/C++, which\n is an essential part of integration with DREAM.3D. Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(in) :: ipar (nipar) real(kind=sgl), intent(in) :: fpar (nfpar) real(kind=sgl), intent(out) :: Kosselpattern (ipar(2),ipar(2),ipar(4)) real(kind=sgl), intent(in) :: quats (nq,ipar(4)) real(kind=sgl), intent(in) :: mLPNH (-ipar(3):ipar(3),-ipar(3):ipar(3),ipar(5)) real(kind=sgl), intent(in) :: mLPSH (-ipar(3):ipar(3),-ipar(3):ipar(3),ipar(5)) public recursive subroutine EBSD4calfun (nipar, nfpar, ninit, ipar, fpar, initmeanval, expt, accum_e, mLPNH, mLPSH, n, x, f, expt2, expt3, expt4, nstep, stepsize, verbose) @author Saransh Singh, Carnegie Mellon University\n @brief This function is used by bobyqa to fit an EBSD pattern\n @details The main purpose of this routine is to calculte the difference of 1 with the dot\n product of an experimental pattern with the given set of detector parameters. This is used\n by bobyqa module to fit an EBSD pattern when 4 patterns are fitted simultaneously Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar integer(kind=irg), intent(in) :: ninit integer(kind=c_size_t), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fpar (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) real(kind=c_float), intent(in) :: expt (ipar(2)*ipar(3)/ipar(12)/ipar(12)) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) integer(kind=irg), intent(in) :: n real(kind=dbl), intent(in), dimension(:) :: x real(kind=dbl), intent(out) :: f real(kind=c_float), intent(in) :: expt2 (ipar(2)*ipar(3)/ipar(12)/ipar(12)) real(kind=c_float), intent(in) :: expt3 (ipar(2)*ipar(3)/ipar(12)/ipar(12)) real(kind=c_float), intent(in) :: expt4 (ipar(2)*ipar(3)/ipar(12)/ipar(12)) integer(kind=irg), intent(in) :: nstep real(kind=sgl), intent(in) :: stepsize (nstep) logical, intent(in), optional :: verbose public recursive subroutine EBSDcalfun (nipar, nfpar, ninit, ipar, fpar, initmeanval, expt, accum_e, mLPNH, mLPSH, n, x, f, nstep, stepsize, verbose) @author Saransh Singh, Carnegie Mellon University\n @brief This function is used by bobyqa to fit an EBSD pattern\n @details The main purpose of this routine is to calculte the difference of 1 with the dot\n product of an experimental pattern with the given set of detector parameters. This is used\n by bobyqa module to fit an EBSD pattern. Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar integer(kind=irg), intent(in) :: ninit integer(kind=c_size_t), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fpar (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) real(kind=c_float), intent(in) :: expt (ipar(2)*ipar(3)/ipar(12)**2) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) integer(kind=irg), intent(in) :: n real(kind=dbl), intent(in), dimension(:) :: x real(kind=dbl), intent(out) :: f integer(kind=irg), intent(in) :: nstep real(kind=sgl), intent(in) :: stepsize (nstep) logical, intent(in), optional :: verbose public recursive subroutine ECPcalfun (nipar, nfpar, ninit, ipar, fpar, initmeanval, expt, accum_e, mLPNH, mLPSH, n, x, f, nstep, stepsize, verbose) @author Saransh Singh, Carnegie Mellon University\n @brief This function is used by bobyqa to fit an EBSD pattern\n @etails The main purpose of this routine is to calculte the difference of 1 with the dot\n product of an experimental pattern with the given set of detector parameters. This is used\n by bobyqa module to fit an EBSD pattern. Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar integer(kind=irg), intent(in) :: ninit integer(kind=c_size_t), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fpar (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) real(kind=c_float), intent(in) :: expt (ipar(2)*ipar(3)/ipar(12)**2) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) integer(kind=irg), intent(in) :: n real(kind=dbl), intent(in), dimension(:) :: x real(kind=dbl), intent(out) :: f integer(kind=irg), intent(in) :: nstep real(kind=sgl), intent(in) :: stepsize (nstep) logical, intent(in), optional :: verbose","tags":"","loc":"module/emdymod.html","title":"EMdymod – Fortran Program"},{"text":"Uses: local module~~filters~~UsesGraph module~filters filters local local local->module~filters Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief various useful filters\n @date 01/21/16 MDG 1.0 original\n @date 02/02/16 MDG 1.1 added Hough Transform Used By module~~filters~~UsedByGraph module~filters filters proc~ebsd4calfun EBSD4calfun module~filters->proc~ebsd4calfun proc~ecpcalfun ECPcalfun module~filters->proc~ecpcalfun proc~ebsdcalfun EBSDcalfun module~filters->proc~ebsdcalfun Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Functions image_histogram image_jointhistogram cumul_histogram image_entropy image_jointentropy image_mutualinformation adhisteq HiPassFilter Subroutines CalcHoughLUT HoughTransform ButterflyMask9x9 InversionDivision Functions public recursive function image_histogram (nx, ny, im) result(h) @author Marc De Graef, Carnegie Mellon University\n @brief  compute the histogram of an image \n @param nx x dimension\n @param ny y dimension\n @param im image array; must have values in range [1..256]\n @date 01/23/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nx integer(kind=irg), intent(in) :: ny integer(kind=irg), intent(in) :: im (nx,ny) Return Value integer(kind=irg)\n  (256) public recursive function image_jointhistogram (nx, ny, im1, im2) result(h) @author Marc De Graef, Carnegie Mellon University\n @brief  compute the joint histogram of two images \n @param nx x dimension\n @param ny y dimension\n @param im1 image array; must have values in range [1..256]\n @param im2 image array; must have values in range [1..256]\n @date 04/23/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nx integer(kind=irg), intent(in) :: ny integer(kind=irg), intent(in) :: im1 (nx,ny) integer(kind=irg), intent(in) :: im2 (nx,ny) Return Value integer(kind=irg)\n  (256,256) public recursive function cumul_histogram (nx, ny, im) result(h) @author Marc De Graef, Carnegie Mellon University\n @brief  compute the cumulative histogram of an image \n @param nx x dimension\n @param ny y dimension\n @param im image array; must have values in range [1..256]\n @date 01/23/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nx integer(kind=irg), intent(in) :: ny integer(kind=irg), intent(in) :: im (nx,ny) Return Value integer(kind=irg)\n  (256) public recursive function image_entropy (h) result(e) @author Marc De Graef, Carnegie Mellon University\n @brief  compute the Shannon entropy of an image \n @param h a 256 element intensity histogram\n @date 04/23/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: h (256) Return Value real(kind=sgl) public recursive function image_jointentropy (h) result(e) @author Marc De Graef, Carnegie Mellon University\n @brief  compute the Shannon joint entropy of two images \n @param h a 256x256 element intensity joint histogram\n @date 04/23/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: h (256,256) Return Value real(kind=sgl) public recursive function image_mutualinformation (nx, ny, im1, im2) result(mi) @author Marc De Graef, Carnegie Mellon University\n @brief  compute the mutual information of two images \n @param nx x dimension\n @param ny y dimension\n @param im image array; must have values in range [1..256] \n @date 04/23/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nx integer(kind=irg), intent(in) :: ny integer(kind=irg), intent(in) :: im1 (nx,ny) integer(kind=irg), intent(in) :: im2 (nx,ny) Return Value real(kind=sgl) public recursive function adhisteq (nr, dimx, dimy, im, verbose) result(output) @author Marc De Graef, Carnegie Mellon University\n @brief  adaptive histogram equalization\n @details This algorithm is based on the original paper by Pizer et al., \n \"Adaptive Histogram Equalization and its Variations\", Computer Vision, \n Graphics, and Image Processing, 39:355-368, 1987. @param nr number of subregions to split the image into [10 works well]\n @param dimx x dimension\n @param dimy y dimension\n @param im image array; must have integer values in range [0..255]\n @date 01/23/16 MDG 1.0 original\n @date 01/27/16 MDG 1.1 correction of off-by-one error in final array copy Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nr integer(kind=irg), intent(in) :: dimx integer(kind=irg), intent(in) :: dimy integer(kind=irg), intent(in) :: im (dimx,dimy) logical, intent(in), optional :: verbose Return Value integer(kind=irg)\n  (dimx,dimy) public recursive function HiPassFilter (rdata, dims, w, init, destroy) result(fdata) @author Marc De Graef, Carnegie Mellon University\n @brief  Perform a high pass filter\n @param rdata real data to be transformed\n @param dims dimensions of rdata array\n @param w width of Gaussian profile\n @param init (optional) initialize without computing anything\n @param destroy (optional) destroy fft plans\n @date 02/02/16 MDG 1.0 original\n @date 06/03/16 MDG 1.1 modified mask to inverted Gaussian profile; added init optional parameter Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: rdata (dims(1),dims(2)) integer(kind=irg), intent(in) :: dims (2) real(kind=dbl), intent(in) :: w logical, intent(in), optional :: init logical, intent(in), optional :: destroy Return Value real(kind=dbl)\n  (dims(1),dims(2)) Subroutines public recursive subroutine CalcHoughLUT (dimx, LUT) @author Marc De Graef, Carnegie Mellon University\n @brief  create a look-up table for a square Hough transform\n @param dimx x dimension\n @param LUT look-up table, allocated in calling program\n @date 02/02/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dimx real(kind=sgl), intent(out) :: LUT (dimx*dimx,dimx) public recursive subroutine HoughTransform (dimx, LUT, im, HT) @author Marc De Graef, Carnegie Mellon University\n @brief  Perform a square Hough transform\n @param dimx x dimension\n @param LUT look-up table from CalcHoughLUT\n @param im image array (must be mean-subtracted)\n @param HT resulting Hough transform array\n @date 02/02/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dimx real(kind=sgl), intent(in) :: LUT (dimx*dimx,dimx) real(kind=sgl), intent(in) :: im (dimx*dimx) real(kind=sgl), intent(out) :: HT (dimx,dimx) public recursive subroutine ButterflyMask9x9 (input, output, dims) @author Saransh Singh, Carnegie Mellon University\n @brief apply 9x9 butterfly mask to the hough image\n @param input input image\n @param output output image\n @param dims dimension of these images\n @date 12/06/16 SS 1.0 original Arguments Type Intent Optional Attributes Name real(kind=sgl), intent(in) :: input (dims,dims) real(kind=sgl), intent(out) :: output (dims,dims) integer(kind=irg), intent(in) :: dims public recursive subroutine InversionDivision (input, output, dims) @author Saransh Singh, Carnegie Mellon University\n @brief Inversion division operation to enhance contrast of hough image \n @param input input image; must be between 0-1\n @param output output image\n @param dims dimension of these image\n @date 12/06/16 SS 1.0 original Arguments Type Intent Optional Attributes Name real(kind=sgl), intent(in) :: input (dims,dims) real(kind=sgl), intent(out) :: output (dims,dims) integer(kind=irg), intent(in) :: dims","tags":"","loc":"module/filters.html","title":"filters – Fortran Program"},{"text":"Uses: local NameListTypedefs module~~indexingmod~~UsesGraph module~indexingmod Indexingmod local local local->module~indexingmod module~namelisttypedefs NameListTypedefs local->module~namelisttypedefs module~namelisttypedefs->module~indexingmod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief everything to do with indexing and such\n @date 11/17/15 SS 1.0 original Used By module~~indexingmod~~UsedByGraph module~indexingmod Indexingmod proc~ebsd4calfun EBSD4calfun module~indexingmod->proc~ebsd4calfun proc~ecpcalfun ECPcalfun module~indexingmod->proc~ecpcalfun proc~ebsdcalfun EBSDcalfun module~indexingmod->proc~ebsdcalfun Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Functions Jaccard_Distance Subroutines InnerProdGPU Functions public recursive function Jaccard_Distance (img1, img2, nn) result(JD) Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: img1 (nn) integer(kind=irg), intent(in) :: img2 (nn) integer(kind=irg), intent(in) :: nn Return Value real(kind=dbl) Subroutines public recursive subroutine InnerProdGPU (cl_expt, cl_dict, Ne, Nd, correctsize, results, numd, selnumd, csource, source_length, platform, device, context, command_queue) @author Saransh Singh, Carnegie Mellon University\n @brief Perform the inner product computations for the dictionary approach\n @param expt vector with list of observed patterns\n @param dict vector with list of calculated patterns\n @param Ne number of patterns in the expt vector\n @param Nd number of patterns in the dict vector\n @param L size of one single pattern\n @param result result of the matrix multiplication\n @param source the opencl kernel as a character array\n @param length of character array\n @param platform opencl platform type\n @param device opencl device type\n @param context opencl context type\n @param command_queue opencl command queue\n @date 12/09/14  SS 1.0 original\n @date 27/01/15  SS 1.1 modified to call the subroutine from mastersubroutine\n @date 02/24/16 MDG 1.2 converted OpenCL calls to clfortran from fortrancl\n @date 03/03/16 MDG 1.3 added C_NULL_CHAR to kernelname\n @date 06/07/17 MDG 1.4 removed progoptions from Build Program call; caused some issues on Linux in Release mode Arguments Type Intent Optional Attributes Name integer(kind=c_intptr_t), intent(inout), target :: cl_expt integer(kind=c_intptr_t), intent(inout), target :: cl_dict integer(kind=4), intent(in) :: Ne integer(kind=4), intent(in) :: Nd integer(kind=4), intent(in) :: correctsize real(kind=4), intent(out), target :: results (Ne*Nd) integer(kind=irg), intent(in) :: numd integer(kind=irg), intent(in) :: selnumd character(kind=len=source_length,c_char), intent(in), TARGET :: csource integer(kind=c_size_t), intent(in), target :: source_length integer(kind=c_intptr_t), intent(in), allocatable, target :: platform (:) integer(kind=c_intptr_t), intent(inout), allocatable, target :: device (:) integer(kind=c_intptr_t), intent(inout), target :: context integer(kind=c_intptr_t), intent(inout), target :: command_queue","tags":"","loc":"module/indexingmod.html","title":"Indexingmod – Fortran Program"},{"text":"@author Marc De Graef, Carnegie Mellon University\n @brief several basic initialization routines\n @date 01/10/14 MDG 1.0 new version\n @date 01/11/15 MDG 2.0 split file into routines without and with HDF stuff Used By module~~initializers~~UsedByGraph module~initializers initializers proc~emsoftcgetebsdmaster EMsoftCgetEBSDmaster module~initializers->proc~emsoftcgetebsdmaster Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Interfaces Initialize_ReflectionList Subroutines Initialize_ReflectionList Initialize_ReflectionList_EwaldSweep Interfaces public interface Initialize_ReflectionList public interface Initialize_ReflectionList () Arguments None public recursive subroutine Initialize_ReflectionList_EwaldSweep (cell, listroot, FN, k, nref, pedangle, goffset, verbose) @author Marc De Graef, Carnegie Mellon University\n @brief initialize the potential reflection list for a given precession electron diffraction geometry\n @param cell unit cell pointer\n @param listroot main pointer for reflection linked list (typically reflist in calling routine)\n @param FN  foil normal\n @param k zone axis direction cosines in direct Bravais lattice\n @param nref number of reflections in main list (used to be DynNbeams)\n @param pedangle precession cone angle in mrad\n @param goffset offset parameter for reflections to be included outside the Ewald sphere precession volume\n @param verbose (optional) used for debugging purposes mostly\n @date 01/10/14 MDG 1.0 original, based on old Compute_ReflectionList\n @date 01/13/14 MDG 1.1 update for new cell type definition and new Bethe potential criterion\n @date 06/15/14 MDG 2.0 update for removal of all globals\n @date 06/16/14 MDG 2.1 added recursive\n @date 06/23/14 MDG 2.2 replaced Dyn structure by FN\n @date 11/30/14 MDG 3.0 forked from original to accommodate PED case Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(reflisttype), pointer :: listroot real(kind=sgl), intent(in) :: FN (3) real(kind=sgl), intent(in) :: k (3) integer(kind=irg), intent(inout) :: nref real(kind=sgl), intent(in) :: pedangle real(kind=sgl), intent(in) :: goffset logical, intent(in), optional :: verbose Subroutines public recursive subroutine Initialize_ReflectionList (cell, listroot, BetheParameter, FN, k, dmin, nref, verbose) @author Marc De Graef, Carnegie Mellon University\n @brief initialize the potential reflection list for a given wave vector\n @param cell unit cell pointer\n @param BetheParameter Bethe potential structure\n @param FN  foil normal\n @param k zone axis direction cosines in direct Bravais lattice\n @param dmin smallest lattice d-spacing to consider\n @param listroot pointer to top of list (could be cell%reflist)\n @param nref number of reflections in main list (used to be DynNbeams)\n @param verbose (optional) used for debugging purposes mostly\n @date 01/10/14 MDG 1.0 original, based on old Compute_ReflectionList\n @date 01/13/14 MDG 1.1 update for new cell type definition and new Bethe potential criterion\n @date 06/15/14 MDG 2.0 update for removal of all globals\n @date 06/16/14 MDG 2.1 added recursive\n @date 06/23/14 MDG 2.2 replaced Dyn structure by FN Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(reflisttype), pointer :: listroot type(BetheParameterType), intent(inout) :: BetheParameter real(kind=sgl), intent(in) :: FN (3) real(kind=sgl), intent(in) :: k (3) real(kind=sgl), intent(in) :: dmin integer(kind=irg), intent(inout) :: nref logical, intent(in), optional :: verbose public recursive subroutine Initialize_ReflectionList_EwaldSweep (cell, listroot, FN, k, nref, pedangle, goffset, verbose) @author Marc De Graef, Carnegie Mellon University\n @brief initialize the potential reflection list for a given precession electron diffraction geometry\n @param cell unit cell pointer\n @param listroot main pointer for reflection linked list (typically reflist in calling routine)\n @param FN  foil normal\n @param k zone axis direction cosines in direct Bravais lattice\n @param nref number of reflections in main list (used to be DynNbeams)\n @param pedangle precession cone angle in mrad\n @param goffset offset parameter for reflections to be included outside the Ewald sphere precession volume\n @param verbose (optional) used for debugging purposes mostly\n @date 01/10/14 MDG 1.0 original, based on old Compute_ReflectionList\n @date 01/13/14 MDG 1.1 update for new cell type definition and new Bethe potential criterion\n @date 06/15/14 MDG 2.0 update for removal of all globals\n @date 06/16/14 MDG 2.1 added recursive\n @date 06/23/14 MDG 2.2 replaced Dyn structure by FN\n @date 11/30/14 MDG 3.0 forked from original to accommodate PED case Arguments Type Intent Optional Attributes Name type(unitcell), pointer :: cell type(reflisttype), pointer :: listroot real(kind=sgl), intent(in) :: FN (3) real(kind=sgl), intent(in) :: k (3) integer(kind=irg), intent(inout) :: nref real(kind=sgl), intent(in) :: pedangle real(kind=sgl), intent(in) :: goffset logical, intent(in), optional :: verbose","tags":"","loc":"module/initializers.html","title":"initializers – Fortran Program"},{"text":"Uses: local typedefs iso_fortran_env NameListTypedefs json_module module~~jsonsupport~~UsesGraph module~jsonsupport JSONsupport json_module json_module json_module->module~jsonsupport typedefs typedefs typedefs->module~jsonsupport local local local->module~jsonsupport module~namelisttypedefs NameListTypedefs local->module~namelisttypedefs module~namelisttypedefs->module~jsonsupport iso_fortran_env iso_fortran_env iso_fortran_env->module~jsonsupport Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief routines for conversion between json and nml files and reading of json files\n @date  08/11/15 MDG 1.0 original\n @date  08/12/15 MDG 1.1 added all routines currently also in NameListHDFwriters.f90\n @date  08/12/15 MDG 1.2 replaced all the json_failed stuff by short routine JSON_failtest\n @date  11/20/15 MDG 1.3 started defect file format Used By module~~jsonsupport~~UsedByGraph module~jsonsupport JSONsupport proc~initializedefects InitializeDefects module~jsonsupport->proc~initializedefects Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Functions JSON_minify JSONgetDouble JSONgetDoubleVector Subroutines JSON_failtest JSON_writeNMLintegers JSON_writeNMLreals JSON_writeNMLdoubles JSON_initpointers JSON_cleanuppointers JSONwriteKosselNameList JSONwriteKosselMasterNameList JSONwriteMCNameList JSONwriteMCCLNameList JSONwriteMCCLMultiLayerNameList JSONwriteEBSDMasterNameList JSONwriteEBSDclusterNameList JSONwriteECPMasterNameList JSONwriteEBSDNameList JSONwriteECPNameList JSONwriteLACBEDNameList JSONwriteECPpatternNameList JSONwritePEDkinNameList JSONwritePEDZANameList JSONwriteECCINameList JSONwriteRFZNameList JSONwriteDictIndxOpenCLNameList JSONreadInteger JSONreadIntegerVec JSONreadReal JSONreadRealVec JSONreadDouble JSONreadDoubleVec JSONreadString JSONreadLogical JSONreadFoilData JSONreadDefectFile JSONreadKosselNameList JSONreadKosselMasterNameList JSONreadreflectorNameList JSONreadMCNameList JSONreadMCCLNameList JSONreadMCCLMultiLayerNameList JSONreadEBSDMasterNameList JSONreadEBSDclusterNameList JSONreadECPMasterNameList JSONreadEBSDNameList JSONreadEBSDoverlapNameList Functions public recursive function JSON_minify (jsonname) result(jsonreturn) @author Marc De Graef, Carnegie Mellon University\n @brief remove all fortran comment lines from a JSON input file and store file in tmp folder\n @param jsonname json file name\n @param jsonreturn filename of stripped down JSON input file (in EMsoft tmp folder)\n @date 05/11/17  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: jsonname Return Value character(len=fnlen) public recursive function JSONgetDouble (child, str, v) result(oval) @author Marc De Graef, Carnegie Mellon University\n @brief get vector from a json_value\n @param child json_value structure\n @param str text with variable name\n @param v verbose if 1\n @date 11/21/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(json_value), intent(in), pointer :: child character(len=fnlen) :: str integer(kind=irg), intent(in) :: v Return Value real(kind=dbl) public recursive function JSONgetDoubleVector (child, nc, str, v) result(ovec) @author Marc De Graef, Carnegie Mellon University\n @brief get vector from a json_value\n @param child json_value structure\n @param nc number of items to read\n @param str text with variable name\n @param v verbose if 1\n @date 11/21/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(json_value), intent(in), pointer :: child integer(kind=irg), intent(in) :: nc character(len=fnlen) :: str integer(kind=irg), intent(in) :: v Return Value real(kind=dbl)\n  (nc) Subroutines public recursive subroutine JSON_failtest (error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief executes the json_fail routine; mostly to shorten the remaining code a little\n @param error_cnt error counter\n @date 08/12/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSON_writeNMLintegers (inp, io_int, intlist, n_int, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief write a series of integer namelist entries to a json structure \n @param inp json structure pointer\n @param io_int list of integers\n @param intlist list of string descriptors\n @param n_int number of entries\n @param error_cnt error counter\n @date 08/11/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(json_value), intent(inout), pointer :: inp integer(kind=irg), intent(in) :: io_int (n_int) character(len=20), intent(in) :: intlist (n_int) integer(kind=irg), intent(in) :: n_int integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSON_writeNMLreals (inp, io_real, reallist, n_real, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief write a series of real namelist entries to a json structure\n @param inp pointer to json_value \n @param io_real list of reals\n @param reallist list of string descriptors\n @param n_real number of entries\n @param error_cnt error counter\n @date 08/11/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(json_value), intent(inout), pointer :: inp real(kind=sgl), intent(in) :: io_real (n_real) character(len=20), intent(in) :: reallist (n_real) integer(kind=irg), intent(in) :: n_real integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSON_writeNMLdoubles (inp, io_real, reallist, n_real, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief write a series of double namelist entries to a json structure\n @param inp pointer to json_value \n @param io_real list ofadoubles \n @param reallist list of string descriptors\n @param n_real number of entries\n @param error_cnt error counter\n @date 08/11/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(json_value), intent(inout), pointer :: inp real(kind=dbl), intent(in) :: io_real (n_real) character(len=20), intent(in) :: reallist (n_real) integer(kind=irg), intent(in) :: n_real integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSON_initpointers (p, inp, jsonname, namelistname, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief initialize the necessary pointers to write a namelist json file\n @param inp pointer to json_value \n @param io_real list of reals\n @param reallist list of string descriptors\n @param n_real number of entries\n @param error_cnt error counter\n @date 08/11/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(json_value), intent(inout), pointer :: p type(json_value), intent(inout), pointer :: inp character(len=fnlen), intent(in) :: jsonname character(len=fnlen), intent(in) :: namelistname integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSON_cleanuppointers (p, inp, jsonname, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief clean up the pointers and write the json file\n @param p pointer to json_value \n @param inp pointer to json_value \n @param jsonname json output file name\n @param error_cnt error counter\n @date 08/11/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(json_value), intent(inout), pointer :: p type(json_value), intent(inout), pointer :: inp character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSONwriteKosselNameList (knl, jsonname, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief write namelist file into json file\n @param knl Kossel name list structure\n @date 08/11/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(KosselNameListType), intent(in) :: knl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSONwriteKosselMasterNameList (knl, jsonname, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief write namelist file into json file\n @param knl Kossel name list structure\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/11/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(KosselMasterNameListType), intent(in) :: knl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSONwriteMCNameList (mcnl, jsonname, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief write namelist file into JSON file\n @param mcnl Monte Carlo name list structure\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/11/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(MCNameListType), intent(inout) :: mcnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSONwriteMCCLNameList (mcnl, jsonname, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief write namelist to JSON file\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @param mcnl Monte Carlo name list structure\n @date 03/21/15 MDG 1.0 new routine\n @date 09/09/15 MDG 1.1 added devid\n @date 10/12/15 SS  1.2 changes to handle new mc program Arguments Type Intent Optional Attributes Name type(MCCLNameListType), intent(inout) :: mcnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSONwriteMCCLMultiLayerNameList (mcnl, jsonname, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief write namelist to JSON file\n @param mcnl Monte Carlo name list structure\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/11/15 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(MCCLMultiLayerNameListType), intent(inout) :: mcnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSONwriteEBSDMasterNameList (emnl, jsonname, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief write namelist to JSON file\n @param emnl EBSD master name list structure\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/12/15 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(EBSDMasterNameListType), intent(inout) :: emnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSONwriteEBSDclusterNameList (emnl, jsonname, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief write namelist to JSON file\n @param emnl EBSD cluster name list structure\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @date 12/28/15 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(EBSDclusterNameListType), intent(inout) :: emnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSONwriteECPMasterNameList (ecpnl, jsonname, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief write namelist to JSON file\n @param ecpnl ECP master name list structure\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/12/15 MDG 1.0 new routine\n @date 09/15/15 SS  1.1 changes after clean up of ECPmasterListType Arguments Type Intent Optional Attributes Name type(ECPMasterNameListType), intent(inout) :: ecpnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSONwriteEBSDNameList (enl, jsonname, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief write namelist to JSON file\n @param enl EBSD name list structure\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/12/15 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(EBSDNameListType), intent(inout) :: enl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSONwriteECPNameList (ecpnl, jsonname, error_cnt, twolayerflag) @author Marc De Graef, Carnegie Mellon University\n @brief write namelist to JSON file\n @param ecpnl ECP namelist structure\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/12/15 MDG 1.0 new routine\n @date 09/15/15 SS  1.1 changes after modification of ECPListType\n @date 10/15/15 SS  1.2 changes for release Arguments Type Intent Optional Attributes Name type(ECPNameListType), intent(inout) :: ecpnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt logical, intent(in) :: twolayerflag public recursive subroutine JSONwriteLACBEDNameList (lacbednl, jsonname, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief write namelist to JSON file\n @param lacbednl LACBED name list structure\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/12/15 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(LACBEDNameListType), intent(inout) :: lacbednl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSONwriteECPpatternNameList (ecpnl, jsonname, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief write namelist into JSON file\n @param ecpnl ECP name list structure\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/12/15 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(ECPpatternNameListType), intent(inout) :: ecpnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSONwritePEDkinNameList (pednl, jsonname, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief write namelist to JSON file\n @param pednl PED name list structure\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/12/15 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(PEDkinNameListType), intent(inout) :: pednl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSONwritePEDZANameList (pednl, jsonname, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief write namelist to JSON file\n @param pednl PED name list structure\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/12/15 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(PEDZANameListType), intent(inout) :: pednl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSONwriteECCINameList (eccinl, jsonname, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief write namelist to JSON file\n @param eccinl ECCI name list structure\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/12/15 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(ECCINameListType), intent(inout) :: eccinl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSONwriteRFZNameList (rfznl, jsonname, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief write namelist to an JSON file\n @param rfznl RFZ name list structure\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/12/15 MDG 1.0 new routine\n @date 08/18/15 MDG 1.1 added other rotation representations Arguments Type Intent Optional Attributes Name type(RFZNameListType), intent(inout) :: rfznl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSONwriteDictIndxOpenCLNameList (dictindxnl, jsonname, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief write namelist to JSON file\n @param rfznl RFZ name list structure\n @param jsonname output file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/12/15 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(DictIndxOpenCLListType), intent(inout) :: dictindxnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSONreadInteger (json, ep, ival, dval) @author Marc De Graef, Carnegie Mellon University\n @brief read integer from json file into namelist structure (with auto missing detection)\n @param json structure\n @param ep entry path string\n @param ival integer variable\n @param dval integer variable (default value)\n @date 08/12/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(json_file), intent(inout) :: json character(len=fnlen), intent(in) :: ep integer(kind=irg), intent(inout) :: ival integer(kind=irg), intent(in) :: dval public recursive subroutine JSONreadIntegerVec (json, ep, ivec, dvec, n) @author Marc De Graef, Carnegie Mellon University\n @brief read integer vector from json file into namelist structure (with auto missing detection)\n @param json structure\n @param ep entry path string\n @param ival integer vector variable\n @param dval integer vector variable (default value)\n @date 08/12/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(json_file), intent(inout) :: json character(len=fnlen), intent(in) :: ep integer(kind=irg), intent(inout) :: ivec (n) integer(kind=irg), intent(in) :: dvec (n) integer(kind=irg), intent(in) :: n public recursive subroutine JSONreadReal (json, ep, rval, dval) @author Marc De Graef, Carnegie Mellon University\n @brief read single precision real from json file into namelist structure (with auto missing detection)\n @param json structure\n @param ep entry path string\n @param rval real variable\n @param dval real variable (default value)\n @date 08/12/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(json_file), intent(inout) :: json character(len=fnlen), intent(in) :: ep real(kind=sgl), intent(inout) :: rval real(kind=sgl), intent(in) :: dval public recursive subroutine JSONreadRealVec (json, ep, rvec, dvec, n) @author Marc De Graef, Carnegie Mellon University\n @brief read single precision real vector from json file into namelist structure (with auto missing detection)\n @param json structure\n @param ep entry path string\n @param rval real vector variable\n @param dval real vector variable (default value)\n @date 08/12/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(json_file), intent(inout) :: json character(len=fnlen), intent(in) :: ep real(kind=sgl), intent(inout) :: rvec (n) real(kind=sgl), intent(in) :: dvec (n) integer(kind=irg), intent(in) :: n public recursive subroutine JSONreadDouble (json, ep, rval, dval) @author Marc De Graef, Carnegie Mellon University\n @brief read double precision real from json file into namelist structure (with auto missing detection)\n @param json structure\n @param ep entry path string\n @param rval real variable\n @param dval real variable (default value)\n @date 08/12/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(json_file), intent(inout) :: json character(len=fnlen), intent(in) :: ep real(kind=dbl), intent(inout) :: rval real(kind=dbl), intent(in) :: dval public recursive subroutine JSONreadDoubleVec (json, ep, rvec, dvec, n) @author Marc De Graef, Carnegie Mellon University\n @brief read double precision real vector from json file into namelist structure (with auto missing detection)\n @param json structure\n @param ep entry path string\n @param rval real vector variable\n @param dval real vector variable (default value)\n @date 08/12/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(json_file), intent(inout) :: json character(len=fnlen), intent(in) :: ep real(kind=dbl), intent(inout) :: rvec (n) real(kind=dbl), intent(in) :: dvec (n) integer(kind=irg), intent(in) :: n public recursive subroutine JSONreadString (json, ep, sval, dval) @author Marc De Graef, Carnegie Mellon University\n @brief read string from json file into namelist structure (with auto missing detection)\n @param json structure\n @param ep entry path string\n @param sval string\n @param dval string (default value)\n @date 08/12/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(json_file), intent(inout) :: json character(len=fnlen), intent(in) :: ep character(len=fnlen), intent(inout) :: sval character(len=fnlen), intent(in) :: dval public recursive subroutine JSONreadLogical (json, ep, sval, dval) @author Marc De Graef, Carnegie Mellon University\n @brief read logical from json file into namelist structure (with auto missing detection)\n @param json structure\n @param ep entry path string\n @param sval logical \n @param dval logical (default value)\n @date 08/20/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(json_file), intent(inout) :: json character(len=fnlen), intent(in) :: ep logical, intent(inout) :: sval logical, intent(in) :: dval public recursive subroutine JSONreadFoilData (cell, defects, error_cnt, verbose) @author Marc De Graef, Carnegie Mellon University\n @brief parse json foil file into defect namelist structures\n @param cell unit cell pointer\n @param defects defect structure, to be filled by this routine\n @param error_cnt total number of errors encountered by json routines\n @param verbose [optional] print a lot of output if present and true\n @date 11/21/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(unitcell), intent(in), pointer :: cell type(defecttype), intent(inout) :: defects integer(kind=irg), intent(inout) :: error_cnt logical, intent(in), optional :: verbose public recursive subroutine JSONreadDefectFile (cell, jsonname, defects, error_cnt, verbose) @author Marc De Graef, Carnegie Mellon University\n @brief parse json file into defect namelist structures\n @param cell unit cell pointer\n @param jsonname input file name\n @param defects defect structure, to be filled by this routine\n @param error_cnt total number of errors encountered by json routines\n @param verbose [optional] print a lot of output if present and true\n @date 11/20/15 MDG 1.0 new routine\n @date 12/08/15 MDG 1.1 added Einclusion defect type Arguments Type Intent Optional Attributes Name type(unitcell), intent(in), pointer :: cell character(len=fnlen), intent(in) :: jsonname type(defecttype), intent(inout) :: defects integer(kind=irg), intent(inout) :: error_cnt logical, intent(in), optional :: verbose public recursive subroutine JSONreadKosselNameList (knl, jsonname, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief read json file into namelist structure\n @param knl Kossel name list structure\n @param jsonname input file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/12/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(KosselNameListType), intent(inout) :: knl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSONreadKosselMasterNameList (knl, jsonname, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief read json file and fill knl structure (used by EMKosselmaster.f90)\n @param knl Kossel name list structure\n @param jsonname input file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/19/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(KosselMasterNameListType), intent(inout) :: knl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSONreadreflectorNameList (rnl, jsonname, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief read json file and fill mcnl structure (used by EMMC.f90)\n @param mcnl Monte Carloname list structure\n @param jsonname input file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/19/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(reflectorNameListType), intent(inout) :: rnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSONreadMCNameList (mcnl, jsonname, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief read json file and fill mcnl structure (used by EMMC.f90)\n @param mcnl Monte Carloname list structure\n @param jsonname input file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/19/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(MCNameListType), intent(inout) :: mcnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSONreadMCCLNameList (mcnl, jsonname, error_cnt) @author Saransh Singh/Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMMCCL.f90)\n @param mcnl Monte Carlo name list structure\n @param jsonname input file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/19/15  MDG 1.0 new routine\n @date 09/09/15  MDG 1.1 added devid Arguments Type Intent Optional Attributes Name type(MCCLNameListType), intent(inout) :: mcnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSONreadMCCLMultiLayerNameList (mcnl, jsonname, error_cnt) @author Saransh Singh/Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMMCCL.f90)\n @param mcnl Monte Carloname list structure\n @param jsonname input file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/19/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(MCCLMultiLayerNameListType), intent(inout) :: mcnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSONreadEBSDMasterNameList (emnl, jsonname, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief read json file and fill emnl structure (used by EMEBSDmaster.f90)\n @param emnl EBSD master name list structure\n @param jsonname input file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/19/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(EBSDMasterNameListType), intent(inout) :: emnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSONreadEBSDclusterNameList (emnl, jsonname, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief read json file and fill emnl structure (used by EMEBSDcluster.f90)\n @param emnl EBSD cluster name list structure\n @param jsonname input file name\n @param error_cnt total number of errors encountered by json routines\n @date 12/28/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(EBSDclusterNameListType), intent(inout) :: emnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSONreadECPMasterNameList (ecpnl, jsonname, error_cnt) @author Saransh Singh/Marc De Graef, Carnegie Mellon University\n @brief read json file and fill mcnl structure (used by EMECPmaster.f90)\n @param emnl ECP master name list structure\n @param jsonname input file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/20/15  MDG 1.0 new routine\n @date 09/15/15  SS  1.1 changes after clean up of ECPmasterListType Arguments Type Intent Optional Attributes Name type(ECPMasterNameListType), intent(inout) :: ecpnl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSONreadEBSDNameList (enl, jsonname, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief read json file and fill enl structure (used by EMEBSD.f90)\n @param enl EBSD name list structure\n @param jsonname input file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/20/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(EBSDNameListType), intent(inout) :: enl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt public recursive subroutine JSONreadEBSDoverlapNameList (enl, jsonname, error_cnt) @author Marc De Graef, Carnegie Mellon University\n @brief read jsonfile and fill enl structure (used by EMEBSDoverlap.f90)\n @param enl EBSD name list structure\n @param jsonname input file name\n @param error_cnt total number of errors encountered by json routines\n @date 08/20/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name type(EBSDoverlapNameListType), intent(inout) :: enl character(len=fnlen), intent(in) :: jsonname integer(kind=irg), intent(inout) :: error_cnt","tags":"","loc":"module/jsonsupport.html","title":"JSONsupport – Fortran Program"},{"text":"Uses: local typedefs error module~~muellercalculus~~UsesGraph module~muellercalculus MuellerCalculus typedefs typedefs typedefs->module~muellercalculus local local local->module~muellercalculus error error error->module~muellercalculus Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief routines to generate and handle Mueller matrices and Stokes vectors for polarized light microscopy\n @details Most of the routines in this module are based on the book by Collett:\n Polarized Light: Fundamentals and Applications, E. Collett, 1993 (M. Decker, Inc)\n @date 02/12/17 MDG 1.0 initial version Functions MC_get_basicMuellerMatrix MC_get_diattenuator MC_get_rotator MC_get_retarder MC_rotate_MuellerMatrix MC_propagateStokesVector MC_concatenateMuellerMatrices MC_get_EllipticityAngle MC_get_OrientationAngle MC_get_AuxiliaryAngle MC_get_PhaseShiftAngle MC_get_Polarization MC_get_Stokes_EO MC_get_Stokes_AD Subroutines MC_print_MuellerMatrix MC_get_AD_from_EO MC_get_EO_from_AD Functions public recursive function MC_get_basicMuellerMatrix (MMtype) result(res) @author Marc De Graef, Carnegie Mellon University\n @brief returns a basic 4x4 Mueller matrix by type\n @param MMtype integer describing the optical element (0 prduces list)\n @date   02/14/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: MMtype Return Value type(MuellerMatrixType) public recursive function MC_get_diattenuator (px, py, polar) result(res) @author Marc De Graef, Carnegie Mellon University\n @brief returns a 4x4 Mueller matrix for a diattenuator (polarizer)\n @param px amplitude attenuation coefficient along x or magnitude of vector p\n @param py amplitude attenuation coefficient along y or polar angle of vector p\n @param polar (OPTIONAL) absent/FALSE: cartesian components; TRUE: polar components of px + i py = (p, alpha)\n @date   02/12/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: px real(kind=dbl), intent(in) :: py logical, intent(in), optional :: polar Return Value type(MuellerMatrixType) public recursive function MC_get_rotator (theta) result(res) @author Marc De Graef, Carnegie Mellon University\n @brief returns a 4x4 Mueller matrix for a rotator\n @param theta rotator angle (radians)\n @date   02/12/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: theta Return Value type(MuellerMatrixType) public recursive function MC_get_retarder (phi) result(res) @author Marc De Graef, Carnegie Mellon University\n @brief returns a 4x4 Mueller matrix for a retarder\n @param phi retardation angle (radians)\n @date   02/12/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: phi Return Value type(MuellerMatrixType) public recursive function MC_rotate_MuellerMatrix (MM, theta) result(res) @author Marc De Graef, Carnegie Mellon University\n @param MM input Mueller matrix\n @param theta rotation angle (radians)\n @date   02/12/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name type(MuellerMatrixType), intent(in) :: MM real(kind=dbl), intent(in) :: theta Return Value type(MuellerMatrixType) public recursive function MC_propagateStokesVector (MM, SV, descriptor) result(res) @author Marc De Graef, Carnegie Mellon University\n @brief multiplies a Stokes vector by a Mueller matrix \n @param MM Mueller matrix structure\n @param SV Stokes vector structure\n @param descriptor string to describe the state of the Stokes vector\n @date   02/12/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name type(MuellerMatrixType), intent(in) :: MM type(StokesVectorType), intent(in) :: SV character(len=fnlen), intent(in) :: descriptor Return Value type(StokesVectorType) public recursive function MC_concatenateMuellerMatrices (MM1, MM2) result(res) @author Marc De Graef, Carnegie Mellon University\n @brief multiplies a Mueller matrix M1 by M2, in the order  M2 x M1\n @param MM1 Mueller matrix structure (earlier in the optical path)\n @param MM2 Mueller matrix structure (later in the optical path)\n @date   02/14/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name type(MuellerMatrixType), intent(in) :: MM1 type(MuellerMatrixType), intent(in) :: MM2 Return Value type(MuellerMatrixType) public recursive function MC_get_EllipticityAngle (SV) result(res) @author Marc De Graef, Carnegie Mellon University\n @brief extracts the ellipticity angle from a Stokes vector\n @param SV Stokes vector structure\n @date   02/12/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name type(StokesVectorType), intent(in) :: SV Return Value real(kind=dbl) public recursive function MC_get_OrientationAngle (SV) result(res) @author Marc De Graef, Carnegie Mellon University\n @brief extracts the polarization ellipse orientation angle from a Stokes vector\n @param SV Stokes vector structure\n @date   02/12/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name type(StokesVectorType), intent(in) :: SV Return Value real(kind=dbl) public recursive function MC_get_AuxiliaryAngle (SV) result(res) @author Marc De Graef, Carnegie Mellon University\n @brief extracts the auxiliary angle from a Stokes vector\n @param SV Stokes vector structure\n @date   02/13/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name type(StokesVectorType), intent(in) :: SV Return Value real(kind=dbl) public recursive function MC_get_PhaseShiftAngle (SV) result(res) @author Marc De Graef, Carnegie Mellon University\n @brief extracts the phase shift angle from a Stokes vector\n @param SV Stokes vector structure\n @date   02/13/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name type(StokesVectorType), intent(in) :: SV Return Value real(kind=dbl) public recursive function MC_get_Polarization (SV) result(res) @author Marc De Graef, Carnegie Mellon University\n @brief extracts the polarization from a Stokes vector\n @param SV Stokes vector structure\n @date   02/12/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name type(StokesVectorType), intent(in) :: SV Return Value real(kind=dbl) public recursive function MC_get_Stokes_EO (chi, psi, descriptor) result(res) @author Marc De Graef, Carnegie Mellon University\n @brief generate a Stokes vector for a given Ellipticity and Orientation angle\n @param chi ellipticity angle (radians)\n @param psi orientation angle (radians)\n @date   02/13/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: chi real(kind=dbl), intent(in) :: psi character(len=fnlen), intent(in) :: descriptor Return Value type(StokesVectorType) public recursive function MC_get_Stokes_AD (alpha, delta, descriptor) result(res) @author Marc De Graef, Carnegie Mellon University\n @brief generate a Stokes vector for a given auxiliary and phase shift angle\n @param alpha auxiliary angle (radians)\n @param delta phase shift angle (radians)\n @date   02/13/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: alpha real(kind=dbl), intent(in) :: delta character(len=fnlen), intent(in) :: descriptor Return Value type(StokesVectorType) Subroutines public recursive subroutine MC_print_MuellerMatrix (MM) @author Marc De Graef, Carnegie Mellon University\n @param MM input Mueller matrix\n @date   02/12/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name type(MuellerMatrixType), intent(in) :: MM public recursive subroutine MC_get_AD_from_EO (chi, psi, alpha, delta) @author Marc De Graef, Carnegie Mellon University\n @brief convert auxiliary and phase shift angle to ellipticity and orientation angles\n @details determined using a Mathematica script\n @param chi ellipticity angle (radians)\n @param psi orientation angle (radians)\n @param alpha auxiliary angle (radians)\n @param delta phase shift angle (radians)\n @date   02/13/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: chi real(kind=dbl), intent(in) :: psi real(kind=dbl), intent(out) :: alpha real(kind=dbl), intent(out) :: delta public recursive subroutine MC_get_EO_from_AD (alpha, delta, chi, psi) @author Marc De Graef, Carnegie Mellon University\n @brief convert ellipticity and orientation angles to auxiliary and phase shift angles\n @details determined using a Mathematica script\n @param alpha auxiliary angle (radians)\n @param delta phase shift angle (radians)\n @param chi ellipticity angle (radians)\n @param psi orientation angle (radians)\n @date   02/13/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: alpha real(kind=dbl), intent(in) :: delta real(kind=dbl), intent(out) :: chi real(kind=dbl), intent(out) :: psi","tags":"","loc":"module/muellercalculus.html","title":"MuellerCalculus – Fortran Program"},{"text":"Uses: local module~~multibeams~~UsesGraph module~multibeams multibeams local local local->module~multibeams Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief Anything related to dynamical diffraction\n @details these variables are passed back and forth between the main\n multi beam program and the various subroutines. Todo prepend MB to all the variable names and propagate into other code\n @date   10/13/98 MDG 1.0 original\n @date    5/22/01 MDG 2.0 f90\n @date   11/27/01 MDG 2.1 added kind support\n @date    3/14/02 MDG 2.2 added CalcDynMat routine Used By module~~multibeams~~UsedByGraph module~multibeams multibeams proc~emsoftcgetebsdmaster EMsoftCgetEBSDmaster module~multibeams->proc~emsoftcgetebsdmaster Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Variables numr family numfam idx glen gm V al Variables Type Visibility Attributes Name Initial integer(kind=irg), public, parameter :: numr = 500 integer(kind=irg), public :: family (numr,48,3) integer(kind=irg), public :: numfam (numr) integer(kind=irg), public, allocatable :: idx (:) real(kind=sgl), public :: glen (numr) real(kind=sgl), public, allocatable :: gm (:) real(kind=sgl), public, allocatable :: V (:,:) logical, public, allocatable :: al (:)","tags":"","loc":"module/multibeams.html","title":"multibeams – Fortran Program"},{"text":"Uses: local NameListTypedefs module~~namelisthandlers~~UsesGraph module~namelisthandlers NameListHandlers local local local->module~namelisthandlers module~namelisttypedefs NameListTypedefs local->module~namelisttypedefs module~namelisttypedefs->module~namelisthandlers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief routines for reading and returning name list type structures\n @date 06/13/14 MDG 1.0 original\n @date 05/05/15 MDG 1.1 removed primelist variable from name list files\n @date 08/12/15 MDG 1.2 added initonly optional keyword to skip reading from file Used By module~~namelisthandlers~~UsedByGraph module~namelisthandlers NameListHandlers proc~jsonreaddefectfile JSONreadDefectFile module~namelisthandlers->proc~jsonreaddefectfile proc~jsonreadebsdmasternamelist JSONreadEBSDMasterNameList module~namelisthandlers->proc~jsonreadebsdmasternamelist proc~jsonreadebsdnamelist JSONreadEBSDNameList module~namelisthandlers->proc~jsonreadebsdnamelist proc~jsonreadmcclmultilayernamelist JSONreadMCCLMultiLayerNameList module~namelisthandlers->proc~jsonreadmcclmultilayernamelist proc~jsonreadebsdclusternamelist JSONreadEBSDclusterNameList module~namelisthandlers->proc~jsonreadebsdclusternamelist proc~jsonreadkosselmasternamelist JSONreadKosselMasterNameList module~namelisthandlers->proc~jsonreadkosselmasternamelist proc~jsonreadkosselnamelist JSONreadKosselNameList module~namelisthandlers->proc~jsonreadkosselnamelist proc~jsonreadfoildata JSONreadFoilData module~namelisthandlers->proc~jsonreadfoildata proc~jsonreadreflectornamelist JSONreadreflectorNameList module~namelisthandlers->proc~jsonreadreflectornamelist proc~jsonreadebsdoverlapnamelist JSONreadEBSDoverlapNameList module~namelisthandlers->proc~jsonreadebsdoverlapnamelist proc~jsonreadecpmasternamelist JSONreadECPMasterNameList module~namelisthandlers->proc~jsonreadecpmasternamelist proc~jsonreadmcnamelist JSONreadMCNameList module~namelisthandlers->proc~jsonreadmcnamelist proc~jsonreadmcclnamelist JSONreadMCCLNameList module~namelisthandlers->proc~jsonreadmcclnamelist Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Subroutines GetMultiPhaseNameList GetKosselNameList GetKosselMasterNameList GetMCNameList GetMCLIPSSNameList GetConvertOrientationsNameList GetOrientationVizNameList GetMCCLNameList GetMCCLMultiLayerNameList GetDisorientationsNameList GetAverageOrientationNameList GetOrientationSimilarityNameList GetKAMNameList GetDvsDNameList GetEBSDMasterNameList GetTKDMasterNameList GetEBSDMasterOpenCLNameList GetEBSDclusterNameList GetECPMasterNameList GetreflectorNameList GetkinematicalNameList GetEBSDdetparmscanNameList GetEBSDNameList GetTKDNameList GetEBSDoverlapNameList GetECPZANameList GetECPNameList GetLACBEDNameList GetECPpatternNameList GetPEDkinNameList GetPEDZANameList GetECCINameList GetRFZNameList GetDictIndxOpenCLNameList GetPEDIndxNameList GetEBSDIndexingNameList GetTKDIndexingNameList GetZAdefectNameList GetECPIndexingNameList GetEMDPFit4NameList GetEMDPFitNameList GetECPSingleNameList GetSTEMDCINameList GetRefineOrientationNameList GetFitOrientationPSNameList GetMCCLsphereNameList GetMCCLfoilNameList GetEBSDFullNameList GetSRdefectNameList GetPFInversionNameList Subroutines public recursive subroutine GetMultiPhaseNameList (nmlfile, enl, initonly) @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill enl structure (used by EMMultiphase.f90)\n @param nmlfile namelist file name\n @param enl multiphase name list structure\n @param initonly [optional] logical\n @date 02/21/17  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(MultiPhaseNameListType), intent(inout) :: enl logical, intent(in), optional :: initonly public recursive subroutine GetKosselNameList (nmlfile, knl, initonly) @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill knl structure (used by EMKossel.f90)\n @param nmlfile namelist file name\n @param knl Kossel name list structure\n @param initonly [optional] logical\n @date 06/13/14  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(KosselNameListType), intent(inout) :: knl logical, intent(in), optional :: initonly public recursive subroutine GetKosselMasterNameList (nmlfile, knl, initonly) @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill knl structure (used by EMKosselmaster.f90)\n @param nmlfile namelist file name\n @param knl Kossel name list structure\n @date 09/09/14  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(KosselMasterNameListType), intent(inout) :: knl logical, intent(in), optional :: initonly public recursive subroutine GetMCNameList (nmlfile, mcnl, initonly) @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMMC.f90)\n @param nmlfile namelist file name\n @param mcnl Monte Carloname list structure\n @date 06/18/14  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(MCNameListType), intent(inout) :: mcnl logical, intent(in), optional :: initonly public recursive subroutine GetMCLIPSSNameList (nmlfile, mcnl, initonly) @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMMC.f90)\n @param nmlfile namelist file name\n @param mcnl Monte Carloname list structure\n @date 12/01/15  PGC 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(MCLIPSSNameListType), intent(inout) :: mcnl logical, intent(in), optional :: initonly public recursive subroutine GetConvertOrientationsNameList (nmlfile, enl, initonly) @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMConvertOrientations.f90 program)\n @param nmlfile namelist file name\n @param enl name list structure\n @date 01/31/17 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(ConvertOrientationsNameListType), intent(inout) :: enl logical, intent(in), optional :: initonly public recursive subroutine GetOrientationVizNameList (nmlfile, enl, initonly) @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMOrientationViz.f90 program)\n @param nmlfile namelist file name\n @param enl name list structure\n @date 01/30/17 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(OrientationVizNameListType), intent(inout) :: enl logical, intent(in), optional :: initonly public recursive subroutine GetMCCLNameList (nmlfile, mcnl, initonly) @author Saransh Singh/Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMMCCL.f90 and other programs)\n @param nmlfile namelist file name\n @param mcnl Monte Carloname list structure\n @date 06/18/14  SS 1.0 new routine\n @date 09/09/15 MDG 1.1 added devid (GPU device id) Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(MCCLNameListType), intent(inout) :: mcnl logical, intent(in), optional :: initonly public recursive subroutine GetMCCLMultiLayerNameList (nmlfile, mcnl, initonly) @author Saransh Singh/Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMMCCL.f90)\n @param nmlfile namelist file name\n @param mcnl Monte Carloname list structure\n @date 06/18/14  SS 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(MCCLMultiLayerNameListType), intent(inout) :: mcnl logical, intent(in), optional :: initonly public recursive subroutine GetDisorientationsNameList (nmlfile, emnl, initonly) @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMDisorientations.f90)\n @param nmlfile namelist file name\n @param emnl name list structure\n @date 06/24/16  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(DisorientationsNameListType), intent(inout) :: emnl logical, intent(in), optional :: initonly public recursive subroutine GetAverageOrientationNameList (nmlfile, emnl, initonly) @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMAverageOrient.f90)\n @param nmlfile namelist file name\n @param emnl name list structure\n @date 06/24/16  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(AverageOrientationNameListType), intent(inout) :: emnl logical, intent(in), optional :: initonly public recursive subroutine GetOrientationSimilarityNameList (nmlfile, emnl, initonly) @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMOrientationSimilarity.f90)\n @param nmlfile namelist file name\n @param emnl name list structure\n @date 07/29/16  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(OrientationSimilarityNameListType), intent(inout) :: emnl logical, intent(in), optional :: initonly public recursive subroutine GetKAMNameList (nmlfile, emnl, initonly) @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMOrientationSimilarity.f90)\n @param nmlfile namelist file name\n @param emnl name list structure\n @date 07/29/16  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(KAMNameListType), intent(inout) :: emnl logical, intent(in), optional :: initonly public recursive subroutine GetDvsDNameList (nmlfile, emnl, initonly) @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMOrientationSimilarity.f90)\n @param nmlfile namelist file name\n @param emnl name list structure\n @date 07/29/16  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(DvsDNameListType), intent(inout) :: emnl logical, intent(in), optional :: initonly public recursive subroutine GetEBSDMasterNameList (nmlfile, emnl, initonly) @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMEBSDmaster.f90)\n @param nmlfile namelist file name\n @param emnl EBSD master name list structure\n @date 06/19/14  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(EBSDMasterNameListType), intent(inout) :: emnl logical, intent(in), optional :: initonly public recursive subroutine GetTKDMasterNameList (nmlfile, emnl, initonly) @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMTKDmaster.f90)\n @param nmlfile namelist file name\n @param emnl TKD master name list structure\n @date 01/16/17  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(TKDMasterNameListType), intent(inout) :: emnl logical, intent(in), optional :: initonly public recursive subroutine GetEBSDMasterOpenCLNameList (nmlfile, emnl, initonly) @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMEBSDmasterOpenCL.f90)\n @param nmlfile namelist file name\n @param emnl EBSD master name list structure\n @date 12/10/16  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(EBSDMasterOpenCLNameListType), intent(inout) :: emnl logical, intent(in), optional :: initonly public recursive subroutine GetEBSDclusterNameList (nmlfile, emnl, initonly) @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill emnl structure (used by EMEBSDcluster.f90)\n @param nmlfile namelist file name\n @param emnl EBSD master name list structure\n @date 06/19/14  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(EBSDclusterNameListType), intent(inout) :: emnl logical, intent(in), optional :: initonly public recursive subroutine GetECPMasterNameList (nmlfile, ecpnl, initonly) @author Saransh Singh/Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMECPmaster.f90)\n @param nmlfile namelist file name\n @param emnl ECP master name list structure\n @date 06/19/14  SS 1.0 new routine\n @date 08/12/15 MDG 1.1 correction of type for startthick and fn(3)\n @date 09/15/15  SS 1.2 clean up of the subroutine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(ECPMasterNameListType), intent(inout) :: ecpnl logical, intent(in), optional :: initonly public recursive subroutine GetreflectorNameList (nmlfile, rnl, initonly) @author Marc De Graef\n @brief read reflector namelist for EMreflectors program\n @param nmlfile namelist file name\n @param rnl reflect name list structure\n @date 05/31/16 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(reflectorNameListType), intent(inout) :: rnl logical, intent(in), optional :: initonly public recursive subroutine GetkinematicalNameList (nmlfile, knl, initonly) @author Marc De Graef\n @brief read reflector namelist for EMreflectors program\n @param nmlfile namelist file name\n @param rnl reflect name list structure\n @date 05/31/16 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(kinematicalNameListType), intent(inout) :: knl logical, intent(in), optional :: initonly public recursive subroutine GetEBSDdetparmscanNameList (nmlfile, enl, initonly) @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill enl structure (used by EMEBSD.f90)\n @param nmlfile namelist file name\n @param enl EBSD name list structure\n @date 06/23/14  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(EBSDdetparmscanNameListType), intent(inout) :: enl logical, intent(in), optional :: initonly public recursive subroutine GetEBSDNameList (nmlfile, enl, initonly) @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill enl structure (used by EMEBSD.f90)\n @param nmlfile namelist file name\n @param enl EBSD name list structure\n @date 06/23/14  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(EBSDNameListType), intent(inout) :: enl logical, intent(in), optional :: initonly public recursive subroutine GetTKDNameList (nmlfile, enl, initonly) @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill enl structure (used by EMTKD.f90)\n @param nmlfile namelist file name\n @param enl TKD name list structure\n @date 05/09/17  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(TKDNameListType), intent(inout) :: enl logical, intent(in), optional :: initonly public recursive subroutine GetEBSDoverlapNameList (nmlfile, enl, initonly) @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill enl structure (used by EMEBSDoverlap.f90)\n @param nmlfile namelist file name\n @param enl EBSD name list structure\n @date 04/29/15  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(EBSDoverlapNameListType), intent(inout) :: enl logical, intent(in), optional :: initonly public recursive subroutine GetECPZANameList (nmlfile, ecpnl, initonly) @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill ecpnl structure (used by EMECPZA.f90)\n @param nmlfile namelist file name\n @param ecpnl name list structure\n @date 01/25/17 MDG 1.0 new structure Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(ECPZANameListType), intent(inout) :: ecpnl logical, intent(in), optional :: initonly public recursive subroutine GetECPNameList (nmlfile, ecpnl, initonly) @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill ecpnl structure (used by EMECP.f90)\n @param nmlfile namelist file name\n @param knl Kossel name list structure\n @date 06/13/14  MDG 1.0 new routine\n @date 11/25/14  MDG 2.0 added parameters for film on substrate mode\n @date 10/15/15 SS  1.2 changes for release Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(ECPNameListType), intent(inout) :: ecpnl logical, intent(in), optional :: initonly public recursive subroutine GetLACBEDNameList (nmlfile, lacbednl, initonly) @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill lacbednl structure (used by EMLACBED.f90)\n @param nmlfile namelist file name\n @param lacbednl LACBED name list structure\n @date 07/01/14  MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(LACBEDNameListType), intent(inout) :: lacbednl logical, intent(in), optional :: initonly public recursive subroutine GetECPpatternNameList (nmlfile, ecpnl, initonly) @author Saransh Singh, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMECPpattern.f90)\n @param nmlfile namelist file name\n @param emnl ECP name list structure\n @date 06/19/14  SS 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(ECPpatternNameListType), intent(inout) :: ecpnl logical, intent(in), optional :: initonly public recursive subroutine GetPEDkinNameList (nmlfile, pednl, initonly) @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill pednl structure (used by EMpedKIN.f90)\n @param nmlfile namelist file name\n @param pednl PED name list structure\n @date 03/02/15 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(PEDkinNameListType), intent(inout) :: pednl logical, intent(in), optional :: initonly public recursive subroutine GetPEDZANameList (nmlfile, pednl, initonly) @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill pednl structure (used by EMPEDZA.f90)\n @param nmlfile namelist file name\n @param pednl PED name list structure\n @date 07/09/14 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(PEDZANameListType), intent(inout) :: pednl logical, intent(in), optional :: initonly public recursive subroutine GetECCINameList (nmlfile, eccinl, initonly) @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill eccinl structure (used by EMECCI.f90)\n @param nmlfile namelist file name\n @param eccinl ECCI name list structure\n @date 10/04/14 MDG 1.0 new routine\n @date 11/24/15 MDG 1.1 adapted for new namelist variables Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(ECCINameListType), intent(inout) :: eccinl logical, intent(in), optional :: initonly public recursive subroutine GetRFZNameList (nmlfile, rfznl, initonly) @author Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill rfznl structure (used by EMsampleRFZ.f90)\n @param nmlfile namelist file name\n @param rfznl RFZ name list structure\n @date 12/09/14 MDG 1.0 new routine\n @date 08/18/15 MDG 1.1 added options for all seven representations\n @date 01/17/15 MDG 1.2 added gridtype option\n @date 12/22/16 MDG 1.3 added new sampling mode\n @date 02/01/17 MDG 1.4 added conical sampling mode Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(RFZNameListType), intent(inout) :: rfznl logical, intent(in), optional :: initonly public recursive subroutine GetDictIndxOpenCLNameList (nmlfile, dictindxnl, initonly) @author Saransh Singh, Carnegie Mellon University\n @brief read namelist file and fill DictIndxOpenCLListType (used by EMDictIndxOpenCL.f90)\n @param nmlfile namelist file name\n @param DictIndxOpenCL name list structure\n @date 13/01/15 SS 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(DictIndxOpenCLListType), intent(inout) :: dictindxnl logical, intent(in), optional :: initonly public recursive subroutine GetPEDIndxNameList (nmlfile, pednl, initonly) @author Saransh Singh, Carnegie Mellon University\n @brief read namelist file and fill PEDKINIndxListType (used by EMPEDIndexing.f90)\n @param nmlfile namelist file name\n @param pednl PEDKINIndx name list structure\n @date 13/01/15 SS 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(PEDKINIndxListType), intent(inout) :: pednl logical, intent(in), optional :: initonly public recursive subroutine GetEBSDIndexingNameList (nmlfile, enl, initonly) @author Saransh Singh, Carnegie Mellon University\n @brief read namelist file and fill enl structure (used by EMDynamicEBSDIndeixing.f90)\n @param nmlfile namelist file name\n @param enl EBSD indexing name list structure\n @date 06/10/15  SS 1.0 new routine\n @date 11/19/15  SS 1.1 added new variables\n @date 01/26/16  SS 1.2 adjusted for EBSDIndexing Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(EBSDIndexingNameListType), intent(inout) :: enl logical, intent(in), optional :: initonly public recursive subroutine GetTKDIndexingNameList (nmlfile, enl, initonly) @author Marc De Graef , Carnegie Mellon University\n @brief read namelist file and fill enl structure (used by EMTKDDI.f90)\n @param nmlfile namelist file name\n @param enl TKD indexing name list structure\n @date 05/07/17 MDG 1.0 new routine, based on EBSD routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(TKDIndexingNameListType), intent(inout) :: enl logical, intent(in), optional :: initonly public recursive subroutine GetZAdefectNameList (nmlfile, ZAdefect, initonly) @author Saransh Singh, Carnegie Mellon University\n @brief read namelist file and fill ZAdefect structure (used by CTEMDefect.f90)\n @param nmlfile namelist file name\n @param ZAdefect Zone Axis defect simulation name list structure\n @date 06/24/15  SS 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(ZAdefectnameListType), intent(inout) :: ZAdefect logical, intent(in), optional :: initonly public recursive subroutine GetECPIndexingNameList (nmlfile, enl, initonly) @author Saransh Singh, Carnegie Mellon University\n @brief read namelist file and fill enl structure (used by EMDynamicECPIndeixing.f90)\n @param nmlfile namelist file name\n @param enl ECP indexing name list structure\n @date 11/19/15  SS 1.0 original\n @date 01/26/16  SS 1.1 modified for EMsoft3.1 indexing code Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(ECPIndexingNameListType), intent(inout) :: enl logical, intent(in), optional :: initonly public recursive subroutine GetEMDPFit4NameList (nmlfile, enl, initonly) @author Saransh Singh, Carnegie Mellon University\n @brief read namelist file and fill enl structure (used by EMDPFit.f90)\n @param nmlfile namelist file name\n @param enl DPFit name list structure\n @date 02/22/16  SS 1.0 original Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(EMDPFit4ListType), intent(inout) :: enl logical, intent(in), optional :: initonly public recursive subroutine GetEMDPFitNameList (nmlfile, enl, initonly) @author Saransh Singh, Carnegie Mellon University\n @brief read namelist file and fill enl structure (used by EMDPFit.f90)\n @param nmlfile namelist file name\n @param enl DPFit name list structure\n @date 02/22/16  SS 1.0 original Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(EMDPFitListType), intent(inout) :: enl logical, intent(in), optional :: initonly public recursive subroutine GetECPSingleNameList (nmlfile, enl, initonly) @author Saransh Singh, Carnegie Mellon University\n @brief read namelist file and fill enl structure (used by EMDPFit.f90)\n @param nmlfile namelist file name\n @param enl ECP single name list structure\n @date 02/22/16  SS 1.0 original Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(ECPSingleNameListType), intent(inout) :: enl logical, intent(in), optional :: initonly public recursive subroutine GetSTEMDCINameList (nmlfile, dcinl, initonly) @author Patrick Callahan\n @brief read namelist file for EMSTEMDCI\n @param nmlfile namelist file name\n @date 11/01/16  PGC 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(STEMDCINameListType), intent(inout) :: dcinl logical, intent(in), optional :: initonly public recursive subroutine GetRefineOrientationNameList (nmlfile, enl, initonly) @author Saransh Singh, Carnegie Mellon University\n @brief read namelist file and fill enl structure (used by EMRefineOrientation.f90)\n @param nmlfile namelist file name\n @param enl single name list structure\n @date 02/22/16  SS 1.0 original Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(RefineOrientationtype), intent(inout) :: enl logical, intent(in), optional :: initonly public recursive subroutine GetFitOrientationPSNameList (nmlfile, enl, initonly) @author Saransh Singh, Carnegie Mellon University\n @brief read namelist file and fill enl structure (used by EMFitOrientationPS.f90)\n @param nmlfile namelist file name\n @param enl single name list structure\n @date 02/22/16  SS 1.0 original Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(FitOrientationPStype), intent(inout) :: enl logical, intent(in), optional :: initonly public recursive subroutine GetMCCLsphereNameList (nmlfile, mcnl, initonly) @author Saransh Singh/Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMMCCL.f90)\n @param nmlfile namelist file name\n @param mcnl Monte Carloname list structure\n @date 10/20/16  SS 1.0 new routine; adapted from GetMCCLNameList Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(MCCLNameListType), intent(inout) :: mcnl logical, intent(in), optional :: initonly public recursive subroutine GetMCCLfoilNameList (nmlfile, mcnl, initonly) @author Saransh Singh/Marc De Graef, Carnegie Mellon University\n @brief read namelist file and fill mcnl structure (used by EMMCfoil.f90)\n @param nmlfile namelist file name\n @param mcnl Monte Carloname list structure\n @date 01/15/17 MDG 1.0 new routine; adapted from GetMCCLNameList Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(MCCLNameListType), intent(inout) :: mcnl logical, intent(in), optional :: initonly public recursive subroutine GetEBSDFullNameList (nmlfile, enl, initonly) @author Saransh Singh, Carnegie Mellon University\n @brief read namelist file and fill enl structure (used by EMEBSDFull.f90)\n @param nmlfile namelist file name\n @param enl EBSD name list structure\n @date 01/24/17  SS 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(EBSDNameListType), intent(inout) :: enl logical, intent(in), optional :: initonly public recursive subroutine GetSRdefectNameList (nmlfile, srdnl, initonly) @author Patrick Callahan\n @brief read namelist file for EMSRdefect\n @param nmlfile namelist file name\n @date 02/10/17  PGC 1.0 new routine Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(SRdefectNameListType), intent(inout) :: srdnl logical, intent(in), optional :: initonly public recursive subroutine GetPFInversionNameList (nmlfile, epf, initonly) @author Saransh Singh, Carnegie Mellon University\n @brief read namelist file and fill enl structure (used by PFInversionSIRT.f90)\n @param nmlfile namelist file name\n @param epf single name list structure\n @date 04/02/17  SS 1.0 original Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: nmlfile type(PFInversionNameListType), intent(inout) :: epf logical, intent(in), optional :: initonly","tags":"","loc":"module/namelisthandlers.html","title":"NameListHandlers – Fortran Program"},{"text":"Uses: local module~~namelisttypedefs~~UsesGraph module~namelisttypedefs NameListTypedefs local local local->module~namelisttypedefs Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief collection of namelist type declarations\n @date 06/13/14 MDG 1.0 initial version\n @date 05/05/15 MDG 1.1 removed primelist variable from name list files\n @date 11/24/15 MDG 1.2 siginificant changes to ECCINameListType Used By module~~namelisttypedefs~~UsedByGraph module~namelisttypedefs NameListTypedefs proc~calckinpedpatternsingle CalcKINPEDPatternSingle module~namelisttypedefs->proc~calckinpedpatternsingle module~namelisthandlers NameListHandlers module~namelisttypedefs->module~namelisthandlers module~jsonsupport JSONsupport module~namelisttypedefs->module~jsonsupport proc~denoise_ped Denoise_PED module~namelisttypedefs->proc~denoise_ped proc~emsoftcgetebsdmaster EMsoftCgetEBSDmaster module~namelisttypedefs->proc~emsoftcgetebsdmaster module~indexingmod Indexingmod module~namelisttypedefs->module~indexingmod proc~ctfped_writefile ctfped_writeFile module~namelisttypedefs->proc~ctfped_writefile proc~jsonreaddefectfile JSONreadDefectFile module~namelisthandlers->proc~jsonreaddefectfile proc~jsonreadebsdmasternamelist JSONreadEBSDMasterNameList module~namelisthandlers->proc~jsonreadebsdmasternamelist proc~jsonreadebsdnamelist JSONreadEBSDNameList module~namelisthandlers->proc~jsonreadebsdnamelist proc~jsonreadmcclmultilayernamelist JSONreadMCCLMultiLayerNameList module~namelisthandlers->proc~jsonreadmcclmultilayernamelist proc~jsonreadebsdclusternamelist JSONreadEBSDclusterNameList module~namelisthandlers->proc~jsonreadebsdclusternamelist proc~jsonreadkosselmasternamelist JSONreadKosselMasterNameList module~namelisthandlers->proc~jsonreadkosselmasternamelist proc~jsonreadkosselnamelist JSONreadKosselNameList module~namelisthandlers->proc~jsonreadkosselnamelist proc~jsonreadfoildata JSONreadFoilData module~namelisthandlers->proc~jsonreadfoildata proc~jsonreadreflectornamelist JSONreadreflectorNameList module~namelisthandlers->proc~jsonreadreflectornamelist proc~jsonreadebsdoverlapnamelist JSONreadEBSDoverlapNameList module~namelisthandlers->proc~jsonreadebsdoverlapnamelist proc~jsonreadecpmasternamelist JSONreadECPMasterNameList module~namelisthandlers->proc~jsonreadecpmasternamelist proc~jsonreadmcnamelist JSONreadMCNameList module~namelisthandlers->proc~jsonreadmcnamelist proc~jsonreadmcclnamelist JSONreadMCCLNameList module~namelisthandlers->proc~jsonreadmcclnamelist proc~initializedefects InitializeDefects module~jsonsupport->proc~initializedefects proc~ebsd4calfun EBSD4calfun module~indexingmod->proc~ebsd4calfun proc~ecpcalfun ECPcalfun module~indexingmod->proc~ecpcalfun proc~ebsdcalfun EBSDcalfun module~indexingmod->proc~ebsdcalfun Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Derived Types MultiPhaseNameListType KosselNameListType KosselMasterNameListType MCNameListType MCLIPSSNameListType reflectorNameListType kinematicalNameListType OrientationVizNameListType ConvertOrientationsNameListType MCCLNameListType MCCLMultiLayerNameListType EBSDMasterNameListType TKDMasterNameListType EBSDMasterOpenCLNameListType EBSDNameListType TKDNameListType EBSDdetparmscanNameListType EBSDoverlapNameListType EBSDclusterNameListType ECPNameListType LACBEDNameListType ECPMasterNameListType ECPpatternNameListType ECPZANameListType PEDZANameListType PEDkinNameListType ECCINameListType RFZNameListType DictIndxOpenCLListType PEDKINIndxListType DisorientationsNameListType AverageOrientationNameListType OrientationSimilarityNameListType KAMNameListType DvsDNameListType EBSDIndexingNameListType TKDIndexingNameListType ECPIndexingNameListType ZAdefectnameListType EMDPFitListType EMDPFit4ListType ECPSingleNameListType STEMDCINameListType SRdefectNameListType RefineOrientationtype FitOrientationPStype PFInversionNameListType Derived Types type, public :: MultiPhaseNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: nthreads character(len=fnlen), public :: dp1file character(len=fnlen), public :: dp2file character(len=fnlen), public :: dp3file character(len=fnlen), public :: outputfile type, public :: KosselNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: numthick integer(kind=irg), public :: npix integer(kind=irg), public :: maxHOLZ integer(kind=irg), public :: nthreads integer(kind=irg), public :: k (3) integer(kind=irg), public :: fn (3) real(kind=sgl), public :: voltage real(kind=sgl), public :: dmin real(kind=sgl), public :: convergence real(kind=sgl), public :: startthick real(kind=sgl), public :: thickinc real(kind=sgl), public :: minten character(len=fnlen), public :: xtalname character(len=fnlen), public :: outname type, public :: KosselMasterNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: numthick integer(kind=irg), public :: npx integer(kind=irg), public :: nthreads real(kind=sgl), public :: voltage real(kind=sgl), public :: dmin real(kind=sgl), public :: startthick real(kind=sgl), public :: thickinc real(kind=sgl), public :: tfraction character(len=6), public :: Kosselmode character(len=fnlen), public :: xtalname character(len=fnlen), public :: outname type, public :: MCNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: numsx integer(kind=irg), public :: primeseed integer(kind=irg), public :: num_el integer(kind=irg), public :: nthreads real(kind=dbl), public :: sig real(kind=dbl), public :: omega real(kind=dbl), public :: EkeV real(kind=dbl), public :: Ehistmin real(kind=dbl), public :: Ebinsize real(kind=dbl), public :: depthmax real(kind=dbl), public :: depthstep character(len=4), public :: MCmode character(len=fnlen), public :: xtalname character(len=fnlen), public :: dataname type, public :: MCLIPSSNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: numsx integer(kind=irg), public :: primeseed integer(kind=irg), public :: num_el integer(kind=irg), public :: nthreads real(kind=dbl), public :: sig real(kind=dbl), public :: omega real(kind=dbl), public :: EkeV real(kind=dbl), public :: Ehistmin real(kind=dbl), public :: Ebinsize real(kind=dbl), public :: depthmax real(kind=dbl), public :: depthstep real(kind=dbl), public :: lipssamp real(kind=dbl), public :: lipsswave real(kind=dbl), public :: scaled integer(kind=irg), public :: npx integer(kind=irg), public :: vis character(len=4), public :: MCmode character(len=fnlen), public :: xtalname character(len=fnlen), public :: dataname type, public :: reflectorNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: numphi integer(kind=irg), public :: numtheta real(kind=sgl), public :: dmin character(len=fnlen), public :: masterfile character(len=fnlen), public :: energyfile type, public :: kinematicalNameListType Components Type Visibility Attributes Name Initial real(kind=sgl), public :: dmin real(kind=sgl), public :: thr real(kind=sgl), public :: voltage character(len=fnlen), public :: xtalname character(len=fnlen), public :: datafile type, public :: OrientationVizNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: cubochoric integer(kind=irg), public :: homochoric integer(kind=irg), public :: rodrigues integer(kind=irg), public :: stereographic integer(kind=irg), public :: eulerspace integer(kind=irg), public :: reducetoRFZ integer(kind=irg), public :: nx integer(kind=irg), public :: ny integer(kind=irg), public :: nz integer(kind=irg), public :: overridepgnum integer(kind=irg), public :: MacKenzieCell real(kind=sgl), public :: rgb (3) real(kind=sgl), public :: sphrad real(kind=sgl), public :: distance character(len=3), public :: scalingmode character(len=fnlen), public :: df3file character(len=fnlen), public :: xtalname character(len=fnlen), public :: povrayfile character(len=fnlen), public :: anglefile type, public :: ConvertOrientationsNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: reducetoRFZ character(len=fnlen), public :: xtalname character(len=fnlen), public :: cubochoric character(len=fnlen), public :: homochoric character(len=fnlen), public :: rodrigues character(len=fnlen), public :: stereographic character(len=fnlen), public :: eulerangles character(len=fnlen), public :: axisangle character(len=fnlen), public :: quaternion character(len=fnlen), public :: rotationmatrix character(len=fnlen), public :: anglefile type, public :: MCCLNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: numsx integer(kind=irg), public :: globalworkgrpsz integer(kind=irg), public :: num_el integer(kind=irg), public :: totnum_el integer(kind=irg), public :: multiplier integer(kind=irg), public :: devid integer(kind=irg), public :: platid real(kind=dbl), public :: sig real(kind=dbl), public :: sigstart real(kind=dbl), public :: sigend real(kind=dbl), public :: sigstep real(kind=dbl), public :: omega real(kind=dbl), public :: EkeV real(kind=dbl), public :: Ehistmin real(kind=dbl), public :: Ebinsize real(kind=dbl), public :: depthmax real(kind=dbl), public :: depthstep real(kind=dbl), public :: thickness real(kind=dbl), public :: radius real(kind=dbl), public :: incloc character(len=4), public :: MCmode character(len=fnlen), public :: xtalname character(len=fnlen), public :: dataname character(len=fnlen), public :: mode type, public :: MCCLMultiLayerNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: numsx integer(kind=irg), public :: globalworkgrpsz integer(kind=irg), public :: num_el integer(kind=irg), public :: totnum_el real(kind=dbl), public :: sig real(kind=dbl), public :: omega real(kind=dbl), public :: EkeV real(kind=dbl), public :: Ehistmin real(kind=dbl), public :: Ebinsize real(kind=dbl), public :: depthmax real(kind=dbl), public :: depthstep real(kind=dbl), public :: filmthickness real(kind=dbl), public :: filmstep character(len=4), public :: MCmode character(len=fnlen), public :: xtalname_film character(len=fnlen), public :: xtalname_subs character(len=fnlen), public :: dataname character(len=fnlen), public :: mode type, public :: EBSDMasterNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: npx integer(kind=irg), public :: Esel integer(kind=irg), public :: nthreads real(kind=sgl), public :: dmin character(len=fnlen), public :: energyfile character(len=fnlen), public :: outname logical, public :: restart logical, public :: uniform type, public :: TKDMasterNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: npx integer(kind=irg), public :: Esel integer(kind=irg), public :: nthreads real(kind=sgl), public :: dmin character(len=fnlen), public :: energyfile character(len=fnlen), public :: outname logical, public :: restart logical, public :: uniform type, public :: EBSDMasterOpenCLNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: npx integer(kind=irg), public :: Esel integer(kind=irg), public :: nthreads integer(kind=irg), public :: platid integer(kind=irg), public :: devid integer(kind=irg), public :: globalworkgrpsz real(kind=sgl), public :: dmin character(len=fnlen), public :: energyfile character(len=fnlen), public :: outname logical, public :: restart logical, public :: uniform type, public :: EBSDNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: numsx integer(kind=irg), public :: numsy integer(kind=irg), public :: binning integer(kind=irg), public :: nthreads integer(kind=irg), public :: energyaverage real(kind=sgl), public :: L real(kind=sgl), public :: thetac real(kind=sgl), public :: delta real(kind=sgl), public :: omega real(kind=sgl), public :: xpc real(kind=sgl), public :: ypc real(kind=sgl), public :: energymin real(kind=sgl), public :: energymax real(kind=sgl), public :: gammavalue real(kind=sgl), public :: axisangle (4) real(kind=sgl), public :: alphaBD real(kind=dbl), public :: beamcurrent real(kind=dbl), public :: dwelltime character(len=1), public :: maskpattern character(len=3), public :: scalingmode character(len=3), public :: eulerconvention character(len=3), public :: outputformat character(len=1), public :: spatialaverage character(len=fnlen), public :: anglefile character(len=fnlen), public :: masterfile character(len=fnlen), public :: energyfile character(len=fnlen), public :: datafile integer(kind=irg), public :: numangles integer(kind=irg), public :: numEbins integer(kind=irg), public :: numzbins integer(kind=irg), public :: nsx integer(kind=irg), public :: nsy integer(kind=irg), public :: num_el integer(kind=irg), public :: MCnthreads integer(kind=irg), public :: npx integer(kind=irg), public :: npy integer(kind=irg), public :: nE integer(kind=irg), public :: numset real(kind=dbl), public :: EkeV real(kind=dbl), public :: Ehistmin real(kind=dbl), public :: Ebinsize real(kind=dbl), public :: depthmax real(kind=dbl), public :: depthstep real(kind=dbl), public :: MCsig real(kind=dbl), public :: MComega character(len=4), public :: MCmode character(len=5), public :: anglemode character(len=6), public :: sqorhe character(len=8), public :: MCscversion character(len=8), public :: Masterscversion character(len=fnlen), public :: Masterprogname character(len=fnlen), public :: Masterxtalname character(len=fnlen), public :: Masterenergyfile character(len=fnlen), public :: MCprogname character(len=fnlen), public :: MCxtalname real(kind=dbl), public :: dmin integer(kind=irg), public :: totnum_el integer(kind=irg), public :: platid integer(kind=irg), public :: devid integer(kind=irg), public :: globalworkgrpsz integer(kind=irg), public :: multiplier type, public :: TKDNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: numsx integer(kind=irg), public :: numsy integer(kind=irg), public :: binning integer(kind=irg), public :: nthreads integer(kind=irg), public :: energyaverage real(kind=sgl), public :: L real(kind=sgl), public :: thetac real(kind=sgl), public :: delta real(kind=sgl), public :: omega real(kind=sgl), public :: xpc real(kind=sgl), public :: ypc real(kind=sgl), public :: energymin real(kind=sgl), public :: energymax real(kind=sgl), public :: gammavalue real(kind=sgl), public :: axisangle (4) real(kind=sgl), public :: alphaBD real(kind=dbl), public :: beamcurrent real(kind=dbl), public :: dwelltime character(len=1), public :: maskpattern character(len=3), public :: scalingmode character(len=3), public :: eulerconvention character(len=3), public :: outputformat character(len=1), public :: spatialaverage character(len=fnlen), public :: anglefile character(len=fnlen), public :: masterfile character(len=fnlen), public :: energyfile character(len=fnlen), public :: datafile integer(kind=irg), public :: numangles integer(kind=irg), public :: numEbins integer(kind=irg), public :: numzbins integer(kind=irg), public :: nsx integer(kind=irg), public :: nsy integer(kind=irg), public :: num_el integer(kind=irg), public :: MCnthreads integer(kind=irg), public :: npx integer(kind=irg), public :: npy integer(kind=irg), public :: nE integer(kind=irg), public :: numset real(kind=dbl), public :: EkeV real(kind=dbl), public :: Ehistmin real(kind=dbl), public :: Ebinsize real(kind=dbl), public :: depthmax real(kind=dbl), public :: depthstep real(kind=dbl), public :: MCsig real(kind=dbl), public :: MComega character(len=4), public :: MCmode character(len=5), public :: anglemode character(len=6), public :: sqorhe character(len=8), public :: MCscversion character(len=8), public :: Masterscversion character(len=fnlen), public :: Masterprogname character(len=fnlen), public :: Masterxtalname character(len=fnlen), public :: Masterenergyfile character(len=fnlen), public :: MCprogname character(len=fnlen), public :: MCxtalname real(kind=dbl), public :: dmin integer(kind=irg), public :: totnum_el integer(kind=irg), public :: platid integer(kind=irg), public :: devid integer(kind=irg), public :: globalworkgrpsz integer(kind=irg), public :: multiplier type, public :: EBSDdetparmscanNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: numdetparm integer(kind=irg), public :: numeuler real(kind=sgl), public :: DetParms (3) real(kind=sgl), public :: Eulertriplet (3) real(kind=sgl), public :: DetParmstepsize (3) real(kind=sgl), public :: Cubochoricstepsize (3) type, public :: EBSDoverlapNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: PatternAxisA (3) integer(kind=irg), public :: HorizontalAxisA (3) real(kind=sgl), public :: tA (3) real(kind=sgl), public :: tB (3) real(kind=sgl), public :: gA (3) real(kind=sgl), public :: gB (3) real(kind=sgl), public :: fracA character(len=fnlen), public :: masterfileA character(len=fnlen), public :: masterfileB character(len=fnlen), public :: datafile integer(kind=irg), public :: numset integer(kind=irg), public :: npx integer(kind=irg), public :: npy integer(kind=irg), public :: nE character(len=6), public :: sqorhe character(len=8), public :: Masterscversion character(len=fnlen), public :: Masterprogname character(len=fnlen), public :: masterfile character(len=fnlen), public :: Masterxtalname character(len=fnlen), public :: xtalnameA character(len=fnlen), public :: xtalnameB character(len=fnlen), public :: Masterenergyfile type, public :: EBSDclusterNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: NClusters integer(kind=irg), public :: NIterations integer(kind=irg), public :: NScanColumns integer(kind=irg), public :: NScanRows integer(kind=irg), public :: binfactor character(len=fnlen), public :: inputfilename character(len=fnlen), public :: groupname character(len=fnlen), public :: datasetname type, public :: ECPNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: fn_f (3) integer(kind=irg), public :: fn_s (3) integer(kind=irg), public :: nthreads integer(kind=irg), public :: npix integer(kind=irg), public :: gF (3) integer(kind=irg), public :: gS (3) integer(kind=irg), public :: tF (3) integer(kind=irg), public :: tS (3) real(kind=sgl), public :: thetac real(kind=sgl), public :: filmthickness character(len=1), public :: maskpattern character(len=fnlen), public :: xtalname character(len=fnlen), public :: xtalname2 character(len=fnlen), public :: energyfile character(len=fnlen), public :: filmfile character(len=fnlen), public :: subsfile character(len=fnlen), public :: masterfile character(len=fnlen), public :: datafile character(len=fnlen), public :: anglefile character(len=3), public :: eulerconvention real(kind=sgl), public :: gammavalue character(len=3), public :: outputformat real(kind=dbl), public :: sampletilt real(kind=sgl), public :: workingdistance real(kind=sgl), public :: Rin real(kind=sgl), public :: Rout integer(kind=irg), public :: numangle integer(kind=irg), public :: numangle_anglefile integer(kind=irg), public :: numEbins integer(kind=irg), public :: numzbins integer(kind=irg), public :: nsx integer(kind=irg), public :: nsy integer(kind=irg), public :: num_el integer(kind=irg), public :: MCnthreads integer(kind=irg), public :: npx integer(kind=irg), public :: npy integer(kind=irg), public :: nE integer(kind=irg), public :: numset integer(kind=irg), public :: npolar integer(kind=irg), public :: nazimuth real(kind=dbl), public :: EkeV real(kind=dbl), public :: Ehistmin real(kind=dbl), public :: Ebinsize real(kind=dbl), public :: depthmax real(kind=dbl), public :: depthstep real(kind=sgl), public :: dmin real(kind=dbl), public :: MCsigstart real(kind=dbl), public :: MCsigend real(kind=dbl), public :: MCsigstep real(kind=dbl), public :: MComega character(len=4), public :: MCmode character(len=5), public :: anglemode character(len=6), public :: sqorhe character(len=8), public :: MCscversion character(len=8), public :: Masterscversion character(len=fnlen), public :: Masterprogname character(len=fnlen), public :: Masterxtalname character(len=fnlen), public :: Masterenergyfile character(len=fnlen), public :: MCprogname character(len=fnlen), public :: MCxtalname type, public :: LACBEDNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: k (3) integer(kind=irg), public :: fn (3) integer(kind=irg), public :: maxHOLZ integer(kind=irg), public :: numthick integer(kind=irg), public :: npix integer(kind=irg), public :: nthreads real(kind=sgl), public :: voltage real(kind=sgl), public :: dmin real(kind=sgl), public :: convergence real(kind=sgl), public :: startthick real(kind=sgl), public :: thickinc real(kind=sgl), public :: minten character(len=fnlen), public :: xtalname character(len=fnlen), public :: outname type, public :: ECPMasterNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: npx integer(kind=irg), public :: Esel integer(kind=irg), public :: nthreads real(kind=sgl), public :: dmin character(len=fnlen), public :: compmode character(len=fnlen), public :: energyfile character(len=fnlen), public :: outname type, public :: ECPpatternNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: npix real(kind=sgl), public :: thetac real(kind=sgl), public :: k (3) character(len=fnlen), public :: masterfile character(len=fnlen), public :: outname type, public :: ECPZANameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: fn (3) integer(kind=irg), public :: k (3) integer(kind=irg), public :: npix integer(kind=irg), public :: nthreads real(kind=sgl), public :: dmin real(kind=sgl), public :: ktmax character(len=1), public :: maskpattern character(len=fnlen), public :: energyfile character(len=fnlen), public :: outname type, public :: PEDZANameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: k (3) integer(kind=irg), public :: fn (3) integer(kind=irg), public :: precsample integer(kind=irg), public :: precazimuthal integer(kind=irg), public :: npix integer(kind=irg), public :: nthreads real(kind=sgl), public :: voltage real(kind=sgl), public :: dmin real(kind=sgl), public :: precangle real(kind=sgl), public :: prechalfwidth real(kind=sgl), public :: thickness real(kind=sgl), public :: camlen character(len=5), public :: filemode character(len=fnlen), public :: xtalname character(len=fnlen), public :: outname type, public :: PEDkinNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: npix integer(kind=irg), public :: ncubochoric integer(kind=irg), public :: nthreads real(kind=sgl), public :: voltage real(kind=sgl), public :: dmin real(kind=sgl), public :: thickness real(kind=sgl), public :: rnmpp character(len=fnlen), public :: xtalname character(len=fnlen), public :: outname type, public :: ECCINameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: stdout integer(kind=irg), public :: nthreads integer(kind=irg), public :: k (3) integer(kind=irg), public :: nktstep integer(kind=irg), public :: DF_npix integer(kind=irg), public :: DF_npiy real(kind=sgl), public :: voltage real(kind=sgl), public :: dkt real(kind=sgl), public :: ktmax real(kind=sgl), public :: lauec (2) real(kind=sgl), public :: lauec2 (2) real(kind=sgl), public :: dmin real(kind=sgl), public :: DF_L real(kind=sgl), public :: DF_slice character(len=4), public :: dispmode character(len=4), public :: summode character(len=5), public :: progmode character(len=fnlen), public :: xtalname character(len=fnlen), public :: defectfilename character(len=fnlen), public :: dispfile character(len=fnlen), public :: dataname character(len=fnlen), public :: ECPname character(len=fnlen), public :: sgname type, public :: RFZNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: pgnum integer(kind=irg), public :: nsteps integer(kind=irg), public :: gridtype real(kind=dbl), public :: rodrigues (4) real(kind=dbl), public :: maxmisor real(kind=dbl), public :: conevector (3) real(kind=dbl), public :: semiconeangle character(len=fnlen), public :: samplemode character(len=fnlen), public :: euoutname character(len=fnlen), public :: cuoutname character(len=fnlen), public :: hooutname character(len=fnlen), public :: rooutname character(len=fnlen), public :: quoutname character(len=fnlen), public :: omoutname character(len=fnlen), public :: axoutname type, public :: DictIndxOpenCLListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: numexptsingle integer(kind=irg), public :: numdictsingle integer(kind=irg), public :: totnumexpt integer(kind=irg), public :: totnumdict integer(kind=irg), public :: imght integer(kind=irg), public :: imgwd integer(kind=irg), public :: nnk character(len=fnlen), public :: exptfile character(len=fnlen), public :: dictfile character(len=fnlen), public :: eulerfile logical, public :: MeanSubtraction logical, public :: patternflip type, public :: PEDKINIndxListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: npix integer(kind=irg), public :: ncubochoric real(kind=sgl), public :: voltage real(kind=sgl), public :: dmin real(kind=sgl), public :: thickness real(kind=sgl), public :: rnmpp character(len=fnlen), public :: xtalname integer(kind=irg), public :: numexptsingle integer(kind=irg), public :: numdictsingle integer(kind=irg), public :: ipf_ht integer(kind=irg), public :: ipf_wd integer(kind=irg), public :: nnk real(kind=sgl), public :: sgmax real(kind=sgl), public :: ww real(kind=sgl), public :: var character(len=fnlen), public :: exptfile character(len=fnlen), public :: datafile character(len=fnlen), public :: ctffile integer(kind=irg), public :: devid integer(kind=irg), public :: platid integer(kind=irg), public :: nthreads real(kind=sgl), public :: Igmax type, public :: DisorientationsNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: pgnum integer(kind=irg), public :: pgnum2 character(len=fnlen), public :: inputfile character(len=fnlen), public :: outputfile type, public :: AverageOrientationNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: nmuse integer(kind=irg), public :: reldisx integer(kind=irg), public :: reldisy logical, public :: oldformat character(len=fnlen), public :: dotproductfile character(len=fnlen), public :: averagectffile character(len=fnlen), public :: averagetxtfile character(len=fnlen), public :: disorientationmap type, public :: OrientationSimilarityNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: nmuse character(len=fnlen), public :: dotproductfile character(len=fnlen), public :: osmtiff type, public :: KAMNameListType Components Type Visibility Attributes Name Initial real(kind=sgl), public :: kamcutoff integer(kind=irg), public :: orav character(len=fnlen), public :: dotproductfile character(len=fnlen), public :: kamtiff type, public :: DvsDNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: nmuse real(kind=sgl), public :: maxdis real(kind=sgl), public :: minang real(kind=sgl), public :: maxang character(len=fnlen), public :: dotproductfile character(len=fnlen), public :: outfile character(len=fnlen), public :: povfile character(len=fnlen), public :: xtalfile type, public :: EBSDIndexingNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: ncubochoric integer(kind=irg), public :: numexptsingle integer(kind=irg), public :: numdictsingle integer(kind=irg), public :: ipf_ht integer(kind=irg), public :: ipf_wd integer(kind=irg), public :: nnk integer(kind=irg), public :: nnav integer(kind=irg), public :: nosm integer(kind=irg), public :: maskradius character(len=fnlen), public :: exptfile integer(kind=irg), public :: numsx integer(kind=irg), public :: numsy integer(kind=irg), public :: binning integer(kind=irg), public :: nthreads integer(kind=irg), public :: energyaverage integer(kind=irg), public :: devid integer(kind=irg), public :: platid integer(kind=irg), public :: nregions real(kind=sgl), public :: L real(kind=sgl), public :: thetac real(kind=sgl), public :: delta real(kind=sgl), public :: omega real(kind=sgl), public :: xpc real(kind=sgl), public :: ypc real(kind=sgl), public :: energymin real(kind=sgl), public :: energymax real(kind=sgl), public :: gammavalue real(kind=sgl), public :: axisangle (4) real(kind=dbl), public :: beamcurrent real(kind=dbl), public :: dwelltime real(kind=dbl), public :: hipassw character(len=1), public :: maskpattern character(len=3), public :: scalingmode character(len=1), public :: spatialaverage character(len=fnlen), public :: anglefile character(len=fnlen), public :: masterfile character(len=fnlen), public :: energyfile character(len=fnlen), public :: datafile character(len=fnlen), public :: tmpfile character(len=fnlen), public :: ctffile character(len=fnlen), public :: avctffile character(len=fnlen), public :: angfile character(len=fnlen), public :: eulerfile character(len=fnlen), public :: dictfile character(len=fnlen), public :: indexingmode integer(kind=irg), public :: numangles integer(kind=irg), public :: numEbins integer(kind=irg), public :: numzbins integer(kind=irg), public :: nsx integer(kind=irg), public :: nsy integer(kind=irg), public :: num_el integer(kind=irg), public :: MCnthreads integer(kind=irg), public :: npx integer(kind=irg), public :: npy integer(kind=irg), public :: nE integer(kind=irg), public :: numset real(kind=dbl), public :: EkeV real(kind=dbl), public :: Ehistmin real(kind=dbl), public :: Ebinsize real(kind=dbl), public :: depthmax real(kind=dbl), public :: depthstep real(kind=dbl), public :: MCsig real(kind=dbl), public :: MComega real(kind=sgl), public :: dmin real(kind=sgl), public :: StepX real(kind=sgl), public :: StepY real(kind=sgl), public :: WD character(len=4), public :: MCmode character(len=5), public :: anglemode character(len=6), public :: sqorhe character(len=8), public :: MCscversion character(len=8), public :: Masterscversion character(len=fnlen), public :: Masterprogname character(len=fnlen), public :: Masterxtalname character(len=fnlen), public :: Masterenergyfile character(len=fnlen), public :: MCprogname character(len=fnlen), public :: MCxtalname type, public :: TKDIndexingNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: ncubochoric integer(kind=irg), public :: numexptsingle integer(kind=irg), public :: numdictsingle integer(kind=irg), public :: ipf_ht integer(kind=irg), public :: ipf_wd integer(kind=irg), public :: nnk integer(kind=irg), public :: nnav integer(kind=irg), public :: nosm integer(kind=irg), public :: maskradius character(len=fnlen), public :: exptfile integer(kind=irg), public :: numsx integer(kind=irg), public :: numsy integer(kind=irg), public :: binning integer(kind=irg), public :: nthreads integer(kind=irg), public :: energyaverage integer(kind=irg), public :: devid integer(kind=irg), public :: platid integer(kind=irg), public :: nregions real(kind=sgl), public :: L real(kind=sgl), public :: thetac real(kind=sgl), public :: delta real(kind=sgl), public :: omega real(kind=sgl), public :: xpc real(kind=sgl), public :: ypc real(kind=sgl), public :: energymin real(kind=sgl), public :: energymax real(kind=sgl), public :: gammavalue real(kind=sgl), public :: axisangle (4) real(kind=dbl), public :: beamcurrent real(kind=dbl), public :: dwelltime real(kind=dbl), public :: hipassw character(len=1), public :: maskpattern character(len=3), public :: scalingmode character(len=1), public :: spatialaverage character(len=fnlen), public :: anglefile character(len=fnlen), public :: masterfile character(len=fnlen), public :: energyfile character(len=fnlen), public :: datafile character(len=fnlen), public :: tmpfile character(len=fnlen), public :: ctffile character(len=fnlen), public :: avctffile character(len=fnlen), public :: angfile character(len=fnlen), public :: eulerfile character(len=fnlen), public :: dictfile character(len=fnlen), public :: indexingmode integer(kind=irg), public :: numangles integer(kind=irg), public :: numEbins integer(kind=irg), public :: numzbins integer(kind=irg), public :: nsx integer(kind=irg), public :: nsy integer(kind=irg), public :: num_el integer(kind=irg), public :: MCnthreads integer(kind=irg), public :: npx integer(kind=irg), public :: npy integer(kind=irg), public :: nE integer(kind=irg), public :: numset real(kind=dbl), public :: EkeV real(kind=dbl), public :: Ehistmin real(kind=dbl), public :: Ebinsize real(kind=dbl), public :: depthmax real(kind=dbl), public :: depthstep real(kind=dbl), public :: MCsig real(kind=dbl), public :: MComega real(kind=sgl), public :: dmin real(kind=sgl), public :: StepX real(kind=sgl), public :: StepY real(kind=sgl), public :: WD character(len=4), public :: MCmode character(len=5), public :: anglemode character(len=6), public :: sqorhe character(len=8), public :: MCscversion character(len=8), public :: Masterscversion character(len=fnlen), public :: Masterprogname character(len=fnlen), public :: Masterxtalname character(len=fnlen), public :: Masterenergyfile character(len=fnlen), public :: MCprogname character(len=fnlen), public :: MCxtalname type, public :: ECPIndexingNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: ncubochoric integer(kind=irg), public :: numexptsingle integer(kind=irg), public :: numdictsingle integer(kind=irg), public :: totnumexpt integer(kind=irg), public :: maskradius integer(kind=irg), public :: nnk integer(kind=irg), public :: platid integer(kind=irg), public :: devid integer(kind=irg), public :: nregions character(len=fnlen), public :: exptfile integer(kind=irg), public :: fn_f (3) integer(kind=irg), public :: fn_s (3) integer(kind=irg), public :: nthreads integer(kind=irg), public :: npix integer(kind=irg), public :: gF (3) integer(kind=irg), public :: gS (3) integer(kind=irg), public :: tF (3) integer(kind=irg), public :: tS (3) real(kind=sgl), public :: thetac real(kind=sgl), public :: filmthickness character(len=1), public :: maskpattern character(len=fnlen), public :: xtalname character(len=fnlen), public :: xtalname2 character(len=fnlen), public :: energyfile character(len=fnlen), public :: filmfile character(len=fnlen), public :: subsfile character(len=fnlen), public :: masterfile character(len=fnlen), public :: datafile character(len=fnlen), public :: tmpfile character(len=fnlen), public :: ctffile character(len=fnlen), public :: anglefile character(len=3), public :: eulerconvention real(kind=sgl), public :: gammavalue character(len=3), public :: outputformat real(kind=dbl), public :: sampletilt real(kind=sgl), public :: workingdistance real(kind=sgl), public :: Rin real(kind=sgl), public :: Rout integer(kind=irg), public :: numangle integer(kind=irg), public :: numangle_anglefile integer(kind=irg), public :: numEbins integer(kind=irg), public :: numzbins integer(kind=irg), public :: nsx integer(kind=irg), public :: nsy integer(kind=irg), public :: num_el integer(kind=irg), public :: MCnthreads integer(kind=irg), public :: npx integer(kind=irg), public :: npy integer(kind=irg), public :: nE integer(kind=irg), public :: numset integer(kind=irg), public :: npolar integer(kind=irg), public :: nazimuth real(kind=dbl), public :: EkeV real(kind=dbl), public :: Ehistmin real(kind=dbl), public :: Ebinsize real(kind=dbl), public :: depthmax real(kind=dbl), public :: depthstep real(kind=sgl), public :: dmin real(kind=dbl), public :: MCsigstart real(kind=dbl), public :: MCsigend real(kind=dbl), public :: MCsigstep real(kind=dbl), public :: MComega character(len=4), public :: MCmode character(len=5), public :: anglemode character(len=6), public :: sqorhe character(len=8), public :: MCscversion character(len=8), public :: Masterscversion character(len=fnlen), public :: Masterprogname character(len=fnlen), public :: Masterxtalname character(len=fnlen), public :: Masterenergyfile character(len=fnlen), public :: MCprogname character(len=fnlen), public :: MCxtalname type, public :: ZAdefectnameListType Components Type Visibility Attributes Name Initial character(len=fnlen), public :: xtalname real(kind=sgl), public :: voltage integer(kind=irg), public :: kk (3) real(kind=sgl), public :: lauec (2) real(kind=sgl), public :: dmin character(len=fnlen), public :: progmode character(len=fnlen), public :: STEMnmlfile character(len=fnlen), public :: foilnmlfile real(kind=sgl), public :: DF_L real(kind=sgl), public :: DF_npix real(kind=sgl), public :: DF_npiy real(kind=sgl), public :: DF_slice integer(kind=irg), public :: dinfo character(len=fnlen), public :: sgname integer(kind=irg), public :: numdisl integer(kind=irg), public :: numsf integer(kind=irg), public :: numinc integer(kind=irg), public :: numvoids character(len=fnlen), public :: voidname character(len=fnlen), public :: dislname character(len=fnlen), public :: sfname character(len=fnlen), public :: incname character(len=fnlen), public :: dispfile character(len=fnlen), public :: dispmode character(len=fnlen), public :: dataname integer(kind=irg), public :: t_interval type, public :: EMDPFitListType Components Type Visibility Attributes Name Initial character(len=fnlen), public :: modalityname character(len=fnlen), public :: masterfile character(len=fnlen), public :: exptfile real(kind=dbl), public :: rhobeg real(kind=dbl), public :: rhoend logical, public :: verbose logical, public :: mask real(kind=irg), public :: maskradius real(kind=sgl), public :: gammavalue real(kind=sgl), public :: phi real(kind=sgl), public :: phi1 real(kind=sgl), public :: phi2 real(kind=sgl), public :: L real(kind=sgl), public :: thetac real(kind=sgl), public :: delta real(kind=sgl), public :: omega integer(kind=irg), public :: numsx integer(kind=irg), public :: numsy integer(kind=irg), public :: binning real(kind=sgl), public :: xpc real(kind=sgl), public :: ypc real(kind=sgl), public :: beamcurrent real(kind=sgl), public :: dwelltime integer(kind=irg), public :: npix real(kind=sgl), public :: Rin real(kind=sgl), public :: Rout real(kind=sgl), public :: thetacone real(kind=sgl), public :: sampletilt real(kind=sgl), public :: workingdistance real(kind=sgl), public :: step_xpc real(kind=sgl), public :: step_ypc real(kind=sgl), public :: step_L real(kind=sgl), public :: step_phi1 real(kind=sgl), public :: step_phi real(kind=sgl), public :: step_phi2 real(kind=sgl), public :: step_thetacone integer(kind=irg), public :: nrun integer(kind=irg), public :: nregions character(len=2), public :: metric type, public :: EMDPFit4ListType Components Type Visibility Attributes Name Initial character(len=fnlen), public :: modalityname character(len=fnlen), public :: masterfile character(len=fnlen), public :: exptfile_pat1 character(len=fnlen), public :: exptfile_pat2 character(len=fnlen), public :: exptfile_pat3 character(len=fnlen), public :: exptfile_pat4 real(kind=dbl), public :: rhobeg real(kind=dbl), public :: rhoend logical, public :: verbose logical, public :: mask real(kind=irg), public :: maskradius real(kind=sgl), public :: gammavalue real(kind=sgl), public :: phi_pat1 real(kind=sgl), public :: phi1_pat1 real(kind=sgl), public :: phi2_pat1 real(kind=sgl), public :: phi_pat2 real(kind=sgl), public :: phi1_pat2 real(kind=sgl), public :: phi2_pat2 real(kind=sgl), public :: phi_pat3 real(kind=sgl), public :: phi1_pat3 real(kind=sgl), public :: phi2_pat3 real(kind=sgl), public :: phi_pat4 real(kind=sgl), public :: phi1_pat4 real(kind=sgl), public :: phi2_pat4 real(kind=sgl), public :: L real(kind=sgl), public :: thetac real(kind=sgl), public :: delta real(kind=sgl), public :: omega integer(kind=irg), public :: numsx integer(kind=irg), public :: numsy integer(kind=irg), public :: binning real(kind=sgl), public :: xpc real(kind=sgl), public :: ypc real(kind=sgl), public :: beamcurrent real(kind=sgl), public :: dwelltime integer(kind=irg), public :: npix real(kind=sgl), public :: Rin real(kind=sgl), public :: Rout real(kind=sgl), public :: thetacone real(kind=sgl), public :: sampletilt real(kind=sgl), public :: workingdistance real(kind=sgl), public :: step_xpc real(kind=sgl), public :: step_ypc real(kind=sgl), public :: step_L real(kind=sgl), public :: step_phi1 real(kind=sgl), public :: step_phi real(kind=sgl), public :: step_phi2 real(kind=sgl), public :: step_thetacone integer(kind=irg), public :: nrun integer(kind=irg), public :: pixx_pat1 integer(kind=irg), public :: pixy_pat1 integer(kind=irg), public :: pixx_pat2 integer(kind=irg), public :: pixy_pat2 integer(kind=irg), public :: pixx_pat3 integer(kind=irg), public :: pixy_pat3 integer(kind=irg), public :: pixx_pat4 integer(kind=irg), public :: pixy_pat4 real(kind=sgl), public :: stepx real(kind=sgl), public :: stepy integer(kind=irg), public :: nregions character(len=2), public :: metric type, public :: ECPSingleNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: nthreads integer(kind=irg), public :: npix real(kind=sgl), public :: thetac character(len=1), public :: maskpattern character(len=fnlen), public :: xtalname character(len=fnlen), public :: energyfile character(len=fnlen), public :: datafile character(len=3), public :: eulerconvention real(kind=sgl), public :: gammavalue real(kind=dbl), public :: sampletilt real(kind=sgl), public :: workingdistance real(kind=sgl), public :: Rin real(kind=sgl), public :: Rout real(kind=dbl), public :: phi1 real(kind=dbl), public :: phi real(kind=dbl), public :: phi2 real(kind=sgl), public :: dmin type, public :: STEMDCINameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: nthreads real(kind=sgl), public :: voltage character(len=4), public :: progmode character(len=fnlen), public :: xtalname integer(kind=irg), public :: kk (3) real(kind=sgl), public :: lauec (2) character(len=fnlen), public :: STEMnmlfile character(len=fnlen), public :: dataname character(len=fnlen), public :: defectfilename character(len=3), public :: dispmode character(len=fnlen), public :: dispfile integer(kind=irg), public :: output integer(kind=irg), public :: dinfo integer(kind=irg), public :: t_interval real(kind=sgl), public :: DF_L integer(kind=irg), public :: DF_npix integer(kind=irg), public :: DF_npiy real(kind=sgl), public :: DF_slice real(kind=sgl), public :: dmin type, public :: SRdefectNameListType Components Type Visibility Attributes Name Initial real(kind=sgl), public :: DF_L integer(kind=irg), public :: DF_npix integer(kind=irg), public :: DF_npiy real(kind=sgl), public :: DF_slice real(kind=sgl), public :: dmin character(len=4), public :: progmode integer(kind=irg), public :: dinfo character(len=3), public :: outputformat integer(kind=irg), public :: output character(len=fnlen), public :: dataname integer(kind=irg), public :: t_interval character(len=fnlen), public :: dispfile integer(kind=irg), public :: nthreads character(len=3), public :: dispmode character(len=fnlen), public :: xtalname real(kind=sgl), public :: voltage integer(kind=irg), public :: SRG (3) integer(kind=irg), public :: Grange real(kind=sgl), public :: GLaue character(len=fnlen), public :: STEMnmlfile character(len=fnlen), public :: defectfilename The following are now in ZAdefectnameListType type, public :: RefineOrientationtype Components Type Visibility Attributes Name Initial integer(kind=irg), public :: nthreads character(len=fnlen), public :: dotproductfile character(len=fnlen), public :: ctffile real(kind=sgl), public :: step integer(kind=irg), public :: nmis integer(kind=irg), public :: niter type, public :: FitOrientationPStype Components Type Visibility Attributes Name Initial integer(kind=irg), public :: nthreads character(len=fnlen), public :: dotproductfile character(len=fnlen), public :: ctffile real(kind=sgl), public :: step real(kind=sgl), public :: angleaxis (4) type, public :: PFInversionNameListType Components Type Visibility Attributes Name Initial integer(kind=irg), public :: nLam integer(kind=irg), public :: nSIRT integer(kind=irg), public :: ncub integer(kind=irg), public :: nfiles character(len=fnlen), public :: xtalname character(len=fnlen), public :: flist (10) character(len=fnlen), public :: datafile","tags":"","loc":"module/namelisttypedefs.html","title":"NameListTypedefs – Fortran Program"},{"text":"Uses: local module~~noise~~UsesGraph module~noise noise local local local->module~noise Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief Poisson noise routine\n @date 03/26/14 MDG 1.0 added to EMsoft from earlier EBSD version Functions alogam ran POIDEV Functions public recursive function alogam (x, ifault) ALOGAM computes the logarithm of the Gamma function. Arguments Type Intent Optional Attributes Name real(kind=8) :: x integer(kind=4) :: ifault Return Value real(kind=8) public function ran (idum) Arguments Type Intent Optional Attributes Name integer(kind=K4B), intent(inout) :: idum Return Value real(kind=sgl) public function POIDEV (XM, IDUM) Arguments Type Intent Optional Attributes Name real(kind=sgl), intent(in) :: XM integer(kind=K4B), intent(inout) :: IDUM Return Value real(kind=sgl)","tags":"","loc":"module/noise.html","title":"noise – Fortran Program"},{"text":"Uses: local module~~others~~UsesGraph module~others others local local local->module~others Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University / and others\n @brief routines written by other people, included with permission, and adapted by MDG\n @details  This is the Weickenmeier-Kohl implementation of their scattering factors\n  and absorptive form factors; it is included with permission from H. Kohl. Note This code was originally f77, and was converted to f90 by MDG [5/22/01];\n core functionality is unchanged from the f77 version, but the output statements\n were adapted to the current EMsoft package standard.\n @date   10/13/98 MDG 1.0 original\n @date    5/22/01 MDG 2.0 f90\n @date   11/27/01 MDG 2.1 added kind support Used By module~~others~~UsedByGraph module~others others module~simann SimAnn module~others->module~simann Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Functions FSCATT WEKO FPHON RI1 RI2 RIH1 RIH2 RIH3 EI FCORE Subroutines GETWK SSORT qsortd Functions public recursive function FSCATT (G, UL, Z, SYMBOL, ACCVLT, ABSFLG, ACCFLG, DWFLG) @author Marc De Graef, Carnegie Mellon University\n @author A. Weickenmeier, original f77 code\n @brief computes the complex scattering amplitude\n @details 'use's error and local modules; Weickenmeier's original comments\n and notes are left unchanged in the source code.\n @date 5/21/01 MDG 1.0 original f90 translation\n @date 3/21/13 MDG 2.0 updated IO statements Arguments Type Intent Optional Attributes Name real :: G real :: UL integer(kind=irg) :: Z character(len=2) :: SYMBOL real :: ACCVLT integer(kind=irg) :: ABSFLG logical :: ACCFLG logical :: DWFLG Return Value complex public function WEKO (A, B, S) Arguments Type Intent Optional Attributes Name real(kind=sgl) :: A (4) real(kind=sgl) :: B (4) real :: S Return Value real public function FPHON (G, UL, A, B) Arguments Type Intent Optional Attributes Name real :: G real :: UL real(kind=sgl) :: A (4) real(kind=sgl) :: B (4) Return Value real public function RI1 (BI, BJ, G) Arguments Type Intent Optional Attributes Name real :: BI real :: BJ real :: G Return Value real public function RI2 (BI, BJ, G, U) Arguments Type Intent Optional Attributes Name real :: BI real :: BJ real :: G real :: U Return Value real public function RIH1 (X1, X2, X3) Arguments Type Intent Optional Attributes Name real :: X1 real :: X2 real :: X3 Return Value real public function RIH2 (X) Arguments Type Intent Optional Attributes Name real :: X Return Value real public function RIH3 (X) Arguments Type Intent Optional Attributes Name real :: X Return Value real public function EI (X) Arguments Type Intent Optional Attributes Name real :: X Return Value real public function FCORE (G, Z, ACCVLT) Arguments Type Intent Optional Attributes Name real :: G integer :: Z real :: ACCVLT Return Value real Subroutines public subroutine GETWK (Z, SYMBOL, A, B) Arguments Type Intent Optional Attributes Name integer :: Z character(len=2) :: SYMBOL real(kind=sgl) :: A (4) real(kind=sgl) :: B (4) public subroutine SSORT (X, Y, N, KFLAG) @author Taken from http://www.personal.psu.edu/jhm/f90/examples/sort/sorthalf.f\n @brief sort the array\n Parameters described in the program Arguments Type Intent Optional Attributes Name real :: X (*) integer :: Y (*) integer :: N integer :: KFLAG public subroutine qsortd (x, ind, n) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: x (n) integer, intent(out) :: ind (n) integer, intent(in) :: n","tags":"","loc":"module/others.html","title":"others – Fortran Program"},{"text":"Uses: local typedefs module~~pedmod~~UsesGraph module~pedmod PEDmod typedefs typedefs typedefs->module~pedmod local local local->module~pedmod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Saransh Singh, Carnegie Mellon University\n @brief all things related to precession electron diffraction\n @date 04/18/16 SS 1.0 original Subroutines CalcKINPEDPatternSingle Denoise_PED Denoise_Pattern ctfped_writeFile Subroutines public recursive subroutine CalcKINPEDPatternSingle (pednl, cell, reflistarray, sanglearray, nref, qu, pedpattern) @author Saransh Singh, Carnegie Mellon University\n @brief calculate single PED pattern; used in the EMPEDDI program\n @param pednl PED name list structure\n @param cell cell structure\n @param reflist list of possible reflections\n @param nref number of reflections in master list\n @param qu orientation of xtal\n @param pedpattern calculated kinematic ped pattern\n @date 06/24/14  SS 1.0 original\n @date 04/28/16  SS 1.1 corrected array bound error Arguments Type Intent Optional Attributes Name type(PEDKINIndxListType), intent(in) :: pednl type(unitcell), pointer :: cell integer(kind=irg), intent(in) :: reflistarray (3,nref) real(kind=sgl), intent(in) :: sanglearray (nref) integer(kind=irg), intent(in) :: nref real(kind=sgl), intent(in) :: qu (4) real(kind=sgl), intent(out) :: pedpattern (1:pednl%npix,1:pednl%npix) public recursive subroutine Denoise_PED (pednl, img_in, img_out) @author Saransh Singh, Carnegie Mellon University\n @brief Denoise a kinematical PED pattern\n @param pednl namelist file for PED\n @date 11/23/15  SS 1.0 original Arguments Type Intent Optional Attributes Name type(PEDKINIndxListType), intent(in) :: pednl real(kind=sgl), intent(in), target :: img_in (1:pednl%npix**2) real(kind=sgl), intent(out) :: img_out (1:pednl%npix**2) public recursive subroutine Denoise_Pattern (flx, fly, fpf, fpowp, fsigma_w, fprinf, fnoisinf, ficd, img_in, img_out) bind(C, name = \"0\") @author Saransh Singh, Carnegie Mellon University\n @brief Denoise an arbitrary pattern\n @param pednl namelist file for PED\n @date 11/23/15  SS 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: flx integer(kind=irg), intent(in) :: fly real(kind=sgl), intent(in) :: fpf real(kind=sgl), intent(in) :: fpowp real(kind=sgl), intent(in) :: fsigma_w real(kind=sgl), intent(in) :: fprinf real(kind=sgl), intent(in) :: fnoisinf integer(kind=irg), intent(in) :: ficd real(kind=sgl), intent(in), target :: img_in (1:flx*fly) real(kind=sgl), intent(out) :: img_out (1:flx*fly) public recursive subroutine ctfped_writeFile (pednl, ipar, indexmain, eulerarray, resultmain) @author Saransh Singh, Carnegie Mellon University\n @brief subroutine to write ctf file for ped indexing program\n @param pednl namelist file for PED\n @param ipar  some integer parameters passed to the subroutine\n @param indexmain indices for top nnk match\n @param eulerarray main euler angle list for the RFZ sampling\n @param resultmain list of dot products for all nnk matches \n @date 04/27/16  SS 1.0 original Arguments Type Intent Optional Attributes Name type(PEDKINIndxListType), intent(inout) :: pednl integer(kind=irg), intent(in) :: ipar (10) integer(kind=irg), intent(in) :: indexmain (ipar(1),ipar(2)) real(kind=sgl), intent(in) :: eulerarray (3,ipar(4)) real(kind=sgl), intent(in) :: resultmain (ipar(1),ipar(2))","tags":"","loc":"module/pedmod.html","title":"PEDmod – Fortran Program"},{"text":"Subroutines ForwardProjection BackProjection Subroutines public recursive subroutine ForwardProjection (ncub, ODF, PFhkl, nLam, PFLam, pgnum) bind(c, name=\"0\") @author Saransh Singh, Carnegie Mellon University\n @brief forward projection from ODF in cubochoric space to IPF in Lambert space\n @param ODF         orientation distribution function\n @param ncub        number of bins in semi-edge in x,y and z directions\n @param PFhkl       hkl indices of the specific pole figure\n @param nLam        bins in the output along semi-edge in Lambert projection\n @out PFLam         Pole figure in Lambert projection\n @date 11/07/16     SS 1.0 original\n @date 11/10/16     SS 1.1 added symmetry; all integration done in FZ\n @date 12/08/16     SS 1.2 all computations in quaternions to avoid infinity problem Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: ncub real(kind=dbl), intent(in) :: ODF (-ncub:ncub,-ncub:ncub,-ncub:ncub) integer(kind=irg), intent(in) :: PFhkl (3) integer(kind=irg), intent(in) :: nLam real(kind=dbl), intent(out) :: PFLam (-nLam:nLam,-nLam:nLam) integer(kind=irg), intent(in) :: pgnum public recursive subroutine BackProjection (ncub, ODF, PFhkl, nLam, PFLam, pgnum) bind(c, name = \"0\") @author Saransh Singh, Carnegie Mellon University\n @brief back projection from PF in Lambert space to ODF in cubochoric space\n @param ncub     number of bins in semi-edge in x,y and z directions\n @param PFhkl    hkl indices of the specific pole figure\n @param nLam     bins in the output along semi-edge in Lambert projection\n @param PFLam    Pole figure in Lambert projection\n @out ODF        orientation distribution function\n @date 11/07/16  SS 1.0 original\n @date 11/10/16  SS 1.1 added symmetry; all integration done in FZ\n @date 12/08/16  SS 1.2 all computations in quaternion to avoid infinity problem Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: ncub real(kind=dbl), intent(out) :: ODF (-ncub:ncub,-ncub:ncub,-ncub:ncub) integer(kind=irg), intent(in) :: PFhkl (3) integer(kind=irg), intent(in) :: nLam real(kind=dbl), intent(in) :: PFLam (-nLam:nLam,-nLam:nLam) integer(kind=irg), intent(in) :: pgnum","tags":"","loc":"module/pfinversion.html","title":"PFInversion – Fortran Program"},{"text":"Uses: local files io module~~pgm~~UsesGraph module~pgm pgm io io io->module~pgm local local local->module~pgm files files files->module~pgm Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief routine to write an image to a pgm file\n @date 1/5/99   MDG 1.0 original\n @date 6/9/14   MDG 2.0 removed global variables Used By module~~pgm~~UsedByGraph module~pgm pgm program~dispfield dispfield module~pgm->program~dispfield Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Subroutines PGM_Write_File Subroutines public recursive subroutine PGM_Write_File (fname, nx, ny, image) Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: fname integer(kind=irg), intent(in) :: nx integer(kind=irg), intent(in) :: ny integer(kind=irg), intent(in) :: image (nx,ny)","tags":"","loc":"module/pgm.html","title":"pgm – Fortran Program"},{"text":"Uses: io local files rotations constants Lambert quaternions module~~povray~~UsesGraph module~povray povray module~constants constants module~constants->module~povray quaternions quaternions quaternions->module~povray io io io->module~povray Lambert Lambert Lambert->module~povray files files files->module~povray rotations rotations rotations->module~povray local local local->module~povray local->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief all povray-related routines\n @details routines to generate output for PoVray file creation; this is mostly\n used for the visualization of orientation data sets in one of the many\n representations and fundamental zones...\n @date  09/08/16 MDG 1.0 original Subroutines PoVRay_openFile PoVRay_setCamera PoVRay_setLightSource PoVRay_addEulerBox PoVRay_declare_DF3file PoVRay_write_DF3file PoVRay_addWireFrameSphere PoVRay_addReferenceFrame PoVRay_addSphere PoVRay_addCylinder PoVRay_addCubochoricCube PoVRay_getpos_FZ432 PoVRay_getpos_FZ23 PoVRay_getpos_FZ622 PoVRay_getpos_FZ422 PoVRay_getpos_FZ32 PoVRay_getpos_FZ222 PoVRay_drawFZ PoVRay_initFZ2 PoVRay_initFZ3 PoVRay_initFZ4 PoVRay_initFZ6 Subroutines public recursive subroutine PoVRay_openFile (dunit, povray_filename, nmlfile) @author Marc De Graef, Carnegie Mellon University\n @brief  add the camera command to the current PoVRay file\n @param dunit output unit number\n @param locationline string that defines the camera position\n @date    09/08/16 MDG 1.0 original\n @date    01/30/17 MDG 1.1 added optional name list file variable Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit character(len=fnlen), intent(in) :: povray_filename character(len=fnlen), intent(in), optional :: nmlfile public recursive subroutine PoVRay_setCamera (dunit, locationline, skyline) @author Marc De Graef, Carnegie Mellon University\n @brief  add the camera command to the current PoVRay file\n @param dunit output unit number\n @param locationline string that defines the camera position\n @date    09/08/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit character(len=fnlen), intent(in) :: locationline character(len=fnlen), intent(in), optional :: skyline public recursive subroutine PoVRay_setLightSource (dunit, lightline, nobackground) @author Marc De Graef, Carnegie Mellon University\n @brief  add a light command to the current PoVRay file\n @param dunit output unit number\n @param lightline string that defines the camera position\n @date    09/08/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit character(len=fnlen), intent(in) :: lightline logical, intent(in), optional :: nobackground public recursive subroutine PoVRay_addEulerBox (dunit) @author Marc De Graef, Carnegie Mellon University\n @brief  add a wireframe Euler Box to the current PoVRay file\n @param dunit output unit number\n @param sphereRadius radius of sphere\n @date    11/23/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit public recursive subroutine PoVRay_declare_DF3file (dunit, df3name, levelset) @author Marc De Graef, Carnegie Mellon University\n @brief set up the code to include a 3D density field (df3) file\n @param dunit output unit number\n @param df3 file name\n @param levelset if TRUE, then different colors are used for level contours\n @date    11/23/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit character(len=fnlen), intent(in) :: df3name logical, intent(in), optional :: levelset public recursive subroutine PoVRay_write_DF3file (dunit, df3name, volume, ndims, scalingmode) @author Marc De Graef, Carnegie Mellon University\n @brief set up the code to include a 3D density field (df3) file\n @param dunit output unit number\n @param df3 file name\n @param volume the volume array to be written to the file\n @param ndims dimensions of the volume array\n @param scalingmode  'lin' or 'log' or 'lev'\n @date    11/23/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit character(len=fnlen), intent(in) :: df3name real(kind=sgl), intent(inout) :: volume (-ndims(1):ndims(1),-ndims(2):ndims(2),-ndims(3):ndims(3)) integer(kind=irg), intent(in) :: ndims (3) character(len=3), intent(in) :: scalingmode public recursive subroutine PoVRay_addWireFrameSphere (dunit, sphereRadius) @author Marc De Graef, Carnegie Mellon University\n @brief  add a wireframe sphere to the current PoVRay file\n @param dunit output unit number\n @param sphereRadius radius of sphere\n @date    09/08/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit real(kind=dbl), intent(in) :: sphereRadius public recursive subroutine PoVRay_addReferenceFrame (dunit, ac, cylr) @author Marc De Graef, Carnegie Mellon University\n @brief  add a reference frame to the current PoVRay file\n @param dunit output unit number\n @param ac maximum semi-length of axis\n @date    09/08/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit real(kind=dbl), intent(in) :: ac real(kind=dbl), intent(in), optional :: cylr public recursive subroutine PoVRay_addSphere (dunit, ctr, radius, rgb) @author Marc De Graef, Carnegie Mellon University\n @brief  add a sphere to the current PoVRay file\n @param dunit output unit number\n @param ctr center coordinates of the sphere\n @param radius sphere radius\n @param rgb color triplet (RGB)\n @date    09/08/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit real(kind=dbl), intent(in) :: ctr (3) real(kind=dbl), intent(in) :: radius real(kind=sgl), intent(in) :: rgb (3) public recursive subroutine PoVRay_addCylinder (dunit, p1, p2, radius, rgb) @author Marc De Graef, Carnegie Mellon University\n @brief  add a cylinder to the current PoVRay file\n @param dunit output unit number\n @param p1 starting point of cylinder (on axis)\n @param p2 end point of cylinder (on axis)\n @param radius cylinder radius\n @param rgb color triplet (RGB)\n @date    09/08/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit real(kind=dbl), intent(in) :: p1 (3) real(kind=dbl), intent(in) :: p2 (3) real(kind=dbl), intent(in) :: radius real(kind=sgl), intent(in) :: rgb (3) public recursive subroutine PoVRay_addCubochoricCube (dunit) @author Marc De Graef, Carnegie Mellon University\n @brief  add a reference frame to the current PoVRay file\n @param dunit output unit number\n @date    09/08/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit public recursive subroutine PoVRay_getpos_FZ432 (dims, cpos, s_edge, t_edge, ns, d, nt, MFZ) @author Marc De Graef, Carnegie Mellon University\n @brief initialize the PoVRay output for rotational group 432\n @param dims dimensions for subsequent arrays\n @param cpos vertex coordinates\n @param s_edge first set of edge connectivities\n @param t_edge second set of edge connectivities\n @param ns, d, nt  auxiliary parameters\n @param MFZ (optional) return coordinates for Mackenzie FZ instead of regular FZ\n @date    09/10/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dims (3) real(kind=dbl), intent(inout) :: cpos (3,dims(1)) integer(kind=irg), intent(inout) :: s_edge (2,dims(2)) integer(kind=irg), intent(inout) :: t_edge (2,dims(3)) integer(kind=irg), intent(out) :: ns real(kind=dbl), intent(out) :: d integer(kind=irg), intent(out) :: nt logical, intent(in), optional :: MFZ public recursive subroutine PoVRay_getpos_FZ23 (dims, cpos, s_edge, t_edge, ns, d, nt, MFZ) @author Marc De Graef, Carnegie Mellon University\n @brief initialize the PoVRay output for rotational group 23\n @param dims dimensions for subsequent arrays\n @param cpos vertex coordinates\n @param s_edge first set of edge connectivities\n @param t_edge second set of edge connectivities\n @param ns, d, nt  auxiliary parameters\n @param MFZ (optional) return coordinates for Mackenzie FZ instead of regular FZ\n @date    09/10/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dims (3) real(kind=dbl), intent(inout) :: cpos (3,dims(1)) integer(kind=irg), intent(inout) :: s_edge (2,dims(2)) integer(kind=irg), intent(inout) :: t_edge (2,dims(3)) integer(kind=irg), intent(out) :: ns real(kind=dbl), intent(out) :: d integer(kind=irg), intent(out) :: nt logical, intent(in), optional :: MFZ public recursive subroutine PoVRay_getpos_FZ622 (dims, cpos, s_edge, t_edge, ns, d, nt, MFZ) @author Marc De Graef, Carnegie Mellon University\n @brief initialize the PoVRay output for rotational group 622\n @param dims dimensions for subsequent arrays\n @param cpos vertex coordinates\n @param s_edge first set of edge connectivities\n @param t_edge second set of edge connectivities\n @param ns, d, nt  auxiliary parameters\n @param MFZ (optional) return coordinates for Mackenzie FZ instead of regular FZ\n @date    09/10/16 MDG 1.0 original\n @date    02/05/17 MDG 1.1 correction of d parameter Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dims (3) real(kind=dbl), intent(inout) :: cpos (3,dims(1)) integer(kind=irg), intent(inout) :: s_edge (2,dims(2)) integer(kind=irg), intent(inout) :: t_edge (2,dims(3)) integer(kind=irg), intent(out) :: ns real(kind=dbl), intent(out) :: d integer(kind=irg), intent(out) :: nt logical, intent(in), optional :: MFZ public recursive subroutine PoVRay_getpos_FZ422 (dims, cpos, s_edge, t_edge, ns, d, nt, MFZ) @author Marc De Graef, Carnegie Mellon University\n @brief initialize the PoVRay output for rotational group 422\n @param dims dimensions for subsequent arrays\n @param cpos vertex coordinates\n @param s_edge first set of edge connectivities\n @param t_edge second set of edge connectivities\n @param ns, d, nt  auxiliary parameters\n @param MFZ (optional) return coordinates for Mackenzie FZ instead of regular FZ\n @date    09/10/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dims (3) real(kind=dbl), intent(inout) :: cpos (3,dims(1)) integer(kind=irg), intent(inout) :: s_edge (2,dims(2)) integer(kind=irg), intent(inout) :: t_edge (2,dims(3)) integer(kind=irg), intent(out) :: ns real(kind=dbl), intent(out) :: d integer(kind=irg), intent(out) :: nt logical, intent(in), optional :: MFZ public recursive subroutine PoVRay_getpos_FZ32 (dims, cpos, s_edge, t_edge, ns, d, nt, MFZ) @author Marc De Graef, Carnegie Mellon University\n @brief initialize the PoVRay output for rotational group 32\n @param dims dimensions for subsequent arrays\n @param cpos vertex coordinates\n @param s_edge first set of edge connectivities\n @param t_edge second set of edge connectivities\n @param ns, d, nt  auxiliary parameters\n @param MFZ (optional) return coordinates for Mackenzie FZ instead of regular FZ\n @date    09/10/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dims (3) real(kind=dbl), intent(inout) :: cpos (3,dims(1)) integer(kind=irg), intent(inout) :: s_edge (2,dims(2)) integer(kind=irg), intent(inout) :: t_edge (2,dims(3)) integer(kind=irg), intent(out) :: ns real(kind=dbl), intent(out) :: d integer(kind=irg), intent(out) :: nt logical, intent(in), optional :: MFZ public recursive subroutine PoVRay_getpos_FZ222 (dims, cpos, s_edge, t_edge, ns, d, nt, MFZ) @author Marc De Graef, Carnegie Mellon University\n @brief initialize the PoVRay output for rotational group 222\n @param dims dimensions for subsequent arrays\n @param cpos vertex coordinates\n @param s_edge first set of edge connectivities\n @param t_edge second set of edge connectivities\n @param ns, d, nt  auxiliary parameters\n @param MFZ (optional) return coordinates for Mackenzie FZ instead of regular FZ\n @date    09/10/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dims (3) real(kind=dbl), intent(inout) :: cpos (3,dims(1)) integer(kind=irg), intent(inout) :: s_edge (2,dims(2)) integer(kind=irg), intent(inout) :: t_edge (2,dims(3)) integer(kind=irg), intent(out) :: ns real(kind=dbl), intent(out) :: d integer(kind=irg), intent(out) :: nt logical, intent(in), optional :: MFZ public recursive subroutine PoVRay_drawFZ (dunit, rmode, cylr, FZtype, FZorder, MFZ) @author Marc De Graef, Carnegie Mellon University\n @brief initialize the PoVRay output for any rotation group\n @details This routine draws the outline of either the Rodrigues Fundamental\n zone, or the Mackenzie Fundamental Zone (if MFZ is set and true).\n @param dunit output unit number\n @param rmode  1(cubochoric)|2(homochoric)|3(stereographic)|4(Rodrigues)|5(Euler)\n @param cylr cylinder radius\n @param FZtype  Fundamental zone type \n @param FZorder order of the FZ point group\n @param MFZ (optional) Mackenzie FZ instead of regular FZ\n @date    09/10/16 MDG 1.0 original\n @date    11/23/16 MDG 1.1 added Euler representation Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit integer(kind=irg), intent(in) :: rmode real(kind=dbl), intent(in) :: cylr integer(kind=irg), intent(in) :: FZtype integer(kind=irg), intent(in) :: FZorder logical, intent(in), optional :: MFZ public recursive subroutine PoVRay_initFZ2 (dunit, rmode) @author Marc De Graef, Carnegie Mellon University\n @brief initialize the PoVRay output for rotational group 2\n @param dunit output unit number\n @param rmode  1(cubochoric)|2(homochoric)|3(stereographic)|4(Rodrigues)\n @date    09/09/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit integer(kind=irg), intent(in) :: rmode public recursive subroutine PoVRay_initFZ3 (dunit, rmode) @author Marc De Graef, Carnegie Mellon University\n @brief initialize the PoVRay output for rotational group 3\n @param dunit output unit number\n @param rmode  1(cubochoric)|2(homochoric)|3(stereographic)|4(Rodrigues)\n @date    09/09/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit integer(kind=irg), intent(in) :: rmode public recursive subroutine PoVRay_initFZ4 (dunit, rmode) @author Marc De Graef, Carnegie Mellon University\n @brief initialize the PoVRay output for rotational group 4\n @param dunit output unit number\n @param rmode  1(cubochoric)|2(homochoric)|3(stereographic)|4(Rodrigues)\n @date    09/09/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit integer(kind=irg), intent(in) :: rmode public recursive subroutine PoVRay_initFZ6 (dunit, rmode) @author Marc De Graef, Carnegie Mellon University\n @brief initialize the PoVRay output for rotational group 6\n @param dunit output unit number\n @param rmode  1(cubochoric)|2(homochoric)|3(stereographic)|4(Rodrigues)\n @date    09/09/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: dunit integer(kind=irg), intent(in) :: rmode","tags":"","loc":"module/povray.html","title":"povray – Fortran Program"},{"text":"Variables ns default_seed Derived Types rng_t Functions rng_uniform Subroutines rng_seed Variables Type Visibility Attributes Name Initial integer, private, parameter :: ns = 4 integer, private, parameter, dimension(ns) :: default_seed = (/521288629, 362436069, 16163801, 1131199299/) Derived Types type, public :: rng_t Components Type Visibility Attributes Name Initial integer, public, dimension(ns) :: state = default_seed Functions public recursive function rng_uniform (self) result(u) Arguments Type Intent Optional Attributes Name type( rng_t ), intent(inout) :: self Return Value real Subroutines public recursive subroutine rng_seed (self, seed) Arguments Type Intent Optional Attributes Name type( rng_t ), intent(inout) :: self integer, intent(in) :: seed","tags":"","loc":"module/rng.html","title":"rng – Fortran Program"},{"text":"Uses: local others EMdymod module~~simann~~UsesGraph module~simann SimAnn module~others others module~others->module~simann local local local->module~simann local->module~others module~emdymod EMdymod module~emdymod->module~simann Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Abstract Interfaces func Subroutines linesearchbox_cont SENZADERGLOB AGGIORNO_OTTIMO RICERCA_LUNGO_ASSI INTERFACCIA GENERA_PUNTO_SA MAINBOX1 MAINBOX2 STOP LINESEARCH_INVERTI Abstract Interfaces abstract interface public recursive subroutine func (nipar, nfpar, ninit, ipar, fpar, initmeanval, expt, accum_e, mLPNH, mLPSH, n, x, f, verbose) calfun interface Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar integer(kind=irg), intent(in) :: ninit integer(kind=8), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fpar (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) real(kind=sgl), intent(in) :: expt (ipar(2)*ipar(3)) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) integer(kind=irg), intent(in) :: n real(kind=dbl), intent(in), dimension(:) :: x real(kind=dbl), intent(out) :: f logical, intent(in), optional :: verbose Subroutines public recursive subroutine linesearchbox_cont (n, x, f, d, alfa, alfa_d, z, fz, i_corr, num_fal, alfa_max, iprint, bl, bu, ipar, fparebsd, initmeanval, ninit, nipar, nfpar, expt, accum_e, mLPNH, mLPSH, verbose, calfun) Arguments Type Intent Optional Attributes Name integer :: n real(kind=8) :: x (n) real(kind=8) :: f real(kind=8) :: d (n) real(kind=8) :: alfa real(kind=8) :: alfa_d (n) real(kind=8) :: z (n) real(kind=8) :: fz integer :: i_corr integer :: num_fal real(kind=8) :: alfa_max integer :: iprint real(kind=8) :: bl (n) real(kind=8) :: bu (n) integer(kind=8), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fparebsd (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) integer(kind=irg), intent(in) :: ninit integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar real(kind=sgl), intent(in) :: expt (ipar(2)*ipar(3)) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) logical, intent(in), optional :: verbose procedure( func ) :: calfun public subroutine SENZADERGLOB (ipar, fparebsd, initmeanval, ninit, nipar, nfpar, expt, accum_e, mLPNH, mLPSH, verbose, calfun, N, XSUP, XINF) Arguments Type Intent Optional Attributes Name integer(kind=8), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fparebsd (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) integer(kind=irg), intent(in) :: ninit integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar real(kind=sgl), intent(in) :: expt (ipar(2)*ipar(3)) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) logical, intent(in), optional :: verbose procedure( func ) :: calfun integer :: N double precision, intent(in) :: XSUP (N) double precision, intent(in) :: XINF (N) public subroutine AGGIORNO_OTTIMO (N, XPROP, FPROP, XOTT, FOTT) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N double precision, intent(in) :: XPROP (N) double precision, intent(in) :: FPROP double precision, intent(out) :: XOTT (N) double precision, intent(out) :: FOTT public subroutine RICERCA_LUNGO_ASSI (N, X, FF, ALFA, DOLDALFA, D, FFSTOP, XINF, XSUP, FMAX_EFF, ipar, fparebsd, initmeanval, ninit, nipar, nfpar, expt, accum_e, mLPNH, mLPSH, verbose, calfun) Arguments Type Intent Optional Attributes Name integer :: N real(kind=8) :: X (N) real(kind=8) :: FF real(kind=8) :: ALFA real(kind=8) :: DOLDALFA (N) real(kind=8) :: D (N) real(kind=8) :: FFSTOP real(kind=8) :: XINF (N) real(kind=8) :: XSUP (N) real(kind=8) :: FMAX_EFF integer(kind=8), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fparebsd (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) integer(kind=irg), intent(in) :: ninit integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar real(kind=sgl), intent(in) :: expt (ipar(2)*ipar(3)) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) logical, intent(in), optional :: verbose procedure( func ) :: calfun public subroutine INTERFACCIA (N, X, FF, ALFA, DOLDALFA, D, FFSTOP, FFSTOPTOL, XINF, XSUP, FOTT, ALFAMAX, ALFAOTT, XOTT, WKS, IDIMWKS, ISTOP, MASCH, MAXNF, fglob, ipar, fparebsd, initmeanval, ninit, nipar, nfpar, expt, accum_e, mLPNH, mLPSH, verbose, calfun) Arguments Type Intent Optional Attributes Name integer :: N real(kind=8) :: X (N) real(kind=8) :: FF real(kind=8) :: ALFA real(kind=8) :: DOLDALFA (N) real(kind=8) :: D (N) real(kind=8) :: FFSTOP real(kind=8) :: FFSTOPTOL real(kind=8) :: XINF (N) real(kind=8) :: XSUP (N) real(kind=8) :: FOTT real(kind=8) :: ALFAMAX real(kind=8) :: ALFAOTT real(kind=8) :: XOTT (N) type(COMP_WKS_TYP) :: WKS (IDIMWKS) integer :: IDIMWKS integer :: ISTOP logical :: MASCH (IDIMWKS) integer :: MAXNF real(kind=8) :: fglob integer(kind=8), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fparebsd (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) integer(kind=irg), intent(in) :: ninit integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar real(kind=sgl), intent(in) :: expt (ipar(2)*ipar(3)) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) logical, intent(in), optional :: verbose procedure( func ) :: calfun public subroutine GENERA_PUNTO_SA (N, XPROP, FPROP, XINF, XSUP, FOTT, TCOEFF, IVAR, IVAR2, VAR2, RMED, RMED2, NLM, NUMFAL, RFAL, RNUMFAL, ICONTFAL, IDFAL, NPC, NF, ipar, fparebsd, initmeanval, ninit, nipar, nfpar, expt, accum_e, mLPNH, mLPSH, verbose, calfun) Arguments Type Intent Optional Attributes Name integer :: N double precision :: XPROP (N) double precision :: FPROP double precision :: XINF (N) double precision :: XSUP (N) double precision :: FOTT double precision :: TCOEFF integer(kind=4) :: IVAR integer(kind=4) :: IVAR2 double precision :: VAR2 double precision :: RMED double precision :: RMED2 integer :: NLM integer :: NUMFAL double precision :: RFAL double precision :: RNUMFAL integer :: ICONTFAL integer :: IDFAL integer :: NPC integer :: NF integer(kind=8), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fparebsd (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) integer(kind=irg), intent(in) :: ninit integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar real(kind=sgl), intent(in) :: expt (ipar(2)*ipar(3)) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) logical, intent(in), optional :: verbose procedure( func ) :: calfun public subroutine MAINBOX1 (N, X, D, D1, Z, Z1, XOLD, NUM_ITER, DOLDALFA, IPRINT, DCONV, FSTOP, XFSTOP, FINIT, FFSTOP, BL, BU, ipar, fparebsd, initmeanval, ninit, nipar, nfpar, expt, accum_e, mLPNH, mLPSH, verbose, calfun) Arguments Type Intent Optional Attributes Name integer :: N real(kind=8) :: X (N) real(kind=8) :: D (N) real(kind=8) :: D1 (N) real(kind=8) :: Z (N) real(kind=8) :: Z1 (N) real(kind=8) :: XOLD (N) integer :: NUM_ITER real(kind=8) :: DOLDALFA (N) integer :: IPRINT real(kind=8) :: DCONV (N) real(kind=8) :: FSTOP (N+1) real(kind=8) :: XFSTOP (N,N+1) real(kind=8) :: FINIT (N,2) real(kind=8) :: FFSTOP real(kind=8) :: BL (N) real(kind=8) :: BU (N) integer(kind=8), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fparebsd (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) integer(kind=irg), intent(in) :: ninit integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar real(kind=sgl), intent(in) :: expt (ipar(2)*ipar(3)) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) logical, intent(in), optional :: verbose procedure( func ) :: calfun public subroutine MAINBOX2 (N, X, D, D1, Z, Z1, XOLD, NUM_ITER, DOLDALFA, ALFA_STOP, IPRINT, DCONV, FSTOP, XFSTOP, FINIT, FFSTOP, FFSTOPTOL, FOTT, ALFAOTT, XOTT, WKS, IDIMWKS, ISTOP, MASCH, MAXNF, fglob, BL, BU, ipar, fparebsd, initmeanval, ninit, nipar, nfpar, expt, accum_e, mLPNH, mLPSH, verbose, calfun) Arguments Type Intent Optional Attributes Name integer :: N real(kind=8) :: X (N) real(kind=8) :: D (N) real(kind=8) :: D1 (N) real(kind=8) :: Z (N) real(kind=8) :: Z1 (N) real(kind=8) :: XOLD (N) integer :: NUM_ITER real(kind=8) :: DOLDALFA (N) real(kind=8) :: ALFA_STOP integer :: IPRINT real(kind=8) :: DCONV (N) real(kind=8) :: FSTOP (N+1) real(kind=8) :: XFSTOP (N,N+1) real(kind=8) :: FINIT (N,2) real(kind=8) :: FFSTOP real(kind=8) :: FFSTOPTOL real(kind=8) :: FOTT real(kind=8) :: ALFAOTT real(kind=8) :: XOTT (N) type(COMP_WKS_TYP) :: WKS (IDIMWKS) integer :: IDIMWKS integer :: ISTOP logical :: MASCH (IDIMWKS) integer :: MAXNF real(kind=8) :: fglob real(kind=8) :: BL (N) real(kind=8) :: BU (N) integer(kind=8), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fparebsd (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) integer(kind=irg), intent(in) :: ninit integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar real(kind=sgl), intent(in) :: expt (ipar(2)*ipar(3)) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) logical, intent(in), optional :: verbose procedure( func ) :: calfun public subroutine STOP (N, DOLDALFA, ISTOP, DALFAMAX, NUM_FUNCT, FSTOP, ALFA_STOP, FFSTOPTOL, FFSTOP, FOTT, X, XOTT, ALFAOTT, WKS, IDIMWKS, MASCH, MAXNF, fglob) Arguments Type Intent Optional Attributes Name integer :: N real(kind=8) :: DOLDALFA (N) integer :: ISTOP real(kind=8) :: DALFAMAX integer :: NUM_FUNCT real(kind=8) :: FSTOP (N+1) real(kind=8) :: ALFA_STOP real(kind=8) :: FFSTOPTOL real(kind=8) :: FFSTOP real(kind=8) :: FOTT real(kind=8) :: X (N) real(kind=8) :: XOTT (N) real(kind=8) :: ALFAOTT type(COMP_WKS_TYP) :: WKS (IDIMWKS) integer :: IDIMWKS logical :: MASCH (IDIMWKS) integer :: MAXNF real(kind=8) :: fglob public subroutine LINESEARCH_INVERTI (N, X, F, D, ALFA, DOLDALFA, Z, FZ, I_CORR, NUM_FAL, DALFAMAX, IPRINT, ipar, fparebsd, initmeanval, ninit, nipar, nfpar, expt, accum_e, mLPNH, mLPSH, verbose, calfun) Arguments Type Intent Optional Attributes Name integer :: N real(kind=8) :: X (N) real(kind=8) :: F real(kind=8) :: D (N) real(kind=8) :: ALFA real(kind=8) :: DOLDALFA (N) real(kind=8) :: Z (N) real(kind=8) :: FZ integer :: I_CORR integer :: NUM_FAL real(kind=8) :: DALFAMAX integer :: IPRINT integer(kind=8), intent(in) :: ipar (nipar) real(kind=sgl), intent(inout) :: fparebsd (nfpar) real(kind=sgl), intent(in) :: initmeanval (ninit) integer(kind=irg), intent(in) :: ninit integer(kind=irg), intent(in) :: nipar integer(kind=irg), intent(in) :: nfpar real(kind=sgl), intent(in) :: expt (ipar(2)*ipar(3)) real(kind=sgl), intent(in) :: accum_e (ipar(4),-ipar(5):ipar(5),-ipar(5):ipar(5)) real(kind=sgl), intent(in) :: mLPNH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) real(kind=sgl), intent(in) :: mLPSH (-ipar(6):ipar(6),-ipar(6):ipar(6),ipar(10),ipar(7)) logical, intent(in), optional :: verbose procedure( func ) :: calfun","tags":"","loc":"module/simann.html","title":"SimAnn – Fortran Program"},{"text":"Uses: local module~~so3~~UsesGraph module~so3 so3 local local local->module~so3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief everything that has to do with sampling of rotation space SO(3) Todo verify that this is correct for point groups with multiple settings, eg, 3m, 32, ...\n @date 05/29/14 MDG 1.0 original\n @date 10/02/14 MDG 2.0 removed globals + rewrite\n @date 01/01/15 MDG 2.1 added IsinsideFZ function, also used in dictionary indexing approach\n @date 01/17/15 MDG 2.2 added gridtype option to SampleRFZ\n @date 03/03/16 MDG 2.3 added uniform sampling for constant misorientations\n @date 04/01/17 MDG 3.0 start to add FZs for two-phase systems (e.g., cubic-hexagonal, etc.) Used By module~~so3~~UsedByGraph module~so3 so3 proc~di_emfordd DI_EMforDD module~so3->proc~di_emfordd proc~reduceorientationtorfz ReduceOrientationtoRFZ module~so3->proc~reduceorientationtorfz proc~reducedisorientationtomfz ReduceDisorientationtoMFZ module~so3->proc~reducedisorientationtomfz proc~reduceorientationtocubicefz ReduceOrientationtoCubicEFZ module~so3->proc~reduceorientationtocubicefz Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Functions IsinsideFZ insideCyclicFZ insideDihedralFZ insideCubicFZ insideCubeHexFZ IsinsideMFZ insideCubicMFZ insideDihedralMFZ Subroutines getFZtypeandorder delete_FZlist SampleRFZ CubochoricNeighbors SamplefcctwinRFZ SampleRFZtwin sample_isoCube sample_isoCubeFilled sample_Cone SampleIsoMisorientation getEulersfromFile Functions public recursive function IsinsideFZ (rod, FZtype, FZorder) result(insideFZ) @author Marc De Graef, Carnegie Mellon University\n @brief does Rodrigues point lie inside the relevant FZ\n @param rod Rodrigues coordinates  (double precision)\n @param FZtype FZ type\n @param FZorder FZ order\n @date 01/01/15 MDG 1.0 new routine, needed for dictionary indexing approach\n @date 06/04/15 MDG 1.1 corrected infty to inftyd (double precision infinity)\n @date 04/02/17 MDG 1.2 expanded FZ types to include misorientation FZs and icosahedral Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: rod (4) integer(kind=irg), intent(in) :: FZtype integer(kind=irg), intent(in) :: FZorder Return Value logical public recursive function insideCyclicFZ (rod, FZtype, FZorder) result(res) @author Marc De Graef, Carnegie Mellon University\n @brief does Rodrigues point lie inside cyclic FZ (for 2, 3, 4, and 6-fold)?\n @param rod Rodrigues coordinates  (double precision)\n @param FZtype symmetry type\n @param FZorder depending on main symmetry axis\n @date 05/12/14 MDG 1.0 original\n @date 10/02/14 MDG 2.0 rewrite\n @date 06/04/15 MDG 2.1 corrected infty to inftyd (double precision infinity) Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: rod (4) integer(kind=irg), intent(in) :: FZtype integer(kind=irg), intent(in) :: FZorder Return Value logical public recursive function insideDihedralFZ (rod, order) result(res) @author Marc De Graef, Carnegie Mellon University\n @brief does Rodrigues point lie inside dihedral FZ (for 2, 3, 4, and 6-fold)?\n @param rod Rodrigues coordinates (double precision)\n @param order depending on main symmetry axis Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: rod (4) integer(kind=irg), intent(in) :: order Return Value logical public recursive function insideCubicFZ (rod, ot) result(res) @author Marc De Graef, Carnegie Mellon University\n @brief does Rodrigues point lie inside cubic FZ (octahedral or tetrahedral)?\n @param rod Rodrigues coordinates  (double precision)\n @param ot 'oct' or 'tet', depending on symmetry\n @date 05/12/14 MDG 1.0 original\n @date 10/02/14 MDG 2.0 rewrite\n @date 01/03/15 MDG 2.1 correction of boundary error; simplification of octahedral planes\n @date 06/04/15 MDG 2.2 simplified handling of components of r Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: rod (4) character(len=3), intent(in) :: ot Return Value logical public recursive function insideCubeHexFZ (rod) result(res) @author Marc De Graef, Carnegie Mellon University\n @brief does Rodrigues point lie inside combined cubic-hexagonal FZ? Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: rod (4) Return Value logical public recursive function IsinsideMFZ (rod, MFZtype, MFZorder) result(insideMFZ) @author Marc De Graef, Carnegie Mellon University\n @brief does Rodrigues point lie inside the relevant Mackenzie (disorientation) FZ\n @param rod Rodrigues coordinates  (double precision)\n @param MFZtype MFZ type\n @param MFZorder MFZ order\n @date 09/09/16 MDG 1.0 new routine Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: rod (4) integer(kind=irg), intent(in) :: MFZtype integer(kind=irg), intent(in) :: MFZorder Return Value logical public recursive function insideCubicMFZ (rod, ot) result(res) @author Marc De Graef, Carnegie Mellon University\n @brief does Rodrigues point lie inside cubic MacKenzie FZ (octahedral or tetrahedral)?\n @param rod Rodrigues coordinates  (double precision)\n @param ot 'oct' or 'tet', depending on symmetry\n @date 09/09/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: rod (4) character(len=3), intent(in) :: ot Return Value logical public recursive function insideDihedralMFZ (rod, MFZorder) result(res) @author Marc De Graef, Carnegie Mellon University\n @brief does Rodrigues point lie inside cubic MacKenzie FZ (octahedral or tetrahedral)?\n @param rod Rodrigues coordinates  (double precision)\n @param ot 'oct' or 'tet', depending on symmetry\n @date 09/09/16 MDG 1.0 original\n @date 09/15/16 MDG 1.0 completed all orders Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: rod (4) integer, intent(in) :: MFZorder Return Value logical Subroutines public recursive subroutine getFZtypeandorder (pgnum1, FZtype, FZorder, pgnum2) @author Marc De Graef, Carnegie Mellon University\n @brief does Rodrigues point lie inside the relevant FZ\n @param pgnum1 point group number for phase 1\n @param FZtype FZ type\n @param FZorder FZ order\n @param pgnum2 point group number for phase 2 (optional)\n @date 04/02/17 MDG 1.0 new routine, needed for two-phase disorientations Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: pgnum1 integer(kind=irg), intent(out) :: FZtype integer(kind=irg), intent(out) :: FZorder integer(kind=irg), intent(in), optional :: pgnum2 public recursive subroutine delete_FZlist (top) @author Marc De Graef, Carnegie Mellon University\n @brief delete a linked list of rodrigues vectors\n @param FZlist linked list\n @date 02/20/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name type(FZpointd), intent(inout), pointer :: top public recursive subroutine SampleRFZ (nsteps, pgnum, gridtype, FZcnt, FZlist) @author Marc De Graef, Carnegie Mellon University\n @brief Generate a uniform sampling of a Rodriguess FZ Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nsteps integer(kind=irg), intent(in) :: pgnum integer(kind=irg), intent(in) :: gridtype integer(kind=irg), intent(out) :: FZcnt type(FZpointd), intent(out), pointer :: FZlist public recursive subroutine CubochoricNeighbors (cubneighbor, nn, cub, stepsize) @author Saransh Singh, Carnegie Mellon University\n @brief find the nearest neighbors of a point in s03 space, given the point\n and the step size used in the previous meshing. to be used in multi resolution\n indexing programs, specifically the PED, ECP and EBSD indexing. we're not worrying\n about keeping the neighbors in the FZ. that can just be done later.\n @param cub cubochoric coordinates  (double precision)\n @param stepsize stepsize of last mesh. the mesh will be stepsize/2\n @date 04/07/15 SS 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(out) :: cubneighbor (3,(2*nn+1)**3) integer(kind=irg), intent(in) :: nn real(kind=dbl), intent(in) :: cub (3) real(kind=dbl), intent(in) :: stepsize public recursive subroutine SamplefcctwinRFZ (nsteps, FZcnt, FZlist) @author Marc De Graef, Carnegie Mellon University\n @brief uniformly sample the 32-based FZ for an fcc twin.\n @param nsteps number of steps along semi-edge in cubochoric grid\n @param FZcnt (output) number of points inside fundamental zone\n @param FZlist (output) linked list of points inside fundamental zone\n @date 09/17/16 MDG 1.0 fcc twin FZ for 60@[111] (also MacKenzie cell) Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nsteps integer(kind=irg), intent(out) :: FZcnt type(FZpointd), intent(out), pointer :: FZlist public recursive subroutine SampleRFZtwin (nsteps, pgnum, qt, FZcnt, FZlist) @author Marc De Graef, Carnegie Mellon University\n @brief use a quaternion to rotate the fundamental zone, then sample it \n this is useful for twins etc, hence the name of the routine...\n @param nsteps number of steps along semi-edge in cubochoric grid\n @param pgnum point group number to determine the appropriate Rodrigues fundamental zone\n @param qt rotation quaternion\n @param FZcnt (output) number of points inside fundamental zone\n @param FZlist (output) linked list of points inside fundamental zone\n @date 04/07/15 SS  1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: nsteps integer(kind=irg), intent(in) :: pgnum real(kind=sgl), intent(in) :: qt (4) integer(kind=irg), intent(out) :: FZcnt type(FZpointd), intent(out), pointer :: FZlist public recursive subroutine sample_isoCube (misang, N, CMcnt, CMlist) @author Marc De Graef, Carnegie Mellon University\n @brief sample a centered cube surface inside the Cubochoric cube for a given misorientation angle\n @details linked list wil have a length of 6(N-1)&#94;2+2 entries\n @param misang the misorientation angle [degrees]\n @param N number of points along cube semi-edge\n @param CMcnt the number of components in the returned linked list\n @param CMlist (output) linked list of Rodrigues vectors\n @date 03/03/16 MDG 1.0 original\n @date 04/19/16 MDG 1.1 changed value of N to be along the semi-edge instead of the edge Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: misang integer(kind=irg), intent(in) :: N integer(kind=irg), intent(inout) :: CMcnt type(FZpointd), pointer :: CMlist public recursive subroutine sample_isoCubeFilled (misang, N, CMcnt, CMlist) @author Marc De Graef, Carnegie Mellon University\n @brief sample a centered cube inside the Cubochoric cube for a given misorientation angle\n @details This routine is different from the sample_isoCube routine in that it \n generates ALL the points inside the centered cube instead of just the points on\n the outer surface.  This can be useful to uniformly sample a small volume of orientation\n space around some point out to a given misorientation angle.  Since the sampling has concentric\n cubes, all the samples can be subdivided into discrete misorientation classes.\n The linked list wil have a length of N&#94;3\n @param misang the misorientation angle [degrees]\n @param N number of points along cube edge\n @param CMcnt the number of components in the returned linked list\n @param CMlist (output) linked list of Rodrigues vectors\n @date 04/08/16 MDG 1.0 original\n @date 04/19/16 MDG 1.1 changed value of N to be along the semi-edge instead of the edge Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: misang integer(kind=irg), intent(in) :: N integer(kind=irg), intent(inout) :: CMcnt type(FZpointd), pointer :: CMlist public recursive subroutine sample_Cone (unitvector, dpmax, N, FZtype, FZorder, cnt, list) @author Marc De Graef, Carnegie Mellon University\n @brief sample a cone centered on a unit vector with apex in the origin and given opening angle\n @param unitvector  unit vector describing the cone axis\n @param dpmax = cosine of half the cone angle\n @param N number of points along cube edge\n @param CMcnt the number of components in the returned linked list\n @param CMlist (output) linked list of Rodrigues vectors\n @date 02/01/17 MDG 1.0 original Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: unitvector (3) real(kind=dbl), intent(in) :: dpmax integer(kind=irg), intent(in) :: N integer(kind=irg), intent(in) :: FZtype integer(kind=irg), intent(in) :: FZorder integer(kind=irg), intent(inout) :: cnt type(FZpointd), pointer :: list public recursive subroutine SampleIsoMisorientation (rhozero, misang, CMcnt, CMlist) @author Marc De Graef, Carnegie Mellon University\n @brief Constant Misorientation sampling routine; input list must be generated by sampleCubeSurface\n @param rhozero central Rodrigues point around which constant misorientation sample is requested\n @param misang the misorientation angle [degrees]\n @param CMcnt the number of components in the returned linked list\n @param CMlist (output) linked list of Rodrigues vectors, with transformed vectors in trod(4) entries\n @date 03/03/16 SS/MDG 1.0 original (merged from two separate implementations) Arguments Type Intent Optional Attributes Name real(kind=dbl), intent(in) :: rhozero (4) real(kind=dbl), intent(in) :: misang integer(kind=irg), intent(inout) :: CMcnt type(FZpointd), pointer :: CMlist public recursive subroutine getEulersfromFile (eulerfile, FZcnt, FZlist) @author Marc De Graef, Carnegie Mellon University\n @brief read a list of Euler angles from a text file and insert them in a linked list\n @param eulerfile name of the Euler angle file (with usual path handling)\n @param FZcnt the number of components in the returned linked list\n @param FZlist (output) linked list of Rodrigues vectors, with transformed vectors in trod(4) entries\n @date 12/22/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name character(len=fnlen), intent(in) :: eulerfile integer(kind=irg), intent(inout) :: FZcnt type(FZpointd), pointer :: FZlist","tags":"","loc":"module/so3.html","title":"so3 – Fortran Program"},{"text":"Uses: local typedefs module~~stemmodule~~UsesGraph module~stemmodule STEMmodule typedefs typedefs typedefs->module~stemmodule local local local->module~stemmodule Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief Provides routines to handle the STEM detector geometry and weightfactors.\n @date   04/29/11 MDG 1.0 original\n @date   06/12/13 MDG 2.0 rewrite Used By module~~stemmodule~~UsedByGraph module~stemmodule STEMmodule program~dispfield dispfield module~stemmodule->program~dispfield Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Subroutines init_STEM init_STEM_ZA read_STEM_data Subroutines public recursive subroutine init_STEM (STEM, cell, nn, g) @author Marc De Graef, Carnegie Mellon University\n @brief initialize the weight factors for the systematic row case.\n @param STEM STEM structure\n @param cell unit cell pointer\n @param nn number of beams\n @param g systematic row basic vector\n @date   04/29/11 MDG 1.0 original\n @date   06/12/13 MDG 2.0 rewrite \n @date   06/09/14 MDG 3.0 added STEM and cell arguments Arguments Type Intent Optional Attributes Name type(STEMtype), intent(inout) :: STEM type(unitcell), pointer :: cell integer(kind=irg), intent(in) :: nn integer(kind=irg), intent(in) :: g (3) public recursive subroutine init_STEM_ZA (STEM, cell, F, Dyn, khead, reflist, nn) @author Marc De Graef, Carnegie Mellon University\n @brief initialize weight factors for zone-axis STEM case Arguments Type Intent Optional Attributes Name type(STEMtype), intent(inout) :: STEM type(unitcell), pointer :: cell real(kind=dbl), intent(inout) :: F (3) type(DynType), intent(inout) :: Dyn type(kvectorlist), pointer :: khead type(reflisttype), pointer :: reflist integer(kind=irg), intent(in) :: nn public recursive subroutine read_STEM_data (STEM, cell, F, Dyn, STEMnmlfile, khead, reflist, geometry, nn, g, kt, numk, beamdiv) @author Marc De Graef, Carnegie Mellon University\n @brief read detector and other parameters for the STEM case\n @param STEM STEM structure\n @param cell unit cell pointer\n @param F foil normal\n @param Dyn dynamical scattering structure\n @param STEMnmlfile filename of the namelist file\n @param khead top of kvector list\n @param reflist top of reflection list\n @param geometry 'SR' for systematic row or 'ZA' for zone axis\n @param nn number of reflections\n @param g fundamental g-vector for systematic row\n @param kt tangential wave vector component\n @param numk number of distinct wave vectors (optional)\n @param beamdiv beam divergence parameter (optional)\n @date   04/29/11 MDG 1.0 original\n @date   06/12/13 MDG 2.0 rewrite \n @date   11/26/13 MDG 2.1 made geometry an input parameter instead of part of the STEMdata namelist\n @date   06/10/14 MDG 3.0 added STEM, cell, foil, and Dyn arguments Arguments Type Intent Optional Attributes Name type(STEMtype), intent(inout) :: STEM type(unitcell), pointer :: cell real(kind=dbl), intent(inout) :: F (3) type(DynType), intent(inout) :: Dyn character(len=fnlen), intent(in) :: STEMnmlfile type(kvectorlist), pointer :: khead type(reflisttype), pointer :: reflist character(len=2), intent(in) :: geometry integer(kind=irg), intent(in) :: nn integer(kind=irg), intent(in) :: g (3) real(kind=sgl), intent(in) :: kt integer(kind=irg), intent(in), optional :: numk real(kind=sgl), intent(out), optional :: beamdiv","tags":"","loc":"module/stemmodule.html","title":"STEMmodule – Fortran Program"},{"text":"Uses: local typedefs io module~~timing~~UsesGraph module~timing timing typedefs typedefs typedefs->module~timing local local local->module~timing io io io->module~timing Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. @author Marc De Graef, Carnegie Mellon University\n @brief Provides a few timing routines\n @date   11/19/01 MDG 1.0 original\n @date   06/04/13 MDG 2.0 rewrite\n @date   06/05/14 MDG 3.0 replaced globals by timetype argument Used By module~~timing~~UsedByGraph module~timing timing proc~calcrlocal CalcRLocal module~timing->proc~calcrlocal program~dispfield dispfield module~timing->program~dispfield proc~emsoftcgetebsdmaster EMsoftCgetEBSDmaster module~timing->proc~emsoftcgetebsdmaster proc~emsoftcgetmcopencl EMsoftCgetMCOpenCL module~timing->proc~emsoftcgetmcopencl Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Functions Time_tock Subroutines Time_tick Time_reset Time_report Time_start Time_estimate Time_remaining PrintTime Time_stop Functions public recursive function Time_tock (t) result(tock) @author Marc De Graef, Carnegie Mellon University\n @brief stop time recording using system_clock\n @date   03/17/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer(kind=irg), intent(in) :: t Return Value integer(kind=irg) Subroutines public recursive subroutine Time_tick (t) @author Marc De Graef, Carnegie Mellon University\n @brief start time recording using system_clock\n @date   03/17/16 MDG 1.0 original Arguments Type Intent Optional Attributes Name integer, intent(out) :: t public recursive subroutine Time_reset (TT) @author Marc De Graef, Carnegie Mellon University\n @brief reset time recording\n @date   06/04/01 MDG 1.0 original\n @date   06/04/13 MDG 2.0 rewrite\n @date   06/05/14 MDG 3.0 added TT as argument Arguments Type Intent Optional Attributes Name type(timetype), intent(inout) :: TT public recursive subroutine Time_report (TT, interval, stdout) @author Marc De Graef, Carnegie Mellon University\n @brief report time recording\n @param TT time structure\n @param interval interval for reporting\n @param stdout optional output unit identifier\n @date   06/04/01 MDG 1.0 original\n @date   06/04/13 MDG 2.0 rewrite\n @date   06/05/14 MDG 3.0 added TT as argument Arguments Type Intent Optional Attributes Name type(timetype), intent(inout) :: TT real(kind=sgl), intent(in) :: interval integer(kind=irg), intent(in), optional :: stdout public recursive subroutine Time_start (TT) @author Marc De Graef, Carnegie Mellon University\n @brief start time recording\n @date   06/04/01 MDG 1.0 original\n @date   06/04/13 MDG 2.0 rewrite\n @date   06/05/14 MDG 3.0 added TT as argument Arguments Type Intent Optional Attributes Name type(timetype), intent(inout) :: TT public recursive subroutine Time_estimate (TT, numk, stdout) @author Marc De Graef, Carnegie Mellon University\n @brief estimare remaining time\n @param TT time structure\n @param numk number of idividual computations\n @param stdout optional output unit identifier\n @date   06/04/01 MDG 1.0 original\n @date   06/04/13 MDG 2.0 rewrite\n @date   06/05/14 MDG 3.0 added TT as argument Arguments Type Intent Optional Attributes Name type(timetype), intent(inout) :: TT integer(kind=irg), intent(in) :: numk integer(kind=irg), intent(in), optional :: stdout public recursive subroutine Time_remaining (TT, ik, numk, stdout) @author Marc De Graef, Carnegie Mellon University\n @brief estimate remaining time\n @param TT time structure\n @param ik current computation\n @param numk number of idividual computations\n @param stdout optional output unit identifier\n @date   06/04/01 MDG 1.0 original\n @date   06/04/13 MDG 2.0 rewrite\n @date   06/05/14 MDG 3.0 added TT as argument Arguments Type Intent Optional Attributes Name type(timetype), intent(inout) :: TT integer(kind=irg), intent(in) :: ik integer(kind=irg), intent(in) :: numk integer(kind=irg), intent(in), optional :: stdout public recursive subroutine PrintTime (tm, stdout) @author Marc De Graef, Carnegie Mellon University\n @brief print  time\n @param tm time variable\n @param stdout optional output unit identifier\n @date   06/04/01 MDG 1.0 original\n @date   06/04/13 MDG 2.0 rewrite\n @date   06/05/14 MDG 3.0 changed IO Arguments Type Intent Optional Attributes Name real(kind=sgl), intent(in) :: tm integer(kind=irg), intent(in), optional :: stdout public recursive subroutine Time_stop (TT, numk, stdout) @author Marc De Graef, Carnegie Mellon University\n @brief stop time recording\n @param TT time structure\n @param numk total number of computations\n @param stdout optional output unit identifier\n @date   06/04/01 MDG 1.0 original\n @date   06/04/13 MDG 2.0 rewrite\n @date   06/05/14 MDG 3.0 added TT; changed IO Arguments Type Intent Optional Attributes Name type(timetype), intent(inout) :: TT integer(kind=irg), intent(in) :: numk integer(kind=irg), intent(in), optional :: stdout","tags":"","loc":"module/timing.html","title":"timing – Fortran Program"},{"text":"Uses: local typedefs crystalvars crystal symmetryvars symmetry postscript constants diffraction dynamical files io foilmodule stacking_fault dislocation void inclusion defectmodule TIFF_global TIFF_f90 pgm timing STEMmodule YSHModule program~~dispfield~~UsesGraph program~dispfield dispfield inclusion inclusion inclusion->program~dispfield module~constants constants module~constants->program~dispfield io io io->program~dispfield module~timing timing io->module~timing module~pgm pgm io->module~pgm dynamical dynamical dynamical->program~dispfield files files files->program~dispfield files->module~pgm typedefs typedefs typedefs->program~dispfield module~defectmodule defectmodule typedefs->module~defectmodule module~stemmodule STEMmodule typedefs->module~stemmodule typedefs->module~timing crystalvars crystalvars crystalvars->program~dispfield symmetryvars symmetryvars symmetryvars->program~dispfield module~defectmodule->program~dispfield module~stemmodule->program~dispfield crystal crystal crystal->program~dispfield symmetry symmetry symmetry->program~dispfield postscript postscript postscript->program~dispfield module~timing->program~dispfield dislocation dislocation dislocation->program~dispfield void void void->program~dispfield foilmodule foilmodule foilmodule->program~dispfield stacking_fault stacking_fault stacking_fault->program~dispfield local local local->program~dispfield local->module~constants local->module~defectmodule local->module~stemmodule local->module~timing local->module~pgm module~yshmodule YSHModule local->module~yshmodule TIFF_global TIFF_global TIFF_global->program~dispfield TIFF_f90 TIFF_f90 TIFF_f90->program~dispfield module~pgm->program~dispfield module~yshmodule->program~dispfield diffraction diffraction diffraction->program~dispfield quaternions quaternions quaternions->module~defectmodule Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Calls program~~dispfield~~CallsGraph program~dispfield dispfield read_inclusion_data read_inclusion_data program~dispfield->read_inclusion_data dl dl program~dispfield->dl safeclosefile safeclosefile program~dispfield->safeclosefile read_stacking_fault_data read_stacking_fault_data program~dispfield->read_stacking_fault_data proc~read_ysh_dislocation_data read_YSH_dislocation_data program~dispfield->proc~read_ysh_dislocation_data emsoft emsoft program~dispfield->emsoft crystaldata crystaldata program~dispfield->crystaldata message message program~dispfield->message read_foil_data read_foil_data program~dispfield->read_foil_data proc~calcrlocal CalcRLocal program~dispfield->proc~calcrlocal read_void_data read_void_data program~dispfield->read_void_data read_dislocation_data read_dislocation_data program~dispfield->read_dislocation_data emsoft_tonativepath emsoft_tonativepath program~dispfield->emsoft_tonativepath proc~read_ysh_dislocation_data->message proc~read_ysh_dislocation_data->emsoft_tonativepath proc~makeyshdislocation~2 makeYSHdislocation proc~read_ysh_dislocation_data->proc~makeyshdislocation~2 float float proc~read_ysh_dislocation_data->float proc~calcrlocal->float proc~time_reset Time_reset proc~calcrlocal->proc~time_reset proc~time_start Time_start proc~calcrlocal->proc~time_start proc~yshdisp YSHDisp proc~calcrlocal->proc~yshdisp proc~time_remaining Time_remaining proc~calcrlocal->proc~time_remaining sngl sngl proc~calcrlocal->sngl proc~time_stop Time_stop proc~calcrlocal->proc~time_stop proc~time_report Time_report proc~calcrlocal->proc~time_report normvec normvec proc~makeyshdislocation~2->normvec calclength calclength proc~makeyshdislocation~2->calclength calcangle calcangle proc~makeyshdislocation~2->calcangle calcdot calcdot proc~makeyshdislocation~2->calcdot calccross calccross proc~makeyshdislocation~2->calccross transspace transspace proc~makeyshdislocation~2->transspace proc~time_start->proc~time_reset datan2 datan2 proc~yshdisp->datan2 proc~time_remaining->message proc~time_remaining->float proc~printtime PrintTime proc~time_remaining->proc~printtime writevalue writevalue proc~time_remaining->writevalue proc~time_stop->message proc~time_stop->float proc~time_stop->proc~printtime proc~time_stop->writevalue proc~time_report->message proc~printtime->writevalue Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Variables ira nn izero i j k n nsl numi npix npiy ii jj numvoids numdisl numsf numinc dinfo t_interval outputfirst outputlast DF_nums_new numYdisl DF_npix_new DF_npiy_new numstart numstop isg TID NTHR jcnt numCL iCL ind hkl exerg cosom glen exer dgr sl thr arg zmax thick mi ma att xgp DF_gf DF_gd fname sgname voidname dislname sfname outputroot incname dispfile dislYname imname outputformat illumination_mode dispmode fnumber ci czero cone disparray Source Code dispfield Variables Type Attributes Name Initial integer(kind=irg) :: ira integer(kind=irg) :: nn integer(kind=irg) :: izero integer(kind=irg) :: i integer(kind=irg) :: j integer(kind=irg) :: k integer(kind=irg) :: n integer(kind=irg) :: nsl integer(kind=irg) :: numi integer(kind=irg) :: npix integer(kind=irg) :: npiy integer(kind=irg) :: ii integer(kind=irg) :: jj integer(kind=irg) :: numvoids integer(kind=irg) :: numdisl integer(kind=irg) :: numsf integer(kind=irg) :: numinc integer(kind=irg) :: dinfo integer(kind=irg) :: t_interval integer(kind=irg) :: outputfirst integer(kind=irg) :: outputlast integer(kind=irg) :: DF_nums_new integer(kind=irg) :: numYdisl integer(kind=irg) :: DF_npix_new integer(kind=irg) :: DF_npiy_new integer(kind=irg) :: numstart integer(kind=irg) :: numstop integer(kind=irg) :: isg integer(kind=irg) :: TID integer(kind=irg) :: NTHR integer(kind=irg) :: jcnt integer(kind=irg) :: numCL integer(kind=irg) :: iCL real(kind=sgl) :: ind (3) real(kind=sgl) :: hkl (3) real(kind=sgl) :: exerg real(kind=sgl) :: cosom real(kind=sgl) :: glen real(kind=sgl) :: exer real(kind=sgl) :: dgr real(kind=sgl) :: sl real(kind=sgl) :: thr real(kind=sgl) :: arg real(kind=sgl) :: zmax real(kind=sgl) :: thick real(kind=sgl) :: mi real(kind=sgl) :: ma real(kind=sgl) :: att real(kind=sgl) :: xgp real(kind=sgl) :: DF_gf (3) real(kind=sgl) :: DF_gd (3,maxdefects) character(len=50) :: fname character(len=50) :: sgname character(len=50) :: voidname character(len=50) :: dislname (3*maxdefects) character(len=50) :: sfname (maxdefects) character(len=50) :: outputroot character(len=50) :: incname character(len=50) :: dispfile character(len=50) :: dislYname (3*maxdefects) character(len=100) :: imname character(len=4) :: outputformat character(len=4) :: illumination_mode character(len=4) :: dispmode character(len=5) :: fnumber (-10:10) character(len=10) :: ci complex(kind=dbl) :: czero complex(kind=dbl) :: cone real(kind=sgl), allocatable :: disparray (:,:,:,:) Source Code program dispfield ! use local use typedefs use crystalvars use crystal use symmetryvars use symmetry use postscript use constants use diffraction use dynamical use files use io use foilmodule use stacking_fault use dislocation use void use inclusion use defectmodule use TIFF_global use TIFF_f90 use pgm use timing use STEMmodule use YSHModule IMPLICIT NONE integer ( kind = irg ) :: ira , nn , izero , i , j , k , n , nsl , numi , npix , npiy , ii , jj , numvoids , numdisl , numsf , & numinc , dinfo , t_interval , outputfirst , outputlast , DF_nums_new , numYdisl , & DF_npix_new , DF_npiy_new , numstart , numstop , isg , TID , NTHR , jcnt , numCL , iCL !                                  OMP_GET_THREAD_NUM,OMP_GET_NUM_THREADS real ( kind = sgl ) :: ind ( 3 ), hkl ( 3 ), exerg , cosom , glen , exer , dgr , sl , thr , arg , zmax , thick , mi , ma , & att , xgp , DF_gf ( 3 ), DF_gd ( 3 , maxdefects ) character ( 50 ) :: fname , sgname , voidname , dislname ( 3 * maxdefects ), sfname ( maxdefects ), outputroot , & incname , dispfile , dislYname ( 3 * maxdefects ) character ( 100 ) :: imname character ( 4 ) :: outputformat , illumination_mode , dispmode character ( 5 ) :: fnumber ( - 10 : 10 ) character ( len = 10 ) :: ci complex ( kind = dbl ) :: czero , cone real ( kind = sgl ), allocatable :: disparray (:,:,:,:) namelist / rundata / DF_L , DF_npix , DF_npiy , DF_slice , Nmat , sgname , numvoids , incname , & voidname , numdisl , dislname , numYdisl , dislYname , numsf , sfname , dinfo , outputformat , & outputroot , t_interval , illumination_mode , outputfirst , outputlast , dispfile , & dispmode ! display the standard program info progname = 'dispfield.f90' progdesc = 'Defect displacement field simulation program' call EMsoft ! get the crystal data and microscope voltage SG % SYM_reduce = . TRUE . call CrystalData ! read crystal structure hexset = . FALSE . czero = cmplx ( 0.0 , 0.0 , dbl ) cone = cmplx ( 1.0 , 0.0 , dbl ) ! here we read the general simulation information from a namelist file SRdef_rundata.nml ! first we define the default values DF_L = 1.0 ! edge length of column in nanometers DF_npix = 256 ! number of image pixels along x DF_npiy = 256 ! number of image pixels along y DF_slice = 1.0 ! slice thickness in nanometers Nmat = 10000 ! number of precomputed A matrices to be stored dinfo = 0 ! switch to make makedislocation verbose sgname = 'nofile' ! if this variable is different from 'nofile', then an external sg array is read (to be implemented) numdisl = 0 ! number of dislocation files numYdisl = 0 ! number of Yoffe dislocation files numsf = 0 ! number of stacking fault files numinc = 0 ! number of inclusions numvoids = 0 ! number of voids voidname = 'none' ! filename for void data dislname = '' ! filenames for dislocation data dislYname = '' ! filenames for Yoffe dislocation data sfname = '' ! filenames for stacking fault data incname = 'none' ! filename for inclusion data outputformat = 'data' ! format for output data, can be 'data', 'pgm', or 'tiff' outputroot = 'image' ! default root name for output files outputfirst = 1 ! first image number to be written to file (will be set to first image in SR) outputlast = nn ! last image number to be written to file (will be set to last image in SR) t_interval = 10 ! default timing interval (output every t_interval image columns) dispfile = 'none' ! name of the displacement field output file (will be created if different from none) dispmode = 'not' ! should a diplacement file be written ('new') or read ('old') or neither ('not')? illumination_mode = 'EM' ! default illumination mode (can be 'EM' or 'STEM') ! then we read the rundata namelist, which may override some of these defaults OPEN ( UNIT = dataunit , FILE = 'SRdef_rundata.nml' , DELIM = 'APOSTROPHE' ) READ ( UNIT = dataunit , NML = rundata ) CLOSE ( UNIT = dataunit ) ! next, we read the foildata namelist from the SRdef_foildata.nml file ! this includes material property data, in this case the elastic moduli ! in particular, the foilmodule MUST compute the beam direction from ! the sample tilt angles !!! call read_foil_data ( DF_npix , DF_npiy , DF_L ) ! define the foil thickness, attenuation, and number slices per column thick = foil % zb ! this is the same everywhere for this version; needs to be updated in the next version DF_nums = nint ( thick / DF_slice ) ! this is the number of slices for this particular column ! next, deal with all the defects ! ! if there is a diplacement field file entered in the STEM_rundata.nml file, ! then we simply read that file in; otherwise, we read all the defect descriptor files ! is there a void data filename? If so, then read it if ( voidname . ne . 'none' ) call read_void_data ( numvoids , voidname , DF_L , DF_npix , DF_npiy , dinfo ) ! read namelist files for all dislocations, if any if ( numdisl . gt . 0 ) call read_dislocation_data ( dislname , numdisl , numsf , DF_npix , DF_npiy , DF_gf , DF_L , dinfo ) ! read namelist files for all Yoffe dislocations, if any if ( numYdisl . gt . 0 ) call read_YSH_dislocation_data ( dislYname , numYdisl , DF_npix , DF_npiy , DF_gf , DF_L , dinfo ) ! read namelist files for all stacking faults, if any if ( numsf . gt . 0 ) call read_stacking_fault_data ( numsf , numdisl , sfname , DF_L , DF_npix , DF_npiy , DF_g , dinfo ) ! is there an inclusion data file? if so, then read it if ( incname . ne . 'none' ) call read_inclusion_data ( numinc , incname , DF_L , DF_npix , DF_npiy , dinfo ) ! transform the g-vector to the defect reference frames (needed for all dislocations in CalcR). ! this can only be done AFTER all dislocations and stacking faults have been created. do i = 1 , numdisl DF_gd ( 0 : 2 , i ) = matmul ( DL ( i )% a_dc , DF_gc ) end do ! precompute ALL the defect columns and, if needed, store them in dispfile ! this portion should be carried out in multi-threaded mode as much as possible allocate ( disparray ( DF_nums , DF_npix , DF_npiy , 3 )) disparray = 0.0 mess = ' Starting Displacement Field Computation ' ; call Message ( \"(A/)\" ) call CalcRLocal ( numvoids , numdisl , numYdisl , numsf , numinc , DF_nums , DF_npix , DF_npiy , t_interval , disparray ) write ( * , * ) maxval ( disparray ), minval ( disparray ) ! and, if needed, store the defect displacement field for re-runs mess = 'Displacement field data stored in file ' // dispfile ; call Message ( \"(/A/)\" ) open ( unit = dataunit , file = trim ( EMsoft_toNativePath ( dispfile )), status = 'new' , action = 'write' , form = 'unformatted' ) i = 3 write ( dataunit ) DF_nums , DF_npix , DF_npiy , i write ( dataunit ) disparray call SafeCloseFile ( 'd1' , 'keep' , dispfile ,. FALSE .) end program dispfield","tags":"","loc":"program/dispfield.html","title":"dispfield – Fortran Program"},{"text":"Uses: hdf5 h5lt program~~hdftest~~UsesGraph program~hdftest hdftest h5lt h5lt h5lt->program~hdftest hdf5 hdf5 hdf5->program~hdftest Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Calls program~~hdftest~~CallsGraph program~hdftest hdftest h5fclose_f h5fclose_f program~hdftest->h5fclose_f proc~timestamp~2 timestamp program~hdftest->proc~timestamp~2 h5ltmake_dataset_f h5ltmake_dataset_f program~hdftest->h5ltmake_dataset_f h5gclose_f h5gclose_f program~hdftest->h5gclose_f h5gcreate_f h5gcreate_f program~hdftest->h5gcreate_f h5close_emsoft h5close_emsoft program~hdftest->h5close_emsoft h5open_emsoft h5open_emsoft program~hdftest->h5open_emsoft h5ltmake_dataset_string_f h5ltmake_dataset_string_f program~hdftest->h5ltmake_dataset_string_f h5fopen_f h5fopen_f program~hdftest->h5fopen_f h5ltget_dataset_ndims_f h5ltget_dataset_ndims_f program~hdftest->h5ltget_dataset_ndims_f h5ltget_dataset_info_f h5ltget_dataset_info_f program~hdftest->h5ltget_dataset_info_f h5ltread_dataset_f h5ltread_dataset_f program~hdftest->h5ltread_dataset_f h5fcreate_f h5fcreate_f program~hdftest->h5fcreate_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Variables filename fix_filename dsetname aname aname2 aname3 aname4 aname5 aname6 RANK NX NY file_id dset_id dataspace attr_id attr2_id attr3_id attr4_id attr5_id attr6_id aspace_id aspace2_id aspace6_id dtype_id atype_id atype2_id atype3_id atype4_id atype5_id adims adims2 arank attrlen attr_space attr2_space attr_type attr2_type attr3_type attr4_type attr5_type attr6_type num_attrs attr_storage attr_name name_size attr_data aread_data attr_character_data attr_double_data attr_real_data attr_integer_data aread_character_data aread_integer_data aread_null_data aread_double_data aread_real_data fname datapath g1 g2 g3 s error total_error i data_dims npoints rnk type_class type_size grp1_id grp2_id grp3_id buf_dbl1 buf_dbl2 buf_dbl3 buf_flt1 scversion dstring tstring Source Code hdftest Variables Type Attributes Name Initial character(len=5), parameter :: filename = \"atest\" character(len=80) :: fix_filename character(len=9), parameter :: dsetname = \"atestdset\" character(len=11), parameter :: aname = \"attr_string\" character(len=14), parameter :: aname2 = \"attr_character\" character(len=11), parameter :: aname3 = \"attr_double\" character(len=9), parameter :: aname4 = \"attr_real\" character(len=12), parameter :: aname5 = \"attr_integer\" character(len=9), parameter :: aname6 = \"attr_null\" integer, parameter :: RANK = 2 integer, parameter :: NX = 4 integer, parameter :: NY = 5 integer(kind=HID_T) :: file_id integer(kind=HID_T) :: dset_id integer(kind=HID_T) :: dataspace integer(kind=HID_T) :: attr_id integer(kind=HID_T) :: attr2_id integer(kind=HID_T) :: attr3_id integer(kind=HID_T) :: attr4_id integer(kind=HID_T) :: attr5_id integer(kind=HID_T) :: attr6_id integer(kind=HID_T) :: aspace_id integer(kind=HID_T) :: aspace2_id integer(kind=HID_T) :: aspace6_id integer(kind=HID_T) :: dtype_id integer(kind=HID_T) :: atype_id integer(kind=HID_T) :: atype2_id integer(kind=HID_T) :: atype3_id integer(kind=HID_T) :: atype4_id integer(kind=HID_T) :: atype5_id integer(kind=HSIZE_T), DIMENSION(1) :: adims = (/2/) integer(kind=HSIZE_T), DIMENSION(1) :: adims2 = (/1/) integer :: arank = 1 integer(kind=SIZE_T) :: attrlen integer(kind=HID_T) :: attr_space integer(kind=HID_T) :: attr2_space integer(kind=HID_T) :: attr_type integer(kind=HID_T) :: attr2_type integer(kind=HID_T) :: attr3_type integer(kind=HID_T) :: attr4_type integer(kind=HID_T) :: attr5_type integer(kind=HID_T) :: attr6_type integer :: num_attrs integer(kind=HSIZE_T) :: attr_storage character(len=256) :: attr_name integer(kind=SIZE_T) :: name_size = 80 character(len=35), DIMENSION(2) :: attr_data character(len=35), DIMENSION(2) :: aread_data character :: attr_character_data = 'A' double precision, DIMENSION(1) :: attr_double_data = 3.459 real, DIMENSION(1) :: attr_real_data = 4.0 integer, DIMENSION(1) :: attr_integer_data = 5 character :: aread_character_data integer, DIMENSION(1) :: aread_integer_data integer, DIMENSION(1) :: aread_null_data = 7 double precision, DIMENSION(1) :: aread_double_data real, DIMENSION(1) :: aread_real_data character(len=80) :: fname character(len=80) :: datapath character(len=80) :: g1 character(len=80) :: g2 character(len=80) :: g3 character(len=80) :: s integer :: error integer :: total_error integer :: i integer(kind=HSIZE_T), allocatable :: data_dims (:) integer(kind=HSIZE_T) :: npoints integer :: rnk integer :: type_class integer(kind=SIZE_T) :: type_size integer(kind=HID_T) :: grp1_id integer(kind=HID_T) :: grp2_id integer(kind=HID_T) :: grp3_id real(kind=8), allocatable :: buf_dbl1 (:) real(kind=8), allocatable :: buf_dbl2 (:,:) real(kind=8), allocatable :: buf_dbl3 (:,:,:) real(kind=4), allocatable :: buf_flt1 (:) character(len=8) :: scversion character(len=11) :: dstring character(len=15) :: tstring Source Code program hdftest use hdf5 use h5lt IMPLICIT NONE CHARACTER ( LEN = 5 ), PARAMETER :: filename = \"atest\" !File name CHARACTER ( LEN = 80 ) :: fix_filename CHARACTER ( LEN = 9 ), PARAMETER :: dsetname = \"atestdset\" !Dataset name CHARACTER ( LEN = 11 ), PARAMETER :: aname = \"attr_string\" !String Attribute name CHARACTER ( LEN = 14 ), PARAMETER :: aname2 = \"attr_character\" !Character Attribute name CHARACTER ( LEN = 11 ), PARAMETER :: aname3 = \"attr_double\" !DOuble Attribute name CHARACTER ( LEN = 9 ), PARAMETER :: aname4 = \"attr_real\" !Real Attribute name CHARACTER ( LEN = 12 ), PARAMETER :: aname5 = \"attr_integer\" !Integer Attribute name CHARACTER ( LEN = 9 ), PARAMETER :: aname6 = \"attr_null\" !Null Attribute name ! !data space rank and dimensions ! INTEGER , PARAMETER :: RANK = 2 INTEGER , PARAMETER :: NX = 4 INTEGER , PARAMETER :: NY = 5 INTEGER ( HID_T ) :: file_id ! File identifier INTEGER ( HID_T ) :: dset_id ! Dataset identifier INTEGER ( HID_T ) :: dataspace ! Dataspace identifier for dataset INTEGER ( HID_T ) :: attr_id !String Attribute identifier INTEGER ( HID_T ) :: attr2_id !Character Attribute identifier INTEGER ( HID_T ) :: attr3_id !Double Attribute identifier INTEGER ( HID_T ) :: attr4_id !Real Attribute identifier INTEGER ( HID_T ) :: attr5_id !Integer Attribute identifier INTEGER ( HID_T ) :: attr6_id !Null Attribute identifier INTEGER ( HID_T ) :: aspace_id !String Attribute Dataspace identifier INTEGER ( HID_T ) :: aspace2_id !Character Attribute Dataspace identifier INTEGER ( HID_T ) :: aspace6_id !Null Attribute Dataspace identifier INTEGER ( HID_T ) :: dtype_id ! INTEGER ( HID_T ) :: atype_id !String Attribute Datatype identifier INTEGER ( HID_T ) :: atype2_id !Character Attribute Datatype identifier INTEGER ( HID_T ) :: atype3_id !Double Attribute Datatype identifier INTEGER ( HID_T ) :: atype4_id !Real Attribute Datatype identifier INTEGER ( HID_T ) :: atype5_id !Integer Attribute Datatype identifier INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: adims = ( / 2 / ) ! Attribute dimension INTEGER ( HSIZE_T ), DIMENSION ( 1 ) :: adims2 = ( / 1 / ) ! Attribute dimension INTEGER :: arank = 1 ! Attribure rank INTEGER ( SIZE_T ) :: attrlen ! Length of the attribute string INTEGER ( HID_T ) :: attr_space !Returned String Attribute Space identifier INTEGER ( HID_T ) :: attr2_space !Returned other Attribute Space identifier INTEGER ( HID_T ) :: attr_type !Returned Attribute Datatype identifier INTEGER ( HID_T ) :: attr2_type !Returned CHARACTER Attribute Datatype identifier INTEGER ( HID_T ) :: attr3_type !Returned DOUBLE Attribute Datatype identifier INTEGER ( HID_T ) :: attr4_type !Returned REAL Attribute Datatype identifier INTEGER ( HID_T ) :: attr5_type !Returned INTEGER Attribute Datatype identifier INTEGER ( HID_T ) :: attr6_type !Returned NULL Attribute Datatype identifier INTEGER :: num_attrs !number of attributes INTEGER ( HSIZE_T ) :: attr_storage ! attributes storage requirements .MSB. CHARACTER ( LEN = 256 ) :: attr_name !buffer to put attr_name INTEGER ( SIZE_T ) :: name_size = 80 !attribute name length CHARACTER ( LEN = 35 ), DIMENSION ( 2 ) :: attr_data ! String attribute data CHARACTER ( LEN = 35 ), DIMENSION ( 2 ) :: aread_data ! Buffer to put read back ! string attr data CHARACTER :: attr_character_data = 'A' DOUBLE PRECISION , DIMENSION ( 1 ) :: attr_double_data = 3.459 REAL , DIMENSION ( 1 ) :: attr_real_data = 4.0 INTEGER , DIMENSION ( 1 ) :: attr_integer_data = 5 CHARACTER :: aread_character_data ! variable to put read back Character attr data INTEGER , DIMENSION ( 1 ) :: aread_integer_data ! variable to put read back integer attr data INTEGER , DIMENSION ( 1 ) :: aread_null_data = 7 ! variable to put read back null attr data DOUBLE PRECISION , DIMENSION ( 1 ) :: aread_double_data ! variable to put read back double attr data REAL , DIMENSION ( 1 ) :: aread_real_data ! variable to put read back real attr data character ( len = 80 ) :: fname , datapath , g1 , g2 , g3 , s integer :: error , total_error , i ! Error flag INTEGER ( HSIZE_T ), allocatable :: data_dims (:) INTEGER ( HSIZE_T ) :: npoints integer :: rnk , type_class integer ( SIZE_T ) :: type_size integer ( HID_T ) :: grp1_id , grp2_id , grp3_id real ( kind = 8 ), allocatable :: buf_dbl1 (:), buf_dbl2 (:,:), buf_dbl3 (:,:,:) real ( kind = 4 ), allocatable :: buf_flt1 (:) character ( 8 ) :: scversion character ( 11 ) :: dstring character ( 15 ) :: tstring call timestamp ( datestring = dstring , timestring = tstring ) fname = 'Nidata.h5' scversion = '3.x.x' write ( * , * ) 'Date = ' // dstring write ( * , * ) 'Time = ' // tstring ! ! Initialize FORTRAN interface. ! CALL h5open_EMsoft ( error ) write ( * , * ) 'Initialize Fortran interface error   = ' , error write ( * , * ) 'calling h5fopen_f to open file ' // fname CALL h5fopen_f ( fname , H5F_ACC_RDWR_F , file_id , error ) write ( * , * ) 'file_id = ' , file_id write ( * , * ) 'error   = ' , error ! datapath = \"/Scan 1/EBSD/Data/CI\" call h5ltget_dataset_ndims_f ( file_id , datapath , rnk , error ) write ( * , * ) ' data dimensionality = ' , rnk allocate ( data_dims ( rnk )) call h5ltget_dataset_info_f ( file_id , datapath , data_dims , type_class , type_size , error ) write ( * , * ) ' data set info : ' , data_dims ( 1 ), type_class , type_size , error allocate ( buf_flt1 ( data_dims ( 1 ))) call h5ltread_dataset_f ( file_id , datapath , H5T_NATIVE_REAL , buf_flt1 , data_dims , error ) do i = 1 , 10 write ( * , * ) i , buf_flt1 ( i ) end do write ( * , * ) 'calling h5fclose_f to close file ' CALL h5fclose_f ( file_id , error ) write ( * , * ) 'error   = ' , error ! now let's do a test an create a new file with this dataset written to it in a different location fname = 'test.h5' call h5fcreate_f ( fname , H5F_ACC_TRUNC_F , file_id , error ) g1 = 'EMheader' call h5gcreate_f ( file_id , g1 , grp1_id , error ) write ( * , * ) 'open group ' , trim ( g1 ), ' ' , error ! version number /EMheader/Version 'character' call h5ltmake_dataset_string_f ( grp1_id , 'Version' , scversion , error ) ! execution data /EMheader/Date 'character' call h5ltmake_dataset_string_f ( grp1_id , 'Date' , dstring , error ) ! start time /EMheader/StartTime 'character' call h5ltmake_dataset_string_f ( grp1_id , 'StartTime' , tstring , error ) ! stop time /EMheader/StopTime 'character' call h5ltmake_dataset_string_f ( grp1_id , 'StopTime' , tstring , error ) call h5gclose_f ( grp1_id , error ) g1 = 'level1' g2 = 'level2' g3 = 'CI' s = '/' call h5gcreate_f ( file_id , g1 , grp1_id , error ) write ( * , * ) 'open group ' , trim ( g1 ), ' ' , error call h5gcreate_f ( grp1_id , g2 , grp2_id , error ) write ( * , * ) 'open group ' , trim ( g2 ), ' ' , error datapath = trim ( s ) // trim ( g1 ) // trim ( s ) // trim ( g2 ) // trim ( s ) // trim ( g3 ) write ( * , * ) 'datapath = ' , datapath call h5ltmake_dataset_f ( file_id , datapath , rnk , data_dims , H5T_NATIVE_REAL , buf_flt1 , error ) call h5gclose_f ( grp2_id , error ) call h5gclose_f ( grp1_id , error ) call h5fclose_f ( file_id , error ) ! ! Close FORTRAN interface. ! CALL h5close_EMsoft ( error ) write ( * , * ) 'close fortran interface error   = ' , error end program hdftest","tags":"","loc":"program/hdftest.html","title":"hdftest – Fortran Program"}]}